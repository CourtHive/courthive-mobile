'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function factoryVersion() {
    return '2.0.0-beta.6';
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function numericSort(a, b) {
    return (a !== null && a !== void 0 ? a : 0) - (b !== null && b !== void 0 ? b : 0);
}

function ensureInt(val) {
    if (typeof val === 'number')
        return parseInt(val.toString());
    return parseInt(val);
}

function isPowerOf2(n) {
    if (isNaN(n))
        return false;
    return n && (n & (n - 1)) === 0;
}
function median(arr) {
    if (!arr.length)
        return undefined;
    var s = __spreadArray([], __read(arr), false).sort(numericSort);
    var mid = Math.floor(s.length / 2);
    return s.length % 2 ? s[mid] : (s[mid - 1] + s[mid]) / 2;
}
function deriveExponent(n) {
    if (!isPowerOf2(n))
        return false;
    var m = n;
    var i = 1;
    while (m !== 2) {
        i += 1;
        m = m / 2;
    }
    return i;
}
function coerceEven(n) {
    return isNaN(n) ? 0 : (n % 2 && n + 1) || n;
}
function nearestPowerOf2(val) {
    return Math.pow(2, Math.round(Math.log(val) / Math.log(2)));
}
function isNumeric(value) {
    return !isNaN(parseFloat(value));
}
function isOdd(num) {
    var numInt = ensureInt(num);
    if (isNaN(numInt))
        return undefined;
    if (numInt === 0)
        return false;
    return (numInt & -numInt) === 1;
}
function nextPowerOf2(n) {
    if (isNaN(n))
        return false;
    while (!isPowerOf2(n)) {
        n++;
    }
    return n;
}
function randomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
// does accept e.e. '1.0'
function isConvertableInteger(n) {
    return Number.isSafeInteger(typeof n === 'string' ? +n : n);
}
// produces an approximated normal distribution between 0 and max
function weightedRandom(max, weight, round) {
    if (max === void 0) { max = 1; }
    if (weight === void 0) { weight = 3; }
    if (round === void 0) { round = true; }
    var num = 0;
    for (var i = 0; i < weight; i++) {
        num += Math.random() * (max / weight);
    }
    return round && max > 1 ? Math.round(num) : num;
}
// round to nearest step, e.g. 0.25
function stepRound(value, step) {
    step || (step = 1.0);
    var inv = 1.0 / step;
    return Math.round(value * inv) / inv;
}
function skewedDistribution(min, max, skew, step, significantDecimals) {
    if (significantDecimals === void 0) { significantDecimals = 2; }
    var u = 1 - Math.random();
    var v = 1 - Math.random();
    var num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    num = num / 10.0 + 0.5;
    if (num > 1 || num < 0) {
        num = skewedDistribution(min, max, skew);
    }
    else {
        num = Math.pow(num, skew);
        num *= max - min;
        num += min;
    }
    if (step)
        num = stepRound(num, step);
    return parseFloat(num.toFixed(significantDecimals));
}

// returns only unique values within an array
function unique(arr) {
    return arr === null || arr === void 0 ? void 0 : arr.filter(function (item, i, s) { return s.lastIndexOf(item) === i; });
}
function noNulls(arr) {
    return arr === null || arr === void 0 ? void 0 : arr.map(function (item) { return (item === null ? undefined : item); });
}
function shuffleArray(arr) {
    return arr
        .map(function (a) { return [Math.random(), a]; })
        .sort(function (a, b) { return a[0] - b[0]; })
        .map(function (a) { return a[1]; });
}
function numericSortValue(v) {
    return isConvertableInteger(v) ? v : Infinity;
}
// return an object whose attributes are values and whose values are counts for values
// e.g. values=[1,2,2,3,4,4,5] produces { 1: 1, 2: 2, 3: 1, 4: 2, 5: 1}
function instanceCount(values) {
    return values.reduce(function (a, c) {
        if (!a[c])
            a[c] = 0;
        a[c]++;
        return a;
    }, {});
}
// return an object whose attributes are value counts and values are arrays of values for each count
// e.g. values=[1,2,2,3,4,4,5] produces { 1: ["1", "3", "5"], 2: ["2", "4"] }
function countValues(values) {
    return groupValues(instanceCount(values));
}
// group the values of an object by attributes(keys) which produce those values
// e.g. obj = { 1: 1, 2: 2, 3: 1, 4: 2, 5: 1} produces { 1: ["1", "3", "5"], 2: ["2", "4"] }
function groupValues(obj) {
    return Object.keys(obj).reduce(function (p, c) {
        var value = obj[c];
        if (p[value]) {
            p[value].push(c);
        }
        else {
            p[value] = [c];
        }
        return p;
    }, {});
}
function onlyUnique(value, index, self) {
    return self.indexOf(value) === index;
}
function uniqueValues(arr) {
    return arr.filter(onlyUnique);
}
function randomPop(array) {
    return Array.isArray(array) && array.length
        ? array.splice(Math.floor(Math.random() * array.length), 1)[0]
        : undefined;
}
function randomMember(arr) {
    var index = Math.floor(Math.random() * arr.length);
    return arr[index];
}
function generateRange(start, end) {
    return Array.from({ length: end - start }, function (_, k) { return k + start; });
}
function arrayIndices(val, arr) {
    return arr.reduce(function (a, e, i) {
        if (e === val)
            a.push(i);
        return a;
    }, []);
}
function intersection(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b))
        return [];
    return a
        .filter(function (n) { return b.indexOf(n) !== -1; })
        .filter(function (e, i, c) { return c.indexOf(e) === i; });
}
function difference(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b))
        return [];
    return a.filter(function (x) { return !b.includes(x); });
}
function overlap(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b))
        return false;
    return a.some(function (e) { return b.includes(e); });
}
function occurrences(val, arr) {
    return (arr.reduce(function (r, val) {
        r[val] = 1 + r[val] || 1;
        return r;
    }, {})[val] || 0);
}
function subSort(arr, i, n, sortFx) {
    return [].concat.apply([], __spreadArray(__spreadArray(__spreadArray([], __read(arr.slice(0, i)), false), __read(arr.slice(i, i + n).sort(sortFx)), false), __read(arr.slice(i + n, arr.length)), false));
}
function chunkArray(arr, chunksize) {
    return arr.reduce(function (all, one, i) {
        var ch = Math.floor(i / chunksize);
        all[ch] = [].concat(all[ch] || [], one);
        return all;
    }, []);
}
// will break an array of items into chunks following pattern [size1, size2, ...]
function chunkSizeProfile(arr, _a) {
    var _b = __read(_a), size = _b[0], otherSizes = _b.slice(1);
    return arr.length
        ? __spreadArray([
            arr.slice(0, size)
        ], __read(chunkSizeProfile(arr.slice(size), __spreadArray(__spreadArray([], __read(otherSizes), false), [size], false))), false) : [];
}
function groupConsecutiveNumbers(arr) {
    return arr.reduce(function (result, num) {
        var finalGroup = result[result.length - 1];
        if (!finalGroup || finalGroup[finalGroup.length - 1] !== num - 1) {
            result.push([]);
        }
        result[result.length - 1].push(num);
        return result;
    }, []);
}
function allNumeric$1(arr) {
    return arr.reduce(function (numeric, item) { return !isNaN(parseInt(item)) && numeric; }, true);
}
function noNumeric(arr) {
    return arr.reduce(function (numeric, item) { return isNaN(parseInt(item)) && numeric; }, true);
}
/**
 * chunk an arbitrary array of elements by adding every Nth instance to chunksCount chunks
 *
 * e.g. given arr=[1,2,3,4,5,6,7,8,9,10,11,12]:
 *
 * chunkByNth(arr, 3)
 * [1, 4, 7, 10]
 * [2, 5, 8, 11]
 * [3, 6, 9, 12]
 * chunkByNth(arr, 4)
 * [1, 5, 9]
 * [2, 6, 10]
 * [3, 7, 11]
 * [4, 8, 12]
 *
 * When shuttle = true:
 * chunkByNth(arr, 3, true)
 * [1, 6, 7, 12]
 * [2, 5, 8, 11]
 * [3, 4, 9, 10]
 * chunkByNth(arr, 4, true)
 * [1, 8, 9]
 * [2, 7, 10]
 * [3, 6, 11]
 * [4, 5, 12]
 *
 * @param {any[]} arr - an array
 * @param {number} chunksCount - number of chunks to create
 * @param {boolean} shuttle - whether or not to "shuttle" as in the movment of a shuttle in a loom
 */
function chunkByNth(arr, chunksCount, shuttle) {
    return arr.reduce(function (chunks, entry, index) {
        var reverseDirection = shuttle
            ? !!(Math.floor(index / chunksCount) % 2)
            : false;
        var chunkIndex = index % chunksCount;
        var directionIndex = reverseDirection
            ? chunksCount - 1 - chunkIndex
            : chunkIndex;
        if (!chunks[directionIndex])
            chunks[directionIndex] = [];
        chunks[directionIndex].push(entry);
        return chunks;
    }, []);
}
function getMissingSequenceNumbers(arr, start) {
    if (start === void 0) { start = 1; }
    if (!Array.isArray(arr) || !arr.every(isConvertableInteger))
        return [];
    var min = Math.min.apply(Math, __spreadArray(__spreadArray([], __read(arr), false), [start], false));
    var max = Math.max.apply(Math, __spreadArray([], __read(arr), false));
    return generateRange(min, max + 1).filter(function (n) { return !arr.includes(n); });
}

var SUCCESS = { success: true };
var ERROR$1 = 'error';
var resultConstants = {
    SUCCESS: SUCCESS,
    ERROR: ERROR$1,
};

var ANACHRONISM = {
    message: 'Chronological error; time violation.',
    code: 'ANACHRONISM',
};
var CANNOT_REMOVE_MAIN_STRUCTURE = {
    message: 'Cannot remove main structure',
    code: 'ERR_CANNOT_REMOVE_MAIN_STRUCTURE',
};
var INVALID_RECORDS = {
    message: 'records must be an object with tournamentId keys',
    code: 'ERR_INVALID_TOURNAMENTS',
};
var MISSING_TOURNAMENT_RECORDS = {
    message: 'Missing tournamentRecords',
    code: 'ERR_MISSING_TOURNAMENTS',
};
var MISSING_TOURNAMENT_RECORD = {
    message: 'Missing tournamentRecord',
    code: 'ERR_MISSING_TOURNAMENT',
};
var INVALID_TOURNAMENT_RECORD = {
    message: 'Invalid tournamentRecord',
    code: 'ERR_INVALID_TOURNAMENT',
};
var MISSING_TOURNAMENT_ID = {
    message: 'Missing tournamentId',
    code: 'ERR_MISSING_TOURNAMENT_ID',
};
var INVALID_DRAW_DEFINITION = {
    message: 'Invalid drawDefinition',
    code: 'ERR_INVALID_DRAWDEF',
};
var MISSING_DRAW_DEFINITION = {
    message: 'Missing drawDefinition',
    code: 'ERR_MISSING_DRAWDEF',
};
var EXISTING_DRAW_DEFINITIONS = {
    message: 'Existing drawDefinition(s)',
    code: 'ERR_EXISTING_DRAWDEFS',
};
var DRAW_DEFINITION_NOT_FOUND = {
    message: 'drawDefinition not found',
    code: 'ERR_NOT_FOUND_DRAWDEF',
};
var INVALID_STRUCTURE = {
    message: 'Invalid structure',
    code: 'ERR_INVALID_STRUCTURE',
};
var INCOMPLETE_SOURCE_STRUCTURE = {
    message: 'Incomplete source structure',
    code: 'ERR_INCOMPLETE_STRUCTURE',
};
var INVALID_DRAW_POSITION_FOR_SEEDING = {
    message: 'Invalid drawPosition for seedAssignment',
    code: 'ERR_INVALID_SEEDING_POSITION',
};
var DRAW_POSITION_ASSIGNED = {
    message: 'drawPosition already assigned',
    code: 'ERR_EXISTING_POSITION_ASSIGNMENT',
};
var SCHEDULE_NOT_CLEARED = {
    message: 'Schedule not cleared',
    code: 'ERR_UNCHANGED_SCHEDULE_NOT_CLEARED',
};
var DRAW_POSITION_NOT_CLEARED = {
    message: 'drawPosition not cleared',
    code: 'ERR_FAILURE_POSITION_NOT_CLEARED',
};
var DRAW_POSITION_NOT_FOUND = {
    message: 'drawPosition not found',
    code: 'ERR_NOT_FOUND_DRAW_POSITION',
};
var UNRECOGNIZED_DRAW_TYPE = {
    message: 'Unrecognized drawType',
    code: 'ERR_UNRECOGNIZED_DRAW_TYPE',
};
var MISSING_DRAW_POSITIONS = {
    message: 'Missing drawPositions',
    code: 'ERR_MISSING_DRAW_POSITIONS',
};
var DRAW_POSITION_ACTIVE = {
    message: 'drawPosition is active',
    code: 'ERR_ACTIVE_DRAW_POSITION',
};
var INVALID_DRAW_POSITION = {
    message: 'Invlid drawPosition',
    code: 'ERR_INVALID_DRAW_POSITION',
};
var MISSING_DRAW_POSITION = {
    message: 'Missing drawPosition',
    code: 'ERR_MISSING_DRAW_POSITION',
};
var INVALID_DRAW_TYPE = {
    message: 'Invalid drawType',
    code: 'ERR_INVALID_DRAW_TYPE',
};
var INVALID_DRAW_SIZE = {
    message: 'Invalid drawSize',
    code: 'ERR_INVALID_DRAW_SIZE',
};
var DRAW_SIZE_MISMATCH = {
    message: 'Cannot set drawSize to be less than existing entries',
    code: 'ERR_INVALID_DRAW_SIZE_MISMATCH',
};
var MISSING_DRAW_SIZE = {
    message: 'Missing drawSize',
    code: 'ERR_MISSING_DRAW_SIZE',
};
var MISSING_DRAW_ID = {
    message: 'Missing drawId',
    code: 'ERR_MISSING_DRAW_ID',
};
var DRAW_ID_EXISTS = {
    message: 'drawId exists',
    code: 'ERR_EXISTING_DRAW_ID',
};
var INVALID_PARTICIPANT_SEEDING = {
    message: 'participantId cannot be assigned to multiple seedNumbers',
    code: 'INVALID_PARTICIPANT_SEEDING',
};
var SEEDSCOUNT_GREATER_THAN_DRAW_SIZE = {
    message: 'seedsCount greater than drawSize',
    code: 'ERR_INVALID_SEED_COUNT',
};
var MISSING_SEEDCOUNT_THRESHOLDS = {
    message: 'Missing seedCountThresholds',
    code: 'ERR_MISSING_SEED_COUNT_THRESHOLD',
};
var INVALID_ACTION = {
    message: 'Invalid action',
    code: 'ERR_INVALID_ACTION',
};
var INVALID_ASSIGNMENT = {
    message: 'Invalid assignment',
    code: 'ERR_INVALID_ASSIGNMENT',
};
var MISSING_SEED_ASSIGNMENTS = {
    message: 'Missing seedAssignments',
    code: 'ERR_MISSING_SEED_ASSIGNMENTS',
};
var INVALID_SEED_NUMBER = {
    message: 'Invalid seedNumber',
    code: 'ERR_INVALID_SEED_NUMBER',
};
var INVALID_SEED_POSITION = {
    message: 'Invalid seedPosition',
    code: 'ERR_INVALID_SEED_POSITION',
};
var MISSING_TARGET_LINK = {
    message: 'Missing targetLink',
    code: 'ERR_MISSING_LINK_TARGET',
};
var EXISTING_ROUND = {
    message: 'Existing round',
    code: 'ERR_EXISTING_ROUND',
};
var MISSING_ROUND_NUMBER = {
    message: 'Missing roundNumber',
    code: 'ERR_MISSING_ROUND_NUMBER',
};
var MISSING_STRUCTURE_ID = {
    message: 'Missing structureId',
    code: 'ERR_MISSING_STRUCTURE_ID',
};
var STRUCTURE_NOT_FOUND = {
    message: 'structure not found',
    code: 'ERR_NOT_FOUND_STRUCTURE',
};
var MISSING_STRUCTURES = {
    message: 'Missing structures',
    code: 'ERR_MISSING_STRUCTURES',
};
var MISSING_STRUCTURE = {
    message: 'Missing structure',
    code: 'ERR_MISSING_STRUCTURE',
};
var UNLINKED_STRUCTURES = {
    message: 'drawDefinition contains unlinked structures',
    code: 'ERR_MISSING_STRUCTURE_LINKS',
};
var INVALID_EVENT_TYPE = {
    message: 'Invalid eventType',
    code: 'ERR_INVALID_EVENT_TYPE',
};
var MISSING_EVENT = {
    message: 'Missing event / eventId',
    code: 'ERR_MISSING_EVENT_ID',
};
var EVENT_NOT_FOUND = {
    message: 'Event not found',
    code: 'ERR_NOT_FOUND_EVENT',
};
var EVENT_EXISTS = {
    message: 'Event exists',
    code: 'ERR_EXISTING_EVENT',
};
var MISSING_ENTRIES = {
    message: 'Missing entries',
    code: 'ERR_MISSING_ENTRIES',
};
var INVALID_ENTRIES = {
    message: 'Invalid entries',
    code: 'ERR_INVALID_ENTRIES',
};
var MISSING_ASSIGNMENTS = {
    message: 'Missing assignments',
    code: 'ERR_MISSING_ASSIGNMENTS',
};
var MISSING_STAGE = {
    message: 'Missing stage',
    code: 'ERR_MISSING_STAGE',
};
var INVALID_STAGE = {
    message: 'Invalid stage',
    code: 'ERR_INVALID_STAGE',
};
var STAGE_SEQUENCE_LIMIT = {
    message: 'stageSequence limit',
    code: 'ERR_LIMIT_STAGE_SEQUENCE',
};
var MISSING_POSITION_ASSIGNMENTS = {
    message: 'Missing positionAssignments',
    code: 'ERR_MISSING_POSITION_ASSIGNMENTS',
};
var INVALID_MATCHUP_STATUS_BYE = {
    message: 'Cannot Assign BYE status if no assignment: { bye: true }',
    code: 'ERR_UNCHANGED_CANNOT_ASSIGN_BYE',
};
var UNRECOGNIZED_MATCHUP_STATUS = {
    message: 'Unrecognized matchUpStatus',
    code: 'ERR_UNRECOGNIZED_MATCHUP_STATUS',
};
var UNRECOGNIZED_MATCHUP_FORMAT = {
    message: 'Unrecognized matchUpFormat',
    code: 'ERR_UNRECOGNIZED_MATCHUP_FORMAT',
};
var INCOMPATIBLE_MATCHUP_STATUS = {
    message: 'Incompatible matchUpStatus',
    code: 'ERR_INCOMPATIBLE_MATCHUP_STATUS',
};
var INVALID_MATCHUP_STATUS = {
    message: 'Invalid matchUpStatus',
    code: 'ERR_INVALID_MATCHUP_STATUS',
};
var INVALID_TIE_FORMAT = {
    message: 'Invalid tieFormat',
    code: 'ERR_INVALID_TIE_FORMAT',
};
var INVALID_MATCHUP_FORMAT = {
    message: 'Invalid matchUpFormat',
    code: 'ERR_INVALID_MATCHUP_FORMAT',
};
var MISSING_MATCHUP_FORMAT = {
    message: 'Missing matchUpFormat',
    code: 'ERR_MISSING_MATCHUP_FORMAT',
};
var MISSING_COLLECTION_DEFINITION = {
    message: 'Missing collectionDefinition',
    code: 'ERR_MISSING_COLLECTION_DEFINITION',
};
var MISSING_TIE_FORMAT = {
    message: 'Missing tieFormat',
    code: 'ERR_MISSING_TIE_FORMAT',
};
var MISSING_MATCHUP_ID = {
    message: 'Missing matchUpId',
    code: 'ERR_MISSING_MATCHUP_ID',
};
var MISSING_MATCHUP_IDS = {
    message: 'Missing matchUpIds',
    code: 'ERR_MISSING_MATCHUP_IDS',
};
var MATCHUP_NOT_FOUND = {
    message: 'matchUp not found',
    code: 'ERR_NOT_FOUND_MATCHUP',
};
var MISSING_MATCHUPS = {
    message: 'Missing matchUps',
    code: 'ERR_MISSING_MATCHUPS',
};
var MISSING_MATCHUP = {
    message: 'Missing matchUp',
    code: 'ERR_MISSING_MATCHUP',
};
var INVALID_MATCHUP = {
    message: 'Invalid matchUp',
    code: 'ERR_INVALID_MATCHUP',
};
var MISSING_POLICY_TYPE = {
    message: 'Missing policyType',
    code: 'ERR_MISSING_POLICY_TYPE',
};
var MISSING_POLICY_DEFINITION = {
    message: 'Missing policyDefinitions',
    code: 'ERR_MISSING_POLICY_DEFINITIONS',
};
var MISSING_SEEDING_POLICY = {
    message: 'Missing seeding policy',
    code: 'ERR_MISSING_POLICY_SEEDING',
};
var MISSING_AVOIDANCE_POLICY = {
    message: 'Missing avoidance policy',
    code: 'ERR_MISSING_POLICY_AVOIDANCE',
};
var MISSING_POLICY_ATTRIBUTES = {
    message: 'Missing policy attributes',
    code: 'ERR_MISSING_POLICY_ATTRIBUTES',
};
var INVALID_POLICY_DEFINITION = {
    message: 'Invalid policyDefinitions',
    code: 'ERR_INVALID_POLICY_DEFINITIONS',
};
var EXISTING_POLICY_TYPE = {
    message: 'existing policyType',
    code: 'ERR_EXISTING_POLICY_TYPE',
};
var POLICY_NOT_ATTACHED = {
    message: 'Policy not attached',
    code: 'ERR_FAILURE_POLICY_NOT_ATTACHED',
};
var POLICY_NOT_FOUND = {
    message: 'Policy not found',
    code: 'ERR_NOT_FOUND_POLICY',
};
var MISSING_SCORING_POLICY = {
    message: 'Missing scoring policy / matchUpFormats',
    code: 'ERR_MISSING_POLICY_SCORING_MATCHUP_FORMATS',
};
var INVALID_SIDE_NUMBER = {
    message: 'Invalid sideNumber',
    code: 'ERR_INVALID_SIDE_NUMBER',
};
var INVALID_SET_NUMBER = {
    message: 'Invalid setNumber',
    code: 'ERR_INVALID_SET_NUMBER',
};
var MISSING_SET_OBJECT = {
    message: 'Missing setObject',
    code: 'ERR_MISSING_SET_ATTRIBUTE',
};
var MISSING_SET_NUMBER = {
    message: 'Missing setNumber',
    code: 'ERR_MISSING_SET_NUMBER',
};
var MISSING_SIDE_NUMBER = {
    message: 'Missing sideNumber',
    code: 'ERR_MISSING_SIDE_NUMBER',
};
var MISSING_COURT_ID = {
    message: 'Missing courtId',
    code: 'ERR_MISSING_COURT_ID',
};
var MISSING_VALUE = {
    message: 'Missing value',
    code: 'ERR_MISSING_VALUE',
};
var MISSING_DATE = {
    message: 'Missing date',
    code: 'ERR_MISSING_DATE',
};
var NO_VALID_DATES = {
    message: 'No valid dates',
    code: 'ERR_NO_VALID_DATES',
};
var INVALID_BOOKINGS = {
    message: 'Invalid bookings',
    code: 'ERR_INVALID_BOOKINGS',
};
var INVALID_DATE_AVAILABILITY = {
    message: 'Invalid dateAvailability',
    code: 'ERR_INVALID_DATE_AVAILABILITY',
};
var MISSING_DATE_AVAILABILITY = {
    message: 'Missing dateAvailability',
    code: 'ERR_MISSING_DATE_AVAILABILITY',
};
// Javascript constant for Date() function
var INVALID_DATE = {
    message: 'Invalid Date',
    code: 'ERR_INVALID_DATE',
};
var INVALID_TIME = {
    message: 'Invalid time',
    code: 'ERR_INVALID_TIME',
};
var INVALID_TOURNAMENT_DATES = {
    message: 'Invalid tournament dates',
    code: 'ERR_INVALID_DATES_TOURNAMENT',
};
var INVALID_GAME_SCORES = {
    message: 'Invalid game scores',
    code: 'ERR_INVALID_SCORES_GAME',
};
var INVALID_SCORE = {
    message: 'Invalid score',
    code: 'ERR_INVALID_SCORE',
};
var INVALID_WINNING_SIDE = {
    message: 'Invalid winningSide',
    code: 'ERR_INVALID_WINNING_SIDE',
};
var NO_PARTICIPANTS_GENERATED = {
    message: 'No participants generated',
    code: 'ERR_NO_PARTICIPANTS_GENERATED',
};
var CANNOT_MODIFY_TIEFORMAT = {
    message: 'Cannot modify tieFormat',
    code: 'ERR_UNCHANGED_CANNOT_MODIFY_TIEFORMAT',
};
var CANNOT_MODIFY_PARTICIPANT_TYPE = {
    message: 'Cannot modify participantType',
    code: 'ERR_UNCHANGED_CANNOT_MODIFY_PARTICIPANT_TYPE',
};
var CANNOT_REMOVE_PARTICIPANTS = {
    message: 'Cannot remove participants',
    code: 'ERR_UNCHANGED_CANNOT_REMOVE_PARTICIPANTS',
};
var CANNOT_CHANGE_WINNING_SIDE = {
    message: 'Cannot change winningSide',
    code: 'ERR_UNCHANGED_CANNOT_CHANGE_WINNING_SIDE',
};
var INVALID_PARTICIPANT = {
    message: 'Invalid participant',
    code: 'ERR_INVALID_PARTICIPANT',
};
var INVALID_PARTICIPANT_ID = {
    message: 'Invalid participantId',
    code: 'ERR_INVALID_PARTICIPANT_ID',
};
var INVALID_PARTICIPANT_IDS = {
    message: 'Invalid participantIds',
    code: 'ERR_INVALID_PARTICIPANT_IDS',
};
var INVALID_PARTICIPANT_ROLE = {
    message: 'Invalid participantRole',
    code: 'ERR_INVALID_PARTICIPANT_ROLE',
};
var INVALID_PARTICIPANT_TYPE = {
    message: 'Invalid participantType',
    code: 'ERR_INVALID_PARTICIPANT_TYPE',
};
var MISSING_PARTICIPANT_ROLE = {
    message: 'Missing participantRole',
    code: 'ERR_MISSING_PARTICIPANT_ROLE',
};
var MISSING_PARTICIPANT = {
    message: 'Missing participant',
    code: 'ERR_MISSING_PARTICIPANT',
};
var MISSING_PARTICIPANTS = {
    message: 'Missing participants',
    code: 'ERR_MISSING_PARTICIPANTS',
};
var MISSING_PARTICIPANT_ID = {
    message: 'Missing participantId',
    code: 'ERR_MISSING_PARTICIPANT_ID',
};
var PARTICIPANT_NOT_FOUND = {
    message: 'Participant Not Found',
    code: 'ERR_NOT_FOUND_PARTICIPANT',
};
var PARTICIPANT_ID_EXISTS = {
    message: 'participantId exists',
    code: 'ERR_EXISTING_PARTICIPANT_ID',
};
var PARTICIPANT_PAIR_EXISTS = {
    message: 'participant pair exists',
    code: 'ERR_EXISTING_PARTICIPANT_PAIR',
};
var NO_PARTICIPANT_REMOVED = {
    message: 'No participant removed',
    code: 'ERR_UNCHANGED_NO_PARTICIPANT_REMOVED',
};
var MISSING_PARTICIPANT_IDS = {
    message: 'Missing participantIds',
    code: 'ERR_MISSING_PARTICIPANT_IDS',
};
var MISSING_PARTICIPANT_COUNT = {
    message: 'Missing participantsCount',
    code: 'ERR_MISSING_PARTICIPANT_COUNT',
};
var PARTICIPANT_NOT_CHECKED_IN = {
    message: 'Participant not checked in',
    code: 'ERR_UNCHANGED_PARTICIPANT_NOT_CHECKED_IN',
};
var MISSING_PERSON_DETAILS = {
    message: 'Missing person details',
    code: 'ERR_MISSING_PERSON_DETAILS',
};
var EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT = {
    message: 'Existing participant drawPosition assignment',
    code: 'ERR_EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT',
};
var EXISTING_PARTICIPANT = {
    message: 'Existing participant',
    code: 'ERR_EXISTING_PARTICIPANT',
};
var PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE = {
    message: 'participantsCount exceeds drawSize',
    code: 'ERR_INVALID_PARTICIPANT_COUNT',
};
var INVALID_ENTRY_STATUS = {
    message: 'Invalid entry status',
    code: 'ERR_INVALID_ENTRY_STATUS',
};
var PARTICIPANT_ENTRY_NOT_FOUND = {
    message: 'Participant Entry Not Found',
    code: 'ERR_NOT_FOUND_PARTICIPANT_ENTRY',
};
var PARTICIPANT_NOT_ENTERED_IN_STAGE = {
    message: 'Participant not entered in stage',
    code: 'ERR_UNCHANGED_PARTICIPANT_NOT_ENTERED',
};
var PARTICIPANT_NOT_FOUND_IN_STAGE = {
    message: 'Participant not found in stageSequence',
    code: 'ERR_NOT_FOUND_PARTICIPANT_IN_STAGE',
};
var ENTRY_STATUS_NOT_ALLOWED_IN_STAGE = {
    message: 'entryStatus not allowed in stage',
    code: 'ERR_INVALID_ENTRY_STATUS_IN_STAGE',
};
var ENTRY_STATUS_NOT_ALLOWED_FOR_EVENT = {
    message: 'entryStatus not allowed for event',
    code: 'ERR_INVALID_ENTRY_STATUS_IN_EVENT',
};
var NO_STAGE_SPACE_AVAILABLE_FOR_ENTRY_STATUS = {
    message: 'No stage space available for entryStatus',
    code: 'ERR_UNCHANGED_NO_AVAILABLE_STAGE_SPACE',
};
var NO_DRAW_POSITIONS_AVAILABLE_FOR_QUALIFIERS = {
    message: 'Insufficient drawPositions to accommodate qualifiers',
    code: 'ERR_UNCHANGED_NO_DRAW_POSITIONS_FOR_QUALIFIERS',
};
var INSUFFICIENT_DRAW_POSITIONS = {
    message: 'Insufficient drawPositions to accommodate entries',
    code: 'ERR_INSUFFICIENT_DRAW_POSITIONS',
};
var MISSING_PENALTY_TYPE = {
    message: 'Missing penaltyType',
    code: 'ERR_MISSING_PENALTY_TYPE',
};
var MISSING_PENALTY_ID = {
    message: 'Missing penaltyId',
    code: 'ERR_MISSING_PENALTY_ID',
};
var PENALTY_NOT_FOUND = {
    message: 'Penalty not found',
    code: 'ERR_NOT_FOUND_PENALTY',
};
var MISSING_COURTS_INFO = {
    message: 'Missing courtsCount/courtNames',
    code: 'ERR_MISSING_COURTS_INFO',
};
var COURT_NOT_FOUND = {
    message: 'Court not found',
    code: 'ERR_NOT_FOUND_COURT',
};
var COURT_EXISTS = {
    message: 'Court exists',
    code: 'ERR_EXISTING_COURT',
};
var VENUE_EXISTS = {
    message: 'Venue exists',
    code: 'ERR_EXISTING_VENUE',
};
var VENUE_NOT_FOUND = {
    message: 'Venue not found',
    code: 'ERR_NOT_FOUND_VENUE',
};
var MISSING_VENUE_ID = {
    message: 'Missing venueId',
    code: 'ERR_MISSING_VENUE_ID',
};
var INVALID_END_TIME = {
    message: 'Invalid endTime',
    code: 'ERR_INVALID_END_TIME',
};
var EXISTING_END_TIME = {
    message: 'Existing endTime',
    code: 'ERR_EXISTING_END_TIME',
};
var INVALID_STOP_TIME = {
    message: 'Invalid stopTime',
    code: 'ERR_INVALID_STOP_TIME',
};
var INVALID_START_TIME = {
    message: 'Invalid startTime',
    code: 'ERR_INVALID_START_TIME',
};
var INVALID_RESUME_TIME = {
    message: 'Invalid resumeTime',
    code: 'ERR_INVALID_RESUME_TIME',
};
var INVALID_TIME_ITEM = {
    message: 'Invalid timeItem',
    code: 'ERR_INVALID_TIME_ITEMS',
};
var MISSING_ASYNC_STATE_PROVIDER = {
    message: 'Missing async state provider',
    code: 'ERR_MISSING_ASYNC_STATE_PROVIDER',
};
var MISSING_TIME_ITEM = {
    message: 'Missing timeItem',
    code: 'ERR_MISSING_TIME_ITEM',
};
var MISSING_TIME_ITEMS = {
    message: 'Missing timeItems',
    code: 'ERR_MISSING_TIME_ITEMS',
};
var MISSING_CONTEXT = {
    message: 'Missing context',
    code: 'ERR_MISSING_CONTEXT',
};
var MISSING_SCHEDULE = {
    message: 'Missing schedule',
    code: 'ERR_MISSING_SCHEDULE',
};
var INVALID_SCALE_ITEM = {
    message: 'Invalid scaleItem',
    code: 'ERR_INVALID_SCALE_ITEM',
};
var MODIFICATIONS_FAILED = {
    message: 'Modifications failed',
    code: 'ERR_FAILURE_MODIFICATIONS',
};
var NO_MODIFICATIONS_APPLIED = {
    message: 'No modifications applied',
    code: 'ERR_UNCHANGED_NO_MODIFICATIONS_APPLIED',
};
var UNABLE_TO_ASSIGN_COURT = {
    message: 'Unable to assign court',
    code: 'ERR_UNCHANGED_COURT_NOT_ASSIGNED',
};
var NO_CANDIDATES = {
    message: 'No Candidates',
    code: 'ERR_UNCHANGED_NO_CANDIDATES',
};
var INVALID_CONFIGURATION = {
    message: 'Invalid configuration',
    code: 'ERR_INVALID_CONFIG',
};
var INVALID_COLLECTION_DEFINITION = {
    message: 'Invalid collectionDefinition',
    code: 'ERR_INVALID_COLLECTION_DEFINITION',
};
var INVALID_OBJECT = {
    message: 'Invalid object',
    code: 'ERR_INVALID_OBJECT',
};
var INVALID_GENDER = {
    message: 'Invalid gender',
    code: 'ERR_INVALID_GENDER',
};
var INVALID_CATEGORY = {
    message: 'Invalid category',
    code: 'ERR_INVALID_CATEGORY',
};
var INVALID_VALUES = {
    message: 'Invalid values',
    code: 'ERR_INVALID_VALUES',
};
var DUPLICATE_VALUE = {
    message: 'Duplicate value',
    code: 'ERR_DUPLICATE_VALUE',
};
var TEAM_NOT_FOUND = {
    message: 'Team not found',
    code: 'ERR_NOT_FOUND_TEAM',
};
var NO_VALID_ACTIONS = {
    message: 'No valid actions',
    code: 'ERR_NO_VALID_ACTIONS',
};
var NO_VALID_ATTRIBUTES = {
    message: 'No valid attributes',
    code: 'ERR_NO_VALID_ATTRIBUTES',
};
var VALUE_UNCHANGED = {
    message: 'Value unchanged',
    code: 'ABORT_UNCHANGED',
};
var NOT_FOUND = { message: 'Not found', code: 'ERR_NOT_FOUND' };
var NOT_IMPLEMENTED = {
    message: 'Not implemented',
    code: 'ERR_NOT_IMPLEMENTED',
};
var EXISTING_FLIGHT = {
    message: 'Existing flight',
    code: 'ERR_EXISTING_FLIGHT',
};
var EXISTING_PROFILE = {
    message: 'Existing flight profile',
    code: 'ERR_EXISTING_FLIGHT_PROFILE',
};
var EXISTING_OUTCOME = {
    message: 'Existing outcome',
    code: 'ERR_EXISTING_OUTCOME',
};
var EXISTING_MATCHUP_ID = {
    message: 'Existing matchUpId',
    code: 'ERR_EXISTING_MATCHUP_ID',
};
var EXISTING_STAGE = {
    message: 'Existing stage',
    code: 'ERR_EXISTING_STAGE',
};
var EXISTING_STRUCTURE = {
    message: 'Existing structure',
    code: 'ERR_EXISTING_STRUCTURE',
};
var METHOD_NOT_FOUND = {
    message: 'Method not found',
    code: 'ERR_NOT_FOUND_METHOD',
};
var SCHEDULED_MATCHUPS = {
    message: 'Scheduled matchUps',
    code: 'ERR_SCHEDULED_MATCHUPS',
};
var SCORES_PRESENT = {
    message: 'Scores present',
    code: 'ERR_SCORES_PRESENT',
};
var errorConditionConstants = {
    ANACHRONISM: ANACHRONISM,
    CANNOT_CHANGE_WINNING_SIDE: CANNOT_CHANGE_WINNING_SIDE,
    CANNOT_MODIFY_TIEFORMAT: CANNOT_MODIFY_TIEFORMAT,
    CANNOT_MODIFY_PARTICIPANT_TYPE: CANNOT_MODIFY_PARTICIPANT_TYPE,
    CANNOT_REMOVE_MAIN_STRUCTURE: CANNOT_REMOVE_MAIN_STRUCTURE,
    CANNOT_REMOVE_PARTICIPANTS: CANNOT_REMOVE_PARTICIPANTS,
    COURT_EXISTS: COURT_EXISTS,
    COURT_NOT_FOUND: COURT_NOT_FOUND,
    DRAW_DEFINITION_NOT_FOUND: DRAW_DEFINITION_NOT_FOUND,
    DRAW_ID_EXISTS: DRAW_ID_EXISTS,
    DRAW_POSITION_ACTIVE: DRAW_POSITION_ACTIVE,
    DRAW_POSITION_ASSIGNED: DRAW_POSITION_ASSIGNED,
    DRAW_POSITION_NOT_CLEARED: DRAW_POSITION_NOT_CLEARED,
    DRAW_POSITION_NOT_FOUND: DRAW_POSITION_NOT_FOUND,
    DRAW_SIZE_MISMATCH: DRAW_SIZE_MISMATCH,
    DUPLICATE_VALUE: DUPLICATE_VALUE,
    ENTRY_STATUS_NOT_ALLOWED_FOR_EVENT: ENTRY_STATUS_NOT_ALLOWED_FOR_EVENT,
    ENTRY_STATUS_NOT_ALLOWED_IN_STAGE: ENTRY_STATUS_NOT_ALLOWED_IN_STAGE,
    EVENT_EXISTS: EVENT_EXISTS,
    EVENT_NOT_FOUND: EVENT_NOT_FOUND,
    EXISTING_DRAW_DEFINITIONS: EXISTING_DRAW_DEFINITIONS,
    EXISTING_END_TIME: EXISTING_END_TIME,
    EXISTING_FLIGHT: EXISTING_FLIGHT,
    EXISTING_MATCHUP_ID: EXISTING_MATCHUP_ID,
    EXISTING_OUTCOME: EXISTING_OUTCOME,
    EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT: EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT,
    EXISTING_PARTICIPANT: EXISTING_PARTICIPANT,
    EXISTING_POLICY_TYPE: EXISTING_POLICY_TYPE,
    EXISTING_PROFILE: EXISTING_PROFILE,
    EXISTING_ROUND: EXISTING_ROUND,
    EXISTING_STAGE: EXISTING_STAGE,
    EXISTING_STRUCTURE: EXISTING_STRUCTURE,
    INCOMPATIBLE_MATCHUP_STATUS: INCOMPATIBLE_MATCHUP_STATUS,
    INCOMPLETE_SOURCE_STRUCTURE: INCOMPLETE_SOURCE_STRUCTURE,
    INSUFFICIENT_DRAW_POSITIONS: INSUFFICIENT_DRAW_POSITIONS,
    INVALID_ACTION: INVALID_ACTION,
    INVALID_ASSIGNMENT: INVALID_ASSIGNMENT,
    INVALID_BOOKINGS: INVALID_BOOKINGS,
    INVALID_CATEGORY: INVALID_CATEGORY,
    INVALID_COLLECTION_DEFINITION: INVALID_COLLECTION_DEFINITION,
    INVALID_CONFIGURATION: INVALID_CONFIGURATION,
    INVALID_DATE_AVAILABILITY: INVALID_DATE_AVAILABILITY,
    INVALID_DATE: INVALID_DATE,
    INVALID_DRAW_DEFINITION: INVALID_DRAW_DEFINITION,
    INVALID_DRAW_POSITION_FOR_SEEDING: INVALID_DRAW_POSITION_FOR_SEEDING,
    INVALID_DRAW_POSITION: INVALID_DRAW_POSITION,
    INVALID_DRAW_SIZE: INVALID_DRAW_SIZE,
    INVALID_END_TIME: INVALID_END_TIME,
    INVALID_ENTRIES: INVALID_ENTRIES,
    INVALID_EVENT_TYPE: INVALID_EVENT_TYPE,
    INVALID_GAME_SCORES: INVALID_GAME_SCORES,
    INVALID_GENDER: INVALID_GENDER,
    INVALID_MATCHUP_FORMAT: INVALID_MATCHUP_FORMAT,
    INVALID_MATCHUP_STATUS: INVALID_MATCHUP_STATUS,
    INVALID_MATCHUP_STATUS_BYE: INVALID_MATCHUP_STATUS_BYE,
    INVALID_MATCHUP: INVALID_MATCHUP,
    INVALID_OBJECT: INVALID_OBJECT,
    INVALID_PARTICIPANT_ID: INVALID_PARTICIPANT_ID,
    INVALID_PARTICIPANT_IDS: INVALID_PARTICIPANT_IDS,
    INVALID_PARTICIPANT_ROLE: INVALID_PARTICIPANT_ROLE,
    INVALID_PARTICIPANT_SEEDING: INVALID_PARTICIPANT_SEEDING,
    INVALID_PARTICIPANT_TYPE: INVALID_PARTICIPANT_TYPE,
    INVALID_PARTICIPANT: INVALID_PARTICIPANT,
    INVALID_POLICY_DEFINITION: INVALID_POLICY_DEFINITION,
    INVALID_RECORDS: INVALID_RECORDS,
    INVALID_SCALE_ITEM: INVALID_SCALE_ITEM,
    INVALID_SEED_NUMBER: INVALID_SEED_NUMBER,
    INVALID_SEED_POSITION: INVALID_SEED_POSITION,
    INVALID_SET_NUMBER: INVALID_SET_NUMBER,
    INVALID_SIDE_NUMBER: INVALID_SIDE_NUMBER,
    INVALID_SCORE: INVALID_SCORE,
    INVALID_STAGE: INVALID_STAGE,
    INVALID_START_TIME: INVALID_START_TIME,
    INVALID_STRUCTURE: INVALID_STRUCTURE,
    INVALID_STOP_TIME: INVALID_STOP_TIME,
    INVALID_TIE_FORMAT: INVALID_TIE_FORMAT,
    INVALID_TIME: INVALID_TIME,
    INVALID_TIME_ITEM: INVALID_TIME_ITEM,
    INVALID_TOURNAMENT_DATES: INVALID_TOURNAMENT_DATES,
    INVALID_TOURNAMENT_RECORD: INVALID_TOURNAMENT_RECORD,
    INVALID_VALUES: INVALID_VALUES,
    INVALID_WINNING_SIDE: INVALID_WINNING_SIDE,
    MATCHUP_NOT_FOUND: MATCHUP_NOT_FOUND,
    METHOD_NOT_FOUND: METHOD_NOT_FOUND,
    MISSING_ASSIGNMENTS: MISSING_ASSIGNMENTS,
    MISSING_ASYNC_STATE_PROVIDER: MISSING_ASYNC_STATE_PROVIDER,
    MISSING_AVOIDANCE_POLICY: MISSING_AVOIDANCE_POLICY,
    MISSING_COLLECTION_DEFINITION: MISSING_COLLECTION_DEFINITION,
    MISSING_COURT_ID: MISSING_COURT_ID,
    MISSING_COURTS_INFO: MISSING_COURTS_INFO,
    MISSING_DATE_AVAILABILITY: MISSING_DATE_AVAILABILITY,
    MISSING_DATE: MISSING_DATE,
    MISSING_DRAW_DEFINITION: MISSING_DRAW_DEFINITION,
    MISSING_DRAW_ID: MISSING_DRAW_ID,
    MISSING_DRAW_POSITION: MISSING_DRAW_POSITION,
    MISSING_DRAW_POSITIONS: MISSING_DRAW_POSITIONS,
    MISSING_DRAW_SIZE: MISSING_DRAW_SIZE,
    MISSING_ENTRIES: MISSING_ENTRIES,
    MISSING_EVENT: MISSING_EVENT,
    MISSING_MATCHUP_FORMAT: MISSING_MATCHUP_FORMAT,
    MISSING_MATCHUP_ID: MISSING_MATCHUP_ID,
    MISSING_MATCHUP_IDS: MISSING_MATCHUP_IDS,
    MISSING_MATCHUP: MISSING_MATCHUP,
    MISSING_MATCHUPS: MISSING_MATCHUPS,
    MISSING_PARTICIPANT_COUNT: MISSING_PARTICIPANT_COUNT,
    MISSING_PARTICIPANT_ID: MISSING_PARTICIPANT_ID,
    MISSING_PARTICIPANT_IDS: MISSING_PARTICIPANT_IDS,
    MISSING_PARTICIPANT_ROLE: MISSING_PARTICIPANT_ROLE,
    MISSING_PARTICIPANT: MISSING_PARTICIPANT,
    MISSING_PARTICIPANTS: MISSING_PARTICIPANTS,
    MISSING_PENALTY_ID: MISSING_PENALTY_ID,
    MISSING_PENALTY_TYPE: MISSING_PENALTY_TYPE,
    MISSING_PERSON_DETAILS: MISSING_PERSON_DETAILS,
    MISSING_POLICY_ATTRIBUTES: MISSING_POLICY_ATTRIBUTES,
    MISSING_POLICY_DEFINITION: MISSING_POLICY_DEFINITION,
    MISSING_POLICY_TYPE: MISSING_POLICY_TYPE,
    MISSING_POSITION_ASSIGNMENTS: MISSING_POSITION_ASSIGNMENTS,
    MISSING_ROUND_NUMBER: MISSING_ROUND_NUMBER,
    MISSING_SCHEDULE: MISSING_SCHEDULE,
    MISSING_SCORING_POLICY: MISSING_SCORING_POLICY,
    MISSING_SEED_ASSIGNMENTS: MISSING_SEED_ASSIGNMENTS,
    MISSING_SEEDCOUNT_THRESHOLDS: MISSING_SEEDCOUNT_THRESHOLDS,
    MISSING_SEEDING_POLICY: MISSING_SEEDING_POLICY,
    MISSING_SET_NUMBER: MISSING_SET_NUMBER,
    MISSING_SET_OBJECT: MISSING_SET_OBJECT,
    MISSING_SIDE_NUMBER: MISSING_SIDE_NUMBER,
    MISSING_STAGE: MISSING_STAGE,
    MISSING_STRUCTURE_ID: MISSING_STRUCTURE_ID,
    MISSING_STRUCTURE: MISSING_STRUCTURE,
    MISSING_STRUCTURES: MISSING_STRUCTURES,
    MISSING_TARGET_LINK: MISSING_TARGET_LINK,
    MISSING_TIE_FORMAT: MISSING_TIE_FORMAT,
    MISSING_TIME_ITEM: MISSING_TIME_ITEM,
    MISSING_TIME_ITEMS: MISSING_TIME_ITEMS,
    MISSING_TOURNAMENT_ID: MISSING_TOURNAMENT_ID,
    MISSING_TOURNAMENT_RECORD: MISSING_TOURNAMENT_RECORD,
    MISSING_TOURNAMENT_RECORDS: MISSING_TOURNAMENT_RECORDS,
    MISSING_VALUE: MISSING_VALUE,
    MISSING_VENUE_ID: MISSING_VENUE_ID,
    MODIFICATIONS_FAILED: MODIFICATIONS_FAILED,
    NO_CANDIDATES: NO_CANDIDATES,
    NO_DRAW_POSITIONS_AVAILABLE_FOR_QUALIFIERS: NO_DRAW_POSITIONS_AVAILABLE_FOR_QUALIFIERS,
    NO_MODIFICATIONS_APPLIED: NO_MODIFICATIONS_APPLIED,
    NO_STAGE_SPACE_AVAILABLE_FOR_ENTRY_STATUS: NO_STAGE_SPACE_AVAILABLE_FOR_ENTRY_STATUS,
    NO_PARTICIPANT_REMOVED: NO_PARTICIPANT_REMOVED,
    NO_VALID_ACTIONS: NO_VALID_ACTIONS,
    NO_VALID_ATTRIBUTES: NO_VALID_ATTRIBUTES,
    NO_VALID_DATES: NO_VALID_DATES,
    NOT_FOUND: NOT_FOUND,
    NOT_IMPLEMENTED: NOT_IMPLEMENTED,
    PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE: PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE,
    PARTICIPANT_ID_EXISTS: PARTICIPANT_ID_EXISTS,
    PARTICIPANT_NOT_CHECKED_IN: PARTICIPANT_NOT_CHECKED_IN,
    PARTICIPANT_NOT_FOUND: PARTICIPANT_NOT_FOUND,
    PARTICIPANT_PAIR_EXISTS: PARTICIPANT_PAIR_EXISTS,
    PENALTY_NOT_FOUND: PENALTY_NOT_FOUND,
    POLICY_NOT_ATTACHED: POLICY_NOT_ATTACHED,
    POLICY_NOT_FOUND: POLICY_NOT_FOUND,
    SCHEDULE_NOT_CLEARED: SCHEDULE_NOT_CLEARED,
    SCHEDULED_MATCHUPS: SCHEDULED_MATCHUPS,
    SCORES_PRESENT: SCORES_PRESENT,
    SEEDSCOUNT_GREATER_THAN_DRAW_SIZE: SEEDSCOUNT_GREATER_THAN_DRAW_SIZE,
    STAGE_SEQUENCE_LIMIT: STAGE_SEQUENCE_LIMIT,
    STRUCTURE_NOT_FOUND: STRUCTURE_NOT_FOUND,
    TEAM_NOT_FOUND: TEAM_NOT_FOUND,
    UNABLE_TO_ASSIGN_COURT: UNABLE_TO_ASSIGN_COURT,
    UNLINKED_STRUCTURES: UNLINKED_STRUCTURES,
    UNRECOGNIZED_DRAW_TYPE: UNRECOGNIZED_DRAW_TYPE,
    UNRECOGNIZED_MATCHUP_FORMAT: UNRECOGNIZED_MATCHUP_FORMAT,
    UNRECOGNIZED_MATCHUP_STATUS: UNRECOGNIZED_MATCHUP_STATUS,
    VALUE_UNCHANGED: VALUE_UNCHANGED,
    VENUE_EXISTS: VENUE_EXISTS,
};

var syncGlobalState = {
    disableNotifications: false,
    tournamentId: undefined,
    tournamentRecords: {},
    subscriptions: {},
    modified: false,
    methods: {},
    notices: [],
};
var syncGlobalState$1 = {
    addNotice: addNotice$1,
    callListener: callListener$1,
    cycleMutationStatus: cycleMutationStatus$1,
    deleteNotice: deleteNotice$1,
    deleteNotices: deleteNotices$1,
    disableNotifications: disableNotifications$1,
    enableNotifications: enableNotifications$1,
    getMethods: getMethods$1,
    getNotices: getNotices$1,
    getTopics: getTopics$1,
    getTournamentId: getTournamentId$1,
    getTournamentRecord: getTournamentRecord$1,
    getTournamentRecords: getTournamentRecords$1,
    removeTournamentRecord: removeTournamentRecord$1,
    setMethods: setMethods$1,
    setSubscriptions: setSubscriptions$1,
    setTournamentId: setTournamentId$1,
    setTournamentRecord: setTournamentRecord$2,
    setTournamentRecords: setTournamentRecords$1,
    handleCaughtError: handleCaughtError$1,
};
function disableNotifications$1() {
    syncGlobalState.disableNotifications = true;
}
function enableNotifications$1() {
    syncGlobalState.disableNotifications = false;
}
function getTournamentId$1() {
    return syncGlobalState.tournamentId;
}
function getTournamentRecord$1(tournamentId) {
    return syncGlobalState.tournamentRecords[tournamentId];
}
function getTournamentRecords$1() {
    return syncGlobalState.tournamentRecords;
}
function setTournamentRecord$2(tournamentRecord) {
    var tournamentId = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId;
    if (tournamentId) {
        syncGlobalState.tournamentRecords[tournamentId] = tournamentRecord;
        return { success: true };
    }
    else {
        return { error: INVALID_TOURNAMENT_RECORD };
    }
}
function setTournamentId$1(tournamentId) {
    if (!tournamentId) {
        syncGlobalState.tournamentId = undefined;
        return { success: true };
    }
    if (syncGlobalState.tournamentRecords[tournamentId]) {
        syncGlobalState.tournamentId = tournamentId;
        return { success: true };
    }
    else {
        return { error: MISSING_TOURNAMENT_RECORD };
    }
}
function setTournamentRecords$1(tournamentRecords) {
    syncGlobalState.tournamentRecords = tournamentRecords;
    var tournamentIds = Object.keys(tournamentRecords);
    if (tournamentIds.length === 1) {
        syncGlobalState.tournamentId = tournamentIds[0];
    }
    else if (!tournamentIds.length) {
        syncGlobalState.tournamentId = undefined;
    }
}
function removeTournamentRecord$1(tournamentId) {
    if (typeof tournamentId !== 'string')
        return { error: INVALID_VALUES };
    if (!syncGlobalState.tournamentRecords[tournamentId])
        return { error: NOT_FOUND };
    delete syncGlobalState.tournamentRecords[tournamentId];
    var tournamentIds = Object.keys(syncGlobalState.tournamentRecords);
    if (tournamentIds.length === 1) {
        syncGlobalState.tournamentId = tournamentIds[0];
    }
    else if (!tournamentIds.length) {
        syncGlobalState.tournamentId = undefined;
    }
    return { success: true };
}
function setSubscriptions$1(params) {
    if (typeof params.subscriptions !== 'object')
        return { error: INVALID_VALUES };
    Object.keys(params.subscriptions).forEach(function (subscription) {
        syncGlobalState.subscriptions[subscription] =
            params.subscriptions[subscription];
    });
    return __assign({}, SUCCESS);
}
function setMethods$1(params) {
    Object.keys(params).forEach(function (methodName) {
        if (typeof params[methodName] !== 'function')
            return;
        syncGlobalState.methods[methodName] = params[methodName];
    });
    return __assign({}, SUCCESS);
}
function cycleMutationStatus$1() {
    var status = syncGlobalState.modified;
    syncGlobalState.modified = false;
    return status;
}
function addNotice$1(_a) {
    var topic = _a.topic, payload = _a.payload, key = _a.key;
    if (typeof topic !== 'string' || typeof payload !== 'object') {
        return;
    }
    if (!syncGlobalState.disableNotifications)
        syncGlobalState.modified = true;
    if (syncGlobalState.disableNotifications ||
        !syncGlobalState.subscriptions[topic]) {
        return;
    }
    if (key) {
        syncGlobalState.notices = syncGlobalState.notices.filter(function (notice) { return !(notice.topic === topic && notice.key === key); });
    }
    syncGlobalState.notices.push({ topic: topic, payload: payload, key: key });
    return __assign({}, SUCCESS);
}
function getMethods$1() {
    var _a;
    return (_a = syncGlobalState.methods) !== null && _a !== void 0 ? _a : {};
}
function getNotices$1(_a) {
    var topic = _a.topic;
    var notices = syncGlobalState.notices
        .filter(function (notice) { return notice.topic === topic; })
        .map(function (notice) { return notice.payload; });
    return notices.length && notices;
}
function deleteNotices$1() {
    syncGlobalState.notices = [];
}
function deleteNotice$1(_a) {
    var topic = _a.topic, key = _a.key;
    syncGlobalState.notices = syncGlobalState.notices.filter(function (notice) { return (!topic || notice.topic === topic) && notice.key !== key; });
}
function getTopics$1() {
    var topics = Object.keys(syncGlobalState.subscriptions);
    return { topics: topics };
}
function callListener$1(_a) {
    var topic = _a.topic, notices = _a.notices;
    var method = syncGlobalState.subscriptions[topic];
    if (method && typeof method === 'function') {
        method(notices);
    }
}
function handleCaughtError$1(_a) {
    var engineName = _a.engineName, methodName = _a.methodName, params = _a.params, err = _a.err;
    var error;
    if (typeof err === 'string') {
        error = err.toUpperCase();
    }
    else if (err instanceof Error) {
        error = err.message;
    }
    console.log('ERROR', {
        tournamentId: getTournamentId$1(),
        params: JSON.stringify(params),
        engine: engineName,
        methodName: methodName,
        error: error,
    });
    return { error: error };
}

var globalState = {
    tournamentFactoryVersion: '0.0.0',
    timers: { default: { elapsedTime: 0 } },
    deepCopyAttributes: {
        stringify: [],
        ignore: [],
        toJSON: [],
    },
    deepCopy: true,
};
var _globalStateProvider = syncGlobalState$1;
var requiredStateProviderMethods = [
    'addNotice',
    'callListener',
    'cycleMutationStatus',
    'deleteNotice',
    'deleteNotices',
    'disableNotifications',
    'enableNotifications',
    'getMethods',
    'getNotices',
    'getTopics',
    'getTournamentId',
    'getTournamentRecord',
    'getTournamentRecords',
    'removeTournamentRecord',
    'setSubscriptions',
    'setTournamentId',
    'setTournamentRecord',
    'setTournamentRecords',
];
function setStateProvider(globalStateProvider) {
    if (typeof globalStateProvider !== 'object') {
        throw new Error("Global state provider can not be undefined or null");
    }
    else {
        var providerMethods = intersection(Object.keys(globalStateProvider), requiredStateProviderMethods);
        if (providerMethods.length !== requiredStateProviderMethods.length) {
            throw new Error('Global state provider is missing required methods');
        }
        else {
            _globalStateProvider = globalStateProvider;
            return { success: true };
        }
    }
}
function createInstanceState() {
    //Only applicable for async
    if (_globalStateProvider.createInstanceState) {
        try {
            _globalStateProvider.createInstanceState();
        }
        catch (error) {
            return { error: error };
        }
        return { success: true };
    }
    else {
        return { error: MISSING_ASYNC_STATE_PROVIDER };
    }
}
/**
 * if contextCriteria, check whether all contextCriteria keys values are equivalent with globalState.devContext object
 */
function getDevContext(contextCriteria) {
    var _a;
    if (!contextCriteria || typeof contextCriteria !== 'object') {
        return (_a = globalState.devContext) !== null && _a !== void 0 ? _a : false;
    }
    else {
        if (typeof globalState.devContext !== 'object')
            return false;
        return (Object.keys(contextCriteria).every(function (key) { var _a; return ((_a = globalState.devContext) === null || _a === void 0 ? void 0 : _a[key]) === contextCriteria[key]; }) && globalState.devContext);
    }
}
function timeKeeper(action, timer) {
    var _a, _b, _c, _d;
    if (action === void 0) { action = 'reset'; }
    if (timer === void 0) { timer = 'default'; }
    var timeNow = Date.now();
    if (action === 'report') {
        if (timer === 'allTimers') {
            var timers = Object.keys(globalState.timers);
            return timers
                .filter(function (timer) { return timer !== 'default' || globalState.timers[timer].startTime; })
                .map(function (timer) {
                var _a;
                var currentTimer = globalState.timers[timer];
                var elapsedPeriod = currentTimer.state === 'stopped'
                    ? 0
                    : (timeNow - ((_a = currentTimer === null || currentTimer === void 0 ? void 0 : currentTimer.startTime) !== null && _a !== void 0 ? _a : 0)) / 1000;
                var elapsedTime = currentTimer.elapsedTime + elapsedPeriod;
                return {
                    state: globalState.timers[timer].state,
                    elapsedTime: elapsedTime.toFixed(2),
                    timer: timer,
                };
            });
        }
        else {
            var elapsedPeriod = globalState.timers[timer].state === 'stopped'
                ? 0
                : (timeNow - ((_b = (_a = globalState.timers[timer]) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : 0)) / 1000;
            var elapsedTime = globalState.timers[timer].elapsedTime + elapsedPeriod;
            return {
                state: globalState.timers[timer].state,
                elapsedTime: elapsedTime.toFixed(2),
                timer: timer,
            };
        }
    }
    if (!globalState.timers[timer] || action === 'reset') {
        if (timer === 'allTimers') {
            globalState.timers = { default: { elapsedTime: 0 } };
            return true;
        }
        else {
            globalState.timers[timer] = {
                startTime: timeNow,
                state: 'active',
                elapsedTime: 0,
            };
        }
    }
    if (!globalState.timers[timer].elapsedTime)
        globalState.timers[timer].elapsedTime = 0;
    action === 'stop' &&
        globalState.timers[timer].state !== 'stopped' &&
        (globalState.timers[timer].state = 'stopped') &&
        (globalState.timers[timer].elapsedTime +=
            (timeNow - ((_d = (_c = globalState.timers[timer]) === null || _c === void 0 ? void 0 : _c.startTime) !== null && _d !== void 0 ? _d : 0)) / 1000);
    action === 'start' &&
        (globalState.timers[timer].startTime = timeNow) &&
        (globalState.timers[timer].state = 'active');
    return globalState.timers[timer];
}
function setGlobalLog(loggingFx) {
    if (typeof loggingFx === 'function') {
        globalState.globalLog = loggingFx;
    }
    else {
        delete globalState.globalLog;
    }
}
function setDevContext(value) {
    globalState.devContext = value;
}
function disableNotifications() {
    _globalStateProvider.disableNotifications();
}
function enableNotifications() {
    _globalStateProvider.enableNotifications();
}
function setDeepCopy(value, attributes) {
    if (typeof value === 'boolean') {
        globalState.deepCopy = value;
    }
    if (typeof attributes === 'object') {
        if (Array.isArray(attributes.ignore))
            globalState.deepCopyAttributes.ignore = attributes.ignore;
        if (Array.isArray(attributes.toJSON))
            globalState.deepCopyAttributes.toJSON = attributes.toJSON;
        if (Array.isArray(attributes.stringify))
            globalState.deepCopyAttributes.stringify = attributes.stringify;
        if (attributes.threshold)
            globalState.deepCopyAttributes.threshold = attributes.threshold;
    }
}
function deepCopyEnabled() {
    return __assign({ enabled: globalState.deepCopy }, globalState.deepCopyAttributes);
}
function setSubscriptions(params) {
    if (!(params === null || params === void 0 ? void 0 : params.subscriptions))
        return { error: MISSING_VALUE, info: 'missing subscriptions' };
    return _globalStateProvider.setSubscriptions({
        subscriptions: params.subscriptions,
    });
}
function setMethods(params) {
    if (!params)
        return { error: MISSING_VALUE, info: 'missing method declarations' };
    if (typeof params !== 'object')
        return { error: INVALID_VALUES };
    return _globalStateProvider.setMethods(params);
}
function cycleMutationStatus() {
    return _globalStateProvider.cycleMutationStatus();
}
function addNotice(notice) {
    return _globalStateProvider.addNotice(notice);
}
function getMethods() {
    return _globalStateProvider.getMethods();
}
function getNotices(params) {
    return _globalStateProvider.getNotices(params);
}
function deleteNotice(_a) {
    var key = _a.key, topic = _a.topic;
    return _globalStateProvider.deleteNotice({ key: key, topic: topic });
}
function deleteNotices() {
    return _globalStateProvider.deleteNotices();
}
function getTopics() {
    return _globalStateProvider.getTopics();
}
function callListener(payload) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, _globalStateProvider.callListener(payload)];
        });
    });
}
function getTournamentId() {
    return _globalStateProvider.getTournamentId();
}
function getTournamentRecord(tournamentId) {
    return _globalStateProvider.getTournamentRecord(tournamentId);
}
function getTournamentRecords() {
    return _globalStateProvider.getTournamentRecords();
}
function setTournamentRecord$1(tournamentRecord) {
    return _globalStateProvider.setTournamentRecord(tournamentRecord);
}
function setTournamentRecords(tournamentRecords) {
    return _globalStateProvider.setTournamentRecords(tournamentRecords);
}
function setTournamentId(tournamentId) {
    return _globalStateProvider.setTournamentId(tournamentId);
}
function removeTournamentRecord(tournamentId) {
    return _globalStateProvider.removeTournamentRecord(tournamentId);
}
function getProvider() {
    return _globalStateProvider;
}
function handleCaughtError(_a) {
    var engineName = _a.engineName, methodName = _a.methodName, params = _a.params, err = _a.err;
    var caughtErrorHandler = (typeof _globalStateProvider.handleCaughtError === 'function' &&
        _globalStateProvider.handleCaughtError) ||
        syncGlobalState$1.handleCaughtError;
    return caughtErrorHandler({
        engineName: engineName,
        methodName: methodName,
        params: params,
        err: err,
    });
}
function globalLog$1(engine, log) {
    if (globalState.globalLog) {
        try {
            globalState.globalLog({ engine: engine, log: log });
        }
        catch (error) {
            console.log('globalLog error', error);
            console.log(engine, log);
            setGlobalLog(); // delete failing custom globalLog
        }
    }
    else {
        console.log(engine, log);
    }
}

var globalState$1 = {
    __proto__: null,
    addNotice: addNotice,
    callListener: callListener,
    createInstanceState: createInstanceState,
    cycleMutationStatus: cycleMutationStatus,
    deepCopyEnabled: deepCopyEnabled,
    deleteNotice: deleteNotice,
    deleteNotices: deleteNotices,
    disableNotifications: disableNotifications,
    enableNotifications: enableNotifications,
    getDevContext: getDevContext,
    getMethods: getMethods,
    getNotices: getNotices,
    getProvider: getProvider,
    getTopics: getTopics,
    getTournamentId: getTournamentId,
    getTournamentRecord: getTournamentRecord,
    getTournamentRecords: getTournamentRecords,
    globalLog: globalLog$1,
    handleCaughtError: handleCaughtError,
    removeTournamentRecord: removeTournamentRecord,
    setDeepCopy: setDeepCopy,
    setDevContext: setDevContext,
    setGlobalLog: setGlobalLog,
    setMethods: setMethods,
    setStateProvider: setStateProvider,
    setSubscriptions: setSubscriptions,
    setTournamentId: setTournamentId,
    setTournamentRecord: setTournamentRecord$1,
    setTournamentRecords: setTournamentRecords,
    timeKeeper: timeKeeper
};

function getDefinedKeys(obj, ignoreValues, ignoreEmptyArrays) {
    return Object.keys(obj).filter(function (key) {
        return !ignoreValues.includes(obj[key]) &&
            (!ignoreEmptyArrays || (Array.isArray(obj[key]) ? obj[key].length : true));
    });
}
function definedAttributes(obj, ignoreFalse, ignoreEmptyArrays, shallow) {
    if (typeof obj !== 'object' || obj === null)
        return obj;
    var deepCopy = deepCopyEnabled();
    if (!(deepCopy === null || deepCopy === void 0 ? void 0 : deepCopy.enabled))
        shallow = true;
    var ignoreValues = ['', undefined, null];
    if (ignoreFalse)
        ignoreValues.push(false);
    var definedKeys = getDefinedKeys(obj, ignoreValues, ignoreEmptyArrays);
    return Object.assign.apply(Object, __spreadArray([{}], __read(definedKeys.map(function (key) {
        var _a, _b;
        return Array.isArray(obj[key])
            ? (_a = {},
                _a[key] = shallow
                    ? obj[key]
                    : obj[key].map(function (m) { return definedAttributes(m); }),
                _a) : (_b = {}, _b[key] = shallow ? obj[key] : definedAttributes(obj[key]), _b);
    })), false));
}

function decorateResult(_a) {
    var context = _a.context, result = _a.result, stack = _a.stack, info = _a.info;
    if (result && !Array.isArray(result === null || result === void 0 ? void 0 : result.stack))
        result.stack = [];
    if (result && Array.isArray(result === null || result === void 0 ? void 0 : result.stack) && typeof stack === 'string') {
        result.stack.push(stack);
    }
    if (result && info) {
        result.info = info;
    }
    if (result && typeof context === 'object' && Object.keys(context).length) {
        Object.assign(result, definedAttributes(context));
    }
    if (result && !(result === null || result === void 0 ? void 0 : result.error) && !(result === null || result === void 0 ? void 0 : result.success)) {
        Object.assign(result, __assign({}, SUCCESS));
    }
    return result !== null && result !== void 0 ? result : { success: true };
}

var ELEMENT_REQUIRED = 'element required';
var MISSING_NAME = 'missing name';

function removeExtension(params) {
    var e_1, _a;
    if (!params || typeof params !== 'object')
        return { error: MISSING_VALUE };
    if (params.element && typeof (params === null || params === void 0 ? void 0 : params.element) !== 'object')
        return { error: INVALID_VALUES };
    if (!(params === null || params === void 0 ? void 0 : params.name))
        return { error: MISSING_VALUE, info: MISSING_NAME };
    if (!(params === null || params === void 0 ? void 0 : params.element)) {
        if (params.discover && params.tournamentRecords) {
            try {
                for (var _b = __values(Object.keys(params.tournamentRecords)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var tournamentId = _c.value;
                    var tournamentRecord = params.tournamentRecords[tournamentId];
                    var result = removeExtension({
                        element: tournamentRecord,
                        name: params.name,
                    });
                    if (result.error)
                        return decorateResult({ result: result, stack: 'removeExtension' });
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return __assign({}, SUCCESS);
        }
        return { error: MISSING_VALUE, info: ELEMENT_REQUIRED };
    }
    if (!(params === null || params === void 0 ? void 0 : params.element.extensions))
        return __assign(__assign({}, SUCCESS), { info: NOT_FOUND });
    params.element.extensions = params.element.extensions.filter(function (extension) { return (extension === null || extension === void 0 ? void 0 : extension.name) !== params.name; });
    return __assign({}, SUCCESS);
}

function isValidExtension(_a) {
    var _b = _a.requiredAttributes, requiredAttributes = _b === void 0 ? ['name', 'value'] : _b, extension = _a.extension;
    if (!extension || typeof extension !== 'object')
        return false;
    if (typeof extension.name !== 'string')
        return false;
    var extensionAttributes = Object.keys(extension);
    return (requiredAttributes.filter(function (attribute) {
        return extensionAttributes.includes(attribute);
    }).length === requiredAttributes.length);
}

function addExtension(params) {
    var e_1, _a;
    var _b;
    if (typeof params !== 'object')
        return { error: MISSING_VALUE };
    var stack = 'addExtension';
    if ((params === null || params === void 0 ? void 0 : params.element) && typeof params.element !== 'object')
        return decorateResult({ result: { error: INVALID_VALUES }, stack: stack });
    if (!isValidExtension({ extension: params.extension }))
        return decorateResult({
            result: { error: INVALID_VALUES, info: 'invalid extension' },
            stack: stack,
        });
    if (!params.element) {
        if (params.discover && !params.tournamentId && params.tournamentRecords) {
            try {
                for (var _c = __values(Object.values(params.tournamentRecords)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var tournamentRecord = _d.value;
                    var result = addExtension({
                        extension: params.extension,
                        element: tournamentRecord,
                    });
                    if (result.error)
                        return decorateResult({ result: result, stack: stack });
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return __assign({}, SUCCESS);
        }
        else {
            return decorateResult({ result: { error: MISSING_VALUE }, stack: stack });
        }
    }
    if (!params.element.extensions)
        params.element.extensions = [];
    var creationTime = (_b = params === null || params === void 0 ? void 0 : params.creationTime) !== null && _b !== void 0 ? _b : true;
    if (creationTime) {
        var createdAt = new Date().toISOString();
        Object.assign(params.extension, { createdAt: createdAt });
    }
    var existingExtension = params.element.extensions.find(function (_a) {
        var name = _a.name;
        return name === params.extension.name;
    });
    if (existingExtension) {
        existingExtension.value = params.extension.value;
    }
    else if (params.extension.value) {
        params.element.extensions.push(params.extension);
    }
    return __assign({}, SUCCESS);
}

var stack = 'extensionQueries';
function findExtension(_a) {
    var _b;
    var discover = _a.discover, // boolean or array of keys to discover extensions on specified params
    element = _a.element, name = _a.name, params = __rest(_a, ["discover", "element", "name"]);
    if (!element || !name) {
        if (discover && params) {
            var attr = Object.keys(params)
                .filter(function (key) {
                return typeof discover === 'boolean' ||
                    (Array.isArray(discover) && discover.includes(key));
            })
                .find(function (key) {
                var _a;
                if (!Array.isArray((_a = params[key]) === null || _a === void 0 ? void 0 : _a.extensions))
                    return false;
                return params[key].extensions.find(function (extension) { return (extension === null || extension === void 0 ? void 0 : extension.name) === name; });
            });
            var element_1 = attr && params[attr];
            if (!element_1 && params.tournamentRecords) {
                element_1 = Object.values(params.tournamentRecords).find(function (tournamentRecord) { var _a; return (_a = tournamentRecord.extensions) === null || _a === void 0 ? void 0 : _a.length; });
            }
            var extension_1 = (_b = element_1 === null || element_1 === void 0 ? void 0 : element_1.extensions) === null || _b === void 0 ? void 0 : _b.find(function (extension) { return (extension === null || extension === void 0 ? void 0 : extension.name) === name; });
            var info_1 = !extension_1 ? NOT_FOUND : undefined;
            return { extension: extension_1, info: info_1 };
        }
        return decorateResult({ result: { error: MISSING_VALUE }, stack: stack });
    }
    if (!Array.isArray(element.extensions))
        return { info: 'no extensions' };
    var extension = element.extensions.find(function (extension) { return (extension === null || extension === void 0 ? void 0 : extension.name) === name; });
    var info = !extension ? NOT_FOUND : undefined;
    return { extension: extension, info: info };
}

var validDateString = /^[\d]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][\d]|3[0-1])$/;
var validTimeString = /^((0[\d]|1[\d]|2[0-3]):[0-5][\d](:[0-5][\d])?)([.,][0-9]{3})?$/;
var dateValidation = /^([\d]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][\d]|3[0-1]))([ T](0[\d]|1[\d]|2[0-3]):[0-5][\d](:[0-5][\d])?)?([.,][\d]{3})?Z?$/;
var timeValidation = /^([\d]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][\d]|3[0-1]))?([ T]?(0[\d]|1[\d]|2[0-3]):[0-5][\d](:[0-5][\d])?)?([.,][\d]{3})?Z?$/;

function getIsoDateString(schedule) {
    var scheduledDate = schedule.scheduledDate;
    if (!scheduledDate && schedule.scheduledTime)
        scheduledDate = extractDate(schedule.scheduledTime);
    if (!scheduledDate)
        return;
    var extractedTime = extractTime(schedule.scheduledTime);
    var isoDateString = extractDate(scheduledDate);
    if (isoDateString && extractedTime)
        isoDateString += "T".concat(extractedTime);
    return isoDateString;
}
function isDateObject(value) {
    if (typeof value !== 'object' || Array.isArray(value)) {
        return false;
    }
    else {
        var datePrototype = Object.prototype.toString.call(value);
        return datePrototype === '[object Date]';
    }
}
function validTimeValue(value) {
    var spaceSplit = typeof value === 'string' ? value === null || value === void 0 ? void 0 : value.split(' ') : [];
    if (value && (spaceSplit === null || spaceSplit === void 0 ? void 0 : spaceSplit.length) > 1 && !['AM', 'PM'].includes(spaceSplit[1].toUpperCase()))
        return false;
    return !!(!value || timeValidation.test(convertTime(value, true, true)));
}
function isValidDateString(scheduleDate) {
    return isISODateString(scheduleDate) || validDateString.test(scheduleDate);
}
function DateHHMM(date) {
    var dt = new Date(date);
    var secs = dt.getSeconds() + 60 * dt.getMinutes() + 60 * 60 * dt.getHours();
    return HHMMSS(secs, { displaySeconds: false });
}
function HHMMSS(s, format) {
    var secondNumber = parseInt(s, 10); // don't forget the second param
    var hours = Math.floor(secondNumber / 3600);
    var minutes = Math.floor((secondNumber - hours * 3600) / 60);
    var seconds = secondNumber - hours * 3600 - minutes * 60;
    var displaySeconds = !format || (format === null || format === void 0 ? void 0 : format.displaySeconds);
    var timeString = displaySeconds ? hours + ':' + minutes + ':' + seconds : hours + ':' + minutes;
    return timeString.split(':').map(zeroPad).join(':');
}
var getUTCdateString = function (date) {
    var dateDate = isDate(date) || isISODateString(date) ? new Date(date) : new Date();
    var monthNumber = dateDate.getUTCMonth() + 1;
    var utcMonth = monthNumber < 10 ? "0".concat(monthNumber) : "".concat(monthNumber);
    return "".concat(dateDate.getUTCFullYear(), "-").concat(zeroPad(utcMonth), "-").concat(zeroPad(dateDate.getUTCDate()));
};
function timeUTC(date) {
    var dateDate = isDate(date) || isISODateString(date) ? new Date(date) : new Date();
    return Date.UTC(dateDate.getFullYear(), dateDate.getMonth(), dateDate.getDate());
}
function formatDate(date, separator, format) {
    if (separator === void 0) { separator = '-'; }
    if (format === void 0) { format = 'YMD'; }
    if (!date)
        return '';
    if (typeof date === 'string' && date.indexOf('T') < 0)
        date = date + 'T00:00';
    var d = new Date(date);
    var month = '' + (d.getMonth() + 1);
    var day = '' + d.getDate();
    var year = d.getFullYear();
    if (month.length < 2)
        month = '0' + month;
    if (day.length < 2)
        day = '0' + day;
    if (format === 'DMY')
        return [day, month, year].join(separator);
    if (format === 'MDY')
        return [month, day, year].join(separator);
    if (format === 'YDM')
        return [year, day, month].join(separator);
    if (format === 'DYM')
        return [day, year, month].join(separator);
    if (format === 'MYD')
        return [month, year, day].join(separator);
    return [year, month, day].join(separator);
}
function offsetDate(date) {
    var targetTime = date ? new Date(date) : new Date();
    var tzDifference = targetTime.getTimezoneOffset();
    return new Date(targetTime.getTime() - tzDifference * 60 * 1000);
}
function offsetTime(date) {
    return offsetDate(date).getTime();
}
// only returns true for valid date objects
// dateArg = new Date('xxx') produces 'Invalid Date', which return false
function isDate(dateArg) {
    if (typeof dateArg == 'boolean')
        return false;
    var t = (dateArg instanceof Date && dateArg) || (!isNaN(dateArg) && new Date(dateArg)) || false;
    return t && !isNaN(t.valueOf());
}
function generateDateRange(startDt, endDt) {
    if (!isValidDateString(startDt) || !isValidDateString(endDt))
        return [];
    var startDateString = extractDate(startDt) + 'T00:00';
    var endDateString = extractDate(endDt) + 'T00:00';
    var startDate = new Date(startDateString);
    var endDate = new Date(endDateString);
    var process = isDate(endDate) && isDate(startDate) && isValidDateRange(startDate, endDate);
    var between = [];
    var iterations = 0;
    if (process) {
        var currentDate = startDate;
        var dateSecs = currentDate.getTime();
        while (dateSecs <= endDate.getTime() && iterations < 300) {
            iterations += 1;
            // must be a *new* Date otherwise it is an array of the same object
            between.push(new Date(currentDate));
            dateSecs = currentDate.setDate(currentDate.getDate() + 1);
        }
    }
    return between.map(function (date) { return formatDate(date); });
    function isValidDateRange(minDate, maxDate) {
        return minDate <= maxDate;
    }
}
// matches valid ISO date string
var re = /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
function isISODateString(dateString) {
    if (typeof dateString !== 'string')
        return false;
    return re.test(dateString);
}
function isTimeString(timeString) {
    if (typeof timeString !== 'string')
        return false;
    var noZ = timeString.split('Z')[0];
    var parts = noZ.split(':');
    var isNumeric = parts.every(function (part) { return !isNaN(parseInt(part)); });
    var invalid = parts.length < 2 || !isNumeric || parseInt(parts[0]) > 23 || parseInt(parts[1]) > 60;
    return !invalid;
}
function timeStringMinutes(timeString) {
    var validTimeString = extractTime(timeString);
    if (!validTimeString)
        return 0;
    var _a = __read(validTimeString.split(':').map(function (value) { return parseInt(value); }), 2), hours = _a[0], minutes = _a[1];
    return hours * 60 + minutes;
}
function dayMinutesToTimeString(totalMinutes) {
    var hours = Math.floor(totalMinutes / 60);
    var minutes = totalMinutes - hours * 60;
    if (hours > 23)
        hours = hours % 24;
    return [zeroPad(hours), zeroPad(minutes)].join(':');
}
function tidyTime(timeString) {
    return isTimeString(timeString) ? timeString.split(':').slice(0, 2).map(zeroPad).join(':') : undefined;
}
function extractTime(dateString) {
    return isISODateString(dateString) && dateString.indexOf('T') > 0
        ? tidyTime(dateString.split('T').reverse()[0])
        : tidyTime(dateString);
}
function extractDate(dateString) {
    return isISODateString(dateString) || dateValidation.test(dateString) ? dateString.split('T')[0] : undefined;
}
function dateStringDaysChange(dateString, daysChange) {
    var date = new Date(dateString);
    date.setDate(date.getDate() + daysChange);
    return extractDate(date.toISOString());
}
function splitTime(value) {
    var _a, _b;
    value = typeof value !== 'string' ? '00:00' : value;
    var o = {}, time = {};
    (_a = value.split(' ') || [], o.time = _a[0], o.ampm = _a[1]);
    (_b = o.time.split(':') || [], time.hours = _b[0], time.minutes = _b[1]);
    time.ampm = o.ampm;
    if (isNaN(time.hours) || isNaN(time.minutes) || (time.ampm && !['AM', 'PM'].includes(time.ampm.toUpperCase())))
        return {};
    return time;
}
function militaryTime(value) {
    var time = splitTime(value);
    if (time.ampm && time.hours) {
        if (time.ampm.toLowerCase() === 'pm' && parseInt(time.hours) < 12)
            time.hours = ((time.hours && parseInt(time.hours)) || 0) + 12;
        if (time.ampm.toLowerCase() === 'am' && time.hours === '12')
            time.hours = '00';
    }
    var timeString = "".concat(time.hours || '12', ":").concat(time.minutes || '00');
    return timeString.split(':').map(zeroPad).join(':');
}
function regularTime(value) {
    var _a;
    var time = splitTime(value);
    if (typeof time === 'object' && !Object.keys(time).length)
        return undefined;
    if (time.ampm)
        return value;
    if (time.hours > 12) {
        time.hours -= 12;
        time.ampm = 'PM';
    }
    else if (time.hours === '12') {
        time.ampm = 'PM';
    }
    else if (time.hours === '00') {
        time.hours = '12';
        time.ampm = 'AM';
    }
    else {
        time.ampm = 'AM';
    }
    if (((_a = time.hours) === null || _a === void 0 ? void 0 : _a[0]) === '0') {
        time.hours = time.hours.slice(1);
    }
    return "".concat(time.hours || '12', ":").concat(time.minutes || '00', " ").concat(time.ampm);
}
function convertTime(value, time24, keepDate) {
    var hasDate = extractDate(value);
    var timeString = extractTime(value);
    var timeValue = hasDate ? timeString : value;
    return !value
        ? undefined
        : (time24 && ((hasDate && keepDate && value) || militaryTime(timeValue))) || regularTime(timeValue);
}
function timeSort(a, b) {
    var as = splitTime(a);
    var bs = splitTime(b);
    if (parseInt(as.hours) < parseInt(bs.hours))
        return -1;
    if (parseInt(as.hours) > parseInt(bs.hours))
        return 1;
    if (as.hours === bs.hours) {
        if (parseInt(as.minutes) < parseInt(bs.minutes))
            return -1;
        if (parseInt(as.minutes) > parseInt(bs.minutes))
            return 1;
    }
    return 0;
}
function addDays(date, days) {
    if (days === void 0) { days = 7; }
    var universalDate = extractDate(date) + 'T00:00';
    var now = new Date(universalDate);
    var adjustedDate = new Date(now.setDate(now.getDate() + days));
    return formatDate(adjustedDate);
}
function addWeek(date) {
    return addDays(date);
}
function getDateByWeek(week, year, dateFormat, sunday) {
    if (sunday === void 0) { sunday = false; }
    var date = new Date(year, 0, 1 + (week - 1) * 7);
    var startValue = sunday ? 0 : 1;
    date.setDate(date.getDate() + (startValue - date.getDay()));
    return formatDate(date, dateFormat);
}
function dateFromDay(year, day, dateFormat) {
    var date = new Date(year, 0); // initialize a date in `year-01-01`
    return formatDate(new Date(date.setDate(day)), dateFormat); // add the number of days
}
function timeToDate(timeString, date) {
    if (date === void 0) { date = undefined; }
    var _a = __read((timeString || '00:00').split(':').map(zeroPad), 2), hours = _a[0], minutes = _a[1];
    var milliseconds = offsetDate(date).setHours(hours, minutes, 0, 0);
    return offsetDate(milliseconds);
}
function minutesDifference(date1, date2, absolute) {
    if (absolute === void 0) { absolute = true; }
    var dt1 = new Date(date1);
    var dt2 = new Date(date2);
    var diff = (dt2.getTime() - dt1.getTime()) / 1000 / 60;
    return absolute ? Math.abs(Math.round(diff)) : Math.round(diff);
}
function addMinutesToTimeString(timeString, minutes) {
    var validTimeString = extractTime(timeString);
    if (!validTimeString)
        return '00:00';
    var minutesToAdd = isNaN(minutes) ? 0 : minutes;
    return extractTime(addMinutes(timeToDate(validTimeString), minutesToAdd).toISOString());
}
function addMinutes(startDate, minutes) {
    var date = new Date(startDate);
    return new Date(date.getTime() + minutes * 60000);
}
function zeroPad(number) {
    return number.toString()[1] ? number : '0' + number;
}
function sameDay(date1, date2) {
    var d1 = new Date(date1);
    var d2 = new Date(date2);
    return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth() && d1.getDate() === d2.getDate();
}
var dateTime = {
    addDays: addDays,
    addWeek: addWeek,
    addMinutesToTimeString: addMinutesToTimeString,
    convertTime: convertTime,
    getIsoDateString: getIsoDateString,
    getUTCdateString: getUTCdateString,
    DateHHMM: DateHHMM,
    extractDate: extractDate,
    extractTime: extractTime,
    formatDate: formatDate,
    getDateByWeek: getDateByWeek,
    isISODateString: isISODateString,
    isDate: isDate,
    isTimeString: isTimeString,
    offsetDate: offsetDate,
    offsetTime: offsetTime,
    sameDay: sameDay,
    timeStringMinutes: timeStringMinutes,
    timeToDate: timeToDate,
    timeUTC: timeUTC,
    validTimeValue: validTimeValue,
    validDateString: validDateString,
    timeValidation: timeValidation,
    dateValidation: dateValidation,
};

function makeDeepCopy(sourceObject, // arbitrary JSON object; functions will be stripped.
convertExtensions, // optional - all extension objects converted to attributes ._key
internalUse, // disregard deepCopy being disabled within the engine - necessary for query results
removeExtensions, // optional - strip all extension attributes
iteration // escape hatch - check against iteration threshold
) {
    var e_1, _a;
    if (iteration === void 0) { iteration = 0; }
    if (getProvider().makeDeepCopy)
        return getProvider().makeDeepCopy(sourceObject, convertExtensions, internalUse, removeExtensions);
    var deepCopy = deepCopyEnabled();
    var _b = deepCopy || {}, stringify = _b.stringify, toJSON = _b.toJSON, ignore = _b.ignore, modulate = _b.modulate;
    if ((!(deepCopy === null || deepCopy === void 0 ? void 0 : deepCopy.enabled) && !internalUse) ||
        typeof sourceObject !== 'object' ||
        typeof sourceObject === 'function' ||
        sourceObject === null ||
        (typeof (deepCopy === null || deepCopy === void 0 ? void 0 : deepCopy.threshold) === 'number' && iteration >= deepCopy.threshold)) {
        return sourceObject;
    }
    var targetObject = Array.isArray(sourceObject) ? [] : {};
    var sourceObjectKeys = Object.keys(sourceObject).filter(function (key) {
        return !internalUse ||
            !ignore ||
            (Array.isArray(ignore) && !ignore.includes(key)) ||
            (typeof ignore === 'function' && !ignore(key));
    });
    var stringifyValue = function (key, value) {
        targetObject[key] =
            typeof (value === null || value === void 0 ? void 0 : value.toString) === 'function'
                ? value.toString()
                : JSON.stringify(value);
    };
    try {
        for (var sourceObjectKeys_1 = __values(sourceObjectKeys), sourceObjectKeys_1_1 = sourceObjectKeys_1.next(); !sourceObjectKeys_1_1.done; sourceObjectKeys_1_1 = sourceObjectKeys_1.next()) {
            var key = sourceObjectKeys_1_1.value;
            var value = sourceObject[key];
            var modulated = typeof modulate === 'function' ? modulate(value) : undefined;
            if (modulated !== undefined) {
                targetObject[key] = modulated;
            }
            else if (convertExtensions &&
                key === 'extensions' &&
                Array.isArray(value)) {
                var extensionConversions = extensionsToAttributes(value);
                Object.assign.apply(Object, __spreadArray([targetObject], __read(extensionConversions), false));
            }
            else if (removeExtensions && key === 'extensions') {
                targetObject[key] = [];
            }
            else if (Array.isArray(stringify) && stringify.includes(key)) {
                stringifyValue(key, value);
            }
            else if (Array.isArray(toJSON) &&
                toJSON.includes(key) &&
                typeof (value === null || value === void 0 ? void 0 : value.toJSON) === 'function') {
                targetObject[key] = value.toJSON();
            }
            else if (value === null) {
                targetObject[key] = undefined;
            }
            else if (isDateObject(value)) {
                targetObject[key] = new Date(value).toISOString();
            }
            else {
                targetObject[key] = makeDeepCopy(value, convertExtensions, internalUse, removeExtensions, iteration + 1);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (sourceObjectKeys_1_1 && !sourceObjectKeys_1_1.done && (_a = sourceObjectKeys_1.return)) _a.call(sourceObjectKeys_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return targetObject;
}
function extensionsToAttributes(extensions) {
    return extensions === null || extensions === void 0 ? void 0 : extensions.map(function (extension) {
        var _a;
        var name = extension.name, value = extension.value;
        return name && value && (_a = {}, _a["_".concat(name)] = value, _a);
    }).filter(Boolean);
}

function getAccessorValue(_a) {
    var element = _a.element, accessor = _a.accessor;
    if (typeof accessor !== 'string')
        return { values: [] };
    var targetElement = makeDeepCopy(element);
    var attributes = accessor.split('.');
    var values = [];
    var value;
    processKeys({ targetElement: targetElement, attributes: attributes });
    var result = { value: value };
    if (values.length)
        result.values = values;
    return result;
    function processKeys(_a) {
        var e_1, _b;
        var targetElement = _a.targetElement, _c = _a.attributes, attributes = _c === void 0 ? [] : _c, significantCharacters = _a.significantCharacters;
        var _loop_1 = function (index, attribute) {
            if (targetElement === null || targetElement === void 0 ? void 0 : targetElement[attribute]) {
                var remainingKeys_1 = attributes.slice(index + 1);
                if (!remainingKeys_1.length) {
                    if (!value)
                        value = targetElement[attribute];
                    if (!values.includes(targetElement[attribute])) {
                        values.push(targetElement[attribute]);
                    }
                }
                else if (Array.isArray(targetElement[attribute])) {
                    var values_1 = targetElement[attribute];
                    values_1.forEach(function (nestedTarget) {
                        return processKeys({
                            targetElement: nestedTarget,
                            attributes: remainingKeys_1,
                        });
                    });
                }
                else {
                    targetElement = targetElement[attribute];
                    checkValue({ targetElement: targetElement, index: index });
                }
            }
        };
        try {
            for (var _d = __values(attributes.entries()), _e = _d.next(); !_e.done; _e = _d.next()) {
                var _f = __read(_e.value, 2), index = _f[0], attribute = _f[1];
                _loop_1(index, attribute);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
        function checkValue(_a) {
            var targetElement = _a.targetElement, index = _a.index;
            if (targetElement &&
                index === attributes.length - 1 &&
                ['string', 'number'].includes(typeof targetElement)) {
                var extractedValue = significantCharacters
                    ? targetElement.slice(0, significantCharacters)
                    : targetElement;
                if (value) {
                    if (!values.includes(extractedValue)) {
                        values.push(extractedValue);
                    }
                }
                else {
                    value = extractedValue;
                    values.push(extractedValue);
                }
            }
        }
    }
}

function isFunction(obj) {
    return typeof obj === 'function';
}
function isString(obj) {
    return typeof obj === 'string';
}
function isObject(obj) {
    return obj !== null && typeof obj === 'object' && !Array.isArray(obj);
}
function objShallowEqual(o1, o2) {
    var e_1, _a;
    if (!isObject(o1) || !isObject(o2))
        return false;
    var keys1 = Object.keys(o1);
    var keys2 = Object.keys(o2);
    if (keys1.length !== keys2.length) {
        return false;
    }
    try {
        for (var keys1_1 = __values(keys1), keys1_1_1 = keys1_1.next(); !keys1_1_1.done; keys1_1_1 = keys1_1.next()) {
            var key = keys1_1_1.value;
            if (o1[key] !== o2[key]) {
                return false;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (keys1_1_1 && !keys1_1_1.done && (_a = keys1_1.return)) _a.call(keys1_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return true;
}
function createMap(objectArray, attribute) {
    if (!Array.isArray(objectArray))
        return {};
    return Object.assign.apply(Object, __spreadArray([{}], __read((objectArray !== null && objectArray !== void 0 ? objectArray : [])
        .filter(isObject)
        .map(function (obj) {
        var _a;
        return (obj[attribute] && (_a = {},
            _a[obj[attribute]] = obj,
            _a));
    })
        .filter(Boolean)), false));
}
// e.g. result.find(hav({ attr: value })) -or- result.filter(hav({ attr: value }))
var hasAttributeValues = function (a) { return function (o) { return Object.keys(a).every(function (key) { return o[key] === a[key]; }); }; };
// extracts targeted attributes
// e.g. const byeAssignments = positionAssignments.filter(xa('bye')).map(xa('drawPosition'));
// supports xa('string'), xa(['string', 'string']), xa({ attr1: true, attr2: true })
var extractAttributes = function (accessor) { return function (element) {
    var _a;
    return !accessor || typeof element !== 'object'
        ? undefined
        : (Array.isArray(accessor) &&
            accessor.map(function (a) {
                var _a;
                var _b;
                return (_a = {},
                    _a[a] = (_b = getAccessorValue({ element: element, accessor: a })) === null || _b === void 0 ? void 0 : _b.value,
                    _a);
            })) ||
            (typeof accessor === 'object' &&
                Object.keys(accessor).map(function (key) {
                    var _a;
                    var _b;
                    return (_a = {},
                        _a[key] = (_b = getAccessorValue({ element: element, accessor: key })) === null || _b === void 0 ? void 0 : _b.value,
                        _a);
                })) ||
            ((_a = (typeof accessor === 'string' && getAccessorValue({ element: element, accessor: accessor }))) === null || _a === void 0 ? void 0 : _a.value);
}; };
var xa = extractAttributes;
// useful in notifications where back end does not recognize undefined for updates
function undefinedToNull(obj, shallow) {
    if (obj === undefined)
        return null;
    if (typeof obj !== 'object' || obj === null)
        return obj;
    var definedKeys = Object.keys(obj);
    var notNull = function (value) { return (value === undefined ? null : value); };
    return Object.assign.apply(Object, __spreadArray([{}], __read(definedKeys.map(function (key) {
        var _a, _b;
        return Array.isArray(obj[key])
            ? (_a = {},
                _a[key] = shallow ? obj[key] : obj[key].map(function (m) { return undefinedToNull(m); }),
                _a) : (_b = {}, _b[key] = shallow ? notNull(obj[key]) : undefinedToNull(obj[key]), _b);
    })), false));
}
function countKeys(o) {
    if (Array.isArray(o)) {
        return o.length + o.map(countKeys).reduce(function (a, b) { return a + b; }, 0);
    }
    else if (typeof o === 'object' && o !== null) {
        return (Object.keys(o).length +
            Object.keys(o)
                .map(function (k) { return countKeys(o[k]); })
                .reduce(function (a, b) { return a + b; }, 0));
    }
    return 0;
}
function generateHashCode(o) {
    if (o === null || typeof o !== 'object')
        return undefined;
    var str = JSON.stringify(o);
    var keyCount = countKeys(o);
    var charSum = str.split('').reduce(function (a, b) { return a + b.charCodeAt(0); }, 0);
    return [str.length, keyCount, charSum].map(function (e) { return e.toString(36); }).join('');
}

var TOURNAMENT_RECORDS = 'tournamentRecords';
var POLICY_DEFINITIONS = 'policyDefinitions';
var TOURNAMENT_RECORD = 'tournamentRecord';
var DRAW_DEFINITION = 'drawDefinition';
var MATCHUP_FORMAT = 'matchUpFormat';
var PARTICIPANT_ID = 'participantId';
var SCHEDULE_DATES = 'scheduleDates';
var TOURNAMENT_ID = 'tournamentId';
var SCHEDULE_DATE = 'scheduleDate';
var STRUCTURE_ID = 'structureId';
var PARTICIPANT = 'participant';
var MATCHUP_IDS = 'matchUpIds';
var POLICY_TYPE = 'policyType';
var STRUCTURES = 'structures';
var MATCHUP_ID = 'matchUpId';
var IN_CONTEXT = 'inContext';
var STRUCTURE = 'structure';
var COURT_IDS = 'courtIds';
var PERSON_ID = 'personId';
var VENUE_IDS = 'venueIds';
var MATCHUPS = 'matchUps';
var COURT_ID = 'courtId';
var EVENT_ID = 'eventId';
var MATCHUP = 'matchUp';
var DRAW_ID = 'drawId';
var ERROR = 'error';
var EVENT = 'event';
var PARAM = 'param';
var UUIDS$1 = 'uuids';
var AVERAGE_MATCHUP_MINUTES = 'averageMatchUpMinutes';
var RECOVERY_MINUTES = 'recoveryMinutes';
var PERIOD_LENGTH = 'periodLength';
var OBJECT = 'object';
var ARRAY = 'array';
var VALIDATE = 'validate';
var INVALID = 'invalid';
var OF_TYPE = '_ofType';
var ANY_OF = '_anyOf';
var ONE_OF = '_oneOf';

var _a$k, _b$8;
var errors = (_a$k = {},
    _a$k[TOURNAMENT_RECORDS] = MISSING_TOURNAMENT_RECORDS,
    _a$k[TOURNAMENT_RECORD] = MISSING_TOURNAMENT_RECORD,
    _a$k[POLICY_DEFINITIONS] = MISSING_POLICY_DEFINITION,
    _a$k[DRAW_DEFINITION] = MISSING_DRAW_DEFINITION,
    _a$k[PARTICIPANT_ID] = MISSING_PARTICIPANT_ID,
    _a$k[TOURNAMENT_ID] = MISSING_TOURNAMENT_ID,
    _a$k[STRUCTURE_ID] = MISSING_STRUCTURE_ID,
    _a$k[MATCHUP_IDS] = MISSING_MATCHUP_IDS,
    _a$k[PARTICIPANT] = MISSING_PARTICIPANT,
    _a$k[STRUCTURES] = MISSING_STRUCTURES,
    _a$k[MATCHUP_ID] = MISSING_MATCHUP_ID,
    _a$k[STRUCTURE] = MISSING_STRUCTURE,
    _a$k[COURT_ID] = MISSING_COURT_ID,
    _a$k[MATCHUPS] = MISSING_MATCHUPS,
    _a$k[MATCHUP] = MISSING_MATCHUP,
    _a$k[COURT_IDS] = MISSING_VALUE,
    _a$k[VENUE_IDS] = MISSING_VALUE,
    _a$k[DRAW_ID] = MISSING_DRAW_ID,
    _a$k[EVENT_ID] = MISSING_EVENT,
    _a$k[EVENT] = EVENT_NOT_FOUND,
    _a$k);
var paramTypes = (_b$8 = {},
    _b$8[TOURNAMENT_RECORDS] = OBJECT,
    _b$8[POLICY_DEFINITIONS] = OBJECT,
    _b$8[TOURNAMENT_RECORD] = OBJECT,
    _b$8[DRAW_DEFINITION] = OBJECT,
    _b$8[SCHEDULE_DATES] = ARRAY,
    _b$8[PARTICIPANT] = OBJECT,
    _b$8[MATCHUP_IDS] = ARRAY,
    _b$8[STRUCTURES] = ARRAY,
    _b$8[STRUCTURE] = OBJECT,
    _b$8[COURT_IDS] = ARRAY,
    _b$8[VENUE_IDS] = ARRAY,
    _b$8[MATCHUPS] = ARRAY,
    _b$8[MATCHUP] = OBJECT,
    _b$8[EVENT] = OBJECT,
    _b$8[UUIDS$1] = ARRAY,
    _b$8);
function checkRequiredParameters(params, requiredParams, stack) {
    if (!params && !isObject(params))
        return { error: INVALID_VALUES };
    if (!(requiredParams === null || requiredParams === void 0 ? void 0 : requiredParams.length) || (params === null || params === void 0 ? void 0 : params._bypassParamCheck))
        return { valid: true };
    if (!Array.isArray(requiredParams))
        return { error: INVALID_VALUES };
    var _a = findParamError(params, requiredParams), paramError = _a.paramError, errorParam = _a.errorParam;
    if (!paramError)
        return { valid: true };
    var error = params[errorParam] === undefined
        ? errors[errorParam] || INVALID_VALUES
        : (paramError.validate && paramError.invalid) || INVALID_VALUES;
    return decorateResult({
        info: { param: errorParam },
        result: { error: error },
        stack: stack,
    });
}
function getIntersection(params, constraint) {
    var paramKeys = Object.keys(params);
    var constraintKeys = Object.keys(constraint);
    return intersection(paramKeys, constraintKeys);
}
function getOneOf(params, _oneOf) {
    if (!_oneOf)
        return;
    var overlap = getIntersection(params, _oneOf);
    if (overlap.length !== 1)
        return { error: INVALID_VALUES };
    return overlap.reduce(function (attr, param) {
        var _a;
        return (__assign(__assign({}, attr), (_a = {}, _a[param] = true, _a)));
    }, {});
}
function getAnyOf(params, _anyOf) {
    if (!_anyOf)
        return;
    var overlap = getIntersection(params, _anyOf).filter(function (param) { return params[param]; });
    if (overlap.length < 1)
        return { error: INVALID_VALUES };
    return overlap.reduce(function (attr, param) {
        var _a;
        return (__assign(__assign({}, attr), (_a = {}, _a[param] = true, _a)));
    }, {});
}
function findParamError(params, requiredParams) {
    var errorParam;
    var paramError = requiredParams.find(function (_a) {
        var _ofType = _a._ofType, _oneOf = _a._oneOf, _anyOf = _a._anyOf, validate = _a.validate, attrs = __rest(_a, ["_ofType", "_oneOf", "_anyOf", "validate"]);
        var oneOf = _oneOf && getOneOf(params, _oneOf);
        if (oneOf === null || oneOf === void 0 ? void 0 : oneOf.error)
            return oneOf.error;
        oneOf && Object.assign(attrs, oneOf);
        var anyOf = _anyOf && getAnyOf(params, _anyOf);
        if (anyOf === null || anyOf === void 0 ? void 0 : anyOf.error)
            return anyOf.error;
        anyOf && Object.assign(attrs, anyOf);
        var booleanParams = Object.keys(attrs).filter(function (key) { return typeof attrs[key] === 'boolean'; });
        var invalidParam = booleanParams.find(function (param) {
            var invalidValidationFunction = validate && !isFunction(validate); // validate is specified but not a function
            var faliedTypeCheck = params[param] && !validate && invalidType(params, param, _ofType); // param is present, no validation function provided, and invalid type
            var paramNotPresent = attrs[param] && !params[param]; // attrs[param] boolean value is true and param is not present
            var invalid = invalidValidationFunction || faliedTypeCheck || paramNotPresent;
            var hasError = invalid || (validate && params[param] && !checkValidation(params[param], validate));
            if (hasError)
                errorParam = param;
            return hasError;
        });
        return !booleanParams.length || invalidParam;
    });
    return { paramError: paramError, errorParam: errorParam };
}
function invalidType(params, param, _ofType) {
    _ofType = _ofType || paramTypes[param] || 'string';
    if (_ofType === 'array') {
        return !Array.isArray(params[param]);
    }
    return typeof params[param] !== _ofType;
}
function checkValidation(value, validate) {
    if (isFunction(validate))
        return validate(value);
    return true;
}

var SINGLES$1 = 'SINGLES';
var SINGLES_EVENT = 'SINGLES';
var DOUBLES$1 = 'DOUBLES';
var DOUBLES_EVENT = 'DOUBLES';
var TEAM$2 = 'TEAM';
var TEAM_EVENT = 'TEAM';
var AGE = 'AGE';
var RATING$2 = 'RATING';
var BOTH = 'BOTH';
var eventConstants = {
    AGE: AGE,
    BOTH: BOTH,
    DOUBLES: DOUBLES$1,
    DOUBLES_EVENT: DOUBLES_EVENT,
    RATING: RATING$2,
    SINGLES: SINGLES$1,
    SINGLES_EVENT: SINGLES_EVENT,
    TEAM_EVENT: TEAM_EVENT,
    TEAM: TEAM$2,
};

var DYNAMIC = 'DYNAMIC';
var RANKING$1 = 'RANKING';
var RATING$1 = 'RATING';
var SCALE$1 = 'SCALE';
var SEEDING$1 = 'SEEDING';
var scaleConstants = {
    RANKING: RANKING$1,
    RATING: RATING$1,
    SCALE: SCALE$1,
    SEEDING: SEEDING$1,
};

function getScaleValues(params) {
    var _a, e_1, _b;
    var _c;
    var paramCheck = checkRequiredParameters(params, [(_a = {}, _a[PARTICIPANT] = true, _a)]);
    if (paramCheck.error)
        return paramCheck;
    var scaleItems = (_c = params.participant.timeItems) === null || _c === void 0 ? void 0 : _c.filter(function (_a) {
        var itemType = _a.itemType;
        return (itemType === null || itemType === void 0 ? void 0 : itemType.startsWith(SCALE$1)) && [RANKING$1, RATING$1, SEEDING$1].includes(itemType.split('.')[1]);
    });
    var scales = { ratings: {}, rankings: {}, seedings: {} };
    if (scaleItems === null || scaleItems === void 0 ? void 0 : scaleItems.length) {
        var latestScaleItem = function (scaleType) {
            return scaleItems
                .filter(function (timeItem) { return (timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType) === scaleType; })
                .sort(function (a, b) { return new Date(a.createdAt || undefined).getTime() - new Date(b.createdAt || undefined).getTime(); })
                .pop();
        };
        var itemTypes = unique(scaleItems.map(function (_a) {
            var itemType = _a.itemType;
            return itemType;
        }));
        try {
            for (var itemTypes_1 = __values(itemTypes), itemTypes_1_1 = itemTypes_1.next(); !itemTypes_1_1.done; itemTypes_1_1 = itemTypes_1.next()) {
                var itemType = itemTypes_1_1.value;
                var scaleItem = latestScaleItem(itemType);
                if (scaleItem) {
                    var _d = __read(scaleItem.itemType.split('.'), 5), type = _d[1], format = _d[2], scaleName = _d[3], modifier = _d[4];
                    var namedScale = modifier ? "".concat(scaleName, ".").concat(modifier) : scaleName;
                    var scaleType = (type === SEEDING$1 && 'seedings') || (type === RANKING$1 && 'rankings') || 'ratings';
                    if (!scales[scaleType][format])
                        scales[scaleType][format] = [];
                    scales[scaleType][format].push({
                        scaleValue: scaleItem.itemValue,
                        scaleDate: scaleItem.itemDate,
                        scaleName: namedScale,
                    });
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (itemTypes_1_1 && !itemTypes_1_1.done && (_b = itemTypes_1.return)) _b.call(itemTypes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return __assign(__assign({}, SUCCESS), scales);
}

// NOTE: type really does need to be any!
function attributeFilter(params) {
    if (params === null)
        return {};
    var _a = params || {}, source = _a.source, template = _a.template;
    if (!template)
        return source;
    var target = {};
    attributeCopy(source, template, target);
    return target;
    function attributeCopy(valuesObject, templateObject, outputObject) {
        var e_1, _a;
        if (!valuesObject || !templateObject)
            return undefined;
        var vKeys = Object.keys(valuesObject);
        var oKeys = Object.keys(templateObject);
        // the orMap allows spcification of { 'a||b': boolean } so that filter templates can apply to multiple attributes
        var orMap = Object.assign.apply(Object, __spreadArray([{}], __read(oKeys
            .filter(function (key) { return key.indexOf('||'); })
            .map(function (key) { return key.split('||').map(function (or) {
            var _a;
            return (_a = {}, _a[or] = key, _a);
        }); })
            .flat()), false));
        var allKeys = oKeys.concat.apply(oKeys, __spreadArray([], __read(Object.keys(orMap)), false));
        var wildcard = allKeys.includes('*');
        var _loop_1 = function (vKey) {
            if (allKeys.indexOf(vKey) >= 0 || wildcard) {
                var templateKey = orMap[vKey] || vKey;
                var tobj_1 = templateObject[templateKey] || wildcard;
                var vobj = valuesObject[vKey];
                if (typeof tobj_1 === 'object' &&
                    typeof vobj !== 'function' &&
                    !Array.isArray(tobj_1)) {
                    if (Array.isArray(vobj)) {
                        var mappedElements = vobj
                            .map(function (arrayMember) {
                            var target = {};
                            var result = attributeCopy(arrayMember, tobj_1, target);
                            return result !== false ? target : undefined;
                        })
                            .filter(Boolean);
                        outputObject[vKey] = mappedElements;
                    }
                    else if (vobj) {
                        outputObject[vKey] = {};
                        attributeCopy(vobj, tobj_1, outputObject[vKey]);
                    }
                }
                else {
                    var value = valuesObject[vKey];
                    var exclude = Array.isArray(tobj_1) && !tobj_1.includes(value);
                    if (exclude)
                        return { value: false };
                    if (templateObject[vKey] ||
                        (wildcard && templateObject[vKey] !== false)) {
                        outputObject[vKey] = value;
                    }
                }
            }
        };
        try {
            for (var vKeys_1 = __values(vKeys), vKeys_1_1 = vKeys_1.next(); !vKeys_1_1.done; vKeys_1_1 = vKeys_1.next()) {
                var vKey = vKeys_1_1.value;
                var state_1 = _loop_1(vKey);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (vKeys_1_1 && !vKeys_1_1.done && (_a = vKeys_1.return)) _a.call(vKeys_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return undefined;
    }
}

var POLICY_TYPE_VOLUNTARY_CONSOLATION = 'voluntaryConsolation';
var POLICY_TYPE_COMPETITIVE_BANDS = 'competitiveBands';
var POLICY_TYPE_ROUND_ROBIN_TALLY = 'roundRobinTally';
var POLICY_TYPE_POSITION_ACTIONS = 'positionActions';
var POLICY_TYPE_MATCHUP_ACTIONS = 'matchUpActions';
var POLICY_TYPE_RANKING_POINTS = 'rankingPoints';
var POLICY_TYPE_ROUND_NAMING = 'roundNaming';
var POLICY_TYPE_PARTICIPANT = 'participant';
var POLICY_TYPE_PROGRESSION = 'progression';
var POLICY_TYPE_SCHEDULING = 'scheduling';
var POLICY_TYPE_AVOIDANCE = 'avoidance';
var POLICY_TYPE_DISPLAY = 'display'; // storage for client type displays, e.g. { public: {}, admin: {} }
var POLICY_TYPE_SCORING = 'scoring';
var POLICY_TYPE_SEEDING = 'seeding';
var POLICY_TYPE_FEED_IN = 'feedIn';
var POLICY_TYPE_AUDIT = 'audit';
var POLICY_TYPE_DRAWS = 'draws';
var policyConstants = {
    POLICY_TYPE_VOLUNTARY_CONSOLATION: POLICY_TYPE_VOLUNTARY_CONSOLATION,
    POLICY_TYPE_COMPETITIVE_BANDS: POLICY_TYPE_COMPETITIVE_BANDS,
    POLICY_TYPE_ROUND_ROBIN_TALLY: POLICY_TYPE_ROUND_ROBIN_TALLY,
    POLICY_TYPE_POSITION_ACTIONS: POLICY_TYPE_POSITION_ACTIONS,
    POLICY_TYPE_MATCHUP_ACTIONS: POLICY_TYPE_MATCHUP_ACTIONS,
    POLICY_TYPE_RANKING_POINTS: POLICY_TYPE_RANKING_POINTS,
    POLICY_TYPE_ROUND_NAMING: POLICY_TYPE_ROUND_NAMING,
    POLICY_TYPE_PARTICIPANT: POLICY_TYPE_PARTICIPANT,
    POLICY_TYPE_PROGRESSION: POLICY_TYPE_PROGRESSION,
    POLICY_TYPE_SCHEDULING: POLICY_TYPE_SCHEDULING,
    POLICY_TYPE_AVOIDANCE: POLICY_TYPE_AVOIDANCE,
    POLICY_TYPE_DISPLAY: POLICY_TYPE_DISPLAY,
    POLICY_TYPE_FEED_IN: POLICY_TYPE_FEED_IN,
    POLICY_TYPE_SCORING: POLICY_TYPE_SCORING,
    POLICY_TYPE_SEEDING: POLICY_TYPE_SEEDING,
    POLICY_TYPE_AUDIT: POLICY_TYPE_AUDIT,
    POLICY_TYPE_DRAWS: POLICY_TYPE_DRAWS,
};

function findParticipant(_a) {
    var _b = _a.tournamentParticipants, tournamentParticipants = _b === void 0 ? [] : _b, _c = _a.policyDefinitions, policyDefinitions = _c === void 0 ? {} : _c, contextProfile = _a.contextProfile, participantId = _a.participantId, internalUse = _a.internalUse, personId = _a.personId;
    var foundParticipant = tournamentParticipants.find(function (candidate) {
        return (participantId && candidate.participantId === participantId) ||
            (personId && candidate.person && candidate.person.personId === personId);
    });
    var participant = makeDeepCopy(foundParticipant, false, internalUse);
    if (participant) {
        var participantAttributes = policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_PARTICIPANT];
        if (contextProfile === null || contextProfile === void 0 ? void 0 : contextProfile.withScaleValues) {
            var _d = getScaleValues({ participant: participant }), ratings = _d.ratings, rankings = _d.rankings;
            participant.rankings = rankings;
            participant.ratings = ratings;
        }
        if (participantAttributes === null || participantAttributes === void 0 ? void 0 : participantAttributes.participant) {
            return attributeFilter({
                template: participantAttributes.participant,
                source: participant,
            });
        }
    }
    return participant;
}

function addTournamentExtension(params) {
    if (!params || typeof params !== 'object')
        return { error: MISSING_VALUE };
    if (!params.tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    return addExtension({
        creationTime: params.creationTime,
        element: params.tournamentRecord,
        extension: params.extension,
    });
}
function addDrawDefinitionExtension(params) {
    if (!params || typeof params !== 'object')
        return { error: MISSING_VALUE };
    if (!params.drawDefinition)
        return { error: DRAW_DEFINITION_NOT_FOUND };
    return addExtension({
        creationTime: params.creationTime,
        element: params.drawDefinition,
        extension: params.extension,
    });
}
function addEventExtension(params) {
    if (!params || typeof params !== 'object')
        return { error: MISSING_VALUE };
    if (!params.event)
        return { error: EVENT_NOT_FOUND };
    return addExtension({
        creationTime: params.creationTime,
        extension: params.extension,
        element: params.event,
    });
}
function addParticipantExtension(params) {
    var _a;
    if (!params || typeof params !== 'object')
        return { error: MISSING_VALUE };
    if (!params.participantId)
        return { error: MISSING_PARTICIPANT_ID };
    var tournamentParticipants = ((_a = params.tournamentRecord) === null || _a === void 0 ? void 0 : _a.participants) || [];
    var participant = findParticipant({
        participantId: params.participantId,
        tournamentParticipants: tournamentParticipants,
    });
    if (!participant)
        return { error: PARTICIPANT_NOT_FOUND };
    return addExtension({
        creationTime: params.creationTime,
        extension: params.extension,
        element: participant,
    });
}
function removeTournamentExtension(params) {
    if (!params || typeof params !== 'object')
        return { error: MISSING_VALUE };
    if (!params.tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    return removeExtension({
        element: params.tournamentRecord,
        name: params.name,
    });
}
function removeDrawDefinitionExtension(params) {
    if (!params || typeof params !== 'object')
        return { error: MISSING_VALUE };
    if (!params.drawDefinition)
        return { error: DRAW_DEFINITION_NOT_FOUND };
    return removeExtension({ element: params.drawDefinition, name: params.name });
}
function removeEventExtension(params) {
    if (!params || typeof params !== 'object')
        return { error: MISSING_VALUE };
    if (!(params === null || params === void 0 ? void 0 : params.event))
        return { error: EVENT_NOT_FOUND };
    return removeExtension({ element: params.event, name: params.name });
}
function removeParticipantExtension(params) {
    var _a;
    if (!params || typeof params !== 'object')
        return { error: MISSING_VALUE };
    if (!params.participantId)
        return { error: MISSING_PARTICIPANT_ID };
    var tournamentParticipants = ((_a = params.tournamentRecord) === null || _a === void 0 ? void 0 : _a.participants) || [];
    var participant = findParticipant({
        participantId: params.participantId,
        tournamentParticipants: tournamentParticipants,
    });
    if (!participant)
        return { error: PARTICIPANT_NOT_FOUND };
    return removeExtension({ element: participant, name: params.name });
}

var ACTIVE_SUSPENSION = 'activeSuspension';
var APPLIED_POLICIES = 'appliedPolicies';
var AUDIT_POSITION_ACTIONS = 'positionActions';
var CONTEXT = 'context';
var DELEGATED_OUTCOME = 'delegatedOutcome';
var DISABLED = 'disabled';
var DISABLE_LINKS = 'disableLinks';
var DISABLE_AUTO_CALC = 'disableAutoCalc';
var DRAW_DELETIONS = 'drawDeletions';
var DRAW_PROFILE = 'drawProfile';
var ENTRY_PROFILE = 'entryProfile';
var EVENT_PROFILE = 'eventProfile';
var EVENT_WITHDRAWAL_REQUESTS = 'eventWithdrawalRequests';
var FACTORY$1 = 'factory';
var FLIGHT_PROFILE = 'flightProfile';
var GROUPING_ATTRIBUTE = 'groupingAttribute';
var LINEUPS = 'lineUps';
var LINKED_TOURNAMENTS = 'linkedTournamentsIds';
var MATCHUP_HISTORY = 'matchUpHistory';
var PARTICIPANT_REPRESENTATIVES = 'participantRepresentatives';
var PERSON_REQUESTS = 'personRequests';
var RANKING_POINTS = 'rankingPoints';
var ROUND_TARGET = 'roundTarget';
var SCHEDULE_LIMITS = 'scheduleLimits';
var SCHEDULE_TIMING = 'scheduleTiming';
var SCHEDULING_PROFILE = 'schedulingProfile';
var STATUS_DETAIL = 'statusDetail';
var SUB_ORDER = 'subOrder';
var TALLY = 'tally';
var TIE_FORMAT_MODIFICATIONS = 'tieFormatModification';
var extensionConstants = {
    ACTIVE_SUSPENSION: ACTIVE_SUSPENSION,
    APPLIED_POLICIES: APPLIED_POLICIES,
    AUDIT_POSITION_ACTIONS: AUDIT_POSITION_ACTIONS,
    CONTEXT: CONTEXT, // used to capture, e.g. context in which a venue was added
    DELEGATED_OUTCOME: DELEGATED_OUTCOME,
    DISABLED: DISABLED,
    DISABLE_LINKS: DISABLE_LINKS,
    DISABLE_AUTO_CALC: DISABLE_AUTO_CALC,
    DRAW_DELETIONS: DRAW_DELETIONS,
    DRAW_PROFILE: DRAW_PROFILE,
    ENTRY_PROFILE: ENTRY_PROFILE, // used for drawGeneration; not relevant for anonymized tournaments
    EVENT_PROFILE: EVENT_PROFILE,
    EVENT_WITHDRAWAL_REQUESTS: EVENT_WITHDRAWAL_REQUESTS,
    FLIGHT_PROFILE: FLIGHT_PROFILE,
    GROUPING_ATTRIBUTE: GROUPING_ATTRIBUTE, // for generating teams; not relevant for anonymized tournaments
    LINEUPS: LINEUPS,
    LINKED_TOURNAMENTS: LINKED_TOURNAMENTS,
    MATCHUP_HISTORY: MATCHUP_HISTORY,
    PARTICIPANT_REPRESENTATIVES: PARTICIPANT_REPRESENTATIVES,
    PERSON_REQUESTS: PERSON_REQUESTS,
    RANKING_POINTS: RANKING_POINTS, // for attaching points awarded to tournamentRecord
    ROUND_TARGET: ROUND_TARGET,
    SCHEDULE_LIMITS: SCHEDULE_LIMITS,
    SCHEDULE_TIMING: SCHEDULE_TIMING,
    SCHEDULING_PROFILE: SCHEDULING_PROFILE,
    STATUS_DETAIL: STATUS_DETAIL, // attached to event.entries
    SUB_ORDER: SUB_ORDER,
    TALLY: TALLY,
    TIE_FORMAT_MODIFICATIONS: TIE_FORMAT_MODIFICATIONS, // for auditing, not important when anonymized
    FACTORY: FACTORY$1,
};
var internalExtensions = [
    DELEGATED_OUTCOME,
    DISABLED,
    DISABLE_LINKS,
    FLIGHT_PROFILE,
    LINEUPS,
    MATCHUP_HISTORY,
    PARTICIPANT_REPRESENTATIVES,
    PERSON_REQUESTS,
    ROUND_TARGET,
    SCHEDULE_LIMITS,
    SCHEDULE_TIMING,
    SCHEDULING_PROFILE,
    SUB_ORDER,
    TALLY,
];

function getTournamentIds(_a) {
    var tournamentRecords = _a.tournamentRecords;
    var tournamentIds = isObject(tournamentRecords)
        ? Object.keys(tournamentRecords)
        : [];
    return __assign({ tournamentIds: tournamentIds }, SUCCESS);
}

/**
 * Links all tournaments which are currently loaded into competitionEngine state
 */
function linkTournaments(_a) {
    var tournamentRecords = _a.tournamentRecords;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var result = getTournamentIds({ tournamentRecords: tournamentRecords });
    var tournamentIds = result.tournamentIds;
    if ((tournamentIds === null || tournamentIds === void 0 ? void 0 : tournamentIds.length) > 1) {
        var extension = {
            name: LINKED_TOURNAMENTS,
            value: { tournamentIds: tournamentIds },
        };
        return addExtension({
            tournamentRecords: tournamentRecords,
            discover: true,
            extension: extension,
        });
    }
    return __assign({}, SUCCESS);
}
function unlinkTournaments(_a) {
    var tournamentRecords = _a.tournamentRecords;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var result = removeExtension({
        name: LINKED_TOURNAMENTS,
        tournamentRecords: tournamentRecords,
        discover: true,
    });
    // TODO: check the integrity of the venues attached to each tournment...
    // get all competitionScheduleMatchUps and ensure that each tournamentRecord has all venues for scheduled matchUps
    return decorateResult({ result: result, stack: 'unlinkTournaments' });
}
function unlinkTournament(_a) {
    var tournamentRecords = _a.tournamentRecords, tournamentId = _a.tournamentId;
    if (typeof tournamentRecords !== 'object')
        return { error: INVALID_VALUES };
    if (!tournamentId)
        return { error: MISSING_TOURNAMENT_ID };
    var result = getTournamentIds({ tournamentRecords: tournamentRecords });
    var tournamentIds = result.tournamentIds;
    if (!tournamentIds.includes(tournamentId))
        return { error: MISSING_TOURNAMENT_ID };
    // not using bulk update function here to handle scenario where
    // tournamentRecords loaded into state are not all linked
    var unlinkError;
    tournamentIds.every(function (currentTournamentId) {
        var _a;
        var tournamentRecord = tournamentRecords[currentTournamentId];
        var extension = findExtension({
            element: tournamentRecord,
            name: LINKED_TOURNAMENTS,
        }).extension;
        // if there is no extension return { ...SUCCESS } because no links exist
        if (!extension)
            return true;
        var linkedTournamentIds = ((_a = extension === null || extension === void 0 ? void 0 : extension.value) === null || _a === void 0 ? void 0 : _a.tournamentIds) || [];
        // if there are no tournamentIds
        if (!(linkedTournamentIds === null || linkedTournamentIds === void 0 ? void 0 : linkedTournamentIds.length) ||
            (linkedTournamentIds.length === 1 &&
                linkedTournamentIds.includes(tournamentId)) ||
            currentTournamentId === tournamentId) {
            var result_1 = removeTournamentExtension({
                name: LINKED_TOURNAMENTS,
                tournamentRecord: tournamentRecord,
            });
            if (result_1.error)
                unlinkError = result_1.error;
            return result_1.success;
        }
        var tournamentIds = linkedTournamentIds.filter(function (linkedTournamentId) { return linkedTournamentId !== tournamentId; });
        extension.value = { tournamentIds: tournamentIds };
        var result = addTournamentExtension({ tournamentRecord: tournamentRecord, extension: extension });
        if (result.error)
            unlinkError = result.error;
        return result.success;
    });
    return unlinkError ? { error: unlinkError } : __assign({}, SUCCESS);
}

var competitionGovernor = {
    linkTournaments: linkTournaments,
    unlinkTournament: unlinkTournament,
    unlinkTournaments: unlinkTournaments,
};

var extractor = function (object) { return function (attr) { return object[attr]; }; };
var getMatchUpIds = function (o) {
    if (o === void 0) { o = []; }
    return o.map(getMatchUpId).filter(Boolean);
};
var getParticipantIds = function (o) {
    if (o === void 0) { o = []; }
    return o.map(getParticipantId).filter(Boolean);
};
var getParticipantId = function (o) {
    if (o === void 0) { o = {}; }
    return extractor(o)('participantId');
};
var getMatchUpId = function (o) {
    if (o === void 0) { o = {}; }
    return extractor(o)('matchUpId');
};

function setDrawParticipantRepresentativeIds(_a) {
    var representativeParticipantIds = _a.representativeParticipantIds, drawDefinition = _a.drawDefinition;
    if (!drawDefinition)
        return { error: DRAW_DEFINITION_NOT_FOUND };
    if (!Array.isArray(representativeParticipantIds))
        return { error: INVALID_VALUES };
    var enteredParticipantIds = getParticipantIds((drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) || []);
    // An empty array is valid; if ids provided...
    // check that all representativeParticipantIds are enteredParticipantIds
    if (representativeParticipantIds.length &&
        intersection(representativeParticipantIds, enteredParticipantIds).length <
            representativeParticipantIds.length) {
        return { error: INVALID_VALUES };
    }
    var extension = {
        name: PARTICIPANT_REPRESENTATIVES,
        value: representativeParticipantIds,
    };
    return addDrawDefinitionExtension({ drawDefinition: drawDefinition, extension: extension });
}

var ABANDONED$1 = 'ABANDONED';
var AWAITING_RESULT = 'AWAITING_RESULT';
var BYE = 'BYE';
var CANCELLED$1 = 'CANCELLED';
var COMPLETED$1 = 'COMPLETED';
var DEAD_RUBBER = 'DEAD_RUBBER';
var DEFAULTED = 'DEFAULTED';
var DOUBLE_DEFAULT = 'DOUBLE_DEFAULT';
var DOUBLE_WALKOVER = 'DOUBLE_WALKOVER';
var IN_PROGRESS$1 = 'IN_PROGRESS';
var INCOMPLETE = 'INCOMPLETE';
var NOT_PLAYED = 'NOT_PLAYED';
var RETIRED$1 = 'RETIRED';
var SUSPENDED = 'SUSPENDED';
var TO_BE_PLAYED = 'TO_BE_PLAYED';
var WALKOVER$2 = 'WALKOVER';
var recoveryTimeRequiredMatchUpStatuses = [
    AWAITING_RESULT,
    COMPLETED$1,
    DEFAULTED,
    IN_PROGRESS$1,
    INCOMPLETE,
    RETIRED$1,
    SUSPENDED,
];
var particicipantsRequiredMatchUpStatuses = [
    AWAITING_RESULT,
    COMPLETED$1,
    DEFAULTED,
    DOUBLE_WALKOVER,
    DOUBLE_DEFAULT,
    IN_PROGRESS$1,
    INCOMPLETE,
    RETIRED$1,
    SUSPENDED,
    WALKOVER$2,
];
var validMatchUpStatuses = [
    ABANDONED$1,
    AWAITING_RESULT,
    BYE,
    CANCELLED$1,
    COMPLETED$1,
    DEAD_RUBBER,
    DEFAULTED,
    DOUBLE_WALKOVER,
    DOUBLE_DEFAULT,
    IN_PROGRESS$1,
    INCOMPLETE,
    NOT_PLAYED,
    RETIRED$1,
    SUSPENDED,
    TO_BE_PLAYED,
    WALKOVER$2,
];
var directingMatchUpStatuses = [
    BYE,
    DOUBLE_WALKOVER, // directing because of a produced WALKOVER
    DOUBLE_DEFAULT, // directing because of a produced WALKOVER
    COMPLETED$1,
    DEFAULTED,
    RETIRED$1,
    WALKOVER$2,
];
var nonDirectingMatchUpStatuses = [
    ABANDONED$1,
    AWAITING_RESULT,
    CANCELLED$1,
    DEAD_RUBBER,
    IN_PROGRESS$1,
    INCOMPLETE,
    NOT_PLAYED,
    SUSPENDED,
    TO_BE_PLAYED,
    undefined,
];
var completedMatchUpStatuses = [
    CANCELLED$1,
    ABANDONED$1,
    COMPLETED$1,
    DEAD_RUBBER,
    DEFAULTED,
    DOUBLE_WALKOVER,
    DOUBLE_DEFAULT,
    RETIRED$1,
    WALKOVER$2,
];
var activeMatchUpStatuses = [
    ABANDONED$1,
    COMPLETED$1,
    DEFAULTED,
    DOUBLE_WALKOVER,
    DOUBLE_DEFAULT,
    IN_PROGRESS$1,
    RETIRED$1,
    WALKOVER$2,
];
var upcomingMatchUpStatuses = [
    IN_PROGRESS$1,
    INCOMPLETE,
    SUSPENDED,
    TO_BE_PLAYED,
];
var matchUpStatusConstants = {
    ABANDONED: ABANDONED$1,
    AWAITING_RESULT: AWAITING_RESULT,
    BYE: BYE,
    CANCELLED: CANCELLED$1,
    COMPLETED: COMPLETED$1,
    DEAD_RUBBER: DEAD_RUBBER,
    DEFAULTED: DEFAULTED,
    DOUBLE_WALKOVER: DOUBLE_WALKOVER,
    DOUBLE_DEFAULT: DOUBLE_DEFAULT,
    IN_PROGRESS: IN_PROGRESS$1,
    INCOMPLETE: INCOMPLETE,
    NOT_PLAYED: NOT_PLAYED,
    RETIRED: RETIRED$1,
    SUSPENDED: SUSPENDED,
    TO_BE_PLAYED: TO_BE_PLAYED,
    WALKOVER: WALKOVER$2,
};

var _a$j, _b$7, _c$1;
// stage types
var MAIN = 'MAIN';
var QUALIFYING = 'QUALIFYING';
var CONSOLATION = 'CONSOLATION';
var VOLUNTARY_CONSOLATION = 'VOLUNTARY_CONSOLATION';
var PLAY_OFF = 'PLAY_OFF';
var validStages = [
    MAIN,
    QUALIFYING,
    CONSOLATION,
    PLAY_OFF,
    VOLUNTARY_CONSOLATION,
];
var stageOrder$1 = (_a$j = {},
    _a$j[QUALIFYING] = 1,
    _a$j[MAIN] = 2,
    _a$j[PLAY_OFF] = 3,
    _a$j[CONSOLATION] = 3,
    _a$j[VOLUNTARY_CONSOLATION] = 4,
    _a$j);
var FINISHING_POSITIONS = 'finishingPositions';
var AGGREGATE_EVENT_STRUCTURES = 'aggregateEventStructures';
var finishOrder = (_b$7 = {},
    _b$7[MAIN] = 1,
    _b$7[PLAY_OFF] = 2,
    _b$7[CONSOLATION] = 3,
    _b$7[QUALIFYING] = 4,
    _b$7[VOLUNTARY_CONSOLATION] = 5,
    _b$7);
// for aggregateOrder { stage: MAIN, stageSequence: 1 } is always first
var aggregateOrder = (_c$1 = {},
    _c$1[PLAY_OFF] = 1,
    _c$1[MAIN] = 2,
    _c$1[CONSOLATION] = 3,
    _c$1[QUALIFYING] = 4,
    _c$1[VOLUNTARY_CONSOLATION] = 5,
    _c$1);
// seedingProfile.positioning
var CLUSTER = 'CLUSTER';
var SEPARATE = 'SEPARATE';
var WATERFALL = 'WATERFALL';
// structureType
var ITEM = 'ITEM';
var CONTAINER = 'CONTAINER';
// positioningProfile
var DRAW = 'DRAW';
var RANDOM = 'RANDOM';
var TOP_DOWN = 'TOP_DOWN';
var BOTTOM_UP = 'BOTTOM_UP';
// Match and Link types
var POSITION = 'POSITION'; // participant advances based on their finishing position
var WINNER = 'WINNER'; // participant advances based on winning a matchUp
var LOSER = 'LOSER'; // partticipant advances based on losing a matchUp
var FIRST_MATCHUP = 'FIRST_MATCHUP'; // condition for valididty of link
// draw types
// PLAY_OFF is also a stage type
var AD_HOC = 'AD_HOC';
var FLEX_ROUNDS = 'AD_HOC';
var FEED_IN$1 = 'FEED_IN';
var COMPASS = 'COMPASS';
var OLYMPIC = 'OLYMPIC';
var KNOCKOUT = 'SINGLE_ELIMINATION';
var SINGLE_ELIMINATION = 'SINGLE_ELIMINATION';
var DOUBLE_ELIMINATION = 'DOUBLE_ELIMINATION';
var FIRST_MATCH_LOSER_CONSOLATION = 'FIRST_MATCH_LOSER_CONSOLATION';
var FIRST_ROUND_LOSER_CONSOLATION = 'FIRST_ROUND_LOSER_CONSOLATION';
var LUCKY_DRAW = 'LUCKY_DRAW';
var CURTIS = 'CURTIS_CONSOLATION';
var CURTIS_CONSOLATION = 'CURTIS_CONSOLATION';
var FICSF = 'FEED_IN_CHAMPIONSHIP_TO_SF';
var FEED_IN_CHAMPIONSHIP_TO_SF = 'FEED_IN_CHAMPIONSHIP_TO_SF';
var FICQF = 'FEED_IN_CHAMPIONSHIP_TO_QF';
var FEED_IN_CHAMPIONSHIP_TO_QF = 'FEED_IN_CHAMPIONSHIP_TO_QF';
var FICR16 = 'FEED_IN_CHAMPIONSHIP_TO_R16';
var FEED_IN_CHAMPIONSHIP_TO_R16 = 'FEED_IN_CHAMPIONSHIP_TO_R16';
var MFIC = 'MODIFIED_FEED_IN_CHAMPIONSHIP';
var MODIFIED_FEED_IN_CHAMPIONSHIP = 'MODIFIED_FEED_IN_CHAMPIONSHIP';
var FEED_IN_CHAMPIONSHIP = 'FEED_IN_CHAMPIONSHIP';
var ROUND_ROBIN = 'ROUND_ROBIN';
var ROUND_ROBIN_WITH_PLAYOFF = 'ROUND_ROBIN_WITH_PLAYOFF';
// structure naming
var DECIDER = 'DECIDER';
var BACKDRAW = 'BACKDRAW';
var COMPASS_ATTRIBUTES = {
    0: { name: 'East', abbreviation: 'E' },
    '0-1': { name: 'West', abbreviation: 'W' },
    '0-2': { name: 'North', abbreviation: 'N' },
    '0-3': { name: 'Northeast', abbreviation: 'NE' },
    '0-1-1': { name: 'South', abbreviation: 'S' },
    '0-1-2': { name: 'Southwest', abbreviation: 'SW' },
    '0-2-1': { name: 'Northwest', abbreviation: 'NW' },
    '0-1-1-1': { name: 'Southeast', abbreviation: 'SE' },
};
var OLYMPIC_ATTRIBUTES = {
    0: { name: 'East', abbreviation: 'E' },
    '0-1': { name: 'West', abbreviation: 'W' },
    '0-2': { name: 'North', abbreviation: 'N' },
    '0-1-1': { name: 'South', abbreviation: 'S' },
};
// finishingPosition determination
var WIN_RATIO$1 = 'WIN_RATIO';
var ROUND_OUTCOME = 'ROUND_OUTCOME';
var MULTI_STRUCTURE_DRAWS = [
    COMPASS,
    CURTIS,
    FEED_IN_CHAMPIONSHIP_TO_QF,
    FEED_IN_CHAMPIONSHIP_TO_R16,
    FEED_IN_CHAMPIONSHIP_TO_SF,
    FEED_IN_CHAMPIONSHIP,
    FICQF,
    FICR16,
    FICSF,
    FIRST_MATCH_LOSER_CONSOLATION,
    FIRST_ROUND_LOSER_CONSOLATION,
    LUCKY_DRAW,
    MODIFIED_FEED_IN_CHAMPIONSHIP,
    OLYMPIC,
    PLAY_OFF,
    ROUND_ROBIN_WITH_PLAYOFF,
];
var generatedDrawTypes = [
    AD_HOC,
    COMPASS,
    CURTIS,
    DOUBLE_ELIMINATION,
    FEED_IN_CHAMPIONSHIP_TO_QF,
    FEED_IN_CHAMPIONSHIP_TO_R16,
    FEED_IN_CHAMPIONSHIP_TO_SF,
    FEED_IN_CHAMPIONSHIP,
    FEED_IN$1,
    FIRST_MATCH_LOSER_CONSOLATION,
    FIRST_ROUND_LOSER_CONSOLATION,
    LUCKY_DRAW,
    MODIFIED_FEED_IN_CHAMPIONSHIP,
    OLYMPIC,
    PLAY_OFF,
    ROUND_ROBIN,
    ROUND_ROBIN_WITH_PLAYOFF,
    SINGLE_ELIMINATION,
];
var drawDefinitionConstants = {
    MAIN: MAIN,
    QUALIFYING: QUALIFYING,
    CONSOLATION: CONSOLATION,
    ITEM: ITEM,
    CONTAINER: CONTAINER,
    FIRST_MATCHUP: FIRST_MATCHUP,
    WINNER: WINNER,
    LOSER: LOSER,
    AD_HOC: AD_HOC,
    FEED_IN: FEED_IN$1,
    FLEX_ROUNDS: FLEX_ROUNDS,
    COMPASS: COMPASS,
    PLAY_OFF: PLAY_OFF,
    OLYMPIC: OLYMPIC,
    KNOCKOUT: KNOCKOUT,
    SINGLE_ELIMINATION: SINGLE_ELIMINATION,
    DOUBLE_ELIMINATION: DOUBLE_ELIMINATION,
    CURTIS: CURTIS,
    FICSF: FICSF,
    FICQF: FICQF,
    FICR16: FICR16,
    MFIC: MFIC,
    VOLUNTARY_CONSOLATION: VOLUNTARY_CONSOLATION,
    FIRST_MATCH_LOSER_CONSOLATION: FIRST_MATCH_LOSER_CONSOLATION,
    FIRST_ROUND_LOSER_CONSOLATION: FIRST_ROUND_LOSER_CONSOLATION,
    MODIFIED_FEED_IN_CHAMPIONSHIP: MODIFIED_FEED_IN_CHAMPIONSHIP,
    FEED_IN_CHAMPIONSHIP_TO_R16: FEED_IN_CHAMPIONSHIP_TO_R16,
    FEED_IN_CHAMPIONSHIP_TO_QF: FEED_IN_CHAMPIONSHIP_TO_QF,
    FEED_IN_CHAMPIONSHIP_TO_SF: FEED_IN_CHAMPIONSHIP_TO_SF,
    FEED_IN_CHAMPIONSHIP: FEED_IN_CHAMPIONSHIP,
    LUCKY_DRAW: LUCKY_DRAW,
    ROUND_ROBIN_WITH_PLAYOFF: ROUND_ROBIN_WITH_PLAYOFF,
    ROUND_ROBIN: ROUND_ROBIN,
    DECIDER: DECIDER,
    BACKDRAW: BACKDRAW,
    COMPASS_ATTRIBUTES: COMPASS_ATTRIBUTES,
    OLYMPIC_ATTRIBUTES: OLYMPIC_ATTRIBUTES,
    DRAW: DRAW,
    RANDOM: RANDOM,
    TOP_DOWN: TOP_DOWN,
    BOTTOM_UP: BOTTOM_UP,
    WATERFALL: WATERFALL,
    WIN_RATIO: WIN_RATIO$1,
    ROUND_OUTCOME: ROUND_OUTCOME,
    MULTI_STRUCTURE_DRAWS: MULTI_STRUCTURE_DRAWS,
    generatedDrawTypes: generatedDrawTypes,
    stageOrder: stageOrder$1,
    finishOrder: finishOrder,
    AGGREGATE_EVENT_STRUCTURES: AGGREGATE_EVENT_STRUCTURES,
    FINISHING_POSITIONS: FINISHING_POSITIONS,
};

function structureSort(a, b, config) {
    var _a, _b, _c, _d, _e, _f;
    var getRoundTarget = function (element) { var _a, _b; return (_b = (_a = findExtension({ element: element, name: ROUND_TARGET })) === null || _a === void 0 ? void 0 : _a.extension) === null || _b === void 0 ? void 0 : _b.value; };
    var completed = config === null || config === void 0 ? void 0 : config.deprioritizeCompleted;
    var aggregate = (config === null || config === void 0 ? void 0 : config.mode) === AGGREGATE_EVENT_STRUCTURES && aggregateOrder;
    var finish = (config === null || config === void 0 ? void 0 : config.mode) === FINISHING_POSITIONS && finishOrder;
    var orderProtocol = finish || aggregate || stageOrder$1;
    var isMain1 = function (s) { return (s === null || s === void 0 ? void 0 : s.stage) === MAIN && (s === null || s === void 0 ? void 0 : s.stageSequence) === 1; };
    var protocolSequence = function (s) {
        return isMain1(s) ? -1 : orderProtocol[s === null || s === void 0 ? void 0 : s.stage];
    };
    var completedStructure = function (s) {
        return s === null || s === void 0 ? void 0 : s.matchUps.every(function (_a) {
            var matchUpStatus = _a.matchUpStatus;
            return completedMatchUpStatuses.includes(matchUpStatus) ? 1 : -1;
        });
    };
    return ((completed && completedStructure(a) - completedStructure(b)) ||
        (aggregate && protocolSequence(a) - protocolSequence(b)) ||
        (((a === null || a === void 0 ? void 0 : a.stage) && orderProtocol[a.stage]) || 0) -
            (((b === null || b === void 0 ? void 0 : b.stage) && orderProtocol[b.stage]) || 0) ||
        (getRoundTarget(a) || 0) - (getRoundTarget(b) || 0) ||
        (!finish &&
            !aggregate &&
            ((_b = (_a = b === null || b === void 0 ? void 0 : b.positionAssignments) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : Infinity) -
                ((_d = (_c = a === null || a === void 0 ? void 0 : a.positionAssignments) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : Infinity)) ||
        ((_e = a === null || a === void 0 ? void 0 : a.stageSequence) !== null && _e !== void 0 ? _e : 0) - ((_f = b === null || b === void 0 ? void 0 : b.stageSequence) !== null && _f !== void 0 ? _f : 0) ||
        (getMinFinishingPositionRange(a) || 0) -
            (getMinFinishingPositionRange(b) || 0));
}
function getMinFinishingPositionRange(structure) {
    return ((structure === null || structure === void 0 ? void 0 : structure.matchUps) || []).reduce(function (rangeSum, matchUp) {
        var _a;
        var sum = (((_a = matchUp.finishingPositionRange) === null || _a === void 0 ? void 0 : _a.winner) || []).reduce(function (a, b) { return a + b; }, 0);
        return !rangeSum || sum < rangeSum ? sum : rangeSum;
    }, undefined);
}

function findStructure(_a) {
    var drawDefinition = _a.drawDefinition, structureId = _a.structureId;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structureId)
        return { error: MISSING_STRUCTURE_ID };
    var structures = getDrawStructures({ drawDefinition: drawDefinition }).structures;
    var allStructures = structures === null || structures === void 0 ? void 0 : structures.map(function (structure) {
        return structure.structures
            ? __spreadArray([], __read(structure.structures), false).concat(structure)
            : structure;
    }).flat();
    var structure = allStructures === null || allStructures === void 0 ? void 0 : allStructures.find(function (structure) { return structure.structureId === structureId; });
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    var containingStructure = structure.structureType === ITEM
        ? allStructures === null || allStructures === void 0 ? void 0 : allStructures.find(function (s) { var _a; return (_a = s.structures) === null || _a === void 0 ? void 0 : _a.some(function (s) { return s.structureId === structureId; }); })
        : undefined;
    return { structure: structure, containingStructure: containingStructure };
}
function getDrawStructures(_a) {
    var _b, _c;
    var withStageGrouping = _a.withStageGrouping, drawDefinition = _a.drawDefinition, stageSequences = _a.stageSequences, stageSequence = _a.stageSequence, roundTarget = _a.roundTarget, sortConfig = _a.sortConfig, stages = _a.stages, stage = _a.stage;
    var error = (!drawDefinition && MISSING_DRAW_DEFINITION) ||
        (!(drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) && MISSING_STRUCTURES) ||
        undefined;
    if (error)
        return { error: error, structures: [], stageStructures: {} };
    var isRoundTarget = function (structure) {
        var _a, _b;
        var value = (_b = (_a = findExtension({
            element: structure,
            name: ROUND_TARGET,
        })) === null || _a === void 0 ? void 0 : _a.extension) === null || _b === void 0 ? void 0 : _b.value;
        return !roundTarget || roundTarget === value;
    };
    var structures = (_c = (_b = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) === null || _b === void 0 ? void 0 : _b.filter(isStage).filter(isStageSequence).filter(isRoundTarget).sort(function (a, b) { return structureSort(a, b, sortConfig); })) !== null && _c !== void 0 ? _c : [];
    var stageStructures = withStageGrouping
        ? Object.assign.apply(Object, __spreadArray([{}], __read(validStages
            .map(function (stage) {
            var _a;
            var relevantStructures = structures === null || structures === void 0 ? void 0 : structures.filter(function (structure) { return structure.stage === stage; });
            return ((relevantStructures === null || relevantStructures === void 0 ? void 0 : relevantStructures.length) && (_a = {}, _a[stage] = relevantStructures, _a));
        })
            .filter(Boolean)), false)) : {};
    return { structures: structures, stageStructures: stageStructures };
    function isStage(structure) {
        return ((!stage && !Array.isArray(stages)) ||
            (stage && structure.stage === stage) ||
            (Array.isArray(stages) && stages.includes(structure.stage)));
    }
    function isStageSequence(structure) {
        return ((!stageSequence && !Array.isArray(stageSequences)) ||
            (stageSequence && structure.stageSequence === stageSequence) ||
            (Array.isArray(stageSequences) &&
                stageSequences.includes(structure.stageSequence)));
    }
}

function getAllPositionedParticipantIds(_a) {
    var drawDefinition = _a.drawDefinition;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var stagePositionedParticipantIds = {};
    var allPositionedParticipantIds = (drawDefinition.structures || [])
        .map(function (structure) {
        var _a;
        var _b;
        var stage = structure.stage;
        if (!stagePositionedParticipantIds[stage])
            stagePositionedParticipantIds[stage] = [];
        var positionAssignments = getPositionAssignments$1({ structure: structure }).positionAssignments;
        var particiapntIds = (_b = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.map(xa('participantId')).filter(Boolean)) !== null && _b !== void 0 ? _b : [];
        (_a = stagePositionedParticipantIds[stage]).push.apply(_a, __spreadArray([], __read(particiapntIds), false));
        return particiapntIds;
    })
        .flat();
    return { allPositionedParticipantIds: allPositionedParticipantIds, stagePositionedParticipantIds: stagePositionedParticipantIds };
}
function getPositionAssignments$1(_a) {
    var _b;
    var drawDefinition = _a.drawDefinition, structureId = _a.structureId, structure = _a.structure;
    var error, positionAssignments = [];
    if (!structure) {
        if (!drawDefinition) {
            return { positionAssignments: positionAssignments, error: MISSING_DRAW_DEFINITION };
        }
        (_b = findStructure({ drawDefinition: drawDefinition, structureId: structureId }), structure = _b.structure, error = _b.error);
        if (error)
            return { positionAssignments: positionAssignments, error: error };
    }
    if (structure.structures) {
        positionAssignments = [].concat.apply([], __spreadArray([], __read(structure.structures.map(function (structure) {
            return getPositionAssignments$1({ structure: structure }).positionAssignments;
        })), false));
    }
    else if (structure.positionAssignments) {
        positionAssignments = structure.positionAssignments;
    }
    else {
        error = MISSING_POSITION_ASSIGNMENTS;
    }
    return { positionAssignments: positionAssignments, error: error };
}
function structureAssignedDrawPositions(_a) {
    var _b;
    var drawDefinition = _a.drawDefinition, structureId = _a.structureId, structure = _a.structure;
    var positionAssignments = ((_b = getPositionAssignments$1({
        drawDefinition: drawDefinition,
        structureId: structureId,
        structure: structure,
    })) === null || _b === void 0 ? void 0 : _b.positionAssignments) || [];
    var assignedPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) {
        var _a, _b;
        return (_b = (_a = assignment.participantId) !== null && _a !== void 0 ? _a : assignment.bye) !== null && _b !== void 0 ? _b : assignment.qualifier;
    });
    var allPositionsAssigned = positionAssignments && (positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.length) === (assignedPositions === null || assignedPositions === void 0 ? void 0 : assignedPositions.length);
    var unassignedPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) {
        return !assignment.participantId && !assignment.bye && !assignment.qualifier;
    });
    var byePositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) {
        return !assignment.participantId && assignment.bye;
    });
    var qualifierPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) {
        return !assignment.participantId && assignment.qualifier;
    });
    return {
        allPositionsAssigned: allPositionsAssigned,
        positionAssignments: positionAssignments,
        unassignedPositions: unassignedPositions,
        assignedPositions: assignedPositions,
        qualifierPositions: qualifierPositions,
        byePositions: byePositions,
    };
}

var SIGN_IN_STATUS = 'SIGN_IN_STATUS';
var SIGNED_OUT = 'SIGNED_OUT';
var SIGNED_IN = 'SIGNED_IN';
var TEAM_PARTICIPANT = 'TEAM';
var INDIVIDUAL = 'INDIVIDUAL';
var GROUP = 'GROUP';
var PAIR = 'PAIR';
var TEAM$1 = 'TEAM';
var participantTypes = {
    TEAM_PARTICIPANT: TEAM_PARTICIPANT,
    INDIVIDUAL: INDIVIDUAL,
    GROUP: GROUP,
    TEAM: TEAM$1,
    PAIR: PAIR,
};
var participantConstants = {
    INDIVIDUAL: INDIVIDUAL,
    GROUP: GROUP,
    PAIR: PAIR,
    TEAM: TEAM$1,
    SIGN_IN_STATUS: SIGN_IN_STATUS,
    SIGNED_OUT: SIGNED_OUT,
    SIGNED_IN: SIGNED_IN,
};

function addParticipantGroupings(_a) {
    var participantsProfile = _a.participantsProfile, _b = _a.participants, participants = _b === void 0 ? [] : _b, deepCopy = _a.deepCopy;
    var groupMap = new Map();
    var participantsWithGroupings = deepCopy !== false
        ? makeDeepCopy(participants, participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.convertExtensions, true)
        : participants;
    var teamParticipants = participantsWithGroupings.filter(function (participant) { return participant.participantType === TEAM$1; });
    var groupParticipants = participantsWithGroupings.filter(function (participant) { return participant.participantType === GROUP; });
    // should pairParticipants only consider those that are in the same event as current draw?
    // TODO: this requires access to the parent event which is not currently in scope
    var pairParticipants = participantsWithGroupings.filter(function (participant) { return participant.participantType === PAIR; });
    participantsWithGroupings.forEach(function (participant) {
        if (participant.participantType === INDIVIDUAL) {
            var participantId_1 = participant.participantId;
            participant.groupParticipantIds = [];
            participant.teamParticipantIds = [];
            participant.pairParticipantIds = [];
            participant.groups = [];
            participant.teams = [];
            teamParticipants.forEach(function (team) {
                ((team === null || team === void 0 ? void 0 : team.individualParticipantIds) || []).forEach(function (individualParticipantId) {
                    var _a;
                    if (individualParticipantId === participantId_1 &&
                        !((_a = participant.teamParticipantIds) === null || _a === void 0 ? void 0 : _a.includes(team.participantId))) {
                        participant.teamParticipantIds.push(team.participantId);
                        if (!groupMap.get(team.participantId))
                            groupMap.set(team.participantId, {
                                participantName: team.participantName,
                                participantId: team.participantId,
                            });
                        participant.teams.push({
                            participantRoleResponsibilities: team.participantRoleResponsibilities,
                            participantOtherName: team.participantOtherName,
                            participantName: team.participantName,
                            participantId: team.participantId,
                            teamId: team.teamId,
                        });
                    }
                });
            });
            pairParticipants.forEach(function (pair) {
                ((pair === null || pair === void 0 ? void 0 : pair.individualParticipantIds) || []).forEach(function (individualParticipantId) {
                    if (individualParticipantId === participantId_1 &&
                        !participant.pairParticipantIds.includes(pair.participantId)) {
                        participant.pairParticipantIds.push(pair.participantId);
                    }
                });
            });
            groupParticipants.forEach(function (group) {
                ((group === null || group === void 0 ? void 0 : group.individualParticipantIds) || []).forEach(function (individualParticipantId) {
                    if (individualParticipantId === participantId_1 &&
                        !participant.groupParticipantIds.includes(group.participantId)) {
                        participant.groupParticipantIds.push(group.participantId);
                        participant.groups.push({
                            participantRoleResponsibilities: group.participantRoleResponsibilities,
                            participantOtherName: group.participantOtherName,
                            participantName: group.participantName,
                            participantId: group.participantId,
                        });
                    }
                });
            });
        }
    });
    return { participantsWithGroupings: participantsWithGroupings, groupInfo: Object.fromEntries(groupMap) };
}

// ISO- 3166-1 alpha-2
function countryToFlag(isoCode) {
    return isoCode && typeof String.fromCodePoint !== 'undefined'
        ? isoCode
            .toUpperCase()
            .replace(/./g, function (char) {
            return String.fromCodePoint(char.charCodeAt(0) + 127397);
        })
        : isoCode;
}
function flagIOC(ioc) {
    var ioc2iso = Object.assign.apply(Object, __spreadArray([{}], __read(countries.filter(function (c) { return c.ioc; }).map(function (c) {
        var _a;
        return (_a = {}, _a[c.ioc] = c.iso, _a);
    })), false));
    return countryToFlag(ioc2iso[ioc]);
}
var countries = [
    {
        ioc: '',
        iso2: '',
        iso: '',
        label: 'NONE',
        phone: '',
    },
    {
        ioc: 'AND',
        iso2: 'AD',
        iso: 'AND',
        label: 'Andorra',
        phone: '376',
    },
    {
        ioc: 'UAE',
        iso2: 'AE',
        iso: 'ARE',
        label: 'United Arab Emirates',
        phone: '971',
    },
    {
        ioc: 'AFG',
        iso2: 'AF',
        iso: 'AFG',
        label: 'Afghanistan',
        phone: '93',
    },
    {
        ioc: 'ANT',
        iso2: 'AG',
        iso: 'ATG',
        label: 'Antigua and Barbuda',
        phone: '1-268',
    },
    {
        ioc: 'AIA',
        iso2: 'AI',
        iso: 'AIA',
        label: 'Anguilla',
        phone: '1-264',
    },
    {
        ioc: 'ALB',
        iso2: 'AL',
        iso: 'ALB',
        label: 'Albania',
        phone: '355',
    },
    {
        ioc: 'ARM',
        iso2: 'AM',
        iso: 'ARM',
        label: 'Armenia',
        phone: '374',
    },
    {
        ioc: 'ANG',
        iso2: 'AO',
        iso: 'AGO',
        label: 'Angola',
        phone: '244',
    },
    {
        ioc: '',
        iso2: 'AQ',
        iso: 'ATA',
        label: 'Antarctica',
        phone: '672',
    },
    {
        ioc: 'ARG',
        iso2: 'AR',
        iso: 'ARG',
        label: 'Argentina',
        phone: '54',
    },
    {
        ioc: 'ASA',
        iso2: 'AS',
        iso: 'ASM',
        label: 'American Samoa',
        phone: '1-684',
    },
    {
        ioc: 'AUT',
        iso2: 'AT',
        iso: 'AUT',
        label: 'Austria',
        phone: '43',
    },
    {
        ioc: 'AUS',
        iso2: 'AU',
        iso: 'AUS',
        label: 'Australia',
        phone: '61',
        suggested: true,
    },
    {
        ioc: 'ARU',
        iso2: 'AW',
        iso: 'ABW',
        label: 'Aruba',
        phone: '297',
    },
    {
        ioc: 'AZE',
        iso2: 'AZ',
        iso: 'AZE',
        label: 'Azerbaijan',
        phone: '994',
    },
    {
        ioc: 'BIH',
        iso2: 'BA',
        iso: 'BIH',
        label: 'Bosnia and Herzegovina',
        phone: '387',
    },
    {
        ioc: 'BAR',
        iso2: 'BB',
        iso: 'BRB',
        label: 'Barbados',
        phone: '1-246',
    },
    {
        ioc: 'BAN',
        iso2: 'BD',
        iso: 'BGD',
        label: 'Bangladesh',
        phone: '880',
    },
    {
        ioc: 'BEL',
        iso2: 'BE',
        iso: 'BEL',
        label: 'Belgium',
        phone: '32',
    },
    {
        ioc: 'BUR',
        iso2: 'BF',
        iso: 'BFA',
        label: 'Burkina Faso',
        phone: '226',
    },
    {
        ioc: 'BUL',
        iso2: 'BG',
        iso: 'BGR',
        label: 'Bulgaria',
        phone: '359',
    },
    {
        ioc: 'BRN',
        iso2: 'BH',
        iso: 'BHR',
        label: 'Bahrain',
        phone: '973',
    },
    {
        ioc: 'BDI',
        iso2: 'BI',
        iso: 'BDI',
        label: 'Burundi',
        phone: '257',
    },
    {
        ioc: 'BEN',
        iso2: 'BJ',
        iso: 'BEN',
        label: 'Benin',
        phone: '229',
    },
    {
        ioc: '',
        iso2: 'BL',
        iso: 'BLM',
        label: 'Saint Barthelemy',
        phone: '590',
    },
    {
        ioc: 'BER',
        iso2: 'BM',
        iso: 'BMU',
        label: 'Bermuda',
        phone: '1-441',
    },
    {
        ioc: 'BRU',
        iso2: 'BN',
        iso: 'BRN',
        label: 'Brunei Darussalam',
        phone: '673',
    },
    {
        ioc: 'BOL',
        iso2: 'BO',
        iso: 'BOL',
        label: 'Bolivia',
        phone: '591',
    },
    {
        ioc: 'BRA',
        iso2: 'BR',
        iso: 'BRA',
        label: 'Brazil',
        phone: '55',
    },
    {
        ioc: 'BAH',
        iso2: 'BS',
        iso: 'BHS',
        label: 'Bahamas',
        phone: '1-242',
    },
    {
        ioc: 'BHU',
        iso2: 'BT',
        iso: 'BTN',
        label: 'Bhutan',
        phone: '975',
    },
    {
        ioc: '',
        iso2: 'BV',
        iso: 'BVT',
        label: 'Bouvet Island',
        phone: '47',
    },
    {
        ioc: 'BOT',
        iso2: 'BW',
        iso: 'BWA',
        label: 'Botswana',
        phone: '267',
    },
    {
        ioc: 'BLR',
        iso2: 'BY',
        iso: 'BLR',
        label: 'Belarus',
        phone: '375',
    },
    {
        ioc: 'BIZ',
        iso2: 'BZ',
        iso: 'BLZ',
        label: 'Belize',
        phone: '501',
    },
    {
        ioc: 'CAN',
        iso2: 'CA',
        iso: 'CAN',
        label: 'Canada',
        phone: '1',
        suggested: true,
    },
    {
        ioc: '',
        iso2: 'CC',
        iso: 'CCK',
        label: 'Cocos (Keeling) Islands',
        phone: '61',
    },
    {
        ioc: 'CGO',
        iso2: 'CD',
        iso: 'COG',
        label: 'Congo, Republic of the',
        phone: '242',
    },
    {
        ioc: 'CAF',
        iso2: 'CF',
        iso: 'CAF',
        label: 'Central African Republic',
        phone: '236',
    },
    {
        ioc: 'COD',
        iso2: 'CG',
        iso: 'CGD',
        label: 'Congo, Democratic Republic of the',
        phone: '243',
    },
    {
        ioc: 'SUI',
        iso2: 'CH',
        iso: 'CHE',
        label: 'Switzerland',
        phone: '41',
    },
    {
        ioc: 'CIV',
        iso2: 'CI',
        iso: 'CIV',
        label: "Cote d'Ivoire",
        phone: '225',
    },
    {
        ioc: 'COK',
        iso2: 'CK',
        iso: 'COK',
        label: 'Cook Islands',
        phone: '682',
    },
    {
        ioc: 'CHI',
        iso2: 'CL',
        iso: 'CHL',
        label: 'Chile',
        phone: '56',
    },
    {
        ioc: 'CMR',
        iso2: 'CM',
        iso: 'CMR',
        label: 'Cameroon',
        phone: '237',
    },
    {
        ioc: 'CHN',
        iso2: 'CN',
        iso: 'CHN',
        label: 'China',
        phone: '86',
    },
    {
        ioc: 'COL',
        iso2: 'CO',
        iso: 'COL',
        label: 'Colombia',
        phone: '57',
    },
    {
        ioc: 'CRC',
        iso2: 'CR',
        iso: 'CRI',
        label: 'Costa Rica',
        phone: '506',
    },
    {
        ioc: 'CUB',
        iso2: 'CU',
        iso: 'CUB',
        label: 'Cuba',
        phone: '53',
    },
    {
        ioc: 'CPV',
        iso2: 'CV',
        iso: 'CPV',
        label: 'Cape Verde',
        phone: '238',
    },
    {
        ioc: 'CUW',
        iso2: 'CW',
        iso: 'CUW',
        label: 'Curacao',
        phone: '599',
    },
    {
        ioc: 'CXR',
        iso2: 'CX',
        iso: 'CXR',
        label: 'Christmas Island',
        phone: '61',
    },
    {
        ioc: 'CYP',
        iso2: 'CY',
        iso: 'CYP',
        label: 'Cyprus',
        phone: '357',
    },
    {
        ioc: 'CZE',
        iso2: 'CZ',
        iso: 'CZE',
        label: 'Czech Republic',
        phone: '420',
    },
    {
        ioc: 'GER',
        iso2: 'DE',
        iso: 'DEU',
        label: 'Germany',
        phone: '49',
        suggested: true,
    },
    {
        ioc: 'DJI',
        iso2: 'DJ',
        iso: 'DJI',
        label: 'Djibouti',
        phone: '253',
    },
    {
        ioc: 'DEN',
        iso2: 'DK',
        iso: 'DNK',
        label: 'Denmark',
        phone: '45',
    },
    {
        ioc: 'DMA',
        iso2: 'DM',
        iso: 'DMA',
        label: 'Dominica',
        phone: '1-767',
    },
    {
        ioc: 'DOM',
        iso2: 'DO',
        iso: 'DOM',
        label: 'Dominican Republic',
        phone: '1-809',
    },
    {
        ioc: 'ALG',
        iso2: 'DZ',
        iso: 'DZA',
        label: 'Algeria',
        phone: '213',
    },
    {
        ioc: 'ECU',
        iso2: 'EC',
        iso: 'ECU',
        label: 'Ecuador',
        phone: '593',
    },
    {
        ioc: 'EST',
        iso2: 'EE',
        iso: 'ESE',
        label: 'Estonia',
        phone: '372',
    },
    {
        ioc: 'EGY',
        iso2: 'EG',
        iso: 'EGY',
        label: 'Egypt',
        phone: '20',
    },
    {
        ioc: '',
        iso2: 'EH',
        iso: 'ESH',
        label: 'Western Sahara',
        phone: '212',
    },
    {
        ioc: 'ERI',
        iso2: 'ER',
        iso: 'ERI',
        label: 'Eritrea',
        phone: '291',
    },
    {
        ioc: 'ESP',
        iso2: 'ES',
        iso: 'ESP',
        label: 'Spain',
        phone: '34',
    },
    {
        ioc: 'ETH',
        iso2: 'ET',
        iso: 'ETH',
        label: 'Ethiopia',
        phone: '251',
    },
    {
        ioc: 'FIN',
        iso2: 'FI',
        iso: 'FIN',
        label: 'Finland',
        phone: '358',
    },
    {
        ioc: 'FIJ',
        iso2: 'FJ',
        iso: 'FJI',
        label: 'Fiji',
        phone: '679',
    },
    {
        ioc: 'FLK',
        iso2: 'FK',
        iso: 'FLK',
        label: 'Falkland Islands (Malvinas)',
        phone: '500',
    },
    {
        ioc: 'FSM',
        iso2: 'FM',
        iso: 'FSM',
        label: 'Micronesia, Federated States of',
        phone: '691',
    },
    {
        ioc: 'FAR',
        iso2: 'FO',
        iso: 'FRO',
        label: 'Faroe Islands',
        phone: '298',
    },
    {
        ioc: 'FRA',
        iso2: 'FR',
        iso: 'FRA',
        label: 'France',
        phone: '33',
        suggested: true,
    },
    {
        ioc: 'GAB',
        iso2: 'GA',
        iso: 'GAB',
        label: 'Gabon',
        phone: '241',
    },
    {
        ioc: 'GBR',
        iso2: 'GB',
        iso: 'GBR',
        label: 'United Kingdom',
        phone: '44',
    },
    {
        ioc: 'GRN',
        iso2: 'GD',
        iso: 'GRD',
        label: 'Grenada',
        phone: '1-473',
    },
    {
        ioc: 'GEO',
        iso2: 'GE',
        iso: 'GEO',
        label: 'Georgia',
        phone: '995',
    },
    {
        ioc: 'FGU',
        iso2: 'GF',
        iso: 'GUF',
        label: 'French Guiana',
        phone: '594',
    },
    {
        ioc: '',
        iso2: 'GG',
        iso: 'GGY',
        label: 'Guernsey',
        phone: '44',
    },
    {
        ioc: '',
        iso2: 'GH',
        iso: 'GHA',
        label: 'Ghana',
        phone: '233',
    },
    {
        ioc: 'GIB',
        iso2: 'GI',
        iso: 'GIB',
        label: 'Gibraltar',
        phone: '350',
    },
    {
        ioc: 'GRL',
        iso2: 'GL',
        iso: 'GRL',
        label: 'Greenland',
        phone: '299',
    },
    {
        ioc: 'GAM',
        iso2: 'GM',
        iso: 'GMB',
        label: 'Gambia',
        phone: '220',
    },
    {
        ioc: 'GUI',
        iso2: 'GN',
        iso: 'GIN',
        label: 'Guinea',
        phone: '224',
    },
    {
        ioc: 'GUD',
        iso2: 'GP',
        iso: 'GLP',
        label: 'Guadeloupe',
        phone: '590',
    },
    {
        ioc: 'GEQ',
        iso2: 'GQ',
        iso: 'GNQ',
        label: 'Equatorial Guinea',
        phone: '240',
    },
    {
        ioc: 'GRE',
        iso2: 'GR',
        iso: 'GRC',
        label: 'Greece',
        phone: '30',
    },
    {
        ioc: '',
        iso2: 'GS',
        iso: 'SGS',
        label: 'South Georgia and the South Sandwich Islands',
        phone: '500',
    },
    {
        ioc: 'GUA',
        iso2: 'GT',
        iso: 'GTM',
        label: 'Guatemala',
        phone: '502',
    },
    {
        ioc: 'GUM',
        iso2: 'GU',
        iso: 'GUM',
        label: 'Guam',
        phone: '1-671',
    },
    {
        ioc: 'GBS',
        iso2: 'GW',
        iso: 'GNB',
        label: 'Guinea-Bissau',
        phone: '245',
    },
    {
        ioc: 'GUY',
        iso2: 'GY',
        iso: 'GUY',
        label: 'Guyana',
        phone: '592',
    },
    {
        ioc: 'HKG',
        iso2: 'HK',
        iso: 'HKG',
        label: 'Hong Kong',
        phone: '852',
    },
    {
        ioc: '',
        iso2: 'HM',
        iso: 'HMD',
        label: 'Heard Island and McDonald Islands',
        phone: '672',
    },
    {
        ioc: 'HON',
        iso2: 'HN',
        iso: 'HND',
        label: 'Honduras',
        phone: '504',
    },
    {
        ioc: 'CRO',
        iso2: 'HR',
        iso: 'HRV',
        label: 'Croatia',
        phone: '385',
    },
    {
        ioc: 'HAI',
        iso2: 'HT',
        iso: 'HTI',
        label: 'Haiti',
        phone: '509',
    },
    {
        ioc: 'HUN',
        iso2: 'HU',
        iso: 'HUN',
        label: 'Hungary',
        phone: '36',
    },
    {
        ioc: 'INA',
        iso2: 'ID',
        iso: 'IDN',
        label: 'Indonesia',
        phone: '62',
    },
    {
        ioc: 'IRL',
        iso2: 'IE',
        iso: 'IRL',
        label: 'Ireland',
        phone: '353',
    },
    {
        ioc: 'ISR',
        iso2: 'IL',
        iso: 'ISR',
        label: 'Israel',
        phone: '972',
    },
    {
        ioc: '',
        iso2: 'IM',
        iso: 'IMN',
        label: 'Isle of Man',
        phone: '44',
    },
    {
        ioc: 'IND',
        iso2: 'IN',
        iso: 'IND',
        label: 'India',
        phone: '91',
    },
    {
        ioc: '',
        iso2: 'IO',
        iso: 'IOT',
        label: 'British Indian Ocean Territory',
        phone: '246',
    },
    {
        ioc: 'IRQ',
        iso2: 'IQ',
        iso: 'IRQ',
        label: 'Iraq',
        phone: '964',
    },
    {
        ioc: 'IRI',
        iso2: 'IR',
        iso: 'IRN',
        label: 'Iran, Islamic Republic of',
        phone: '98',
    },
    {
        ioc: 'ISL',
        iso2: 'IS',
        iso: 'ISL',
        label: 'Iceland',
        phone: '354',
    },
    {
        ioc: 'ITA',
        iso2: 'IT',
        iso: 'ITA',
        label: 'Italy',
        phone: '39',
    },
    {
        ioc: '',
        iso2: 'JE',
        iso: 'JEY',
        label: 'Jersey',
        phone: '44',
    },
    {
        ioc: 'JAM',
        iso2: 'JM',
        iso: 'JAM',
        label: 'Jamaica',
        phone: '1-876',
    },
    {
        ioc: 'JOR',
        iso2: 'JO',
        iso: 'JOR',
        label: 'Jordan',
        phone: '962',
    },
    {
        ioc: 'JPN',
        iso2: 'JP',
        iso: 'JPN',
        label: 'Japan',
        phone: '81',
        suggested: true,
    },
    {
        ioc: 'KEN',
        iso2: 'KE',
        iso: 'KEN',
        label: 'Kenya',
        phone: '254',
    },
    {
        ioc: 'KGZ',
        iso2: 'KG',
        iso: 'KGZ',
        label: 'Kyrgyzstan',
        phone: '996',
    },
    {
        ioc: 'CAM',
        iso2: 'KH',
        iso: 'KHM',
        label: 'Cambodia',
        phone: '855',
    },
    {
        ioc: 'KIR',
        iso2: 'KI',
        iso: 'KIR',
        label: 'Kiribati',
        phone: '686',
    },
    {
        ioc: 'COM',
        iso2: 'KM',
        iso: 'COM',
        label: 'Comoros',
        phone: '269',
    },
    {
        ioc: 'SKN',
        iso2: 'KN',
        iso: 'KNA',
        label: 'Saint Kitts and Nevis',
        phone: '1-869',
    },
    {
        ioc: 'KOR',
        iso2: 'KP',
        iso: 'KOR',
        label: "Korea, Democratic People's Republic of",
        phone: '850',
    },
    {
        ioc: 'PRK',
        iso2: 'KR',
        iso: 'PRK',
        label: 'Korea, Republic of',
        phone: '82',
    },
    {
        ioc: 'KUW',
        iso2: 'KW',
        iso: 'KWT',
        label: 'Kuwait',
        phone: '965',
    },
    {
        ioc: 'CAY',
        iso2: 'KY',
        iso: 'CYM',
        label: 'Cayman Islands',
        phone: '1-345',
    },
    {
        ioc: 'KAZ',
        iso2: 'KZ',
        iso: 'KAZ',
        label: 'Kazakhstan',
        phone: '7',
    },
    {
        ioc: 'LAO',
        iso2: 'LA',
        iso: 'LAO',
        label: "Lao People's Democratic Republic",
        phone: '856',
    },
    {
        ioc: 'LIB',
        iso2: 'LB',
        iso: 'LBN',
        label: 'Lebanon',
        phone: '961',
    },
    {
        ioc: 'LCA',
        iso2: 'LC',
        iso: 'LCA',
        label: 'Saint Lucia',
        phone: '1-758',
    },
    {
        ioc: 'LIE',
        iso2: 'LI',
        iso: 'LIE',
        label: 'Liechtenstein',
        phone: '423',
    },
    {
        ioc: 'SRI',
        iso2: 'LK',
        iso: 'LKA',
        label: 'Sri Lanka',
        phone: '94',
    },
    {
        ioc: 'LBR',
        iso2: 'LR',
        iso: 'LBR',
        label: 'Liberia',
        phone: '231',
    },
    {
        ioc: 'LES',
        iso2: 'LS',
        iso: 'LSO',
        label: 'Lesotho',
        phone: '266',
    },
    {
        ioc: 'LTU',
        iso2: 'LT',
        iso: 'LTU',
        label: 'Lithuania',
        phone: '370',
    },
    {
        ioc: 'LUX',
        iso2: 'LU',
        iso: 'LUX',
        label: 'Luxembourg',
        phone: '352',
    },
    {
        ioc: 'LAT',
        iso2: 'LV',
        iso: 'LVA',
        label: 'Latvia',
        phone: '371',
    },
    {
        ioc: 'LBA',
        iso2: 'LY',
        iso: 'LBY',
        label: 'Libya',
        phone: '218',
    },
    {
        ioc: 'MAR',
        iso2: 'MA',
        iso: 'MAR',
        label: 'Morocco',
        phone: '212',
    },
    {
        ioc: 'MON',
        iso2: 'MC',
        iso: 'MCO',
        label: 'Monaco',
        phone: '377',
    },
    {
        ioc: 'MDA',
        iso2: 'MD',
        iso: 'MDA',
        label: 'Moldova, Republic of',
        phone: '373',
    },
    {
        ioc: 'MNE',
        iso2: 'ME',
        iso: 'MNE',
        label: 'Montenegro',
        phone: '382',
    },
    {
        ioc: '',
        iso2: 'MF',
        iso: 'MAF',
        label: 'Saint Martin (French part)',
        phone: '590',
    },
    {
        ioc: 'MAD',
        iso2: 'MG',
        iso: 'MDG',
        label: 'Madagascar',
        phone: '261',
    },
    {
        ioc: 'MSH',
        iso2: 'MH',
        iso: 'MHL',
        label: 'Marshall Islands',
        phone: '692',
    },
    {
        ioc: 'MKD',
        iso2: 'MK',
        iso: 'MKD',
        label: 'Macedonia, the Former Yugoslav Republic of',
        phone: '389',
    },
    {
        ioc: 'MLI',
        iso2: 'ML',
        iso: 'MLI',
        label: 'Mali',
        phone: '223',
    },
    {
        ioc: 'MYA',
        iso2: 'MM',
        iso: 'MMR',
        label: 'Myanmar',
        phone: '95',
    },
    {
        ioc: 'MGL',
        iso2: 'MN',
        iso: 'MNG',
        label: 'Mongolia',
        phone: '976',
    },
    {
        ioc: 'MAC',
        iso2: 'MO',
        iso: 'MAC',
        label: 'Macao',
        phone: '853',
    },
    {
        ioc: 'NMA',
        iso2: 'MP',
        iso: 'NMP',
        label: 'Northern Mariana Islands',
        phone: '1-670',
    },
    {
        ioc: 'MRT',
        iso2: 'MQ',
        iso: 'MTQ',
        label: 'Martinique',
        phone: '596',
    },
    {
        ioc: 'MTN',
        iso2: 'MR',
        iso: 'MRT',
        label: 'Mauritania',
        phone: '222',
    },
    {
        ioc: 'MNT',
        iso2: 'MS',
        iso: 'MSR',
        label: 'Montserrat',
        phone: '1-664',
    },
    {
        ioc: 'MLT',
        iso2: 'MT',
        iso: 'MLT',
        label: 'Malta',
        phone: '356',
    },
    {
        ioc: 'MRI',
        iso2: 'MU',
        iso: 'MUS',
        label: 'Mauritius',
        phone: '230',
    },
    {
        ioc: 'MDV',
        iso2: 'MV',
        iso: 'MDV',
        label: 'Maldives',
        phone: '960',
    },
    {
        ioc: 'MAW',
        iso2: 'MW',
        iso: 'MWI',
        label: 'Malawi',
        phone: '265',
    },
    {
        ioc: 'MEX',
        iso2: 'MX',
        iso: 'MEX',
        label: 'Mexico',
        phone: '52',
    },
    {
        ioc: 'MAS',
        iso2: 'MY',
        iso: 'MYS',
        label: 'Malaysia',
        phone: '60',
    },
    {
        ioc: 'MOZ',
        iso2: 'MZ',
        iso: 'MOZ',
        label: 'Mozambique',
        phone: '258',
    },
    {
        ioc: 'NAM',
        iso2: 'NA',
        iso: 'NAM',
        label: 'Namibia',
        phone: '264',
    },
    {
        ioc: 'NCL',
        iso2: 'NC',
        iso: 'NCL',
        label: 'New Caledonia',
        phone: '687',
    },
    {
        ioc: 'NIG',
        iso2: 'NE',
        iso: 'NER',
        label: 'Niger',
        phone: '227',
    },
    {
        ioc: 'NFI',
        iso2: 'NF',
        iso: 'NFK',
        label: 'Norfolk Island',
        phone: '672',
    },
    {
        ioc: 'NGR',
        iso2: 'NG',
        iso: 'NGA',
        label: 'Nigeria',
        phone: '234',
    },
    {
        ioc: 'NCA',
        iso2: 'NI',
        iso: 'NIC',
        label: 'Nicaragua',
        phone: '505',
    },
    {
        ioc: 'NED',
        iso2: 'NL',
        iso: 'NLD',
        label: 'Netherlands',
        phone: '31',
    },
    {
        ioc: 'NOR',
        iso2: 'NO',
        iso: 'NOR',
        label: 'Norway',
        phone: '47',
    },
    {
        ioc: 'NEP',
        iso2: 'NP',
        iso: 'NPL',
        label: 'Nepal',
        phone: '977',
    },
    {
        ioc: 'NRU',
        iso2: 'NR',
        iso: 'NRU',
        label: 'Nauru',
        phone: '674',
    },
    {
        ioc: 'NIU',
        iso2: 'NU',
        iso: 'NIU',
        label: 'Niue',
        phone: '683',
    },
    {
        ioc: 'NZL',
        iso2: 'NZ',
        iso: 'NZL',
        label: 'New Zealand',
        phone: '64',
    },
    {
        ioc: 'OMA',
        iso2: 'OM',
        iso: 'OMN',
        label: 'Oman',
        phone: '968',
    },
    {
        ioc: 'PAN',
        iso2: 'PA',
        iso: 'PAN',
        label: 'Panama',
        phone: '507',
    },
    {
        ioc: 'PER',
        iso2: 'PE',
        iso: 'PER',
        label: 'Peru',
        phone: '51',
    },
    {
        ioc: 'FPO',
        iso2: 'PF',
        iso: 'PYF',
        label: 'French Polynesia',
        phone: '689',
    },
    {
        ioc: 'PNG',
        iso2: 'PG',
        iso: 'PNG',
        label: 'Papua New Guinea',
        phone: '675',
    },
    {
        ioc: 'PHI',
        iso2: 'PH',
        iso: 'PHL',
        label: 'Philippines',
        phone: '63',
    },
    {
        ioc: 'PAK',
        iso2: 'PK',
        iso: 'PAK',
        label: 'Pakistan',
        phone: '92',
    },
    {
        ioc: 'POL',
        iso2: 'PL',
        iso: 'POL',
        label: 'Poland',
        phone: '48',
    },
    {
        ioc: 'SPM',
        iso2: 'PM',
        iso: 'SPM',
        label: 'Saint Pierre and Miquelon',
        phone: '508',
    },
    {
        ioc: '',
        iso2: 'PN',
        iso: 'PCN',
        label: 'Pitcairn',
        phone: '870',
    },
    {
        ioc: 'PUR',
        iso2: 'PR',
        iso: 'PRI',
        label: 'Puerto Rico',
        phone: '1',
    },
    {
        ioc: 'PLE',
        iso2: 'PS',
        iso: 'PSE',
        label: 'Palestine, State of',
        phone: '970',
    },
    {
        ioc: 'POR',
        iso2: 'PT',
        iso: 'PRT',
        label: 'Portugal',
        phone: '351',
    },
    {
        ioc: 'PLW',
        iso2: 'PW',
        iso: 'PLW',
        label: 'Palau',
        phone: '680',
    },
    {
        ioc: 'PAR',
        iso2: 'PY',
        iso: 'PRY',
        label: 'Paraguay',
        phone: '595',
    },
    {
        ioc: 'QAT',
        iso2: 'QA',
        iso: 'QAT',
        label: 'Qatar',
        phone: '974',
    },
    {
        ioc: 'REU',
        iso2: 'RE',
        iso: 'REU',
        label: 'Reunion',
        phone: '262',
    },
    {
        ioc: 'ROU',
        iso2: 'RO',
        iso: 'ROU',
        label: 'Romania',
        phone: '40',
    },
    {
        ioc: 'SRB',
        iso2: 'RS',
        iso: 'SRB',
        label: 'Serbia',
        phone: '381',
    },
    {
        ioc: 'RUS',
        iso2: 'RU',
        iso: 'RUS',
        label: 'Russia',
        phone: '7',
    },
    {
        ioc: 'RWA',
        iso2: 'RW',
        iso: 'RWA',
        label: 'Rwanda',
        phone: '250',
    },
    {
        ioc: 'KSA',
        iso2: 'SA',
        iso: 'SAU',
        label: 'Saudi Arabia',
        phone: '966',
    },
    {
        ioc: 'SOL',
        iso2: 'SB',
        iso: 'SLB',
        label: 'Solomon Islands',
        phone: '677',
    },
    {
        ioc: 'SEY',
        iso2: 'SC',
        iso: 'SYC',
        label: 'Seychelles',
        phone: '248',
    },
    {
        ioc: 'SUD',
        iso2: 'SD',
        iso: 'SDN',
        label: 'Sudan',
        phone: '249',
    },
    {
        ioc: 'SWE',
        iso2: 'SE',
        iso: 'SWE',
        label: 'Sweden',
        phone: '46',
    },
    {
        ioc: 'SIN',
        iso2: 'SG',
        iso: 'SGP',
        label: 'Singapore',
        phone: '65',
    },
    {
        ioc: 'HEL',
        iso2: 'SH',
        iso: 'SHN',
        label: 'Saint Helena',
        phone: '290',
    },
    {
        ioc: 'SLO',
        iso2: 'SI',
        iso: 'SVN',
        label: 'Slovenia',
        phone: '386',
    },
    {
        ioc: '',
        iso2: 'SJ',
        iso: 'SJM',
        label: 'Svalbard and Jan Mayen',
        phone: '47',
    },
    {
        ioc: 'SVK',
        iso2: 'SK',
        iso: 'SVK',
        label: 'Slovakia',
        phone: '421',
    },
    {
        ioc: 'SLE',
        iso2: 'SL',
        iso: 'SLE',
        label: 'Sierra Leone',
        phone: '232',
    },
    {
        ioc: 'SMR',
        iso2: 'SM',
        iso: 'SMR',
        label: 'San Marino',
        phone: '378',
    },
    {
        ioc: 'SEN',
        iso2: 'SN',
        iso: 'SEN',
        label: 'Senegal',
        phone: '221',
    },
    {
        ioc: 'SOM',
        iso2: 'SO',
        iso: 'SOM',
        label: 'Somalia',
        phone: '252',
    },
    {
        ioc: 'SUR',
        iso2: 'SR',
        iso: 'SUR',
        label: 'Suriname',
        phone: '597',
    },
    {
        ioc: '',
        iso2: 'SS',
        iso: 'SSD',
        label: 'South Sudan',
        phone: '211',
    },
    {
        ioc: 'STP',
        iso2: 'ST',
        iso: 'STP',
        label: 'Sao Tome and Principe',
        phone: '239',
    },
    {
        ioc: 'ESA',
        iso2: 'SV',
        iso: 'SLV',
        label: 'El Salvador',
        phone: '503',
    },
    {
        ioc: '',
        iso2: 'SX',
        iso: 'SMX',
        label: 'Sint Maarten',
        phone: '1-721',
    },
    {
        ioc: 'SYR',
        iso2: 'SY',
        iso: 'SYR',
        label: 'Syria',
        phone: '963',
    },
    {
        ioc: '',
        iso2: 'SZ',
        iso: 'SWZ',
        label: 'Swaziland',
        phone: '268',
    },
    {
        ioc: 'TKS',
        iso2: 'TC',
        iso: 'TCA',
        label: 'Turks and Caicos Islands',
        phone: '1-649',
    },
    {
        ioc: 'CHA',
        iso2: 'TD',
        iso: 'TCD',
        label: 'Chad',
        phone: '235',
    },
    {
        ioc: '',
        iso2: 'TF',
        iso: 'ATF',
        label: 'French Southern Territories',
        phone: '262',
    },
    {
        ioc: 'TOG',
        iso2: 'TG',
        iso: 'TGO',
        label: 'Togo',
        phone: '228',
    },
    {
        ioc: 'THA',
        iso2: 'TH',
        iso: 'THA',
        label: 'Thailand',
        phone: '66',
    },
    {
        ioc: 'TJK',
        iso2: 'TJ',
        iso: 'TJK',
        label: 'Tajikistan',
        phone: '992',
    },
    {
        ioc: '',
        iso2: 'TK',
        iso: 'TKL',
        label: 'Tokelau',
        phone: '690',
    },
    {
        ioc: 'TLS',
        iso2: 'TL',
        iso: 'TLS',
        label: 'Timor-Leste',
        phone: '670',
    },
    {
        ioc: 'TKM',
        iso2: 'TM',
        iso: 'TKM',
        label: 'Turkmenistan',
        phone: '993',
    },
    {
        ioc: 'TUN',
        iso2: 'TN',
        iso: 'TUN',
        label: 'Tunisia',
        phone: '216',
    },
    {
        ioc: 'TGA',
        iso2: 'TO',
        iso: 'TON',
        label: 'Tonga',
        phone: '676',
    },
    {
        ioc: 'TUR',
        iso2: 'TR',
        iso: 'TUR',
        label: 'Turkey',
        phone: '90',
    },
    {
        ioc: 'TTO',
        iso2: 'TT',
        iso: 'TTO',
        label: 'Trinidad and Tobago',
        phone: '1-868',
    },
    {
        ioc: 'TUV',
        iso2: 'TV',
        iso: 'TUV',
        label: 'Tuvalu',
        phone: '688',
    },
    {
        ioc: 'TPE',
        iso2: 'TW',
        iso: 'TWN',
        label: 'Taiwan',
        phone: '886',
    },
    {
        ioc: 'TAN',
        iso2: 'TZ',
        iso: 'TZA',
        label: 'United Republic of Tanzania',
        phone: '255',
    },
    {
        ioc: 'UKR',
        iso2: 'UA',
        iso: 'UKR',
        label: 'Ukraine',
        phone: '380',
    },
    {
        ioc: 'UGA',
        iso2: 'UG',
        iso: 'UGA',
        label: 'Uganda',
        phone: '256',
    },
    {
        ioc: 'USA',
        iso2: 'US',
        label: 'United States',
        phone: '1',
        suggested: true,
        iso: 'USA',
    },
    {
        ioc: 'URU',
        iso2: 'UY',
        iso: 'URY',
        label: 'Uruguay',
        phone: '598',
    },
    {
        ioc: 'UZB',
        iso2: 'UZ',
        iso: 'UZB',
        label: 'Uzbekistan',
        phone: '998',
    },
    {
        ioc: '',
        iso2: 'VA',
        iso: 'VAT',
        label: 'Holy See (Vatican City State)',
        phone: '379',
    },
    {
        ioc: 'VIN',
        iso2: 'VC',
        iso: 'VCT',
        label: 'Saint Vincent and the Grenadines',
        phone: '1-784',
    },
    {
        ioc: 'VEN',
        iso2: 'VE',
        iso: 'VEN',
        label: 'Venezuela',
        phone: '58',
    },
    {
        ioc: 'IVB',
        iso2: 'VG',
        iso: 'VGB',
        label: 'British Virgin Islands',
        phone: '1-284',
    },
    {
        ioc: 'ISV',
        iso2: 'VI',
        iso: 'VIR',
        label: 'US Virgin Islands',
        phone: '1-340',
    },
    {
        ioc: 'VIE',
        iso2: 'VN',
        iso: 'VNM',
        label: 'Vietnam',
        phone: '84',
    },
    {
        ioc: 'VAN',
        iso2: 'VU',
        iso: 'VUT',
        label: 'Vanuatu',
        phone: '678',
    },
    {
        ioc: 'WAF',
        iso2: 'WF',
        iso: 'WLF',
        label: 'Wallis and Futuna',
        phone: '681',
    },
    {
        ioc: 'SAM',
        iso2: 'WS',
        iso: 'WSM',
        label: 'Samoa',
        phone: '685',
    },
    {
        ioc: 'KOS',
        iso2: 'XK',
        iso: 'KOS',
        label: 'Kosovo',
        phone: '383',
    },
    {
        ioc: 'YEM',
        iso2: 'YE',
        iso: 'YEM',
        label: 'Yemen',
        phone: '967',
    },
    {
        ioc: 'MAY',
        iso2: 'YT',
        iso: 'MYT',
        label: 'Mayotte',
        phone: '262',
    },
    {
        ioc: 'RSA',
        iso2: 'ZA',
        iso: 'ZAF',
        label: 'South Africa',
        phone: '27',
    },
    {
        ioc: 'ZAM',
        iso2: 'ZM',
        iso: 'ZMB',
        label: 'Zambia',
        phone: '260',
    },
    {
        ioc: 'ZIM',
        iso2: 'ZW',
        iso: 'ZWE',
        label: 'Zimbabwe',
        phone: '263',
    },
];

function addNationalityCode(_a) {
    var participant = _a.participant, withISO2 = _a.withISO2, withIOC = _a.withIOC;
    var person = participant.person, individualParticipants = participant.individualParticipants;
    var persons = [person, individualParticipants === null || individualParticipants === void 0 ? void 0 : individualParticipants.map(function (_a) {
            var person = _a.person;
            return person;
        })]
        .flat()
        .filter(Boolean);
    function annotatePerson(person) {
        var nationalityCode = (person || {}).nationalityCode;
        if (nationalityCode) {
            var country = countries.find(function (_a) {
                var iso = _a.iso;
                return iso === nationalityCode;
            });
            if (withIOC && (country === null || country === void 0 ? void 0 : country.ioc) && !person.iocNationalityCode)
                person.iocNationalityCode = country.ioc;
            if (withISO2 && (country === null || country === void 0 ? void 0 : country.iso2) && !person.iso2NationalityCode)
                person.iso2NationalityCode = country.iso2;
            if ((country === null || country === void 0 ? void 0 : country.label) && !person.countryName)
                person.countryName = country.label;
        }
    }
    persons.forEach(annotatePerson);
}

function addIndividualParticipants(_a) {
    var e_1, _b, e_2, _c;
    var _d;
    var participantMap = _a.participantMap, template = _a.template;
    var participantObjects = Object.values(participantMap);
    try {
        for (var participantObjects_1 = __values(participantObjects), participantObjects_1_1 = participantObjects_1.next(); !participantObjects_1_1.done; participantObjects_1_1 = participantObjects_1.next()) {
            var participantObject = participantObjects_1_1.value;
            var participant = participantObject.participant;
            if ((_d = participant.individualParticipantIds) === null || _d === void 0 ? void 0 : _d.length) {
                participant.individualParticipants = [];
                try {
                    for (var _e = (e_2 = void 0, __values(participant.individualParticipantIds)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var participantId = _f.value;
                        var source = participantMap[participantId].participant;
                        participant.individualParticipants.push(template ? attributeFilter({ template: template, source: source }) : source);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (participantObjects_1_1 && !participantObjects_1_1.done && (_b = participantObjects_1.return)) _b.call(participantObjects_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}

function findTournamentParticipant(params) {
    var _a, e_1, _b;
    var _c;
    var tournamentRecord = params.tournamentRecord, participantId = params.participantId;
    var tournamentRecords = params.tournamentRecords ||
        (tournamentRecord && (_a = {},
            _a[tournamentRecord.tournamentId] = tournamentRecord,
            _a)) ||
        {};
    try {
        for (var _d = __values(Object.values(tournamentRecords)), _e = _d.next(); !_e.done; _e = _d.next()) {
            var tournamentRecord_1 = _e.value;
            var participant = (_c = tournamentRecord_1.participants) === null || _c === void 0 ? void 0 : _c.find(function (participant) { return participant.participantId === participantId; });
            if (participant)
                return { participant: participant, tournamentId: tournamentRecord_1.tournamentId };
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { error: PARTICIPANT_NOT_FOUND };
}

function getTimeItem(_a) {
    var returnPreviousValues = _a.returnPreviousValues, itemSubTypes = _a.itemSubTypes, itemType = _a.itemType, element = _a.element;
    if (!element)
        return { error: MISSING_VALUE, info: ELEMENT_REQUIRED };
    if (itemSubTypes && !Array.isArray(itemSubTypes))
        return { error: INVALID_VALUES, context: { itemSubTypes: itemSubTypes } };
    if (!Array.isArray(element.timeItems))
        return { error: MISSING_TIME_ITEMS };
    var filteredSorted = element.timeItems
        .filter(function (timeItem) { return (timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType) === itemType; })
        .filter(function (timeItem) {
        return !(itemSubTypes === null || itemSubTypes === void 0 ? void 0 : itemSubTypes.length) ||
            itemSubTypes.some(function (subType) { var _a; return (_a = timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemSubTypes) === null || _a === void 0 ? void 0 : _a.includes(subType); });
    })
        .sort(function (a, b) {
        var aDate = new Date(a.createdAt || undefined).getTime();
        var bDate = new Date(b.createdAt || undefined).getTime();
        return aDate - bDate;
    });
    var timeItem = filteredSorted.pop();
    if (timeItem) {
        var result = __assign({ timeItem: timeItem }, SUCCESS);
        if (returnPreviousValues)
            Object.assign(result, { previousItems: filteredSorted });
        return result;
    }
    else {
        return { info: NOT_FOUND };
    }
}
function getDrawDefinitionTimeItem(_a) {
    var returnPreviousValues = _a.returnPreviousValues, drawDefinition = _a.drawDefinition, itemSubTypes = _a.itemSubTypes, itemType = _a.itemType;
    if (!drawDefinition)
        return { error: MISSING_DRAW_ID };
    if (!drawDefinition.timeItems)
        return { info: NOT_FOUND };
    var _b = getTimeItem({
        element: drawDefinition,
        returnPreviousValues: returnPreviousValues,
        itemSubTypes: itemSubTypes,
        itemType: itemType,
    }), timeItem = _b.timeItem, previousItems = _b.previousItems, info = _b.info;
    return (timeItem && { timeItem: timeItem, previousItems: previousItems }) || { info: info };
}
function getEventTimeItem(_a) {
    var returnPreviousValues = _a.returnPreviousValues, itemSubTypes = _a.itemSubTypes, itemType = _a.itemType, event = _a.event;
    if (!event)
        return { error: MISSING_EVENT };
    if (!event.timeItems)
        return { info: NOT_FOUND };
    var _b = getTimeItem({
        returnPreviousValues: returnPreviousValues,
        element: event,
        itemSubTypes: itemSubTypes,
        itemType: itemType,
    }), timeItem = _b.timeItem, previousItems = _b.previousItems, info = _b.info;
    return (timeItem && { timeItem: timeItem, previousItems: previousItems }) || { info: info };
}
function getTournamentTimeItem(_a) {
    var returnPreviousValues = _a.returnPreviousValues, tournamentRecord = _a.tournamentRecord, itemSubTypes = _a.itemSubTypes, itemType = _a.itemType;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!tournamentRecord.timeItems)
        return { info: NOT_FOUND };
    var _b = getTimeItem({
        element: tournamentRecord,
        returnPreviousValues: returnPreviousValues,
        itemSubTypes: itemSubTypes,
        itemType: itemType,
    }), timeItem = _b.timeItem, previousItems = _b.previousItems, info = _b.info;
    return (timeItem && { timeItem: timeItem, previousItems: previousItems }) || { info: info };
}
function getParticipantTimeItem(_a) {
    var returnPreviousValues = _a.returnPreviousValues, tournamentRecord = _a.tournamentRecord, participantId = _a.participantId, itemSubTypes = _a.itemSubTypes, itemType = _a.itemType;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!participantId)
        return { error: MISSING_PARTICIPANT_ID };
    var result = findTournamentParticipant({ tournamentRecord: tournamentRecord, participantId: participantId });
    if (result.error)
        return result;
    var participant = result.participant;
    if (!(participant === null || participant === void 0 ? void 0 : participant.timeItems))
        return { info: NOT_FOUND };
    var _b = getTimeItem({
        element: result.participant,
        returnPreviousValues: returnPreviousValues,
        itemSubTypes: itemSubTypes,
        itemType: itemType,
    }), timeItem = _b.timeItem, previousItems = _b.previousItems, info = _b.info;
    return (timeItem && { timeItem: timeItem, previousItems: previousItems }) || { info: info };
}

var SINGLES_MATCHUP = 'SINGLES';
var SINGLES = 'SINGLES';
var DOUBLES_MATCHUP = 'DOUBLES';
var DOUBLES = 'DOUBLES';
var TEAM_MATCHUP = 'TEAM';
var TEAM = 'TEAM';
var matchUpTypes = {
    SINGLES_MATCHUP: SINGLES_MATCHUP,
    SINGLES: SINGLES,
    DOUBLES_MATCHUP: DOUBLES_MATCHUP,
    DOUBLES: DOUBLES,
    TEAM_MATCHUP: TEAM_MATCHUP,
    TEAM: TEAM,
};

var _a$i, _b$6;
var typeMap = (_a$i = {},
    _a$i[GROUP] = 'groupParticipantIds',
    _a$i[PAIR] = 'pairParticipantIds',
    _a$i[TEAM$1] = 'teamParticipantIds',
    _a$i);
var membershipMap = (_b$6 = {},
    _b$6[GROUP] = 'groups',
    _b$6[TEAM$1] = 'teams',
    _b$6);
function getParticipantMap(_a) {
    var e_1, _b, e_2, _c;
    var _d, _e;
    var withIndividualParticipants = _a.withIndividualParticipants, convertExtensions = _a.convertExtensions, tournamentRecord = _a.tournamentRecord, withSignInStatus = _a.withSignInStatus, withScaleValues = _a.withScaleValues, internalUse = _a.internalUse, withISO2 = _a.withISO2, withIOC = _a.withIOC;
    var participantMap = {};
    try {
        // initialize all participants first, to preserve order
        for (var _f = __values((_d = tournamentRecord.participants) !== null && _d !== void 0 ? _d : []), _g = _f.next(); !_g.done; _g = _f.next()) {
            var participant = _g.value;
            var participantId = participant === null || participant === void 0 ? void 0 : participant.participantId;
            participantId && initializeParticipantId({ participantMap: participantMap, participantId: participantId });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var _h = __values((_e = tournamentRecord.participants) !== null && _e !== void 0 ? _e : []), _j = _h.next(); !_j.done; _j = _h.next()) {
            var participant = _j.value;
            var participantCopy = makeDeepCopy(participant, convertExtensions, internalUse);
            var participantId = participantCopy.participantId, individualParticipantIds = participantCopy.individualParticipantIds, participantType = participantCopy.participantType;
            Object.assign(participantMap[participantId].participant, participantCopy);
            if (individualParticipantIds) {
                processIndividualParticipantIds({
                    individualParticipantIds: individualParticipantIds,
                    participantCopy: participantCopy,
                    participantMap: participantMap,
                    participantType: participantType,
                    participantId: participantId,
                });
            }
            if (withSignInStatus) {
                participantMap[participantId].participant.signedIn =
                    signedIn(participantCopy);
            }
            if (withScaleValues) {
                var _k = getScaleValues({
                    participant: participantCopy,
                }), ratings = _k.ratings, rankings = _k.rankings, seedings = _k.seedings;
                participantMap[participantId].participant.seedings = seedings;
                participantMap[participantId].participant.rankings = rankings;
                participantMap[participantId].participant.ratings = ratings;
            }
            if (withIOC || withISO2)
                addNationalityCode({
                    participant: participantMap[participantId].participant,
                    withISO2: withISO2,
                    withIOC: withIOC,
                });
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
        }
        finally { if (e_2) throw e_2.error; }
    }
    if (withIndividualParticipants) {
        var template = isObject(withIndividualParticipants)
            ? withIndividualParticipants
            : undefined;
        addIndividualParticipants({ participantMap: participantMap, template: template });
    }
    return { participantMap: participantMap };
}
function signedIn(participant) {
    var timeItem = getTimeItem({
        itemType: SIGN_IN_STATUS,
        element: participant,
    }).timeItem;
    return (timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemValue) === SIGNED_IN;
}
function processIndividualParticipantIds(_a) {
    var e_3, _b;
    var individualParticipantIds = _a.individualParticipantIds, participantCopy = _a.participantCopy, participantMap = _a.participantMap, participantType = _a.participantType, participantId = _a.participantId;
    var _loop_1 = function (individualParticipantId) {
        var individualParticipant = participantMap[individualParticipantId].participant;
        individualParticipant[typeMap[participantType]].push(participantId);
        if ([TEAM$1, GROUP].includes(participantType)) {
            var participantRoleResponsibilities = participantCopy.participantRoleResponsibilities, participantOtherName = participantCopy.participantOtherName, participantName = participantCopy.participantName, participantId_1 = participantCopy.participantId, teamId = participantCopy.teamId;
            var membership = membershipMap[participantType];
            individualParticipant[membership].push({
                participantRoleResponsibilities: participantRoleResponsibilities,
                participantOtherName: participantOtherName,
                participantName: participantName,
                participantId: participantId_1,
                teamId: teamId,
            });
        }
        if (participantType === PAIR) {
            var partnerParticipantId = individualParticipantIds.find(function (id) { return id !== individualParticipantId; });
            participantMap[individualParticipantId].pairIdMap[participantId] =
                partnerParticipantId;
            participantMap[individualParticipantId].pairIdMap[partnerParticipantId] =
                participantId;
        }
    };
    try {
        for (var individualParticipantIds_1 = __values(individualParticipantIds), individualParticipantIds_1_1 = individualParticipantIds_1.next(); !individualParticipantIds_1_1.done; individualParticipantIds_1_1 = individualParticipantIds_1.next()) {
            var individualParticipantId = individualParticipantIds_1_1.value;
            _loop_1(individualParticipantId);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (individualParticipantIds_1_1 && !individualParticipantIds_1_1.done && (_b = individualParticipantIds_1.return)) _b.call(individualParticipantIds_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
}
function initializeParticipantId(_a) {
    var _b;
    var participantMap = _a.participantMap, participantId = _a.participantId;
    // nothing to do if participantId is present
    if (participantMap[participantId])
        return;
    var counters = {
        walkoverWins: 0,
        defaultWins: 0,
        walkovers: 0,
        defaults: 0,
        losses: 0,
        wins: 0,
    };
    participantMap[participantId] = {
        structureParticipation: {},
        potentialMatchUps: {},
        scheduleConflicts: {},
        scheduleItems: [],
        participant: {
            groupParticipantIds: [],
            pairParticipantIds: [],
            teamParticipantIds: [],
            seedings: {},
            rankings: {},
            ratings: {},
            groups: [],
            teams: [],
        },
        statistics: {},
        opponents: {},
        pairIdMap: {},
        matchUps: {},
        events: {},
        draws: {},
        counters: __assign((_b = {}, _b[SINGLES] = __assign({}, counters), _b[DOUBLES] = __assign({}, counters), _b[TEAM$1] = __assign({}, counters), _b), counters),
    };
}

function hydrateParticipants(_a) {
    var _b, e_1, _c;
    var _d;
    var participantsProfile = _a.participantsProfile, useParticipantMap = _a.useParticipantMap, tournamentRecord = _a.tournamentRecord, contextProfile = _a.contextProfile, inContext = _a.inContext;
    if (useParticipantMap) {
        var participantMap = (_d = getParticipantMap(__assign(__assign(__assign({}, participantsProfile), contextProfile), { tournamentRecord: tournamentRecord }))) === null || _d === void 0 ? void 0 : _d.participantMap;
        return { participantMap: participantMap };
    }
    var participants = makeDeepCopy(tournamentRecord.participants, false, true) || [];
    if ((participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.withIOC) || (participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.withISO2))
        participants.forEach(function (participant) {
            return addNationalityCode(__assign({ participant: participant }, participantsProfile));
        });
    var groupInfo;
    if ((inContext || (participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.withGroupings)) &&
        (participants === null || participants === void 0 ? void 0 : participants.length)) {
        (_b = addParticipantGroupings({
            participantsProfile: participantsProfile,
            deepCopy: false,
            participants: participants,
        }), participants = _b.participantsWithGroupings, groupInfo = _b.groupInfo);
    }
    if ((participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.withScaleValues) && (participants === null || participants === void 0 ? void 0 : participants.length)) {
        try {
            for (var participants_1 = __values(participants), participants_1_1 = participants_1.next(); !participants_1_1.done; participants_1_1 = participants_1.next()) {
                var participant = participants_1_1.value;
                var _e = getScaleValues({ participant: participant }), ratings = _e.ratings, rankings = _e.rankings;
                participant.rankings = rankings;
                participant.ratings = ratings;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (participants_1_1 && !participants_1_1.done && (_c = participants_1.return)) _c.call(participants_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return { participants: participants, groupInfo: groupInfo };
}

/*
  returns the next round matchUp for winner of given matchUp
  must exclude tieMatchUps as next round matchUp count may not be consistent
*/
function getNextRoundMatchUp(_a) {
    var structureMatchUps = _a.structureMatchUps, matchUp = _a.matchUp;
    var roundNumber = matchUp.roundNumber, roundPosition = matchUp.roundPosition;
    var currentRoundMatchUps = structureMatchUps.filter(function (matchUp) { return matchUp.roundNumber === roundNumber && !matchUp.matchUpTieId; });
    var nextRoundMatchUps = structureMatchUps.filter(function (matchUp) {
        return matchUp.roundNumber === roundNumber + 1 && !matchUp.matchUpTieId;
    });
    if (nextRoundMatchUps.length) {
        var nextMatchUp = void 0;
        if (nextRoundMatchUps.length === currentRoundMatchUps.length) {
            nextMatchUp = nextRoundMatchUps.find(function (matchUp) { return matchUp.roundPosition === roundPosition; });
        }
        else if (nextRoundMatchUps.length === currentRoundMatchUps.length / 2) {
            nextMatchUp = nextRoundMatchUps.find(function (matchUp) { return matchUp.roundPosition === Math.ceil(roundPosition / 2); });
        }
        return { matchUp: nextMatchUp };
    }
    return { message: 'no progression found' };
}

function reduceGroupedOrder(_a) {
    var groupedOrder = _a.groupedOrder, roundPositionsCount = _a.roundPositionsCount;
    if (!groupedOrder || (groupedOrder === null || groupedOrder === void 0 ? void 0 : groupedOrder.length) <= roundPositionsCount) {
        return groupedOrder;
    }
    var groupChunks = chunkArray(groupedOrder, groupedOrder.length / roundPositionsCount);
    var chunkValues = groupChunks.map(function (chunk) { return chunk.reduce(function (a, b) { return a + b; }); });
    var sortedChunks = chunkValues.slice().sort(numericSort); // make a copy of the values to avoid mutating the original
    return chunkValues.map(function (chunkValue) { return sortedChunks.indexOf(chunkValue) + 1; });
}

function getTargetMatchUp(_a) {
    var _b;
    var sourceRoundMatchUpCount = _a.sourceRoundMatchUpCount, inContextDrawMatchUps = _a.inContextDrawMatchUps, sourceRoundPosition = _a.sourceRoundPosition, drawDefinition = _a.drawDefinition, targetLink = _a.targetLink;
    if (!targetLink)
        return { error: MISSING_TARGET_LINK };
    var _c = targetLink.target, structureId = _c.structureId, feedProfile = _c.feedProfile, groupedOrder = _c.groupedOrder, roundNumber = _c.roundNumber, positionInterleave = _c.positionInterleave;
    var targetStructure = findStructure({
        drawDefinition: drawDefinition,
        structureId: structureId,
    }).structure;
    var positionAssignments = getPositionAssignments$1({
        structure: targetStructure,
    }).positionAssignments;
    var structureMatchUps = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.filter(function (matchUp) { return matchUp.structureId === (targetStructure === null || targetStructure === void 0 ? void 0 : targetStructure.structureId); });
    var targetRoundMatchUps = structureMatchUps.filter(function (matchUp) { return matchUp.roundNumber === roundNumber && !matchUp.matchUpTieId; } // exclude tieMatchUps
    );
    var targetRoundMatchUpCount = targetRoundMatchUps.length;
    var roundPositions = generateRange(1, targetRoundMatchUpCount + 1);
    var matchUpCountFactor = targetRoundMatchUpCount / sourceRoundMatchUpCount;
    // usually target structures are half the size of source structures
    // which means the calculatedRoundPosition for target matchUps is sourceRoundPosition * 0.5
    var calculatedRoundPosition = Math.ceil(matchUpCountFactor * sourceRoundPosition);
    var matchUpDrawPositionIndex = 1 - (sourceRoundPosition % 2);
    // when more than one source structure or more than one source structure round feed the same round in the target structure
    // then there is a positionInterleave attribute which specifies both an offset and an interleave
    // the offset is the number of positions from the start
    // the interleave indicates how many positions are fed in between each position fed by current source structure round
    if ((positionInterleave === null || positionInterleave === void 0 ? void 0 : positionInterleave.interleave) && matchUpCountFactor !== 0.5) {
        // the oofset here is a combination of the specified offset and the number of previous positions interleaved
        var offset = positionInterleave.offset +
            (sourceRoundPosition - 1) * positionInterleave.interleave;
        // the target drawPosition is relative because the actual drawPosition value is based on the number of subseqent round feed-in matchUps
        var relativeRoundPosition = sourceRoundPosition + offset;
        calculatedRoundPosition = Math.ceil(relativeRoundPosition / 2);
        // the index in the target matchUp.drawPositions[] is recalculated based on calculated relative drawPosition
        matchUpDrawPositionIndex = 1 - (relativeRoundPosition % 2);
    }
    var orderedPositions = roundPositions;
    var targetedRoundPosition = roundPositions[calculatedRoundPosition - 1];
    var sizedGroupOrder = reduceGroupedOrder({
        groupedOrder: groupedOrder,
        roundPositionsCount: roundPositions.length,
    });
    var groupsCount = (sizedGroupOrder === null || sizedGroupOrder === void 0 ? void 0 : sizedGroupOrder.length) || 1;
    if (groupsCount <= roundPositions.length) {
        var groupSize = targetRoundMatchUpCount / groupsCount;
        var groups_1 = chunkArray(roundPositions, groupSize);
        if (feedProfile === BOTTOM_UP)
            groups_1.forEach(function (group) { return group.reverse(); });
        orderedPositions =
            ((sizedGroupOrder === null || sizedGroupOrder === void 0 ? void 0 : sizedGroupOrder.length) &&
                (sizedGroupOrder === null || sizedGroupOrder === void 0 ? void 0 : sizedGroupOrder.map(function (order) { return groups_1[order - 1]; }).flat())) ||
                orderedPositions;
    }
    if (feedProfile === TOP_DOWN) {
        /*
          TOP_DOWN feed profile implies that the roundPosition in the
          target is equivalent to the roundPosition in the source
        */
        targetedRoundPosition = orderedPositions[calculatedRoundPosition - 1];
    }
    else if (feedProfile === BOTTOM_UP) {
        /*
          BOTTOM_UP feed profile implies that the roundPosition in the
          target is (# of matchUps in source/target round + 1) - roundPosition in the source
        */
        if (!(sizedGroupOrder === null || sizedGroupOrder === void 0 ? void 0 : sizedGroupOrder.length) || groupsCount > roundPositions.length) {
            calculatedRoundPosition =
                targetRoundMatchUps.length + 1 - calculatedRoundPosition;
        }
        targetedRoundPosition = orderedPositions[calculatedRoundPosition - 1];
    }
    else if (feedProfile === RANDOM) {
        /*
          RANDOM feed profile selects a random position from available
        */
        if (getDevContext())
            console.log(NOT_IMPLEMENTED, { feedProfile: feedProfile });
    }
    else ;
    var matchUp = targetedRoundPosition &&
        targetRoundMatchUps.reduce(function (matchUp, current) {
            return current.roundPosition === targetedRoundPosition
                ? current
                : matchUp;
        }, undefined);
    // targetDrawPosition and matchUpDrawPositionIndex are only relevant
    // when drawPositions need to be assigned in positionAssignments
    // which means only when a targetMatchUp is in a different structure
    var targetDrawPosition;
    if (matchUp === null || matchUp === void 0 ? void 0 : matchUp.feedRound) {
        // for fedDrawPositions in linked elimination structures...
        // ...when roundNumber > 1 matchUpDrawPositionIndex should always be 0
        // ...because fed drawPositions are always numerically smaller than advanced drawPositions
        matchUpDrawPositionIndex = 0;
        targetDrawPosition = Math.min.apply(Math, __spreadArray([], __read((matchUp.drawPositions || []).filter(Boolean)), false));
    }
    else {
        // when not a feedRound targetDrawPosition can only be determined when both drawPositions present
        targetDrawPosition =
            ((_b = matchUp === null || matchUp === void 0 ? void 0 : matchUp.drawPositions) === null || _b === void 0 ? void 0 : _b.length) === 2 &&
                (matchUp === null || matchUp === void 0 ? void 0 : matchUp.drawPositions[matchUpDrawPositionIndex]);
    }
    var relevantAssignment = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (_a) {
        var drawPosition = _a.drawPosition;
        return drawPosition === targetDrawPosition;
    });
    if (relevantAssignment) {
        var extension = findExtension({
            element: relevantAssignment,
            name: DISABLE_LINKS,
        }).extension;
        if (extension === null || extension === void 0 ? void 0 : extension.value) {
            return { disabledDrawPosition: targetDrawPosition };
        }
    }
    return {
        matchUp: matchUp,
        targetDrawPosition: targetDrawPosition,
        matchUpDrawPositionIndex: matchUpDrawPositionIndex,
    };
}

// Return links which govern movement for a given matchUp either as a source or a target
function getRoundLinks(_a) {
    var drawDefinition = _a.drawDefinition, // passed automatically by drawEngine
    roundNumber = _a.roundNumber, // optional - filter for only links that apply to roundNumber
    structureId = _a.structureId;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structureId)
        return { error: MISSING_STRUCTURE_ID };
    var links = getStructureLinks({ drawDefinition: drawDefinition, structureId: structureId }).links;
    var source = links.source.reduce(function (source, link) {
        return !link.source.roundNumber || link.source.roundNumber === roundNumber
            ? source.concat(link)
            : source;
    }, []);
    var target = links.target.reduce(function (target, link) {
        return !link.target.roundNumber || link.target.roundNumber === roundNumber
            ? target.concat(link)
            : target;
    }, []);
    return { links: { source: source, target: target } };
}
function getTargetLink(_a) {
    var _b;
    var finishingPositions = _a.finishingPositions, linkCondition = _a.linkCondition, linkType = _a.linkType, source = _a.source;
    var result = source.find(function (link) {
        var _a, _b;
        var positionCondition = !((_a = link.source) === null || _a === void 0 ? void 0 : _a.finishingPositions) ||
            !finishingPositions ||
            overlap(finishingPositions, (_b = link.source) === null || _b === void 0 ? void 0 : _b.finishingPositions);
        var condition = linkCondition === link.linkCondition;
        return condition && positionCondition && link.linkType === linkType;
    });
    if ([WINNER, LOSER].includes(result === null || result === void 0 ? void 0 : result.linkType) &&
        !((_b = result === null || result === void 0 ? void 0 : result.source) === null || _b === void 0 ? void 0 : _b.roundNumber)) {
        return decorateResult({
            result: { error: INVALID_VALUES },
            stack: 'getTargetLink',
            context: result,
        });
    }
    return result;
}
// Returns all links for which a structure is either a source or a target; optionally filter by roundNumber
function getStructureLinks(_a) {
    var drawDefinition = _a.drawDefinition, //passed automatically by drawEngine
    structureId = _a.structureId, // id of structure for which links are desired
    roundNumber = _a.roundNumber;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structureId)
        return { error: MISSING_STRUCTURE_ID };
    var links = drawDefinition.links || [];
    var structureLinks = links.filter(Boolean).reduce(function (structureLinks, link) {
        var _a, _b;
        if (((_a = link.source) === null || _a === void 0 ? void 0 : _a.structureId) === structureId &&
            (!roundNumber || link.source.roundNumber === roundNumber))
            structureLinks.source = structureLinks.source.concat(link);
        if (((_b = link.target) === null || _b === void 0 ? void 0 : _b.structureId) === structureId &&
            (!roundNumber || link.target.roundNumber === roundNumber))
            structureLinks.target = structureLinks.target.concat(link);
        return structureLinks;
    }, { source: [], target: [] });
    return { links: structureLinks };
}

function positionTargets(_a) {
    var _b = _a.inContextDrawMatchUps, inContextDrawMatchUps = _b === void 0 ? [] : _b, useTargetMatchUpIds = _a.useTargetMatchUpIds, inContextMatchUp = _a.inContextMatchUp, drawDefinition = _a.drawDefinition, matchUpId = _a.matchUpId;
    var matchUp = inContextMatchUp;
    if (inContextDrawMatchUps.length && !matchUp) {
        matchUp = inContextDrawMatchUps.find(function (m) { return m.matchUpId === matchUpId; });
    }
    var structure = findStructure({
        structureId: matchUp === null || matchUp === void 0 ? void 0 : matchUp.structureId,
        drawDefinition: drawDefinition,
    }).structure;
    var finishingPosition = structure === null || structure === void 0 ? void 0 : structure.finishingPosition;
    if (finishingPosition === ROUND_OUTCOME) {
        return targetByRoundOutcome({
            inContextDrawMatchUps: inContextDrawMatchUps,
            useTargetMatchUpIds: useTargetMatchUpIds,
            drawDefinition: drawDefinition,
            structure: structure,
            matchUp: matchUp,
        });
    }
    else {
        return targetByWinRatio({ matchUp: matchUp });
    }
}
function targetByRoundOutcome(_a) {
    var _b, _c, _d;
    var _e, _f, _g;
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, useTargetMatchUpIds = _a.useTargetMatchUpIds, drawDefinition = _a.drawDefinition, structure = _a.structure, matchUp = _a.matchUp;
    var winnerMatchUpId = matchUp.winnerMatchUpId, loserMatchUpId = matchUp.loserMatchUpId;
    var links = getRoundLinks({
        roundNumber: matchUp.roundNumber,
        structureId: structure.structureId,
        drawDefinition: drawDefinition,
    }).links;
    var source = links === null || links === void 0 ? void 0 : links.source;
    var winnerTargetLink = getTargetLink({ source: source, linkType: WINNER });
    var byeTargetLink = getTargetLink({
        linkCondition: FIRST_MATCHUP,
        linkType: LOSER,
        source: source,
    });
    var loserTargetLink = getTargetLink({ source: source, linkType: LOSER });
    var propagateByeFMLC = byeTargetLink && loserTargetLink;
    if (!loserTargetLink)
        loserTargetLink = byeTargetLink;
    var winnerFeedProfile = (_e = winnerTargetLink === null || winnerTargetLink === void 0 ? void 0 : winnerTargetLink.target) === null || _e === void 0 ? void 0 : _e.feedProfile;
    var loserFeedProfile = (_f = loserTargetLink === null || loserTargetLink === void 0 ? void 0 : loserTargetLink.target) === null || _f === void 0 ? void 0 : _f.feedProfile;
    var byeFeedProfile = (_g = byeTargetLink === null || byeTargetLink === void 0 ? void 0 : byeTargetLink.target) === null || _g === void 0 ? void 0 : _g.feedProfile;
    var byeMatchUp, byeTargetDrawPosition, byeMatchUpDrawPositionIndex;
    var loserMatchUp, loserTargetDrawPosition, loserMatchUpDrawPositionIndex;
    var winnerMatchUp, winnerTargetDrawPosition, winnerMatchUpDrawPositionIndex;
    var structureMatchUps;
    if (useTargetMatchUpIds && (winnerMatchUpId || loserMatchUpId)) {
        winnerMatchUp =
            winnerMatchUpId &&
                winnerFeedProfile !== DRAW &&
                inContextDrawMatchUps.find(function (_a) {
                    var matchUpId = _a.matchUpId;
                    return matchUpId === winnerMatchUpId;
                });
        loserMatchUp =
            loserMatchUpId &&
                loserFeedProfile !== DRAW &&
                inContextDrawMatchUps.find(function (_a) {
                    var matchUpId = _a.matchUpId;
                    return matchUpId === loserMatchUpId;
                });
        if (winnerMatchUp || loserMatchUp) {
            return {
                matchUp: matchUp,
                targetLinks: { loserTargetLink: loserTargetLink, winnerTargetLink: winnerTargetLink },
                targetMatchUps: { loserMatchUp: loserMatchUp, winnerMatchUp: winnerMatchUp },
            };
        }
    }
    var sourceRoundPosition = matchUp.roundPosition;
    structureMatchUps =
        structureMatchUps ||
            inContextDrawMatchUps.filter(function (matchUp) { return matchUp.structureId === structure.structureId; });
    var sourceRoundMatchUpCount = structureMatchUps.reduce(function (count, currentMatchUp) {
        return currentMatchUp.roundNumber === matchUp.roundNumber &&
            !currentMatchUp.matchUpTieId // exclude tieMatchUps
            ? count + 1
            : count;
    }, 0);
    if (loserTargetLink && !loserMatchUp && loserFeedProfile !== DRAW) {
        (_b = getTargetMatchUp({
            targetLink: loserTargetLink,
            sourceRoundMatchUpCount: sourceRoundMatchUpCount,
            inContextDrawMatchUps: inContextDrawMatchUps,
            sourceRoundPosition: sourceRoundPosition,
            drawDefinition: drawDefinition,
        }), loserMatchUpDrawPositionIndex = _b.matchUpDrawPositionIndex, loserTargetDrawPosition = _b.targetDrawPosition, loserMatchUp = _b.matchUp);
    }
    if (propagateByeFMLC && byeFeedProfile !== DRAW) {
        (_c = getTargetMatchUp({
            targetLink: byeTargetLink,
            sourceRoundMatchUpCount: sourceRoundMatchUpCount,
            inContextDrawMatchUps: inContextDrawMatchUps,
            sourceRoundPosition: sourceRoundPosition,
            drawDefinition: drawDefinition,
        }), byeMatchUpDrawPositionIndex = _c.matchUpDrawPositionIndex, byeTargetDrawPosition = _c.targetDrawPosition, byeMatchUp = _c.matchUp);
    }
    if (winnerTargetLink && !winnerMatchUp && winnerFeedProfile !== DRAW) {
        (_d = getTargetMatchUp({
            targetLink: winnerTargetLink,
            sourceRoundMatchUpCount: sourceRoundMatchUpCount,
            inContextDrawMatchUps: inContextDrawMatchUps,
            sourceRoundPosition: sourceRoundPosition,
            drawDefinition: drawDefinition,
        }), winnerMatchUpDrawPositionIndex = _d.matchUpDrawPositionIndex, winnerTargetDrawPosition = _d.targetDrawPosition, winnerMatchUp = _d.matchUp);
    }
    if (!winnerMatchUp) {
        // if there is no winnerTargetLink then find targetMatchUp in next round
        structureMatchUps =
            structureMatchUps ||
                inContextDrawMatchUps.filter(function (matchUp) { return matchUp.structureId === structure.structureId; });
        (winnerMatchUp = getNextRoundMatchUp({
            structureMatchUps: structureMatchUps,
            matchUp: matchUp,
        }).matchUp);
    }
    return definedAttributes({
        matchUp: matchUp,
        targetLinks: { loserTargetLink: loserTargetLink, winnerTargetLink: winnerTargetLink, byeTargetLink: byeTargetLink },
        targetMatchUps: {
            winnerMatchUpDrawPositionIndex: winnerMatchUpDrawPositionIndex,
            loserMatchUpDrawPositionIndex: loserMatchUpDrawPositionIndex,
            byeMatchUpDrawPositionIndex: byeMatchUpDrawPositionIndex,
            winnerTargetDrawPosition: winnerTargetDrawPosition,
            loserTargetDrawPosition: loserTargetDrawPosition,
            byeTargetDrawPosition: byeTargetDrawPosition,
            winnerMatchUp: winnerMatchUp,
            loserMatchUp: loserMatchUp,
            byeMatchUp: byeMatchUp,
        },
        targetMatchUpIds: !!(winnerMatchUpId || loserMatchUpId),
    });
}
function targetByWinRatio(_a) {
    var matchUp = _a.matchUp;
    return {
        targetLinks: { loserTargetLink: undefined, winnerTargetLink: undefined }, // returned for testing
        targetMatchUps: { loserMatchUp: undefined, winnerMatchUp: undefined },
        matchUp: matchUp,
    };
}

function validMatchUp(matchUp) {
    if (!isObject(matchUp))
        return false;
    var matchUpId = matchUp.matchUpId, drawPositions = matchUp.drawPositions;
    var validMatchUpId = typeof matchUpId === 'string';
    var validDrawPositions = !drawPositions ||
        (Array.isArray(drawPositions) &&
            drawPositions.length <= 2 &&
            drawPositions.every(function (dp) { return isConvertableInteger(dp) || dp === undefined || dp === null; }));
    return validMatchUpId && validDrawPositions;
}
function validMatchUps(matchUps) {
    if (!Array.isArray(matchUps))
        return false;
    return matchUps.every(validMatchUp);
}

function getRoundMatchUps(_a) {
    var _b;
    var _c = _a.matchUps, matchUps = _c === void 0 ? [] : _c, interpolate = _a.interpolate;
    if (!validMatchUps(matchUps))
        return { roundMatchUps: [], error: INVALID_VALUES };
    // create an array of arrays of matchUps grouped by roundNumber
    var roundMatchUpsArray = matchUps
        .reduce(function (roundNumbers, matchUp) {
        var roundNumber = typeof matchUp.roundNumber === 'string' ? ensureInt(matchUp.roundNumber) : matchUp.roundNumber;
        return !matchUp.roundNumber || roundNumbers.includes(roundNumber)
            ? roundNumbers
            : roundNumbers.concat(roundNumber);
    }, [])
        .sort(numericSort)
        .map(function (roundNumber) {
        var _a;
        var roundMatchUps = matchUps.filter(function (matchUp) { return matchUp.roundNumber === roundNumber; });
        var hasTeamMatchUps = roundMatchUps.find(function (_a) {
            var matchUpType = _a.matchUpType;
            return matchUpType === TEAM;
        });
        // if there are TEAM matchUps then all other matchUpTypes must be removed
        var consideredMatchUps = hasTeamMatchUps
            ? roundMatchUps.filter(function (_a) {
                var matchUpType = _a.matchUpType;
                return matchUpType === TEAM;
            })
            : roundMatchUps;
        var getSorted = function (items) { return items.sort(function (a, b) { return numericSort(a.roundPosition, b.roundPosition); }); };
        return _a = {},
            _a[roundNumber] = getSorted(consideredMatchUps),
            _a;
    });
    // calculate the finishing Round for each roundNumber
    var finishingRoundMap = matchUps.reduce(function (mapping, matchUp) {
        var roundNumber = typeof matchUp.roundNumber === 'string' ? ensureInt(matchUp.roundNumber) : matchUp.roundNumber;
        if (!mapping[roundNumber])
            mapping[roundNumber] = definedAttributes({
                abbreviatedRoundName: matchUp.abbreviatedRoundName,
                finishingRound: matchUp.finishingRound,
                roundName: matchUp.roundName,
            });
        return mapping;
    }, {});
    // convert roundMatchUpsArray into an object with roundNumber keys
    var roundMatchUps = Object.assign.apply(Object, __spreadArray([{}], __read(roundMatchUpsArray), false));
    if (interpolate) {
        var maxRoundNumber = Math.max.apply(Math, __spreadArray([], __read(Object.keys(roundMatchUps)
            .map(function (key) { return ensureInt(key); })
            .filter(function (f) { return !isNaN(f); })), false));
        var maxRoundMatchUpsCount_1 = (_b = roundMatchUps[maxRoundNumber]) === null || _b === void 0 ? void 0 : _b.length;
        // when considering a structue, if rounds do not progress to a final round which contains one matchUp
        // and if the last provided round has power-of-two matchUpsCount, add details for the matchUps which are "missing"
        if (maxRoundMatchUpsCount_1 > 1 && isPowerOf2(maxRoundMatchUpsCount_1)) {
            var nextRound = maxRoundNumber + 1;
            var lastRound = nextRound + maxRoundMatchUpsCount_1 / 2;
            var roundsToInterpolate = generateRange(nextRound, lastRound);
            roundsToInterpolate.forEach(function (roundNumber, i) {
                roundMatchUps[roundNumber] = generateRange(0, maxRoundMatchUpsCount_1 / (2 + i * 2)).map(function () { return ({}); }); // add dummy objects for padding out the array
            });
        }
    }
    var maxMatchUpsCount = 0;
    // create a profle object with roundNubmer keys
    // provides details for each round, including:
    //  - matchUpsCount: total number of matchUps
    //  - preFeedRound: whether the round is followed by a feedRound
    //  - feedRound: whether round matchUps have fed partitipants
    //  - roundIndex & feedRoundIndex: index relative to round type
    //  - finishingRound: reverse count of rounds. Final is finishingRound #1
    var roundProfile = Object.assign.apply(Object, __spreadArray([{}], __read(Object.keys(roundMatchUps).map(function (roundNumber) {
        var _a;
        var _b, _c, _d;
        var matchUpsCount = (_b = roundMatchUps[roundNumber]) === null || _b === void 0 ? void 0 : _b.length;
        var inactiveCount = (_d = (_c = roundMatchUps[roundNumber]) === null || _c === void 0 ? void 0 : _c.filter(function (matchUp) { var _a; return !completedMatchUpStatuses.includes(matchUp.matchUpStatus) && !((_a = matchUp.score) === null || _a === void 0 ? void 0 : _a.scoreStringSide1); })) === null || _d === void 0 ? void 0 : _d.length;
        var inactiveRound = matchUpsCount && matchUpsCount === inactiveCount;
        maxMatchUpsCount = Math.max(maxMatchUpsCount, matchUpsCount);
        return _a = {}, _a[roundNumber] = { matchUpsCount: matchUpsCount, inactiveCount: inactiveCount, inactiveRound: inactiveRound }, _a;
    })), false));
    var roundIndex = 0;
    var feedRoundIndex = 0;
    var roundNumbers = Object.keys(roundMatchUps)
        .map(function (key) { return ensureInt(key); })
        .filter(function (f) { return !isNaN(f); });
    roundNumbers.forEach(function (roundNumber) {
        var _a, _b, _c, _d, _e;
        var currentRoundMatchUps = roundMatchUps[roundNumber].sort(function (a, b) { return a.roundPosition - b.roundPosition; });
        var currentRoundDrawPositions = currentRoundMatchUps.map(function (matchUp) { return (matchUp === null || matchUp === void 0 ? void 0 : matchUp.drawPositions) || []; }).flat();
        roundProfile[roundNumber].roundNumber = roundNumber; // convenience
        // convenience for display calculations
        roundProfile[roundNumber].roundFactor = roundProfile[roundNumber].matchUpsCount
            ? maxMatchUpsCount / roundProfile[roundNumber].matchUpsCount
            : 1;
        roundProfile[roundNumber].finishingRound = (_a = finishingRoundMap[roundNumber]) === null || _a === void 0 ? void 0 : _a.finishingRound;
        roundProfile[roundNumber].roundName = (_b = finishingRoundMap[roundNumber]) === null || _b === void 0 ? void 0 : _b.roundName;
        roundProfile[roundNumber].abbreviatedRoundName = (_c = finishingRoundMap[roundNumber]) === null || _c === void 0 ? void 0 : _c.abbreviatedRoundName;
        roundProfile[roundNumber].finishingPositionRange = (_e = (_d = roundMatchUps[roundNumber]) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.finishingPositionRange;
        if (roundNumber === 1 || !roundProfile[roundNumber - 1]) {
            var orderedDrawPositions = currentRoundDrawPositions.sort(numericSort);
            var pairedDrawPositions = chunkArray(orderedDrawPositions, 2);
            roundProfile[roundNumber].drawPositions = orderedDrawPositions;
            roundProfile[roundNumber].pairedDrawPositions = pairedDrawPositions;
        }
        else {
            var priorRound = roundProfile[roundNumber - 1];
            var priorRoundDrawPositions_1 = priorRound.drawPositions;
            var chunkFactor = priorRound.matchUpsCount / roundProfile[roundNumber].matchUpsCount;
            var priorRoundDrawPositionChunks_1 = chunkArray(priorRoundDrawPositions_1, chunkFactor);
            // ensures that drawPositions are returned in top to bottom order
            var roundDrawPositions = currentRoundMatchUps.map(function (matchUp) {
                var roundPosition = matchUp.roundPosition;
                var drawPositions = __spreadArray(__spreadArray([], __read((matchUp.drawPositions || [])), false), [undefined, undefined], false).slice(0, 2); // accounts for empty array, should always have length 2
                if (!roundPosition)
                    return drawPositions;
                var filteredDrawPositions = (drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.filter(Boolean)) || [];
                if (!(filteredDrawPositions === null || filteredDrawPositions === void 0 ? void 0 : filteredDrawPositions.length))
                    return [undefined, undefined];
                // { roundNumber: 2 } is the first possible feed round and the last time that a numeric sort is guaranteed to work
                if (roundNumber < 3 && (filteredDrawPositions === null || filteredDrawPositions === void 0 ? void 0 : filteredDrawPositions.length) === 2) {
                    return drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.slice().sort(numericSort); // make a copy of the values to avoid mutating the original
                }
                var isFeedRound = intersection(priorRoundDrawPositions_1, filteredDrawPositions).length !== (filteredDrawPositions === null || filteredDrawPositions === void 0 ? void 0 : filteredDrawPositions.length);
                // if the prior round does NOT include the one existing drawPosition then it is a feed round
                // ... and fed positions are always { sideNumber: 1 }
                if ((filteredDrawPositions === null || filteredDrawPositions === void 0 ? void 0 : filteredDrawPositions.length) && isFeedRound) {
                    if ((filteredDrawPositions === null || filteredDrawPositions === void 0 ? void 0 : filteredDrawPositions.length) === 1) {
                        return [filteredDrawPositions[0], undefined];
                    }
                    else {
                        return drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.slice().sort(numericSort); // make a copy of the values to avoid mutating the original
                    }
                }
                // otherwise determine the order of the drawPositions by looking at the prior round
                // this accounts for ADVANCED fed positions which are NOT guaranteed to be in numeric order
                // ... because a lower number fed position may be in { sideNumber: 2 } while an drawPosition advanced
                // from the first round may be in { sideNumber: 1 }
                // const targetChunkIndex = (roundPosition - 1) * 2;
                var targetChunkIndex = (roundPosition - 1) * 2;
                var targetChunks = priorRoundDrawPositionChunks_1.slice(targetChunkIndex, targetChunkIndex + 2);
                return targetChunks.map(function (chunk) {
                    return filteredDrawPositions === null || filteredDrawPositions === void 0 ? void 0 : filteredDrawPositions.find(function (drawPosition) { return chunk.includes(drawPosition); });
                });
            });
            roundProfile[roundNumber].drawPositions = roundDrawPositions === null || roundDrawPositions === void 0 ? void 0 : roundDrawPositions.flat();
            roundProfile[roundNumber].pairedDrawPositions = roundDrawPositions;
        }
        if (roundProfile[roundNumber + 1] &&
            roundProfile[roundNumber + 1].matchUpsCount === roundProfile[roundNumber].matchUpsCount) {
            roundProfile[roundNumber + 1].feedRound = true;
            roundProfile[roundNumber + 1].feedRoundIndex = feedRoundIndex;
            roundProfile[roundNumber].preFeedRound = true;
            feedRoundIndex += 1;
        }
        if (roundProfile[roundNumber] && !roundProfile[roundNumber].feedRound) {
            roundProfile[roundNumber].roundIndex = roundIndex;
            roundIndex += 1;
        }
    });
    var roundsNotPowerOf2 = !!Object.values(roundProfile).find(function (_a) {
        var matchUpsCount = _a.matchUpsCount;
        return !isPowerOf2(matchUpsCount);
    });
    var hasNoRoundPositions = matchUps.some(function (matchUp) { return !matchUp.roundPosition; });
    return __assign({ hasNoRoundPositions: hasNoRoundPositions, roundsNotPowerOf2: roundsNotPowerOf2, maxMatchUpsCount: maxMatchUpsCount, roundMatchUps: roundMatchUps, roundNumbers: roundNumbers, roundProfile: roundProfile }, SUCCESS);
}

function addUpcomingMatchUps(_a) {
    var drawDefinition = _a.drawDefinition, inContextDrawMatchUps = _a.inContextDrawMatchUps;
    var scheduleConflictMatchUpIds = {};
    inContextDrawMatchUps.forEach(function (inContextMatchUp) {
        var _a, _b, _c, _d, _e, _f;
        var matchUpId = inContextMatchUp.matchUpId, structureId = inContextMatchUp.structureId, _g = inContextMatchUp.drawPositions, drawPositions = _g === void 0 ? [] : _g;
        var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
        if ((structure === null || structure === void 0 ? void 0 : structure.finishingPosition) === WIN_RATIO$1) {
            var roundNumber = inContextMatchUp.roundNumber;
            var nextRoundNumber_1 = roundNumber && ensureInt(roundNumber) + 1;
            var matchUps = (_a = structure.matchUps) !== null && _a !== void 0 ? _a : [];
            var roundMatchUps_1 = getRoundMatchUps({ matchUps: matchUps }).roundMatchUps;
            // if this is a round robin then we have sidesTo information, not winnerTo and loserTo
            if (nextRoundNumber_1 && (roundMatchUps_1 === null || roundMatchUps_1 === void 0 ? void 0 : roundMatchUps_1[nextRoundNumber_1])) {
                var sidesTo = __spreadArray([], __read(drawPositions), false).sort(numericSort)
                    .map(function (drawPosition, index) {
                    var nextRoundMatchUp = roundMatchUps_1[nextRoundNumber_1].find(function (matchUp) { var _a; return (_a = matchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.includes(drawPosition); });
                    return {
                        matchUpId: nextRoundMatchUp === null || nextRoundMatchUp === void 0 ? void 0 : nextRoundMatchUp.matchUpId,
                        roundNumber: nextRoundNumber_1,
                        schedule: nextRoundMatchUp === null || nextRoundMatchUp === void 0 ? void 0 : nextRoundMatchUp.schedule,
                        sideNumber: index + 1,
                        structureName: structure.structureName,
                    };
                });
                Object.assign(inContextMatchUp, { sidesTo: sidesTo });
            }
        }
        else {
            var targetData = positionTargets({
                useTargetMatchUpIds: true,
                inContextDrawMatchUps: inContextDrawMatchUps,
                inContextMatchUp: inContextMatchUp,
                drawDefinition: drawDefinition,
                matchUpId: matchUpId,
            });
            var winnerMatchUp_1 = targetData.targetMatchUps.winnerMatchUp;
            var loserMatchUp_1 = targetData.targetMatchUps.loserMatchUp;
            if (!inContextMatchUp.winnerMatchUpId && winnerMatchUp_1) {
                inContextMatchUp.winnerMatchUpId = winnerMatchUp_1.matchUpId;
            }
            if (!inContextMatchUp.loserMatchUpId && loserMatchUp_1) {
                inContextMatchUp.loserMatchUpId = loserMatchUp_1.matchUpId;
            }
            var winnerTo = getUpcomingInfo({ upcomingMatchUp: winnerMatchUp_1 });
            var loserTo = getUpcomingInfo({ upcomingMatchUp: loserMatchUp_1 });
            if (inContextMatchUp.matchUpStatus !== BYE && (loserMatchUp_1 === null || loserMatchUp_1 === void 0 ? void 0 : loserMatchUp_1.matchUpStatus) === BYE) {
                var nextMatchUp = (getNextToBePlayedMatchUp({
                    matchUp: loserMatchUp_1,
                    drawDefinition: drawDefinition,
                    inContextDrawMatchUps: inContextDrawMatchUps,
                }) || {}).matchUp;
                loserTo = (nextMatchUp && getUpcomingInfo({ upcomingMatchUp: nextMatchUp })) || loserTo;
            }
            // scheduleConflict in the following only applies to conflicts between subsequent matchUps WITHIN the same draw
            var timeAfterRecovery = (_b = inContextMatchUp.schedule) === null || _b === void 0 ? void 0 : _b.timeAfterRecovery;
            if (timeAfterRecovery) {
                if ((_c = winnerTo === null || winnerTo === void 0 ? void 0 : winnerTo.schedule) === null || _c === void 0 ? void 0 : _c.scheduledTime) {
                    var scheduleConflict = timeStringMinutes(winnerTo.schedule.scheduledTime) < timeStringMinutes(timeAfterRecovery);
                    if (scheduleConflict) {
                        scheduleConflictMatchUpIds[winnerTo.matchUpId] = inContextMatchUp.matchUpId;
                        winnerTo.schedule.scheduleConflict = inContextMatchUp.matchUpId;
                    }
                }
                if ((_d = loserTo === null || loserTo === void 0 ? void 0 : loserTo.schedule) === null || _d === void 0 ? void 0 : _d.scheduledTime) {
                    var scheduleConflict = timeStringMinutes(loserTo.schedule.scheduledTime) < timeStringMinutes(timeAfterRecovery);
                    if (scheduleConflict) {
                        scheduleConflictMatchUpIds[loserTo.matchUpId] = inContextMatchUp.matchUpId;
                        loserTo.schedule.scheduleConflict = inContextMatchUp.matchUpId;
                    }
                }
            }
            Object.assign(inContextMatchUp, { winnerTo: winnerTo, loserTo: loserTo });
            if ((_e = inContextMatchUp.drawPositions) === null || _e === void 0 ? void 0 : _e.filter(Boolean).length) {
                var loserTargetLink = (_f = targetData.targetLinks) === null || _f === void 0 ? void 0 : _f.loserTargetLink;
                var firstMatchUp = (loserTargetLink === null || loserTargetLink === void 0 ? void 0 : loserTargetLink.linkCondition) === FIRST_MATCHUP;
                var participants = getMatchUpParticipants(inContextMatchUp);
                if (participants.length) {
                    var winnerParticipantIds_1 = getParticipantIds(winnerMatchUp_1 === null || winnerMatchUp_1 === void 0 ? void 0 : winnerMatchUp_1.sides);
                    var loserParticipantIds_1 = getParticipantIds(loserMatchUp_1 === null || loserMatchUp_1 === void 0 ? void 0 : loserMatchUp_1.sides);
                    var winnerDetermined = participants.find(function (_a) {
                        var participantId = _a.participantId;
                        return winnerParticipantIds_1.includes(participantId);
                    });
                    var winnerPotentials = !winnerDetermined ? participants : [];
                    var loserDetermined = participants.find(function (_a) {
                        var participantId = _a.participantId;
                        return loserParticipantIds_1.includes(participantId);
                    });
                    var loserPotentials = !loserDetermined ? participants : [];
                    if (loserMatchUp_1 && firstMatchUp && loserPotentials.length < 2) {
                        loserPotentials.push({ bye: true, tbd: true }); // tbd: true indiciates that for FMLC, WO/DEF could propagate a player
                    }
                    if ((winnerPotentials === null || winnerPotentials === void 0 ? void 0 : winnerPotentials.length) && winnerMatchUp_1) {
                        // -----------------------------------------------------
                        // when targetMatchUpIds are not present in source data
                        // winnerMatchUp / loserMatchUp are not original objects
                        if (!targetData.targetMatchUpIds && winnerMatchUp_1) {
                            winnerMatchUp_1 = inContextDrawMatchUps.find(function (_a) {
                                var matchUpId = _a.matchUpId;
                                return matchUpId === winnerMatchUp_1.matchUpId;
                            });
                        }
                        // -----------------------------------------------------
                        if (!winnerMatchUp_1.potentialParticipants)
                            winnerMatchUp_1.potentialParticipants = [];
                        winnerMatchUp_1.potentialParticipants.push(winnerPotentials);
                    }
                    if ((loserPotentials === null || loserPotentials === void 0 ? void 0 : loserPotentials.length) && loserMatchUp_1) {
                        // -----------------------------------------------------
                        // when targetMatchUpIds are not present in source data
                        // winnerMatchUp / loserMatchUp are not original objects
                        if (!targetData.targetMatchUpIds) {
                            winnerMatchUp_1 = inContextDrawMatchUps.find(function (_a) {
                                var matchUpId = _a.matchUpId;
                                return matchUpId === loserMatchUp_1.matchUpId;
                            });
                        }
                        // -----------------------------------------------------
                        if (!loserMatchUp_1.potentialParticipants) {
                            loserMatchUp_1.potentialParticipants = [];
                        }
                        loserMatchUp_1.potentialParticipants.push(loserPotentials);
                    }
                }
            }
        }
    });
    if (Object.keys(scheduleConflictMatchUpIds).length) {
        inContextDrawMatchUps.forEach(function (inContextMatchUp) {
            if (Object.keys(scheduleConflictMatchUpIds).includes(inContextMatchUp.matchUpId))
                inContextMatchUp.schedule.scheduleConflict = scheduleConflictMatchUpIds[inContextMatchUp.matchUpId];
        });
    }
    return { scheduleConflictMatchUpIds: scheduleConflictMatchUpIds };
}
function getMatchUpParticipants(matchUp) {
    var _a;
    return (((_a = matchUp === null || matchUp === void 0 ? void 0 : matchUp.sides) === null || _a === void 0 ? void 0 : _a.map(function (_a) {
        var participant = _a.participant, participantId = _a.participantId, qualifier = _a.qualifier;
        return participant || (participantId && { participantId: participantId }) || (qualifier && { qualifier: qualifier });
    }).filter(Boolean)) || []);
}
function getNextToBePlayedMatchUp(_a) {
    var matchUp = _a.matchUp, drawDefinition = _a.drawDefinition, inContextDrawMatchUps = _a.inContextDrawMatchUps;
    var _b = matchUp || {}, matchUpId = _b.matchUpId, matchUpStatus = _b.matchUpStatus, structureId = _b.structureId;
    if (!matchUp || !structureId || (matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpStatus) === TO_BE_PLAYED)
        return { matchUp: matchUp };
    if (matchUpStatus === BYE) {
        var winnerMatchUp = void 0;
        if (matchUp.winnerMatchUpId) {
            winnerMatchUp = inContextDrawMatchUps.find(function (_a) {
                var matchUpId = _a.matchUpId;
                return matchUpId === matchUp.winnerMatchUpId;
            });
        }
        else {
            var targetData = positionTargets({
                inContextDrawMatchUps: inContextDrawMatchUps,
                drawDefinition: drawDefinition,
                matchUpId: matchUpId,
            });
            (winnerMatchUp = ((targetData === null || targetData === void 0 ? void 0 : targetData.targetMatchUps) || {}).winnerMatchUp);
        }
        return getNextToBePlayedMatchUp({
            matchUp: winnerMatchUp,
            drawDefinition: drawDefinition,
            inContextDrawMatchUps: inContextDrawMatchUps,
        });
    }
    return { matchUp: undefined };
}
function getUpcomingInfo(params) {
    if (!(params === null || params === void 0 ? void 0 : params.upcomingMatchUp))
        return;
    return (function (_a) {
        var matchUpId = _a.matchUpId, structureId = _a.structureId, schedule = _a.schedule, roundNumber = _a.roundNumber, roundPosition = _a.roundPosition, structureName = _a.structureName;
        return ({
            matchUpId: matchUpId,
            structureId: structureId,
            schedule: schedule,
            roundNumber: roundNumber,
            roundPosition: roundPosition,
            structureName: structureName,
        });
    })(params.upcomingMatchUp);
}

function getAppliedPolicies(_a) {
    var _b = _a.onlySpecifiedPolicyTypes, onlySpecifiedPolicyTypes = _b === void 0 ? false : _b, _c = _a.policyTypes, policyTypes = _c === void 0 ? [] : _c, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, structure = _a.structure, event = _a.event;
    if (!Array.isArray(policyTypes))
        return { error: MISSING_POLICY_TYPE };
    var appliedPolicies = {};
    if (tournamentRecord)
        extractAppliedPolicies(tournamentRecord);
    if (event)
        extractAppliedPolicies(event);
    if (drawDefinition)
        extractAppliedPolicies(drawDefinition);
    if (structure)
        extractAppliedPolicies(structure);
    return __assign({ appliedPolicies: appliedPolicies }, SUCCESS);
    function extractAppliedPolicies(params) {
        var e_1, _a;
        var _b;
        var extensions = params === null || params === void 0 ? void 0 : params.extensions;
        var extensionPolicies = (_b = extensions === null || extensions === void 0 ? void 0 : extensions.find(function (extension) { return extension.name === APPLIED_POLICIES; })) === null || _b === void 0 ? void 0 : _b.value;
        if (extensionPolicies) {
            try {
                for (var _c = __values(Object.keys(extensionPolicies)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var key = _d.value;
                    if (onlySpecifiedPolicyTypes
                        ? policyTypes.includes(key)
                        : !policyTypes.length || policyTypes.includes(key)) {
                        appliedPolicies[key] = makeDeepCopy(extensionPolicies[key], false, true);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
}
function getPolicyDefinitions(_a) {
    var e_2, _b;
    var _c = _a.policyTypes, policyTypes = _c === void 0 ? [] : _c, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, structure = _a.structure, event = _a.event;
    if (!Array.isArray(policyTypes))
        return { error: MISSING_POLICY_TYPE };
    var appliedPolicies = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    }).appliedPolicies;
    var policyDefinitions = {};
    try {
        for (var policyTypes_1 = __values(policyTypes), policyTypes_1_1 = policyTypes_1.next(); !policyTypes_1_1.done; policyTypes_1_1 = policyTypes_1.next()) {
            var policyType = policyTypes_1_1.value;
            var policy = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[policyType];
            if (policy)
                policyDefinitions[policyType] = policy;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (policyTypes_1_1 && !policyTypes_1_1.done && (_b = policyTypes_1.return)) _b.call(policyTypes_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return Object.keys(policyDefinitions).length
        ? { policyDefinitions: policyDefinitions }
        : { info: POLICY_NOT_FOUND.message };
}

var WALKOVER$1 = 'WALKOVER';
var RETIRED = 'RETIRED';
var COMPETITIVE = 'COMPETITIVE';
var ROUTINE = 'ROUTINE';
var DECISIVE = 'DECISIVE';
var WIN_RATIO = 'winRatio';

var _a$h, _b$5;
var POLICY_COMPETITIVE_BANDS_DEFAULT = (_a$h = {},
    _a$h[POLICY_TYPE_COMPETITIVE_BANDS] = {
        policyName: 'Competitive Bands Default',
        profileBands: (_b$5 = {},
            _b$5[DECISIVE] = 20,
            _b$5[ROUTINE] = 50,
            _b$5),
    },
    _a$h);

function getContextContent(_a) {
    var _b, _c;
    var policyDefinitions = _a.policyDefinitions, tournamentRecord = _a.tournamentRecord, contextProfile = _a.contextProfile, drawDefinition = _a.drawDefinition, event = _a.event;
    var contextContent = { policies: {} };
    if (!contextProfile)
        return contextContent;
    var policies = getPolicyDefinitions({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        event: event,
    }).policyDefinitions;
    if (contextProfile.withCompetitiveness) {
        var policy = (_c = (_b = policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_COMPETITIVE_BANDS]) !== null && _b !== void 0 ? _b : policies === null || policies === void 0 ? void 0 : policies[POLICY_TYPE_COMPETITIVE_BANDS]) !== null && _c !== void 0 ? _c : POLICY_COMPETITIVE_BANDS_DEFAULT[POLICY_TYPE_COMPETITIVE_BANDS];
        contextContent.policies[POLICY_TYPE_COMPETITIVE_BANDS] = policy;
    }
    return contextContent;
}

function getExitProfiles(_a) {
    var e_1, _b;
    var drawDefinition = _a.drawDefinition;
    if (typeof drawDefinition !== 'object')
        return { error: INVALID_DRAW_DEFINITION };
    var exitProfiles = {};
    var _c = drawDefinition || {}, _d = _c.structures, structures = _d === void 0 ? [] : _d, _e = _c.links, links = _e === void 0 ? [] : _e;
    var stageStructures = structures.reduce(function (stageStructures, structure) {
        var stage = structure.stage;
        if (!stageStructures[stage]) {
            stageStructures[stage] = [structure];
        }
        else {
            stageStructures[stage].push(structure);
        }
        return stageStructures;
    }, {});
    try {
        for (var _f = __values(Object.keys(stageStructures)), _g = _f.next(); !_g.done; _g = _f.next()) {
            var stage = _g.value;
            // there can only be one structure per stage with stageSequence 1
            var initialStructure = stageStructures[stage].find(function (_a) {
                var stageSequence = _a.stageSequence;
                return stageSequence === 1;
            });
            if (!initialStructure)
                continue;
            // initial structure of each stage has exitProfile of '0'
            var structureId = initialStructure.structureId;
            // each structure can **potentially** have more than one exitProfile
            // a DOUBLE_ELIMINATION initialStructure is also referred to by the CONSOLATION final exitProfile
            // a CONSOLATION structure with multiple feed rounds will have multiple exitProfiles referring to it
            var exitProfile = '0';
            addExitProfiles({
                aggregator: {},
                targetRound: 0,
                exitProfiles: exitProfiles,
                exitProfile: exitProfile,
                structureId: structureId,
                stage: stage,
            });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { exitProfiles: exitProfiles };
    function addExitProfiles(_a) {
        var e_2, _b;
        var exitProfiles = _a.exitProfiles, exitProfile = _a.exitProfile, structureId = _a.structureId, targetRound = _a.targetRound, aggregator = _a.aggregator, stage = _a.stage;
        if (!exitProfiles[structureId])
            exitProfiles[structureId] = [];
        // initialStructure of CONSOLATION and PLAY_OFF do not need to be captured
        if (!(exitProfile === '0' && [CONSOLATION, PLAY_OFF].includes(stage)))
            exitProfiles[structureId].push(exitProfile);
        var relevantLinks = links.filter(function (link) {
            return link.source.structureId === structureId &&
                link.source.roundNumber >= targetRound;
        } // this doesn't work for ROUND_ROBIN. Will need to use roundProfile to determine final roundNumber.
        );
        var _loop_1 = function (link) {
            var exitRound = link.source.roundNumber;
            var targetRound_1 = link.target.roundNumber;
            var targetStructureId = link.target.structureId;
            var stage_1 = structures.find(function (structure) { return structure.structureId === targetStructureId; }).stage;
            var fp = [stage_1, targetStructureId, targetRound_1, exitRound].join('|');
            if (aggregator[fp])
                return { value: void 0 };
            aggregator[fp] = true;
            addExitProfiles({
                exitProfile: "".concat(exitProfile, "-").concat(exitRound),
                structureId: targetStructureId,
                exitProfiles: exitProfiles,
                targetRound: targetRound_1,
                aggregator: aggregator,
                stage: stage_1,
            });
        };
        try {
            for (var relevantLinks_1 = __values(relevantLinks), relevantLinks_1_1 = relevantLinks_1.next(); !relevantLinks_1_1.done; relevantLinks_1_1 = relevantLinks_1.next()) {
                var link = relevantLinks_1_1.value;
                var state_1 = _loop_1(link);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (relevantLinks_1_1 && !relevantLinks_1_1.done && (_b = relevantLinks_1.return)) _b.call(relevantLinks_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
}

function getMatchUpsMap(_a) {
    var _b;
    var drawDefinition = _a.drawDefinition, structure = _a.structure;
    var mappedMatchUps = {};
    var drawMatchUps = [];
    ((_b = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) !== null && _b !== void 0 ? _b : [structure])
        .filter(function (structure) { return structure && typeof structure === 'object'; })
        .forEach(function (structure) {
        if (!structure)
            return;
        var structureId = structure.structureId, matchUps = structure.matchUps, structures = structure.structures;
        var isRoundRobin = Array.isArray(structures);
        if (!isRoundRobin) {
            var filteredMatchUps = matchUps;
            mappedMatchUps[structureId] = {
                matchUps: filteredMatchUps,
                itemStructureIds: [],
            };
            filteredMatchUps === null || filteredMatchUps === void 0 ? void 0 : filteredMatchUps.forEach(function (matchUp) {
                drawMatchUps.push(matchUp);
                if (matchUp.tieMatchUps)
                    drawMatchUps.push.apply(drawMatchUps, __spreadArray([], __read(matchUp.tieMatchUps), false));
            });
        }
        else if (isRoundRobin) {
            structures.forEach(function (itemStructure) {
                var structureName = itemStructure.structureName;
                var filteredMatchUps = itemStructure.matchUps;
                mappedMatchUps[itemStructure.structureId] = {
                    matchUps: filteredMatchUps,
                    itemStructureIds: [],
                    structureName: structureName,
                };
                if (filteredMatchUps) {
                    drawMatchUps.push.apply(drawMatchUps, __spreadArray([], __read(filteredMatchUps), false));
                    filteredMatchUps.forEach(function (matchUp) {
                        if (matchUp.tieMatchUps)
                            drawMatchUps.push.apply(drawMatchUps, __spreadArray([], __read(matchUp.tieMatchUps), false));
                    });
                }
                if (!mappedMatchUps[structureId])
                    mappedMatchUps[structureId] = {
                        itemStructureIds: [],
                        matchUps: [],
                    };
                if (!mappedMatchUps[structureId].itemStructureIds)
                    mappedMatchUps[structureId].itemStructureIds = [];
                mappedMatchUps[structureId].itemStructureIds.push(itemStructure.structureId);
            });
        }
    });
    return { mappedMatchUps: mappedMatchUps, drawMatchUps: drawMatchUps };
}
function getMappedStructureMatchUps(_a) {
    var _b;
    var _c;
    var mappedMatchUps = _a.mappedMatchUps, matchUpsMap = _a.matchUpsMap, structureId = _a.structureId, inContext = _a.inContext;
    mappedMatchUps = (_c = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.mappedMatchUps) !== null && _c !== void 0 ? _c : mappedMatchUps;
    var structureMatchUpsMap = mappedMatchUps[structureId];
    var itemStructureMatchUps = ((structureMatchUpsMap === null || structureMatchUpsMap === void 0 ? void 0 : structureMatchUpsMap.itemStructureIds) || [])
        .map(function (itemStructureId) {
        var _a = mappedMatchUps[itemStructureId], matchUps = _a.matchUps, structureName = _a.structureName;
        if (inContext) {
            return matchUps.map(function (matchUp) {
                return Object.assign(makeDeepCopy(matchUp, true, true), {
                    containerStructureId: structureId,
                    structureId: itemStructureId,
                    structureName: structureName,
                });
            });
        }
        else {
            return matchUps;
        }
    })
        .flat();
    return (_b = ((structureMatchUpsMap === null || structureMatchUpsMap === void 0 ? void 0 : structureMatchUpsMap.matchUps) || [])).concat.apply(_b, __spreadArray([], __read(itemStructureMatchUps), false));
}

function getCollectionPositionAssignments(_a) {
    var e_1, _b;
    var collectionPosition = _a.collectionPosition, collectionId = _a.collectionId, lineUp = _a.lineUp;
    var assignedParticipantIds = [];
    var substitutions = [];
    if (lineUp) {
        var getOrderValue_1 = function (order) { return (order === undefined ? -1 : order); };
        var competitorAssignments = lineUp
            .map(function (teamCompetitor) {
            var collectionAssignments = teamCompetitor.collectionAssignments, participantId = teamCompetitor.participantId;
            var assignment = collectionAssignments === null || collectionAssignments === void 0 ? void 0 : collectionAssignments.find(function (assignment) {
                return assignment.collectionPosition === collectionPosition &&
                    assignment.collectionId === collectionId;
            });
            return assignment && __assign({ participantId: participantId }, assignment);
        })
            .filter(Boolean)
            .sort(function (a, b) {
            return getOrderValue_1(a.substitutionOrder) -
                getOrderValue_1(b.substitutionOrder);
        });
        var _loop_1 = function (competitorAssignment) {
            var participantId = competitorAssignment.participantId, previousParticipantId = competitorAssignment.previousParticipantId, substitutionOrder = competitorAssignment.substitutionOrder;
            if (assignedParticipantIds.includes(participantId))
                return "continue";
            if (previousParticipantId)
                substitutions.push({
                    previousParticipantId: previousParticipantId,
                    substitutionOrder: substitutionOrder,
                    participantId: participantId,
                });
            assignedParticipantIds = assignedParticipantIds.filter(function (id) { return id !== previousParticipantId; });
            assignedParticipantIds.push(participantId);
        };
        try {
            for (var competitorAssignments_1 = __values(competitorAssignments), competitorAssignments_1_1 = competitorAssignments_1.next(); !competitorAssignments_1_1.done; competitorAssignments_1_1 = competitorAssignments_1.next()) {
                var competitorAssignment = competitorAssignments_1_1.value;
                _loop_1(competitorAssignment);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (competitorAssignments_1_1 && !competitorAssignments_1_1.done && (_b = competitorAssignments_1.return)) _b.call(competitorAssignments_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return { assignedParticipantIds: assignedParticipantIds, substitutions: substitutions };
}

function getPairedParticipant(_a) {
    var _b;
    var tournamentParticipants = _a.tournamentParticipants, tournamentRecord = _a.tournamentRecord, participantIds = _a.participantIds;
    var stack = 'getPairedParticipant';
    if (!tournamentParticipants && !tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!Array.isArray(participantIds) || participantIds.length > 2)
        return { error: INVALID_PARTICIPANT_IDS };
    if (!participantIds.length)
        return decorateResult({
            result: { error: MISSING_PARTICIPANT_IDS },
            stack: stack,
        });
    tournamentParticipants =
        (_b = tournamentParticipants !== null && tournamentParticipants !== void 0 ? tournamentParticipants : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) !== null && _b !== void 0 ? _b : [];
    var existingPairedParticipants = tournamentParticipants.filter(function (participant) {
        return participant.participantType === PAIR &&
            intersection(participantIds, participant.individualParticipantIds)
                .length === participantIds.length &&
            participant.individualParticipantIds.length === participantIds.length;
    });
    var existingPairedParticipant = existingPairedParticipants[0];
    if (!existingPairedParticipant) {
        return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack: stack });
    }
    var duplicatedPairParticipants = makeDeepCopy(existingPairedParticipants.slice(1), false, true);
    return __assign({ participant: makeDeepCopy(existingPairedParticipant), duplicatedPairParticipants: duplicatedPairParticipants }, SUCCESS);
}

function getTeamLineUp(_a) {
    var drawDefinition = _a.drawDefinition, participantId = _a.participantId;
    if (typeof drawDefinition !== 'object')
        return { error: MISSING_DRAW_DEFINITION };
    if (typeof participantId !== 'string')
        return { error: MISSING_PARTICIPANT_ID };
    var extension = findExtension({
        element: drawDefinition,
        name: LINEUPS,
    }).extension;
    var lineUps = (extension === null || extension === void 0 ? void 0 : extension.value) || {};
    var lineUp = lineUps[participantId];
    return { lineUp: lineUp };
}

function getCollectionAssignment(_a) {
    var tournamentParticipants = _a.tournamentParticipants, positionAssignments = _a.positionAssignments, collectionPosition = _a.collectionPosition, _b = _a.drawPositions, drawPositions = _b === void 0 ? [] : _b, participantMap = _a.participantMap, drawDefinition = _a.drawDefinition, collectionId = _a.collectionId, sideLineUps = _a.sideLineUps, matchUpType = _a.matchUpType;
    if (!collectionId || !collectionPosition)
        return {};
    var getAssignment = function (_a) {
        var _b, _c, _d;
        var _e, _f, _g;
        var attribute = _a.attribute, lineUp = _a.lineUp, teamParticipant = _a.teamParticipant;
        var _h = getCollectionPositionAssignments({
            collectionPosition: collectionPosition,
            collectionId: collectionId,
            lineUp: lineUp,
        }), assignedParticipantIds = _h.assignedParticipantIds, substitutions = _h.substitutions;
        if (matchUpType === DOUBLES) {
            if ((assignedParticipantIds === null || assignedParticipantIds === void 0 ? void 0 : assignedParticipantIds.length) <= 2) {
                var pairedParticipantId = (_f = (_e = participantMap === null || participantMap === void 0 ? void 0 : participantMap[assignedParticipantIds[0]]) === null || _e === void 0 ? void 0 : _e.pairIdMap) === null || _f === void 0 ? void 0 : _f[assignedParticipantIds[1]];
                var pairedParticipant = pairedParticipantId && ((_g = participantMap[pairedParticipantId]) === null || _g === void 0 ? void 0 : _g.participant);
                var participant = pairedParticipant ||
                    // resort to brute force
                    getPairedParticipant({
                        participantIds: assignedParticipantIds,
                        tournamentParticipants: tournamentParticipants,
                    }).participant;
                var participantId = participant === null || participant === void 0 ? void 0 : participant.participantId;
                return _b = {},
                    _b[attribute] = { participantId: participantId, teamParticipant: teamParticipant, substitutions: substitutions },
                    _b;
            }
            else if ((assignedParticipantIds === null || assignedParticipantIds === void 0 ? void 0 : assignedParticipantIds.length) > 2) {
                return _c = {}, _c[attribute] = { teamParticipant: teamParticipant, substitutions: substitutions }, _c;
            }
        }
        else {
            var participantId = assignedParticipantIds === null || assignedParticipantIds === void 0 ? void 0 : assignedParticipantIds[0];
            return (participantId && (_d = {},
                _d[attribute] = { participantId: participantId, teamParticipant: teamParticipant, substitutions: substitutions },
                _d));
        }
        return undefined;
    };
    if (!(drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.length)) {
        var sideNumberCollectionAssignment = (sideLineUps === null || sideLineUps === void 0 ? void 0 : sideLineUps.map(function (side) {
            var _a;
            var teamParticipant = side.teamParticipant, sideNumber = side.sideNumber;
            var lineUp = side.lineUp || ((_a = getTeamLineUp({ participantId: teamParticipant.teamParticipantId, drawDefinition: drawDefinition })) === null || _a === void 0 ? void 0 : _a.lineUp);
            return getAssignment({ attribute: sideNumber, lineUp: lineUp, teamParticipant: teamParticipant });
        }).filter(Boolean)) || {};
        return { sideNumberCollectionAssignment: Object.assign.apply(Object, __spreadArray([{}], __read(sideNumberCollectionAssignment), false)) };
    }
    var drawPositionCollectionAssignment = (drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.map(function (drawPosition) {
        var _a, _b, _c;
        var teamParticipantId = (_a = positionAssignments.find(function (assignment) { return assignment.drawPosition === drawPosition; })) === null || _a === void 0 ? void 0 : _a.participantId;
        var side = sideLineUps === null || sideLineUps === void 0 ? void 0 : sideLineUps.find(function (lineUp) { return (lineUp === null || lineUp === void 0 ? void 0 : lineUp.drawPosition) === drawPosition; });
        var teamParticipant = (side === null || side === void 0 ? void 0 : side.teamParticipant) ||
            (teamParticipantId && ((_b = participantMap === null || participantMap === void 0 ? void 0 : participantMap[teamParticipantId]) === null || _b === void 0 ? void 0 : _b.participant)) ||
            (tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.find(function (_a) {
                var participantId = _a.participantId;
                return participantId === teamParticipantId;
            }));
        var lineUp = (side === null || side === void 0 ? void 0 : side.lineUp) ||
            ((_c = getTeamLineUp({
                participantId: teamParticipantId,
                drawDefinition: drawDefinition,
            })) === null || _c === void 0 ? void 0 : _c.lineUp);
        return getAssignment({ attribute: drawPosition, lineUp: lineUp, teamParticipant: teamParticipant });
    }).filter(Boolean)) || {};
    return { drawPositionCollectionAssignment: Object.assign.apply(Object, __spreadArray([{}], __read(drawPositionCollectionAssignment), false)) };
}

function modifyEntryProfile(_a) {
    var drawDefinition = _a.drawDefinition, attributes = _a.attributes;
    var extension = findExtension({
        element: drawDefinition,
        name: ENTRY_PROFILE,
    }).extension;
    var entryProfile = (extension === null || extension === void 0 ? void 0 : extension.value) || {};
    attributes.forEach(function (attribute) {
        Object.keys(attribute).forEach(function (key) {
            if (!entryProfile[key]) {
                entryProfile[key] = attribute[key];
            }
            else {
                Object.assign(entryProfile[key], attribute[key]);
            }
        });
    });
    extension = {
        name: ENTRY_PROFILE,
        value: entryProfile,
    };
    addDrawDefinitionExtension({ drawDefinition: drawDefinition, extension: extension });
    return { entryProfile: entryProfile };
}

function getEntryProfile(_a) {
    var drawDefinition = _a.drawDefinition;
    var extension = findExtension({
        element: drawDefinition,
        name: ENTRY_PROFILE,
    }).extension;
    var entryProfile = (extension === null || extension === void 0 ? void 0 : extension.value) || {};
    return { entryProfile: entryProfile };
}

var ALTERNATE = 'ALTERNATE';
var CONFIRMED = 'CONFIRMED';
var DIRECT_ACCEPTANCE = 'DIRECT_ACCEPTANCE';
var FEED_IN = 'FEED_IN';
var JUNIOR_EXEMPT = 'JUNIOR_EXEMPT';
var LUCKY_LOSER = 'LUCKY_LOSER';
var ORGANISER_ACCEPTANCE = 'ORGANISER_ACCEPTANCE';
var QUALIFIER = 'QUALIFIER';
var REGISTERED = 'REGISTERED';
var SPECIAL_EXEMPT = 'SPECIAL_EXEMPT';
var UNGROUPED = 'UNGROUPED';
var UNPAIRED = 'UNPAIRED';
var WILDCARD = 'WILDCARD';
var WITHDRAWN = 'WITHDRAWN';
var EQUIVALENT_ACCEPTANCE_STATUSES = [
    CONFIRMED,
    DIRECT_ACCEPTANCE,
    JUNIOR_EXEMPT,
    ORGANISER_ACCEPTANCE,
    SPECIAL_EXEMPT,
];
var DRAW_SPECIFIC_STATUSES = [FEED_IN, LUCKY_LOSER, QUALIFIER];
var DIRECT_ENTRY_STATUSES = [
    CONFIRMED,
    DIRECT_ACCEPTANCE,
    FEED_IN,
    JUNIOR_EXEMPT,
    ORGANISER_ACCEPTANCE,
    SPECIAL_EXEMPT,
    WILDCARD,
];
var STRUCTURE_SELECTED_STATUSES = [
    CONFIRMED,
    DIRECT_ACCEPTANCE,
    JUNIOR_EXEMPT,
    LUCKY_LOSER,
    QUALIFIER,
    ORGANISER_ACCEPTANCE,
    SPECIAL_EXEMPT,
    WILDCARD,
];
var VALID_ENTRY_STATUSES = [
    ALTERNATE,
    CONFIRMED,
    DIRECT_ACCEPTANCE,
    FEED_IN,
    JUNIOR_EXEMPT,
    LUCKY_LOSER,
    ORGANISER_ACCEPTANCE,
    QUALIFIER,
    REGISTERED,
    SPECIAL_EXEMPT,
    UNGROUPED,
    UNPAIRED,
    WILDCARD,
    WITHDRAWN,
];
var entryStatusConstants = {
    ALTERNATE: ALTERNATE,
    CONFIRMED: CONFIRMED,
    DIRECT_ACCEPTANCE: DIRECT_ACCEPTANCE,
    DIRECT_ENTRY_STATUSES: DIRECT_ENTRY_STATUSES,
    DRAW_SPECIFIC_STATUSES: DRAW_SPECIFIC_STATUSES,
    EQUIVALENT_ACCEPTANCE_STATUSES: EQUIVALENT_ACCEPTANCE_STATUSES,
    FEED_IN: FEED_IN,
    JUNIOR_EXEMPT: JUNIOR_EXEMPT,
    LUCKY_LOSER: LUCKY_LOSER,
    ORGANISER_ACCEPTANCE: ORGANISER_ACCEPTANCE,
    QUALIFIER: QUALIFIER,
    SPECIAL_EXEMPT: SPECIAL_EXEMPT,
    STRUCTURE_SELECTED_STATUSES: STRUCTURE_SELECTED_STATUSES,
    UNGROUPED: UNGROUPED,
    UNPAIRED: UNPAIRED,
    VALID_ENTRY_STATUSES: VALID_ENTRY_STATUSES,
    WILDCARD: WILDCARD,
    WITHDRAWN: WITHDRAWN,
};

function stageExists(_a) {
    var _b;
    var stage = _a.stage, drawDefinition = _a.drawDefinition;
    var entryProfile = getEntryProfile({ drawDefinition: drawDefinition }).entryProfile;
    var exists = Object.keys(entryProfile).includes(stage);
    if (!exists && validStages.includes(stage)) {
        var attributes = [
            (_b = {},
                _b[stage] = {
                    drawSize: undefined,
                    alternates: true,
                },
                _b),
        ];
        modifyEntryProfile({ drawDefinition: drawDefinition, attributes: attributes });
        return true;
    }
    return exists;
}
function stageAlternatesCount(_a) {
    var _b;
    var stage = _a.stage, drawDefinition = _a.drawDefinition;
    var entryProfile = getEntryProfile({ drawDefinition: drawDefinition }).entryProfile;
    return ((_b = entryProfile[stage]) === null || _b === void 0 ? void 0 : _b.alternates) || 0;
}
function getStageWildcardsCount(_a) {
    var _b;
    var stage = _a.stage, drawDefinition = _a.drawDefinition;
    var entryProfile = getEntryProfile({ drawDefinition: drawDefinition }).entryProfile;
    return ((_b = entryProfile[stage]) === null || _b === void 0 ? void 0 : _b.wildcardsCount) || 0;
}
function getStageEntryTypeCount(_a) {
    var stage = _a.stage, drawDefinition = _a.drawDefinition, entryStatus = _a.entryStatus;
    return drawDefinition.entries.reduce(function (p, c) { return (c.entryStage === stage && c.entryStatus === entryStatus ? p + 1 : p); }, 0);
}
function getStageEntries$1(_a) {
    var _b, _c;
    var provisionalPositioning = _a.provisionalPositioning, placementGroup = _a.placementGroup, drawDefinition = _a.drawDefinition, stageSequence = _a.stageSequence, entryStatuses = _a.entryStatuses, structureId = _a.structureId, roundTarget = _a.roundTarget, stages = _a.stages, stage = _a.stage;
    var entries = (_c = (_b = drawDefinition.entries) === null || _b === void 0 ? void 0 : _b.reduce(function (entries, entry) {
        var _a, _b, _c;
        var entryRoundTarget = (_b = (_a = findExtension({
            name: ROUND_TARGET,
            element: entry,
        })) === null || _a === void 0 ? void 0 : _a.extension) === null || _b === void 0 ? void 0 : _b.value;
        var stageTarget = (stage && entry.entryStage === stage) ||
            ((stages === null || stages === void 0 ? void 0 : stages.length) && entry.entryStage && stages.includes(entry.entryStage));
        var matchesEntryType = !entryStatuses || (entry.entryStatus && entryStatuses.includes(entry.entryStatus));
        var entryStageSequence = (_c = entry.entryStageSequence) !== null && _c !== void 0 ? _c : 1; // default to 1 if not present
        var sameStageSequence = !stageSequence || entryStageSequence === stageSequence;
        var targetMatch = !roundTarget || !entryRoundTarget || roundTarget === entryRoundTarget;
        return stageTarget && sameStageSequence && matchesEntryType && targetMatch ? entries.concat(entry) : entries;
    }, [])) !== null && _c !== void 0 ? _c : [];
    // handle POSITION entries
    if (structureId && stage === PLAY_OFF) {
        var _d = getPlayoffEntries({
            provisionalPositioning: provisionalPositioning,
            drawDefinition: drawDefinition,
            structureId: structureId,
        }), playoffEntries = _d.playoffEntries, error = _d.error;
        if (error) {
            console.log('playoff entries error'); // TODO: bubble this up...
        }
        return ((playoffEntries === null || playoffEntries === void 0 ? void 0 : playoffEntries.length) ? playoffEntries : entries).filter(function (entry) { return !placementGroup || entry.placementGroup === placementGroup; });
    }
    return entries;
}
function getPlayoffEntries(_a) {
    var _b, _c;
    var provisionalPositioning = _a.provisionalPositioning, drawDefinition = _a.drawDefinition, structureId = _a.structureId;
    var playoffEntries = [];
    var inboundLink = ((_b = drawDefinition.links) !== null && _b !== void 0 ? _b : []).find(function (link) { return link.linkType === POSITION && link.target.structureId === structureId; });
    if (inboundLink) {
        // links from round robins include an array of finishing positions
        // which qualify participants to travel across a link to a playoff structure
        var _d = inboundLink.source, finishingPositions_1 = _d.finishingPositions, structureId_1 = _d.structureId;
        var sourceStructure = findStructure({
            drawDefinition: drawDefinition,
            structureId: structureId_1,
        }).structure;
        // for group participant results to be tallied,
        // the source structure must be a container of other structures
        if ((sourceStructure === null || sourceStructure === void 0 ? void 0 : sourceStructure.structureType) === CONTAINER) {
            var playoffStructures = (_c = sourceStructure.structures) !== null && _c !== void 0 ? _c : [];
            playoffStructures.forEach(function (structure) {
                var _a;
                var positionAssignments = (_a = structure.positionAssignments) !== null && _a !== void 0 ? _a : [];
                var playoffStructureId = structure.structureId;
                var groupingValue = playoffStructureId;
                var results = Object.assign.apply(Object, __spreadArray([{}], __read(positionAssignments
                    .map(function (assignment) {
                    var _a;
                    var _b;
                    var participantId = assignment.participantId;
                    var results = (_b = findExtension({
                        element: assignment,
                        name: TALLY,
                    }).extension) === null || _b === void 0 ? void 0 : _b.value;
                    return results && participantId ? (_a = {}, _a[participantId] = results, _a) : undefined;
                })
                    .filter(Boolean)), false));
                // TODO: ignore structures where finishingPositions are not unique
                var uniqueFinishingPositions = Object.keys(results).reduce(function (unique, key) {
                    var result = results[key];
                    var finishingPosition = result.groupOrder || (provisionalPositioning && result.provisionalOrder);
                    if (!unique.includes(finishingPosition)) {
                        unique.push(finishingPosition);
                    }
                    return unique;
                }, []);
                var finishingPositionsAreUnique = uniqueFinishingPositions.length === Object.keys(results).length;
                var participantIds = Object.keys(results).filter(function (key) {
                    var result = results[key];
                    var finishingPosition = result.groupOrder || (provisionalPositioning && result.provisionalOrder);
                    return finishingPositions_1 === null || finishingPositions_1 === void 0 ? void 0 : finishingPositions_1.includes(finishingPosition);
                });
                if (!provisionalPositioning || finishingPositionsAreUnique) {
                    participantIds.forEach(function (participantId) {
                        var participantResult = results[participantId];
                        var groupOrder = participantResult.groupOrder, provisionalOrder = participantResult.provisionalOrder, GEMscore = participantResult.GEMscore;
                        var finishingPosition = groupOrder || (provisionalPositioning && provisionalOrder);
                        // spread to avoid immutable client data
                        var placementGroup = __spreadArray([], __read((finishingPositions_1 !== null && finishingPositions_1 !== void 0 ? finishingPositions_1 : [])), false).sort(numericSort).indexOf(finishingPosition) + 1;
                        playoffEntries.push({
                            entryStage: PLAY_OFF,
                            entryStatus: FEED_IN,
                            placementGroup: placementGroup,
                            groupingValue: groupingValue,
                            participantId: participantId,
                            GEMscore: GEMscore,
                        });
                    });
                }
            });
        }
    }
    return { playoffEntries: playoffEntries };
}
function getStageDirectEntriesCount(_a) {
    var stage = _a.stage, drawDefinition = _a.drawDefinition;
    return DIRECT_ENTRY_STATUSES.reduce(function (count, entryStatus) {
        var statusCount = getStageEntryTypeCount({
            drawDefinition: drawDefinition,
            entryStatus: entryStatus,
            stage: stage,
        });
        return (statusCount || 0) + count;
    }, 0);
}

function getStructureSeedAssignments(_a) {
    var _b;
    var _c, _d;
    var provisionalPositioning = _a.provisionalPositioning, returnAllProxies = _a.returnAllProxies, drawDefinition = _a.drawDefinition, structureId = _a.structureId, structure = _a.structure;
    var error, seedAssignments = [];
    if (!structure) {
        (_b = findStructure({ drawDefinition: drawDefinition, structureId: structureId }), structure = _b.structure, error = _b.error);
    }
    var positionAssignments = getPositionAssignments$1({
        structure: structure,
    }).positionAssignments;
    if (error || !structure)
        return { seedAssignments: [], error: STRUCTURE_NOT_FOUND };
    if (!structureId)
        structureId = structure.structureId;
    var stage = structure.stage, stageSequence = structure.stageSequence;
    var isPlayoffStructure = stage === PLAY_OFF;
    var entries = isPlayoffStructure &&
        drawDefinition &&
        getStageEntries$1({
            provisionalPositioning: provisionalPositioning,
            drawDefinition: drawDefinition,
            stageSequence: stageSequence,
            structureId: structureId,
            stage: stage,
        });
    var proxiedEntries = entries
        ? entries
            .filter(function (entry) { return entry.placementGroup === 1; })
            .sort(function (a, b) {
            // GEMscore is used here because headToHead encounters are not relevant
            // when the participants are derived from more than one RR group
            return ((a.GEMscore < b.GEMscore && 1) ||
                (a.GEMscore > b.GEMscore && -1) ||
                0);
        })
            .map(function (entry, index) {
            var seedNumber = index + 1;
            return {
                participantId: entry.participantId,
                seedValue: seedNumber,
                seedProxy: true, // flag so that proxy seeding information doesn't get used externally
                seedNumber: seedNumber,
            };
        })
        : [];
    var seedProxies = proxiedEntries === null || proxiedEntries === void 0 ? void 0 : proxiedEntries.slice(0, returnAllProxies ? proxiedEntries.length : positionAssignments.length / 2);
    if (seedProxies.length) {
        // seedProxies are only found in PLAY_OFF when ROUND_ROBIN is MAIN stage
        seedAssignments = seedProxies;
    }
    else if (structure.seedAssignments) {
        seedAssignments = structure.seedAssignments;
    }
    else {
        error = MISSING_SEED_ASSIGNMENTS;
    }
    var seedLimit = (_c = structure.seedLimit) !== null && _c !== void 0 ? _c : (_d = structure === null || structure === void 0 ? void 0 : structure.positionAssignments) === null || _d === void 0 ? void 0 : _d.length;
    return {
        seedAssignments: seedAssignments,
        stageSequence: stageSequence,
        seedLimit: seedLimit,
        stage: stage,
        error: error,
    };
}

var add = function (a, b) { return (a || 0) + (b || 0); };
function getBand(spread, bandProfiles) {
    var spreadValue = Array.isArray(spread) ? spread[0] : spread;
    return ((isNaN(spreadValue) && WALKOVER$1) ||
        (spreadValue <= bandProfiles[DECISIVE] && DECISIVE) ||
        (spreadValue <= bandProfiles[ROUTINE] && ROUTINE) ||
        COMPETITIVE);
}
function getScoreComponents(_a) {
    var score = _a.score;
    var sets = (score === null || score === void 0 ? void 0 : score.sets) || [];
    var games = sets.reduce(function (p, c) {
        p[0] += c.side1Score || 0;
        p[1] += c.side2Score || 0;
        return p;
    }, [0, 0]);
    var stb = sets.reduce(function (p, c) {
        p[0] += c.side1TiebreakScore || 0;
        p[1] += c.side2TiebreakScore || 0;
        return p;
    }, [0, 0]);
    // add an extra game to the winner of tiebreak
    if (stb.reduce(add)) {
        games[stb[0] > stb[1] ? 0 : 1] += 1;
    }
    return { sets: sets, games: games, score: score };
}
function gamesPercent(scoreComponents) {
    var minGames = Math.min.apply(Math, __spreadArray([], __read(scoreComponents.games), false));
    var maxGames = Math.max.apply(Math, __spreadArray([], __read(scoreComponents.games), false));
    return Math.round((minGames / maxGames) * 100);
}
function pctSpread(pcts) {
    return pcts
        .map(gamesPercent)
        .sort()
        .map(function (p) { return parseFloat(p.toFixed(2)); });
}

function findPolicy(_a) {
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, policyType = _a.policyType, structure = _a.structure, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var appliedPolicies = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    }).appliedPolicies;
    return (appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[policyType])
        ? { policy: appliedPolicies[policyType] }
        : { info: POLICY_NOT_FOUND === null || POLICY_NOT_FOUND === void 0 ? void 0 : POLICY_NOT_FOUND.message };
}

function getMatchUpCompetitiveProfile(_a) {
    var tournamentRecord = _a.tournamentRecord, profileBands = _a.profileBands, matchUp = _a.matchUp;
    if (!matchUp)
        return { error: MISSING_MATCHUP };
    var score = matchUp.score, winningSide = matchUp.winningSide;
    if (!winningSide)
        return { error: INVALID_VALUES };
    var policy = !profileBands &&
        tournamentRecord &&
        findPolicy({
            policyType: POLICY_TYPE_COMPETITIVE_BANDS,
            tournamentRecord: tournamentRecord,
        }).policy;
    var bandProfiles = profileBands ||
        (policy === null || policy === void 0 ? void 0 : policy.profileBands) ||
        POLICY_COMPETITIVE_BANDS_DEFAULT[POLICY_TYPE_COMPETITIVE_BANDS]
            .profileBands;
    var scoreComponents = getScoreComponents({ score: score });
    var spread = pctSpread([scoreComponents]);
    var competitiveness = getBand(spread, bandProfiles);
    var pctSpreadValue = Array.isArray(spread) ? spread[0] : spread;
    return __assign(__assign({}, SUCCESS), { competitiveness: competitiveness, pctSpread: pctSpreadValue });
}

function getMatchUpParticipantIds(_a) {
    var _b, _c, _d, _e, _f, _g, _h, _j, _k;
    var matchUp = _a.matchUp;
    if (!matchUp)
        return { error: MISSING_MATCHUP };
    if (matchUp && !matchUp.sides)
        return { error: INVALID_MATCHUP };
    if (matchUp && !matchUp.hasContext)
        return { error: MISSING_CONTEXT };
    var sideParticipantIds = (_c = ((_b = matchUp.sides) !== null && _b !== void 0 ? _b : [])) === null || _c === void 0 ? void 0 : _c.map(function (side) { return side === null || side === void 0 ? void 0 : side.participantId; }).filter(Boolean);
    var sideIndividualParticipantIds = (_e = (_d = matchUp.sides) === null || _d === void 0 ? void 0 : _d.filter(function (side) { var _a; return ((_a = side.participant) === null || _a === void 0 ? void 0 : _a.participantType) === INDIVIDUAL; }).map(function (participant) { return participant.participantId; }).filter(Boolean)) !== null && _e !== void 0 ? _e : [];
    var nestedIndividualParticipants = (_h = (_g = ((_f = matchUp.sides) !== null && _f !== void 0 ? _f : [])) === null || _g === void 0 ? void 0 : _g.map(function (side) { var _a; return (_a = side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipants; }).filter(Boolean)) !== null && _h !== void 0 ? _h : [];
    var nestedIndividualParticipantIds = nestedIndividualParticipants.map(function (participants) {
        return (participants !== null && participants !== void 0 ? participants : [])
            .map(function (participant) { return participant === null || participant === void 0 ? void 0 : participant.participantId; })
            .filter(Boolean);
    });
    var individualParticipantIds = (_j = __spreadArray(__spreadArray([], __read(sideIndividualParticipantIds), false), __read(nestedIndividualParticipantIds.flat()), false).filter(Boolean)) !== null && _j !== void 0 ? _j : [];
    var allRelevantParticipantIds = (_k = unique(individualParticipantIds.concat(sideParticipantIds)).filter(Boolean)) !== null && _k !== void 0 ? _k : [];
    return __assign({ nestedIndividualParticipantIds: nestedIndividualParticipantIds, allRelevantParticipantIds: allRelevantParticipantIds, individualParticipantIds: individualParticipantIds, sideParticipantIds: sideParticipantIds }, SUCCESS);
}

var CHECK_IN = 'CHECK_IN';
var CHECK_OUT = 'CHECK_OUT';
var SCHEDULE$1 = 'SCHEDULE';
var ASSIGN_VENUE = 'SCHEDULE.ASSIGNMENT.VENUE';
var ALLOCATE_COURTS = 'SCHEDULE.ALLOCATION.COURTS';
var ASSIGN_COURT = 'SCHEDULE.ASSIGNMENT.COURT';
var COURT_ORDER = 'SCHEDULE.COURT.ORDER';
var SCHEDULED_DATE = 'SCHEDULE.DATE';
var COMPLETED_DATE = 'COMPLETED.DATE'; // considering adding this timeItem on completed score entry provided date is between tournament startDate/endDate
var ASSIGN_OFFICIAL = 'SCHEDULE.ASSIGN.OFFICIAL';
var SCHEDULED_TIME = 'SCHEDULE.TIME.SCHEDULED';
var START_TIME = 'SCHEDULE.TIME.START';
var STOP_TIME = 'SCHEDULE.TIME.STOP';
var RESUME_TIME = 'SCHEDULE.TIME.RESUME';
var END_TIME = 'SCHEDULE.TIME.END';
var TIME_MODIFIERS = 'SCHEDULE.TIME.MODIFIERS';
var TO_BE_ANNOUNCED = 'TO_BE_ANNOUNCED';
var NEXT_AVAILABLE = 'NEXT_AVAILABLE';
var FOLLOWED_BY = 'FOLLOWED_BY';
var AFTER_REST = 'AFTER_REST';
var RAIN_DELAY = 'RAIN_DELAY';
var NOT_BEFORE = 'NOT_BEFORE';
var MUTUALLY_EXCLUSIVE_TIME_MODIFIERS = [
    TO_BE_ANNOUNCED,
    NEXT_AVAILABLE,
    FOLLOWED_BY,
    AFTER_REST,
    RAIN_DELAY,
];
var ELIGIBILITY = 'ELIGIBILITY';
var REGISTRATION = 'REGISTRATION';
var SUSPENSION = 'SUSPENSION';
var MEDICAL$1 = 'MEDICAL';
var PENALTY$1 = 'PENALTY';
var SCALE = 'SCALE';
var RATING = 'RATING'; // 'SCALE.RATING'
var RANKING = 'RANKING'; // 'SCALE.RANKING'
var SEEDING = 'SEEDING'; // 'SCALE.SEEDING'
var PUBLISH = 'PUBLISH';
var PUBLIC = 'PUBLIC';
var STATUS$1 = 'STATUS';
var MODIFICATION = 'MODIFICATION';
var RETRIEVAL = 'RETRIEVAL';
var OTHER$3 = 'other';
var timeItemConstants = {
    MUTUALLY_EXCLUSIVE_TIME_MODIFIERS: MUTUALLY_EXCLUSIVE_TIME_MODIFIERS,
    AFTER_REST: AFTER_REST,
    ALLOCATE_COURTS: ALLOCATE_COURTS,
    ASSIGN_COURT: ASSIGN_COURT,
    ASSIGN_OFFICIAL: ASSIGN_OFFICIAL,
    ASSIGN_VENUE: ASSIGN_VENUE,
    CHECK_IN: CHECK_IN,
    CHECK_OUT: CHECK_OUT,
    COMPLETED_DATE: COMPLETED_DATE,
    COURT_ORDER: COURT_ORDER,
    ELIGIBILITY: ELIGIBILITY,
    END_TIME: END_TIME,
    FOLLOWED_BY: FOLLOWED_BY,
    MEDICAL: MEDICAL$1,
    MODIFICATION: MODIFICATION,
    NEXT_AVAILABLE: NEXT_AVAILABLE,
    NOT_BEFORE: NOT_BEFORE,
    OTHER: OTHER$3,
    PENALTY: PENALTY$1,
    PUBLIC: PUBLIC,
    PUBLISH: PUBLISH,
    RANKING: RANKING,
    RATING: RATING,
    RAIN_DELAY: RAIN_DELAY,
    REGISTRATION: REGISTRATION,
    RESUME_TIME: RESUME_TIME,
    RETRIEVAL: RETRIEVAL,
    SCALE: SCALE,
    SCHEDULE: SCHEDULE$1,
    SCHEDULED_DATE: SCHEDULED_DATE,
    SCHEDULED_TIME: SCHEDULED_TIME,
    SEEDING: SEEDING,
    START_TIME: START_TIME,
    STATUS: STATUS$1,
    STOP_TIME: STOP_TIME,
    SUSPENSION: SUSPENSION,
    TIME_MODIFIERS: TIME_MODIFIERS,
    TO_BE_ANNOUNCED: TO_BE_ANNOUNCED,
};

/*
  takes a matchUpWithContext
  returns all participaantIds which have current checkedIn status
    - if sideParticipant is participantType TEAM or PAIR then
      sideParticipant is considered checkedIn if all individualParticipants are checkedIn
    - if sideParticipant is participantType TEAM or PAIR and is checkedIn then
      all individualParticipants are considered checkedIn
*/
function getCheckedInParticipantIds(_a) {
    var _b;
    var matchUp = _a.matchUp;
    if (!matchUp)
        return { error: MISSING_MATCHUP };
    if (!matchUp.hasContext) {
        return { error: MISSING_CONTEXT };
    }
    if (!matchUp.sides || matchUp.sides.filter(Boolean).length !== 2) {
        return { error: INVALID_MATCHUP };
    }
    var _c = getMatchUpParticipantIds({ matchUp: matchUp }), nestedIndividualParticipantIds = _c.nestedIndividualParticipantIds, allRelevantParticipantIds = _c.allRelevantParticipantIds, sideParticipantIds = _c.sideParticipantIds;
    var timeItems = (_b = matchUp.timeItems) !== null && _b !== void 0 ? _b : [];
    var checkInItems = timeItems
        .filter(function (timeItem) {
        return (timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType) && [CHECK_IN, CHECK_OUT].includes(timeItem.itemType);
    })
        .sort(function (a, b) {
        return (a.createdAt ? new Date(a.createdAt).getTime() : 0) -
            (b.createdAt ? new Date(b.createdAt).getTime() : 0);
    });
    var timeItemParticipantIds = checkInItems.map(function (timeItem) { return timeItem.itemValue; });
    // first determine whether each timeItemParticipantId is checkedIn
    var checkedInParticipantIds = timeItemParticipantIds.filter(function (participantId) {
        return (checkInItems
            .filter(function (timeItem) { return (timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemValue) === participantId; })
            .reverse()[0].itemType === CHECK_IN);
    });
    // if all individuals on one side are checked in then side is checked in
    nestedIndividualParticipantIds === null || nestedIndividualParticipantIds === void 0 ? void 0 : nestedIndividualParticipantIds.forEach(function (sideIndividualParticipantIds, sideIndex) {
        var sideParticipantId = sideParticipantIds === null || sideParticipantIds === void 0 ? void 0 : sideParticipantIds[sideIndex];
        var allIndividualsCheckedIn = (sideIndividualParticipantIds === null || sideIndividualParticipantIds === void 0 ? void 0 : sideIndividualParticipantIds.length) &&
            sideIndividualParticipantIds.every(function (participantId) {
                return checkedInParticipantIds.includes(participantId);
            });
        if (sideParticipantId &&
            allIndividualsCheckedIn &&
            !checkedInParticipantIds.includes(sideParticipantId)) {
            checkedInParticipantIds.push(sideParticipantId);
        }
    });
    // if side is checked in then all individuals on that side are checked in
    sideParticipantIds === null || sideParticipantIds === void 0 ? void 0 : sideParticipantIds.forEach(function (sideParticipantId, sideIndex) {
        var _a;
        if (checkedInParticipantIds.includes(sideParticipantId)) {
            ((_a = nestedIndividualParticipantIds === null || nestedIndividualParticipantIds === void 0 ? void 0 : nestedIndividualParticipantIds[sideIndex]) !== null && _a !== void 0 ? _a : []).forEach(function (participantId) {
                if (participantId &&
                    !checkedInParticipantIds.includes(participantId)) {
                    checkedInParticipantIds.push(participantId);
                }
            });
        }
    });
    var allParticipantsCheckedIn = sideParticipantIds === null || sideParticipantIds === void 0 ? void 0 : sideParticipantIds.reduce(function (checkedIn, participantId) {
        return checkedInParticipantIds.includes(participantId) && checkedIn;
    }, true);
    return __assign({ allRelevantParticipantIds: allRelevantParticipantIds, allParticipantsCheckedIn: allParticipantsCheckedIn, checkedInParticipantIds: checkedInParticipantIds }, SUCCESS);
}

function findMatchupFormatAverageTimes(params) {
    var _a = params || {}, matchUpAverageTimes = _a.matchUpAverageTimes, matchUpFormat = _a.matchUpFormat;
    // first find all matchUpAverageTime definitions which include matchUpFormats...
    // ... that either exactly match or start with the target matchUpFormat.
    var codeMatches = (matchUpAverageTimes === null || matchUpAverageTimes === void 0 ? void 0 : matchUpAverageTimes.map(function (_a) {
        var matchUpFormatCodes = _a.matchUpFormatCodes;
        return matchUpFormatCodes === null || matchUpFormatCodes === void 0 ? void 0 : matchUpFormatCodes.filter(function (code) { return code === matchUpFormat; });
    }).flat().filter(Boolean).sort(function (a, b) { return ((a === null || a === void 0 ? void 0 : a.length) || 0) - ((b === null || b === void 0 ? void 0 : b.length) || 0); })) || [];
    // determine if there is an exact match
    var exactCodeMatch = codeMatches.includes(matchUpFormat);
    // select the exact match or the shortest code which matches
    var targetCode = exactCodeMatch ? matchUpFormat : codeMatches[0];
    var targetDefinition = matchUpAverageTimes === null || matchUpAverageTimes === void 0 ? void 0 : matchUpAverageTimes.find(function (_a) {
        var matchUpFormatCodes = _a.matchUpFormatCodes, averageTimes = _a.averageTimes;
        return (matchUpFormatCodes === null || matchUpFormatCodes === void 0 ? void 0 : matchUpFormatCodes.find(function (code) { return targetCode === code; })) && averageTimes;
    });
    return targetDefinition === null || targetDefinition === void 0 ? void 0 : targetDefinition.averageTimes;
}
function findMatchupFormatRecoveryTimes(params) {
    var _a;
    var _b = params || {}, matchUpRecoveryTimes = _b.matchUpRecoveryTimes, averageMinutes = _b.averageMinutes, matchUpFormat = _b.matchUpFormat;
    return (_a = matchUpRecoveryTimes === null || matchUpRecoveryTimes === void 0 ? void 0 : matchUpRecoveryTimes.find(function (_a) {
        var matchUpFormatCodes = _a.matchUpFormatCodes, averageTimes = _a.averageTimes, recoveryTimes = _a.recoveryTimes;
        if (averageTimes && averageMinutes) {
            var _b = averageTimes.greaterThan, greaterThan = _b === void 0 ? 0 : _b, _c = averageTimes.lessThan, lessThan = _c === void 0 ? 360 : _c;
            if (averageMinutes > greaterThan && averageMinutes < lessThan)
                return true;
        }
        return ((matchUpFormatCodes === null || matchUpFormatCodes === void 0 ? void 0 : matchUpFormatCodes.find(function (code) { return code === matchUpFormat; })) &&
            recoveryTimes);
    })) === null || _a === void 0 ? void 0 : _a.recoveryTimes;
}

function findCategoryTiming(_a) {
    var timesBlockArray = _a.timesBlockArray, categoryName = _a.categoryName, categoryType = _a.categoryType;
    return timesBlockArray
        .filter(function (f) { return Array.isArray(f); })
        .map(function (times) {
        return times
            .sort(function (a, b) { var _a, _b; return (((_a = b.categoryNames) === null || _a === void 0 ? void 0 : _a.length) || 0) - (((_b = a.categoryNames) === null || _b === void 0 ? void 0 : _b.length) || 0); })
            .find(function (_a) {
            var categoryTypes = _a.categoryTypes, categoryNames = _a.categoryNames;
            return (!(categoryNames === null || categoryNames === void 0 ? void 0 : categoryNames.length) && !(categoryTypes === null || categoryTypes === void 0 ? void 0 : categoryTypes.length)) ||
                (categoryNames === null || categoryNames === void 0 ? void 0 : categoryNames.includes(categoryName)) ||
                (categoryTypes === null || categoryTypes === void 0 ? void 0 : categoryTypes.includes(categoryType));
        });
    })
        .find(Boolean);
}

function getMatchUpFormatRecoveryTimes(_a) {
    var _b;
    var tournamentScheduling = _a.tournamentScheduling, eventScheduling = _a.eventScheduling, averageMinutes = _a.averageMinutes, defaultTiming = _a.defaultTiming, matchUpFormat = _a.matchUpFormat, categoryName = _a.categoryName, categoryType = _a.categoryType, policy = _a.policy;
    var eventRecoveryTimes = (eventScheduling === null || eventScheduling === void 0 ? void 0 : eventScheduling.matchUpRecoveryTimes) &&
        findMatchupFormatRecoveryTimes(__assign(__assign({}, eventScheduling), { averageMinutes: averageMinutes, matchUpFormat: matchUpFormat }));
    var tournamentRecoveryTimes = (tournamentScheduling === null || tournamentScheduling === void 0 ? void 0 : tournamentScheduling.matchUpRecoveryTimes) &&
        findMatchupFormatRecoveryTimes(__assign(__assign({}, tournamentScheduling), { averageMinutes: averageMinutes, matchUpFormat: matchUpFormat }));
    var policyRecoveryTimes = (policy === null || policy === void 0 ? void 0 : policy.matchUpRecoveryTimes) &&
        findMatchupFormatRecoveryTimes(__assign(__assign({}, policy), { averageMinutes: averageMinutes, matchUpFormat: matchUpFormat }));
    var timesBlockArray = [
        eventRecoveryTimes,
        tournamentRecoveryTimes,
        policyRecoveryTimes,
        (_b = policy === null || policy === void 0 ? void 0 : policy.defaultTimes) === null || _b === void 0 ? void 0 : _b.recoveryTimes,
        defaultTiming === null || defaultTiming === void 0 ? void 0 : defaultTiming.recoveryTimes,
    ];
    return findCategoryTiming({
        categoryName: categoryName,
        categoryType: categoryType,
        timesBlockArray: timesBlockArray,
    });
}

function getMatchUpFormatAverageTimes(_a) {
    var _b;
    var matchUpFormat = _a.matchUpFormat, categoryName = _a.categoryName, categoryType = _a.categoryType, defaultTiming = _a.defaultTiming, tournamentScheduling = _a.tournamentScheduling, eventScheduling = _a.eventScheduling, policy = _a.policy;
    var eventAverageTimes = (eventScheduling === null || eventScheduling === void 0 ? void 0 : eventScheduling.matchUpAverageTimes) &&
        findMatchupFormatAverageTimes(__assign(__assign({}, eventScheduling), { matchUpFormat: matchUpFormat }));
    var tournamentAverageTimes = (tournamentScheduling === null || tournamentScheduling === void 0 ? void 0 : tournamentScheduling.matchUpAverageTimes) &&
        findMatchupFormatAverageTimes(__assign(__assign({}, tournamentScheduling), { matchUpFormat: matchUpFormat }));
    var policyAverageTimes = (policy === null || policy === void 0 ? void 0 : policy.matchUpAverageTimes) &&
        findMatchupFormatAverageTimes(__assign(__assign({}, policy), { matchUpFormat: matchUpFormat }));
    var timesBlockArray = [
        eventAverageTimes,
        tournamentAverageTimes,
        policyAverageTimes,
        (_b = policy === null || policy === void 0 ? void 0 : policy.defaultTimes) === null || _b === void 0 ? void 0 : _b.averageTimes,
        defaultTiming === null || defaultTiming === void 0 ? void 0 : defaultTiming.averageTimes,
    ];
    return findCategoryTiming({
        categoryName: categoryName,
        categoryType: categoryType,
        timesBlockArray: timesBlockArray,
    });
}

function getScheduleTiming(_a) {
    var _b, _c, _d, _e, _f, _g;
    var tournamentRecord = _a.tournamentRecord, categoryName = _a.categoryName, categoryType = _a.categoryType, event = _a.event;
    categoryName =
        (_c = categoryName !== null && categoryName !== void 0 ? categoryName : (_b = event === null || event === void 0 ? void 0 : event.category) === null || _b === void 0 ? void 0 : _b.categoryName) !== null && _c !== void 0 ? _c : (_d = event === null || event === void 0 ? void 0 : event.category) === null || _d === void 0 ? void 0 : _d.ageCategoryCode;
    categoryType =
        (_f = categoryType !== null && categoryType !== void 0 ? categoryType : (_e = event === null || event === void 0 ? void 0 : event.category) === null || _e === void 0 ? void 0 : _e.categoryType) !== null && _f !== void 0 ? _f : (_g = event === null || event === void 0 ? void 0 : event.category) === null || _g === void 0 ? void 0 : _g.subType;
    var policy = findPolicy({
        policyType: POLICY_TYPE_SCHEDULING,
        tournamentRecord: tournamentRecord,
        event: event,
    }).policy;
    var tournamentExtension = tournamentRecord
        ? findExtension({
            element: tournamentRecord,
            name: SCHEDULE_TIMING,
        }).extension
        : undefined;
    var tournamentScheduling = tournamentExtension === null || tournamentExtension === void 0 ? void 0 : tournamentExtension.value;
    var eventExtension = event &&
        findExtension({
            name: SCHEDULE_TIMING,
            element: event,
        }).extension;
    var eventScheduling = eventExtension === null || eventExtension === void 0 ? void 0 : eventExtension.value;
    var scheduleTiming = {
        tournamentScheduling: tournamentScheduling,
        eventScheduling: eventScheduling,
        categoryName: categoryName,
        categoryType: categoryType,
        policy: policy,
    };
    return { scheduleTiming: scheduleTiming };
}

var DOUBLES_SINGLES = 'DOUBLES_SINGLES';
var SINGLES_DOUBLES = 'SINGLES_DOUBLES';
var TOTAL = 'total';
var CONFLICT_PARTICIPANTS = 'participantConflict';
var CONFLICT_MATCHUP_ORDER = 'matchUpConflict';
var SCHEDULE_ISSUE_IDS = 'ISSUE_IDS';
var SCHEDULE_CONFLICT = 'CONFLICT';
var SCHEDULE_WARNING = 'WARNING';
var SCHEDULE_ERROR = 'ERROR';
var SCHEDULE_ISSUE = 'ISSUE';
var SCHEDULE_STATE = 'STATE';
var scheduleConstants = {
    SINGLES_DOUBLES: SINGLES_DOUBLES,
    DOUBLES_SINGLES: DOUBLES_SINGLES,
    TOTAL: TOTAL,
    CONFLICT_MATCHUP_ORDER: CONFLICT_MATCHUP_ORDER,
    CONFLICT_PARTICIPANTS: CONFLICT_PARTICIPANTS,
    SCHEDULE_ISSUE_IDS: SCHEDULE_ISSUE_IDS,
    SCHEDULE_CONFLICT: SCHEDULE_CONFLICT,
    SCHEDULE_WARNING: SCHEDULE_WARNING,
    SCHEDULE_ERROR: SCHEDULE_ERROR,
    SCHEDULE_ISSUE: SCHEDULE_ISSUE,
    SCHEDULE_STATE: SCHEDULE_STATE,
};

function getMatchUpFormatTiming(_a) {
    var _b;
    var _c = _a.defaultAverageMinutes, defaultAverageMinutes = _c === void 0 ? 90 : _c, _d = _a.defaultRecoveryMinutes, defaultRecoveryMinutes = _d === void 0 ? 0 : _d, tournamentRecord = _a.tournamentRecord, matchUpFormat = _a.matchUpFormat, categoryName = _a.categoryName, categoryType = _a.categoryType, eventType = _a.eventType, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    // event is optional, so eventType can also be passed in directly
    eventType = (_b = eventType !== null && eventType !== void 0 ? eventType : event === null || event === void 0 ? void 0 : event.eventType) !== null && _b !== void 0 ? _b : SINGLES_EVENT;
    var defaultTiming = {
        averageTimes: [{ minutes: { default: defaultAverageMinutes } }],
        recoveryTimes: [{ minutes: { default: defaultRecoveryMinutes } }],
    };
    var scheduleTiming = getScheduleTiming({
        tournamentRecord: tournamentRecord,
        categoryName: categoryName,
        categoryType: categoryType,
        event: event,
    }).scheduleTiming;
    var timingDetails = __assign(__assign({}, scheduleTiming), { matchUpFormat: matchUpFormat, categoryType: categoryType, defaultTiming: defaultTiming });
    return matchUpFormatTimes({ eventType: eventType, timingDetails: timingDetails });
}
function matchUpFormatTimes(_a) {
    var timingDetails = _a.timingDetails, eventType = _a.eventType;
    var averageTimes = getMatchUpFormatAverageTimes(timingDetails);
    var averageKeys = Object.keys((averageTimes === null || averageTimes === void 0 ? void 0 : averageTimes.minutes) || {});
    var averageMinutes = (averageTimes === null || averageTimes === void 0 ? void 0 : averageTimes.minutes) &&
        (((averageKeys === null || averageKeys === void 0 ? void 0 : averageKeys.includes(eventType)) && averageTimes.minutes[eventType]) ||
            averageTimes.minutes.default);
    var recoveryTimes = getMatchUpFormatRecoveryTimes(__assign(__assign({}, timingDetails), { averageMinutes: averageMinutes }));
    var recoveryKeys = Object.keys((recoveryTimes === null || recoveryTimes === void 0 ? void 0 : recoveryTimes.minutes) || {});
    var recoveryMinutes = (recoveryTimes === null || recoveryTimes === void 0 ? void 0 : recoveryTimes.minutes) &&
        (((recoveryKeys === null || recoveryKeys === void 0 ? void 0 : recoveryKeys.includes(eventType)) && recoveryTimes.minutes[eventType]) ||
            recoveryTimes.minutes.default);
    var formatChangeKey = eventType === SINGLES_EVENT ? SINGLES_DOUBLES : DOUBLES_SINGLES;
    var typeChangeRecoveryMinutes = (recoveryTimes === null || recoveryTimes === void 0 ? void 0 : recoveryTimes.minutes) &&
        (((recoveryKeys === null || recoveryKeys === void 0 ? void 0 : recoveryKeys.includes(formatChangeKey)) &&
            recoveryTimes.minutes[formatChangeKey]) ||
            recoveryMinutes);
    return { averageMinutes: averageMinutes, recoveryMinutes: recoveryMinutes, typeChangeRecoveryMinutes: typeChangeRecoveryMinutes };
}

function getTimeStamp(item) {
    return !item.createdAt ? 0 : new Date(item.createdAt).getTime();
}
function latestVisibleTimeItemValue(_a) {
    // TODO: should visibilityThreshold be combination of scheduled date/time
    var visibilityThreshold = _a.visibilityThreshold, timeItems = _a.timeItems, itemType = _a.itemType;
    var latestVisible = timeItems
        .filter(function (timeItem) {
        return timeItem &&
            timeItem.itemType === itemType &&
            (!visibilityThreshold ||
                getTimeStamp(timeItem) < new Date(visibilityThreshold).getTime());
    })
        .sort(function (a, b) { return getTimeStamp(a) - getTimeStamp(b); })
        .pop();
    var timeStamp = latestVisible && getTimeStamp(latestVisible);
    return { itemValue: latestVisible === null || latestVisible === void 0 ? void 0 : latestVisible.itemValue, timeStamp: timeStamp };
}

function scheduledMatchUpTime(_a) {
    var visibilityThreshold = _a.visibilityThreshold, timeStamp = _a.timeStamp, schedule = _a.schedule, matchUp = _a.matchUp;
    var _b = latestVisibleTimeItemValue({
        timeItems: (matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) || [],
        itemType: SCHEDULED_TIME,
        visibilityThreshold: visibilityThreshold,
    }), scheduledTime = _b.itemValue, itemTimeStamp = _b.timeStamp;
    return !schedule ||
        (itemTimeStamp &&
            timeStamp &&
            new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())
        ? { scheduledTime: scheduledTime }
        : schedule;
}

function scheduledMatchUpDate(_a) {
    var visibilityThreshold = _a.visibilityThreshold, timeStamp = _a.timeStamp, schedule = _a.schedule, matchUp = _a.matchUp;
    var _b = latestVisibleTimeItemValue({
        timeItems: (matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) || [],
        itemType: SCHEDULED_DATE,
        visibilityThreshold: visibilityThreshold,
    }), scheduledDate = _b.itemValue, itemTimeStamp = _b.timeStamp;
    return !schedule ||
        (itemTimeStamp &&
            timeStamp &&
            new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())
        ? { scheduledDate: scheduledDate }
        : schedule;
}

function matchUpAllocatedCourts(_a) {
    var visibilityThreshold = _a.visibilityThreshold, timeStamp = _a.timeStamp, schedule = _a.schedule, matchUp = _a.matchUp;
    var _b = latestVisibleTimeItemValue({
        timeItems: (matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) || [],
        itemType: ALLOCATE_COURTS,
        visibilityThreshold: visibilityThreshold,
    }), allocatedCourts = _b.itemValue, itemTimeStamp = _b.timeStamp;
    return !schedule ||
        (itemTimeStamp &&
            timeStamp &&
            new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())
        ? { allocatedCourts: makeDeepCopy(allocatedCourts, false, true) }
        : schedule;
}

function matchUpAssignedCourtId(_a) {
    var visibilityThreshold = _a.visibilityThreshold, timeStamp = _a.timeStamp, schedule = _a.schedule, matchUp = _a.matchUp;
    var _b = latestVisibleTimeItemValue({
        timeItems: (matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) || [],
        itemType: ASSIGN_COURT,
        visibilityThreshold: visibilityThreshold,
    }), courtId = _b.itemValue, itemTimeStamp = _b.timeStamp;
    return !schedule ||
        (itemTimeStamp &&
            timeStamp &&
            new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())
        ? { courtId: courtId }
        : schedule;
}

function matchUpAssignedVenueId(_a) {
    var visibilityThreshold = _a.visibilityThreshold, timeStamp = _a.timeStamp, schedule = _a.schedule, matchUp = _a.matchUp;
    var _b = latestVisibleTimeItemValue({
        timeItems: (matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) || [],
        itemType: ASSIGN_VENUE,
        visibilityThreshold: visibilityThreshold,
    }), venueId = _b.itemValue, itemTimeStamp = _b.timeStamp;
    return !schedule ||
        (itemTimeStamp &&
            timeStamp &&
            new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())
        ? { venueId: venueId }
        : schedule;
}

function getLinkedTournamentIds(_a) {
    var tournamentRecords = _a.tournamentRecords;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var linkedTournamentIds = Object.assign.apply(Object, __spreadArray([{}], __read(Object.keys(tournamentRecords).map(function (tournamentId) {
        var _a;
        var _b;
        var tournamentRecord = tournamentRecords[tournamentId];
        var touranmentId = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId;
        var extension = findExtension({
            element: tournamentRecord,
            name: LINKED_TOURNAMENTS,
        }).extension;
        var tournamentIds = (((_b = extension === null || extension === void 0 ? void 0 : extension.value) === null || _b === void 0 ? void 0 : _b.tournamentIds) || []).filter(function (currentTournamentId) { return currentTournamentId !== touranmentId; });
        return _a = {}, _a[tournamentId] = tournamentIds, _a;
    })), false));
    return { linkedTournamentIds: linkedTournamentIds };
}

function resolveTournamentRecords(params) {
    var _a;
    var _b, _c;
    return ((_c = (_b = params === null || params === void 0 ? void 0 : params.tournamentRecords) !== null && _b !== void 0 ? _b : ((params === null || params === void 0 ? void 0 : params.tournamentRecord) && (_a = {},
        _a[params.tournamentRecord.tournamentId] = params.tournamentRecord,
        _a))) !== null && _c !== void 0 ? _c : {});
}

/*
  based on an answer provided by Jeff Ward on StackOverflow; November 2019
  https://stackoverflow.com/users/1026023/jeff-ward
  https://stackoverflow.com/questions/105034/how-to-create-guid-uuid?rq=1
*/
/**
 * generate a given number of UUIDs
 *
 * @param {number} count - number of UUIDs to generate
 */
function UUIDS(count) {
    if (count === void 0) { count = 1; }
    return generateRange(0, count).map(UUID);
}
function UUID() {
    var lut = [];
    for (var i = 0; i < 256; i++) {
        lut[i] = (i < 16 ? '0' : '') + i.toString(16);
    }
    var d0 = (Math.random() * 0xffffffff) | 0;
    var d1 = (Math.random() * 0xffffffff) | 0;
    var d2 = (Math.random() * 0xffffffff) | 0;
    var d3 = (Math.random() * 0xffffffff) | 0;
    // eslint-disable-next-line no-mixed-operators
    return (lut[d0 & 0xff] +
        lut[(d0 >> 8) & 0xff] +
        lut[(d0 >> 16) & 0xff] +
        lut[(d0 >> 24) & 0xff] +
        '-' +
        // eslint-disable-next-line no-mixed-operators
        lut[d1 & 0xff] +
        lut[(d1 >> 8) & 0xff] +
        '-' +
        lut[((d1 >> 16) & 0x0f) | 0x40] +
        lut[(d1 >> 24) & 0xff] +
        '-' +
        // eslint-disable-next-line no-mixed-operators
        lut[(d2 & 0x3f) | 0x80] +
        lut[(d2 >> 8) & 0xff] +
        '-' +
        lut[(d2 >> 16) & 0xff] +
        lut[(d2 >> 24) & 0xff] +
        // eslint-disable-next-line no-mixed-operators
        lut[d3 & 0xff] +
        lut[(d3 >> 8) & 0xff] +
        lut[(d3 >> 16) & 0xff] +
        lut[(d3 >> 24) & 0xff]);
}

var ADD_DRAW_DEFINITION = 'addDrawDefinition';
var ADD_MATCHUPS = 'addMatchUps';
var ADD_PARTICIPANTS = 'addParticipants';
var ADD_SCALE_ITEMS = 'addScaleItems';
var ADD_VENUE = 'addVenue';
var AUDIT = 'audit';
var DELETE_PARTICIPANTS = 'deleteParticipants';
var DELETE_VENUE = 'deleteVenue';
var DELETED_DRAW_IDS = 'deletedDrawIds';
var DELETED_MATCHUP_IDS = 'deletedMatchUpIds';
var MODIFY_DRAW_DEFINITION = 'modifyDrawDefinition';
var MODIFY_DRAW_ENTRIES = 'modifyDrawEntries';
var MODIFY_EVENT_ENTRIES = 'modifyEventEntries';
var MODIFY_MATCHUP = 'modifyMatchUp';
var MODIFY_PARTICIPANTS = 'modifyParticipants';
var MODIFY_POSITION_ASSIGNMENTS = 'modifyPositionAssignments';
var MODIFY_SEED_ASSIGNMENTS = 'modifySeedAssignments';
var MODIFY_TOURNAMENT_DETAIL = 'modifyTournamentDetail';
var MODIFY_VENUE = 'modifyVenue';
var MUTATIONS = 'mutations';
var PUBLISH_EVENT = 'publishEvent';
var PUBLISH_EVENT_SEEDING = 'publishEventSeeding';
var PUBLISH_ORDER_OF_PLAY = 'publishOrderOfPlay';
var UNPUBLISH_EVENT = 'unPublishEvent';
var UNPUBLISH_EVENT_SEEDING = 'unPublishEventSeeding';
var UNPUBLISH_ORDER_OF_PLAY = 'unPublishOrderOfPlay';
var UPDATE_INCONTEXT_MATCHUP = 'updateInContextMatchUp';
var topicConstants = {
    ADD_DRAW_DEFINITION: ADD_DRAW_DEFINITION,
    ADD_MATCHUPS: ADD_MATCHUPS,
    ADD_PARTICIPANTS: ADD_PARTICIPANTS,
    ADD_SCALE_ITEMS: ADD_SCALE_ITEMS,
    ADD_VENUE: ADD_VENUE,
    AUDIT: AUDIT,
    DELETE_PARTICIPANTS: DELETE_PARTICIPANTS,
    DELETE_VENUE: DELETE_VENUE,
    DELETED_DRAW_IDS: DELETED_DRAW_IDS,
    DELETED_MATCHUP_IDS: DELETED_MATCHUP_IDS,
    MODIFY_DRAW_DEFINITION: MODIFY_DRAW_DEFINITION,
    MODIFY_DRAW_ENTRIES: MODIFY_DRAW_ENTRIES, // TODO
    MODIFY_EVENT_ENTRIES: MODIFY_EVENT_ENTRIES, // TODO
    MODIFY_MATCHUP: MODIFY_MATCHUP,
    MODIFY_PARTICIPANTS: MODIFY_PARTICIPANTS,
    MODIFY_POSITION_ASSIGNMENTS: MODIFY_POSITION_ASSIGNMENTS,
    MODIFY_SEED_ASSIGNMENTS: MODIFY_SEED_ASSIGNMENTS,
    MODIFY_TOURNAMENT_DETAIL: MODIFY_TOURNAMENT_DETAIL,
    MODIFY_VENUE: MODIFY_VENUE,
    MUTATIONS: MUTATIONS,
    PUBLISH_EVENT_SEEDING: PUBLISH_EVENT_SEEDING,
    PUBLISH_EVENT: PUBLISH_EVENT,
    PUBLISH_ORDER_OF_PLAY: PUBLISH_ORDER_OF_PLAY,
    UNPUBLISH_EVENT_SEEDING: UNPUBLISH_EVENT_SEEDING,
    UNPUBLISH_EVENT: UNPUBLISH_EVENT,
    UNPUBLISH_ORDER_OF_PLAY: UNPUBLISH_ORDER_OF_PLAY,
    UPDATE_INCONTEXT_MATCHUP: UPDATE_INCONTEXT_MATCHUP,
};

function addVenue(params) {
    var e_1, _a;
    var disableNotice = params.disableNotice, venue = params.venue, context = params.context;
    if (typeof venue !== 'object')
        return { error: INVALID_VALUES };
    var tournamentRecords = resolveTournamentRecords(params);
    if (!venue.venueId)
        venue.venueId = UUID();
    var addedVenue;
    try {
        for (var _b = __values(Object.values(tournamentRecords)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var tournamentRecord = _c.value;
            var result = venueAdd({
                disableNotice: true,
                tournamentRecord: tournamentRecord,
                context: context,
                venue: venue,
            });
            if (result === null || result === void 0 ? void 0 : result.error)
                return result;
            addedVenue = result.venue;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (!disableNotice) {
        addNotice({ topic: ADD_VENUE, payload: { venue: venue } });
    }
    return definedAttributes(__assign(__assign({}, SUCCESS), { venue: addedVenue }));
}
function venueAdd(_a) {
    var tournamentRecord = _a.tournamentRecord, disableNotice = _a.disableNotice, context = _a.context, venue = _a.venue;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!venue)
        return { error: MISSING_VALUE, info: 'missing venue' };
    if (!tournamentRecord.venues)
        tournamentRecord.venues = [];
    if (!venue.venueId)
        venue.venueId = UUID();
    var venueExists = tournamentRecord.venues.reduce(function (exists, existingVenue) {
        return exists || existingVenue.venueId === venue.venueId;
    }, undefined);
    if (!venueExists) {
        if (context) {
            var extension = {
                value: context,
                name: CONTEXT,
            };
            addExtension({ element: venue, extension: extension });
        }
        tournamentRecord.venues.push(venue);
        if (!disableNotice) {
            addNotice({
                payload: { venue: venue, tournamentId: tournamentRecord.tournamentId },
                topic: ADD_VENUE,
            });
        }
        return __assign(__assign({}, SUCCESS), { venue: makeDeepCopy(venue) });
    }
    else {
        return { error: VENUE_EXISTS };
    }
}

function findVenue(_a) {
    var e_1, _b;
    var _c, _d;
    var tournamentRecords = _a.tournamentRecords, tournamentRecord = _a.tournamentRecord, venueId = _a.venueId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!venueId)
        return { error: MISSING_VENUE_ID };
    var venues = (_c = tournamentRecord.venues) !== null && _c !== void 0 ? _c : [];
    var venue = venues.reduce(function (venue, venueRecord) {
        return venueRecord.venueId === venueId ? venueRecord : venue;
    }, undefined);
    if (!venue && tournamentRecords) {
        var linkedTournamentIds = (_d = getLinkedTournamentIds({
            tournamentRecords: tournamentRecords,
        }).linkedTournamentIds) !== null && _d !== void 0 ? _d : [];
        var relevantIds = linkedTournamentIds[tournamentRecord.tournamentId];
        try {
            // if there are linked tournaments search for court in all linked tournaments
            for (var relevantIds_1 = __values(relevantIds), relevantIds_1_1 = relevantIds_1.next(); !relevantIds_1_1.done; relevantIds_1_1 = relevantIds_1.next()) {
                var tournamentId = relevantIds_1_1.value;
                var record = tournamentRecords[tournamentId];
                var result = findVenue({ tournamentRecord: record, venueId: venueId });
                // if venue is found in linked tournamentRecords, add venue to original tournamentRecord
                if (result.success && result.venue) {
                    addVenue({ tournamentRecord: tournamentRecord, venue: result.venue });
                    return __assign(__assign({}, SUCCESS), { venue: venue });
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (relevantIds_1_1 && !relevantIds_1_1.done && (_b = relevantIds_1.return)) _b.call(relevantIds_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    if (!venue) {
        return { error: VENUE_NOT_FOUND };
    }
    else {
        return __assign(__assign({}, SUCCESS), { venue: venue });
    }
}
function publicFindVenue(_a) {
    var convertExtensions = _a.convertExtensions, params = __rest(_a, ["convertExtensions"]);
    var tournamentRecords = params.tournamentRecords, tournamentRecord = params.tournamentRecord, venueId = params.venueId;
    var result = findVenue({ tournamentRecords: tournamentRecords, tournamentRecord: tournamentRecord, venueId: venueId });
    return makeDeepCopy(result, convertExtensions, true);
}

function findCourt(_a) {
    var e_1, _b;
    var _c, _d;
    var tournamentRecords = _a.tournamentRecords, tournamentRecord = _a.tournamentRecord, courtId = _a.courtId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!courtId)
        return { error: MISSING_COURT_ID };
    var stack = 'findCourt';
    var court, venue;
    ((_c = tournamentRecord.venues) !== null && _c !== void 0 ? _c : []).forEach(function (venueRecord) {
        var _a;
        ((_a = venueRecord.courts) !== null && _a !== void 0 ? _a : []).forEach(function (courtRecord) {
            if (courtRecord.courtId === courtId) {
                court = courtRecord;
                venue = venueRecord;
            }
        });
    });
    if (court) {
        return __assign(__assign({}, SUCCESS), { court: court, venue: venue });
    }
    else if (tournamentRecords) {
        // if tournamentRecords is provided then call is from competitionEngine
        var linkedTournamentIds = (_d = getLinkedTournamentIds({
            tournamentRecords: tournamentRecords,
        }).linkedTournamentIds) !== null && _d !== void 0 ? _d : [];
        var relevantIds = linkedTournamentIds[tournamentRecord.tournamentId];
        try {
            // if there are linked tournaments search for court in all linked tournaments
            for (var relevantIds_1 = __values(relevantIds), relevantIds_1_1 = relevantIds_1.next(); !relevantIds_1_1.done; relevantIds_1_1 = relevantIds_1.next()) {
                var tournamentId = relevantIds_1_1.value;
                var record = tournamentRecords[tournamentId];
                var result = findCourt({ tournamentRecord: record, courtId: courtId });
                // if court is found in linked tournamentRecords, add venue to original tournamentRecord
                if (result.success) {
                    result.venue && addVenue({ tournamentRecord: tournamentRecord, venue: result.venue });
                    return __assign(__assign({}, SUCCESS), { court: court, venue: venue });
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (relevantIds_1_1 && !relevantIds_1_1.done && (_b = relevantIds_1.return)) _b.call(relevantIds_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    // fall through to error condition
    return decorateResult({ result: { error: COURT_NOT_FOUND }, stack: stack });
}
function publicFindCourt(params) {
    return makeDeepCopy(findCourt(params), false, true);
}

function getCourtInfo(_a) {
    var tournamentRecord = _a.tournamentRecord, internalUse = _a.internalUse, courtId = _a.courtId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!courtId)
        return { error: MISSING_COURT_ID };
    var result = findCourt({ tournamentRecord: tournamentRecord, courtId: courtId });
    if (result.error)
        return result;
    var courtInfo = result.court &&
        (function (_a) {
            var altitude = _a.altitude, courtId = _a.courtId, courtName = _a.courtName, courtDimensions = _a.courtDimensions, latitude = _a.latitude, longitude = _a.longitude, surfaceCategory = _a.surfaceCategory, surfaceType = _a.surfaceType, surfacedDate = _a.surfacedDate, pace = _a.pace, notes = _a.notes;
            return ({
                altitude: altitude,
                courtId: courtId,
                courtName: courtName,
                courtDimensions: courtDimensions,
                latitude: latitude,
                longitude: longitude,
                surfaceCategory: surfaceCategory,
                surfaceType: surfaceType,
                surfacedDate: surfacedDate,
                pace: pace,
                notes: notes,
            });
        })(result.court);
    return __assign(__assign({}, SUCCESS), { courtInfo: makeDeepCopy(courtInfo, false, internalUse) });
}

function getVenueData(_a) {
    var _b, _c;
    var tournamentRecord = _a.tournamentRecord, venueId = _a.venueId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!venueId)
        return { error: MISSING_VENUE_ID };
    var result = findVenue({ tournamentRecord: tournamentRecord, venueId: venueId });
    if (result.error)
        return result;
    var courts = (_c = (_b = result.venue) === null || _b === void 0 ? void 0 : _b.courts) !== null && _c !== void 0 ? _c : [];
    var courtsInfo = courts.map(function (court) {
        return (function (_a) {
            var courtInfo = _a.courtInfo;
            return (__assign({}, courtInfo));
        })(getCourtInfo({
            courtId: court.courtId,
            internalUse: true,
            tournamentRecord: tournamentRecord,
        }));
    });
    var venueInfo = result.venue &&
        (function (_a) {
            var venueId = _a.venueId, venueName = _a.venueName, venueAbbreviation = _a.venueAbbreviation;
            return ({
                venueAbbreviation: venueAbbreviation,
                venueName: venueName,
                venueId: venueId,
            });
        })(result.venue);
    var venueData = venueInfo && __assign(__assign({}, venueInfo), { courtsInfo: courtsInfo });
    return __assign(__assign({}, SUCCESS), { venueData: makeDeepCopy(venueData, false, true) });
}

function matchUpTimeModifiers(_a) {
    var visibilityThreshold = _a.visibilityThreshold, timeStamp = _a.timeStamp, schedule = _a.schedule, matchUp = _a.matchUp;
    var _b = latestVisibleTimeItemValue({
        timeItems: (matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) || [],
        itemType: TIME_MODIFIERS,
        visibilityThreshold: visibilityThreshold,
    }), timeModifiers = _b.itemValue, itemTimeStamp = _b.timeStamp;
    return !schedule ||
        (itemTimeStamp &&
            timeStamp &&
            new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())
        ? { timeModifiers: timeModifiers }
        : schedule;
}

function timeDate$1(value) {
    if (validTimeString.test(value)) {
        var dateString = getUTCdateString();
        return new Date("".concat(dateString, "T").concat(value));
    }
    else {
        return new Date(value);
    }
}
function matchUpDuration(_a) {
    var matchUp = _a.matchUp;
    if (!matchUp)
        return { error: MISSING_MATCHUP };
    if (!matchUp.timeItems)
        return { error: MISSING_TIME_ITEMS };
    var relevantTimeItems = matchUp.timeItems
        .filter(function (timeItem) {
        return [START_TIME, STOP_TIME, RESUME_TIME, END_TIME].includes(timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType);
    })
        .sort(function (a, b) {
        return timeDate$1(a.itemValue).getTime() - timeDate$1(b.itemValue).getTime();
    });
    var elapsed = relevantTimeItems.reduce(function (elapsed, timeItem) {
        var _a, _b;
        var milliseconds;
        var itemTypeComponents = (_a = timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType) === null || _a === void 0 ? void 0 : _a.split('.');
        var timeType = ((_b = timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType) === null || _b === void 0 ? void 0 : _b.startsWith('SCHEDULE.TIME')) &&
            itemTypeComponents[2];
        var scheduleType = "SCHEDULE.TIME.".concat(timeType);
        switch (scheduleType) {
            case START_TIME:
                milliseconds = 0;
                break;
            case END_TIME:
                if (elapsed.lastValue &&
                    [START_TIME, RESUME_TIME].includes(elapsed.lastType)) {
                    var interval = timeDate$1(timeItem.itemValue).getTime() -
                        timeDate$1(elapsed.lastValue).getTime();
                    milliseconds = elapsed.milliseconds + interval;
                }
                else {
                    milliseconds = elapsed.milliseconds;
                }
                break;
            case STOP_TIME:
                if ([START_TIME, 'SCHECULE.TIME.RESUME'].includes(elapsed.lastType)) {
                    var interval = timeDate$1(timeItem.itemValue).getTime() -
                        timeDate$1(elapsed.lastValue).getTime();
                    milliseconds = elapsed.milliseconds + interval;
                }
                else {
                    milliseconds = elapsed.milliseconds;
                }
                break;
            default:
                milliseconds = elapsed.milliseconds;
                break;
        }
        return {
            milliseconds: milliseconds,
            lastType: scheduleType,
            lastValue: timeItem.itemValue,
        };
    }, { milliseconds: 0, lastType: undefined, lastValue: undefined });
    if ([START_TIME, RESUME_TIME].includes(elapsed.lastType)) {
        var interval = new Date().getTime() - timeDate$1(elapsed.lastValue).getTime();
        elapsed.milliseconds += interval;
    }
    return {
        milliseconds: elapsed.milliseconds,
        time: msToTime(elapsed.milliseconds),
        relevantTimeItems: relevantTimeItems,
    };
}
function msToTime(s) {
    var pad = function (n, z) {
        if (z === void 0) { z = 2; }
        return ('00' + n).slice(-z);
    };
    return (pad((s / 3.6e6) | 0) +
        ':' +
        pad(((s % 3.6e6) / 6e4) | 0) +
        ':' +
        pad(((s % 6e4) / 1000) | 0));
}

function getFlightProfile(_a) {
    var _b;
    var event = _a.event, eventId = _a.eventId;
    if (!event)
        return { error: MISSING_EVENT };
    var result = findExtension({
        name: FLIGHT_PROFILE,
        element: event,
    });
    var extension = result === null || result === void 0 ? void 0 : result.extension;
    // eventId indicates that `getFlightProfile()` has been called via `tournamentEngine`
    // a deep copy is made and drawDefinitions are attached for client convenience
    var flightProfile = eventId
        ? makeDeepCopy(extension === null || extension === void 0 ? void 0 : extension.value, false, true)
        : extension === null || extension === void 0 ? void 0 : extension.value;
    if (eventId) {
        (_b = event.drawDefinitions) === null || _b === void 0 ? void 0 : _b.forEach(function (drawDefinition) {
            var _a;
            (_a = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _a === void 0 ? void 0 : _a.forEach(function (flight) {
                if (flight.drawId === drawDefinition.drawId) {
                    Object.assign(flight, { drawDefinition: drawDefinition });
                }
            });
        });
    }
    return { flightProfile: flightProfile };
}

function findEvent(params) {
    var _a;
    var _b, _c;
    var tournamentRecord = params.tournamentRecord, eventId = params.eventId, drawId = params.drawId;
    var stack = 'findEvent';
    var eventIdsMap = {};
    var tournamentRecords = (_c = (_b = params.tournamentRecords) !== null && _b !== void 0 ? _b : (tournamentRecord && (_a = {},
        _a[tournamentRecord.tournamentId] = tournamentRecord,
        _a))) !== null && _c !== void 0 ? _c : {};
    var events = Object.values(tournamentRecords)
        .map(function (_a) {
        var events = _a.events, tournamentId = _a.tournamentId;
        if (events) {
            events.forEach(function (event) {
                eventIdsMap[event.eventId] = { tournamentId: tournamentId };
            });
        }
        return events !== null && events !== void 0 ? events : [];
    })
        .flat();
    var tournamentId;
    if (drawId) {
        var drawDefinition_1;
        var event_1 = events.find(function (event) {
            var _a, _b, _c;
            var drawDefinitions = (_a = event === null || event === void 0 ? void 0 : event.drawDefinitions) !== null && _a !== void 0 ? _a : [];
            var targetDrawDefinition = drawDefinitions.find(function (drawDefinition) { return drawDefinition.drawId === drawId; });
            if (targetDrawDefinition) {
                drawDefinition_1 = targetDrawDefinition;
                tournamentId = eventIdsMap[event.eventId].tournamentId;
            }
            else {
                var flightProfile = event && ((_b = getFlightProfile({ event: event })) === null || _b === void 0 ? void 0 : _b.flightProfile);
                var flight = (_c = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _c === void 0 ? void 0 : _c.find(function (flight) { return flight.drawId === drawId; });
                if (flight) {
                    tournamentId = eventIdsMap[event.eventId].tournamentId;
                    return {
                        entries: flight.drawEntries,
                        drawName: flight.drawName,
                        tournamentId: tournamentId,
                        drawId: drawId,
                    };
                }
            }
            return targetDrawDefinition;
        });
        if (event_1)
            return { event: event_1, drawDefinition: drawDefinition_1, tournamentId: tournamentId };
    }
    if (eventId) {
        var event_2 = events.find(function (event) { return (event === null || event === void 0 ? void 0 : event.eventId) === eventId; });
        if (!event_2) {
            return __assign({ event: undefined, drawDefinition: undefined }, decorateResult({ result: { error: EVENT_NOT_FOUND }, stack: stack }));
        }
        else {
            tournamentId = eventIdsMap[event_2.eventId].tournamentId;
        }
        return { event: event_2, drawDefinition: undefined, tournamentId: tournamentId };
    }
    return __assign({ event: undefined, drawDefinition: undefined }, decorateResult({
        result: { error: DRAW_DEFINITION_NOT_FOUND },
        context: { drawId: drawId, eventId: eventId },
        stack: stack,
    }));
}

function matchUpCourtOrder(_a) {
    var visibilityThreshold = _a.visibilityThreshold, timeStamp = _a.timeStamp, schedule = _a.schedule, matchUp = _a.matchUp;
    var _b = latestVisibleTimeItemValue({
        timeItems: (matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) || [],
        itemType: COURT_ORDER,
        visibilityThreshold: visibilityThreshold,
    }), courtOrder = _b.itemValue, itemTimeStamp = _b.timeStamp;
    return !schedule ||
        (itemTimeStamp &&
            timeStamp &&
            new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())
        ? { courtOrder: courtOrder }
        : schedule;
}

function matchUpStartTime(_a) {
    var matchUp = _a.matchUp;
    var timeItems = (matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) || [];
    var getTimeStamp = function (item) {
        return !item.createdAt ? 0 : new Date(item.createdAt).getTime();
    };
    var startTimeItem = timeItems.reduce(function (startTimeItem, timeItem) {
        var startTimeCandidate = timeItem.itemType === START_TIME && timeItem;
        var earlierStartTimeItem = startTimeCandidate &&
            (!startTimeItem ||
                getTimeStamp(startTimeCandidate) < getTimeStamp(startTimeItem));
        return earlierStartTimeItem ? startTimeCandidate : startTimeItem;
    }, undefined);
    var startTime = startTimeItem === null || startTimeItem === void 0 ? void 0 : startTimeItem.itemValue;
    return { startTime: startTime };
}

function matchUpEndTime(_a) {
    var matchUp = _a.matchUp;
    var timeItems = (matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) || [];
    var getTimeStamp = function (item) {
        return !item.createdAt ? 0 : new Date(item.createdAt).getTime();
    };
    var endTimeItem = timeItems.reduce(function (endTimeItem, timeItem) {
        var endTimeCandidate = timeItem.itemType === END_TIME && timeItem;
        var earlierStartTimeItem = endTimeCandidate &&
            (!endTimeItem ||
                getTimeStamp(endTimeCandidate) > getTimeStamp(endTimeItem));
        return earlierStartTimeItem ? endTimeCandidate : endTimeItem;
    }, undefined);
    var endTime = endTimeItem === null || endTimeItem === void 0 ? void 0 : endTimeItem.itemValue;
    return { endTime: endTime };
}

function getMatchUpScheduleDetails(params) {
    var _a, _b, _c, _d, _e, e_1, _f;
    var _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    var event = params.event;
    var matchUpType = params.matchUpType;
    var scheduleVisibilityFilters = params.scheduleVisibilityFilters, afterRecoveryTimes = params.afterRecoveryTimes, tournamentRecord = params.tournamentRecord, usePublishState = params.usePublishState, scheduleTiming = params.scheduleTiming, matchUpFormat = params.matchUpFormat, publishStatus = params.publishStatus, matchUp = params.matchUp;
    if (!matchUp)
        return { error: MISSING_MATCHUP };
    // matchUpType is required to derive averageMatchUpMinutes and recoveryMinutes.
    /// If matchUpType is not provided or is not present on matchUp...
    // ...attempt to derive by interrogating structure, draw, and event
    if (afterRecoveryTimes &&
        !matchUp.matchUpType &&
        !params.matchUpType &&
        (event || tournamentRecord) &&
        matchUp.drawId) {
        var drawDefinition = (_g = event === null || event === void 0 ? void 0 : event.drawDefinitions) === null || _g === void 0 ? void 0 : _g.find(function (drawDefinition) { return drawDefinition.drawId === matchUp.drawId; });
        if (!drawDefinition && tournamentRecord) {
            (_a = findEvent({
                tournamentRecord: tournamentRecord,
                drawId: matchUp.drawId,
            }), drawDefinition = _a.drawDefinition, event = _a.event);
        }
        var structure = matchUp.structureId &&
            ((_h = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) === null || _h === void 0 ? void 0 : _h.find(function (_a) {
                var structureId = _a.structureId;
                return structureId === matchUp.structureId;
            }));
        matchUpType =
            params.matchUpType ||
                (structure === null || structure === void 0 ? void 0 : structure.matchUpType) ||
                (drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.matchUpType) ||
                ((event === null || event === void 0 ? void 0 : event.eventType) !== TEAM$2 && (event === null || event === void 0 ? void 0 : event.eventType));
    }
    var _u = matchUpDuration({ matchUp: matchUp }), milliseconds = _u.milliseconds, time = _u.time;
    var startTime = matchUpStartTime({ matchUp: matchUp }).startTime;
    var endTime = matchUpEndTime({ matchUp: matchUp }).endTime;
    var schedule;
    var _v = scheduleVisibilityFilters !== null && scheduleVisibilityFilters !== void 0 ? scheduleVisibilityFilters : {}, visibilityThreshold = _v.visibilityThreshold, eventIds = _v.eventIds, drawIds = _v.drawIds;
    if ((!eventIds || eventIds.includes(matchUp.eventId)) &&
        (!drawIds || drawIds.includes(matchUp.drawId))) {
        var scheduleSource = { matchUp: matchUp, visibilityThreshold: visibilityThreshold };
        var allocatedCourts = matchUpAllocatedCourts(scheduleSource).allocatedCourts;
        var scheduledTime_1 = scheduledMatchUpTime(scheduleSource).scheduledTime;
        var scheduledDate_1 = scheduledMatchUpDate(scheduleSource).scheduledDate;
        var venueId = matchUpAssignedVenueId(scheduleSource).venueId;
        var courtId_1 = matchUpAssignedCourtId(scheduleSource).courtId;
        var courtOrder = matchUpCourtOrder(scheduleSource).courtOrder;
        var timeModifiers = matchUpTimeModifiers(scheduleSource).timeModifiers;
        var timeAfterRecovery = void 0, averageMinutes = void 0, recoveryMinutes = void 0, typeChangeRecoveryMinutes = void 0, typeChangeTimeAfterRecovery = void 0;
        var eventType = (_j = matchUp.matchUpType) !== null && _j !== void 0 ? _j : matchUpType;
        if (scheduleTiming && scheduledTime_1 && afterRecoveryTimes && eventType) {
            var timingDetails = __assign({ matchUpFormat: (_k = matchUp.matchUpFormat) !== null && _k !== void 0 ? _k : matchUpFormat }, scheduleTiming);
            (_b = matchUpFormatTimes({
                timingDetails: timingDetails,
                eventType: eventType,
            }), _c = _b.averageMinutes, averageMinutes = _c === void 0 ? 0 : _c, _d = _b.recoveryMinutes, recoveryMinutes = _d === void 0 ? 0 : _d, _e = _b.typeChangeRecoveryMinutes, typeChangeRecoveryMinutes = _e === void 0 ? 0 : _e);
            if (averageMinutes || recoveryMinutes) {
                timeAfterRecovery = endTime
                    ? addMinutesToTimeString(extractTime(endTime), recoveryMinutes)
                    : addMinutesToTimeString(scheduledTime_1, averageMinutes + recoveryMinutes);
            }
            if (typeChangeRecoveryMinutes) {
                typeChangeTimeAfterRecovery = endTime
                    ? addMinutesToTimeString(extractTime(endTime), typeChangeRecoveryMinutes)
                    : addMinutesToTimeString(scheduledTime_1, averageMinutes + typeChangeRecoveryMinutes);
            }
        }
        if (!scheduledDate_1 && scheduledTime_1)
            scheduledDate_1 = extractDate(scheduledTime_1);
        var isoDateString = getIsoDateString({ scheduledDate: scheduledDate_1, scheduledTime: scheduledTime_1 });
        var venueDataMap = {};
        var venueData = ((_l = (tournamentRecord &&
            venueId &&
            getVenueData({ tournamentRecord: tournamentRecord, venueId: venueId }))) === null || _l === void 0 ? void 0 : _l.venueData) || {};
        if (venueId)
            venueDataMap[venueId] = venueData;
        var venueName = venueData.venueName, venueAbbreviation = venueData.venueAbbreviation, courtsInfo = venueData.courtsInfo;
        var courtInfo = courtId_1 && (courtsInfo === null || courtsInfo === void 0 ? void 0 : courtsInfo.find(function (courtInfo) { return courtInfo.courtId === courtId_1; }));
        var courtName = courtInfo === null || courtInfo === void 0 ? void 0 : courtInfo.courtName;
        var _loop_1 = function (allocatedCourt) {
            if (!tournamentRecord)
                return "break";
            if (allocatedCourt.venueId && !venueDataMap[allocatedCourt.venueid]) {
                venueDataMap[allocatedCourt.venueId] = (_m = getVenueData({
                    venueId: allocatedCourt.venueId,
                    tournamentRecord: tournamentRecord,
                })) === null || _m === void 0 ? void 0 : _m.venueData;
            }
            var vData = venueDataMap[allocatedCourt.venueId];
            allocatedCourt.venueName = vData === null || vData === void 0 ? void 0 : vData.venueName;
            var courtInfo_1 = (_o = vData === null || vData === void 0 ? void 0 : vData.courtsInfo) === null || _o === void 0 ? void 0 : _o.find(function (courtInfo) { return courtInfo.courtId === allocatedCourt.courtId; });
            allocatedCourt.courtName = courtInfo_1 === null || courtInfo_1 === void 0 ? void 0 : courtInfo_1.courtName;
        };
        try {
            for (var _w = __values(allocatedCourts || []), _x = _w.next(); !_x.done; _x = _w.next()) {
                var allocatedCourt = _x.value;
                var state_1 = _loop_1(allocatedCourt);
                if (state_1 === "break")
                    break;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_x && !_x.done && (_f = _w.return)) _f.call(_w);
            }
            finally { if (e_1) throw e_1.error; }
        }
        schedule = definedAttributes({
            typeChangeTimeAfterRecovery: typeChangeTimeAfterRecovery,
            timeAfterRecovery: timeAfterRecovery,
            scheduledDate: scheduledDate_1,
            scheduledTime: scheduledTime_1,
            isoDateString: isoDateString,
            allocatedCourts: allocatedCourts,
            timeModifiers: timeModifiers,
            venueAbbreviation: venueAbbreviation,
            venueName: venueName,
            venueId: venueId,
            courtOrder: courtOrder,
            courtName: courtName,
            courtId: courtId_1,
            typeChangeRecoveryMinutes: typeChangeRecoveryMinutes,
            recoveryMinutes: recoveryMinutes,
            averageMinutes: averageMinutes,
            milliseconds: milliseconds,
            startTime: startTime,
            endTime: endTime,
            time: time,
        });
    }
    else {
        schedule = definedAttributes({
            milliseconds: milliseconds,
            startTime: startTime,
            endTime: endTime,
            time: time,
        });
    }
    var scheduledDate = scheduledMatchUpDate({ matchUp: matchUp }).scheduledDate;
    var scheduledTime = scheduledMatchUpTime({ matchUp: matchUp }).scheduledTime;
    if (usePublishState && ((_p = publishStatus === null || publishStatus === void 0 ? void 0 : publishStatus.displaySettings) === null || _p === void 0 ? void 0 : _p.draws)) {
        var drawSettings = publishStatus.displaySettings.draws;
        var scheduleDetails = (_r = ((_q = drawSettings === null || drawSettings === void 0 ? void 0 : drawSettings[matchUp.drawId]) !== null && _q !== void 0 ? _q : drawSettings === null || drawSettings === void 0 ? void 0 : drawSettings.default)) === null || _r === void 0 ? void 0 : _r.scheduleDetails;
        if (scheduleDetails) {
            var scheduleAttributes = (_t = ((_s = scheduleDetails.find(function (details) { var _a; return scheduledDate && ((_a = details.dates) === null || _a === void 0 ? void 0 : _a.includes(scheduledDate)); })) !== null && _s !== void 0 ? _s : scheduleDetails.find(function (details) { var _a; return !((_a = details.dates) === null || _a === void 0 ? void 0 : _a.length); }))) === null || _t === void 0 ? void 0 : _t.attributes;
            if (scheduleAttributes) {
                // set all attributes to true
                var template = Object.assign.apply(Object, __spreadArray(__spreadArray([{}], __read(Object.keys(schedule).map(function (key) {
                    var _a;
                    return (_a = {}, _a[key] = true, _a);
                })), false), [
                    // overwrite with publishStatus attributes
                    scheduleAttributes], false));
                schedule = attributeFilter({
                    source: schedule,
                    template: template,
                });
            }
        }
    }
    var hasCompletedStatus = matchUp.matchUpStatus &&
        completedMatchUpStatuses.includes(matchUp.matchUpStatus);
    var endDate = (hasCompletedStatus &&
        (extractDate(endTime) ||
            extractDate(scheduledDate) ||
            extractDate(scheduledTime))) ||
        undefined;
    return { schedule: schedule, endDate: endDate };
}

function getCollectionPositionMatchUps(_a) {
    var matchUps = _a.matchUps;
    var collectionPositionMatchUpsArray = matchUps
        .reduce(function (collectionPositions, matchUp) {
        return !matchUp.collectionPosition ||
            collectionPositions.includes(matchUp.collectionPosition)
            ? collectionPositions
            : collectionPositions.concat(matchUp.collectionPosition);
    }, [])
        .map(function (collectionPosition) {
        var _a;
        return _a = {},
            _a[collectionPosition] = matchUps.filter(function (matchUp) { return matchUp.collectionPosition === collectionPosition; }),
            _a;
    });
    var collectionPositionMatchUps = Object.assign.apply(Object, __spreadArray([{}], __read(collectionPositionMatchUpsArray), false));
    return { collectionPositionMatchUps: collectionPositionMatchUps };
}

function getObjectTieFormat(obj) {
    if (!obj)
        return;
    var tieFormatId = obj.tieFormatId, tieFormats = obj.tieFormats;
    if (obj.tieFormat) {
        return obj.tieFormat;
    }
    else if (tieFormatId && Array.isArray(tieFormats)) {
        return tieFormats.find(function (tf) { return tf.tieFormatId === tieFormatId; });
    }
}

function getItemTieFormat(_a) {
    var _b, _c, _d;
    var item = _a.item, drawDefinition = _a.drawDefinition, structure = _a.structure, event = _a.event;
    if (!item)
        return;
    if (item.tieFormat)
        return item.tieFormat;
    // if there is a tieFormatId, only possible to look for referenced tieFormat in tieFormats on drawDefinition and event
    if (item.tieFormatId) {
        if (drawDefinition.tieFormat)
            return drawDefinition.tieFormat;
        var tieFormat = (_b = drawDefinition.tieFormats) === null || _b === void 0 ? void 0 : _b.find(function (tf) { return item.tieFormatId === tf.tieFormatId; });
        if (tieFormat)
            return tieFormat;
        if (event.tieFormat)
            return event.tieFormat;
        return (_c = event.tieFormats) === null || _c === void 0 ? void 0 : _c.find(function (tf) { return item.tieFormatId === tf.tieFormatId; });
    }
    if (structure.tieFormat)
        return structure.tieFormat;
    if (structure.tieFormatId) {
        var structureTieFormat = (_d = drawDefinition.tieFormats) === null || _d === void 0 ? void 0 : _d.find(function (tf) { return structure.tieFormatId === tf.tieFormatId; });
        if (structureTieFormat)
            return structureTieFormat;
    }
}

function resolveTieFormat(_a) {
    var drawDefinition = _a.drawDefinition, structure = _a.structure, matchUp = _a.matchUp, event = _a.event;
    return {
        tieFormat: getItemTieFormat({
            item: matchUp,
            drawDefinition: drawDefinition,
            structure: structure,
            event: event,
        }) ||
            getItemTieFormat({
                item: structure,
                drawDefinition: drawDefinition,
                structure: structure,
                event: event,
            }) ||
            getObjectTieFormat(drawDefinition) ||
            getObjectTieFormat(event),
    };
}

function getRangeString(arr) {
    if (!Array.isArray(arr))
        return '';
    var numericArray = arr.filter(isNumeric);
    if (!numericArray.length)
        return '';
    var range = unique([Math.min.apply(Math, __spreadArray([], __read(numericArray), false)), Math.max.apply(Math, __spreadArray([], __read(numericArray), false))]);
    return range.join('-');
}

function getSourceDrawPositionRanges(_a) {
    var drawDefinition = _a.drawDefinition, structureId = _a.structureId, matchUpsMap = _a.matchUpsMap;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structureId)
        return { error: MISSING_STRUCTURE_ID };
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    if ((structure === null || structure === void 0 ? void 0 : structure.stage) !== CONSOLATION)
        return { error: INVALID_STAGE, info: 'Structure is not CONSOLATION stage' };
    var links = drawDefinition.links;
    var relevantLinks = (links === null || links === void 0 ? void 0 : links.filter(function (link) { return link.target.structureId === structureId; })) || [];
    var sourceStructureIds = (relevantLinks === null || relevantLinks === void 0 ? void 0 : relevantLinks.reduce(function (sourceStructureIds, link) {
        var sourceStructureId = link.source.structureId;
        return sourceStructureIds.includes(sourceStructureId)
            ? sourceStructureIds
            : sourceStructureIds.concat(sourceStructureId);
    }, [])) || [];
    var sourceStructureProfiles = Object.assign.apply(Object, __spreadArray([{}], __read(sourceStructureIds.map(function (sourceStructureId) {
        var _a;
        var structureMatchUps = getMappedStructureMatchUps({
            structureId: sourceStructureId,
            matchUpsMap: matchUpsMap,
        });
        var roundMatchUpsResult = getRoundMatchUps({
            matchUps: structureMatchUps,
        });
        var roundProfile = roundMatchUpsResult.roundProfile;
        return _a = {}, _a[sourceStructureId] = roundProfile, _a;
    })), false));
    var structureMatchUps = getMappedStructureMatchUps({
        matchUpsMap: matchUpsMap,
        structureId: structureId,
    });
    var targetStructureProfile = getRoundMatchUps({
        matchUps: structureMatchUps,
    }).roundProfile;
    var sourceDrawPositionRanges = {};
    relevantLinks === null || relevantLinks === void 0 ? void 0 : relevantLinks.forEach(function (link) {
        var _a;
        var _b = link.source, sourceStructureId = _b.structureId, sourceRoundNumber = _b.roundNumber;
        var _c = link.target, feedProfile = _c.feedProfile, groupedOrder = _c.groupedOrder, positionInterleave = _c.positionInterleave, targetRoundNumber = _c.roundNumber;
        var sourceStructureProfile = sourceStructureProfiles[sourceStructureId];
        var firstRoundDrawPositions = (_a = sourceStructureProfile[1]) === null || _a === void 0 ? void 0 : _a.drawPositions;
        var sourceRoundProfile = sourceStructureProfile[sourceRoundNumber];
        var sourceRoundMatchUpsCount = sourceRoundProfile === null || sourceRoundProfile === void 0 ? void 0 : sourceRoundProfile.matchUpsCount;
        if (!sourceRoundMatchUpsCount)
            return;
        var chunkSize = sourceRoundMatchUpsCount
            ? firstRoundDrawPositions.length / sourceRoundMatchUpsCount
            : 0;
        var targetRoundMatchUpsCount = firstRoundDrawPositions.length / chunkSize;
        var orderedPositions = firstRoundDrawPositions.slice();
        var sizedGroupOrder = reduceGroupedOrder({
            roundPositionsCount: orderedPositions.length,
            groupedOrder: groupedOrder,
        });
        var groupsCount = (sizedGroupOrder === null || sizedGroupOrder === void 0 ? void 0 : sizedGroupOrder.length) || 1;
        if (groupsCount <= targetRoundMatchUpsCount) {
            var groupSize = firstRoundDrawPositions.length / groupsCount;
            var groups_1 = chunkArray(orderedPositions, groupSize);
            if (feedProfile === BOTTOM_UP)
                groups_1.forEach(function (group) { return group.reverse(); });
            orderedPositions =
                ((sizedGroupOrder === null || sizedGroupOrder === void 0 ? void 0 : sizedGroupOrder.length) &&
                    (sizedGroupOrder === null || sizedGroupOrder === void 0 ? void 0 : sizedGroupOrder.map(function (order) { return groups_1[order - 1]; }).flat())) ||
                    orderedPositions;
        }
        var drawPositionBlocks = chunkArray(orderedPositions, chunkSize);
        if (!(sizedGroupOrder === null || sizedGroupOrder === void 0 ? void 0 : sizedGroupOrder.length) && feedProfile === BOTTOM_UP)
            drawPositionBlocks.reverse();
        // positionInterleave describes how positions are fed from source to target
        // In double elimination, for instance:
        //  - roundNumber: 1 has positions fed top down from source roundNumber: 1
        //  - roundNumber: 1 has positions fed bottom up from source roundNumber: 2
        // These TOP_DOWN and BOTTOM_UP feeds are interleaved, e.g. T1, B3, T2, B2, T3, B1
        // The BOTTOM_UP feed in this example is offset (shifted down) by 1 and reversed
        if (positionInterleave) {
            // an array of undefined items
            var interleave_1 = generateRange(0, positionInterleave.interleave).map(function () { return undefined; });
            // an array of undefined items. NOTE: new Array(#) does not work in this instance
            var offset = generateRange(0, positionInterleave.offset).map(function () { return undefined; });
            drawPositionBlocks = drawPositionBlocks.map(function (block) { return __spreadArray([
                block
            ], __read(interleave_1), false); });
            drawPositionBlocks.unshift(offset);
            drawPositionBlocks = drawPositionBlocks.flat(1);
            var targetLength = drawPositionBlocks.length - positionInterleave.offset;
            drawPositionBlocks = drawPositionBlocks.slice(0, targetLength);
        }
        // build an object with keys [targetRoundnumber][roundPosition]
        if (!sourceDrawPositionRanges[targetRoundNumber])
            sourceDrawPositionRanges[targetRoundNumber] = {};
        // drawPositions for consolation structures are offset by the number of fed positions in subsequent rounds
        // columnPosition gives an ordered position value relative to a single column
        // when the number of drawPositions is greater than the number of drawPositionBlocks for a given roundNumber
        // then sourceDrawPositionRanges are being added to a feedRound
        // targetStructureProfile also has the boolean attribute .feedRound to flag this case
        var targetRoundProfile = targetStructureProfile === null || targetStructureProfile === void 0 ? void 0 : targetStructureProfile[targetRoundNumber];
        var increment = (targetRoundProfile === null || targetRoundProfile === void 0 ? void 0 : targetRoundProfile.feedRound) ? 2 : 1;
        drawPositionBlocks.forEach(function (block, index) {
            // fed drawPositions are always sideNumber: 1, so when the increment is 2 the columnPosition is always an odd number
            // because sideNumber: 1 maps to index: 0 in matchUp.drawPositions
            var columnPosition = 1 + index * increment;
            if (!sourceDrawPositionRanges[targetRoundNumber][columnPosition]) {
                sourceDrawPositionRanges[targetRoundNumber][columnPosition] =
                    getRangeString(block);
            }
        });
    });
    return { sourceDrawPositionRanges: sourceDrawPositionRanges };
}
/*
 * function getRangeString(arr) {
 *   if (!Array.isArray(arr)) return '';
 *   const numericArray = arr.filter(isNumeric);
 *   if (!numericArray.length) return '';
 *   const range = unique([Math.min(...numericArray), Math.max(...numericArray)]);
 *   return range.join('-');
 * }
 */

var NORMAL = 'normal';
var TIMED = 'timed';
var FINAL = 'final';
var NOAD = 'NOAD';
var SET = 'SET';
var setTypes$1 = {
    S: NORMAL,
    F: FINAL,
};

function parse(matchUpFormatCode) {
    if (typeof matchUpFormatCode === 'string') {
        var type = (matchUpFormatCode.startsWith('T') && TIMED) ||
            (matchUpFormatCode.startsWith(SET) && SET) ||
            '';
        if (type === TIMED) {
            var setFormat = parseTimedSet(matchUpFormatCode);
            var parsedFormat = {
                simplified: true,
                setFormat: setFormat,
                bestOf: 1,
            };
            if (setFormat)
                return parsedFormat;
        }
        if (type === SET)
            return setsMatch(matchUpFormatCode);
    }
    return undefined;
}
function setsMatch(formatstring) {
    var parts = formatstring.split('-');
    var setsCount = getNumber$1(parts[0].slice(3));
    var bestOf = setsCount === 1 || setsCount % 2 !== 0 ? setsCount : undefined;
    var exactly = setsCount !== 1 && setsCount % 2 === 0 ? setsCount : undefined;
    var setFormat = parts && parseSetFormat(parts[1]);
    var finalSetFormat = parts && parseSetFormat(parts[2]);
    var timed = (setFormat && setFormat.timed) || (finalSetFormat && finalSetFormat.timed);
    var validSetsCount = (bestOf && bestOf < 6) || (timed && exactly);
    var validFinalSet = !parts[2] || finalSetFormat;
    var validSetsFormat = setFormat;
    var result = definedAttributes({
        setFormat: setFormat,
        exactly: exactly,
        bestOf: bestOf,
    });
    if (finalSetFormat)
        result.finalSetFormat = finalSetFormat;
    if (validSetsCount && validSetsFormat && validFinalSet)
        return result;
}
function parseSetFormat(formatstring) {
    if ((formatstring === null || formatstring === void 0 ? void 0 : formatstring[1]) === ':') {
        var parts = formatstring.split(':');
        var setType = setTypes$1[parts[0]];
        var setFormatString = parts[1];
        if (setType && setFormatString) {
            var isTiebreakSet = setFormatString.startsWith('TB');
            if (isTiebreakSet) {
                var tiebreakSet = parseTiebreakFormat(setFormatString);
                if (tiebreakSet === false)
                    return false;
                return typeof tiebreakSet === 'object' ? { tiebreakSet: tiebreakSet } : undefined;
            }
            var timedSet = setFormatString.startsWith('T');
            if (timedSet)
                return parseTimedSet(setFormatString);
            var parts_1 = formatstring.match(/^[FS]:(\d+)([A-Za-z]*)/);
            var NoAD = (parts_1 && isNoAD(parts_1[2])) || false;
            var validNoAD = !(parts_1 === null || parts_1 === void 0 ? void 0 : parts_1[2]) || NoAD;
            var setTo = parts_1 ? getNumber$1(parts_1[1]) : undefined;
            var tiebreakAtValue = parseTiebreakAt(setFormatString);
            var validTiebreakAt = tiebreakAtValue !== false;
            var tiebreakAt = (validTiebreakAt && tiebreakAtValue) || setTo;
            var tiebreakFormat = parseTiebreakFormat(setFormatString.split('/')[1]);
            var validTiebreak = tiebreakFormat !== false;
            var result = { setTo: setTo };
            if (NoAD)
                result.NoAD = true;
            if (tiebreakFormat) {
                result.tiebreakFormat = tiebreakFormat;
                result.tiebreakAt = tiebreakAt;
            }
            else {
                result.noTiebreak = true;
            }
            return ((setTo && validNoAD && validTiebreak && validTiebreakAt && result) ||
                false);
        }
    }
    return undefined;
}
function parseTiebreakAt(setFormatString, expectNumber) {
    if (expectNumber === void 0) { expectNumber = true; }
    var tiebreakAtValue = (setFormatString === null || setFormatString === void 0 ? void 0 : setFormatString.indexOf('@')) > 0 && setFormatString.split('@');
    if (tiebreakAtValue) {
        var tiebreakAt = expectNumber
            ? getNumber$1(tiebreakAtValue[1])
            : tiebreakAtValue[1];
        return tiebreakAt || false;
    }
    return undefined;
}
function parseTiebreakFormat(formatstring) {
    if (formatstring) {
        if (formatstring.startsWith('TB')) {
            var modifier = parseTiebreakAt(formatstring, false);
            var parts = formatstring.match(/^TB(\d+)([A-Za-z]*)/);
            var tiebreakToString = parts === null || parts === void 0 ? void 0 : parts[1];
            var NoAD = parts && isNoAD(parts[2]);
            var validNoAD = !(parts === null || parts === void 0 ? void 0 : parts[2]) || NoAD;
            var tiebreakTo = getNumber$1(tiebreakToString);
            if (tiebreakTo && validNoAD) {
                var result = { tiebreakTo: tiebreakTo };
                // modifiers cannot be numeric
                if (modifier &&
                    typeof modifier === 'string' &&
                    !isConvertableInteger(modifier)) {
                    result.modifier = modifier;
                }
                if (NoAD)
                    result.NoAD = true;
                return result;
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
    return undefined;
}
function parseTimedSet(formatstring) {
    var _a;
    var timestring = formatstring.slice(1);
    var parts = timestring.match(/^(\d+)(@?[A-Za-z]*)/);
    var minutes = getNumber$1(parts === null || parts === void 0 ? void 0 : parts[1]);
    if (!minutes)
        return;
    var setFormat = { timed: true, minutes: minutes };
    var based = parts === null || parts === void 0 ? void 0 : parts[2];
    var validModifier = [undefined, 'P', 'G'].includes(based);
    if (based && !validModifier) {
        var modifier = (_a = timestring.match(/^(\d+)(@)([A-Za-z]+)$/)) === null || _a === void 0 ? void 0 : _a[3];
        if (modifier) {
            setFormat.modifier = modifier;
            return setFormat;
        }
        return;
    }
    if (based)
        setFormat.based = parts[2];
    return setFormat;
}
function isNoAD(formatstring) {
    return formatstring && formatstring.indexOf(NOAD) >= 0;
}
function getNumber$1(formatstring) {
    return !isNaN(Number(formatstring)) ? Number(formatstring) : 0;
}

function getOrderedDrawPositions(_a) {
    var _b;
    var drawPositions = _a.drawPositions, roundProfile = _a.roundProfile, roundNumber = _a.roundNumber;
    var unassignedDrawPositions = [undefined, undefined];
    if (noNumeric(drawPositions)) {
        return {
            orderedDrawPositions: unassignedDrawPositions,
            displayOrder: unassignedDrawPositions,
        };
    }
    var targetRoundProfile = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber];
    var pairedDrawPositions = targetRoundProfile === null || targetRoundProfile === void 0 ? void 0 : targetRoundProfile.pairedDrawPositions;
    var displayOrder = (_b = pairedDrawPositions === null || pairedDrawPositions === void 0 ? void 0 : pairedDrawPositions.find(function (pair) { return overlap(pair || [], drawPositions.filter(Boolean)); })) !== null && _b !== void 0 ? _b : unassignedDrawPositions;
    // ############# IMPORTANT DO NOT CHANGE #################
    // when both present, drawPositions are always sorted numerically
    // this holds true even when fed positions encounter each other in later rounds
    // { sideNumber: 1 } always goes to the lower drawPosition
    // displayOrder for feedRounds follows this rule...
    // ...but displayOrder for non-fed rounds must look back to the previous round
    // previous round lookback is provided by the roundProfile
    var isFeedRound = targetRoundProfile === null || targetRoundProfile === void 0 ? void 0 : targetRoundProfile.feedRound;
    if (allNumeric$1(drawPositions)) {
        var orderedDrawPositions = __spreadArray([], __read(drawPositions), false).sort(numericSort); // spread to avoid immutable client data
        return {
            orderedDrawPositions: orderedDrawPositions.length === 2 ? orderedDrawPositions : displayOrder,
            displayOrder: isFeedRound ? orderedDrawPositions : displayOrder,
        };
    }
    // ############# IMPORTANT DO NOT CHANGE #################
    // when only one side is present in a feedRound, it is the fed position
    // and fed positions are always { sideNumber: 1 }
    if (isFeedRound) {
        var drawPosition = drawPositions.find(function (drawPosition) { return !isNaN(ensureInt(drawPosition)); });
        var orderedDrawPositions = [drawPosition, undefined];
        return { orderedDrawPositions: orderedDrawPositions, displayOrder: orderedDrawPositions };
    }
    return { orderedDrawPositions: displayOrder, displayOrder: displayOrder };
}

function getDrawPositionsRanges(_a) {
    var _b, _c;
    var drawDefinition = _a.drawDefinition, roundProfile = _a.roundProfile, structureId = _a.structureId, matchUpsMap = _a.matchUpsMap;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structureId)
        return { error: MISSING_STRUCTURE_ID };
    if (!roundProfile) {
        var structureMatchUps = getMappedStructureMatchUps({
            matchUpsMap: matchUpsMap,
            structureId: structureId,
        });
        (roundProfile = getRoundMatchUps({
            matchUps: structureMatchUps,
        }).roundProfile);
        if (!roundProfile)
            return { error: MISSING_VALUE };
    }
    var firstRoundFirstDrawPosition = Math.min.apply(Math, __spreadArray([], __read(((_c = (_b = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[1]) === null || _b === void 0 ? void 0 : _b.drawPositions) !== null && _c !== void 0 ? _c : [])), false));
    var firstRoundFirstDrawPositionOffset = (firstRoundFirstDrawPosition || 1) - 1;
    var roundNumbers = Object.keys(roundProfile);
    var drawPositionsRanges = Object.assign.apply(Object, __spreadArray([{}], __read((roundNumbers || []).map(function (roundNumber) {
        var _a;
        var _b, _c, _d;
        var matchUpsCount = (_b = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber]) === null || _b === void 0 ? void 0 : _b.matchUpsCount;
        var firstRoundDrawPositions = (_d = (_c = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[1]) === null || _c === void 0 ? void 0 : _c.drawPositions) !== null && _d !== void 0 ? _d : [];
        var firstRoundDrawPositionsChunks = chunkArray(firstRoundDrawPositions, firstRoundDrawPositions.length / matchUpsCount);
        var firstRoundDrawPositionsRanges = firstRoundDrawPositionsChunks.map(getRangeString);
        var firstRoundOffsetDrawPositionsRanges = firstRoundDrawPositionsChunks
            .map(function (drawPositions) {
            return drawPositions.map(function (drawPosition) { return drawPosition - firstRoundFirstDrawPositionOffset; });
        })
            .map(getRangeString);
        var currentRoundDrawPositionChunks = roundNumbers
            .map(function (value) {
            var _a, _b;
            if (value > roundNumber)
                return undefined;
            var drawPositions = (_b = (_a = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[value]) === null || _a === void 0 ? void 0 : _a.drawPositions) !== null && _b !== void 0 ? _b : [];
            return chunkArray(drawPositions, drawPositions.length / matchUpsCount);
        })
            .filter(Boolean);
        var possibleDrawPositions = generateRange(0, matchUpsCount)
            .map(function (index) {
            return currentRoundDrawPositionChunks
                .map(function (chunk) { return chunk[index]; })
                .flat()
                .filter(Boolean)
                .sort(numericSort);
        })
            .map(function (possible) { return unique(possible); });
        var drawPositionsRanges = possibleDrawPositions.map(function (possible) {
            return groupConsecutiveNumbers(possible).map(getRangeString).join(', ');
        });
        var roundPositionsMap = Object.assign.apply(Object, __spreadArray([{}], __read(generateRange(0, matchUpsCount).map(function (index) {
            var _a;
            var roundPosition = index + 1;
            return _a = {},
                _a[roundPosition] = {
                    firstRoundDrawPositionsRange: firstRoundDrawPositionsRanges[index],
                    firstRoundOffsetDrawPositionsRange: firstRoundOffsetDrawPositionsRanges[index],
                    possibleDrawPositions: possibleDrawPositions[index],
                    drawPositionsRange: drawPositionsRanges[index],
                },
                _a;
        })), false));
        return _a = {}, _a[roundNumber] = roundPositionsMap, _a;
    })), false));
    return { drawPositionsRanges: drawPositionsRanges };
}

function isLucky(_a) {
    var _b, _c;
    var roundsNotPowerOf2 = _a.roundsNotPowerOf2, drawDefinition = _a.drawDefinition, structure = _a.structure, matchUps = _a.matchUps;
    if (!structure)
        return false;
    matchUps = (_b = matchUps !== null && matchUps !== void 0 ? matchUps : structure.matchUps) !== null && _b !== void 0 ? _b : [];
    roundsNotPowerOf2 =
        roundsNotPowerOf2 !== null && roundsNotPowerOf2 !== void 0 ? roundsNotPowerOf2 : getRoundMatchUps({ matchUps: matchUps }).roundsNotPowerOf2;
    var hasDrawPositions = !!((_c = structure.positionAssignments) === null || _c === void 0 ? void 0 : _c.find(function (_a) {
        var drawPosition = _a.drawPosition;
        return drawPosition;
    })) ||
        !!(matchUps === null || matchUps === void 0 ? void 0 : matchUps.find(function (_a) {
            var drawPositions = _a.drawPositions;
            return drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.length;
        }));
    return ((!(drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.drawType) || drawDefinition.drawType !== LUCKY_DRAW) &&
        !(structure === null || structure === void 0 ? void 0 : structure.structures) &&
        roundsNotPowerOf2 &&
        hasDrawPositions);
}

function isAdHoc(_a) {
    var drawDefinition = _a.drawDefinition, structure = _a.structure;
    if (!structure)
        return false;
    var matchUps = structure.matchUps ||
        (structure.roundMatchUps && Object.values(structure.roundMatchUps).flat());
    var hasRoundPosition = matchUps === null || matchUps === void 0 ? void 0 : matchUps.find(function (matchUp) { return matchUp === null || matchUp === void 0 ? void 0 : matchUp.roundPosition; });
    var hasDrawPosition = matchUps === null || matchUps === void 0 ? void 0 : matchUps.find(function (matchUp) { var _a; return (_a = matchUp === null || matchUp === void 0 ? void 0 : matchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.length; });
    return (!(structure === null || structure === void 0 ? void 0 : structure.structures) &&
        (structure === null || structure === void 0 ? void 0 : structure.stage) !== VOLUNTARY_CONSOLATION &&
        !((drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.drawType) && drawDefinition.drawType !== AD_HOC) &&
        !hasRoundPosition &&
        !hasDrawPosition);
}

var _a$g, _b$4;
var POLICY_ROUND_NAMING_DEFAULT = (_a$g = {},
    _a$g[POLICY_TYPE_ROUND_NAMING] = {
        policyName: 'Round Naming Default',
        namingConventions: {
            round: 'Round',
            pre: 'Pre',
        },
        qualifyingFinishMap: {
            1: 'Final',
        },
        abbreviatedRoundNamingMap: {
            // key is matchUpsCount for the round
            1: 'F',
            2: 'SF',
            4: 'QF',
        },
        roundNamingMap: {
            1: 'Final',
            2: 'Semifinal',
            4: 'Quarterfinal',
        },
        affixes: {
            roundNumber: 'R',
            preFeedRound: 'Q',
            preQualifying: 'P',
        },
        stageConstants: (_b$4 = {},
            _b$4[MAIN] = '',
            _b$4[PLAY_OFF] = 'P',
            _b$4[QUALIFYING] = 'Q',
            _b$4[CONSOLATION] = 'C',
            _b$4),
    },
    _a$g);

function getRoundContextProfile(_a) {
    var _b, _c, _d, _e, _f, _g;
    var roundNamingPolicy = _a.roundNamingPolicy, drawDefinition = _a.drawDefinition, structure = _a.structure, matchUps = _a.matchUps;
    var _h = getRoundMatchUps({ matchUps: matchUps }), roundProfile = _h.roundProfile, roundMatchUps = _h.roundMatchUps;
    var structureAbbreviation = structure.structureAbbreviation, stage = structure.stage;
    var isAdHocStructure = isAdHoc({ structure: structure });
    var isLuckyStructure = isLucky({ structure: structure });
    var isRoundRobin = structure.structures;
    var roundNamingProfile = {};
    var defaultRoundNamingPolicy = POLICY_ROUND_NAMING_DEFAULT[POLICY_TYPE_ROUND_NAMING];
    var isQualifying = structure.stage === QUALIFYING;
    var qualifyingStageSequences = isQualifying
        ? Math.max.apply(Math, __spreadArray(__spreadArray([], __read(((_b = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) !== null && _b !== void 0 ? _b : [])
            .filter(function (structure) { return structure.stage === QUALIFYING; })
            .map(function (_a) {
            var stageSequence = _a.stageSequence;
            return stageSequence !== null && stageSequence !== void 0 ? stageSequence : 1;
        })), false), [0], false)) : 0;
    var preQualifyingSequence = ((_c = structure.stageSequence) !== null && _c !== void 0 ? _c : 1) < qualifyingStageSequences
        ? (_d = structure.stageSequence) !== null && _d !== void 0 ? _d : 1
        : '';
    var preQualifyingAffix = preQualifyingSequence
        ? ((_e = roundNamingPolicy === null || roundNamingPolicy === void 0 ? void 0 : roundNamingPolicy.affixes) === null || _e === void 0 ? void 0 : _e.preQualifying) ||
            defaultRoundNamingPolicy.affixes.preQualifying ||
            ''
        : '';
    var roundNamingMap = (roundNamingPolicy === null || roundNamingPolicy === void 0 ? void 0 : roundNamingPolicy.roundNamingMap) ||
        defaultRoundNamingPolicy.roundNamingMap ||
        {};
    var abbreviatedRoundNamingMap = (roundNamingPolicy === null || roundNamingPolicy === void 0 ? void 0 : roundNamingPolicy.abbreviatedRoundNamingMap) ||
        defaultRoundNamingPolicy.abbreviatedRoundNamingMap ||
        {};
    var preFeedAffix = ((_f = roundNamingPolicy === null || roundNamingPolicy === void 0 ? void 0 : roundNamingPolicy.affixes) === null || _f === void 0 ? void 0 : _f.preFeedRound) ||
        defaultRoundNamingPolicy.affixes.preFeedRound;
    var roundNumberAffix = ((_g = roundNamingPolicy === null || roundNamingPolicy === void 0 ? void 0 : roundNamingPolicy.affixes) === null || _g === void 0 ? void 0 : _g.roundNumber) ||
        defaultRoundNamingPolicy.affixes.roundNumber;
    var namingConventions = (roundNamingPolicy === null || roundNamingPolicy === void 0 ? void 0 : roundNamingPolicy.namingConventions) ||
        defaultRoundNamingPolicy.namingConventions;
    var roundNameFallback = namingConventions.round;
    var stageInitial = stage && stage !== MAIN ? stage[0] : '';
    var stageConstants = (roundNamingPolicy === null || roundNamingPolicy === void 0 ? void 0 : roundNamingPolicy.stageConstants) ||
        defaultRoundNamingPolicy.stageConstants;
    var stageIndicator = (stage && (stageConstants === null || stageConstants === void 0 ? void 0 : stageConstants[stage])) || stageInitial;
    var stageConstant = "".concat(preQualifyingAffix).concat(stageIndicator).concat(preQualifyingSequence);
    var roundProfileKeys = roundProfile ? Object.keys(roundProfile) : [];
    var qualifyingAffix = isQualifying && (stageConstants === null || stageConstants === void 0 ? void 0 : stageConstants[QUALIFYING])
        ? "".concat(stageConstants === null || stageConstants === void 0 ? void 0 : stageConstants[QUALIFYING], "-")
        : '';
    if (isRoundRobin || isAdHocStructure || isLuckyStructure) {
        Object.assign.apply(Object, __spreadArray([roundNamingProfile], __read(roundProfileKeys.map(function (key) {
            var _a;
            var roundName = "".concat(qualifyingAffix).concat(roundNameFallback, " ").concat(key);
            var abbreviatedRoundName = "".concat(roundNumberAffix).concat(key);
            return _a = {}, _a[key] = { roundName: roundName, abbreviatedRoundName: abbreviatedRoundName }, _a;
        })), false));
    }
    else {
        var qualifyingFinishgMap_1 = isQualifying &&
            ((roundNamingPolicy === null || roundNamingPolicy === void 0 ? void 0 : roundNamingPolicy.qualifyingFinishMap) ||
                (defaultRoundNamingPolicy === null || defaultRoundNamingPolicy === void 0 ? void 0 : defaultRoundNamingPolicy.qualifyingFinishMap) ||
                {});
        Object.assign.apply(Object, __spreadArray([roundNamingProfile], __read(roundProfileKeys.map(function (round) {
            var _a;
            if (!(roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[round]))
                return;
            var _b = roundProfile[round], matchUpsCount = _b.matchUpsCount, preFeedRound = _b.preFeedRound;
            var participantsCount = matchUpsCount * 2;
            var sizedRoundName = (qualifyingFinishgMap_1 === null || qualifyingFinishgMap_1 === void 0 ? void 0 : qualifyingFinishgMap_1[roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[round].finishingRound]) ||
                (qualifyingFinishgMap_1 && "".concat(roundNumberAffix).concat(participantsCount)) ||
                roundNamingMap[matchUpsCount] ||
                "".concat(roundNumberAffix).concat(participantsCount);
            var suffix = preFeedRound ? "-".concat(preFeedAffix) : '';
            var profileRoundName = "".concat(sizedRoundName).concat(suffix);
            var roundName = [
                stageConstant,
                structureAbbreviation,
                profileRoundName,
            ]
                .filter(Boolean)
                .join('-');
            var sizedAbbreviation = abbreviatedRoundNamingMap[matchUpsCount] ||
                "".concat(roundNumberAffix).concat(participantsCount);
            var profileAbbreviation = "".concat(sizedAbbreviation).concat(suffix);
            var abbreviatedRoundName = [
                stageConstant,
                structureAbbreviation,
                profileAbbreviation,
            ]
                .filter(Boolean)
                .join('-');
            return _a = {}, _a[round] = { abbreviatedRoundName: abbreviatedRoundName, roundName: roundName }, _a;
        })), false));
    }
    return { roundNamingProfile: roundNamingProfile, roundProfile: roundProfile, roundMatchUps: roundMatchUps };
}

// derive matchUpType from participants when not defined on matchUp
function getMatchUpType(params) {
    var _a;
    var _b;
    var paramCheck = checkRequiredParameters(params, [(_a = {}, _a[MATCHUP] = true, _a)]);
    if (paramCheck.error)
        return paramCheck;
    var matchUp = params === null || params === void 0 ? void 0 : params.matchUp;
    var matchUpType = matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpType;
    if (!matchUpType && ((_b = matchUp === null || matchUp === void 0 ? void 0 : matchUp.sides) === null || _b === void 0 ? void 0 : _b.length)) {
        var side = matchUp.sides.find(function (_a) {
            var participant = _a.participant;
            return participant;
        });
        var participant = side === null || side === void 0 ? void 0 : side.participant;
        var participantType = participant === null || participant === void 0 ? void 0 : participant.participantType;
        matchUpType =
            (participantType === INDIVIDUAL && SINGLES) ||
                (participantType === PAIR && DOUBLES) ||
                (participantType === TEAM$1 && TEAM$1) ||
                undefined;
    }
    return { matchUpType: matchUpType };
}

function filterMatchUps(params) {
    var matchUps = params.matchUps, isCollectionMatchUp = params.isCollectionMatchUp, excludeMatchUpStatuses = params.excludeMatchUpStatuses, matchUpStatuses = params.matchUpStatuses, hasWinningSide = params.hasWinningSide, matchUpFormats = params.matchUpFormats, roundPositions = params.roundPositions, matchUpFormat = params.matchUpFormat, collectionIds = params.collectionIds, isMatchUpTie = params.isMatchUpTie, roundNumbers = params.roundNumbers, matchUpIds = params.matchUpIds, roundNames = params.roundNames, 
    // only applies to inContext matchUps and only when processContext boolean is true
    stageSequences = params.stageSequences, scheduledDates = params.scheduledDates, scheduledDate = params.scheduledDate, participantIds = params.participantIds, processContext = params.processContext, tournamentIds = params.tournamentIds, matchUpTypes = params.matchUpTypes, structureIds = params.structureIds, readyToScore = params.readyToScore, courtIds = params.courtIds, eventIds = params.eventIds, venueIds = params.venueIds, drawIds = params.drawIds, stages = params.stages, _a = params.filterMatchUpIds, filterMatchUpIds = _a === void 0 ? true : _a, _b = params.filterMatchUpTypes, filterMatchUpTypes = _b === void 0 ? true : _b;
    var targetParticipantIds = Array.isArray(participantIds) ? participantIds.filter(Boolean) : [];
    var targetMatchUpStatuses = Array.isArray(matchUpStatuses) ? matchUpStatuses.filter(Boolean) : [];
    var excludeTargetMatchUpStatuses = Array.isArray(excludeMatchUpStatuses)
        ? excludeMatchUpStatuses.filter(Boolean)
        : [];
    var targetStages = Array.isArray(stages) ? stages.filter(Boolean) : [];
    var targetStageSequences = Array.isArray(stageSequences) ? stageSequences.filter(Boolean) : [];
    var targetCollectionIds = Array.isArray(collectionIds) ? collectionIds.filter(Boolean) : [];
    var targetRoundNames = Array.isArray(roundNames) ? roundNames.filter(Boolean) : [];
    var targetRoundNumbers = Array.isArray(roundNumbers) ? roundNumbers.filter(Boolean) : [];
    var targetRoundPositions = Array.isArray(roundPositions) ? roundPositions.filter(Boolean) : [];
    var targetMatchUpIds = Array.isArray(matchUpIds) && filterMatchUpIds ? matchUpIds.filter(Boolean) : [];
    var targetMatchUpTypes = Array.isArray(matchUpTypes) && filterMatchUpTypes ? matchUpTypes.filter(Boolean) : [];
    var targetCourtIds = Array.isArray(courtIds) ? courtIds.filter(Boolean) : [];
    var targetVenueIds = Array.isArray(venueIds) ? venueIds.filter(Boolean) : [];
    var targetMatchUpFormats = (Array.isArray(matchUpFormats) && matchUpFormats.filter(Boolean)) ||
        (typeof matchUpFormat === 'string' && [matchUpFormat]) ||
        [];
    var targetScheduledDates = (Array.isArray(scheduledDates) && scheduledDates.filter(Boolean)) ||
        (typeof scheduledDate === 'string' && scheduledDate.length && [scheduledDate]) ||
        [];
    var targetTournamentIds = Array.isArray(tournamentIds) ? tournamentIds.filter(Boolean) : [];
    var targetEventIds = Array.isArray(eventIds) ? eventIds.filter(Boolean) : [];
    var targetDrawIds = Array.isArray(drawIds) ? drawIds.filter(Boolean) : [];
    var targetStructureIds = Array.isArray(structureIds) ? structureIds.filter(Boolean) : [];
    return matchUps.filter(function (matchUp) {
        var _a, _b;
        if (readyToScore && matchUp.matchUpType !== TEAM_MATCHUP && !matchUp.readyToScore)
            return false;
        if (matchUp.winningSide && hasWinningSide && ![1, 2].includes(matchUp.winningSide))
            return false;
        if (isMatchUpTie !== undefined) {
            if (isMatchUpTie && !matchUp.tieMatchUps) {
                return false;
            }
            if (!isMatchUpTie && matchUp.tieMatchUps) {
                return false;
            }
        }
        if (isCollectionMatchUp !== undefined) {
            if (isCollectionMatchUp && !matchUp.collectionId) {
                return false;
            }
            if (!isCollectionMatchUp && matchUp.collectionId) {
                return false;
            }
        }
        if (targetStages.length && !targetStages.includes(matchUp.stage)) {
            return false;
        }
        if (targetStageSequences.length && !targetStageSequences.includes(matchUp.stageSequence)) {
            return false;
        }
        if (targetCollectionIds.length && (!matchUp.collectionId || !targetCollectionIds.includes(matchUp.collectionId))) {
            return false;
        }
        if (targetRoundNames.length && (!matchUp.roundName || !targetRoundNames.includes(matchUp.roundName))) {
            return false;
        }
        if (targetRoundNumbers.length && (!matchUp.roundNumber || !targetRoundNumbers.includes(matchUp.roundNumber))) {
            return false;
        }
        if (targetRoundPositions.length &&
            (!matchUp.roundPosition || !targetRoundPositions.includes(matchUp.roundPosition))) {
            return false;
        }
        if (targetMatchUpStatuses.length &&
            (!matchUp.matchUpStatus || !targetMatchUpStatuses.includes(matchUp.matchUpStatus))) {
            return false;
        }
        if (excludeTargetMatchUpStatuses.length &&
            matchUp.matchUpStatus &&
            excludeTargetMatchUpStatuses.includes(matchUp.matchUpStatus)) {
            return false;
        }
        if (targetMatchUpIds.length && !targetMatchUpIds.includes(matchUp.matchUpId)) {
            return false;
        }
        if (targetMatchUpTypes.length && (!matchUp.matchUpType || !targetMatchUpTypes.includes(matchUp.matchUpType))) {
            return false;
        }
        if (targetMatchUpFormats.length &&
            (!matchUp.matchUpFormat || !targetMatchUpFormats.includes(matchUp.matchUpFormat))) {
            return false;
        }
        if (targetScheduledDates === null || targetScheduledDates === void 0 ? void 0 : targetScheduledDates.length) {
            var scheduledTime = scheduledMatchUpTime({ matchUp: matchUp }).scheduledTime;
            var matchUpDate = scheduledMatchUpDate({ matchUp: matchUp }).scheduledDate;
            var scheduledTimeDate = extractDate(scheduledTime);
            var comparisonDate_1 = scheduledTimeDate || matchUpDate;
            if (!targetScheduledDates.find(function (scheduledDate) { return sameDay(scheduledDate, comparisonDate_1); }))
                return false;
        }
        if (targetCourtIds.length) {
            var courtId = matchUpAssignedCourtId({ matchUp: matchUp }).courtId;
            var allocatedCourts = matchUpAllocatedCourts({ matchUp: matchUp }).allocatedCourts;
            var allocatedCourtIds = allocatedCourts === null || allocatedCourts === void 0 ? void 0 : allocatedCourts.map(function (_a) {
                var courtId = _a.courtId;
                return courtId;
            });
            if (!targetCourtIds.filter(Boolean).includes(courtId) || (allocatedCourtIds === null || allocatedCourtIds === void 0 ? void 0 : allocatedCourtIds.includes(courtId))) {
                return false;
            }
        }
        if (targetVenueIds.length) {
            var venueId = matchUpAssignedVenueId({ matchUp: matchUp }).venueId;
            if (!targetVenueIds.filter(Boolean).includes(venueId)) {
                return false;
            }
        }
        if (processContext) {
            if (targetTournamentIds.length && !targetTournamentIds.includes(matchUp.tournamentId)) {
                return false;
            }
            if (targetEventIds.length && !targetEventIds.includes(matchUp.eventId)) {
                return false;
            }
            if (targetDrawIds.length && !targetDrawIds.includes(matchUp.drawId)) {
                return false;
            }
            if (targetStructureIds.length && !targetStructureIds.includes(matchUp.structureId)) {
                return false;
            }
            if (targetParticipantIds.length) {
                var matchUpParticipantIds_1 = (_b = (_a = matchUp.sides) === null || _a === void 0 ? void 0 : _a.map(function (_a) {
                    var participantId = _a.participantId;
                    return participantId;
                }).filter(Boolean)) !== null && _b !== void 0 ? _b : [];
                var containsTargetedParticipantId = targetParticipantIds.some(function (participantId) {
                    return matchUpParticipantIds_1.includes(participantId);
                });
                if (!containsTargetedParticipantId)
                    return false;
            }
        }
        return true;
    });
}

function getSide(_a) {
    var _b, _c, _d, _e;
    var drawPositionCollectionAssignment = _a.drawPositionCollectionAssignment, sideNumberCollectionAssignment = _a.sideNumberCollectionAssignment, positionAssignments = _a.positionAssignments, displaySideNumber = _a.displaySideNumber, seedAssignments = _a.seedAssignments, drawPosition = _a.drawPosition, isFeedRound = _a.isFeedRound, sideNumber = _a.sideNumber;
    var assignment = positionAssignments.find(function (assignment) { return assignment.drawPosition && assignment.drawPosition === drawPosition; });
    var dpc = drawPosition && drawPositionCollectionAssignment;
    var snc = sideNumber && sideNumberCollectionAssignment;
    var participantId = dpc ? (_b = dpc[drawPosition]) === null || _b === void 0 ? void 0 : _b.participantId : assignment === null || assignment === void 0 ? void 0 : assignment.participantId;
    var sideValue = assignment
        ? getSideValue$1({
            displaySideNumber: displaySideNumber,
            seedAssignments: seedAssignments,
            participantId: participantId,
            assignment: assignment,
            sideNumber: sideNumber,
        })
        : __assign({}, snc === null || snc === void 0 ? void 0 : snc[sideNumber]);
    if (isFeedRound) {
        if (sideNumber === 1) {
            Object.assign(sideValue, { participantFed: true });
        }
        else {
            Object.assign(sideValue, { participantAdvanced: true });
        }
    }
    if (drawPosition && dpc) {
        var teamParticipant = (_c = dpc[drawPosition]) === null || _c === void 0 ? void 0 : _c.teamParticipant;
        var participant = (_d = dpc[drawPosition]) === null || _d === void 0 ? void 0 : _d.participant;
        var substitutions = (_e = dpc[drawPosition]) === null || _e === void 0 ? void 0 : _e.substitutions;
        if (participant)
            sideValue.participant = participant;
        if (substitutions)
            sideValue.substitutions = substitutions;
        if (teamParticipant)
            sideValue.teamParticipant = teamParticipant;
    }
    return sideValue;
}
function getSideValue$1(_a) {
    var displaySideNumber = _a.displaySideNumber, seedAssignments = _a.seedAssignments, participantId = _a.participantId, assignment = _a.assignment, sideNumber = _a.sideNumber;
    var side = {
        drawPosition: assignment.drawPosition,
        displaySideNumber: displaySideNumber,
        sideNumber: sideNumber,
    };
    if (participantId) {
        var seeding = getSeeding({ seedAssignments: seedAssignments, participantId: participantId });
        Object.assign(side, seeding, { participantId: participantId });
    }
    else if (assignment.bye) {
        Object.assign(side, { bye: true });
    }
    if (assignment.qualifier) {
        Object.assign(side, { qualifier: true });
    }
    return side;
}
function getSeeding(_a) {
    var seedAssignments = _a.seedAssignments, participantId = _a.participantId;
    return seedAssignments === null || seedAssignments === void 0 ? void 0 : seedAssignments.find(function (assignment) { return !assignment.seedProxy && assignment.participantId === participantId; });
}

var ANY = 'ANY';
var MALE = 'MALE';
var MIXED = 'MIXED';
var OTHER$2 = 'OTHER';
var FEMALE = 'FEMALE';
var genderConstants = {
    ANY: ANY,
    MALE: MALE,
    FEMALE: FEMALE,
    MIXED: MIXED,
    OTHER: OTHER$2,
};

function getAllStructureMatchUps(_a) {
    var _b, _c, _d, _e, _f, _g, _h;
    var scheduleVisibilityFilters = _a.scheduleVisibilityFilters, tournamentAppliedPolicies = _a.tournamentAppliedPolicies, provisionalPositioning = _a.provisionalPositioning, tournamentParticipants = _a.tournamentParticipants, afterRecoveryTimes = _a.afterRecoveryTimes, policyDefinitions = _a.policyDefinitions, tournamentRecord = _a.tournamentRecord, seedAssignments = _a.seedAssignments, usePublishState = _a.usePublishState, contextFilters = _a.contextFilters, contextContent = _a.contextContent, matchUpFilters = _a.matchUpFilters, participantMap = _a.participantMap, scheduleTiming = _a.scheduleTiming, contextProfile = _a.contextProfile, drawDefinition = _a.drawDefinition, publishStatus = _a.publishStatus, _j = _a.context, context = _j === void 0 ? {} : _j, exitProfiles = _a.exitProfiles, matchUpsMap = _a.matchUpsMap, structure = _a.structure, inContext = _a.inContext, event = _a.event;
    var collectionPositionMatchUps = {}, roundMatchUps = {};
    tournamentParticipants = tournamentParticipants !== null && tournamentParticipants !== void 0 ? tournamentParticipants : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants;
    if (!structure) {
        return {
            collectionPositionMatchUps: collectionPositionMatchUps,
            error: MISSING_STRUCTURE,
            roundMatchUps: roundMatchUps,
            matchUps: [],
        };
    }
    var selectedEventIds = Array.isArray(matchUpFilters === null || matchUpFilters === void 0 ? void 0 : matchUpFilters.eventIds) ? matchUpFilters === null || matchUpFilters === void 0 ? void 0 : matchUpFilters.eventIds.filter(Boolean) : [];
    var selectedStructureIds = Array.isArray(matchUpFilters === null || matchUpFilters === void 0 ? void 0 : matchUpFilters.structureIds)
        ? matchUpFilters === null || matchUpFilters === void 0 ? void 0 : matchUpFilters.structureIds.filter(Boolean)
        : [];
    var selectedDrawIds = Array.isArray(matchUpFilters === null || matchUpFilters === void 0 ? void 0 : matchUpFilters.drawIds) ? matchUpFilters === null || matchUpFilters === void 0 ? void 0 : matchUpFilters.drawIds.filter(Boolean) : [];
    var targetEvent = !(context === null || context === void 0 ? void 0 : context.eventId) ||
        (!(selectedEventIds === null || selectedEventIds === void 0 ? void 0 : selectedEventIds.length) && !((_b = contextFilters === null || contextFilters === void 0 ? void 0 : contextFilters.eventIds) === null || _b === void 0 ? void 0 : _b.filter(Boolean).length)) ||
        (selectedEventIds === null || selectedEventIds === void 0 ? void 0 : selectedEventIds.includes(context.eventId)) ||
        ((_c = contextFilters === null || contextFilters === void 0 ? void 0 : contextFilters.eventIds) === null || _c === void 0 ? void 0 : _c.includes(context.eventId));
    var targetStructure = !(selectedStructureIds === null || selectedStructureIds === void 0 ? void 0 : selectedStructureIds.length) || selectedStructureIds.includes(structure.structureId);
    var targetDraw = !drawDefinition || !(selectedDrawIds === null || selectedDrawIds === void 0 ? void 0 : selectedDrawIds.length) || selectedDrawIds.includes(drawDefinition.drawId);
    // don't process this structure if filters and filters don't include eventId, drawId or structureId
    if (!targetEvent || !targetStructure || !targetDraw) {
        return {
            collectionPositionMatchUps: collectionPositionMatchUps,
            roundMatchUps: roundMatchUps,
            matchUps: [],
        };
    }
    if (contextProfile && !contextContent) {
        contextContent = getContextContent({
            tournamentRecord: tournamentRecord,
            contextProfile: contextProfile,
            drawDefinition: drawDefinition,
        });
    }
    // TODO: code is shared with matchUpActions.js
    // TODO: extend testing to restrict for MAIN while leaving consolation unrestricted
    var drawAppliedPolicies = getAppliedPolicies({
        drawDefinition: drawDefinition,
    }).appliedPolicies;
    var appliedPolicies = __assign(__assign(__assign({}, tournamentAppliedPolicies), drawAppliedPolicies), policyDefinitions);
    var structureScoringPolicies = (_d = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.scoring) === null || _d === void 0 ? void 0 : _d.structures;
    var stageSpecificPolicies = structure.stage && (structureScoringPolicies === null || structureScoringPolicies === void 0 ? void 0 : structureScoringPolicies.stage) && (structureScoringPolicies === null || structureScoringPolicies === void 0 ? void 0 : structureScoringPolicies.stage[structure.stage]);
    var sequenceSpecificPolicies = structure.stageSequence &&
        (stageSpecificPolicies === null || stageSpecificPolicies === void 0 ? void 0 : stageSpecificPolicies.stageSequence) &&
        stageSpecificPolicies.stageSequence[structure.stageSequence];
    var requireAllPositionsAssigned = ((_e = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.scoring) === null || _e === void 0 ? void 0 : _e.requireAllPositionsAssigned) ||
        (stageSpecificPolicies === null || stageSpecificPolicies === void 0 ? void 0 : stageSpecificPolicies.requireAllPositionsAssigned) ||
        (sequenceSpecificPolicies === null || sequenceSpecificPolicies === void 0 ? void 0 : sequenceSpecificPolicies.requireAllPositionsAssigned);
    if (!matchUpsMap) {
        matchUpsMap = getMatchUpsMap({ drawDefinition: drawDefinition, structure: structure });
    }
    var _k = structureAssignedDrawPositions({ structure: structure }), positionAssignments = _k.positionAssignments, allPositionsAssigned = _k.allPositionsAssigned;
    var scoringActive = !requireAllPositionsAssigned || allPositionsAssigned;
    var structureSeedAssignments = getStructureSeedAssignments({
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        structure: structure,
    }).seedAssignments;
    // enables passing in seedAssignments rather than using structureSeedAssignments
    seedAssignments = seedAssignments !== null && seedAssignments !== void 0 ? seedAssignments : structureSeedAssignments;
    var roundOffset = structure.roundOffset, structureId = structure.structureId, structureName = structure.structureName, stage = structure.stage, stageSequence = structure.stageSequence;
    var _l = drawDefinition !== null && drawDefinition !== void 0 ? drawDefinition : {}, drawId = _l.drawId, drawName = _l.drawName, drawType = _l.drawType;
    exitProfiles = exitProfiles || (drawDefinition && getExitProfiles({ drawDefinition: drawDefinition }).exitProfiles);
    var exitProfile = exitProfiles === null || exitProfiles === void 0 ? void 0 : exitProfiles[structureId];
    var initialRoundOfPlay = (exitProfile === null || exitProfile === void 0 ? void 0 : exitProfile.length) &&
        (exitProfile[0]
            .split('-')
            .map(function (x) { return parseInt(x); })
            .reduce(function (a, b) { return a + b; }) ||
            0);
    var isRoundRobin = !!structure.structures;
    var matchUps = getMappedStructureMatchUps({
        matchUpsMap: matchUpsMap,
        structureId: structureId,
        inContext: inContext,
    });
    var roundNamingPolicy = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_ROUND_NAMING];
    var result = getRoundContextProfile({
        roundNamingPolicy: roundNamingPolicy,
        drawDefinition: drawDefinition,
        structure: structure,
        matchUps: matchUps,
    });
    var roundNamingProfile = result.roundNamingProfile, roundProfile = result.roundProfile;
    roundMatchUps = (_f = result === null || result === void 0 ? void 0 : result.roundMatchUps) !== null && _f !== void 0 ? _f : [];
    // must make a pass before hydration and addition of tieMatchUps
    if (matchUpFilters) {
        matchUps = filterMatchUps(__assign(__assign({ matchUps: matchUps }, matchUpFilters), { filterMatchUpTypes: false, filterMatchUpIds: false }));
    }
    if (inContext) {
        var sourceDrawPositionRanges_1 = getSourceDrawPositionRanges({
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
            structureId: structureId,
        }).sourceDrawPositionRanges;
        var drawPositionsRanges_1 = drawDefinition
            ? getDrawPositionsRanges({
                drawDefinition: drawDefinition,
                roundProfile: roundProfile,
                matchUpsMap: matchUpsMap,
                structureId: structureId,
            }).drawPositionsRanges
            : undefined;
        matchUps = matchUps.map(function (matchUp) {
            return addMatchUpContext({
                scheduleVisibilityFilters: scheduleVisibilityFilters,
                sourceDrawPositionRanges: sourceDrawPositionRanges_1,
                drawPositionsRanges: drawPositionsRanges_1,
                roundNamingProfile: roundNamingProfile,
                initialRoundOfPlay: initialRoundOfPlay,
                appliedPolicies: appliedPolicies,
                usePublishState: usePublishState,
                publishStatus: publishStatus,
                isRoundRobin: isRoundRobin,
                roundProfile: roundProfile,
                matchUp: matchUp,
                event: event,
            });
        });
        var matchUpTies = matchUps === null || matchUps === void 0 ? void 0 : matchUps.filter(function (matchUp) { return Array.isArray(matchUp.tieMatchUps); });
        matchUpTies.forEach(function (matchUpTie) {
            var tieMatchUps = matchUpTie.tieMatchUps;
            matchUps = matchUps.concat.apply(matchUps, __spreadArray([], __read(tieMatchUps), false));
        });
        if (contextFilters) {
            matchUps = filterMatchUps(__assign(__assign({ processContext: true }, contextFilters), { matchUps: matchUps }));
        }
    }
    else {
        var matchUpTies = matchUps === null || matchUps === void 0 ? void 0 : matchUps.filter(function (matchUp) { return Array.isArray(matchUp.tieMatchUps); });
        matchUpTies.forEach(function (matchUpTie) {
            var tieMatchUps = matchUpTie.tieMatchUps;
            matchUps = matchUps.concat.apply(matchUps, __spreadArray([], __read(tieMatchUps), false));
        });
    }
    // must make a pass after tieMatchUps have been added
    if (matchUpFilters) {
        matchUps = filterMatchUps(__assign(__assign({ matchUps: matchUps }, matchUpFilters), { filterMatchUpTypes: false, filterMatchUpIds: false }));
    }
    // now filter again if there are any matchUpTypes or matchUpIds
    if ((matchUpFilters === null || matchUpFilters === void 0 ? void 0 : matchUpFilters.matchUpTypes) || (matchUpFilters === null || matchUpFilters === void 0 ? void 0 : matchUpFilters.matchUpIds)) {
        matchUps = filterMatchUps({
            matchUpTypes: matchUpFilters.matchUpTypes,
            matchUpIds: matchUpFilters.matchUpIds,
            matchUps: matchUps,
        });
    }
    if ((matchUpFilters === null || matchUpFilters === void 0 ? void 0 : matchUpFilters.matchUpTypes) || (matchUpFilters === null || matchUpFilters === void 0 ? void 0 : matchUpFilters.matchUpIds) || inContext) {
        roundMatchUps = (_g = getRoundMatchUps({ matchUps: matchUps }).roundMatchUps) !== null && _g !== void 0 ? _g : [];
    }
    if ((_h = resolveTieFormat({ drawDefinition: drawDefinition, structure: structure, event: event })) === null || _h === void 0 ? void 0 : _h.tieFormat) {
        (collectionPositionMatchUps = getCollectionPositionMatchUps({
            matchUps: matchUps,
        }).collectionPositionMatchUps);
    }
    return {
        collectionPositionMatchUps: collectionPositionMatchUps,
        roundMatchUps: roundMatchUps,
        roundProfile: roundProfile,
        matchUpsMap: matchUpsMap,
        matchUps: matchUps,
    };
    function addMatchUpContext(_a) {
        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
        var scheduleVisibilityFilters = _a.scheduleVisibilityFilters, sourceDrawPositionRanges = _a.sourceDrawPositionRanges, drawPositionsRanges = _a.drawPositionsRanges, initialRoundOfPlay = _a.initialRoundOfPlay, additionalContext = _a.additionalContext, roundNamingProfile = _a.roundNamingProfile, tieDrawPositions = _a.tieDrawPositions, appliedPolicies = _a.appliedPolicies, isCollectionBye = _a.isCollectionBye, usePublishState = _a.usePublishState, publishStatus = _a.publishStatus, matchUpTieId = _a.matchUpTieId, isRoundRobin = _a.isRoundRobin, roundProfile = _a.roundProfile, sideLineUps = _a.sideLineUps, matchUp = _a.matchUp, event = _a.event;
        additionalContext = additionalContext !== null && additionalContext !== void 0 ? additionalContext : {};
        var tieFormat = (_b = resolveTieFormat({
            drawDefinition: drawDefinition,
            structure: structure,
            matchUp: matchUp,
            event: event,
        })) === null || _b === void 0 ? void 0 : _b.tieFormat;
        var collectionDefinitions = tieFormat === null || tieFormat === void 0 ? void 0 : tieFormat.collectionDefinitions;
        var collectionDefinition = matchUp.collectionId &&
            (collectionDefinitions === null || collectionDefinitions === void 0 ? void 0 : collectionDefinitions.find(function (definition) { return definition.collectionId === matchUp.collectionId; }));
        var matchUpFormat = matchUp.collectionId
            ? collectionDefinition === null || collectionDefinition === void 0 ? void 0 : collectionDefinition.matchUpFormat
            : (_e = (_d = (_c = matchUp.matchUpFormat) !== null && _c !== void 0 ? _c : structure === null || structure === void 0 ? void 0 : structure.matchUpFormat) !== null && _d !== void 0 ? _d : drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.matchUpFormat) !== null && _e !== void 0 ? _e : event === null || event === void 0 ? void 0 : event.matchUpFormat;
        var matchUpType = matchUp.matchUpType ||
            (collectionDefinition === null || collectionDefinition === void 0 ? void 0 : collectionDefinition.matchUpType) ||
            (structure === null || structure === void 0 ? void 0 : structure.matchUpType) ||
            (drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.matchUpType) ||
            ((event === null || event === void 0 ? void 0 : event.eventType) !== TEAM$2 && (event === null || event === void 0 ? void 0 : event.eventType));
        var matchUpStatus = isCollectionBye ? BYE : matchUp.matchUpStatus;
        var _1 = getMatchUpScheduleDetails({
            scheduleVisibilityFilters: scheduleVisibilityFilters,
            afterRecoveryTimes: afterRecoveryTimes,
            tournamentRecord: tournamentRecord,
            usePublishState: usePublishState,
            scheduleTiming: scheduleTiming,
            matchUpFormat: matchUpFormat,
            publishStatus: publishStatus,
            matchUpType: matchUpType,
            matchUp: matchUp,
            event: event,
        }), schedule = _1.schedule, endDate = _1.endDate;
        var drawPositions = (_f = tieDrawPositions !== null && tieDrawPositions !== void 0 ? tieDrawPositions : matchUp.drawPositions) !== null && _f !== void 0 ? _f : [];
        var collectionPosition = matchUp.collectionPosition, collectionId = matchUp.collectionId, roundPosition = matchUp.roundPosition;
        var roundNumber = (_g = matchUp.roundNumber) !== null && _g !== void 0 ? _g : additionalContext.roundNumber;
        var collectionAssignmentDetail = collectionId
            ? getCollectionAssignment({
                tournamentParticipants: tournamentParticipants,
                positionAssignments: positionAssignments,
                collectionPosition: collectionPosition,
                drawDefinition: drawDefinition,
                participantMap: participantMap,
                drawPositions: drawPositions,
                collectionId: collectionId,
                sideLineUps: sideLineUps,
                matchUpType: matchUpType,
            })
            : undefined;
        var roundName = ((_h = roundNamingProfile === null || roundNamingProfile === void 0 ? void 0 : roundNamingProfile[roundNumber]) === null || _h === void 0 ? void 0 : _h.roundName) || additionalContext.roundName;
        var abbreviatedRoundName = ((_j = roundNamingProfile === null || roundNamingProfile === void 0 ? void 0 : roundNamingProfile[roundNumber]) === null || _j === void 0 ? void 0 : _j.abbreviatedRoundName) || additionalContext.abbreviatedRoundName;
        var feedRound = (_k = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber]) === null || _k === void 0 ? void 0 : _k.feedRound;
        var preFeedRound = (_l = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber]) === null || _l === void 0 ? void 0 : _l.preFeedRound;
        var roundFactor = (_m = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber]) === null || _m === void 0 ? void 0 : _m.roundFactor;
        var drawPositionsRoundRanges = drawPositionsRanges === null || drawPositionsRanges === void 0 ? void 0 : drawPositionsRanges[roundNumber];
        var drawPositionsRange = roundPosition ? drawPositionsRoundRanges === null || drawPositionsRoundRanges === void 0 ? void 0 : drawPositionsRoundRanges[roundPosition] : undefined;
        var sourceDrawPositionRoundRanges = sourceDrawPositionRanges === null || sourceDrawPositionRanges === void 0 ? void 0 : sourceDrawPositionRanges[roundNumber];
        // if part of a tie matchUp and collectionDefinition has a category definition, prioritize
        var matchUpCategory = (collectionDefinition === null || collectionDefinition === void 0 ? void 0 : collectionDefinition.category)
            ? __assign(__assign({}, ((context === null || context === void 0 ? void 0 : context.category) || {})), collectionDefinition.category) : (_o = context === null || context === void 0 ? void 0 : context.category) !== null && _o !== void 0 ? _o : event === null || event === void 0 ? void 0 : event.category;
        var processCodes = (((_p = matchUp.processCodes) === null || _p === void 0 ? void 0 : _p.length) && matchUp.processCodes) ||
            (((_q = collectionDefinition === null || collectionDefinition === void 0 ? void 0 : collectionDefinition.processCodes) === null || _q === void 0 ? void 0 : _q.length) && (collectionDefinition === null || collectionDefinition === void 0 ? void 0 : collectionDefinition.processCodes)) ||
            (((_r = structure === null || structure === void 0 ? void 0 : structure.processCodes) === null || _r === void 0 ? void 0 : _r.length) && (structure === null || structure === void 0 ? void 0 : structure.processCodes)) ||
            (((_s = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.processCodes) === null || _s === void 0 ? void 0 : _s.length) && (drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.processCodes)) ||
            (((_t = event === null || event === void 0 ? void 0 : event.processCodes) === null || _t === void 0 ? void 0 : _t.length) && (event === null || event === void 0 ? void 0 : event.processCodes)) ||
            (tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.processCodes);
        var competitiveProfile = (contextProfile === null || contextProfile === void 0 ? void 0 : contextProfile.withCompetitiveness) && getMatchUpCompetitiveProfile(__assign(__assign({}, contextContent), { matchUp: matchUp }));
        // necessry for SINGLES/DOUBLES matchUps that are part of TEAM tournaments
        var finishingPositionRange = (_u = matchUp.finishingPositionRange) !== null && _u !== void 0 ? _u : additionalContext.finishingPositionRange;
        // order is important here as Round Robin matchUps already have inContext structureId
        var onlyDefined = function (obj) { return definedAttributes(obj, undefined, true); };
        var matchUpWithContext = __assign(__assign(__assign({}, onlyDefined(context)), onlyDefined({
            matchUpFormat: matchUp.matchUpType === TEAM$2 ? undefined : matchUpFormat,
            tieFormat: matchUp.matchUpType !== TEAM$2 ? undefined : tieFormat,
            gender: (_v = collectionDefinition === null || collectionDefinition === void 0 ? void 0 : collectionDefinition.gender) !== null && _v !== void 0 ? _v : event === null || event === void 0 ? void 0 : event.gender,
            roundOfPlay: stage !== QUALIFYING && isConvertableInteger(initialRoundOfPlay) && initialRoundOfPlay + (roundNumber || 0),
            endDate: (_w = matchUp.endDate) !== null && _w !== void 0 ? _w : endDate,
            discipline: event === null || event === void 0 ? void 0 : event.discipline,
            category: matchUpCategory,
            finishingPositionRange: finishingPositionRange,
            abbreviatedRoundName: abbreviatedRoundName,
            drawPositionsRange: drawPositionsRange,
            competitiveProfile: competitiveProfile,
            structureName: structureName,
            stageSequence: stageSequence,
            drawPositions: drawPositions,
            matchUpStatus: matchUpStatus,
            processCodes: processCodes,
            isRoundRobin: isRoundRobin,
            matchUpTieId: matchUpTieId,
            preFeedRound: preFeedRound,
            matchUpType: matchUpType,
            roundFactor: roundFactor,
            roundOffset: roundOffset,
            structureId: structureId,
            roundNumber: roundNumber,
            feedRound: feedRound,
            roundName: roundName,
            drawName: drawName,
            drawType: drawType,
            schedule: schedule,
            drawId: drawId,
            stage: stage,
        })), makeDeepCopy(onlyDefined(matchUp), true, true));
        if (matchUpFormat && ((_x = matchUp.score) === null || _x === void 0 ? void 0 : _x.scoreStringSide1)) {
            var parsedFormat = parse(matchUpFormat);
            var _2 = parsedFormat !== null && parsedFormat !== void 0 ? parsedFormat : {}, bestOf_1 = _2.bestOf, finalSetFormat_1 = _2.finalSetFormat, setFormat_1 = _2.setFormat;
            if ((finalSetFormat_1 === null || finalSetFormat_1 === void 0 ? void 0 : finalSetFormat_1.tiebreakSet) || (setFormat_1 === null || setFormat_1 === void 0 ? void 0 : setFormat_1.tiebreakSet) || (setFormat_1 === null || setFormat_1 === void 0 ? void 0 : setFormat_1.timed)) {
                matchUpWithContext.score.sets = matchUpWithContext.score.sets
                    .sort(function (a, b) { return a.setNumber - b.setNumber; })
                    .map(function (set, i) {
                    var setNumber = i + 1;
                    if (setNumber === bestOf_1) {
                        if ((finalSetFormat_1 === null || finalSetFormat_1 === void 0 ? void 0 : finalSetFormat_1.tiebreakSet) || (finalSetFormat_1 === null || finalSetFormat_1 === void 0 ? void 0 : finalSetFormat_1.timed))
                            set.tiebreakSet = true;
                    }
                    else if ((setFormat_1 === null || setFormat_1 === void 0 ? void 0 : setFormat_1.tiebreakSet) || (setFormat_1 === null || setFormat_1 === void 0 ? void 0 : setFormat_1.timed)) {
                        set.tiebreakSet = true;
                    }
                    return set;
                });
            }
        }
        if (Array.isArray(drawPositions)) {
            var _3 = getOrderedDrawPositions({
                drawPositions: drawPositions,
                roundProfile: roundProfile,
                roundNumber: roundNumber,
            }), orderedDrawPositions = _3.orderedDrawPositions, displayOrder = _3.displayOrder;
            var isFeedRound_1 = (_y = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber]) === null || _y === void 0 ? void 0 : _y.feedRound;
            var reversedDisplayOrder_1 = displayOrder[0] !== orderedDrawPositions[0];
            // ensure there are two sides generated
            var sideDrawPositions = orderedDrawPositions.concat(undefined, undefined).slice(0, 2);
            var sides = sideDrawPositions.map(function (drawPosition, index) {
                var _a;
                var sideNumber = index + 1;
                var displaySideNumber = reversedDisplayOrder_1 ? 3 - sideNumber : sideNumber;
                var side = getSide(__assign(__assign({}, collectionAssignmentDetail), { positionAssignments: positionAssignments, displaySideNumber: displaySideNumber, seedAssignments: seedAssignments, drawPosition: drawPosition, isFeedRound: isFeedRound_1, sideNumber: sideNumber }));
                var existingSide = (_a = matchUp.sides) === null || _a === void 0 ? void 0 : _a.find(function (existing) { return existing.sideNumber === sideNumber; });
                // drawPositions for consolation structures are offset by the number of fed positions in subsequent rounds
                // columnPosition gives an ordered position value relative to a single column
                var columnPosition = roundPosition ? (roundPosition - 1) * 2 + index + 1 : undefined;
                var sourceDrawPositionRange = columnPosition ? sourceDrawPositionRoundRanges === null || sourceDrawPositionRoundRanges === void 0 ? void 0 : sourceDrawPositionRoundRanges[columnPosition] : undefined;
                return onlyDefined(__assign(__assign({ sourceDrawPositionRange: sourceDrawPositionRange }, existingSide), side));
            });
            Object.assign(matchUpWithContext, makeDeepCopy({ sides: sides }, true, true));
        }
        if (tournamentParticipants && matchUpWithContext.sides) {
            var participantAttributes_1 = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_PARTICIPANT];
            var getMappedParticipant_1 = function (participantId) {
                var _a;
                var participant = (_a = participantMap === null || participantMap === void 0 ? void 0 : participantMap[participantId]) === null || _a === void 0 ? void 0 : _a.participant;
                return (participant &&
                    attributeFilter({
                        template: participantAttributes_1 === null || participantAttributes_1 === void 0 ? void 0 : participantAttributes_1.participant,
                        source: participant,
                    }));
            };
            matchUpWithContext.sides.filter(Boolean).forEach(function (side) {
                var _a, _b, _c;
                if (side.participantId) {
                    var participant = makeDeepCopy(getMappedParticipant_1(side.participantId) ||
                        (tournamentParticipants &&
                            findParticipant({
                                policyDefinitions: appliedPolicies,
                                participantId: side.participantId,
                                tournamentParticipants: tournamentParticipants,
                                internalUse: true,
                                contextProfile: contextProfile,
                            })), undefined, true);
                    if (participant) {
                        if (drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) {
                            var entry = drawDefinition.entries.find(function (entry) { return entry.participantId === side.participantId; });
                            if (entry === null || entry === void 0 ? void 0 : entry.entryStatus) {
                                participant.entryStatus = entry.entryStatus;
                            }
                            if (entry === null || entry === void 0 ? void 0 : entry.entryStage) {
                                participant.entryStage = entry.entryStage;
                            }
                        }
                        Object.assign(side, { participant: participant });
                    }
                }
                if (((_b = (_a = side === null || side === void 0 ? void 0 : side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipantIds) === null || _b === void 0 ? void 0 : _b.length) && !((_c = side.participant.individualParticipants) === null || _c === void 0 ? void 0 : _c.length)) {
                    var individualParticipants = side.participant.individualParticipantIds.map(function (participantId) {
                        return (getMappedParticipant_1(participantId) ||
                            (tournamentParticipants &&
                                findParticipant({
                                    policyDefinitions: appliedPolicies,
                                    tournamentParticipants: tournamentParticipants,
                                    internalUse: true,
                                    contextProfile: contextProfile,
                                    participantId: participantId,
                                })));
                    });
                    Object.assign(side.participant, { individualParticipants: individualParticipants });
                }
            });
            if (!matchUpWithContext.matchUpType) {
                var matchUpType_1 = getMatchUpType({ matchUp: matchUpWithContext }).matchUpType;
                if (matchUpType_1)
                    Object.assign(matchUpWithContext, { matchUpType: matchUpType_1 });
            }
            var inferGender = (contextProfile === null || contextProfile === void 0 ? void 0 : contextProfile.inferGender) &&
                (!matchUpWithContext.gender || matchUpWithContext.gender === MIXED) &&
                ((_z = matchUpWithContext.sides) === null || _z === void 0 ? void 0 : _z.length) === 2 &&
                matchUpWithContext.matchUpType !== TEAM$2;
            if (inferGender) {
                var sideGenders = matchUpWithContext.sides.map(function (side) {
                    var _a, _b, _c, _d;
                    if (matchUpWithContext.matchUpType === SINGLES)
                        return (_b = (_a = side.participant) === null || _a === void 0 ? void 0 : _a.person) === null || _b === void 0 ? void 0 : _b.sex;
                    if (((_d = (_c = side.participant) === null || _c === void 0 ? void 0 : _c.individualParticipants) === null || _d === void 0 ? void 0 : _d.length) === 2) {
                        var pairGenders = unique(side.participant.individualParticipants.map(function (participant) { var _a; return (_a = participant.person) === null || _a === void 0 ? void 0 : _a.sex; })).filter(Boolean);
                        if (pairGenders.length === 1)
                            return pairGenders[0];
                    }
                });
                if (sideGenders.filter(Boolean).length === 2 && unique(sideGenders).length === 1) {
                    var inferredGender = sideGenders[0];
                    matchUpWithContext.inferredGender = inferredGender;
                }
            }
        }
        if (matchUpWithContext.tieMatchUps) {
            var isCollectionBye_1 = matchUpWithContext.matchUpStatus === BYE;
            var lineUps_1 = (_0 = matchUpWithContext.sides) === null || _0 === void 0 ? void 0 : _0.map(function (_a) {
                var participant = _a.participant, drawPosition = _a.drawPosition, sideNumber = _a.sideNumber, lineUp = _a.lineUp;
                var teamParticipant = (participant === null || participant === void 0 ? void 0 : participant.participantType) === TEAM$2 && participant;
                var teamParticipantValues = teamParticipant &&
                    definedAttributes({
                        participantRoleResponsibilities: teamParticipant.participantRoleResponsibilities,
                        participantOtherName: teamParticipant.participanOthertName,
                        participantName: teamParticipant.participantName,
                        participantId: teamParticipant.participantId,
                        teamId: teamParticipant.teamId,
                    });
                return {
                    teamParticipant: teamParticipantValues,
                    drawPosition: drawPosition,
                    sideNumber: sideNumber,
                    lineUp: lineUp,
                };
            });
            matchUpWithContext.tieMatchUps = matchUpWithContext.tieMatchUps.map(function (matchUp) {
                var matchUpTieId = matchUpWithContext.matchUpId;
                var finishingPositionRange = matchUpWithContext.finishingPositionRange;
                var additionalContext = {
                    finishingPositionRange: finishingPositionRange,
                    abbreviatedRoundName: abbreviatedRoundName,
                    roundNumber: roundNumber,
                    roundName: roundName,
                };
                return addMatchUpContext({
                    tieDrawPositions: drawPositions,
                    scheduleVisibilityFilters: scheduleVisibilityFilters,
                    sourceDrawPositionRanges: sourceDrawPositionRanges,
                    sideLineUps: lineUps_1,
                    drawPositionsRanges: drawPositionsRanges,
                    initialRoundOfPlay: initialRoundOfPlay,
                    roundNamingProfile: roundNamingProfile,
                    additionalContext: additionalContext,
                    appliedPolicies: appliedPolicies,
                    isCollectionBye: isCollectionBye_1,
                    usePublishState: usePublishState,
                    publishStatus: publishStatus,
                    matchUpTieId: matchUpTieId,
                    isRoundRobin: isRoundRobin,
                    roundProfile: roundProfile,
                    matchUp: matchUp,
                    event: event,
                });
            });
        }
        var hasParticipants = matchUpWithContext.sides && matchUpWithContext.sides.filter(function (side) { return side === null || side === void 0 ? void 0 : side.participantId; }).length === 2;
        var hasNoWinner = !matchUpWithContext.winningSide;
        var readyToScore = scoringActive && hasParticipants && hasNoWinner;
        Object.assign(matchUpWithContext, { readyToScore: readyToScore, hasContext: true });
        if (hasParticipants) {
            var _4 = getCheckedInParticipantIds({
                matchUp: matchUpWithContext,
            }), allParticipantsCheckedIn = _4.allParticipantsCheckedIn, checkedInParticipantIds = _4.checkedInParticipantIds;
            Object.assign(matchUpWithContext, {
                allParticipantsCheckedIn: allParticipantsCheckedIn,
                checkedInParticipantIds: checkedInParticipantIds,
            });
        }
        if (Array.isArray(contextProfile === null || contextProfile === void 0 ? void 0 : contextProfile.exclude)) {
            // loop through all attributes and delete them from matchUpWithContext
            contextProfile === null || contextProfile === void 0 ? void 0 : contextProfile.exclude.forEach(function (attribute) { return delete matchUpWithContext[attribute]; });
        }
        return matchUpWithContext;
    }
}

function checkMatchUpIsComplete(_a) {
    var matchUp = _a.matchUp;
    if (!matchUp)
        return false;
    return (completedMatchUpStatuses.includes(matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpStatus) ||
        (matchUp === null || matchUp === void 0 ? void 0 : matchUp.winningSide));
}

function getStructureMatchUps(_a) {
    var _b = _a.requireParticipants, requireParticipants = _b === void 0 ? true : _b, scheduleVisibilityFilters = _a.scheduleVisibilityFilters, tournamentAppliedPolicies = _a.tournamentAppliedPolicies, tournamentParticipants = _a.tournamentParticipants, afterRecoveryTimes = _a.afterRecoveryTimes, policyDefinitions = _a.policyDefinitions, tournamentRecord = _a.tournamentRecord, usePublishState = _a.usePublishState, matchUpFilters = _a.matchUpFilters, contextFilters = _a.contextFilters, contextContent = _a.contextContent, participantMap = _a.participantMap, scheduleTiming = _a.scheduleTiming, publishStatus = _a.publishStatus, contextProfile = _a.contextProfile, drawDefinition = _a.drawDefinition, exitProfiles = _a.exitProfiles, matchUpsMap = _a.matchUpsMap, structureId = _a.structureId, inContext = _a.inContext, structure = _a.structure, context = _a.context, event = _a.event;
    if (!structure && structureId) {
        (structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure);
    }
    var result = getAllStructureMatchUps({
        tournamentAppliedPolicies: tournamentAppliedPolicies,
        scheduleVisibilityFilters: scheduleVisibilityFilters,
        tournamentParticipants: tournamentParticipants,
        afterRecoveryTimes: afterRecoveryTimes,
        policyDefinitions: policyDefinitions,
        tournamentRecord: tournamentRecord,
        usePublishState: usePublishState,
        matchUpFilters: matchUpFilters,
        contextFilters: contextFilters,
        contextContent: contextContent,
        participantMap: participantMap,
        scheduleTiming: scheduleTiming,
        publishStatus: publishStatus,
        contextProfile: contextProfile,
        drawDefinition: drawDefinition,
        exitProfiles: exitProfiles,
        matchUpsMap: matchUpsMap,
        structure: structure,
        inContext: inContext,
        context: context,
        event: event,
    });
    var abandonedMatchUps = [];
    var completedMatchUps = [];
    var upcomingMatchUps = [];
    var pendingMatchUps = [];
    var byeMatchUps = [];
    if (result.error)
        return result;
    var matchUps = result.matchUps;
    var assignedPositions = structureAssignedDrawPositions({ structure: structure }).assignedPositions;
    var participantAssignedDrawPositions = assignedPositions === null || assignedPositions === void 0 ? void 0 : assignedPositions.filter(function (assignment) { return assignment.participantId; }).map(function (assignment) { return assignment.drawPosition; });
    var includesTeamMatchUps;
    matchUps
        .filter(function (matchUp) {
        var _a;
        var teamsMatchUpsOnly = ((_a = matchUpFilters === null || matchUpFilters === void 0 ? void 0 : matchUpFilters.matchUpTypes) === null || _a === void 0 ? void 0 : _a.length) === 1 && matchUpFilters.matchUpTypes[0] === TEAM;
        return !(matchUp.matchUpType !== TEAM && teamsMatchUpsOnly);
    })
        .forEach(function (matchUp) {
        var _a, _b, _c, _d;
        if (matchUp.matchUpStatus === ABANDONED$1) {
            abandonedMatchUps.push(matchUp);
            return;
        }
        if (matchUp.matchUpType === TEAM)
            includesTeamMatchUps = true;
        var isCollectionMatchUp = matchUp.collectionId;
        var collectionSidesAssigned = isCollectionMatchUp && ((_a = matchUp.sides) === null || _a === void 0 ? void 0 : _a.every(function (side) { return side.participantId; }));
        var drawPositionsFilled = !isCollectionMatchUp && ((_b = matchUp.drawPositions) === null || _b === void 0 ? void 0 : _b.filter(Boolean).length) === 2;
        var drawPositionsAssigned = !isCollectionMatchUp &&
            ((_c = matchUp.drawPositions) === null || _c === void 0 ? void 0 : _c.every(function (drawPosition) { return participantAssignedDrawPositions === null || participantAssignedDrawPositions === void 0 ? void 0 : participantAssignedDrawPositions.includes(drawPosition); }));
        var byeAssignedDrawPositions = assignedPositions === null || assignedPositions === void 0 ? void 0 : assignedPositions.filter(function (assignment) { return assignment.bye; }).map(function (assignment) { return assignment.drawPosition; });
        var isByeMatchUp = !isCollectionMatchUp &&
            ((_d = matchUp.drawPositions) === null || _d === void 0 ? void 0 : _d.find(function (drawPosition) { return byeAssignedDrawPositions === null || byeAssignedDrawPositions === void 0 ? void 0 : byeAssignedDrawPositions.includes(drawPosition); }));
        var validUpcomingMatchUpStatus = upcomingMatchUpStatuses.includes(matchUp.matchUpStatus);
        var isUpcomingMatchUp = validUpcomingMatchUpStatus &&
            (collectionSidesAssigned || (drawPositionsFilled && (!requireParticipants || drawPositionsAssigned)));
        if (isByeMatchUp)
            return byeMatchUps.push(matchUp);
        if (checkMatchUpIsComplete({ matchUp: matchUp }))
            return completedMatchUps.push(matchUp);
        if (isUpcomingMatchUp)
            return upcomingMatchUps.push(matchUp);
        return pendingMatchUps.push(matchUp);
    });
    return {
        includesTeamMatchUps: includesTeamMatchUps,
        abandonedMatchUps: abandonedMatchUps,
        completedMatchUps: completedMatchUps,
        upcomingMatchUps: upcomingMatchUps,
        pendingMatchUps: pendingMatchUps,
        byeMatchUps: byeMatchUps,
        structure: structure,
    };
}

/*
  return ALL matchUps within a drawDefinition, regardless of state
*/
function getAllDrawMatchUps(params) {
    var _a;
    var stack = 'getAllDrawMatchUps';
    Object.assign(params, { requireParticipants: false });
    var result = getDrawMatchUps(params);
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    var abandonedMatchUps = result.abandonedMatchUps, completedMatchUps = result.completedMatchUps, upcomingMatchUps = result.upcomingMatchUps, pendingMatchUps = result.pendingMatchUps, byeMatchUps = result.byeMatchUps, matchUpsMap = result.matchUpsMap;
    var matchUps = (_a = (abandonedMatchUps !== null && abandonedMatchUps !== void 0 ? abandonedMatchUps : [])).concat.apply(_a, __spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read((completedMatchUps !== null && completedMatchUps !== void 0 ? completedMatchUps : [])), false), __read((upcomingMatchUps !== null && upcomingMatchUps !== void 0 ? upcomingMatchUps : [])), false), __read((pendingMatchUps !== null && pendingMatchUps !== void 0 ? pendingMatchUps : [])), false), __read((byeMatchUps !== null && byeMatchUps !== void 0 ? byeMatchUps : [])), false));
    return { matchUps: matchUps, matchUpsMap: matchUpsMap };
}
function getDrawMatchUps(params) {
    var _a;
    if (!(params === null || params === void 0 ? void 0 : params.drawDefinition))
        return { error: MISSING_DRAW_DEFINITION };
    var tournamentParticipants = params.tournamentParticipants, contextContent = params.contextContent, matchUpsMap = params.matchUpsMap;
    var scheduleVisibilityFilters = params.scheduleVisibilityFilters, tournamentAppliedPolicies = params.tournamentAppliedPolicies, requireParticipants = params.requireParticipants, participantsProfile = params.participantsProfile, afterRecoveryTimes = params.afterRecoveryTimes, policyDefinitions = params.policyDefinitions, tournamentRecord = params.tournamentRecord, usePublishState = params.usePublishState, contextFilters = params.contextFilters, matchUpFilters = params.matchUpFilters, scheduleTiming = params.scheduleTiming, participantMap = params.participantMap, publishStatus = params.publishStatus, contextProfile = params.contextProfile, drawDefinition = params.drawDefinition, nextMatchUps = params.nextMatchUps, inContext = params.inContext, context = params.context, event = params.event;
    var allAbandonedMatchUps = [];
    var allCompletedMatchUps = [];
    var allUpcomingMatchUps = [];
    var allPendingMatchUps = [];
    var allByeMatchUps = [];
    if (contextProfile && !contextContent) {
        contextContent = getContextContent({
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            contextProfile: contextProfile,
            event: event,
        });
    }
    // getParticipants() calls allEventMatchUps()
    // ...so participants must be sourced directly from tournamentRecord
    // ...and groupings must be added independent of that
    var groupInfo;
    if (!(tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.length) && tournamentRecord) {
        tournamentParticipants = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants;
        if ((inContext || (participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.withGroupings)) &&
            (tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.length)) {
            (_a = addParticipantGroupings({
                participants: tournamentParticipants,
                participantsProfile: participantsProfile,
            }), tournamentParticipants = _a.participantsWithGroupings, groupInfo = _a.groupInfo);
        }
    }
    var structures = getDrawStructures({ drawDefinition: drawDefinition }).structures;
    if (!structures)
        return { error: STRUCTURE_NOT_FOUND };
    if (!matchUpsMap) {
        matchUpsMap = getMatchUpsMap({ drawDefinition: drawDefinition });
    }
    // TODO: get QUALIFYING/MAIN { stageSequence: 1 } seedAssignments
    // ...optionally pass these seedAssignments to other stage structures
    var exitProfiles = drawDefinition && getExitProfiles({ drawDefinition: drawDefinition }).exitProfiles;
    structures.forEach(function (structure) {
        var _a = getStructureMatchUps({
            // if nextMatchUps then the filters can't be applied at this level
            matchUpFilters: !nextMatchUps ? matchUpFilters : undefined,
            contextFilters: !nextMatchUps ? contextFilters : undefined,
            inContext: inContext || nextMatchUps || contextFilters,
            tournamentAppliedPolicies: tournamentAppliedPolicies,
            scheduleVisibilityFilters: scheduleVisibilityFilters,
            tournamentParticipants: tournamentParticipants,
            requireParticipants: requireParticipants,
            afterRecoveryTimes: afterRecoveryTimes,
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            usePublishState: usePublishState,
            contextContent: contextContent,
            participantMap: participantMap,
            scheduleTiming: scheduleTiming,
            publishStatus: publishStatus,
            contextProfile: contextProfile,
            drawDefinition: drawDefinition,
            exitProfiles: exitProfiles,
            matchUpsMap: matchUpsMap,
            structure: structure,
            context: context,
            event: event,
        }), _b = _a.byeMatchUps, byeMatchUps = _b === void 0 ? [] : _b, _c = _a.pendingMatchUps, pendingMatchUps = _c === void 0 ? [] : _c, _d = _a.upcomingMatchUps, upcomingMatchUps = _d === void 0 ? [] : _d, _e = _a.completedMatchUps, completedMatchUps = _e === void 0 ? [] : _e, _f = _a.abandonedMatchUps, abandonedMatchUps = _f === void 0 ? [] : _f;
        allAbandonedMatchUps = allAbandonedMatchUps.concat.apply(allAbandonedMatchUps, __spreadArray([], __read(abandonedMatchUps), false));
        allCompletedMatchUps = allCompletedMatchUps.concat.apply(allCompletedMatchUps, __spreadArray([], __read(completedMatchUps), false));
        allUpcomingMatchUps = allUpcomingMatchUps.concat.apply(allUpcomingMatchUps, __spreadArray([], __read(upcomingMatchUps), false));
        allPendingMatchUps = allPendingMatchUps.concat.apply(allPendingMatchUps, __spreadArray([], __read(pendingMatchUps), false));
        allByeMatchUps = allByeMatchUps.concat.apply(allByeMatchUps, __spreadArray([], __read(byeMatchUps), false));
    });
    // only apply this filter if filters haven't already been applied
    var applyFilter = function (matchUps) {
        if (!matchUpFilters && !nextMatchUps && !contextFilters)
            return matchUps;
        if (matchUpFilters) {
            matchUps = filterMatchUps(__assign({ matchUps: matchUps }, matchUpFilters));
        }
        if (contextFilters) {
            matchUps = filterMatchUps(__assign(__assign({ matchUps: matchUps }, contextFilters), { processContext: true }));
        }
        return matchUps;
    };
    var drawMatchUpsResult = __assign(__assign({ abandonedMatchUps: applyFilter(allAbandonedMatchUps), completedMatchUps: applyFilter(allCompletedMatchUps), upcomingMatchUps: applyFilter(allUpcomingMatchUps), pendingMatchUps: applyFilter(allPendingMatchUps), byeMatchUps: applyFilter(allByeMatchUps), matchUpsMap: matchUpsMap }, SUCCESS), { groupInfo: groupInfo });
    if (nextMatchUps) {
        var nextFilter = typeof nextMatchUps === 'object' || {
            abandoned: true,
            completed: true,
            upcoming: true,
            pending: true,
            bye: true,
        };
        var abandoned = nextFilter.abandoned, completed = nextFilter.completed, upcoming = nextFilter.upcoming, pending = nextFilter.pending, bye = nextFilter.bye;
        var matchUps = [].concat.apply([], __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(((abandoned && allAbandonedMatchUps) || [])), false), __read(((completed && allCompletedMatchUps) || [])), false), __read(((upcoming && allUpcomingMatchUps) || [])), false), __read(((pending && allPendingMatchUps) || [])), false), __read(((bye && allByeMatchUps) || [])), false));
        addUpcomingMatchUps({
            inContextDrawMatchUps: matchUps,
            drawDefinition: drawDefinition,
        });
    }
    return drawMatchUpsResult;
}

function allDrawMatchUps(params) {
    var _a, _b;
    var _c, _d;
    var tournamentParticipants = params.participants, participantMap = params.participantMap, contextContent = params.contextContent;
    var scheduleVisibilityFilters = params.scheduleVisibilityFilters, tournamentAppliedPolicies = params.tournamentAppliedPolicies, participantsProfile = params.participantsProfile, afterRecoveryTimes = params.afterRecoveryTimes, policyDefinitions = params.policyDefinitions, useParticipantMap = params.useParticipantMap, tournamentRecord = params.tournamentRecord, contextFilters = params.contextFilters, contextProfile = params.contextProfile, drawDefinition = params.drawDefinition, matchUpFilters = params.matchUpFilters, nextMatchUps = params.nextMatchUps, inContext = params.inContext, context = params.context, event = params.event;
    var _e = event !== null && event !== void 0 ? event : {}, eventId = _e.eventId, eventName = _e.eventName, eventType = _e.eventType, category = _e.category, gender = _e.gender, matchUpFormat = _e.matchUpFormat;
    var additionalContext = __assign(__assign({}, context), { eventId: eventId, eventType: eventType, eventName: eventName, category: category, gender: gender, matchUpFormat: matchUpFormat, indoorOutDoor: (_c = event === null || event === void 0 ? void 0 : event.indoorOutdoor) !== null && _c !== void 0 ? _c : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.indoorOutdoor, surfaceCategory: (_d = event === null || event === void 0 ? void 0 : event.surfaceCategory) !== null && _d !== void 0 ? _d : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.surfaceCategory, endDate: event === null || event === void 0 ? void 0 : event.endDate });
    var groupInfo;
    if (!(tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.length) && !participantMap && tournamentRecord) {
        (_a = hydrateParticipants({
            participantsProfile: participantsProfile,
            useParticipantMap: useParticipantMap,
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            contextProfile: contextProfile,
            inContext: inContext,
        }), _b = _a.participants, tournamentParticipants = _b === void 0 ? [] : _b, participantMap = _a.participantMap, groupInfo = _a.groupInfo);
    }
    if (contextProfile && !contextContent) {
        contextContent = getContextContent({
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            contextProfile: contextProfile,
            drawDefinition: drawDefinition,
            event: event,
        });
    }
    var allDrawMatchUpsResult = getAllDrawMatchUps({
        context: additionalContext,
        tournamentAppliedPolicies: tournamentAppliedPolicies,
        scheduleVisibilityFilters: scheduleVisibilityFilters,
        tournamentParticipants: tournamentParticipants,
        participantsProfile: participantsProfile,
        afterRecoveryTimes: afterRecoveryTimes,
        policyDefinitions: policyDefinitions,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        contextContent: contextContent,
        contextFilters: contextFilters,
        contextProfile: contextProfile,
        matchUpFilters: matchUpFilters,
        participantMap: participantMap,
        nextMatchUps: nextMatchUps,
        inContext: inContext,
        event: event,
    });
    return __assign(__assign({}, allDrawMatchUpsResult), { groupInfo: groupInfo });
}

function getStructureRoundProfile(_a) {
    var drawDefinition = _a.drawDefinition, matchUpsMap = _a.matchUpsMap, structureId = _a.structureId;
    var result = findStructure({
        drawDefinition: drawDefinition,
        structureId: structureId,
    });
    if (result.error)
        return decorateResult({ result: result });
    // DEV-NOTE cannot pass drawDefinition parameter in this scenario; callstack error
    var matchUps = getAllStructureMatchUps({
        structure: result.structure,
        matchUpsMap: matchUpsMap,
    }).matchUps;
    return __assign(__assign({}, getRoundMatchUps({ matchUps: matchUps })), { matchUps: matchUps, matchUpsMap: matchUpsMap });
}

function getFinishingPositionSourceRoundsMap(_a) {
    var finishingPositions = _a.finishingPositions, drawDefinition = _a.drawDefinition, structureId = _a.structureId;
    var roundProfile = getStructureRoundProfile({
        drawDefinition: drawDefinition,
        structureId: structureId,
    }).roundProfile;
    var roundNumbers = roundProfile && Object.keys(roundProfile);
    return roundNumbers === null || roundNumbers === void 0 ? void 0 : roundNumbers.reduce(function (sourceRounds, roundNumber) {
        var rangeDefinitions = roundValues(roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber]);
        rangeDefinitions.forEach(function (rangeDefinition) {
            finishingPositions.forEach(function (position) {
                if (positionIsInRange({ position: position, rangeDefinition: rangeDefinition })) {
                    sourceRounds[position] = { roundNumber: roundNumber };
                }
            });
        });
        return sourceRounds;
    }, {});
}
function positionIsInRange(_a) {
    var position = _a.position, rangeDefinition = _a.rangeDefinition;
    if (!Array.isArray(rangeDefinition))
        return false;
    if (rangeDefinition.reduce(function (includesNonInteger, i) { return includesNonInteger || isNaN(i); }, false))
        return false;
    var _b = __read(rangeDefinition, 2), min = _b[0], max = _b[1];
    var positionsInRange = generateRange(min, (max || min) + 1);
    return positionsInRange.includes(position);
}
// extracts winner and loser rangeDefinitions
function roundValues(values) {
    var _a, _b;
    return [
        unique(((_a = values === null || values === void 0 ? void 0 : values.finishingPositionRange) === null || _a === void 0 ? void 0 : _a.loser) || []),
        unique(((_b = values === null || values === void 0 ? void 0 : values.finishingPositionRange) === null || _b === void 0 ? void 0 : _b.winner) || []),
    ];
}
function roundValueRanges(values) {
    return roundValues(values).map(function (arr) {
        return generateRange(arr[0], (arr[1] && arr[1] + 1) || arr[0] + 1);
    });
}

function getPositionsPlayedOff(_a) {
    var _b;
    var drawDefinition = _a.drawDefinition, structureIds = _a.structureIds, matchUpsMap = _a.matchUpsMap;
    if (structureIds && !Array.isArray(structureIds))
        return { error: INVALID_VALUES, context: { structureIds: structureIds } };
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    structureIds =
        structureIds !== null && structureIds !== void 0 ? structureIds : ((_b = drawDefinition.structures) !== null && _b !== void 0 ? _b : [])
            .filter(function (structure) { return structure.stage !== QUALIFYING; })
            .map(function (_a) {
            var structureId = _a.structureId;
            return structureId;
        });
    var allFinishingPositionRanges = structureIds
        .map(function (structureId) {
        var roundProfile = getStructureRoundProfile({
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
            structureId: structureId,
        }).roundProfile;
        var values = roundProfile && Object.values(roundProfile);
        return values === null || values === void 0 ? void 0 : values.map(roundValueRanges).flat();
    })
        .flat();
    var positionsPlayedOff = allFinishingPositionRanges
        .filter(function (positionRange) { return (positionRange === null || positionRange === void 0 ? void 0 : positionRange.length) === 1; })
        .sort(numericSort)
        .flat();
    var allRangeValues = unique(allFinishingPositionRanges.flat());
    var positionsNotPlayedOff = allRangeValues.filter(function (position) { return !positionsPlayedOff.includes(position); });
    return {
        positionsNotPlayedOff: positionsNotPlayedOff,
        positionsPlayedOff: positionsPlayedOff,
    };
}

function getSourceRounds(_a) {
    var _b = _a.excludeRoundNumbers, excludeRoundNumbers = _b === void 0 ? [] : _b, _c = _a.playoffPositions, playoffPositions = _c === void 0 ? [] : _c, drawDefinition = _a.drawDefinition, structureId = _a.structureId;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structureId)
        return { error: MISSING_STRUCTURE_ID };
    if (!playoffPositions)
        return { error: MISSING_VALUE, info: 'missing playoffPositions' };
    // NOTE: in this instance do not pass in structureIds
    var result = getPositionsPlayedOff({ drawDefinition: drawDefinition });
    if (result.error)
        return result;
    var positionsPlayedOff = result.positionsPlayedOff;
    // filter out playoff positions which are already being played off
    var relevantPlayoffPositions = playoffPositions.filter(function (position) { return !positionsPlayedOff.includes(position); });
    // get a map of which rounds produce which finishingPositions for positions
    // which are relevant, e.g. aren't already playedoff positions in current structure
    var playoffPositionSourceRoundsMap = getFinishingPositionSourceRoundsMap({
        finishingPositions: relevantPlayoffPositions,
        drawDefinition: drawDefinition,
        structureId: structureId,
    });
    // reduce the sourceRoundsMap to roundNumbers, not including excludedRoundNumbers
    var keys = Object.values(playoffPositionSourceRoundsMap);
    var relevantPlayoffSourceRounds = keys
        .reduce(function (rounds, round) {
        return rounds.includes(round.roundNumber) ? rounds : rounds.concat(round.roundNumber);
    }, [])
        .map(function (roundNumber) { return ensureInt(roundNumber); })
        .filter(function (roundNumber) { return !excludeRoundNumbers.includes(roundNumber); });
    // generate a map of finishingPosition: { roundNumber }
    var playedOffRoundsMap = getFinishingPositionSourceRoundsMap({
        finishingPositions: positionsPlayedOff,
        drawDefinition: drawDefinition,
        structureId: structureId,
    });
    // determine which rounds produced played off positions
    var roundsMapValues = playedOffRoundsMap ? Object.values(playedOffRoundsMap) : [];
    var playedOffSourceRounds = playedOffRoundsMap
        ? roundsMapValues
            .reduce(function (rounds, round) {
            return rounds.includes(round.roundNumber) ? rounds : rounds.concat(round.roundNumber);
        }, [])
            .map(function (round) { return ensureInt(round); })
        : [];
    // available playoffSourceRounds are those relevantPlayoffSourceRounds which are not included in playoffSourceRounds
    var playoffSourceRounds = relevantPlayoffSourceRounds
        .filter(function (roundNumber) { return !playedOffSourceRounds.includes(roundNumber); })
        .sort(numericSort);
    var roundProfile = getStructureRoundProfile({
        drawDefinition: drawDefinition,
        structureId: structureId,
    }).roundProfile;
    var playoffPositionsReturned = playoffSourceRounds
        .map(function (round) {
        var rangeDefinition = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[round].finishingPositionRange.loser;
        var _a = __read(rangeDefinition !== null && rangeDefinition !== void 0 ? rangeDefinition : [0, 0], 2), min = _a[0], max = _a[1];
        return generateRange(min, (max || min) + 1);
    })
        .flat()
        .sort(numericSort);
    var playoffRoundsRanges = getPlayoffRoundsRanges({
        playoffSourceRounds: playoffSourceRounds,
        roundProfile: roundProfile,
    }).playoffRoundsRanges;
    var sourceRounds = __spreadArray(__spreadArray([], __read(playoffSourceRounds), false), __read(playedOffSourceRounds), false);
    return {
        playoffPositionsReturned: playoffPositionsReturned,
        playedOffSourceRounds: playedOffSourceRounds,
        playoffRoundsRanges: playoffRoundsRanges,
        playoffSourceRounds: playoffSourceRounds,
        sourceRounds: sourceRounds,
        roundProfile: roundProfile,
    };
}
function getPlayoffRoundsRanges(_a) {
    var playoffSourceRounds = _a.playoffSourceRounds, roundProfile = _a.roundProfile;
    var playoffRoundsRanges = playoffSourceRounds.map(function (roundNumber) {
        var rangeDefinition = roundProfile[roundNumber].finishingPositionRange.loser;
        var _a = __read(rangeDefinition, 2), min = _a[0], max = _a[1];
        var finishingPositions = generateRange(min, (max || min) + 1);
        return {
            finishingPositionRange: rangeDefinition.join('-'),
            finishingPositions: finishingPositions,
            roundNumber: roundNumber,
        };
    });
    return { playoffRoundsRanges: playoffRoundsRanges };
}

function getAvailablePlayoffProfiles(_a) {
    var e_1, _b;
    var drawDefinition = _a.drawDefinition, structureId = _a.structureId;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var _c = allDrawMatchUps({
        inContext: true,
        drawDefinition: drawDefinition,
    }), matchUps = _c.matchUps, matchUpsMap = _c.matchUpsMap;
    // positions which are being played off by existing structure(s)
    var _d = getPositionsPlayedOff({
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
    }), positionsNotPlayedOff = _d.positionsNotPlayedOff, positionsPlayedOff = _d.positionsPlayedOff;
    var structures = getDrawStructures({ drawDefinition: drawDefinition }).structures;
    var filteredStructures = structures.filter(function (structure) { return (!structureId && structure.stage !== VOLUNTARY_CONSOLATION) || structure.structureId === structureId; });
    var available = {};
    try {
        for (var filteredStructures_1 = __values(filteredStructures), filteredStructures_1_1 = filteredStructures_1.next(); !filteredStructures_1_1.done; filteredStructures_1_1 = filteredStructures_1.next()) {
            var structure = filteredStructures_1_1.value;
            var structureId_1 = structure === null || structure === void 0 ? void 0 : structure.structureId;
            var result = availablePlayoffProfiles({
                playoffPositions: positionsNotPlayedOff,
                drawDefinition: drawDefinition,
                structure: structure,
                matchUps: matchUps,
            });
            var error = result.error, values = __rest(result, ["error"]);
            if (error)
                return result;
            available[structureId_1] = __assign({ structureId: structureId_1 }, values);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (filteredStructures_1_1 && !filteredStructures_1_1.done && (_b = filteredStructures_1.return)) _b.call(filteredStructures_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (structureId) {
        return __assign({ positionsPlayedOff: positionsPlayedOff }, available[structureId]);
    }
    else {
        return {
            availablePlayoffProfiles: Object.values(available),
            availablePlayoffRounds: Object.values(available), // to be deprecated
            positionsPlayedOff: positionsPlayedOff,
        };
    }
}
function availablePlayoffProfiles(_a) {
    var e_2, _b;
    var _c, _d, _e, _f, _g, _h, _j, _k, _l;
    var playoffPositions = _a.playoffPositions, drawDefinition = _a.drawDefinition, structure = _a.structure, matchUps = _a.matchUps;
    var structureId = structure === null || structure === void 0 ? void 0 : structure.structureId;
    var links = getStructureLinks({ drawDefinition: drawDefinition, structureId: structureId }).links;
    if (structure.structureType === CONTAINER || structure.structures) {
        var positionsCount = (_d = (_c = getPositionAssignments$1({ structure: structure })) === null || _c === void 0 ? void 0 : _c.positionAssignments) === null || _d === void 0 ? void 0 : _d.length;
        var groupCount = structure.structures.length;
        var groupSize = (positionsCount !== null && positionsCount !== void 0 ? positionsCount : 0) / groupCount;
        var finishingPositionsPlayedOff_1 = ((_e = links.source) === null || _e === void 0 ? void 0 : _e.flatMap(function (_a) {
            var source = _a.source;
            return (source === null || source === void 0 ? void 0 : source.finishingPositions) || [];
        })) || [];
        var finishingPositionsAvailable = generateRange(1, groupSize + 1).filter(function (n) { return !finishingPositionsPlayedOff_1.includes(n); });
        var positionRange = ((_g = (_f = matchUps.find(function (m) { return m.containerStructureId === structureId && m.finishingPositionRange; })) === null || _f === void 0 ? void 0 : _f.finishingPositionRange) === null || _g === void 0 ? void 0 : _g.winner) || [0, 1];
        var targetStructureIds = links === null || links === void 0 ? void 0 : links.source.map(function (_a) {
            var target = _a.target;
            return target.structureId;
        });
        var _m = getPositionsPlayedOff({
            structureIds: targetStructureIds,
            drawDefinition: drawDefinition,
        }), positionsPlayedOff = _m.positionsPlayedOff, positionsNotPlayedOff = _m.positionsNotPlayedOff;
        var positionsInTargetStructures_1 = __spreadArray(__spreadArray([], __read((positionsPlayedOff !== null && positionsPlayedOff !== void 0 ? positionsPlayedOff : [])), false), __read(positionsNotPlayedOff), false);
        var availablePlayoffPositions = generateRange(positionRange[0], positionRange[1] + 1).filter(function (position) { return !positionsInTargetStructures_1.includes(position); });
        var positionChunks_1 = chunkArray(availablePlayoffPositions, availablePlayoffPositions.length / finishingPositionsAvailable.length);
        var playoffFinishingPositionRanges = finishingPositionsAvailable.map(function (finishingPosition, i) {
            var finishingPositions = positionChunks_1[i];
            var finishingPositionRange = [
                Math.min.apply(Math, __spreadArray([], __read((finishingPositions || [])), false)),
                Math.max.apply(Math, __spreadArray([], __read((finishingPositions || [])), false)),
            ].join('-');
            return {
                finishingPosition: finishingPosition,
                finishingPositions: finishingPositions,
                finishingPositionRange: finishingPositionRange,
            };
        });
        return {
            // positionNotPlayefOff cannot include positions not playedOff by existing playoff structures which branch from source ROUND_ROBIN
            // e.g. if finishingPosition: 1 of each RR group already feeds a playoff structure, all the position which feed that structure are
            // not available to be played off from the source ROUND_ROBIN structure.
            positionsNotPlayedOff: availablePlayoffPositions,
            playoffFinishingPositionRanges: playoffFinishingPositionRanges,
            finishingPositionsAvailable: finishingPositionsAvailable,
            finishingPositionsPlayedOff: finishingPositionsPlayedOff_1,
            positionsPlayedOff: positionsPlayedOff,
            groupCount: groupCount,
            groupSize: groupSize,
        };
    }
    var linkSourceRoundNumbers = ((_h = links === null || links === void 0 ? void 0 : links.source) === null || _h === void 0 ? void 0 : _h.filter(function (link) { return link.linkCondition !== FIRST_MATCHUP; }).map(function (link) { var _a; return (_a = link.source) === null || _a === void 0 ? void 0 : _a.roundNumber; })) || [];
    var potentialFirstMatchUpRounds = ((_j = links === null || links === void 0 ? void 0 : links.source) === null || _j === void 0 ? void 0 : _j.filter(function (link) { return link.linkCondition === FIRST_MATCHUP; }).map(function (link) { var _a; return (_a = link.source) === null || _a === void 0 ? void 0 : _a.roundNumber; })) || [];
    var sourceRoundsResult = getSourceRounds({
        excludeRoundNumbers: linkSourceRoundNumbers,
        playoffPositions: playoffPositions,
        drawDefinition: drawDefinition,
        structureId: structureId,
    });
    var playoffRounds = (sourceRoundsResult === null || sourceRoundsResult === void 0 ? void 0 : sourceRoundsResult.playoffSourceRounds)
        ? __spreadArray([], __read(((sourceRoundsResult === null || sourceRoundsResult === void 0 ? void 0 : sourceRoundsResult.playoffSourceRounds) || [])), false) : undefined;
    var playoffRoundsRanges = __spreadArray([], __read(((sourceRoundsResult === null || sourceRoundsResult === void 0 ? void 0 : sourceRoundsResult.playoffRoundsRanges) || [])), false);
    var roundProfile = sourceRoundsResult.roundProfile, error = sourceRoundsResult.error;
    var _loop_1 = function (roundNumber) {
        // sourceRounds will only include roundNumbers in the case of FMLC
        // because it should still be possible to generate 3-4 playoffs even if 2nd round losers lost in the 1st round
        // but 3-4 playoffs should not be possible to generate if there are not at least 2 matchUps where players COULD progress
        var link = links === null || links === void 0 ? void 0 : links.source.find(function (link) { return link.source.roundNumber === roundNumber; });
        var targetRoundNumber = link === null || link === void 0 ? void 0 : link.target.roundNumber;
        var targetStructureId = link === null || link === void 0 ? void 0 : link.target.structureId;
        var targetRoundMatchUps = matchUps.filter(function (_a) {
            var roundNumber = _a.roundNumber, structureId = _a.structureId;
            return structureId === targetStructureId && roundNumber === targetRoundNumber;
        });
        var availableToProgress = targetRoundMatchUps.filter(function (_a) {
            var sides = _a.sides;
            return sides.find(function (side) { return side.participantFed && !side.participantId; });
        }).length;
        if (playoffRounds && availableToProgress === targetRoundMatchUps.length) {
            playoffRounds.push(roundNumber);
            var loser = (_l = (_k = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber]) === null || _k === void 0 ? void 0 : _k.finishingPositionRange) === null || _l === void 0 ? void 0 : _l.loser;
            if (loser) {
                var minFinishingPosition = Math.min.apply(Math, __spreadArray([], __read(loser), false));
                var maxFinishingPosition = minFinishingPosition + availableToProgress;
                var finishingPositions = generateRange(minFinishingPosition, maxFinishingPosition);
                var roundsRange = {
                    finishingPositionRange: [minFinishingPosition, maxFinishingPosition - 1].join('-'),
                    finishingPositions: finishingPositions,
                    roundNumber: roundNumber,
                };
                playoffRoundsRanges.push(roundsRange);
            }
        }
    };
    try {
        for (var potentialFirstMatchUpRounds_1 = __values(potentialFirstMatchUpRounds), potentialFirstMatchUpRounds_1_1 = potentialFirstMatchUpRounds_1.next(); !potentialFirstMatchUpRounds_1_1.done; potentialFirstMatchUpRounds_1_1 = potentialFirstMatchUpRounds_1.next()) {
            var roundNumber = potentialFirstMatchUpRounds_1_1.value;
            _loop_1(roundNumber);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (potentialFirstMatchUpRounds_1_1 && !potentialFirstMatchUpRounds_1_1.done && (_b = potentialFirstMatchUpRounds_1.return)) _b.call(potentialFirstMatchUpRounds_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    if (playoffRounds)
        playoffRounds.sort(numericSort);
    playoffRoundsRanges.sort(function (a, b) { return a.roundNumber - b.roundNumber; });
    return { playoffRounds: playoffRounds, playoffRoundsRanges: playoffRoundsRanges, error: error };
}

function drawUpdatedAt(drawDefinition, structureIds) {
    var _a;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var timeStamp = Date.now();
    if (drawDefinition.updatedAt &&
        timeStamp === new Date(drawDefinition.updatedAt).getTime())
        timeStamp += 1;
    var updatedAt = new Date(timeStamp).toISOString();
    var relevantStructureIds = structureIds === null || structureIds === void 0 ? void 0 : structureIds.filter(Boolean);
    drawDefinition.updatedAt = updatedAt;
    (_a = drawDefinition.structures) === null || _a === void 0 ? void 0 : _a.filter(Boolean).forEach(function (structure) {
        if (!(relevantStructureIds === null || relevantStructureIds === void 0 ? void 0 : relevantStructureIds.length) ||
            (relevantStructureIds === null || relevantStructureIds === void 0 ? void 0 : relevantStructureIds.includes(structure.structureId))) {
            structure.updatedAt = updatedAt;
        }
    });
    return __assign({}, SUCCESS);
}
function addMatchUpsNotice(_a) {
    var drawDefinition = _a.drawDefinition, tournamentId = _a.tournamentId, matchUps = _a.matchUps, eventId = _a.eventId;
    if (drawDefinition)
        drawUpdatedAt(drawDefinition);
    addNotice({
        payload: { matchUps: matchUps, tournamentId: tournamentId, eventId: eventId },
        topic: ADD_MATCHUPS,
    });
    return __assign({}, SUCCESS);
}
function deleteMatchUpsNotice(_a) {
    var e_1, _b;
    var drawDefinition = _a.drawDefinition, tournamentId = _a.tournamentId, matchUpIds = _a.matchUpIds, eventId = _a.eventId, action = _a.action;
    if (drawDefinition)
        drawUpdatedAt(drawDefinition);
    addNotice({
        topic: DELETED_MATCHUP_IDS,
        payload: {
            tournamentId: tournamentId,
            matchUpIds: matchUpIds,
            eventId: eventId,
            action: action,
        },
    });
    try {
        for (var matchUpIds_1 = __values(matchUpIds), matchUpIds_1_1 = matchUpIds_1.next(); !matchUpIds_1_1.done; matchUpIds_1_1 = matchUpIds_1.next()) {
            var matchUpId = matchUpIds_1_1.value;
            deleteNotice({ key: matchUpId });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (matchUpIds_1_1 && !matchUpIds_1_1.done && (_b = matchUpIds_1.return)) _b.call(matchUpIds_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}
function modifyMatchUpNotice(_a) {
    var drawDefinition = _a.drawDefinition, tournamentId = _a.tournamentId, structureId = _a.structureId, context = _a.context, eventId = _a.eventId, matchUp = _a.matchUp;
    if (!matchUp) {
        console.log(MISSING_MATCHUP);
        return { error: MISSING_MATCHUP };
    }
    if (drawDefinition) {
        var structureIds = structureId ? [structureId] : undefined;
        modifyDrawNotice({
            drawDefinition: drawDefinition,
            structureIds: structureIds,
            tournamentId: tournamentId,
            eventId: eventId,
        });
    }
    addNotice({
        topic: MODIFY_MATCHUP,
        payload: { matchUp: matchUp, tournamentId: tournamentId, context: context },
        key: matchUp.matchUpId,
    });
    return __assign({}, SUCCESS);
}
function updateInContextMatchUp(_a) {
    var tournamentId = _a.tournamentId, inContextMatchUp = _a.inContextMatchUp;
    if (!inContextMatchUp) {
        return { error: MISSING_MATCHUP };
    }
    addNotice({
        payload: { inContextMatchUp: inContextMatchUp, tournamentId: tournamentId },
        topic: UPDATE_INCONTEXT_MATCHUP,
        key: inContextMatchUp.matchUpId,
    });
    return __assign({}, SUCCESS);
}
function addDrawNotice(_a) {
    var tournamentId = _a.tournamentId, eventId = _a.eventId, drawDefinition = _a.drawDefinition;
    if (!drawDefinition) {
        console.log(MISSING_DRAW_DEFINITION);
        return { error: MISSING_DRAW_DEFINITION };
    }
    drawUpdatedAt(drawDefinition);
    addNotice({
        payload: { drawDefinition: drawDefinition, tournamentId: tournamentId, eventId: eventId },
        topic: ADD_DRAW_DEFINITION,
        key: drawDefinition.drawId,
    });
    return __assign({}, SUCCESS);
}
function deleteDrawNotice(_a) {
    var tournamentId = _a.tournamentId, eventId = _a.eventId, drawId = _a.drawId;
    addNotice({
        payload: { drawId: drawId, tournamentId: tournamentId, eventId: eventId },
        topic: DELETED_DRAW_IDS,
        key: drawId,
    });
    deleteNotice({ key: drawId });
    return __assign({}, SUCCESS);
}
function modifyDrawNotice(_a) {
    var drawDefinition = _a.drawDefinition, tournamentId = _a.tournamentId, structureIds = _a.structureIds, eventId = _a.eventId;
    if (!drawDefinition) {
        return { error: MISSING_DRAW_DEFINITION };
    }
    drawUpdatedAt(drawDefinition, structureIds);
    addNotice({
        payload: { tournamentId: tournamentId, eventId: eventId, drawDefinition: drawDefinition },
        topic: MODIFY_DRAW_DEFINITION,
        key: drawDefinition.drawId,
    });
    return __assign({}, SUCCESS);
}
function modifySeedAssignmentsNotice(_a) {
    var drawDefinition = _a.drawDefinition, tournamentId = _a.tournamentId, structure = _a.structure, eventId = _a.eventId;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structure)
        return { error: MISSING_STRUCTURE };
    var seedAssignments = structure.seedAssignments;
    var structureId = structure.structureId;
    var drawId = drawDefinition.drawId;
    addNotice({
        payload: { tournamentId: tournamentId, eventId: eventId, drawId: drawId, structureId: structureId, seedAssignments: seedAssignments },
        topic: MODIFY_SEED_ASSIGNMENTS,
        key: drawDefinition.drawId,
    });
    modifyDrawNotice({
        structureIds: [structureId],
        drawDefinition: drawDefinition,
        tournamentId: tournamentId,
        eventId: eventId,
    });
    return __assign({}, SUCCESS);
}
function modifyPositionAssignmentsNotice(_a) {
    var drawDefinition = _a.drawDefinition, tournamentId = _a.tournamentId, structure = _a.structure, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structure)
        return { error: MISSING_STRUCTURE };
    var positionAssignments = getPositionAssignments$1({ structure: structure });
    var structureId = structure.structureId;
    var drawId = drawDefinition.drawId;
    var eventId = event === null || event === void 0 ? void 0 : event.eventId;
    addNotice({
        topic: MODIFY_POSITION_ASSIGNMENTS,
        payload: {
            positionAssignments: positionAssignments,
            tournamentId: tournamentId,
            structureId: structureId,
            eventId: eventId,
            drawId: drawId,
        },
        key: structureId,
    });
    modifyDrawNotice({
        structureIds: [structureId],
        drawDefinition: drawDefinition,
        tournamentId: tournamentId,
        eventId: eventId,
    });
    return __assign({}, SUCCESS);
}

function resetVoluntaryConsolationStructure(_a) {
    var _b, _c;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, resetEntries = _a.resetEntries, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var structure = (_b = drawDefinition.structures) === null || _b === void 0 ? void 0 : _b.find(function (structure) { return structure.stage === VOLUNTARY_CONSOLATION; });
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    var removedMatchUpIds = ((_c = structure.matchUps) === null || _c === void 0 ? void 0 : _c.map(function (_a) {
        var matchUpId = _a.matchUpId;
        return matchUpId;
    })) || [];
    structure.positionAssignments = [];
    structure.seedAssignments = [];
    structure.matchUps = [];
    deleteMatchUpsNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        action: 'resetVoluntaryConsolationStructure',
        matchUpIds: removedMatchUpIds,
        drawDefinition: drawDefinition,
    });
    // TODO: add modifyPositionAssignmentsNotice, modifySeedAssignmentsNotice
    if (resetEntries) {
        drawDefinition.entries = drawDefinition.entries.filter(function (entry) { return entry.entryStage !== VOLUNTARY_CONSOLATION; });
    }
    modifyDrawNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        eventId: event === null || event === void 0 ? void 0 : event.eventId,
        drawDefinition: drawDefinition,
        structureIds: [structure.structureId],
    });
    return __assign({}, SUCCESS);
}

function conditionallyDisableLinkPositioning(_a) {
    var drawPositions = _a.drawPositions, structure = _a.structure;
    if ([QUALIFYING, MAIN].includes(structure.stage) &&
        structure.stageSequence === 1) {
        // positionActions are not disabled for first stage QUALIFYING and MAIN structures
        return;
    }
    var positionAssignments = getPositionAssignments$1({ structure: structure }).positionAssignments;
    var relevantAssignments = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (_a) {
        var drawPosition = _a.drawPosition;
        return drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(drawPosition);
    });
    relevantAssignments === null || relevantAssignments === void 0 ? void 0 : relevantAssignments.forEach(function (assignment) {
        var extension = {
            name: DISABLE_LINKS,
            value: true,
        };
        addExtension({ element: assignment, extension: extension });
    });
}
// NOTE: NOT READY TO USE.
// Would only be possible to remove disabling extension if the position is unassigned..
// ...AND the source position has not yet attempted participant traversal
/*
export function reEnableDrawPositionLinks({ drawPosition, structure }) {
  const { positionAssignments } = getPositionAssignments({ structure });
  const assignment = positionAssignments.find(
    (assignment) => assignment.drawPosition === drawPosition
  );

  const { participantId, bye, qualifier } = assignment || {};
  if (!participantId && !bye && !qualifier) {
    removeExtension({ element: assignment, name: DISABLE_LINKS });
  }
}
*/

// updates 'positionActions' extension to keep track of positionActions by end-user
// TODO: consider adding timestamp attribute to positionAction object
function addPositionActionTelemetry(_a) {
    var _b, _c;
    var drawDefinition = _a.drawDefinition, positionAction = _a.positionAction;
    var extension = findExtension({
        name: AUDIT_POSITION_ACTIONS,
        element: drawDefinition,
    }).extension;
    var existingValue = Array.isArray(extension === null || extension === void 0 ? void 0 : extension.value)
        ? (_b = extension === null || extension === void 0 ? void 0 : extension.value) !== null && _b !== void 0 ? _b : []
        : [];
    if (!(existingValue === null || existingValue === void 0 ? void 0 : existingValue.length)) {
        var mainStructure = drawDefinition.structures.find(function (structure) { return structure.stage === MAIN; });
        if (mainStructure) {
            var initialAssignments = (_c = getPositionAssignments$1({
                structure: mainStructure,
            }).positionAssignments) === null || _c === void 0 ? void 0 : _c.map(function (_a) {
                var drawPosition = _a.drawPosition, participantId = _a.participantId, bye = _a.bye, qualifier = _a.qualifier;
                return ({
                    drawPosition: drawPosition,
                    participantId: participantId,
                    qualifier: qualifier,
                    bye: bye,
                });
            });
            existingValue.push({
                name: 'initialMainAssignments',
                initialAssignments: initialAssignments,
            });
        }
    }
    var updatedExtension = {
        name: AUDIT_POSITION_ACTIONS,
        value: existingValue.concat(positionAction),
    };
    addExtension({ element: drawDefinition, extension: updatedExtension });
}

function getContainedStructures(_a) {
    var e_1, _b;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, event = _a.event;
    var events = (tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.events) || (event && [event]);
    var drawDefinitions = (events === null || events === void 0 ? void 0 : events.map(function (event) { return event === null || event === void 0 ? void 0 : event.drawDefinitions; }).flat().filter(Boolean)) ||
        (drawDefinition && [drawDefinition]) ||
        [];
    var containedStructures = {};
    var containerStructures = {};
    var structureContainers = drawDefinitions
        .map(function (dd) { var _a; return (_a = dd === null || dd === void 0 ? void 0 : dd.structures) === null || _a === void 0 ? void 0 : _a.filter(function (structure) { return structure === null || structure === void 0 ? void 0 : structure.structures; }); })
        .flat()
        .filter(Boolean);
    var _loop_1 = function (structureContainer) {
        var _c = structureContainer !== null && structureContainer !== void 0 ? structureContainer : {}, structures = _c.structures, structureId = _c.structureId;
        structures &&
            structureId &&
            (containedStructures[structureId] = structures === null || structures === void 0 ? void 0 : structures.map(function (structure) { return structure.structureId; })) &&
            structures.forEach(function (structure) {
                return (containerStructures[structure.structureId] =
                    structureContainer === null || structureContainer === void 0 ? void 0 : structureContainer.structureId);
            });
    };
    try {
        for (var structureContainers_1 = __values(structureContainers), structureContainers_1_1 = structureContainers_1.next(); !structureContainers_1_1.done; structureContainers_1_1 = structureContainers_1.next()) {
            var structureContainer = structureContainers_1_1.value;
            _loop_1(structureContainer);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (structureContainers_1_1 && !structureContainers_1_1.done && (_b = structureContainers_1.return)) _b.call(structureContainers_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { containedStructures: containedStructures, containerStructures: containerStructures };
}

function checkScoreHasValue(params) {
    var _a, _b;
    var matchUp = params === null || params === void 0 ? void 0 : params.matchUp;
    var score = (params === null || params === void 0 ? void 0 : params.score) || (matchUp === null || matchUp === void 0 ? void 0 : matchUp.score);
    var firstSet = (_a = score === null || score === void 0 ? void 0 : score.sets) === null || _a === void 0 ? void 0 : _a[0];
    var _c = firstSet || {}, side1Score = _c.side1Score, side2Score = _c.side2Score, side1TiebreakScore = _c.side1TiebreakScore, side2TiebreakScore = _c.side2TiebreakScore, side1PointScore = _c.side1PointScore, side2PointScore = _c.side2PointScore;
    var firstSetScore = side1Score ||
        side2Score ||
        side1TiebreakScore ||
        side2TiebreakScore ||
        side1PointScore ||
        side2PointScore;
    var hasValue = ((_b = score === null || score === void 0 ? void 0 : score.sets) === null || _b === void 0 ? void 0 : _b.length) > 1 || firstSetScore;
    return !!hasValue;
}

function isDirectingMatchUpStatus(_a) {
    var matchUpStatus = _a.matchUpStatus;
    return directingMatchUpStatuses.includes(matchUpStatus);
}
function isActiveMatchUpStatus(_a) {
    var matchUpStatus = _a.matchUpStatus;
    return activeMatchUpStatuses.includes(matchUpStatus);
}
function isNonDirectingMatchUpStatus(_a) {
    var matchUpStatus = _a.matchUpStatus;
    return nonDirectingMatchUpStatuses.includes(matchUpStatus);
}

function isActiveMatchUp(_a) {
    var _b;
    var matchUpStatus = _a.matchUpStatus, winningSide = _a.winningSide, tieMatchUps = _a.tieMatchUps, sides = _a.sides, score = _a.score;
    var participantAssigned = sides === null || sides === void 0 ? void 0 : sides.find(function (_a) {
        var participantId = _a.participantId;
        return participantId;
    });
    var activeTieMatchUps = (_b = tieMatchUps === null || tieMatchUps === void 0 ? void 0 : tieMatchUps.filter(isActiveMatchUp)) === null || _b === void 0 ? void 0 : _b.length;
    var scoreExists = checkScoreHasValue({ score: score });
    return (scoreExists ||
        activeTieMatchUps ||
        (winningSide && participantAssigned) || // if winningSide and no participant assigned => "produced" WALKOVER
        // must exclude IN_PROGRESS as this is automatically set by updateTieMatchUpScore
        // must exclude WALKOVER and DEFAULTED as "produced" scenarios do not imply a winningSide
        (matchUpStatus &&
            isActiveMatchUpStatus({ matchUpStatus: matchUpStatus }) &&
            ![DEFAULTED, WALKOVER$2, IN_PROGRESS$1].includes(matchUpStatus)));
}

function getIndividualParticipantIds(matchUp) {
    var _a;
    var _b = matchUp || {}, sides = _b.sides, matchUpType = _b.matchUpType;
    var potentialIndividualParticipantIds = ((_a = matchUp.potentialParticipants) === null || _a === void 0 ? void 0 : _a.length)
        ? matchUp.potentialParticipants
            .flat()
            .map(function (participant) {
            return matchUpType === DOUBLES
                ? (participant === null || participant === void 0 ? void 0 : participant.individualParticipantIds) || []
                : participant.participantId;
        })
            .flat()
        : [];
    var enteredIndividualParticipantIds = (sides || [])
        .map(function (side) {
        var _a;
        return ((matchUpType === DOUBLES &&
            (((_a = side === null || side === void 0 ? void 0 : side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipantIds) || [])) ||
            ((side === null || side === void 0 ? void 0 : side.participantId) && [side.participantId]) ||
            []);
    })
        .flat();
    var individualParticipantIds = enteredIndividualParticipantIds
        .concat(potentialIndividualParticipantIds)
        .flat();
    return {
        individualParticipantIds: individualParticipantIds,
        enteredIndividualParticipantIds: enteredIndividualParticipantIds,
        potentialIndividualParticipantIds: potentialIndividualParticipantIds,
    };
}

function addFinishingRounds(_a) {
    var _b;
    var _c = _a.finishingPositionOffset, finishingPositionOffset = _c === void 0 ? 0 : _c, finishingPositionLimit = _a.finishingPositionLimit, positionsFed = _a.positionsFed, roundsCount = _a.roundsCount, roundLimit = _a.roundLimit, matchUps = _a.matchUps, lucky = _a.lucky, fmlc = _a.fmlc;
    if (!validMatchUps(matchUps))
        return [];
    var _d = getRoundMatchUps({
        interpolate: true, // for structures which do not contain a final round of one matchUps (structure winner)
        matchUps: matchUps,
    }), roundProfile = _d.roundProfile, _e = _d.roundNumbers, roundNumbers = _e === void 0 ? [] : _e;
    roundsCount = roundsCount !== null && roundsCount !== void 0 ? roundsCount : Math.max.apply(Math, __spreadArray(__spreadArray([], __read(roundNumbers), false), [0], false));
    // for qualifying, offset the final round so that qualifyinground is finishingRound
    var finishingRoundOffset = roundLimit ? roundsCount - roundLimit : 0;
    // for QUALIFYING draws the best finishingPosition is equal to the number of matchUps in the final round of the structure
    var minQualifyingPosition = finishingRoundOffset && ((_b = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundsCount - finishingRoundOffset]) === null || _b === void 0 ? void 0 : _b.matchUpsCount);
    var roundMatchUpsCountArray = roundProfile && Object.values(roundProfile).map(xa('matchUpsCount'));
    // returns a range for array of possible finishing drawPositions
    var finishingRange = function (positionRange, winner) {
        var minFinishingPosition = Math.min.apply(Math, __spreadArray([], __read(positionRange), false));
        // only modify for qualifying when the minFinishingPosition is 1
        // and when the finishingRange is being calculated for a matchUp winner
        if (minQualifyingPosition && winner && minFinishingPosition === 1) {
            minFinishingPosition = minQualifyingPosition;
        }
        var maxFinishingPosition = Math.max.apply(Math, __spreadArray([], __read(positionRange), false));
        if (finishingPositionLimit && maxFinishingPosition > finishingPositionLimit)
            maxFinishingPosition = finishingPositionLimit;
        return [minFinishingPosition, maxFinishingPosition];
    };
    var roundFinishingData = roundProfile && Object.assign.apply(Object, __spreadArray([{}], __read(roundNumbers.map(function (roundNumber) {
        var _a;
        var finishingRound = (roundsCount !== null && roundsCount !== void 0 ? roundsCount : 0) + 1 - roundNumber - finishingRoundOffset;
        var matchUpsCount = roundProfile[roundNumber].matchUpsCount;
        var finishingData = {
            finishingPositionRange: {},
            finishingRound: finishingRound,
        };
        var upcomingMatchUps = roundMatchUpsCountArray === null || roundMatchUpsCountArray === void 0 ? void 0 : roundMatchUpsCountArray.slice(roundNumber - 1).reduce(function (a, b) { return a + (b || 0); }, 0);
        // in the case of FMLC the finishingPositionRange in consolation is not modified after first fed round
        var fmlcException = fmlc && roundNumber !== 1;
        var rangeOffset = 1 + finishingPositionOffset + (fmlcException ? positionsFed !== null && positionsFed !== void 0 ? positionsFed : 0 : 0);
        var finalPosition = 1;
        var positionRange = generateRange(rangeOffset, lucky ? rangeOffset + matchUpsCount * 2 : upcomingMatchUps + rangeOffset + finalPosition);
        var slicer = upcomingMatchUps + finalPosition - matchUpsCount;
        var loser = finishingRange(positionRange.slice(slicer));
        var winner = finishingRange(positionRange.slice(0, slicer), true);
        finishingData.finishingPositionRange = { loser: loser, winner: winner };
        return _a = {}, _a[roundNumber] = finishingData, _a;
    })), false));
    var devContext = getDevContext({ finishingRound: true });
    matchUps.filter(Boolean).forEach(function (matchUp) {
        var roundData = matchUp.roundNumber && roundFinishingData[matchUp.roundNumber];
        if (devContext && !roundData)
            console.log({ roundFinishingData: roundFinishingData, matchUp: matchUp });
        matchUp.finishingRound = roundData === null || roundData === void 0 ? void 0 : roundData.finishingRound;
        matchUp.finishingPositionRange = roundData === null || roundData === void 0 ? void 0 : roundData.finishingPositionRange;
    });
    return matchUps;
}

function addGoesTo(_a) {
    var _b;
    var _c, _d;
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, drawDefinition = _a.drawDefinition, matchUpsMap = _a.matchUpsMap;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var goesToMap = { loserMatchUpIds: {}, winnerMatchUpIds: {} };
    if (!inContextDrawMatchUps) {
        (_b = getAllDrawMatchUps({
            inContext: true,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
        }), inContextDrawMatchUps = _b.matchUps, matchUpsMap = _b.matchUpsMap);
    }
    var hasFinishingPositionRanges = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.drawMatchUps.some(function (m) { return m.finishingPositionRange; });
    // NOTE: handles drawDefinitions in TODS files not generated by the factory
    // IF: there is only one structure present... as is the case with tods-xls-converter
    // TODO: make a more sophisticated version which can use .links to addFinishingRounds for all structures
    if (!hasFinishingPositionRanges &&
        ((_c = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) === null || _c === void 0 ? void 0 : _c.length) === 1 &&
        !(drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures[0].structures)) {
        var matchUps = (_d = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.drawMatchUps) !== null && _d !== void 0 ? _d : [];
        addFinishingRounds({ matchUps: matchUps });
    }
    (inContextDrawMatchUps !== null && inContextDrawMatchUps !== void 0 ? inContextDrawMatchUps : [])
        .filter(function (_a) {
        var collectionId = _a.collectionId;
        return !collectionId;
    })
        .forEach(function (inContextMatchUp) {
        var matchUpId = inContextMatchUp.matchUpId, structureId = inContextMatchUp.structureId;
        var targetData = positionTargets({
            inContextDrawMatchUps: inContextDrawMatchUps,
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
        });
        var _a = targetData.targetMatchUps, winnerMatchUp = _a.winnerMatchUp, loserMatchUp = _a.loserMatchUp;
        var winnerMatchUpId = winnerMatchUp === null || winnerMatchUp === void 0 ? void 0 : winnerMatchUp.matchUpId;
        var loserMatchUpId = loserMatchUp === null || loserMatchUp === void 0 ? void 0 : loserMatchUp.matchUpId;
        var matchUps = getMappedStructureMatchUps({
            matchUpsMap: matchUpsMap,
            structureId: structureId,
        });
        var matchUp = matchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
        if (matchUp) {
            if (winnerMatchUpId) {
                goesToMap.winnerMatchUpIds[matchUp.matchUpId] = winnerMatchUpId;
                Object.assign(matchUp, { winnerMatchUpId: winnerMatchUpId });
                Object.assign(inContextMatchUp, { winnerMatchUpId: winnerMatchUpId });
            }
            if (loserMatchUpId) {
                goesToMap.loserMatchUpIds[matchUp.matchUpId] = loserMatchUpId;
                inContextMatchUp.loserMatchUpId = loserMatchUpId;
                matchUp.loserMatchUpId = loserMatchUpId;
                if (inContextMatchUp.finishingPositionRange) {
                    var loserRange = loserMatchUp.finishingPositionRange && __spreadArray(__spreadArray([], __read(inContextMatchUp.finishingPositionRange.loser), false), __read(loserMatchUp.finishingPositionRange.loser), false);
                    var loser = loserRange && [
                        Math.min.apply(Math, __spreadArray([], __read(loserRange), false)),
                        Math.max.apply(Math, __spreadArray([], __read(loserRange), false)),
                    ];
                    inContextMatchUp.finishingPositionRange.loser = loser;
                    matchUp.finishingPositionRange.loser = loser;
                }
            }
        }
    });
    return { inContextDrawMatchUps: inContextDrawMatchUps, goesToMap: goesToMap };
}

function allEventMatchUps(params) {
    var _a, _b, _c, _d, _e;
    var _f = params.participants, participants = _f === void 0 ? [] : _f, contextContent = params.contextContent, participantMap = params.participantMap;
    var scheduleVisibilityFilters = params.scheduleVisibilityFilters, tournamentAppliedPolicies = params.tournamentAppliedPolicies, participantsProfile = params.participantsProfile, afterRecoveryTimes = params.afterRecoveryTimes, policyDefinitions = params.policyDefinitions, useParticipantMap = params.useParticipantMap, tournamentRecord = params.tournamentRecord, contextFilters = params.contextFilters, contextProfile = params.contextProfile, matchUpFilters = params.matchUpFilters, nextMatchUps = params.nextMatchUps, inContext = params.inContext, context = params.context, event = params.event;
    if (!event)
        return { error: MISSING_EVENT };
    var eventId = event.eventId, eventName = event.eventName, endDate = event.endDate, category = event.category, gender = event.gender, matchUpFormat = event.matchUpFormat;
    var additionalContext = __assign(__assign({}, context), definedAttributes({
        indoorOutDoor: (_a = event.indoorOutdoor) !== null && _a !== void 0 ? _a : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.indoorOutdoor,
        surfaceCategory: (_b = event.surfaceCategory) !== null && _b !== void 0 ? _b : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.surfaceCategory,
        endDate: (_c = event.endDate) !== null && _c !== void 0 ? _c : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.endDate,
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        matchUpFormat: matchUpFormat,
        eventName: eventName,
        category: category,
        gender: gender,
        eventId: eventId,
    }));
    if (endDate)
        additionalContext.endDate = endDate;
    if (contextProfile && !contextContent) {
        contextContent = getContextContent({
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            contextProfile: contextProfile,
            event: event,
        });
    }
    var groupInfo;
    if (!(participants === null || participants === void 0 ? void 0 : participants.length) && !participantMap && tournamentRecord) {
        var hydratedParticipantResult = hydrateParticipants({
            participantsProfile: participantsProfile,
            useParticipantMap: useParticipantMap,
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            contextProfile: contextProfile,
            inContext: inContext,
        });
        participantMap = hydratedParticipantResult.participantMap;
        participants = (_d = hydratedParticipantResult.participants) !== null && _d !== void 0 ? _d : [];
        groupInfo = hydratedParticipantResult.groupInfo;
    }
    var drawDefinitions = (_e = event.drawDefinitions) !== null && _e !== void 0 ? _e : [];
    var scheduleTiming = getScheduleTiming({
        tournamentRecord: tournamentRecord,
        event: event,
    }).scheduleTiming;
    var matchUps = drawDefinitions.flatMap(function (drawDefinition) {
        var matchUps = getAllDrawMatchUps({
            tournamentParticipants: participants,
            tournamentAppliedPolicies: tournamentAppliedPolicies,
            scheduleVisibilityFilters: scheduleVisibilityFilters,
            context: additionalContext,
            participantsProfile: participantsProfile,
            afterRecoveryTimes: afterRecoveryTimes,
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            contextFilters: contextFilters,
            contextProfile: contextProfile,
            drawDefinition: drawDefinition,
            contextContent: contextContent,
            matchUpFilters: matchUpFilters,
            participantMap: participantMap,
            scheduleTiming: scheduleTiming,
            nextMatchUps: nextMatchUps,
            inContext: inContext,
            event: event,
        }).matchUps;
        return matchUps !== null && matchUps !== void 0 ? matchUps : [];
    });
    return { matchUps: matchUps, groupInfo: groupInfo };
}

function allTournamentMatchUps(params) {
    var _a, _b;
    var _c, _d, _e;
    if (!(params === null || params === void 0 ? void 0 : params.tournamentRecord))
        return { error: MISSING_TOURNAMENT_RECORD };
    var participantMap = params.participantMap, participants = params.participants;
    var scheduleVisibilityFilters = params.scheduleVisibilityFilters, participantsProfile = params.participantsProfile, afterRecoveryTimes = params.afterRecoveryTimes, useParticipantMap = params.useParticipantMap, // will default to true in future release
    policyDefinitions = params.policyDefinitions, tournamentRecord = params.tournamentRecord, _f = params.inContext, inContext = _f === void 0 ? true : _f, contextProfile = params.contextProfile, matchUpFilters = params.matchUpFilters, contextFilters = params.contextFilters, nextMatchUps = params.nextMatchUps, context = params.context;
    var tournamentId = (_c = params.tournamentId) !== null && _c !== void 0 ? _c : tournamentRecord.tournamentId;
    var events = (_d = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.events) !== null && _d !== void 0 ? _d : [];
    if (!participants) {
        (_a = hydrateParticipants({
            participantsProfile: participantsProfile,
            useParticipantMap: useParticipantMap,
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            contextProfile: contextProfile,
            inContext: inContext,
        }), participants = _a.participants, participantMap = _a.participantMap);
    }
    var tournamentAppliedPolicies = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
    }).appliedPolicies;
    var additionalContext = __assign(__assign({}, context), { tournamentId: tournamentId, indoorOutDoor: tournamentRecord.indoorOutdoor, surfaceCategory: tournamentRecord.surfaceCategory, endDate: tournamentRecord.endDate });
    var contextContent = getContextContent({
        policyDefinitions: policyDefinitions,
        tournamentRecord: tournamentRecord,
        contextProfile: contextProfile,
    });
    var matchUps = (_b = events
        .flatMap(function (event) {
        var _a, _b, _c;
        additionalContext.eventDrawsCount = (_b = (_a = event.drawDefinitions) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        return ((_c = allEventMatchUps({
            context: additionalContext,
            scheduleVisibilityFilters: scheduleVisibilityFilters,
            tournamentAppliedPolicies: tournamentAppliedPolicies,
            participantsProfile: participantsProfile,
            afterRecoveryTimes: afterRecoveryTimes,
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            contextContent: contextContent,
            contextFilters: contextFilters,
            contextProfile: contextProfile,
            matchUpFilters: matchUpFilters,
            participantMap: participantMap,
            nextMatchUps: nextMatchUps,
            participants: participants,
            inContext: inContext,
            event: event,
        }).matchUps) !== null && _c !== void 0 ? _c : []);
    }))
        .concat.apply(_b, __spreadArray([], __read(((_e = tournamentRecord.matchUps) !== null && _e !== void 0 ? _e : [])), false));
    return { matchUps: matchUps };
}

function allCompetitionMatchUps(_a) {
    var scheduleVisibilityFilters = _a.scheduleVisibilityFilters, afterRecoveryTimes = _a.afterRecoveryTimes, participantsProfile = _a.participantsProfile, tournamentRecords = _a.tournamentRecords, policyDefinitions = _a.policyDefinitions, matchUpFilters = _a.matchUpFilters, contextFilters = _a.contextFilters, nextMatchUps = _a.nextMatchUps, inContext = _a.inContext;
    if (typeof tournamentRecords !== 'object' || !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var tournamentIds = Object.keys(tournamentRecords);
    var competitionMatchUps = tournamentIds
        .map(function (tournamentId) {
        var _a;
        var tournamentRecord = tournamentRecords[tournamentId];
        return ((_a = allTournamentMatchUps({
            scheduleVisibilityFilters: scheduleVisibilityFilters,
            afterRecoveryTimes: afterRecoveryTimes,
            participantsProfile: participantsProfile,
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            matchUpFilters: matchUpFilters,
            contextFilters: contextFilters,
            nextMatchUps: nextMatchUps,
            inContext: inContext,
        }).matchUps) !== null && _a !== void 0 ? _a : []);
    })
        .flat();
    return { matchUps: competitionMatchUps };
}

/**
 * Sorting function to arrange matchUps by stage, stageSequence, roundNumber, roundPosition (where applicable)
 * - Useful for automatically scoring all matchUps in connected draw structures
 * - Useful for visualizing the progression of drawPositions through rounds
 *
 * @param {object} a - matchUp object
 * @param {object} b - matchUp object
 *
 */
function matchUpSort(a, b) {
    var _a, _b;
    return (stageDifference(a, b) ||
        ((a === null || a === void 0 ? void 0 : a.stageSequence) || 0) - ((b === null || b === void 0 ? void 0 : b.stageSequence) || 0) ||
        ((a === null || a === void 0 ? void 0 : a.roundNumber) && b.roundNumber && (a === null || a === void 0 ? void 0 : a.roundNumber) - (b === null || b === void 0 ? void 0 : b.roundNumber)) ||
        ((_a = a === null || a === void 0 ? void 0 : a.roundPosition) !== null && _a !== void 0 ? _a : 0) - ((_b = b === null || b === void 0 ? void 0 : b.roundPosition) !== null && _b !== void 0 ? _b : 0));
}
function stageDifference(a, b) {
    return (stageOrder$1[a === null || a === void 0 ? void 0 : a.stage] || 0) - (stageOrder$1[b === null || b === void 0 ? void 0 : b.stage] || 0);
}

/**
 * Builds up an exhaustive map of all matchUpIds on which a matchUpId is depdendent
 * Optionally builds up an exhaustive map of all potential participantIds for each matchUpId
 */
function getMatchUpDependencies(params) {
    var _a, e_1, _b, e_2, _c, e_3, _d;
    var _e, _f, _g;
    var tournamentRecords = resolveTournamentRecords(params);
    var targetMatchUps = (_e = params.matchUps) !== null && _e !== void 0 ? _e : []; // requires matchUps { inContext: true }
    var drawIds = (_f = params.drawIds) !== null && _f !== void 0 ? _f : [];
    var includeParticipantDependencies = params.includeParticipantDependencies, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition;
    if (!Array.isArray(targetMatchUps))
        return { error: MISSING_MATCHUPS };
    if (!Array.isArray(drawIds))
        return { error: MISSING_DRAW_ID };
    var matchUpIds = ((_g = params.matchUpIds) === null || _g === void 0 ? void 0 : _g.length)
        ? params.matchUpIds
        : targetMatchUps.map(function (matchUp) { return matchUp.matchUpId; });
    if (!Array.isArray(matchUpIds))
        return { error: MISSING_MATCHUP_IDS };
    var positionDependencies = {};
    var matchUpDependencies = {};
    var sourceStructureIdMap = {};
    var sourceMatchUpIds = {};
    if (tournamentRecord && !Object.keys(tournamentRecords).length)
        tournamentRecords = (_a = {}, _a[tournamentRecord.tournamentId] = tournamentRecord, _a);
    var allTournamentRecords = Object.values(tournamentRecords);
    var allLinks = allTournamentRecords.reduce(function (allLinks, tournamentRecord) {
        var _a;
        return allLinks
            .concat((_a = tournamentRecord.events) !== null && _a !== void 0 ? _a : [])
            .map(function (event) {
            return (event.drawDefinitions || []).map(function (drawDefinition) { return drawDefinition.links || []; });
        })
            .flat(Infinity);
    }, []);
    var positionLinks = allLinks.filter(function (_a) {
        var linkType = _a.linkType;
        return linkType === POSITION;
    });
    var matchUps = targetMatchUps;
    if (positionLinks.length) {
        matchUps = allCompetitionMatchUps({
            nextMatchUps: true,
            tournamentRecords: tournamentRecords,
        }).matchUps;
        // sourceStructureIdMap returns the sourceStructureId for a given targetStructureId
        var sourceStructureIds = positionLinks.reduce(function (structureIds, link) {
            var _a, _b;
            var sourceStructureId = (_a = link.source) === null || _a === void 0 ? void 0 : _a.structureId;
            var targetStructureId = (_b = link.target) === null || _b === void 0 ? void 0 : _b.structureId;
            if (sourceStructureId && targetStructureId)
                sourceStructureIdMap[targetStructureId] = sourceStructureId;
            if (sourceStructureId && !structureIds.includes(sourceStructureId))
                structureIds.push(sourceStructureId);
            return structureIds;
        }, []);
        try {
            // positionDependencies map a sourceStructureId to the matchUpIds which it contains
            for (var sourceStructureIds_1 = __values(sourceStructureIds), sourceStructureIds_1_1 = sourceStructureIds_1.next(); !sourceStructureIds_1_1.done; sourceStructureIds_1_1 = sourceStructureIds_1.next()) {
                var sourceStructureId = sourceStructureIds_1_1.value;
                positionDependencies[sourceStructureId] = [];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sourceStructureIds_1_1 && !sourceStructureIds_1_1.done && (_b = sourceStructureIds_1.return)) _b.call(sourceStructureIds_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var _h = __values(matchUps !== null && matchUps !== void 0 ? matchUps : []), _j = _h.next(); !_j.done; _j = _h.next()) {
                var matchUp = _j.value;
                // pertains to Round Robins and e.g. Swiss rounds; Round Robins require hoisting to containing structure
                var sourceStructureId = matchUp.containerStructureId || matchUp.structureId;
                if (sourceStructureIds.includes(sourceStructureId)) {
                    positionDependencies[sourceStructureId].push(matchUp.matchUpId);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    var initializeMatchUpId = function (matchUpId) {
        if (!matchUpDependencies[matchUpId]) {
            matchUpDependencies[matchUpId] = {
                dependentMatchUpIds: [],
                participantIds: [],
                matchUpIds: [],
                sources: [],
            };
            sourceMatchUpIds[matchUpId] = [];
        }
    };
    var propagateDependencies = function (matchUpId, targetMatchUpId) {
        var propagatedMatchUpIds = matchUpDependencies[matchUpId].matchUpIds;
        // push all existing dependents onto target dependents
        propagatedMatchUpIds.forEach(function (matchUpIdDependency) {
            matchUpDependencies[targetMatchUpId].matchUpIds.push(matchUpIdDependency);
        });
        matchUpDependencies[targetMatchUpId].matchUpIds.push(matchUpId);
        matchUpDependencies[matchUpId].dependentMatchUpIds.push(targetMatchUpId);
        if (includeParticipantDependencies) {
            matchUpDependencies[matchUpId].participantIds.forEach(function (participantIdDependency) {
                return matchUpDependencies[targetMatchUpId].participantIds.push(participantIdDependency);
            });
        }
    };
    var processMatchUps = function (matchUpsToProcess) {
        var e_4, _a, _b, e_5, _c;
        var processSourceStructures = Object.keys(positionDependencies).length;
        try {
            for (var _d = __values(matchUpsToProcess || []), _e = _d.next(); !_e.done; _e = _d.next()) {
                var matchUp = _e.value;
                var matchUpId = matchUp.matchUpId, winnerMatchUpId = matchUp.winnerMatchUpId, loserMatchUpId = matchUp.loserMatchUpId;
                // only process specified matchUps
                if (!matchUpIds.length || matchUpIds.includes(matchUpId)) {
                    initializeMatchUpId(matchUpId);
                    if (includeParticipantDependencies) {
                        var individualParticipantIds = getIndividualParticipantIds(matchUp).individualParticipantIds;
                        matchUpDependencies[matchUpId].participantIds =
                            individualParticipantIds;
                    }
                    if (winnerMatchUpId) {
                        initializeMatchUpId(winnerMatchUpId);
                        propagateDependencies(matchUpId, winnerMatchUpId);
                        sourceMatchUpIds[winnerMatchUpId].push(matchUpId);
                    }
                    if (loserMatchUpId) {
                        initializeMatchUpId(loserMatchUpId);
                        propagateDependencies(matchUpId, loserMatchUpId);
                        sourceMatchUpIds[loserMatchUpId].push(matchUpId);
                    }
                    matchUpDependencies[matchUpId].sources.push(sourceMatchUpIds[matchUpId]);
                    var s1 = sourceMatchUpIds[matchUpId]
                        .map(function (id) { return matchUpDependencies[id].sources[0]; })
                        .flat();
                    var s2 = sourceMatchUpIds[matchUpId]
                        .map(function (id) { return matchUpDependencies[id].sources[1]; })
                        .flat();
                    (_b = matchUpDependencies[matchUpId].sources).push.apply(_b, [s1, s2]);
                    if (processSourceStructures) {
                        var relevantStructureId = matchUp.containerStructureId || matchUp.structureId;
                        var sourceStructureId = sourceStructureIdMap[relevantStructureId];
                        if (positionDependencies[sourceStructureId]) {
                            try {
                                for (var _f = (e_5 = void 0, __values(positionDependencies[sourceStructureId])), _g = _f.next(); !_g.done; _g = _f.next()) {
                                    var matchUpDependency = _g.value;
                                    initializeMatchUpId(matchUpDependency);
                                    propagateDependencies(matchUpDependency, matchUpId);
                                    sourceMatchUpIds[matchUpDependency].push(matchUpId);
                                }
                            }
                            catch (e_5_1) { e_5 = { error: e_5_1 }; }
                            finally {
                                try {
                                    if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
                                }
                                finally { if (e_5) throw e_5.error; }
                            }
                        }
                    }
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    if (drawDefinition) {
        addGoesTo({ drawDefinition: drawDefinition });
        if (!(matchUps === null || matchUps === void 0 ? void 0 : matchUps.length)) {
            matchUps = allDrawMatchUps({ drawDefinition: drawDefinition }).matchUps;
        }
        processMatchUps(matchUps);
    }
    else {
        if (!(matchUps === null || matchUps === void 0 ? void 0 : matchUps.length)) {
            matchUps = allCompetitionMatchUps({
                nextMatchUps: true,
                tournamentRecords: tournamentRecords,
            }).matchUps;
        }
        if (!drawIds.length) {
            var allDrawIds = (allTournamentRecords === null || allTournamentRecords === void 0 ? void 0 : allTournamentRecords.length)
                ? allTournamentRecords
                    .map(function (_a) {
                    var _b = _a.events, events = _b === void 0 ? [] : _b;
                    return events.map(function (_a) {
                        var _b = _a.drawDefinitions, drawDefinitions = _b === void 0 ? [] : _b;
                        return drawDefinitions.map(function (_a) {
                            var drawId = _a.drawId;
                            return drawId;
                        });
                    });
                })
                    .flat(Infinity)
                : [];
            if (allDrawIds)
                drawIds = allDrawIds;
        }
        var _loop_1 = function (drawId) {
            var drawMatchUps = matchUps === null || matchUps === void 0 ? void 0 : matchUps
            // first get all matchUps for the draw
            .filter(function (matchUp) { return matchUp.drawId === drawId; }).sort(matchUpSort);
            var isRoundRobin = drawMatchUps === null || drawMatchUps === void 0 ? void 0 : drawMatchUps.find(function (_a) {
                var roundPosition = _a.roundPosition;
                return !roundPosition;
            });
            // skip this if Round Robin because there is no "Goes To"
            if (!isRoundRobin) {
                var hasTournamentId = drawMatchUps === null || drawMatchUps === void 0 ? void 0 : drawMatchUps.find(function (_a) {
                    var tournamentId = _a.tournamentId;
                    return tournamentId;
                });
                var drawDefinition_1 = findEvent({
                    tournamentRecord: tournamentRecords[hasTournamentId === null || hasTournamentId === void 0 ? void 0 : hasTournamentId.tournamentId],
                    drawId: drawId,
                }).drawDefinition;
                if (drawDefinition_1)
                    addGoesTo({ drawDefinition: drawDefinition_1 });
            }
            processMatchUps(drawMatchUps);
        };
        try {
            for (var drawIds_1 = __values(drawIds), drawIds_1_1 = drawIds_1.next(); !drawIds_1_1.done; drawIds_1_1 = drawIds_1.next()) {
                var drawId = drawIds_1_1.value;
                _loop_1(drawId);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (drawIds_1_1 && !drawIds_1_1.done && (_d = drawIds_1.return)) _d.call(drawIds_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    }
    return __assign({ positionDependencies: positionDependencies, matchUpDependencies: matchUpDependencies, sourceMatchUpIds: sourceMatchUpIds, matchUps: matchUps }, SUCCESS);
}

function getStructureDrawPositionProfiles(params) {
    var e_1, _a, e_2, _b;
    var _c, _d, _e, _f;
    var drawDefinition = params.drawDefinition, findContainer = params.findContainer, structureId = params.structureId, event = params.event;
    var structure = params.structure;
    var matchUpFilters = { isCollectionMatchUp: false };
    var containedStructures = getContainedStructures({ drawDefinition: drawDefinition }).containedStructures;
    var containedStructureIds = structureId
        ? containedStructures[structureId] || []
        : [];
    if (!structure) {
        var result = findStructure({ drawDefinition: drawDefinition, structureId: structureId });
        if (result.error)
            return result;
        structure = findContainer
            ? (_c = result.containingStructure) !== null && _c !== void 0 ? _c : result.structure
            : result.structure;
    }
    if (isAdHoc({ drawDefinition: drawDefinition, structure: structure })) {
        return { structure: structure, isAdHoc: true, error: INVALID_DRAW_POSITION };
    }
    // must use all draw matchUps to get active matchUps across all connected structures
    var inContextDrawMatchUps = getAllDrawMatchUps({
        inContext: true,
        matchUpFilters: matchUpFilters,
        drawDefinition: drawDefinition,
        event: event,
    }).matchUps;
    var inContextStructureMatchUps = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.filter(function (matchUp) {
        return matchUp.structureId === structureId ||
            containedStructureIds.includes(matchUp.structureId);
    });
    // get a mapping of all matchUpIds to dependent matchUpIds
    var matchUpDependencies = getMatchUpDependencies({
        drawIds: [drawDefinition.drawId],
        matchUps: inContextDrawMatchUps,
        drawDefinition: drawDefinition,
    }).matchUpDependencies;
    var activeDependentMatchUpIdsCollection = [];
    var drawPositionsCollection = [];
    var drawPositionInitialRounds = {};
    var activeMatchUps = [];
    try {
        for (var _g = __values(inContextDrawMatchUps !== null && inContextDrawMatchUps !== void 0 ? inContextDrawMatchUps : []), _h = _g.next(); !_h.done; _h = _g.next()) {
            var matchUp = _h.value;
            if (matchUp.structureId === structureId ||
                containedStructureIds.includes(matchUp.structureId)) {
                drawPositionsCollection.push.apply(drawPositionsCollection, __spreadArray([], __read(((_d = matchUp.drawPositions) !== null && _d !== void 0 ? _d : [])), false));
                var roundNumber = matchUp.roundNumber;
                try {
                    for (var _j = (e_2 = void 0, __values(((_e = matchUp.drawPositions) !== null && _e !== void 0 ? _e : []).filter(Boolean))), _k = _j.next(); !_k.done; _k = _j.next()) {
                        var drawPosition = _k.value;
                        if (!drawPositionInitialRounds[drawPosition] ||
                            (roundNumber && drawPositionInitialRounds[drawPosition] > roundNumber)) {
                            drawPositionInitialRounds[drawPosition] = roundNumber;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_k && !_k.done && (_b = _j.return)) _b.call(_j);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            if (isActiveMatchUp(matchUp)) {
                activeMatchUps.push(matchUp);
                activeDependentMatchUpIdsCollection.push.apply(activeDependentMatchUpIdsCollection, __spreadArray([matchUp.matchUpId], __read((((_f = matchUpDependencies === null || matchUpDependencies === void 0 ? void 0 : matchUpDependencies[matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpId]) === null || _f === void 0 ? void 0 : _f.matchUpIds) || [])), false));
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // sorted drawPositions for the structure
    var drawPositions = unique(drawPositionsCollection.filter(Boolean)).sort(numericSort);
    var activeDependentMatchUpIds = unique(activeDependentMatchUpIdsCollection);
    var activeDrawPositions = unique(inContextStructureMatchUps === null || inContextStructureMatchUps === void 0 ? void 0 : inContextStructureMatchUps.map(function (_a) {
        var matchUpId = _a.matchUpId, drawPositions = _a.drawPositions;
        return activeDependentMatchUpIds.includes(matchUpId) ? drawPositions : [];
    }).flat().filter(Boolean)).sort(numericSort);
    var positionAssignments = getPositionAssignments$1({
        drawDefinition: drawDefinition,
        structure: structure,
    }).positionAssignments;
    // determine which positions are BYEs
    var byeDrawPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) { return assignment.bye; }).map(function (assignment) { return assignment.drawPosition; });
    // determine which positions are Qualifiers
    var qualifyingDrawPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) { return assignment.qualifier; }).map(function (assignment) { return assignment.drawPosition; });
    var inactiveDrawPositions = (drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.filter(function (drawPosition) { return !activeDrawPositions.includes(drawPosition); })) || [];
    return {
        allDrawPositions: drawPositions,
        inContextStructureMatchUps: inContextStructureMatchUps,
        drawPositionInitialRounds: drawPositionInitialRounds,
        activeDependentMatchUpIds: activeDependentMatchUpIds,
        qualifyingDrawPositions: qualifyingDrawPositions,
        inactiveDrawPositions: inactiveDrawPositions,
        positionAssignments: positionAssignments,
        activeDrawPositions: activeDrawPositions,
        byeDrawPositions: byeDrawPositions,
        activeMatchUps: activeMatchUps,
        structure: structure,
    };
}

function getInitialRoundNumber(_a) {
    var drawPosition = _a.drawPosition, _b = _a.matchUps, matchUps = _b === void 0 ? [] : _b;
    // determine the initial round where drawPosition appears
    // drawPosition cannot be removed from its initial round
    var initialRoundNumber = matchUps
        .filter(function (_a) {
        var drawPositions = _a.drawPositions;
        return drawPosition && (drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(drawPosition));
    })
        .map(function (_a) {
        var roundNumber = _a.roundNumber;
        return roundNumber;
    })
        .sort(numericSort)[0];
    return { initialRoundNumber: initialRoundNumber };
}

var logColors = {
    reset: '\x1b[0m',
    bright: '\x1b[1m',
    dim: '\x1b[2m',
    red: '\x1b[31m',
    brightred: '\x1b[91m',
    green: '\x1b[32m',
    brightgreen: '\x1b[92m',
    yellow: '\x1b[33m',
    brightyellow: '\x1b[93m',
    blue: '\x1b[34m',
    brightblue: '\x1b[94m',
    lightblue: '\x1b[105m',
    magenta: '\x1b[35m',
    brightmagenta: '\x1b[95m',
    cyan: '\x1b[36m',
    brightcyan: '\x1b[96m',
    white: '\x1b[37m',
    brightwhite: '\x1b[97m',
};

var globalLog = [];
function pushGlobalLog(value, devContextOverride) {
    if (typeof value === 'string')
        value = { method: value };
    if (devContextOverride || getDevContext())
        globalLog.push(value);
}
function getGlobalLog(purge) {
    var globalLogCopy = globalLog.slice();
    if (purge) {
        globalLog.length = 0;
    }
    return globalLogCopy;
}
function printGlobalLog(purge) {
    var globalLogCopy = getGlobalLog(purge);
    var modifiedText = globalLogCopy.map(function (line) {
        var color = line.color, keyColors = line.keyColors, method = line.method, newline = line.newline;
        var methodColor = Object.keys(logColors).includes(color)
            ? logColors[color]
            : logColors.cyan;
        var bodyKeys = Object.keys(line).filter(function (key) { return !['color', 'keyColors', 'method', 'newline'].includes(key); });
        var body = bodyKeys
            .map(function (key) {
            var keyColor = keyColors &&
                Object.keys(keyColors).includes(key) &&
                logColors[keyColors[key]]
                ? logColors[keyColors[key]]
                : logColors.brightwhite;
            return "".concat(logColors.white).concat(key, ": ").concat(keyColor).concat(line[key]);
        })
            .join(', ');
        var tabs = (method === null || method === void 0 ? void 0 : method.length) < 15 ? "\t\t" : '\t';
        return [
            newline ? '\n' : '',
            methodColor,
            method,
            tabs,
            logColors.white,
            body,
            logColors.reset,
            '\n',
        ].join('');
    });
    if (modifiedText === null || modifiedText === void 0 ? void 0 : modifiedText.length)
        console.log.apply(console, __spreadArray([], __read(modifiedText), false));
}
function purgeGlobalLog() {
    globalLog.length = 0;
}

function assignDrawPositionBye(_a) {
    var _b, _c;
    var provisionalPositioning = _a.provisionalPositioning, isPositionAction = _a.isPositionAction, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawPosition = _a.drawPosition, matchUpsMap = _a.matchUpsMap, structureId = _a.structureId, structure = _a.structure, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structure)
        (structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure);
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    if (!structureId)
        (structureId = structure.structureId);
    var stack = 'assignDrawPositionBye';
    pushGlobalLog({ method: stack, color: 'cyan', drawPosition: drawPosition });
    if (!matchUpsMap) {
        matchUpsMap = getMatchUpsMap({ drawDefinition: drawDefinition });
    }
    var positionAssignments = getPositionAssignments$1({ structure: structure }).positionAssignments;
    var activeDrawPositions = getStructureDrawPositionProfiles({
        drawDefinition: drawDefinition,
        structureId: structureId,
    }).activeDrawPositions;
    var currentAssignment = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (assignment) { return assignment.drawPosition === drawPosition; });
    if (currentAssignment === null || currentAssignment === void 0 ? void 0 : currentAssignment.bye) {
        return __assign({}, SUCCESS);
    }
    // ################### Check error conditions ######################
    var drawPositionIsActive = activeDrawPositions === null || activeDrawPositions === void 0 ? void 0 : activeDrawPositions.includes(drawPosition);
    if (drawPositionIsActive) {
        return { error: DRAW_POSITION_ACTIVE };
    }
    var positionAssignment = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (assignment) { return assignment.drawPosition === drawPosition; });
    if (!positionAssignment)
        return { error: INVALID_DRAW_POSITION };
    var _d = drawPositionFilled(positionAssignment), filled = _d.filled, containsBye = _d.containsBye, assignedParticipantId = _d.assignedParticipantId;
    if (containsBye)
        return __assign({}, SUCCESS); // nothing to be done
    if (filled && !containsBye) {
        return decorateResult({ result: { error: DRAW_POSITION_ASSIGNED }, stack: stack });
    }
    // ########## gather reusable data for performance optimization ###########
    var inContextDrawMatchUps = (_b = getAllDrawMatchUps({
        inContext: true,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
    }).matchUps) !== null && _b !== void 0 ? _b : [];
    var matchUpFilters = { isCollectionMatchUp: false };
    var matchUps = getAllStructureMatchUps({
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        matchUpFilters: matchUpFilters,
        matchUpsMap: matchUpsMap,
        structure: structure,
    }).matchUps;
    // modifies the structure's positionAssignments
    // applies to both ELIMINATION and ROUND_ROBIN structures
    positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.forEach(function (assignment) {
        if (assignment.drawPosition === drawPosition) {
            assignment.bye = true;
        }
    });
    if (structure.structureType === CONTAINER) {
        assignRoundRobinBYE({
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            drawPosition: drawPosition,
            matchUps: matchUps,
        });
        modifyPositionAssignmentsNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            drawDefinition: drawDefinition,
            structure: structure,
            event: event,
        });
        return successNotice({
            assignedParticipantId: assignedParticipantId,
            isPositionAction: isPositionAction,
            drawDefinition: drawDefinition,
            drawPosition: drawPosition,
            structureId: structureId,
            stack: stack,
        });
    }
    // ############ Get furthest advancement of drawPosition ############
    var _e = getRoundMatchUps({ matchUps: matchUps }), roundProfile = _e.roundProfile, roundMatchUps = _e.roundMatchUps;
    // search from final rounds towards first rounds to find furthest advancement
    var roundNumbers = roundProfile &&
        Object.keys(roundProfile)
            .map(function (roundNumber) { return parseInt(roundNumber); })
            .reverse();
    var roundNumber = roundNumbers === null || roundNumbers === void 0 ? void 0 : roundNumbers.find(function (roundNumber) {
        var _a;
        return (_a = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber].drawPositions) === null || _a === void 0 ? void 0 : _a.includes(drawPosition);
    });
    // matchUp where BYE-advancement needs to occur
    var matchUp = roundNumber
        ? roundMatchUps === null || roundMatchUps === void 0 ? void 0 : roundMatchUps[roundNumber].find(function (_a) {
            var drawPositions = _a.drawPositions;
            return drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(drawPosition);
        })
        : undefined;
    matchUp &&
        setMatchUpStatusBYE({ tournamentRecord: tournamentRecord, drawDefinition: drawDefinition, matchUp: matchUp, event: event });
    var drawPositionToAdvance = (_c = matchUp === null || matchUp === void 0 ? void 0 : matchUp.drawPositions) === null || _c === void 0 ? void 0 : _c.find(function (position) { return position !== drawPosition; });
    if (matchUp && drawPositionToAdvance) {
        var result = advanceDrawPosition({
            sourceDrawPositions: matchUp.drawPositions,
            matchUpId: matchUp.matchUpId,
            inContextDrawMatchUps: inContextDrawMatchUps,
            drawPositionToAdvance: drawPositionToAdvance,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
        });
        if (result.error)
            return result;
    }
    modifyPositionAssignmentsNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    });
    return successNotice({
        assignedParticipantId: assignedParticipantId,
        isPositionAction: isPositionAction,
        drawDefinition: drawDefinition,
        drawPosition: drawPosition,
        structureId: structureId,
        stack: stack,
    });
}
function successNotice(_a) {
    var assignedParticipantId = _a.assignedParticipantId, isPositionAction = _a.isPositionAction, drawDefinition = _a.drawDefinition, drawPosition = _a.drawPosition, structureId = _a.structureId, stack = _a.stack;
    if (isPositionAction) {
        var positionAction = {
            removedParticipantId: assignedParticipantId,
            drawPosition: drawPosition,
            structureId: structureId,
            name: stack,
        };
        addPositionActionTelemetry({ drawDefinition: drawDefinition, positionAction: positionAction });
    }
    return decorateResult({ result: __assign({}, SUCCESS), stack: stack });
}
function drawPositionFilled(positionAssignment) {
    var containsBye = positionAssignment.bye;
    var containsQualifier = positionAssignment.qualifier;
    var assignedParticipantId = positionAssignment.participantId;
    var filled = containsBye || containsQualifier || assignedParticipantId;
    return { containsBye: containsBye, containsQualifier: containsQualifier, assignedParticipantId: assignedParticipantId, filled: filled };
}
function setMatchUpStatusBYE(_a) {
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, eventId = _a.eventId, matchUp = _a.matchUp, event = _a.event;
    Object.assign(matchUp, {
        matchUpStatus: BYE,
        score: undefined,
        winningSide: undefined,
    });
    modifyMatchUpNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        eventId: eventId !== null && eventId !== void 0 ? eventId : event === null || event === void 0 ? void 0 : event.eventId,
        context: 'setMatchUpStatusBye',
        drawDefinition: drawDefinition,
        matchUp: matchUp,
    });
}
function assignRoundRobinBYE(_a) {
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawPosition = _a.drawPosition, matchUps = _a.matchUps, event = _a.event;
    matchUps.forEach(function (matchUp) {
        var _a;
        if ((_a = matchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.includes(drawPosition)) {
            setMatchUpStatusBYE({
                eventId: event === null || event === void 0 ? void 0 : event.eventId,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                matchUp: matchUp,
            });
        }
    });
}
function advanceDrawPosition(_a) {
    var _b;
    var drawPositionToAdvance = _a.drawPositionToAdvance, inContextDrawMatchUps = _a.inContextDrawMatchUps, sourceDrawPositions = _a.sourceDrawPositions, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, matchUpsMap = _a.matchUpsMap, matchUpId = _a.matchUpId, event = _a.event;
    var stack = 'advanceDrawPosition';
    pushGlobalLog({ method: stack, color: 'cyan', drawPositionToAdvance: drawPositionToAdvance });
    var matchUp = matchUpsMap.drawMatchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
    var inContextMatchUp = inContextDrawMatchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
    var structureId = inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.structureId;
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    var positionAssignments = getPositionAssignments$1({
        structure: structure,
    }).positionAssignments;
    var byeAssignedDrawPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) { return assignment.bye; }).map(function (assignment) { return assignment.drawPosition; });
    var losingDrawPosition = (_b = matchUp === null || matchUp === void 0 ? void 0 : matchUp.drawPositions) === null || _b === void 0 ? void 0 : _b.find(function (drawPosition) { return drawPosition !== drawPositionToAdvance; });
    var losingDrawPosiitonIsBye = losingDrawPosition &&
        (byeAssignedDrawPositions === null || byeAssignedDrawPositions === void 0 ? void 0 : byeAssignedDrawPositions.includes(losingDrawPosition));
    var _c = positionTargets({
        inContextDrawMatchUps: inContextDrawMatchUps,
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
    }), loserTargetLink = _c.targetLinks.loserTargetLink, _d = _c.targetMatchUps, loserMatchUp = _d.loserMatchUp, winnerMatchUp = _d.winnerMatchUp, loserTargetDrawPosition = _d.loserTargetDrawPosition;
    // only handling situation where winningMatchUp is in same structure
    if (winnerMatchUp && winnerMatchUp.structureId === (structure === null || structure === void 0 ? void 0 : structure.structureId)) {
        // NOTE: error conditions are ignored
        advanceWinner({
            drawPositionToAdvance: drawPositionToAdvance,
            inContextDrawMatchUps: inContextDrawMatchUps,
            sourceDrawPositions: sourceDrawPositions,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            winnerMatchUp: winnerMatchUp,
            matchUpsMap: matchUpsMap,
            event: event,
        });
    }
    // only handling situation where a BYE is being placed in linked structure
    // and linked structure is NOT the same structure
    if (loserMatchUp &&
        losingDrawPosiitonIsBye &&
        loserMatchUp.structureId !== (structure === null || structure === void 0 ? void 0 : structure.structureId)) {
        var roundNumber = loserMatchUp.roundNumber;
        if (roundNumber === 1) {
            var result = assignDrawPositionBye({
                structureId: loserTargetLink.target.structureId,
                drawPosition: loserTargetDrawPosition,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                event: event,
            });
            if (result.error)
                return result;
        }
        else {
            assignFedDrawPositionBye({
                loserTargetDrawPosition: loserTargetDrawPosition,
                tournamentRecord: tournamentRecord,
                loserTargetLink: loserTargetLink,
                drawDefinition: drawDefinition,
                loserMatchUp: loserMatchUp,
                matchUpsMap: matchUpsMap,
                event: event,
            });
        }
    }
    return __assign({}, SUCCESS);
}
function advanceWinner(_a) {
    var _b, _c, _d;
    var drawPositionToAdvance = _a.drawPositionToAdvance, inContextDrawMatchUps = _a.inContextDrawMatchUps, sourceDrawPositions = _a.sourceDrawPositions, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, winnerMatchUp = _a.winnerMatchUp, matchUpsMap = _a.matchUpsMap, event = _a.event;
    var stack = 'advanceWinner';
    var noContextWinnerMatchUp = matchUpsMap.drawMatchUps.find(function (matchUp) { return matchUp.matchUpId === winnerMatchUp.matchUpId; });
    var inContextMatchUp = inContextDrawMatchUps.find(function (matchUp) { return matchUp.matchUpId === winnerMatchUp.matchUpId; });
    var structureId = inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.structureId;
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    var positionAssignments = getPositionAssignments$1({ structure: structure }).positionAssignments;
    var drawPositionToAdvanceAssigment = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (_a) {
        var drawPosition = _a.drawPosition;
        return drawPosition === drawPositionToAdvance;
    });
    var drawPositionToAdvanceIsBye = drawPositionToAdvanceAssigment === null || drawPositionToAdvanceAssigment === void 0 ? void 0 : drawPositionToAdvanceAssigment.bye;
    var existingDrawPositions = (_b = noContextWinnerMatchUp.drawPositions) === null || _b === void 0 ? void 0 : _b.filter(Boolean);
    var existingAssignments = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) { return existingDrawPositions === null || existingDrawPositions === void 0 ? void 0 : existingDrawPositions.includes(assignment.drawPosition); });
    var advancingAssignmentIsBye = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (_a) {
        var drawPosition = _a.drawPosition;
        return drawPosition === drawPositionToAdvance;
    });
    /// ????????????????????????????????????????
    // This may be unnecessary....
    var priorPair = sourceDrawPositions === null || sourceDrawPositions === void 0 ? void 0 : sourceDrawPositions.find(function (drawPosition) { return drawPosition !== drawPositionToAdvance; });
    var priorPairAssignment = priorPair &&
        (existingAssignments === null || existingAssignments === void 0 ? void 0 : existingAssignments.find(function (_a) {
            var drawPosition = _a.drawPosition;
            return drawPosition === priorPair;
        }));
    var priorPairIsBye = priorPairAssignment === null || priorPairAssignment === void 0 ? void 0 : priorPairAssignment.bye;
    var isByeAdvancedBye = drawPositionToAdvanceIsBye && priorPairIsBye;
    if (isByeAdvancedBye)
        console.log({ isByeAdvancedBye: isByeAdvancedBye });
    /// ????????????????????????????????????????
    if ((existingDrawPositions === null || existingDrawPositions === void 0 ? void 0 : existingDrawPositions.length) > 1 &&
        drawPositionToAdvanceIsBye &&
        !priorPairIsBye) {
        return decorateResult({ result: { error: DRAW_POSITION_ASSIGNED }, stack: stack });
    }
    var pairedDrawPosition = existingDrawPositions === null || existingDrawPositions === void 0 ? void 0 : existingDrawPositions.find(function (drawPosition) { return drawPosition !== drawPositionToAdvance; });
    var drawPositionAssigned = isByeAdvancedBye;
    // always ensure there are two drawPositions to iterate over
    var twoDrawPositions = __spreadArray(__spreadArray([], __read((noContextWinnerMatchUp.drawPositions || []).filter(Boolean)), false), [
        undefined,
        undefined,
    ], false).slice(0, 2);
    var drawPositions = twoDrawPositions
        .map(function (position) {
        if ((!position && !drawPositionAssigned) ||
            position === drawPositionToAdvance) {
            drawPositionAssigned = true;
            return drawPositionToAdvance;
        }
        else {
            return position;
        }
    })
        .sort(numericSort);
    if (!drawPositionAssigned) {
        console.log('@@@@@@@', {
            advancingAssignmentIsBye: advancingAssignmentIsBye,
            drawPositionToAdvance: drawPositionToAdvance,
            existingAssignments: existingAssignments,
        });
        return decorateResult({ result: { error: DRAW_POSITION_ASSIGNED }, stack: stack });
    }
    var pairedDrawPositionIsBye = (_c = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (_a) {
        var drawPosition = _a.drawPosition;
        return drawPosition === pairedDrawPosition;
    })) === null || _c === void 0 ? void 0 : _c.bye;
    var drawPositionIsBye = (_d = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (_a) {
        var drawPosition = _a.drawPosition;
        return drawPosition === drawPositionToAdvance;
    })) === null || _d === void 0 ? void 0 : _d.bye;
    var matchUpStatus = drawPositionIsBye || pairedDrawPositionIsBye ? BYE : TO_BE_PLAYED;
    Object.assign(noContextWinnerMatchUp, {
        matchUpStatus: matchUpStatus,
        score: undefined,
        winningSide: undefined,
        drawPositions: drawPositions,
    });
    var changedDrawPosition = noContextWinnerMatchUp.drawPositions.find(function (position) { return !twoDrawPositions.includes(position); });
    pushGlobalLog({
        method: stack,
        color: 'brightyellow',
        changedDrawPosition: changedDrawPosition,
        pairedDrawPositionIsBye: pairedDrawPositionIsBye,
        drawPositionIsBye: drawPositionIsBye,
    });
    modifyMatchUpNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        matchUp: noContextWinnerMatchUp,
        eventId: event === null || event === void 0 ? void 0 : event.eventId,
        context: stack,
        drawDefinition: drawDefinition,
    });
    var _e = positionTargets({
        matchUpId: winnerMatchUp.matchUpId,
        inContextDrawMatchUps: inContextDrawMatchUps,
        drawDefinition: drawDefinition,
    }), loserTargetLink = _e.targetLinks.loserTargetLink, _f = _e.targetMatchUps, loserMatchUp = _f.loserMatchUp, loserTargetDrawPosition = _f.loserTargetDrawPosition;
    if (pairedDrawPositionIsBye || drawPositionIsBye) {
        var advancingDrawPosition = pairedDrawPositionIsBye
            ? drawPositionToAdvance
            : pairedDrawPosition;
        if (advancingDrawPosition) {
            advanceDrawPosition({
                drawPositionToAdvance: advancingDrawPosition,
                matchUpId: winnerMatchUp.matchUpId,
                inContextDrawMatchUps: inContextDrawMatchUps,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                matchUpsMap: matchUpsMap,
            });
        }
        else if (drawPositionIsBye && loserTargetLink && loserMatchUp) {
            if (loserMatchUp.feedRound) {
                assignFedDrawPositionBye({
                    loserTargetDrawPosition: loserTargetDrawPosition,
                    tournamentRecord: tournamentRecord,
                    loserTargetLink: loserTargetLink,
                    drawDefinition: drawDefinition,
                    loserMatchUp: loserMatchUp,
                    matchUpsMap: matchUpsMap,
                });
            }
            else {
                var sourceStructureRoundPosition = winnerMatchUp.roundPosition;
                // loser drawPosition in target structure is determined bye even/odd
                var targetDrawPositionIndex = 1 - (sourceStructureRoundPosition % 2);
                var targetDrawPosition = loserMatchUp.drawPositions[targetDrawPositionIndex];
                var result = assignDrawPositionBye({
                    structureId: loserTargetLink.target.structureId,
                    drawPosition: targetDrawPosition,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    event: event,
                });
                if (result.error)
                    return result;
            }
        }
    }
}
function assignFedDrawPositionBye(_a) {
    var loserTargetDrawPosition = _a.loserTargetDrawPosition, tournamentRecord = _a.tournamentRecord, loserTargetLink = _a.loserTargetLink, drawDefinition = _a.drawDefinition, loserMatchUp = _a.loserMatchUp, matchUpsMap = _a.matchUpsMap, event = _a.event;
    var roundNumber = loserMatchUp.roundNumber;
    var stack = 'assignFedDrawPositionBye';
    pushGlobalLog({ method: stack, color: 'cyan', loserTargetDrawPosition: loserTargetDrawPosition });
    var mappedMatchUps = (matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.mappedMatchUps) || {};
    var loserStructureMatchUps = mappedMatchUps[loserMatchUp.structureId].matchUps;
    var initialRoundNumber = getInitialRoundNumber({
        drawPosition: loserTargetDrawPosition,
        matchUps: loserStructureMatchUps,
    }).initialRoundNumber;
    if (initialRoundNumber === roundNumber) {
        var result = assignDrawPositionBye({
            structureId: loserTargetLink.target.structureId,
            drawPosition: loserTargetDrawPosition,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            event: event,
        });
        if (result.error)
            return result;
    }
}

function modifyRoundRobinMatchUpsStatus(_a) {
    var positionAssignments = _a.positionAssignments, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, matchUpsMap = _a.matchUpsMap, structure = _a.structure, event = _a.event;
    var matchUps = getAllStructureMatchUps({
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        structure: structure,
        event: event,
    }).matchUps;
    matchUps.forEach(function (matchUp) {
        var matchUpAssignments = positionAssignments.filter(function (_a) {
            var _b;
            var drawPosition = _a.drawPosition;
            return (_b = matchUp.drawPositions) === null || _b === void 0 ? void 0 : _b.includes(drawPosition);
        });
        var matchUpContainsBye = matchUpAssignments.filter(function (assignment) { return assignment.bye; }).length;
        if (!matchUp.winningSide) {
            var matchUpStatus = matchUpContainsBye ? BYE : TO_BE_PLAYED;
            Object.assign(matchUp, { matchUpStatus: matchUpStatus });
            modifyMatchUpNotice({
                tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                context: 'modifyRoundRobinMatchUpsStatus',
                eventId: event === null || event === void 0 ? void 0 : event.eventId,
                drawDefinition: drawDefinition,
                matchUp: matchUp,
            });
        }
    });
}

function clearDrawPosition(params) {
    var inContextDrawMatchUps = params.inContextDrawMatchUps, participantId = params.participantId, drawPosition = params.drawPosition;
    var tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, structureId = params.structureId, matchUpsMap = params.matchUpsMap, event = params.event;
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    var positionAssignments = structureAssignedDrawPositions({
        drawDefinition: drawDefinition,
        structure: structure,
    }).positionAssignments || [];
    var existingAssignment = positionAssignments.find(function (assignment) {
        return (participantId && assignment.participantId === participantId) ||
            (drawPosition && assignment.drawPosition === drawPosition);
    });
    if (existingAssignment && participantId && !drawPosition) {
        drawPosition = existingAssignment === null || existingAssignment === void 0 ? void 0 : existingAssignment.drawPosition;
    }
    if (!drawPosition)
        return { error: MISSING_DRAW_POSITION };
    if (!participantId)
        participantId = existingAssignment === null || existingAssignment === void 0 ? void 0 : existingAssignment.participantId;
    var activeDrawPositions = getStructureDrawPositionProfiles({
        drawDefinition: drawDefinition,
        structureId: structureId,
    }).activeDrawPositions;
    var drawPositionIsActive = activeDrawPositions.includes(drawPosition);
    // drawPosition may not be cleared if:
    // 1. drawPosition has been advanced by winning a matchUp
    // 2. drawPosition is paired with another drawPosition which has been advanced by winning a matchUp
    if (drawPositionIsActive) {
        return { error: DRAW_POSITION_ACTIVE };
    }
    if (!inContextDrawMatchUps) {
        (inContextDrawMatchUps = getAllDrawMatchUps({
            inContext: true,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
        }).matchUps);
    }
    var result = drawPositionRemovals({
        inContextDrawMatchUps: inContextDrawMatchUps,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        structureId: structureId,
        drawPosition: drawPosition,
        matchUpsMap: matchUpsMap,
        event: event,
    });
    if (!result.drawPositionCleared)
        return { error: DRAW_POSITION_NOT_CLEARED };
    modifyPositionAssignmentsNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    });
    return __assign(__assign({}, SUCCESS), { participantId: participantId });
}
function drawPositionRemovals(_a) {
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawPosition = _a.drawPosition, matchUpsMap = _a.matchUpsMap, structureId = _a.structureId, event = _a.event;
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    var positionAssignments = structureAssignedDrawPositions({
        drawDefinition: drawDefinition,
        structure: structure,
    }).positionAssignments || [];
    var drawPositionCleared = positionAssignments.some(function (assignment) {
        if (assignment.drawPosition === drawPosition) {
            delete assignment.participantId;
            delete assignment.qualifier;
            delete assignment.bye;
            return true;
        }
        return undefined;
    });
    if (structure.structureType === CONTAINER) {
        modifyRoundRobinMatchUpsStatus({
            positionAssignments: positionAssignments,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
            structure: structure,
        });
        return __assign({ drawPositionCleared: drawPositionCleared }, SUCCESS);
    }
    var matchUpFilters = { isCollectionMatchUp: false };
    var structureMatchUps = getAllStructureMatchUps({
        drawDefinition: drawDefinition,
        matchUpFilters: matchUpFilters,
        matchUpsMap: matchUpsMap,
        structure: structure,
        event: event,
    }).matchUps;
    var _b = getRoundMatchUps({
        matchUps: structureMatchUps,
    }), roundProfile = _b.roundProfile, roundMatchUps = _b.roundMatchUps;
    var profileKeys = roundProfile && Object.keys(roundProfile);
    var roundNumbers = profileKeys === null || profileKeys === void 0 ? void 0 : profileKeys.map(function (roundNumber) {
        return ensureInt(roundNumber);
    });
    var targetDrawPosition = drawPosition;
    var pairingDetails = roundNumbers === null || roundNumbers === void 0 ? void 0 : roundNumbers.map(function (roundNumber) {
        var _a, _b, _c;
        // find the pair of drawPositions which includes the targetDrawPosition
        var profile = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber];
        var relevantPair = (_a = profile === null || profile === void 0 ? void 0 : profile.pairedDrawPositions) === null || _a === void 0 ? void 0 : _a.find(function (drawPositions) {
            return drawPositions.includes(targetDrawPosition);
        });
        // find the drawPosition which is paired with the targetDrawPosition
        var pairedDrawPosition = relevantPair === null || relevantPair === void 0 ? void 0 : relevantPair.find(function (currentDrawPosition) { return currentDrawPosition !== targetDrawPosition; });
        // find the assignment for the paired drawPosition
        var pairedDrawPositionAssignment = positionAssignments.find(function (assignment) { return assignment.drawPosition === pairedDrawPosition; });
        var nextRoundProfile = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber + 1];
        // whether or not the pairedDrawPosition is a BYE
        var pairedDrawPositionIsBye = pairedDrawPositionAssignment === null || pairedDrawPositionAssignment === void 0 ? void 0 : pairedDrawPositionAssignment.bye;
        // whether or not the pairedDrawPosition is present in the next round
        var pairedDrawPositionInNextRound = (_b = nextRoundProfile === null || nextRoundProfile === void 0 ? void 0 : nextRoundProfile.pairedDrawPositions) === null || _b === void 0 ? void 0 : _b.find(function (pairedPositions) {
            return pairedPositions.includes(pairedDrawPosition);
        });
        // pairedDrawPosition is a transitiveBye if it is a BYE and if it is present in next round
        var isTransitiveBye = pairedDrawPositionIsBye &&
            pairedDrawPositionInNextRound &&
            nextRoundProfile &&
            ((_c = nextRoundProfile.drawPositions) === null || _c === void 0 ? void 0 : _c.includes(pairedDrawPosition));
        var pairedDrawPositionByeAdvancedPair = !isTransitiveBye && pairedDrawPositionInNextRound;
        var result = relevantPair && {
            pairedDrawPositionByeAdvancedPair: pairedDrawPositionByeAdvancedPair,
            pairedDrawPosition: pairedDrawPosition,
            targetDrawPosition: targetDrawPosition,
            relevantPair: relevantPair,
            roundNumber: roundNumber,
        };
        // if the pairedDrawPosition is a BYE, continue search with pairedDrawPoaition as targetDrawPosition
        if (isTransitiveBye)
            targetDrawPosition = pairedDrawPosition;
        return result;
    }).filter(function (f) { return f === null || f === void 0 ? void 0 : f.targetDrawPosition; });
    var tasks = pairingDetails === null || pairingDetails === void 0 ? void 0 : pairingDetails.reduce(function (tasks, pairingDetail) {
        var roundNumber = pairingDetail.roundNumber, relevantPair = pairingDetail.relevantPair, targetDrawPosition = pairingDetail.targetDrawPosition, pairedDrawPosition = pairingDetail.pairedDrawPosition, pairedDrawPositionByeAdvancedPair = pairingDetail.pairedDrawPositionByeAdvancedPair;
        var roundRemoval = { roundNumber: roundNumber, targetDrawPosition: targetDrawPosition, relevantPair: relevantPair };
        var byeAdvancedRemoval = pairedDrawPositionByeAdvancedPair && {
            roundNumber: roundNumber + 1,
            targetDrawPosition: pairedDrawPosition,
            relevantPair: pairedDrawPositionByeAdvancedPair,
            subsequentRoundRemoval: true,
        };
        var newTasks = [roundRemoval, byeAdvancedRemoval].filter(Boolean);
        return tasks.concat.apply(tasks, __spreadArray([], __read(newTasks), false));
    }, []);
    tasks === null || tasks === void 0 ? void 0 : tasks.forEach(function (_a) {
        var roundNumber = _a.roundNumber, targetDrawPosition = _a.targetDrawPosition, relevantPair = _a.relevantPair;
        var targetMatchUp = roundMatchUps === null || roundMatchUps === void 0 ? void 0 : roundMatchUps[roundNumber].find(function (matchUp) {
            var _a;
            return overlap((_a = matchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.filter(Boolean), relevantPair.filter(Boolean));
        });
        if (!targetMatchUp) {
            return;
        }
        removeSubsequentRoundsParticipant$1({
            inContextDrawMatchUps: inContextDrawMatchUps,
            targetDrawPosition: targetDrawPosition,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            structureId: structureId,
            roundNumber: roundNumber,
            matchUpsMap: matchUpsMap,
        });
        removeDrawPosition$1({
            inContextDrawMatchUps: inContextDrawMatchUps,
            positionAssignments: positionAssignments,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            targetMatchUp: targetMatchUp,
            drawPosition: drawPosition,
            matchUpsMap: matchUpsMap,
            structure: structure,
            event: event,
        });
    });
    return { tasks: tasks, drawPositionCleared: drawPositionCleared, positionAssignments: positionAssignments };
}
function removeSubsequentRoundsParticipant$1(_a) {
    var _b;
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, targetDrawPosition = _a.targetDrawPosition, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, matchUpsMap = _a.matchUpsMap, roundNumber = _a.roundNumber, structureId = _a.structureId;
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    if (structure.structureType === CONTAINER)
        return;
    matchUpsMap = matchUpsMap || getMatchUpsMap({ drawDefinition: drawDefinition });
    var mappedMatchUps = (matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.mappedMatchUps) || {};
    var matchUps = mappedMatchUps[structureId].matchUps;
    var initialRoundNumber = getInitialRoundNumber({
        drawPosition: targetDrawPosition,
        matchUps: matchUps,
    }).initialRoundNumber;
    var relevantMatchUps = matchUps === null || matchUps === void 0 ? void 0 : matchUps.filter(function (matchUp) {
        var _a;
        return matchUp.roundNumber >= roundNumber &&
            matchUp.roundNumber !== initialRoundNumber &&
            ((_a = matchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.includes(targetDrawPosition));
    });
    var positionAssignments = (_b = getPositionAssignments$1({
        drawDefinition: drawDefinition,
        structureId: structureId,
    }).positionAssignments) !== null && _b !== void 0 ? _b : [];
    relevantMatchUps === null || relevantMatchUps === void 0 ? void 0 : relevantMatchUps.forEach(function (matchUp) {
        return removeDrawPosition$1({
            drawPosition: targetDrawPosition,
            targetMatchUp: matchUp,
            inContextDrawMatchUps: inContextDrawMatchUps,
            positionAssignments: positionAssignments,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
            structure: structure,
        });
    });
    return __assign({}, SUCCESS);
}
function removeDrawPosition$1(_a) {
    var _b, _c, _d, _e, _f, _g, _h;
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, positionAssignments = _a.positionAssignments, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, targetMatchUp = _a.targetMatchUp, drawPosition = _a.drawPosition, matchUpsMap = _a.matchUpsMap, structure = _a.structure, event = _a.event;
    var stack = 'removeDrawPosition';
    var initialDrawPositions = (_b = targetMatchUp.drawPositions) === null || _b === void 0 ? void 0 : _b.slice();
    var initialMatchUpStatus = targetMatchUp.matchUpStatus;
    var initialWinningSide = targetMatchUp.winningSide;
    matchUpsMap = matchUpsMap !== null && matchUpsMap !== void 0 ? matchUpsMap : getMatchUpsMap({ drawDefinition: drawDefinition });
    var mappedMatchUps = matchUpsMap.mappedMatchUps;
    var matchUps = mappedMatchUps[structure.structureId].matchUps;
    var initialRoundNumber = getInitialRoundNumber({
        drawPosition: drawPosition,
        matchUps: matchUps,
    }).initialRoundNumber;
    if (targetMatchUp.roundNumber &&
        initialRoundNumber &&
        targetMatchUp.roundNumber > initialRoundNumber) {
        var drawPositions = ((_c = targetMatchUp.drawPositions) !== null && _c !== void 0 ? _c : []).map(function (currentDrawPosition) {
            return currentDrawPosition === drawPosition ? undefined : currentDrawPosition;
        });
        targetMatchUp.drawPositions = drawPositions;
    }
    if (targetMatchUp.matchUpType === TEAM) {
        var inContextTargetMatchUp = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.find(function (matchUp) { return matchUp.matchUpId === targetMatchUp.matchUpId; });
        var sides = (_d = inContextTargetMatchUp === null || inContextTargetMatchUp === void 0 ? void 0 : inContextTargetMatchUp.sides) !== null && _d !== void 0 ? _d : [];
        var drawPositionSideIndex = sides.reduce(function (index, side, i) { return (side.drawPosition === drawPosition ? i : index); }, undefined);
        if (drawPositionSideIndex !== undefined &&
            ((_f = (_e = targetMatchUp.sides) === null || _e === void 0 ? void 0 : _e[drawPositionSideIndex]) === null || _f === void 0 ? void 0 : _f.lineUp)) {
            (_g = targetMatchUp.sides) === null || _g === void 0 ? true : delete _g[drawPositionSideIndex].lineUp;
            modifyMatchUpNotice({
                tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                context: "".concat(stack, "-TEAM"),
                eventId: event === null || event === void 0 ? void 0 : event.eventId,
                matchUp: targetMatchUp,
                drawDefinition: drawDefinition,
            });
        }
    }
    var targetData = positionTargets({
        matchUpId: targetMatchUp.matchUpId,
        inContextDrawMatchUps: inContextDrawMatchUps,
        drawDefinition: drawDefinition,
    });
    var winnerTargetLink = targetData.targetLinks.winnerTargetLink, _j = targetData.targetMatchUps, loserMatchUp = _j.loserMatchUp, winnerMatchUp = _j.winnerMatchUp, loserMatchUpDrawPositionIndex = _j.loserMatchUpDrawPositionIndex;
    var matchUpAssignments = positionAssignments.filter(function (_a) {
        var _b;
        var drawPosition = _a.drawPosition;
        return (_b = targetMatchUp.drawPositions) === null || _b === void 0 ? void 0 : _b.includes(drawPosition);
    });
    var matchUpContainsBye = matchUpAssignments.filter(function (assignment) { return assignment.bye; }).length;
    var newMatchUpStatus = (matchUpContainsBye && BYE) ||
        (targetMatchUp.matchUpStatus &&
            [DEFAULTED, WALKOVER$2].includes(targetMatchUp.matchUpStatus) &&
            targetMatchUp.matcHUpStatus) ||
        (((_h = targetMatchUp.drawPositions) === null || _h === void 0 ? void 0 : _h.length) === 2 && TO_BE_PLAYED) ||
        undefined;
    targetMatchUp.matchUpStatus = newMatchUpStatus;
    // if the matchUpStatus is WALKOVER then it is DOUBLE_WALKOVER produced
    // if the matchUpStatus is DEFAULTED then it is DOUBLE_DEFAULT produced
    // ... and the winningSide must be removed
    if (targetMatchUp.matchUpStatus &&
        [WALKOVER$2, DEFAULTED].includes(targetMatchUp.matchUpStatus))
        targetMatchUp.winningSide = undefined;
    var removedDrawPosition = initialDrawPositions === null || initialDrawPositions === void 0 ? void 0 : initialDrawPositions.find(function (position) { var _a; return !((_a = targetMatchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.includes(position)); });
    var noChange = (initialDrawPositions === null || initialDrawPositions === void 0 ? void 0 : initialDrawPositions.includes(drawPosition)) &&
        initialMatchUpStatus === targetMatchUp.matchUpStatus &&
        initialWinningSide === targetMatchUp.winningSide;
    if (!noChange) {
        if (removedDrawPosition) {
            pushGlobalLog({
                method: stack,
                color: 'brightyellow',
                removedDrawPosition: removedDrawPosition,
            });
        }
        modifyMatchUpNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            matchUp: targetMatchUp,
            context: "".concat(stack, "-").concat(drawPosition),
            drawDefinition: drawDefinition,
        });
    }
    if (loserMatchUp &&
        loserMatchUp.structureId !== targetData.matchUp.structureId &&
        !matchUpContainsBye) {
        var drawPositions = loserMatchUp.drawPositions, roundNumber = loserMatchUp.roundNumber;
        if (roundNumber === 1) {
            var loserMatchUpDrawPosition = drawPositions[loserMatchUpDrawPositionIndex];
            drawPositionRemovals({
                structureId: loserMatchUp.structureId,
                drawPosition: loserMatchUpDrawPosition,
                inContextDrawMatchUps: inContextDrawMatchUps,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                matchUpsMap: matchUpsMap,
            });
        }
        else {
            // for fed rounds the loserMatchUpDrawPosiiton is always the fed drawPosition
            // which is always the lowest numerical drawPosition
            var loserMatchUpDrawPosition = Math.min.apply(Math, __spreadArray([], __read(drawPositions.filter(Boolean)), false));
            var result = consolationCleanup({
                loserMatchUpDrawPosition: loserMatchUpDrawPosition,
                inContextDrawMatchUps: inContextDrawMatchUps,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                loserMatchUp: loserMatchUp,
                matchUpsMap: matchUpsMap,
                event: event,
            });
            if (result.error)
                return decorateResult({ result: result, stack: stack });
            var mappedMatchUps_1 = (matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.mappedMatchUps) || {};
            var loserStructureMatchUps = mappedMatchUps_1[loserMatchUp.structureId].matchUps;
            var initialRoundNumber_1 = getInitialRoundNumber({
                drawPosition: loserMatchUpDrawPosition,
                matchUps: loserStructureMatchUps,
            }).initialRoundNumber;
            // if clearing a drawPosition from a feed round the initialRoundNumber for the drawPosition must be { roundNumber: 1 }
            if (initialRoundNumber_1 === 1) {
                pushGlobalLog({
                    method: stack,
                    color: 'brightyellow',
                    loserMatchUpDrawPosition: loserMatchUpDrawPosition,
                });
                drawPositionRemovals({
                    structureId: loserMatchUp.structureId,
                    drawPosition: loserMatchUpDrawPosition,
                    inContextDrawMatchUps: inContextDrawMatchUps,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    matchUpsMap: matchUpsMap,
                });
            }
        }
    }
    if (winnerMatchUp &&
        winnerMatchUp.structureId !== targetData.matchUp.structureId &&
        // does not apply to traversals that are based on QUALIFYING
        winnerTargetLink.target.feedProfile !== DRAW) ;
    return __assign({}, SUCCESS);
}
function consolationCleanup(_a) {
    var loserMatchUpDrawPosition = _a.loserMatchUpDrawPosition, inContextDrawMatchUps = _a.inContextDrawMatchUps, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, loserMatchUp = _a.loserMatchUp, matchUpsMap = _a.matchUpsMap, event = _a.event;
    var structure = findStructure({
        structureId: loserMatchUp.structureId,
        drawDefinition: drawDefinition,
    }).structure;
    var positionAssignments = getPositionAssignments$1({ structure: structure }).positionAssignments;
    var assignment = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (assignment) { return assignment.drawPosition === loserMatchUpDrawPosition; });
    if (assignment === null || assignment === void 0 ? void 0 : assignment.bye) {
        var result = clearDrawPosition({
            drawPosition: loserMatchUpDrawPosition,
            structureId: loserMatchUp.structureId,
            inContextDrawMatchUps: inContextDrawMatchUps,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
            event: event,
        });
        if (result.error)
            return result;
    }
    return __assign({}, SUCCESS);
}

function getAssignedParticipantIds(_a) {
    var _b;
    var drawDefinition = _a.drawDefinition, stages = _a.stages;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var stageStructures = ((_b = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) !== null && _b !== void 0 ? _b : []).filter(function (structure) { return !(stages === null || stages === void 0 ? void 0 : stages.length) || (structure.stage && stages.includes(structure.stage)); });
    var assignedParticipantIds = unique(stageStructures
        .map(function (structure) {
        var positionAssignments = getPositionAssignments$1({
            structure: structure,
        }).positionAssignments;
        return positionAssignments ? positionAssignments.map(xa('participantId')) : [];
    })
        .flat()
        .filter(Boolean));
    return __assign(__assign({}, SUCCESS), { assignedParticipantIds: assignedParticipantIds });
}

/**
 *
 * @param {object[]} entries - array of entry objects
 * @returns entries - with updated entryPosition values
 */
function refreshEntryPositions(params) {
    var _a;
    var stagedEntries = ((_a = params === null || params === void 0 ? void 0 : params.entries) !== null && _a !== void 0 ? _a : [])
        .filter(Boolean)
        .reduce(function (stages, entry) {
        var entryStage = entry.entryStage, entryStatus = entry.entryStatus;
        var entryHash = "_".concat(entryStage || MAIN).concat(entryStatus || '');
        if (!stages[entryHash])
            stages[entryHash] = [];
        stages[entryHash].push(entry);
        return stages;
    }, {});
    var validEntryPosition = function (entryPosition) {
        return !isNaN(entryPosition) ? entryPosition : Infinity;
    };
    return Object.keys(stagedEntries)
        .map(function (entryHash) {
        return stagedEntries[entryHash]
            .sort(function (a, b) {
            return validEntryPosition(a.entryPosition) -
                validEntryPosition(b.entryPosition);
        })
            .map(function (entry, index) {
            var entryPosition = index + 1;
            return __assign(__assign({}, entry), { entryPosition: entryPosition });
        });
    })
        .flat();
}

function isUngrouped(entryStatus) {
    return [UNPAIRED, UNGROUPED].includes(entryStatus);
}

function modifyEntriesStatus(_a) {
    var e_1, _b, e_2, _c;
    var _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
    var _w = _a.autoEntryPositions, autoEntryPositions = _w === void 0 ? true : _w, ignoreAssignment = _a.ignoreAssignment, // override check for existing assignments
    tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, participantIds = _a.participantIds, entryStatus = _a.entryStatus, entryStage = _a.entryStage, extension = _a.extension, // modify the specified extension (remove if value undefined)
    eventSync = _a.eventSync, drawId = _a.drawId, stage = _a.stage, event = _a.event;
    if (!participantIds || !Array.isArray(participantIds))
        return {
            error: INVALID_PARTICIPANT_ID,
            method: 'modifyEntriesStatus',
            participantIds: participantIds,
        };
    if (!drawDefinition && !event)
        return { error: MISSING_EVENT };
    if (entryStatus && !VALID_ENTRY_STATUSES.includes(entryStatus))
        return { error: INVALID_ENTRY_STATUS };
    if (entryStage && !validStages.includes(entryStage))
        return { error: INVALID_STAGE };
    var stack = 'modifyEntriesStatus';
    var modifiedDrawIds = [];
    if (!entryStatus && !extension)
        return decorateResult({
            result: { error: MISSING_VALUE },
            info: 'Missing entryStatus',
            stack: stack,
        });
    if (extension &&
        !isValidExtension({ extension: extension, requiredAttributes: ['name'] }))
        // valid without value (will remove extension)
        return decorateResult({
            result: { error: INVALID_VALUES },
            info: 'Invalid extension',
            context: { extension: extension },
            stack: stack,
        });
    // build up an array of participantIds which are assigned positions in structures
    var assignedParticipantIds = [];
    (_d = event === null || event === void 0 ? void 0 : event.drawDefinitions) === null || _d === void 0 ? void 0 : _d.forEach(function (drawDefinition) {
        var _a;
        var participantIds = (_a = getAssignedParticipantIds({
            stages: stage && [stage],
            drawDefinition: drawDefinition,
        }).assignedParticipantIds) !== null && _a !== void 0 ? _a : [];
        assignedParticipantIds.push.apply(assignedParticipantIds, __spreadArray([], __read(participantIds), false));
    });
    var tournamentParticipants = (_e = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) !== null && _e !== void 0 ? _e : [];
    var validEntryStatusForAllParticipantIds = participantIds.every(function (participantId) {
        var _a;
        var participantType = (_a = findParticipant({
            tournamentParticipants: tournamentParticipants,
            participantId: participantId,
        })) === null || _a === void 0 ? void 0 : _a.participantType;
        return (!(participantType &&
            [PAIR, TEAM_PARTICIPANT].includes(participantType) &&
            isUngrouped(entryStatus)) &&
            !(entryStatus &&
                (event === null || event === void 0 ? void 0 : event.eventType) &&
                participantType === INDIVIDUAL &&
                [DOUBLES$1, TEAM_EVENT].includes(event.eventType) &&
                __spreadArray([ALTERNATE], __read(EQUIVALENT_ACCEPTANCE_STATUSES), false).includes(entryStatus)));
    });
    if (!validEntryStatusForAllParticipantIds)
        return { error: INVALID_ENTRY_STATUS };
    var flightProfile = event && getFlightProfile({ event: event }).flightProfile;
    var flight = (_f = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _f === void 0 ? void 0 : _f.find(function (flight) { return flight.drawId === drawId; });
    // ------------------------------------------------------------------------
    // reusable functions
    var updateEntryStatus = function (entries) {
        var filteredEntries = (entries || [])
            // filter out entries by stage (if specified)
            .filter(function (entry) {
            return !stage || !entry.entryStage || stage === entry.entryStage;
        })
            // filter by specified participantIds
            .filter(function (_a) {
            var participantId = _a.participantId;
            return participantIds.includes(participantId);
        });
        var isAssigned = function (entry) {
            return entryStatus &&
                assignedParticipantIds.includes(entry.participantId) &&
                !(EQUIVALENT_ACCEPTANCE_STATUSES.includes(entry.entryStatus) &&
                    EQUIVALENT_ACCEPTANCE_STATUSES.includes(entryStatus));
        };
        var success = filteredEntries.every(function (entry) {
            if (isAssigned(entry) && !ignoreAssignment)
                return false;
            if (entryStatus) {
                entry.entryStatus = entryStatus;
                // since entryStatus has changed remove current entryPosition
                delete entry.entryPosition;
            }
            if (entryStage) {
                entry.entryStage = entryStage;
                // since entryStage has changed remove current entryPosition
                delete entry.entryPosition;
            }
            if (extension) {
                if (extension.value) {
                    addExtension({ element: entry, extension: extension });
                }
                else {
                    removeExtension({ element: entry, name: extension.name });
                }
            }
            return true;
        });
        return success
            ? __assign({}, SUCCESS) : { error: EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT };
    };
    var autoPosition = function (_a) {
        var _b;
        var flight = _a.flight, drawDefinition = _a.drawDefinition;
        if (event) {
            event.entries = refreshEntryPositions({
                entries: (_b = event.entries) !== null && _b !== void 0 ? _b : [],
            });
        }
        if (flight) {
            flight.drawEntries = refreshEntryPositions({
                entries: flight.drawEntries,
            });
        }
        if (drawDefinition) {
            drawDefinition.entries = refreshEntryPositions({
                entries: drawDefinition.entries,
            });
        }
    };
    var updateDrawEntries = function (params) {
        var flight = params.flight, drawDefinition = params.drawDefinition;
        var stack = 'updateDrawEntries';
        if (flight) {
            var result = updateEntryStatus(flight.drawEntries);
            if (result.error)
                return decorateResult({ result: result, stack: stack });
        }
        if (drawDefinition) {
            var result = updateEntryStatus(drawDefinition.entries);
            if (result.error)
                return decorateResult({ result: result, stack: stack });
            if (!modifiedDrawIds.includes(drawDefinition.drawId))
                modifiedDrawIds.push(drawDefinition.drawId);
        }
        return __assign({}, SUCCESS);
    };
    // ------------------------------------------------------------------------
    // before modifying, if autoEntryPositions: true, pre-assign entryPositions
    var entryPositionsExist = (_h = (_g = event === null || event === void 0 ? void 0 : event.entries) === null || _g === void 0 ? void 0 : _g.find(function (_a) {
        var entryPosition = _a.entryPosition;
        return entryPosition;
    })) !== null && _h !== void 0 ? _h : (((_j = flight === null || flight === void 0 ? void 0 : flight.drawEntries) === null || _j === void 0 ? void 0 : _j.find(function (_a) {
        var entryPosition = _a.entryPosition;
        return entryPosition;
    })) ||
        ((_k = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) === null || _k === void 0 ? void 0 : _k.find(function (_a) {
            var entryPosition = _a.entryPosition;
            return entryPosition;
        })));
    if (autoEntryPositions && !entryPositionsExist)
        autoPosition({ flight: flight, drawDefinition: drawDefinition });
    // ------------------------------------------------------------------------
    // if flight or drawDefinition scope modifications
    if (flight || drawDefinition) {
        var result = updateDrawEntries({ flight: flight, drawDefinition: drawDefinition });
        if (result.error)
            return decorateResult({ result: result, stack: stack });
    }
    // ------------------------------------------------------------------------
    // update any flights which have no draw generated to keep entries in sync
    var generatedDrawIds = (_m = (_l = event === null || event === void 0 ? void 0 : event.drawDefinitions) === null || _l === void 0 ? void 0 : _l.map(function (_a) {
        var drawId = _a.drawId;
        return drawId;
    })) !== null && _m !== void 0 ? _m : [];
    var flightsNoDraw = ((_o = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _o === void 0 ? void 0 : _o.filter(function (flight) { return !generatedDrawIds.includes(flight.drawId); })) || [];
    try {
        for (var flightsNoDraw_1 = __values(flightsNoDraw), flightsNoDraw_1_1 = flightsNoDraw_1.next(); !flightsNoDraw_1_1.done; flightsNoDraw_1_1 = flightsNoDraw_1.next()) {
            var flight_1 = flightsNoDraw_1_1.value;
            var result = flight_1 && updateDrawEntries({ flight: flight_1 });
            if (result === null || result === void 0 ? void 0 : result.error)
                return decorateResult({ result: result, stack: stack });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (flightsNoDraw_1_1 && !flightsNoDraw_1_1.done && (_b = flightsNoDraw_1.return)) _b.call(flightsNoDraw_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // ------------------------------------------------------------------------
    var singleDraw = ((_p = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _p === void 0 ? void 0 : _p.length) === 1 &&
        ((_r = (_q = event === null || event === void 0 ? void 0 : event.drawDefinitions) === null || _q === void 0 ? void 0 : _q.length) !== null && _r !== void 0 ? _r : 0) <= ((_s = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _s === void 0 ? void 0 : _s.length);
    if (!flight &&
        !drawDefinition &&
        entryStatus &&
        DRAW_SPECIFIC_STATUSES.includes(entryStatus)) {
        return { error: ENTRY_STATUS_NOT_ALLOWED_FOR_EVENT };
    }
    if ((!flight && !drawDefinition) ||
        entryStatus === WITHDRAWN ||
        (eventSync && singleDraw) // if there is only one draw keep event entries in sync
    ) {
        // if entryStatus is WITHDRAWN then participantIds appearing in ANY flight or drawDefinition must be removed
        var result = updateEntryStatus(event === null || event === void 0 ? void 0 : event.entries);
        if (result === null || result === void 0 ? void 0 : result.error)
            return decorateResult({ result: result, stack: stack });
        var error_1;
        if (entryStatus === WITHDRAWN) {
            (_t = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _t === void 0 ? void 0 : _t.every(function (flight) {
                var result = updateEntryStatus(flight.drawEntries);
                if (result.error) {
                    error_1 = result.error;
                    return false;
                }
                flight.drawEntries = flight.drawEntries.filter(function (_a) {
                    var participantId = _a.participantId;
                    return !participantIds.includes(participantId);
                });
                return true;
            });
            (_u = event === null || event === void 0 ? void 0 : event.drawDefinitions) === null || _u === void 0 ? void 0 : _u.every(function (drawDefinition) {
                var _a;
                var result = updateEntryStatus(drawDefinition.entries);
                if (result.error) {
                    error_1 = result.error;
                    return false;
                }
                drawDefinition.entries = (_a = drawDefinition.entries) === null || _a === void 0 ? void 0 : _a.filter(function (_a) {
                    var participantId = _a.participantId;
                    return !participantIds.includes(participantId);
                });
                return true;
            });
        }
        if (error_1)
            return decorateResult({ result: { error: error_1 }, stack: stack });
    }
    if (autoEntryPositions)
        autoPosition({ flight: flight, drawDefinition: drawDefinition });
    try {
        for (var _x = __values((_v = event === null || event === void 0 ? void 0 : event.drawDefinitions) !== null && _v !== void 0 ? _v : []), _y = _x.next(); !_y.done; _y = _x.next()) {
            var drawDefinition_1 = _y.value;
            if (modifiedDrawIds.length &&
                !modifiedDrawIds.includes(drawDefinition_1.drawId))
                continue;
            modifyDrawNotice({
                tournamentId: tournamentRecord.tournamentId,
                eventId: event === null || event === void 0 ? void 0 : event.eventId,
                drawDefinition: drawDefinition_1,
            });
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_y && !_y.done && (_c = _x.return)) _c.call(_x);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return __assign({}, SUCCESS);
}

function addScheduleItem(params) {
    var participantMap = params.participantMap, participantId = params.participantId, matchUpStatus = params.matchUpStatus, roundPosition = params.roundPosition, structureId = params.structureId, matchUpType = params.matchUpType, roundNumber = params.roundNumber, matchUpId = params.matchUpId, potential = params.potential, schedule = params.schedule, drawId = params.drawId, score = params.score;
    if (!schedule || !Object.keys(schedule).length)
        return;
    var ignoreMatchUp = matchUpStatus === BYE;
    if (!ignoreMatchUp) {
        participantMap[participantId].scheduleItems.push(__assign(__assign({}, schedule), { scheduledDate: extractDate(schedule === null || schedule === void 0 ? void 0 : schedule.scheduledDate), scheduledTime: extractTime(schedule === null || schedule === void 0 ? void 0 : schedule.scheduledTime), checkScoreHasValue: checkScoreHasValue({ score: score }), matchUpStatus: matchUpStatus, roundPosition: roundPosition, structureId: structureId, matchUpType: matchUpType, roundNumber: roundNumber, matchUpId: matchUpId, potential: potential, drawId: drawId }));
    }
}

function participantScaleItem(_a) {
    var _b, _c;
    var requireTimeStamp = _a.requireTimeStamp, scaleAttributes = _a.scaleAttributes, participant = _a.participant;
    if (!participant)
        return { error: MISSING_PARTICIPANT };
    if (!isObject(scaleAttributes))
        return { error: INVALID_VALUES };
    if (!participant.timeItems)
        participant.timeItems = [];
    if (Array.isArray(participant.timeItems)) {
        var accessor = scaleAttributes.accessor, scaleType = scaleAttributes.scaleType, eventType = scaleAttributes.eventType, scaleName = scaleAttributes.scaleName;
        var filterType_1 = [SCALE$1, scaleType, eventType, scaleName].join('.');
        var filteredTimeItems = participant.timeItems
            .filter(function (timeItem) { return (timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType) === filterType_1; })
            .filter(function (timeItem) { return !requireTimeStamp || (timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemDate); })
            .sort(function (a, b) {
            return (a.createdAt ? new Date(a.createdAt).getTime() : 0) -
                (b.createdAt ? new Date(b.createdAt).getTime() : 0);
        });
        var timeItem = filteredTimeItems.pop();
        if (timeItem) {
            var _d = __read((_c = (_b = timeItem.itemType) === null || _b === void 0 ? void 0 : _b.split('.')) !== null && _c !== void 0 ? _c : [], 4), itemSubject = _d[0], scaleType_1 = _d[1], eventType_1 = _d[2], scaleName_1 = _d[3];
            if (itemSubject !== SCALE$1)
                return { error: INVALID_SCALE_ITEM };
            var accessorValue = accessor && getAccessorValue({ element: timeItem.itemValue, accessor: accessor });
            var scaleValue = (accessorValue === null || accessorValue === void 0 ? void 0 : accessorValue.value) || timeItem.itemValue;
            var scaleItem = {
                eventType: eventType_1,
                scaleDate: timeItem.itemDate,
                scaleValue: scaleValue,
                scaleName: scaleName_1,
                scaleType: scaleType_1,
            };
            return __assign(__assign({}, SUCCESS), { scaleItem: scaleItem });
        }
    }
    return __assign(__assign({}, SUCCESS), { scaleItem: undefined });
}

function getEventSeedAssignments(_a) {
    var e_1, _b;
    var _c, _d, _e;
    var publishedSeeding = _a.publishedSeeding, usePublishState = _a.usePublishState, withSeeding = _a.withSeeding, participant = _a.participant, event = _a.event;
    var eventSeedAssignments = {};
    var getScaleAccessor = function (scaleName) {
        return [SCALE$1, SEEDING$1, event.eventType, scaleName].join('.');
    };
    var seedingScales = Object.assign.apply(Object, __spreadArray([{}], __read((participant.timeItems || [])
        .filter(function (_a) {
        var itemType = _a.itemType;
        return itemType.split('.')[1] === SEEDING$1;
    })
        .map(function (_a) {
        var _b;
        var seedingScaleName = _a.itemType, seedValue = _a.itemValue;
        return (_b = {},
            _b[seedingScaleName] = seedValue,
            _b);
    })), false));
    var eventSeedingScaleNames = (((publishedSeeding === null || publishedSeeding === void 0 ? void 0 : publishedSeeding.stageSeedingScaleNames) &&
        Object.values(publishedSeeding === null || publishedSeeding === void 0 ? void 0 : publishedSeeding.stageSeedingScaleNames)) ||
        (Array.isArray(publishedSeeding === null || publishedSeeding === void 0 ? void 0 : publishedSeeding.seedingScaleNames) &&
            publishedSeeding.seedingScaleNames) ||
        []).map(getScaleAccessor);
    var publishedEventSeedingScaleNames = intersection(Object.keys(seedingScales), eventSeedingScaleNames);
    var eventSeedingPublished = !!(!usePublishState ||
        (!Object.keys(seedingScales).length &&
            !((_c = publishedSeeding === null || publishedSeeding === void 0 ? void 0 : publishedSeeding.drawIds) === null || _c === void 0 ? void 0 : _c.length)) ||
        publishedEventSeedingScaleNames.length);
    if (eventSeedingPublished && publishedEventSeedingScaleNames.length) {
        if (publishedSeeding === null || publishedSeeding === void 0 ? void 0 : publishedSeeding.stageSeedingScaleNames) {
            var scaleValues = Object.keys(publishedSeeding.stageSeedingScaleNames)
                .map(function (key) {
                var accessor = getScaleAccessor(publishedSeeding.stageSeedingScaleNames[key]);
                var scaleValue = seedingScales[accessor];
                return [key, scaleValue];
            })
                .filter(function (pair) { return pair[1]; })
                .map(function (pair) {
                var _a;
                return (_a = {}, _a[pair[0]] = { seedValue: pair[1] }, _a);
            });
            var seedAssignments = Object.assign.apply(Object, __spreadArray([{}], __read(scaleValues), false));
            eventSeedAssignments.seedAssignments = seedAssignments;
        }
        else if (publishedEventSeedingScaleNames) {
            var seedValues = publishedEventSeedingScaleNames.map(function (scaleName) { return seedingScales[scaleName]; });
            eventSeedAssignments.seedValue = seedValues.pop();
        }
    }
    else if (!usePublishState && typeof withSeeding === 'object') {
        var scaleValues = Object.keys(withSeeding)
            .map(function (key) {
            var accessor = getScaleAccessor(withSeeding[key]);
            var scaleValue = seedingScales[accessor];
            return [key, scaleValue];
        })
            .filter(function (pair) { return pair[1]; })
            .map(function (pair) {
            var _a;
            return (_a = {}, _a[pair[0]] = { seedValue: pair[1] }, _a);
        });
        var seedAssignments = Object.assign.apply(Object, __spreadArray([{}], __read(scaleValues), false));
        eventSeedAssignments.seedAssignments = seedAssignments;
    }
    else {
        var _f = event.category || {}, categoryName = _f.categoryName, ageCategoryCode = _f.ageCategoryCode;
        var scaleNames = [ageCategoryCode, event.eventId, categoryName].filter(Boolean);
        var scaleItem = void 0;
        try {
            for (var scaleNames_1 = __values(scaleNames), scaleNames_1_1 = scaleNames_1.next(); !scaleNames_1_1.done; scaleNames_1_1 = scaleNames_1.next()) {
                var scaleName = scaleNames_1_1.value;
                var scaleAttributes = {
                    eventType: event.eventType,
                    scaleType: SEEDING$1,
                    scaleName: scaleName,
                };
                var result = participantScaleItem({
                    scaleAttributes: scaleAttributes,
                    participant: participant,
                });
                if (result.scaleItem) {
                    scaleItem = result.scaleItem;
                    break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (scaleNames_1_1 && !scaleNames_1_1.done && (_b = scaleNames_1.return)) _b.call(scaleNames_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (scaleItem) {
            var seedingPublished = !usePublishState ||
                ((publishedSeeding === null || publishedSeeding === void 0 ? void 0 : publishedSeeding.published) &&
                    // if drawIds have been specified then don't attach event seeding here
                    // defer to seedValue that is in seedAssignments for draw in which participant appears
                    !((_e = (_d = publishedSeeding === null || publishedSeeding === void 0 ? void 0 : publishedSeeding.published) === null || _d === void 0 ? void 0 : _d.drawIds) === null || _e === void 0 ? void 0 : _e.length));
            if (seedingPublished) {
                var seedValue = scaleItem.scaleValue;
                eventSeedAssignments.seedValue = seedValue;
            }
        }
    }
    return eventSeedAssignments;
}

function getEventPublishStatus(_a) {
    var _b, _c, _d;
    var event = _a.event, _e = _a.status, status = _e === void 0 ? PUBLIC : _e;
    var itemType = "".concat(PUBLISH, ".").concat(STATUS$1);
    return (_d = (_c = (_b = getEventTimeItem({
        itemType: itemType,
        event: event,
    })) === null || _b === void 0 ? void 0 : _b.timeItem) === null || _c === void 0 ? void 0 : _c.itemValue) === null || _d === void 0 ? void 0 : _d[status];
}

function getDrawPublishStatus(_a) {
    var _b;
    var drawDetails = _a.drawDetails, drawId = _a.drawId;
    // TODO: check details.embargo
    var details = (_b = drawDetails === null || drawDetails === void 0 ? void 0 : drawDetails[drawId]) === null || _b === void 0 ? void 0 : _b.publishingDetail;
    return details === null || details === void 0 ? void 0 : details.published;
}

function getPublishState(_a) {
    var e_1, _b, e_2, _c, e_3, _d, e_4, _e;
    var tournamentRecord = _a.tournamentRecord, eventIds = _a.eventIds, drawIds = _a.drawIds, drawId = _a.drawId, event = _a.event;
    if (Array.isArray(eventIds) && (eventIds === null || eventIds === void 0 ? void 0 : eventIds.length)) {
        var publishState = {};
        try {
            for (var eventIds_1 = __values(eventIds), eventIds_1_1 = eventIds_1.next(); !eventIds_1_1.done; eventIds_1_1 = eventIds_1.next()) {
                var eventId = eventIds_1_1.value;
                if (!isString(eventId))
                    return { error: INVALID_VALUES };
                var event_1 = findEvent({ tournamentRecord: tournamentRecord, eventId: eventId });
                if (!event_1)
                    return { error: EVENT_NOT_FOUND };
                var pubStatus = getPubStatus({ event: event_1 });
                if (pubStatus.error)
                    return pubStatus;
                publishState[eventId] = pubStatus;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (eventIds_1_1 && !eventIds_1_1.done && (_b = eventIds_1.return)) _b.call(eventIds_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return __assign(__assign({}, SUCCESS), { publishState: publishState });
    }
    else if (!event && (tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.events) && Array.isArray(drawIds) && drawIds.length) {
        var publishState = {};
        try {
            for (var _f = __values(tournamentRecord.events), _g = _f.next(); !_g.done; _g = _f.next()) {
                var event_2 = _g.value;
                var pubStatus = getPubStatus({ event: event_2 });
                if (pubStatus.error)
                    return pubStatus;
                try {
                    for (var drawIds_1 = (e_3 = void 0, __values(drawIds)), drawIds_1_1 = drawIds_1.next(); !drawIds_1_1.done; drawIds_1_1 = drawIds_1.next()) {
                        var drawId_1 = drawIds_1_1.value;
                        if (!isString(drawId_1))
                            return { error: INVALID_VALUES };
                        var published = pubStatus.publishState.publishedDrawIds.includes(drawId_1);
                        if (published)
                            publishState[drawId_1] = { published: published };
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (drawIds_1_1 && !drawIds_1_1.done && (_d = drawIds_1.return)) _d.call(drawIds_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return __assign(__assign({}, SUCCESS), { publishState: publishState });
    }
    else if (event) {
        var pubStatus = getPubStatus({ event: event });
        if (pubStatus.error)
            return pubStatus;
        if (drawId) {
            return {
                publishState: __assign({ published: pubStatus.publishState.publishedDrawIds.includes(drawId) }, SUCCESS),
            };
        }
        else if (Array.isArray(drawIds) && (drawIds === null || drawIds === void 0 ? void 0 : drawIds.length)) {
            var publishState = {};
            try {
                for (var drawIds_2 = __values(drawIds), drawIds_2_1 = drawIds_2.next(); !drawIds_2_1.done; drawIds_2_1 = drawIds_2.next()) {
                    var drawId_2 = drawIds_2_1.value;
                    if (!isString(drawId_2))
                        return { error: INVALID_VALUES };
                    publishState[drawId_2] = {
                        published: pubStatus.publishState.publishedDrawIds.includes(drawId_2),
                    };
                    return __assign(__assign({}, SUCCESS), { publishState: publishState });
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (drawIds_2_1 && !drawIds_2_1.done && (_e = drawIds_2.return)) _e.call(drawIds_2);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
        else {
            return pubStatus;
        }
    }
    return { error: INVALID_VALUES };
}
function getPubStatus(_a) {
    var event = _a.event;
    var eventPubStatus = getEventPublishStatus({ event: event });
    if (!eventPubStatus)
        return { error: EVENT_NOT_FOUND };
    var publishedSeeding = {
        published: undefined, // seeding can be present for all entries in an event when no flights have been defined
        seedingScaleNames: [],
        drawIds: [], // seeding can be specific to drawIds
    };
    if (eventPubStatus.seeding) {
        Object.assign(publishedSeeding, eventPubStatus.seeding);
    }
    var drawDetails = eventPubStatus.drawDetails;
    var publishedDrawIds = (drawDetails && Object.keys(drawDetails).filter(function (drawId) { return getDrawPublishStatus({ drawDetails: drawDetails, drawId: drawId }); })) ||
        eventPubStatus.drawIds ||
        [];
    return __assign({ publishState: {
            published: publishedDrawIds.length > 0,
            publishedDrawIds: publishedDrawIds,
            publishedSeeding: publishedSeeding,
            drawDetails: drawDetails,
        } }, SUCCESS);
}

function processEventEntry(_a) {
    var convertExtensions = _a.convertExtensions, seedAssignments = _a.seedAssignments, participant = _a.participant, withSeeding = _a.withSeeding, seedValue = _a.seedValue, eventId = _a.eventId, ranking = _a.ranking, entry = _a.entry;
    var entryStatus = entry.entryStatus, entryStage = entry.entryStage, entryPosition = entry.entryPosition, extensions = entry.extensions;
    var entryExtensions = (extensions === null || extensions === void 0 ? void 0 : extensions.length) && convertExtensions
        ? Object.assign.apply(Object, __spreadArray([{}], __read(extensionsToAttributes(extensions)), false)) : {};
    var attributes = Object.assign(entryExtensions, {
        entryPosition: entryPosition,
        entryStatus: entryStatus,
        entryStage: entryStage,
        ranking: ranking,
        eventId: eventId,
    });
    participant.events[eventId] = definedAttributes(attributes, false, false, true);
    if (withSeeding) {
        if (seedAssignments)
            participant.events[eventId].seedAssignments = seedAssignments;
        if (seedValue)
            participant.events[eventId].seedValue = seedValue;
    }
}

function stringSort(a, b) {
    return (a || '').localeCompare(b || '');
}

function addStructureParticipation(_a) {
    var _b = _a.finishingPositionRange, matchUpFinishingPositionRanges = _b === void 0 ? {} : _b, participantMap = _a.participantMap, finishingRound = _a.finishingRound, participantWon = _a.participantWon, matchUpStatus = _a.matchUpStatus, participantId = _a.participantId, stageSequence = _a.stageSequence, roundNumber = _a.roundNumber, structureId = _a.structureId, matchUpId = _a.matchUpId, drawId = _a.drawId, stage = _a.stage;
    var participantAggregator = participantMap[participantId];
    var diff = function (range) { return Math.abs(range[0] - range[1]); };
    if (!participantAggregator.structureParticipation[structureId]) {
        participantAggregator.structureParticipation[structureId] = {
            rankingStage: stage,
            walkoverWinCount: 0,
            defaultWinCount: 0,
            stageSequence: stageSequence,
            winCount: 0,
            structureId: structureId,
            drawId: drawId,
        };
    }
    var structureParticipation = participantAggregator.structureParticipation[structureId];
    var _c = matchUpFinishingPositionRanges, winner = _c.winner, loser = _c.loser;
    var finishingPositionRange = participantWon ? winner : loser;
    if (participantWon) {
        structureParticipation.winCount += 1;
        if (matchUpStatus === WALKOVER$2) {
            structureParticipation.walkoverWinCount += 1;
        }
        if (matchUpStatus === DEFAULTED) {
            structureParticipation.defaultWinCount += 1;
        }
    }
    if (finishingPositionRange &&
        (!structureParticipation.finishingPositionRange ||
            diff(finishingPositionRange) <
                diff(structureParticipation.finishingPositionRange))) {
        structureParticipation.finishingPositionRange = finishingPositionRange;
    }
    if (finishingRound) {
        if (!structureParticipation.finishingRound ||
            finishingRound < structureParticipation.finishingRound) {
            structureParticipation.finishingMatchUpId = matchUpId;
            structureParticipation.finishingRound = finishingRound;
            structureParticipation.roundNumber = roundNumber;
        }
        if (finishingRound === 1) {
            // participant won the structure
            structureParticipation.participantWon = participantWon;
        }
    }
}

function processSides(params) {
    var e_1, _a;
    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    var withScheduleItems = params.withScheduleItems, scheduleAnalysis = params.scheduleAnalysis, withTeamMatchUps = params.withTeamMatchUps, participantMap = params.participantMap, withOpponents = params.withOpponents, withMatchUps = params.withMatchUps, withEvents = params.withEvents, withDraws = params.withDraws, finishingPositionRange = params.finishingPositionRange, finishingRound = params.finishingRound, matchUpStatus = params.matchUpStatus, stageSequence = params.stageSequence, roundNumber = params.roundNumber, structureId = params.structureId, score = params.score, stage = params.stage, withRankingProfile = params.withRankingProfile, tieWinningSide = params.tieWinningSide, roundPosition = params.roundPosition, matchUpTieId = params.matchUpTieId, matchUpSides = params.matchUpSides, collectionId = params.collectionId, matchUpType = params.matchUpType, winningSide = params.winningSide, matchUpId = params.matchUpId, schedule = params.schedule, eventId = params.eventId, drawId = params.drawId, sides = params.sides;
    var opponents = withOpponents &&
        (sides === null || sides === void 0 ? void 0 : sides.length) === 2 && Object.assign.apply(Object, __spreadArray([{}], __read(sides
        .map(function (_a, i) {
        var _b;
        var sideNumber = _a.sideNumber;
        var opponentParticipantId = sides[1 - i].participantId;
        return (sideNumber && (_b = {},
            _b[sideNumber] = opponentParticipantId,
            _b));
    })
        .filter(Boolean)), false));
    var _loop_1 = function (side) {
        var participantId = side.participantId, sideNumber = side.sideNumber, bye = side.bye;
        if (bye)
            return "continue";
        var participantWon = winningSide === sideNumber;
        var getOpponentInfo = function (opponentParticipantId) {
            var e_2, _a;
            var _b, _c;
            var opponent = (_b = participantMap[opponentParticipantId]) === null || _b === void 0 ? void 0 : _b.participant;
            var participantType = opponent === null || opponent === void 0 ? void 0 : opponent.participantType;
            var info = [
                {
                    participantId: opponentParticipantId,
                    participantType: participantType,
                },
            ];
            if (participantType !== TEAM_PARTICIPANT) {
                try {
                    for (var _d = (e_2 = void 0, __values((opponent === null || opponent === void 0 ? void 0 : opponent.individualParticipantIds) || [])), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var participantId_1 = _e.value;
                        var participant = (_c = participantMap[participantId_1]) === null || _c === void 0 ? void 0 : _c.participant;
                        info.push({
                            participantType: participant === null || participant === void 0 ? void 0 : participant.participantType,
                            participantId: participantId_1,
                        });
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            return info;
        };
        var addMatchUp = function (participantId, opponentParticipantId) {
            if (withMatchUps) {
                participantMap[participantId].matchUps[matchUpId] = {
                    participantWon: participantWon,
                    matchUpType: matchUpType,
                    structureId: structureId,
                    sideNumber: sideNumber,
                    matchUpId: matchUpId,
                    eventId: eventId,
                    drawId: drawId,
                    stage: stage,
                };
                if (withOpponents) {
                    var opponentParticipantInfo = getOpponentInfo(opponentParticipantId);
                    participantMap[participantId].matchUps[matchUpId].opponentParticipantInfo = opponentParticipantInfo;
                }
                if (collectionId) {
                    participantMap[participantId].matchUps[matchUpId].collectionId =
                        collectionId;
                }
            }
            if (withOpponents && opponentParticipantId) {
                participantMap[participantId].opponents[opponentParticipantId] = {
                    participantId: opponentParticipantId,
                    matchUpId: matchUpId,
                    eventId: eventId,
                    drawId: drawId,
                };
            }
            if (withRankingProfile) {
                addStructureParticipation({
                    finishingPositionRange: finishingPositionRange,
                    participantMap: participantMap,
                    participantWon: participantWon,
                    finishingRound: finishingRound,
                    matchUpStatus: matchUpStatus,
                    participantId: participantId,
                    stageSequence: stageSequence,
                    roundNumber: roundNumber,
                    structureId: structureId,
                    matchUpId: matchUpId,
                    drawId: drawId,
                    stage: stage,
                });
            }
            if (scheduleAnalysis || withScheduleItems) {
                addScheduleItem({
                    participantMap: participantMap,
                    participantId: participantId,
                    matchUpStatus: matchUpStatus,
                    roundPosition: roundPosition,
                    matchUpType: matchUpType,
                    roundNumber: roundNumber,
                    structureId: structureId,
                    matchUpId: matchUpId,
                    schedule: schedule,
                    drawId: drawId,
                    score: score,
                });
            }
        };
        var addPartner = function (_a) {
            var _b, _c, _d;
            var participant = _a.participant, partnerParticipantId = _a.partnerParticipantId;
            var addPartnerParticiapntId = function (element, partnerParticipantId) {
                if (element) {
                    if (!element.partnerParticipantIds)
                        element.partnerParticipantIds = [];
                    if (!element.partnerParticipantIds.includes(partnerParticipantId))
                        element.partnerParticipantIds.push(partnerParticipantId);
                }
            };
            if (withDraws)
                addPartnerParticiapntId((_b = participant === null || participant === void 0 ? void 0 : participant.draws) === null || _b === void 0 ? void 0 : _b[drawId], partnerParticipantId);
            if (withEvents) {
                addPartnerParticiapntId((_c = participant === null || participant === void 0 ? void 0 : participant.events) === null || _c === void 0 ? void 0 : _c[eventId], partnerParticipantId);
            }
            if (withMatchUps) {
                addPartnerParticiapntId((_d = participant === null || participant === void 0 ? void 0 : participant.matchUps) === null || _d === void 0 ? void 0 : _d[matchUpId], partnerParticipantId);
            }
        };
        if (participantId && participantMap[participantId]) {
            var opponentParticipantId_1 = opponents === null || opponents === void 0 ? void 0 : opponents[sideNumber];
            addMatchUp(participantId, opponentParticipantId_1);
            var isPair = ((_b = participantMap[participantId]) === null || _b === void 0 ? void 0 : _b.participant.participantType) === PAIR;
            var individualParticipantIds_1 = ((_c = participantMap[participantId]) === null || _c === void 0 ? void 0 : _c.participant.individualParticipantIds) ||
                [];
            if (matchUpTieId) {
                if (withTeamMatchUps) {
                    var addTeamMatchUp = function (participantId) {
                        return (participantMap[participantId].matchUps[matchUpTieId] = {
                            participantWon: tieWinningSide === sideNumber,
                            matchUpId: matchUpTieId,
                            matchUpType: TEAM,
                            sideNumber: sideNumber,
                        });
                    };
                    addTeamMatchUp(participantId);
                    individualParticipantIds_1.forEach(addTeamMatchUp);
                }
                if (withDraws && !participantMap[participantId].draws[drawId]) {
                    var teamParticipantId = (_e = (_d = matchUpSides.find(function (s) { return s.sideNumber === sideNumber; })) === null || _d === void 0 ? void 0 : _d.participant) === null || _e === void 0 ? void 0 : _e.participantId;
                    var teamEntryStatus_1 = (_h = (_g = (_f = participantMap[teamParticipantId]) === null || _f === void 0 ? void 0 : _f.draws) === null || _g === void 0 ? void 0 : _g[drawId]) === null || _h === void 0 ? void 0 : _h.entryStatus;
                    var addDrawData = function (participantId) {
                        return (participantMap[participantId].draws[drawId] = {
                            entryStatus: teamEntryStatus_1,
                            // add positions played in lineUp collections
                            eventId: eventId,
                            drawId: drawId,
                        });
                    };
                    addDrawData(participantId);
                    individualParticipantIds_1.forEach(addDrawData);
                }
            }
            if (isPair) {
                individualParticipantIds_1.forEach(function (participantId) {
                    return participantMap[participantId] &&
                        addMatchUp(participantId, opponentParticipantId_1);
                });
                individualParticipantIds_1.forEach(function (participantId, i) {
                    var partnerParticipantId = individualParticipantIds_1[1 - i];
                    var participant = participantMap[participantId];
                    participant && addPartner({ participant: participant, partnerParticipantId: partnerParticipantId });
                });
                // in TEAM events PAIR participants do not appear in entries
                if (withEvents && matchUpSides) {
                    var teamParticipantId = (_k = (_j = matchUpSides.find(function (s) { return s.sideNumber === sideNumber; })) === null || _j === void 0 ? void 0 : _j.participant) === null || _k === void 0 ? void 0 : _k.participantId;
                    if (teamParticipantId) {
                        var teamEntry_1 = (_l = participantMap[teamParticipantId]) === null || _l === void 0 ? void 0 : _l.events[eventId];
                        if (teamEntry_1) {
                            participantMap[participantId].events[eventId] = __assign({}, teamEntry_1);
                            individualParticipantIds_1.forEach(function (individualParticiapntId) {
                                return (participantMap[individualParticiapntId].events[eventId] = __assign({}, teamEntry_1));
                            });
                        }
                        else {
                            console.log('Missing teamEntry', { eventId: eventId, teamParticipantId: teamParticipantId });
                        }
                    }
                }
            }
            if (winningSide) {
                var processParticipantId = function (id) {
                    if (participantWon) {
                        participantMap[id].counters[matchUpType].wins += 1;
                        participantMap[id].counters.wins += 1;
                        if (matchUpStatus === WALKOVER$2) {
                            participantMap[id].counters[matchUpType].walkoverWins += 1;
                            participantMap[id].counters.walkoverWins += 1;
                        }
                        if (matchUpStatus === DEFAULTED) {
                            participantMap[id].counters[matchUpType].defaultWins += 1;
                            participantMap[id].counters.defaultWins += 1;
                        }
                    }
                    else {
                        participantMap[id].counters[matchUpType].losses += 1;
                        participantMap[id].counters.losses += 1;
                        if (matchUpStatus === WALKOVER$2) {
                            participantMap[id].counters[matchUpType].walkovers += 1;
                            participantMap[id].counters.walkovers += 1;
                        }
                        if (matchUpStatus === DEFAULTED) {
                            participantMap[id].counters[matchUpType].defaults += 1;
                            participantMap[id].counters.defaults += 1;
                        }
                    }
                };
                processParticipantId(participantId);
                individualParticipantIds_1.forEach(processParticipantId);
            }
        }
    };
    try {
        for (var sides_1 = __values(sides), sides_1_1 = sides_1.next(); !sides_1_1.done; sides_1_1 = sides_1.next()) {
            var side = sides_1_1.value;
            _loop_1(side);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (sides_1_1 && !sides_1_1.done && (_a = sides_1.return)) _a.call(sides_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}

function getParticipantEntries(params) {
    var e_1, _a, e_2, _b;
    var _c, _d, _e, _f, _g, _h, _j, _k;
    var participantFilters = params.participantFilters, convertExtensions = params.convertExtensions, policyDefinitions = params.policyDefinitions, tournamentRecord = params.tournamentRecord, usePublishState = params.usePublishState, contextProfile = params.contextProfile, participantMap = params.participantMap, withPotentialMatchUps = params.withPotentialMatchUps, withRankingProfile = params.withRankingProfile, withScheduleItems = params.withScheduleItems, scheduleAnalysis = params.scheduleAnalysis, withTeamMatchUps = params.withTeamMatchUps, withStatistics = params.withStatistics, withOpponents = params.withOpponents, withMatchUps = params.withMatchUps, withSeeding = params.withSeeding, withEvents = params.withEvents, withDraws = params.withDraws;
    var targetParticipantIds = participantFilters === null || participantFilters === void 0 ? void 0 : participantFilters.participantIds;
    var getRelevantParticipantIds = function (participantId) {
        var _a, _b;
        var relevantParticipantIds = [participantId];
        (_b = (_a = participantMap[participantId]) === null || _a === void 0 ? void 0 : _a.participant.individualParticipantIds) === null || _b === void 0 ? void 0 : _b.forEach(function (individualParticiapntId) {
            return relevantParticipantIds.push(individualParticiapntId);
        });
        return relevantParticipantIds.some(function (id) { return !(targetParticipantIds === null || targetParticipantIds === void 0 ? void 0 : targetParticipantIds.length) || targetParticipantIds.includes(id); })
            ? relevantParticipantIds
            : [];
    };
    var withOpts = {
        withMatchUps: withMatchUps || withRankingProfile,
        withEvents: withEvents || withRankingProfile,
        withDraws: withDraws || withRankingProfile,
        withPotentialMatchUps: withPotentialMatchUps,
        withRankingProfile: withRankingProfile,
        withScheduleItems: withScheduleItems,
        scheduleAnalysis: scheduleAnalysis,
        withTeamMatchUps: withTeamMatchUps,
        withStatistics: withStatistics,
        participantMap: participantMap,
        withOpponents: withOpponents,
        withSeeding: withSeeding,
    };
    var participantIdsWithConflicts = [];
    var mappedMatchUps = {};
    var matchUps = [];
    var eventsPublishStatuses = {};
    var derivedEventInfo = {};
    var derivedDrawInfo = {};
    var getRanking = function (_a) {
        var _b, _c, _d, _e;
        var eventType = _a.eventType, scaleNames = _a.scaleNames, participantId = _a.participantId;
        return (_e = (_d = (_c = (_b = participantMap[participantId].participant) === null || _b === void 0 ? void 0 : _b.rankings) === null || _c === void 0 ? void 0 : _c[eventType]) === null || _d === void 0 ? void 0 : _d.find(function (ranking) {
            return scaleNames.includes(ranking.scaleName);
        })) === null || _e === void 0 ? void 0 : _e.scaleValue;
    };
    var _loop_1 = function (event_1) {
        var e_3, _o, e_4, _p, e_5, _q;
        if ((participantFilters === null || participantFilters === void 0 ? void 0 : participantFilters.eventIds) && !participantFilters.eventIds.includes(event_1.eventId))
            return "continue";
        var _r = event_1.drawDefinitions, drawDefinitions = _r === void 0 ? [] : _r, _s = event_1.extensions, extensions = _s === void 0 ? [] : _s, eventType = event_1.eventType, eventName = event_1.eventName, category = event_1.category, entries = event_1.entries, eventId = event_1.eventId, gender = event_1.gender;
        var flightProfile = getFlightProfile({ event: event_1 }).flightProfile;
        var flights = (_c = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) !== null && _c !== void 0 ? _c : [];
        var publishStatuses = getPublishState({ event: event_1 }).publishState;
        if (publishStatuses)
            eventsPublishStatuses[eventId] = publishStatuses;
        var publishedSeeding = publishStatuses === null || publishStatuses === void 0 ? void 0 : publishStatuses.publishedSeeding;
        if (withEvents || withSeeding || withRankingProfile) {
            var extensionConversions = convertExtensions ? Object.assign.apply(Object, __spreadArray([{}], __read(extensionsToAttributes(extensions)), false)) : {};
            derivedEventInfo[eventId] = __assign(__assign({}, extensionConversions), { eventName: eventName, eventType: eventType, category: category, eventId: eventId, gender: gender });
            var scaleNames = [category === null || category === void 0 ? void 0 : category.categoryName, category === null || category === void 0 ? void 0 : category.ageCategoryCode].filter(Boolean);
            var _loop_3 = function (entry) {
                var _t;
                var participantId = entry.participantId;
                if (!participantId || !participantMap[participantId])
                    return "continue"; // handle bad data
                // get event ranking; this is the same for pairs, teams and all individual participants
                var ranking = getRanking({ eventType: eventType, scaleNames: scaleNames, participantId: participantId });
                var seedAssignments, seedValue;
                if (withSeeding) {
                    var participant = participantMap[participantId].participant;
                    (_t = getEventSeedAssignments({
                        publishedSeeding: publishedSeeding,
                        usePublishState: usePublishState,
                        withSeeding: withSeeding,
                        participant: participant,
                        event: event_1,
                    }), seedAssignments = _t.seedAssignments, seedValue = _t.seedValue);
                }
                // IMPORTANT NOTE!
                // id is the pair, team or individual participant currently being processed
                // whereas participantId is the id of the entry into the event
                var addEventEntry = function (id) {
                    var _a, _b;
                    if ((_b = (_a = participantMap[id]) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b[eventId])
                        return;
                    var participant = participantMap[id];
                    processEventEntry({
                        convertExtensions: convertExtensions,
                        seedAssignments: seedAssignments,
                        participant: participant,
                        withSeeding: withSeeding,
                        seedValue: seedValue,
                        eventId: eventId,
                        ranking: ranking,
                        entry: entry,
                    });
                };
                addEventEntry(participantId);
                // add details for individualParticipantIds for TEAM/PAIR events
                var individualParticipantIds = participantMap[participantId].participant.individualParticipantIds || [];
                individualParticipantIds.forEach(addEventEntry);
            };
            try {
                for (var entries_1 = (e_3 = void 0, __values(entries)), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                    var entry = entries_1_1.value;
                    _loop_3(entry);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (entries_1_1 && !entries_1_1.done && (_o = entries_1.return)) _o.call(entries_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        var eventPublishedSeeding = (_d = eventsPublishStatuses === null || eventsPublishStatuses === void 0 ? void 0 : eventsPublishStatuses[eventId]) === null || _d === void 0 ? void 0 : _d.publishedSeeding;
        if (withDraws || withRankingProfile || withSeeding) {
            var getSeedingMap = function (assignments) {
                return assignments
                    ? Object.assign.apply(Object, __spreadArray([{}], __read(assignments.map(function (_a) {
                        var _b;
                        var participantId = _a.participantId, seedValue = _a.seedValue, seedNumber = _a.seedNumber;
                        return (_b = {},
                            _b[participantId] = { seedValue: seedValue, seedNumber: seedNumber },
                            _b);
                    })), false)) : undefined;
            };
            var drawIds = unique(__spreadArray(__spreadArray([], __read(drawDefinitions.map(xa('drawId'))), false), __read(flights.map(xa('drawId'))), false));
            var _loop_4 = function (drawId) {
                var e_6, _u;
                var drawDefinition = drawDefinitions.find(function (drawDefinition) { return drawDefinition.drawId === drawId; });
                var flight = flights === null || flights === void 0 ? void 0 : flights.find(function (flight) { return flight.drawId === drawId; });
                var entries_2 = (drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) || (flight === null || flight === void 0 ? void 0 : flight.drawEntries);
                var _v = drawDefinition !== null && drawDefinition !== void 0 ? drawDefinition : {}, _w = _v.structures, structures = _w === void 0 ? [] : _w, drawOrder = _v.drawOrder, drawName = _v.drawName, drawType = _v.drawType;
                var flightNumber = flight === null || flight === void 0 ? void 0 : flight.flightNumber;
                var scaleNames = [category === null || category === void 0 ? void 0 : category.categoryName, category === null || category === void 0 ? void 0 : category.ageCategoryCode].filter(Boolean);
                // used in rankings pipeline.
                // the structures in which a particpant particpates are ordered
                // to enable differentiation for Points-per-round and points-per-win
                var orderedStructureIds = ((drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) || [])
                    .sort(function (a, b) { return structureSort(a, b); })
                    .map(function (_a) {
                    var structureId = _a.structureId, structures = _a.structures;
                    return __spreadArray([structureId], __read((structures || []).map(function (_a) {
                        var structureId = _a.structureId;
                        return structureId;
                    })), false);
                })
                    .flat(Infinity);
                var qualifyingPositionAssignments, qualifyingSeedAssignments, mainPositionAssignments, mainSeedAssignments, drawSize = 0;
                // build up assignedParticipantIds array
                // to ensure that only assignedParticipants are included
                var assignedParticipantIds = structures
                    .filter(function (_a) {
                    var stage = _a.stage, stageSequence = _a.stageSequence;
                    return (stage === MAIN && stageSequence === 1) || stage === QUALIFYING;
                })
                    .flatMap(function (structure) {
                    var _a;
                    var seedAssignments = structure.seedAssignments, stageSequence = structure.stageSequence, stage = structure.stage;
                    var positionAssignments = getPositionAssignments$1({
                        structure: structure,
                    }).positionAssignments;
                    if (stage === MAIN) {
                        drawSize = (_a = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.length) !== null && _a !== void 0 ? _a : 0;
                        mainPositionAssignments = positionAssignments;
                        mainSeedAssignments = seedAssignments;
                    }
                    else if (stageSequence === 1) {
                        qualifyingPositionAssignments = positionAssignments;
                        qualifyingSeedAssignments = seedAssignments;
                    }
                    return positionAssignments;
                })
                    .map(function (_a) {
                    var participantId = _a.participantId;
                    return participantId;
                })
                    .filter(Boolean);
                var mainSeedingMap = getSeedingMap(mainSeedAssignments);
                var qualifyingSeedingMap = getSeedingMap(qualifyingSeedAssignments);
                var relevantEntries = !drawDefinition
                    ? entries_2
                    : entries_2.filter(function (_a) {
                        var participantId = _a.participantId;
                        return assignedParticipantIds.includes(participantId);
                    });
                var seedingPublished = !usePublishState ||
                    ((eventPublishedSeeding === null || eventPublishedSeeding === void 0 ? void 0 : eventPublishedSeeding.published) &&
                        (((_e = eventPublishedSeeding === null || eventPublishedSeeding === void 0 ? void 0 : eventPublishedSeeding.drawIds) === null || _e === void 0 ? void 0 : _e.length) === 0 || ((_f = eventPublishedSeeding === null || eventPublishedSeeding === void 0 ? void 0 : eventPublishedSeeding.drawIds) === null || _f === void 0 ? void 0 : _f.includes(drawId))));
                var _loop_6 = function (entry) {
                    var entryStatus = entry.entryStatus, entryStage = entry.entryStage, entryPosition = entry.entryPosition, participantId = entry.participantId;
                    // get event ranking
                    var ranking = getRanking({
                        participantId: participantId,
                        scaleNames: scaleNames,
                        eventType: eventType,
                    });
                    // IMPORTANT NOTE!
                    // id is the pair, team or individual participant currently being processed
                    // whereas participantId is the id of the entry into the draw
                    var addDrawEntry = function (id) {
                        var _a, _b, _c, _d, _e;
                        if ((_a = participantMap[id].draws) === null || _a === void 0 ? void 0 : _a[drawId])
                            return;
                        var includeSeeding = withSeeding && seedingPublished;
                        var seedAssignments = includeSeeding ? {} : undefined;
                        var mainSeeding = includeSeeding
                            ? ((_b = mainSeedingMap === null || mainSeedingMap === void 0 ? void 0 : mainSeedingMap[participantId]) === null || _b === void 0 ? void 0 : _b.seedValue) || ((_c = mainSeedingMap === null || mainSeedingMap === void 0 ? void 0 : mainSeedingMap[participantId]) === null || _c === void 0 ? void 0 : _c.seedNumber)
                            : undefined;
                        var mainSeedingAssignments = mainSeeding ? mainSeedingMap === null || mainSeedingMap === void 0 ? void 0 : mainSeedingMap[participantId] : undefined;
                        var qualifyingSeeding = includeSeeding
                            ? ((_d = qualifyingSeedingMap === null || qualifyingSeedingMap === void 0 ? void 0 : qualifyingSeedingMap[participantId]) === null || _d === void 0 ? void 0 : _d.seedValue) || ((_e = qualifyingSeedingMap === null || qualifyingSeedingMap === void 0 ? void 0 : qualifyingSeedingMap[participantId]) === null || _e === void 0 ? void 0 : _e.seedNumber)
                            : undefined;
                        var qualifyingSeedingAssignments = qualifyingSeeding ? qualifyingSeedingMap === null || qualifyingSeedingMap === void 0 ? void 0 : qualifyingSeedingMap[participantId] : undefined;
                        if (seedAssignments && mainSeeding)
                            seedAssignments[MAIN] = mainSeedingAssignments;
                        if (seedAssignments && qualifyingSeeding)
                            seedAssignments[QUALIFYING] = qualifyingSeedingAssignments;
                        var seedValue = mainSeeding || qualifyingSeeding;
                        if (seedValue) {
                            if (!participantMap[id].participant.seedings[eventType])
                                participantMap[id].participant.seedings[eventType] = [];
                            if (mainSeedingAssignments) {
                                participantMap[id].participant.seedings[eventType].push(__assign(__assign({}, mainSeedingAssignments), { scaleName: drawId }));
                            }
                            if (qualifyingSeedingAssignments) {
                                participantMap[id].participant.seedings[eventType].push(__assign(__assign({}, qualifyingSeedingAssignments), { scaleName: drawId }));
                            }
                            if (seedAssignments) {
                                if (!participantMap[id].events[eventId].seedAssignments)
                                    participantMap[id].events[eventId].seedAssignments = {};
                                Object.keys(seedAssignments).forEach(function (stage) { return (participantMap[id].events[eventId].seedAssignments[stage] = seedAssignments[stage]); });
                            }
                        }
                        if (withDraws || withRankingProfile) {
                            participantMap[id].draws[drawId] = definedAttributes({
                                seedAssignments: seedAssignments,
                                entryPosition: entryPosition,
                                entryStatus: entryStatus,
                                entryStage: entryStage,
                                seedValue: seedValue,
                                eventId: eventId,
                                ranking: ranking,
                                drawId: drawId,
                            }, false, false, true);
                        }
                    };
                    if (![UNGROUPED, UNPAIRED].includes(entryStatus)) {
                        addDrawEntry(participantId);
                        var individualParticipantIds = participantMap[participantId].participant.individualParticipantIds || [];
                        // add for individualParticipantIds when participantType is TEAM/PAIR
                        individualParticipantIds === null || individualParticipantIds === void 0 ? void 0 : individualParticipantIds.forEach(addDrawEntry);
                    }
                };
                try {
                    for (var relevantEntries_1 = (e_6 = void 0, __values(relevantEntries)), relevantEntries_1_1 = relevantEntries_1.next(); !relevantEntries_1_1.done; relevantEntries_1_1 = relevantEntries_1.next()) {
                        var entry = relevantEntries_1_1.value;
                        _loop_6(entry);
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (relevantEntries_1_1 && !relevantEntries_1_1.done && (_u = relevantEntries_1.return)) _u.call(relevantEntries_1);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
                var stages = ((_g = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) !== null && _g !== void 0 ? _g : []).reduce(function (stages, structure) {
                    if (!stages.includes(structure.stage))
                        stages.push(structure.stage);
                    return stages;
                }, []);
                var linksCount = ((_h = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.links) !== null && _h !== void 0 ? _h : []).length;
                derivedDrawInfo[drawId] = {
                    qualifyingPositionAssignments: qualifyingPositionAssignments,
                    qualifyingSeedAssignments: qualifyingSeedAssignments,
                    mainPositionAssignments: mainPositionAssignments,
                    qualifyingSeedingMap: qualifyingSeedingMap,
                    mainSeedAssignments: mainSeedAssignments,
                    orderedStructureIds: orderedStructureIds,
                    mainSeedingMap: mainSeedingMap,
                    flightNumber: flightNumber,
                    linksCount: linksCount,
                    drawOrder: drawOrder,
                    drawName: drawName,
                    drawType: drawType,
                    drawSize: drawSize,
                    drawId: drawId,
                    stages: stages,
                    // qualifyingDrawSize,
                };
            };
            try {
                for (var drawIds_1 = (e_4 = void 0, __values(drawIds)), drawIds_1_1 = drawIds_1.next(); !drawIds_1_1.done; drawIds_1_1 = drawIds_1.next()) {
                    var drawId = drawIds_1_1.value;
                    _loop_4(drawId);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (drawIds_1_1 && !drawIds_1_1.done && (_p = drawIds_1.return)) _p.call(drawIds_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
        if (withRankingProfile ||
            scheduleAnalysis ||
            withTeamMatchUps ||
            withStatistics ||
            withOpponents ||
            withMatchUps ||
            withDraws) {
            var nextMatchUps = !!scheduleAnalysis || withPotentialMatchUps;
            var eventMatchUps = (_k = (_j = allEventMatchUps({
                afterRecoveryTimes: !!scheduleAnalysis,
                policyDefinitions: policyDefinitions,
                tournamentRecord: tournamentRecord,
                inContext: true,
                contextProfile: contextProfile,
                participantMap: participantMap,
                nextMatchUps: nextMatchUps,
                event: event_1,
            })) === null || _j === void 0 ? void 0 : _j.matchUps) !== null && _k !== void 0 ? _k : [];
            var _loop_5 = function (matchUp) {
                var e_7, _x;
                var finishingPositionRange = matchUp.finishingPositionRange, potentialParticipants = matchUp.potentialParticipants, _y = matchUp.tieMatchUps, tieMatchUps = _y === void 0 ? [] : _y, _z = matchUp.sides, sides = _z === void 0 ? [] : _z, winningSide = matchUp.winningSide, matchUpType = matchUp.matchUpType, matchUpId = matchUp.matchUpId, eventId_1 = matchUp.eventId, drawId = matchUp.drawId, collectionId = matchUp.collectionId, stageSequence = matchUp.stageSequence, finishingRound = matchUp.finishingRound, matchUpStatus = matchUp.matchUpStatus, roundPosition = matchUp.roundPosition, roundNumber = matchUp.roundNumber, structureId = matchUp.structureId, schedule = matchUp.schedule, score = matchUp.score, stage = matchUp.stage;
                mappedMatchUps[matchUpId] = matchUp;
                var baseAttrs = {
                    finishingPositionRange: finishingPositionRange,
                    finishingRound: finishingRound,
                    stageSequence: stageSequence,
                    roundPosition: roundPosition,
                    collectionId: collectionId,
                    roundNumber: roundNumber,
                    structureId: structureId,
                    schedule: schedule,
                    eventId: eventId_1,
                    drawId: drawId,
                    score: score,
                    stage: stage,
                };
                processSides(__assign(__assign(__assign({}, baseAttrs), withOpts), { matchUpStatus: matchUpStatus, winningSide: winningSide, matchUpType: matchUpType, matchUpId: matchUpId, sides: sides }));
                try {
                    for (var tieMatchUps_1 = (e_7 = void 0, __values(tieMatchUps)), tieMatchUps_1_1 = tieMatchUps_1.next(); !tieMatchUps_1_1.done; tieMatchUps_1_1 = tieMatchUps_1.next()) {
                        var tieMatchUp = tieMatchUps_1_1.value;
                        var tieMatchUpWinningSide = tieMatchUp.winningSide, _0 = tieMatchUp.sides, tieMatchUpSides = _0 === void 0 ? [] : _0, tieMatchUpId = tieMatchUp.matchUpId, matchUpStatus_1 = tieMatchUp.matchUpStatus, matchUpType_1 = tieMatchUp.matchUpType;
                        processSides(__assign(__assign(__assign({}, baseAttrs), withOpts), { winningSide: tieMatchUpWinningSide, tieWinningSide: winningSide, matchUpTieId: matchUpId, matchUpId: tieMatchUpId, sides: tieMatchUpSides, matchUpSides: sides, matchUpStatus: matchUpStatus_1, matchUpType: matchUpType_1 }));
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (tieMatchUps_1_1 && !tieMatchUps_1_1.done && (_x = tieMatchUps_1.return)) _x.call(tieMatchUps_1);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
                if (Array.isArray(potentialParticipants) && (nextMatchUps || !!scheduleAnalysis || withScheduleItems)) {
                    var potentialParticipantIds = potentialParticipants.flat().map(xa('participantId')).filter(Boolean);
                    potentialParticipantIds === null || potentialParticipantIds === void 0 ? void 0 : potentialParticipantIds.forEach(function (participantId) {
                        var relevantParticipantIds = getRelevantParticipantIds(participantId);
                        relevantParticipantIds === null || relevantParticipantIds === void 0 ? void 0 : relevantParticipantIds.forEach(function (relevantParticipantId) {
                            if (!participantMap[relevantParticipantId]) {
                                return;
                            }
                            participantMap[relevantParticipantId].potentialMatchUps[matchUpId] = definedAttributes({
                                tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                                matchUpId: matchUpId,
                                eventId: eventId_1,
                                drawId: drawId,
                            });
                        });
                        if (!!scheduleAnalysis || withScheduleItems) {
                            addScheduleItem({
                                potential: true,
                                participantMap: participantMap,
                                participantId: participantId,
                                matchUpStatus: matchUpStatus,
                                roundPosition: roundPosition,
                                structureId: structureId,
                                matchUpType: matchUpType,
                                roundNumber: roundNumber,
                                matchUpId: matchUpId,
                                schedule: schedule,
                                drawId: drawId,
                                score: score,
                            });
                        }
                    });
                }
            };
            try {
                for (var eventMatchUps_1 = (e_5 = void 0, __values(eventMatchUps)), eventMatchUps_1_1 = eventMatchUps_1.next(); !eventMatchUps_1_1.done; eventMatchUps_1_1 = eventMatchUps_1.next()) {
                    var matchUp = eventMatchUps_1_1.value;
                    _loop_5(matchUp);
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (eventMatchUps_1_1 && !eventMatchUps_1_1.done && (_q = eventMatchUps_1.return)) _q.call(eventMatchUps_1);
                }
                finally { if (e_5) throw e_5.error; }
            }
            matchUps.push.apply(matchUps, __spreadArray([], __read(eventMatchUps), false));
        }
    };
    try {
        for (var _l = __values((tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.events) || []), _m = _l.next(); !_m.done; _m = _l.next()) {
            var event_1 = _m.value;
            _loop_1(event_1);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_m && !_m.done && (_a = _l.return)) _a.call(_l);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (withStatistics || withRankingProfile || !!scheduleAnalysis) {
        var aggregators = Object.values(participantMap);
        var _loop_2 = function (participantAggregator) {
            var e_8, _1, e_9, _2, e_10, _3;
            var _4 = participantAggregator.counters, wins = _4.wins, losses = _4.losses, _5 = SINGLES, _6 = _4[_5], singlesWins = _6.wins, singlesLosses = _6.losses, _7 = DOUBLES, _8 = _4[_7], doublesWins = _8.wins, doublesLosses = _8.losses;
            var addStatValue = function (statCode, wins, losses) {
                var denominator = wins + losses;
                var numerator = wins;
                var statValue = denominator && numerator / denominator;
                participantAggregator.statistics[statCode] = {
                    denominator: denominator,
                    numerator: numerator,
                    statValue: statValue,
                    statCode: statCode,
                };
            };
            if (withStatistics) {
                addStatValue(WIN_RATIO, wins, losses);
                addStatValue("".concat(WIN_RATIO, ".").concat(SINGLES), singlesWins, singlesLosses);
                addStatValue("".concat(WIN_RATIO, ".").concat(DOUBLES), doublesWins, doublesLosses);
            }
            if (withRankingProfile) {
                var diff_1 = function (range) {
                    if (range === void 0) { range = []; }
                    return Math.abs(range[0] - range[1]);
                };
                var _loop_7 = function (drawId) {
                    var _11 = derivedDrawInfo[drawId] || {}, _12 = _11.orderedStructureIds, orderedStructureIds = _12 === void 0 ? [] : _12, flightNumber = _11.flightNumber;
                    if (participantAggregator.structureParticipation && orderedStructureIds.length) {
                        var finishingPositionRange_1;
                        var nonQualifyingOrder_1 = 0;
                        // structures in which a participant participants/exits
                        var orderedParticipation = orderedStructureIds
                            .map(function (structureId) {
                            var participation = participantAggregator.structureParticipation[structureId];
                            if (!participation)
                                return;
                            if (!finishingPositionRange_1)
                                finishingPositionRange_1 = participation === null || participation === void 0 ? void 0 : participation.finishingPositionRange;
                            if (diff_1(finishingPositionRange_1) > diff_1(participation === null || participation === void 0 ? void 0 : participation.finishingPositionRange))
                                finishingPositionRange_1 = participation === null || participation === void 0 ? void 0 : participation.finishingPositionRange;
                            var notQualifying = participation.stage !== QUALIFYING;
                            if (notQualifying)
                                nonQualifyingOrder_1 += 1;
                            var participationOrder = notQualifying ? nonQualifyingOrder_1 : undefined;
                            return definedAttributes(__assign(__assign({}, participation), { participationOrder: participationOrder, flightNumber: flightNumber }));
                        })
                            .filter(Boolean);
                        if (participantAggregator.draws[drawId]) {
                            participantAggregator.draws[drawId].finishingPositionRange = finishingPositionRange_1;
                            participantAggregator.draws[drawId].structureParticipation = orderedParticipation;
                        }
                    }
                };
                try {
                    for (var _9 = (e_8 = void 0, __values(Object.keys(participantAggregator.draws))), _10 = _9.next(); !_10.done; _10 = _9.next()) {
                        var drawId = _10.value;
                        _loop_7(drawId);
                    }
                }
                catch (e_8_1) { e_8 = { error: e_8_1 }; }
                finally {
                    try {
                        if (_10 && !_10.done && (_1 = _9.return)) _1.call(_9);
                    }
                    finally { if (e_8) throw e_8.error; }
                }
            }
            if (scheduleAnalysis) {
                var scheduledMinutesDifference = isObject(scheduleAnalysis) ? scheduleAnalysis.scheduledMinutesDifference : 0;
                // iterate through participantAggregator.scheduleItems
                var scheduleItems = participantAggregator.scheduleItems || [];
                var potentialMatchUps = participantAggregator.potentialMatchUps || {};
                var dateItems = scheduleItems.reduce(function (dateItems, scheduleItem) {
                    var scheduledDate = scheduleItem.scheduledDate, scheduledTime = scheduleItem.scheduledTime;
                    if (!dateItems[scheduledDate])
                        dateItems[scheduledDate] = [];
                    if (scheduledTime)
                        dateItems[scheduledDate].push(scheduleItem);
                    return dateItems;
                }, {});
                // sort scheduleItems for each date
                Object.values(dateItems).forEach(function (items) { return items.sort(timeSort); });
                try {
                    for (var scheduleItems_1 = (e_9 = void 0, __values(scheduleItems)), scheduleItems_1_1 = scheduleItems_1.next(); !scheduleItems_1_1.done; scheduleItems_1_1 = scheduleItems_1.next()) {
                        var scheduleItem = scheduleItems_1_1.value;
                        var typeChangeTimeAfterRecovery = scheduleItem.typeChangeTimeAfterRecovery, timeAfterRecovery = scheduleItem.timeAfterRecovery, scheduledDate = scheduleItem.scheduledDate, scheduledTime = scheduleItem.scheduledTime;
                        var scheduleItemsToConsider = dateItems[scheduledDate];
                        var scheduledMinutes = timeStringMinutes(scheduledTime);
                        try {
                            for (var scheduleItemsToConsider_1 = (e_10 = void 0, __values(scheduleItemsToConsider)), scheduleItemsToConsider_1_1 = scheduleItemsToConsider_1.next(); !scheduleItemsToConsider_1_1.done; scheduleItemsToConsider_1_1 = scheduleItemsToConsider_1.next()) {
                                var consideredItem = scheduleItemsToConsider_1_1.value;
                                var ignoreItem = consideredItem.matchUpId === scheduleItem.matchUpId ||
                                    ([WALKOVER$2, DEFAULTED].includes(consideredItem.matchUpStatus) && !consideredItem.checkScoreHasValue);
                                if (ignoreItem)
                                    continue;
                                // if there is a matchType change (SINGLES => DOUBLES or vice versa) then there is potentially a different timeAfterRecovery
                                var typeChange = scheduleItem.matchUpType !== consideredItem.matchUpType;
                                var notBeforeTime = typeChange ? typeChangeTimeAfterRecovery || timeAfterRecovery : timeAfterRecovery;
                                // if two matchUps are both potentials and both part of the same draw they cannot be considered in conflict
                                var sameDraw = scheduleItem.drawId === consideredItem.drawId;
                                var bothPotential = potentialMatchUps[scheduleItem.matchUpId] && potentialMatchUps[consideredItem.matchUpId];
                                var consideredMinutes = timeStringMinutes(consideredItem.scheduledTime);
                                var minutesDifference = Math.abs(consideredMinutes - scheduledMinutes);
                                var itemIsPrior = consideredMinutes >= scheduledMinutes;
                                // Conflicts can be determined in two ways:
                                // 1. scheduledMinutesDifference - the minutes difference between two scheduledTimes
                                // 2. A scheduledTime occurring before a prior matchUps notBeforeTime (timeAfterRecovery)
                                var timeOverlap = scheduledMinutesDifference && !isNaN(scheduledMinutesDifference)
                                    ? minutesDifference <= scheduledMinutesDifference
                                    : itemIsPrior && timeStringMinutes(consideredItem.scheduledTime) < timeStringMinutes(notBeforeTime);
                                // if there is a time overlap capture both the prior matchUpId and the conflicted matchUpId
                                if (timeOverlap && !(bothPotential && sameDraw) && itemIsPrior) {
                                    var key = [scheduleItem.matchUpId, consideredItem.matchUpId].sort(stringSort).join('|');
                                    participantAggregator.scheduleConflicts[key] = {
                                        priorScheduledMatchUpId: scheduleItem.matchUpId,
                                        matchUpIdWithConflict: consideredItem.matchUpId,
                                    };
                                }
                            }
                        }
                        catch (e_10_1) { e_10 = { error: e_10_1 }; }
                        finally {
                            try {
                                if (scheduleItemsToConsider_1_1 && !scheduleItemsToConsider_1_1.done && (_3 = scheduleItemsToConsider_1.return)) _3.call(scheduleItemsToConsider_1);
                            }
                            finally { if (e_10) throw e_10.error; }
                        }
                    }
                }
                catch (e_9_1) { e_9 = { error: e_9_1 }; }
                finally {
                    try {
                        if (scheduleItems_1_1 && !scheduleItems_1_1.done && (_2 = scheduleItems_1.return)) _2.call(scheduleItems_1);
                    }
                    finally { if (e_9) throw e_9.error; }
                }
                var pid = participantAggregator.participant.participantId;
                if (Object.keys(participantAggregator.scheduleConflicts).length) {
                    participantIdsWithConflicts.push(pid);
                }
                participantMap[pid].scheduleConflicts = participantAggregator.scheduleConflicts;
            }
        };
        try {
            for (var aggregators_1 = __values(aggregators), aggregators_1_1 = aggregators_1.next(); !aggregators_1_1.done; aggregators_1_1 = aggregators_1.next()) {
                var participantAggregator = aggregators_1_1.value;
                _loop_2(participantAggregator);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (aggregators_1_1 && !aggregators_1_1.done && (_b = aggregators_1.return)) _b.call(aggregators_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    return {
        participantIdsWithConflicts: participantIdsWithConflicts,
        eventsPublishStatuses: eventsPublishStatuses,
        derivedEventInfo: derivedEventInfo,
        derivedDrawInfo: derivedDrawInfo,
        mappedMatchUps: mappedMatchUps,
        participantMap: participantMap,
        matchUps: matchUps,
    };
}

function filterParticipants(_a) {
    var _b;
    var _c = _a.participantFilters, participantFilters = _c === void 0 ? {} : _c, tournamentRecord = _a.tournamentRecord, _d = _a.participants, participants = _d === void 0 ? [] : _d;
    if (!Object.keys(participantFilters).length) {
        return participants;
    }
    var accessorValues = participantFilters.accessorValues, drawEntryStatuses = participantFilters.drawEntryStatuses, // {string[]} participantIds that are in draw.entries or flightProfile.flights[].drawEnteredParticipantIds with entryStatuses
    positionedParticipants = participantFilters.positionedParticipants, // boolean - participantIds that are included in any structure.positionAssignments
    eventEntryStatuses = participantFilters.eventEntryStatuses, // {string[]} participantIds that are in entry.entries with entryStatuses
    participantRoles = participantFilters.participantRoles, participantRoleResponsibilities = participantFilters.participantRoleResponsibilities, participantTypes = participantFilters.participantTypes, participantIds = participantFilters.participantIds, signInStatus = participantFilters.signInStatus, enableOrFiltering = participantFilters.enableOrFiltering, eventIds = participantFilters.eventIds, genders = participantFilters.genders;
    var tournamentEvents = (isValidFilterArray(eventIds) &&
        ((_b = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.events) === null || _b === void 0 ? void 0 : _b.filter(function (event) { return eventIds === null || eventIds === void 0 ? void 0 : eventIds.includes(event.eventId); }))) ||
        (tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.events) ||
        [];
    var drawEnteredParticipantIds = drawEntryStatuses &&
        getDrawEntries({ drawEntryStatuses: drawEntryStatuses, tournamentEvents: tournamentEvents });
    var eventEnteredParticipantIds = eventEntryStatuses &&
        getEventEntries({ eventEntryStatuses: eventEntryStatuses, tournamentEvents: tournamentEvents });
    var positionedParticipantIds = positionedParticipants !== undefined &&
        [true, false].includes(positionedParticipants) &&
        tournamentEvents.reduce(function (participantIds, event) {
            return participantIds.concat.apply(participantIds, __spreadArray([], __read((event.drawDefinitions || [])
                .map(function (drawDefinition) {
                return getAllPositionedParticipantIds({ drawDefinition: drawDefinition })
                    .allPositionedParticipantIds;
            })
                .filter(Boolean)), false));
        }, []);
    var participantHasAccessorValues = function (participant) {
        return accessorValues === null || accessorValues === void 0 ? void 0 : accessorValues.reduce(function (hasValues, keyValue) {
            var accessor = keyValue.accessor, value = keyValue.value;
            var values = getAccessorValue({
                element: participant,
                accessor: accessor,
            }).values;
            return hasValues && (values === null || values === void 0 ? void 0 : values.includes(value));
        }, true);
    };
    participants = participants === null || participants === void 0 ? void 0 : participants.filter(function (participant) {
        var _a, _b;
        var participantSignInStatus = (_b = (_a = getTimeItem({
            element: participant,
            itemType: SIGN_IN_STATUS,
        })) === null || _a === void 0 ? void 0 : _a.timeItem) === null || _b === void 0 ? void 0 : _b.itemValue;
        var responsibilities = participant.participantRoleResponsibilities, participantType = participant.participantType, participantRole = participant.participantRole, participantId = participant.participantId, person = participant.person;
        var hasGender = Array.isArray(genders) &&
            (genders === null || genders === void 0 ? void 0 : genders.length) &&
            (person === null || person === void 0 ? void 0 : person.sex) &&
            genders.includes(person.sex);
        if (enableOrFiltering) {
            return ((genders && hasGender) ||
                (positionedParticipants &&
                    positionedParticipantIds.includes(participantId)) ||
                (positionedParticipants === false &&
                    !positionedParticipantIds.includes(participantId)) ||
                (drawEnteredParticipantIds === null || drawEnteredParticipantIds === void 0 ? void 0 : drawEnteredParticipantIds.includes(participantId)) ||
                (eventEnteredParticipantIds === null || eventEnteredParticipantIds === void 0 ? void 0 : eventEnteredParticipantIds.includes(participantId)) ||
                (participantIds === null || participantIds === void 0 ? void 0 : participantIds.includes(participantId)) ||
                (signInStatus && participantSignInStatus === signInStatus) ||
                (participantTypes &&
                    participantType &&
                    isValidFilterArray(participantTypes) &&
                    participantTypes.includes(participantType)) ||
                (participantRoles &&
                    participantRole &&
                    isValidFilterArray(participantRoles) &&
                    participantRoles.includes(participantRole)) ||
                (participantRoleResponsibilities &&
                    isValidFilterArray(responsibilities) &&
                    isValidFilterArray(participantRoleResponsibilities) &&
                    participantRoleResponsibilities.find(function (roleResponsbility) { return responsibilities === null || responsibilities === void 0 ? void 0 : responsibilities.includes(roleResponsbility); })) ||
                ((accessorValues === null || accessorValues === void 0 ? void 0 : accessorValues.length) &&
                    isValidFilterArray(accessorValues) &&
                    participantHasAccessorValues(participant)));
        }
        else {
            return ((!genders || hasGender) &&
                (positionedParticipants === undefined ||
                    (positionedParticipants &&
                        positionedParticipantIds.includes(participantId)) ||
                    (positionedParticipants === false &&
                        !positionedParticipantIds.includes(participantId))) &&
                (!drawEnteredParticipantIds ||
                    drawEnteredParticipantIds.includes(participantId)) &&
                (!eventEnteredParticipantIds ||
                    eventEnteredParticipantIds.includes(participantId)) &&
                (!participantIds || participantIds.includes(participantId)) &&
                (!signInStatus || participantSignInStatus === signInStatus) &&
                (!participantTypes ||
                    (participantType &&
                        isValidFilterArray(participantTypes) &&
                        participantTypes.includes(participantType))) &&
                (!participantRoles ||
                    (participantRole &&
                        isValidFilterArray(participantRoles) &&
                        participantRoles.includes(participantRole))) &&
                (!participantRoleResponsibilities ||
                    (isValidFilterArray(responsibilities) &&
                        isValidFilterArray(participantRoleResponsibilities) &&
                        participantRoleResponsibilities.find(function (roleResponsbility) {
                            return responsibilities === null || responsibilities === void 0 ? void 0 : responsibilities.includes(roleResponsbility);
                        }))) &&
                (!(accessorValues === null || accessorValues === void 0 ? void 0 : accessorValues.length) ||
                    (isValidFilterArray(accessorValues) &&
                        participantHasAccessorValues(participant))));
        }
    });
    if (tournamentEvents.length && eventIds) {
        var participantIds_1 = tournamentEvents
            .filter(function (event) { return eventIds.includes(event.eventId); })
            .map(function (event) {
            var _a;
            var enteredParticipantIds = (event.entries || []).map(function (entry) { return entry.participantId; });
            if (event.eventType === SINGLES$1)
                return enteredParticipantIds;
            var individualParticipantIds = ((_a = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) !== null && _a !== void 0 ? _a : [])
                .filter(function (participant) {
                return enteredParticipantIds.includes(participant.participantId);
            })
                .map(function (participant) { return participant.individualParticipantIds; })
                .flat(1);
            return enteredParticipantIds.concat.apply(enteredParticipantIds, __spreadArray([], __read(individualParticipantIds), false));
        })
            .flat(1);
        participants = participants === null || participants === void 0 ? void 0 : participants.filter(function (participant) {
            return participantIds_1.includes(participant.participantId);
        });
    }
    return participants;
}
function isValidFilterArray(filter) {
    return filter && Array.isArray(filter) && filter.length;
}
function getDrawEntries(_a) {
    var drawEntryStatuses = _a.drawEntryStatuses, tournamentEvents = _a.tournamentEvents;
    var statusFilter = function (_a) {
        var entryStatus = _a.entryStatus;
        return !Array.isArray(drawEntryStatuses)
            ? true
            : drawEntryStatuses.includes(entryStatus);
    };
    return unique(tournamentEvents.reduce(function (entries, event) {
        var _a, _b;
        var flightProfile = getFlightProfile({ event: event }).flightProfile;
        var flightEntries = ((_a = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _a === void 0 ? void 0 : _a.map(function (_a) {
            var drawEntries = _a.drawEntries;
            return Array.isArray(drawEntries)
                ? drawEntries.filter(statusFilter).map(getParticipantId)
                : [];
        }).flat()) || [];
        var drawEnteredParticipantIds = ((_b = event.drawDefinitions) === null || _b === void 0 ? void 0 : _b.map(function (_a) {
            var entries = _a.entries;
            return entries ? entries.filter(statusFilter).map(getParticipantId) : [];
        })) || [];
        return entries.concat.apply(entries, __spreadArray(__spreadArray([], __read(flightEntries), false), __read(drawEnteredParticipantIds), false));
    }, []));
}
function getEventEntries(_a) {
    var eventEntryStatuses = _a.eventEntryStatuses, tournamentEvents = _a.tournamentEvents;
    return unique(tournamentEvents.reduce(function (entries, event) {
        var eventEntries = (event.entries || [])
            .filter(function (_a) {
            var entryStatus = _a.entryStatus;
            return !Array.isArray(eventEntryStatuses)
                ? true
                : eventEntryStatuses.includes(entryStatus);
        })
            .map(getParticipantId);
        return entries.concat.apply(entries, __spreadArray([], __read(eventEntries), false));
    }, []));
}

function getParticipants(params) {
    var e_1, _a, e_2, _b, e_3, _c;
    var _d;
    var withIndividualParticipants = params.withIndividualParticipants, _e = params.participantFilters, participantFilters = _e === void 0 ? {} : _e, withPotentialMatchUps = params.withPotentialMatchUps, withRankingProfile = params.withRankingProfile, convertExtensions = params.convertExtensions, policyDefinitions = params.policyDefinitions, withScheduleItems = params.withScheduleItems, tournamentRecord = params.tournamentRecord, scheduleAnalysis = params.scheduleAnalysis, withSignInStatus = params.withSignInStatus, withTeamMatchUps = params.withTeamMatchUps, withScaleValues = params.withScaleValues, usePublishState = params.usePublishState, contextProfile = params.contextProfile, withStatistics = params.withStatistics, withOpponents = params.withOpponents, withMatchUps = params.withMatchUps, internalUse = params.internalUse, withSeeding = params.withSeeding, withEvents = params.withEvents, withDraws = params.withDraws, withISO2 = params.withISO2, withIOC = params.withIOC;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (withMatchUps || withRankingProfile) {
        getMatchUpDependencies({ tournamentRecord: tournamentRecord }); // ensure goesTos are present
    }
    var participantMap = getParticipantMap({
        convertExtensions: convertExtensions,
        tournamentRecord: tournamentRecord,
        withSignInStatus: withSignInStatus,
        withScaleValues: withScaleValues,
        internalUse: internalUse,
        withISO2: withISO2,
        withIOC: withIOC,
    }).participantMap;
    var entriesResult = getParticipantEntries({
        withMatchUps: withMatchUps !== null && withMatchUps !== void 0 ? withMatchUps : withRankingProfile,
        withEvents: withEvents !== null && withEvents !== void 0 ? withEvents : withRankingProfile,
        withDraws: withDraws !== null && withDraws !== void 0 ? withDraws : withRankingProfile,
        withPotentialMatchUps: withPotentialMatchUps,
        participantFilters: participantFilters,
        withRankingProfile: withRankingProfile,
        convertExtensions: convertExtensions,
        withScheduleItems: withScheduleItems,
        policyDefinitions: policyDefinitions,
        tournamentRecord: tournamentRecord,
        scheduleAnalysis: scheduleAnalysis,
        withTeamMatchUps: withTeamMatchUps,
        usePublishState: usePublishState,
        withStatistics: withStatistics,
        participantMap: participantMap,
        withOpponents: withOpponents,
        contextProfile: contextProfile,
        withSeeding: withSeeding,
    });
    var participantIdsWithConflicts = entriesResult.participantIdsWithConflicts, eventsPublishStatuses = entriesResult.eventsPublishStatuses, derivedEventInfo = entriesResult.derivedEventInfo, derivedDrawInfo = entriesResult.derivedDrawInfo, mappedMatchUps = entriesResult.mappedMatchUps;
    var matchUps = entriesResult.matchUps;
    participantMap = entriesResult.participantMap;
    var nextMatchUps = scheduleAnalysis !== null && scheduleAnalysis !== void 0 ? scheduleAnalysis : withPotentialMatchUps;
    var processParticipant = function (_a) {
        var potentialMatchUps = _a.potentialMatchUps, scheduleConflicts = _a.scheduleConflicts, scheduleItems = _a.scheduleItems, participant = _a.participant, statistics = _a.statistics, opponents = _a.opponents, matchUps = _a.matchUps, events = _a.events, draws = _a.draws;
        var participantDraws = Object.values(draws);
        var participantOpponents = Object.values(opponents);
        if (withOpponents) {
            participantDraws === null || participantDraws === void 0 ? void 0 : participantDraws.forEach(function (draw) {
                draw.opponents = participantOpponents.filter(function (opponent) { return opponent.drawId === draw.drawId; });
            });
        }
        return definedAttributes(__assign(__assign({}, participant), { scheduleConflicts: scheduleAnalysis
                ? Object.values(scheduleConflicts)
                : undefined, draws: withDraws || withRankingProfile ? participantDraws : undefined, events: withEvents || withRankingProfile ? Object.values(events) : undefined, matchUps: withMatchUps || withRankingProfile
                ? Object.values(matchUps)
                : undefined, opponents: withOpponents ? participantOpponents : undefined, potentialMatchUps: nextMatchUps
                ? Object.values(potentialMatchUps)
                : undefined, statistics: withStatistics ? Object.values(statistics) : undefined, scheduleItems: withScheduleItems ? scheduleItems : undefined }), false, false, true);
    };
    var ppMap = new Map();
    try {
        for (var _f = __values(Object.keys(participantMap)), _g = _f.next(); !_g.done; _g = _f.next()) {
            var participantId = _g.value;
            ppMap.set(participantId, processParticipant(participantMap[participantId]));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var processedParticipants = __spreadArray([], __read(ppMap.values()), false);
    var participantAttributes = policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_PARTICIPANT];
    var template = participantAttributes === null || participantAttributes === void 0 ? void 0 : participantAttributes.participant;
    // filter must be last so attributes can be used for reporting & etc.
    var filteredParticipants = filterParticipants({
        participants: processedParticipants,
        participantFilters: participantFilters,
        tournamentRecord: tournamentRecord,
    });
    if (withIndividualParticipants) {
        var template_1 = isObject(withIndividualParticipants)
            ? withIndividualParticipants
            : undefined;
        try {
            for (var filteredParticipants_1 = __values(filteredParticipants), filteredParticipants_1_1 = filteredParticipants_1.next(); !filteredParticipants_1_1.done; filteredParticipants_1_1 = filteredParticipants_1.next()) {
                var participant = filteredParticipants_1_1.value;
                try {
                    for (var _h = (e_3 = void 0, __values((_d = participant.individualParticipantIds) !== null && _d !== void 0 ? _d : [])), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var individualParticipantId = _j.value;
                        if (!participant.individualParticipants)
                            participant.individualParticipants = [];
                        var source = ppMap.get(individualParticipantId);
                        participant.individualParticipants.push(template_1 ? attributeFilter({ template: template_1, source: source }) : source);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (filteredParticipants_1_1 && !filteredParticipants_1_1.done && (_b = filteredParticipants_1.return)) _b.call(filteredParticipants_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    var participants = template
        ? filteredParticipants.map(function (source) {
            return attributeFilter({ source: source, template: template });
        })
        : filteredParticipants;
    // IDEA: optimizePayload derive array of matchUpIds required for filteredParticipants
    // filter mappedMatchUps and matchUps to reduce over-the-wire payloads
    return __assign(__assign({ participantIdsWithConflicts: participantIdsWithConflicts, eventsPublishStatuses: eventsPublishStatuses, derivedEventInfo: derivedEventInfo, derivedDrawInfo: derivedDrawInfo, mappedMatchUps: mappedMatchUps, participantMap: participantMap, participants: participants }, SUCCESS), { matchUps: matchUps });
}

function participantInEntries(_a) {
    var _b;
    var participantId = _a.participantId, drawDefinition = _a.drawDefinition, entryStatus = _a.entryStatus, entryStage = _a.entryStage;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var inEntries = (_b = drawDefinition.entries) === null || _b === void 0 ? void 0 : _b.find(function (entry) {
        return entry.participantId === participantId &&
            (!entryStatus || entryStatus === entry.entryStatus) &&
            (!entryStage || entryStage === entry.entryStage);
    });
    return participantId && inEntries;
}

function getQualifiersCount(params) {
    var e_1, _a;
    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    var provisionalPositioning = params.provisionalPositioning, drawDefinition = params.drawDefinition, stageSequence = params.stageSequence, structureId = params.structureId, stage = params.stage;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var entryProfile = getEntryProfile({ drawDefinition: drawDefinition }).entryProfile;
    var profileQualifiersCount = (stage &&
        stageSequence &&
        ((_d = (_c = (_b = entryProfile === null || entryProfile === void 0 ? void 0 : entryProfile[stage]) === null || _b === void 0 ? void 0 : _b.stageSequence) === null || _c === void 0 ? void 0 : _c[stageSequence]) === null || _d === void 0 ? void 0 : _d.qualifiersCount)) ||
        (stage && ((_e = entryProfile === null || entryProfile === void 0 ? void 0 : entryProfile[stage]) === null || _e === void 0 ? void 0 : _e.qualifiersCount)) ||
        0;
    var roundQualifiersCounts = {};
    if (!structureId)
        return { qualifiersCount: profileQualifiersCount, roundQualifiersCounts: roundQualifiersCounts };
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    var relevantLinks = (_f = drawDefinition.links) === null || _f === void 0 ? void 0 : _f.filter(function (link) { var _a; return ((_a = link === null || link === void 0 ? void 0 : link.target) === null || _a === void 0 ? void 0 : _a.structureId) === (structure === null || structure === void 0 ? void 0 : structure.structureId); });
    var qualifiersCount = 0;
    // if structureId is provided and there is a relevant link...
    if (relevantLinks === null || relevantLinks === void 0 ? void 0 : relevantLinks.length) {
        try {
            for (var relevantLinks_1 = __values(relevantLinks), relevantLinks_1_1 = relevantLinks_1.next(); !relevantLinks_1_1.done; relevantLinks_1_1 = relevantLinks_1.next()) {
                var relevantLink = relevantLinks_1_1.value;
                var sourceStructure = (_g = findStructure({
                    structureId: relevantLink.source.structureId,
                    drawDefinition: drawDefinition,
                })) === null || _g === void 0 ? void 0 : _g.structure;
                if ((sourceStructure === null || sourceStructure === void 0 ? void 0 : sourceStructure.stage) === QUALIFYING) {
                    var sourceRoundNumber = relevantLink.source
                        .roundNumber;
                    var roundTarget = relevantLink.target.roundNumber;
                    var count = 0;
                    if (sourceStructure.structureType === CONTAINER) {
                        // for Round Robin qualifying the number of qualifiers needs to be derived from:
                        // the number of groups (substructures) * the length of source.finishingPositions[]
                        var groupCount = (_j = (_h = sourceStructure.structures) === null || _h === void 0 ? void 0 : _h.length) !== null && _j !== void 0 ? _j : 0;
                        var finishingPositionsCount = (_l = (_k = relevantLink.source.finishingPositions) === null || _k === void 0 ? void 0 : _k.length) !== null && _l !== void 0 ? _l : 0;
                        count = groupCount * finishingPositionsCount;
                    }
                    else {
                        // return source structure qualifying round matchUps count
                        var matchUps = getAllStructureMatchUps({
                            matchUpFilters: { roundNumbers: [sourceRoundNumber] },
                            structure: sourceStructure,
                            afterRecoveryTimes: false,
                            provisionalPositioning: provisionalPositioning,
                            inContext: false,
                        }).matchUps;
                        count = (matchUps === null || matchUps === void 0 ? void 0 : matchUps.length) || 0;
                    }
                    if (!roundQualifiersCounts[roundTarget])
                        roundQualifiersCounts[roundTarget] = 0;
                    roundQualifiersCounts[roundTarget] += count;
                    qualifiersCount += count;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (relevantLinks_1_1 && !relevantLinks_1_1.done && (_a = relevantLinks_1.return)) _a.call(relevantLinks_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    // allow profileQualifiersCount to override if and only if there is only one qualifying roundTarget
    var qualifyingRounds = Object.keys(roundQualifiersCounts);
    if (qualifyingRounds.length <= 1) {
        var qualifyingRound = qualifyingRounds[0] || 1;
        roundQualifiersCounts[qualifyingRound] = Math.max(roundQualifiersCounts[qualifyingRound] || 0, profileQualifiersCount);
    }
    qualifiersCount = Math.max(qualifiersCount, profileQualifiersCount);
    return { qualifiersCount: qualifiersCount, roundQualifiersCounts: roundQualifiersCounts };
}

function getStageDrawPositionsCount(_a) {
    var _b;
    var stage = _a.stage, drawDefinition = _a.drawDefinition;
    var entryProfile = getEntryProfile({ drawDefinition: drawDefinition }).entryProfile;
    return ((_b = entryProfile === null || entryProfile === void 0 ? void 0 : entryProfile[stage]) === null || _b === void 0 ? void 0 : _b.drawSize) || 0;
}
// drawSize - qualifyingPositions
function getStageDrawPositionsAvailable(params) {
    var provisionalPositioning = params.provisionalPositioning, drawDefinition = params.drawDefinition, stageSequence = params.stageSequence, stage = params.stage;
    var drawSize = getStageDrawPositionsCount({ stage: stage, drawDefinition: drawDefinition });
    var qualifiersCount = getQualifiersCount({
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        stageSequence: stageSequence,
        stage: stage,
    }).qualifiersCount;
    return drawSize && drawSize - qualifiersCount;
}

function getValidStage(_a) {
    var stage = _a.stage, drawDefinition = _a.drawDefinition;
    return Boolean(stage === VOLUNTARY_CONSOLATION ||
        (stageExists({ stage: stage, drawDefinition: drawDefinition }) &&
            getStageDrawPositionsCount({ stage: stage, drawDefinition: drawDefinition })));
}

function getStageSpace(_a) {
    var _b = _a.entryStatus, entryStatus = _b === void 0 ? DIRECT_ACCEPTANCE : _b, drawDefinition = _a.drawDefinition, stageSequence = _a.stageSequence, stage = _a.stage;
    if (entryStatus === ALTERNATE) {
        if (stageAlternatesCount({ stage: stage, drawDefinition: drawDefinition })) {
            return __assign({ positionsAvailable: Infinity }, SUCCESS);
        }
        else {
            return { error: ENTRY_STATUS_NOT_ALLOWED_IN_STAGE };
        }
    }
    var stageDrawPositionsAvailable = getStageDrawPositionsAvailable({
        drawDefinition: drawDefinition,
        stageSequence: stageSequence,
        stage: stage,
    });
    var wildcardPositions = getStageWildcardsCount({
        drawDefinition: drawDefinition,
        stage: stage,
    });
    var wildcardEntriesCount = getStageEntryTypeCount({
        entryStatus: WILDCARD,
        drawDefinition: drawDefinition,
        stage: stage,
    });
    var directEntriesCount = getStageEntryTypeCount({
        entryStatus: DIRECT_ACCEPTANCE,
        drawDefinition: drawDefinition,
        stage: stage,
    });
    var totalEntriesCount = wildcardEntriesCount + directEntriesCount;
    var stageFull = totalEntriesCount >= stageDrawPositionsAvailable;
    var positionsAvailable = stageDrawPositionsAvailable - totalEntriesCount;
    if (stage !== VOLUNTARY_CONSOLATION && stageFull) {
        return { error: NO_STAGE_SPACE_AVAILABLE_FOR_ENTRY_STATUS };
    }
    if (entryStatus === WILDCARD) {
        if (wildcardEntriesCount < wildcardPositions)
            return __assign({}, SUCCESS);
        return { error: NO_STAGE_SPACE_AVAILABLE_FOR_ENTRY_STATUS };
    }
    return __assign({ positionsAvailable: positionsAvailable }, SUCCESS);
}

function addDrawEntry(params) {
    var _a = params.entryStatus, entryStatus = _a === void 0 ? DIRECT_ACCEPTANCE : _a, entryStageSequence = params.entryStageSequence, _b = params.entryStage, entryStage = _b === void 0 ? MAIN : _b, ignoreStageSpace = params.ignoreStageSpace, drawDefinition = params.drawDefinition, entryPosition = params.entryPosition, participant = params.participant, roundTarget = params.roundTarget, extensions = params.extensions, extension = params.extension, drawType = params.drawType;
    var stack = 'addDrawEntry';
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!entryStage)
        return { error: MISSING_STAGE };
    if (drawType !== AD_HOC &&
        !getValidStage({ stage: entryStage, drawDefinition: drawDefinition })) {
        return decorateResult({ result: { error: INVALID_STAGE }, stack: stack });
    }
    var spaceAvailable = getStageSpace({
        stageSequence: entryStageSequence,
        stage: entryStage,
        drawDefinition: drawDefinition,
        entryStatus: entryStatus,
    });
    if (!ignoreStageSpace && !spaceAvailable.success) {
        return { error: spaceAvailable.error };
    }
    if (extension && !isValidExtension({ extension: extension }))
        return decorateResult({
            result: { error: INVALID_VALUES },
            info: 'Invalid extension',
            context: { extension: extension },
            stack: stack,
        });
    var participantId = params.participantId || (participant === null || participant === void 0 ? void 0 : participant.participantId);
    if (!participantId)
        return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack: stack });
    var invalidLuckyLoser = entryStatus === LUCKY_LOSER &&
        participantInEntries({ participantId: participantId, drawDefinition: drawDefinition, entryStatus: entryStatus });
    var invalidVoluntaryConsolation = entryStage === VOLUNTARY_CONSOLATION &&
        participantInEntries({
            participantId: participantId,
            drawDefinition: drawDefinition,
            entryStage: entryStage,
        });
    var invalidEntry = entryStatus !== LUCKY_LOSER &&
        entryStage !== VOLUNTARY_CONSOLATION &&
        participantInEntries({ drawDefinition: drawDefinition, participantId: participantId });
    if (invalidEntry || invalidLuckyLoser || invalidVoluntaryConsolation) {
        return decorateResult({
            context: { invalidEntry: invalidEntry, invalidLuckyLoser: invalidLuckyLoser, invalidVoluntaryConsolation: invalidVoluntaryConsolation },
            result: { error: EXISTING_PARTICIPANT },
            stack: stack,
        });
    }
    var entry = definedAttributes({
        entryStageSequence: entryStageSequence,
        participantId: participantId,
        entryPosition: entryPosition,
        entryStatus: entryStatus,
        entryStage: entryStage,
        extensions: extensions,
    });
    if (extension) {
        addExtension({ element: entry, extension: extension });
    }
    if (roundTarget) {
        addExtension({
            extension: { name: 'roundEntry', value: roundTarget },
            element: entry,
        });
    }
    if (!drawDefinition.entries)
        drawDefinition.entries = [];
    drawDefinition.entries.push(entry);
    modifyDrawNotice({ drawDefinition: drawDefinition });
    return __assign({}, SUCCESS);
}
function addDrawEntries$1(params) {
    var _a;
    var stack = 'addDrawEntries';
    var _b = params.entryStatus, entryStatus = _b === void 0 ? DIRECT_ACCEPTANCE : _b, _c = params.stage, stage = _c === void 0 ? MAIN : _c, _d = params.autoEntryPositions, autoEntryPositions = _d === void 0 ? true : _d, ignoreStageSpace = params.ignoreStageSpace, drawDefinition = params.drawDefinition, participantIds = params.participantIds, stageSequence = params.stageSequence, roundTarget = params.roundTarget, extension = params.extension;
    if (!stage)
        return { error: MISSING_STAGE };
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!Array.isArray(participantIds))
        return { error: INVALID_PARTICIPANT_IDS };
    if (!getValidStage({ stage: stage, drawDefinition: drawDefinition })) {
        return { error: INVALID_STAGE };
    }
    if (extension && !isValidExtension({ extension: extension })) {
        return decorateResult({
            result: { error: INVALID_VALUES },
            info: 'Invalid extension',
            context: { extension: extension },
            stack: stack,
        });
    }
    var spaceAvailable = getStageSpace({
        drawDefinition: drawDefinition,
        stageSequence: stageSequence,
        entryStatus: entryStatus,
        stage: stage,
    });
    if (!ignoreStageSpace && !spaceAvailable.success) {
        return { error: spaceAvailable.error };
    }
    var positionsAvailable = (_a = spaceAvailable.positionsAvailable) !== null && _a !== void 0 ? _a : 0;
    if (!ignoreStageSpace &&
        stage !== VOLUNTARY_CONSOLATION &&
        positionsAvailable < participantIds.length)
        return { error: PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE };
    var participantIdsNotAdded = participantIds.reduce(function (notAdded, participantId) {
        var invalidLuckyLoser = entryStatus === LUCKY_LOSER &&
            participantInEntries({ participantId: participantId, drawDefinition: drawDefinition, entryStatus: entryStatus });
        var invalidVoluntaryConsolation = stage === VOLUNTARY_CONSOLATION &&
            participantInEntries({
                entryStage: stage,
                drawDefinition: drawDefinition,
                participantId: participantId,
            });
        var invalidEntry = entryStatus !== LUCKY_LOSER &&
            stage !== VOLUNTARY_CONSOLATION &&
            participantInEntries({ drawDefinition: drawDefinition, participantId: participantId });
        if (invalidEntry || invalidLuckyLoser || invalidVoluntaryConsolation) {
            return notAdded.concat(participantId);
        }
        return notAdded;
    }, []);
    participantIds
        .filter(function (participantId) {
        return participantId && !participantIdsNotAdded.includes(participantId);
    })
        .forEach(function (participantId) {
        var entry = {
            entryStageSequence: stageSequence,
            entryStage: stage,
            participantId: participantId,
            entryStatus: entryStatus,
        };
        if (extension) {
            addExtension({ element: entry, extension: extension });
        }
        if (roundTarget) {
            addExtension({
                extension: { name: ROUND_TARGET, value: roundTarget },
                element: entry,
            });
        }
        if (!drawDefinition.entries)
            drawDefinition.entries = [];
        drawDefinition.entries.push(entry);
    });
    if (autoEntryPositions) {
        drawDefinition.entries = refreshEntryPositions({
            entries: drawDefinition.entries,
        });
    }
    modifyDrawNotice({ drawDefinition: drawDefinition });
    return (participantIdsNotAdded === null || participantIdsNotAdded === void 0 ? void 0 : participantIdsNotAdded.length)
        ? __assign({ info: 'some participantIds could not be added', participantIdsNotAdded: participantIdsNotAdded }, SUCCESS) : __assign({}, SUCCESS);
}

function addDrawEntries(_a) {
    var _b = _a.autoEntryPositions, autoEntryPositions = _b === void 0 ? true : _b, entryStageSequence = _a.entryStageSequence, ignoreStageSpace = _a.ignoreStageSpace, drawDefinition = _a.drawDefinition, participantIds = _a.participantIds, entryStatus = _a.entryStatus, roundTarget = _a.roundTarget, entryStage = _a.entryStage, extension = _a.extension, drawId = _a.drawId, event = _a.event;
    if (!(participantIds === null || participantIds === void 0 ? void 0 : participantIds.length))
        return { error: MISSING_PARTICIPANT_IDS };
    if (!event)
        return { error: EVENT_NOT_FOUND };
    if (!drawId)
        return { error: MISSING_DRAW_ID };
    var eventEnteredParticipantIds = (event.entries || []).map(getParticipantId);
    var missingEventEntries = participantIds.filter(function (participantId) { return !eventEnteredParticipantIds.includes(participantId); });
    if (missingEventEntries.length)
        return { error: MISSING_ENTRIES };
    if (drawDefinition) {
        var result = addDrawEntries$1({
            stageSequence: entryStageSequence,
            autoEntryPositions: autoEntryPositions,
            stage: entryStage,
            ignoreStageSpace: ignoreStageSpace,
            drawDefinition: drawDefinition,
            participantIds: participantIds,
            entryStatus: entryStatus,
            roundTarget: roundTarget,
            extension: extension,
        });
        if (result.error)
            return result;
    }
    var flightProfile = getFlightProfile({ event: event }).flightProfile;
    var flight = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights.find(function (flight) { return flight.drawId === drawId; });
    if (flight === null || flight === void 0 ? void 0 : flight.drawEntries) {
        participantIds.forEach(function (participantId) {
            var invalidLuckyLoser = entryStatus === LUCKY_LOSER &&
                participantInFlightEntries({
                    participantId: participantId,
                    entryStatus: entryStatus,
                    flight: flight,
                });
            var invalidVoluntaryConsolation = entryStage === VOLUNTARY_CONSOLATION &&
                participantInFlightEntries({
                    participantId: participantId,
                    entryStage: entryStage,
                    flight: flight,
                });
            var invalidEntry = entryStatus !== LUCKY_LOSER &&
                entryStage !== VOLUNTARY_CONSOLATION &&
                participantInFlightEntries({ flight: flight, participantId: participantId });
            if (!invalidEntry && !invalidLuckyLoser && !invalidVoluntaryConsolation) {
                flight.drawEntries.push({
                    participantId: participantId,
                    entryStatus: entryStatus,
                    entryStage: entryStage,
                });
            }
        });
        if (autoEntryPositions) {
            flight.drawEntries = refreshEntryPositions({
                entries: flight.drawEntries,
            });
        }
    }
    return __assign({}, SUCCESS);
}
function participantInFlightEntries(_a) {
    var _b;
    var participantId = _a.participantId, entryStatus = _a.entryStatus, entryStage = _a.entryStage, flight = _a.flight;
    var inEntries = (_b = flight.drawEntries) === null || _b === void 0 ? void 0 : _b.find(function (entry) {
        return entry.participantId === participantId &&
            (!entryStatus || entryStatus === entry.entryStatus) &&
            (!entryStage || entryStage === entry.entryStage);
    });
    return participantId && inEntries;
}

function removeEventEntries(_a) {
    var _b, _c, _d, _e, _f, _g;
    var _h = _a.autoEntryPositions, autoEntryPositions = _h === void 0 ? true : _h, _j = _a.participantIds, participantIds = _j === void 0 ? [] : _j, entryStatuses = _a.entryStatuses, stage = _a.stage, event = _a.event;
    var stack = 'removeEventEntries';
    if (!(event === null || event === void 0 ? void 0 : event.eventId))
        return { error: MISSING_EVENT };
    if (!Array.isArray(participantIds) || participantIds.some(function (participantId) { return !isString(participantId); })) {
        return decorateResult({ result: { error: INVALID_PARTICIPANT_ID }, stack: stack });
    }
    // do not filter by stages; must kmow all participantIds assigned to any stage!
    var assignedParticipantIds = ((_b = event.drawDefinitions) !== null && _b !== void 0 ? _b : []).flatMap(function (drawDefinition) { var _a; return (_a = getAssignedParticipantIds({ drawDefinition: drawDefinition }).assignedParticipantIds) !== null && _a !== void 0 ? _a : []; });
    var statusParticipantIds = (((entryStatuses === null || entryStatuses === void 0 ? void 0 : entryStatuses.length) &&
        ((_c = event.entries) === null || _c === void 0 ? void 0 : _c.filter(function (entry) { return entry.entryStatus && entryStatuses.includes(entry.entryStatus); }))) ||
        [])
        .map(xa('participantId'))
        .filter(function (participantId) { return !assignedParticipantIds.includes(participantId); });
    var stageParticipantIds = ((stage && ((_d = event.entries) === null || _d === void 0 ? void 0 : _d.filter(function (entry) { return entry.entryStage && entry.entryStage === stage; }))) ||
        [])
        .map(xa('participantId'))
        .filter(function (participantId) { return !assignedParticipantIds.includes(participantId); });
    if (participantIds.length) {
        participantIds = participantIds.filter(function (participantId) {
            return (!(entryStatuses === null || entryStatuses === void 0 ? void 0 : entryStatuses.length) || statusParticipantIds.includes(participantId)) &&
                (!stage || stageParticipantIds.includes(participantId));
        });
    }
    else if (statusParticipantIds.length && stageParticipantIds.length) {
        participantIds = intersection(statusParticipantIds, stageParticipantIds);
    }
    else if (statusParticipantIds.length) {
        participantIds = statusParticipantIds;
    }
    else if (stageParticipantIds.length) {
        participantIds = stageParticipantIds;
    }
    if ((participantIds === null || participantIds === void 0 ? void 0 : participantIds.length) &&
        assignedParticipantIds.some(function (participantId) { return participantIds.includes(participantId); })) {
        return decorateResult({
            result: { error: EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT },
            stack: stack,
        });
    }
    if (!(participantIds === null || participantIds === void 0 ? void 0 : participantIds.length))
        return __assign(__assign({}, SUCCESS), { participantIdsRemoved: [] });
    var participantIdsRemoved = [];
    event.entries = ((_e = event.entries) !== null && _e !== void 0 ? _e : []).filter(function (entry) {
        var keepEntry = !participantIds.includes(entry === null || entry === void 0 ? void 0 : entry.participantId);
        if (!keepEntry)
            participantIdsRemoved.push(entry.participantId);
        return keepEntry;
    });
    if (autoEntryPositions) {
        event.entries = refreshEntryPositions({
            entries: event.entries,
        });
    }
    // also remove entry from all flights and drawDefinitions
    var flightProfile = getFlightProfile({ event: event }).flightProfile;
    (_f = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _f === void 0 ? void 0 : _f.forEach(function (flight) {
        flight.drawEntries = (flight.drawEntries || []).filter(function (entry) { return !participantIds.includes(entry.participantId); });
    });
    (_g = event.drawDefinitions) === null || _g === void 0 ? void 0 : _g.forEach(function (drawDefinition) {
        var _a;
        drawDefinition.entries = ((_a = drawDefinition.entries) !== null && _a !== void 0 ? _a : []).filter(function (entry) { return !participantIds.includes(entry.participantId); });
    });
    return __assign(__assign({}, SUCCESS), { participantIdsRemoved: participantIdsRemoved });
}

var _a$f;
var POLICY_MATCHUP_ACTIONS_DEFAULT = (_a$f = {},
    _a$f[POLICY_TYPE_MATCHUP_ACTIONS] = {
        policyName: 'matchUpActionsDefault',
        // matchUpActions will be selectively enabled for structures matching { stages: [], stageSequences: [] }
        // enabledStructures: [] => all structures are enabled
        enabledStructures: [
            {
                stages: [], // stages: [] => applies to all stages
                stageSequences: [], // stageSequences: [] => applies to all stageSequences
                enabledActions: [],
                disabledActions: [], // disabledActions: [] => no actions are disabled
            },
        ],
        participants: {
            enforceCategory: true, // validate collectionDefinition.category against event.category
            enforceGender: true, // disallow placing FEMALEs in MALE events and vice versa
        },
        processCodes: {
            substitution: ['RANKING.IGNORE', 'RATING.IGNORE'],
        },
        substituteAfterCompleted: false,
        substituteWithoutScore: false,
    },
    _a$f);

function addEventEntries(params) {
    var _a, _b, _c, _d, _e, _f, _g;
    var _h = params.entryStatus, entryStatus = _h === void 0 ? DIRECT_ACCEPTANCE : _h, _j = params.autoEntryPositions, autoEntryPositions = _j === void 0 ? true : _j, _k = params.enforceGender, enforceGender = _k === void 0 ? true : _k, _l = params.participantIds, participantIds = _l === void 0 ? [] : _l, entryStageSequence = params.entryStageSequence, policyDefinitions = params.policyDefinitions, _m = params.entryStage, entryStage = _m === void 0 ? MAIN : _m, tournamentRecord = params.tournamentRecord, ignoreStageSpace = params.ignoreStageSpace, drawDefinition = params.drawDefinition, roundTarget = params.roundTarget, extensions = params.extensions, extension = params.extension, drawId = params.drawId, event = params.event;
    var stack = 'addEventEntries';
    if (!event)
        return { error: MISSING_EVENT };
    if (!(participantIds === null || participantIds === void 0 ? void 0 : participantIds.length)) {
        return decorateResult({
            result: { error: MISSING_PARTICIPANT_IDS },
            stack: stack,
        });
    }
    if (!(event === null || event === void 0 ? void 0 : event.eventId))
        return { error: EVENT_NOT_FOUND };
    var appliedPolicies = (_a = getAppliedPolicies({ tournamentRecord: tournamentRecord, event: event }).appliedPolicies) !== null && _a !== void 0 ? _a : {};
    var matchUpActionsPolicy = (_c = (_b = policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_MATCHUP_ACTIONS]) !== null && _b !== void 0 ? _b : appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_MATCHUP_ACTIONS]) !== null && _c !== void 0 ? _c : POLICY_MATCHUP_ACTIONS_DEFAULT[POLICY_TYPE_MATCHUP_ACTIONS];
    var genderEnforced = (enforceGender !== null && enforceGender !== void 0 ? enforceGender : (_d = matchUpActionsPolicy === null || matchUpActionsPolicy === void 0 ? void 0 : matchUpActionsPolicy.participants) === null || _d === void 0 ? void 0 : _d.enforceGender) !==
        false;
    var addedParticipantIdEntries = [];
    var removedEntries = [];
    if ((extensions &&
        (!Array.isArray(extensions) ||
            !extensions.every(function (extension) { return isValidExtension({ extension: extension }); }))) ||
        (extension && !isValidExtension({ extension: extension }))) {
        return decorateResult({
            context: definedAttributes({ extension: extension, extensions: extensions }),
            result: { error: INVALID_VALUES },
            info: 'Invalid extension(s)',
            stack: stack,
        });
    }
    var checkTypedParticipants = !!tournamentRecord;
    var mismatchedGender = [];
    var info;
    var typedParticipantIds = (_f = (_e = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) === null || _e === void 0 ? void 0 : _e.filter(function (participant) {
        var _a, _b, _c;
        if (!participantIds.includes(participant.participantId))
            return false;
        var validSingles = event.eventType === SINGLES &&
            participant.participantType === INDIVIDUAL &&
            !isUngrouped(entryStatus);
        var validDoubles = event.eventType === DOUBLES && participant.participantType === PAIR;
        if (validSingles &&
            (!event.gender ||
                !genderEnforced ||
                [MIXED, ANY].includes(event.gender) ||
                event.gender === ((_a = participant.person) === null || _a === void 0 ? void 0 : _a.sex))) {
            return true;
        }
        if (validDoubles && !isUngrouped(entryStatus)) {
            return true;
        }
        if (event.eventType === DOUBLES &&
            participant.participantType === INDIVIDUAL &&
            isUngrouped(entryStatus)) {
            return true;
        }
        if (validSingles &&
            event.gender &&
            genderEnforced &&
            ![MIXED, ANY].includes(event.gender) &&
            event.gender !== ((_b = participant.person) === null || _b === void 0 ? void 0 : _b.sex)) {
            mismatchedGender.push({
                participantId: participant.participantId,
                sex: (_c = participant.person) === null || _c === void 0 ? void 0 : _c.sex,
            });
            return false;
        }
        return (event.eventType === TEAM$1 &&
            (participant.participantType === TEAM$1 ||
                (isUngrouped(entryStatus) &&
                    participant.participantType === INDIVIDUAL)));
    }).map(function (participant) { return participant.participantId; })) !== null && _f !== void 0 ? _f : [];
    var validParticipantIds = participantIds.filter(function (participantId) {
        return !checkTypedParticipants || typedParticipantIds.includes(participantId);
    });
    if (!event.entries)
        event.entries = [];
    var existingIds = event.entries.map(function (e) { var _a; return e.participantId || ((_a = e.participant) === null || _a === void 0 ? void 0 : _a.participantId); });
    validParticipantIds.forEach(function (participantId) {
        var _a;
        if (!existingIds.includes(participantId)) {
            var entry = definedAttributes({
                participantId: participantId,
                entryStatus: entryStatus,
                entryStage: entryStage,
                extensions: extensions,
            });
            if (extension) {
                addExtension({ element: entry, extension: extension });
            }
            if (roundTarget) {
                addExtension({
                    extension: { name: ROUND_TARGET, value: roundTarget },
                    element: entry,
                });
            }
            if (entryStageSequence)
                entry.entryStageSequence = entryStageSequence;
            addedParticipantIdEntries.push(entry.participantId);
            (_a = event.entries) === null || _a === void 0 ? void 0 : _a.push(entry);
        }
    });
    if (drawId && !isUngrouped(entryStage)) {
        var result = addDrawEntries({
            participantIds: validParticipantIds,
            autoEntryPositions: autoEntryPositions,
            entryStageSequence: entryStageSequence,
            ignoreStageSpace: ignoreStageSpace,
            drawDefinition: drawDefinition,
            entryStatus: entryStatus,
            roundTarget: roundTarget,
            entryStage: entryStage,
            extension: extension,
            drawId: drawId,
            event: event,
        });
        // Ignore error if drawId is included but entry can't be added to drawDefinition/flightProfile
        // return error as info to client
        if (result.error) {
            info = result.error;
        }
    }
    // now remove any ungrouped participantIds which exist as part of added grouped participants
    if (event.eventType &&
        [DOUBLES_EVENT, TEAM_EVENT].includes(event.eventType)) {
        var enteredParticipantIds_1 = (event.entries || []).map(function (entry) { return entry.participantId; });
        var ungroupedIndividualParticipantIds = (event.entries || [])
            .filter(function (entry) { return isUngrouped(entry.entryStatus); })
            .map(function (entry) { return entry.participantId; });
        var tournamentParticipants = (_g = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) !== null && _g !== void 0 ? _g : [];
        var groupedIndividualParticipantIds_1 = tournamentParticipants
            .filter(function (participant) {
            return enteredParticipantIds_1.includes(participant.participantId) &&
                participant.participantType &&
                [PAIR, TEAM$1].includes(participant.participantType);
        })
            .map(function (participant) { return participant.individualParticipantIds; })
            .flat(Infinity);
        var ungroupedParticipantIdsToRemove = ungroupedIndividualParticipantIds.filter(function (participantId) {
            return groupedIndividualParticipantIds_1.includes(participantId);
        });
        if (ungroupedParticipantIdsToRemove.length) {
            removedEntries.push.apply(removedEntries, __spreadArray([], __read(ungroupedParticipantIdsToRemove), false));
            removeEventEntries({
                participantIds: ungroupedParticipantIdsToRemove,
                autoEntryPositions: false, // because the method will be called below if necessary
                event: event,
            });
        }
    }
    var invalidParticipantIds = validParticipantIds.length !== participantIds.length;
    if (invalidParticipantIds)
        return decorateResult({
            context: { mismatchedGender: mismatchedGender, gender: event.gender },
            result: { error: INVALID_PARTICIPANT_IDS },
            stack: stack,
        });
    if (autoEntryPositions) {
        event.entries = refreshEntryPositions({
            entries: event.entries || [],
        });
    }
    var addedEntriesCount = addedParticipantIdEntries.length - removedEntries.length;
    return decorateResult({
        result: __assign(__assign({}, SUCCESS), { addedEntriesCount: addedEntriesCount }),
        stack: stack,
        info: info,
    });
}

var ADMINISTRATION = 'ADMINISTRATION';
var CAPTAIN = 'CAPTAIN';
var COACH = 'COACH';
var COMPETITOR = 'COMPETITOR';
var MEDIA = 'MEDIA';
var MEDICAL = 'MEDICAL';
var OFFICIAL = 'OFFICIAL';
var OTHER$1 = 'OTHER';
var SECURITY = 'SECURITY';
var participantRoles = {
    ADMINISTRATION: ADMINISTRATION,
    CAPTAIN: CAPTAIN,
    COACH: COACH,
    COMPETITOR: COMPETITOR,
    MEDIA: MEDIA,
    MEDICAL: MEDICAL,
    OFFICIAL: OFFICIAL,
    OTHER: OTHER$1,
    SECURITY: SECURITY,
};

function removeIndividualParticipantIds(_a) {
    var e_1, _b;
    var _c, _d, _e;
    var addIndividualParticipantsToEvents = _a.addIndividualParticipantsToEvents, individualParticipantIds = _a.individualParticipantIds, groupingParticipantId = _a.groupingParticipantId, tournamentRecord = _a.tournamentRecord, suppressErrors = _a.suppressErrors;
    var stack = 'removeIndividualParticipantIds';
    if (!tournamentRecord)
        return decorateResult({
            result: { error: MISSING_TOURNAMENT_RECORD },
            stack: stack,
        });
    if (!groupingParticipantId || !individualParticipantIds)
        return decorateResult({ result: { error: MISSING_VALUE }, stack: stack });
    var tournamentParticipants = (_c = tournamentRecord.participants) !== null && _c !== void 0 ? _c : [];
    var groupingParticipant = tournamentParticipants.find(function (participant) {
        return participant.participantId === groupingParticipantId;
    });
    if (!groupingParticipant)
        return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack: stack });
    if (![TEAM$1, GROUP].includes(groupingParticipant.participantType)) {
        return decorateResult({
            result: {
                participantType: groupingParticipant.participantType,
                error: INVALID_PARTICIPANT_TYPE,
            },
            stack: stack,
        });
    }
    var result = removeParticipantIdsFromGroupingParticipant({
        individualParticipantIds: individualParticipantIds,
        groupingParticipant: groupingParticipant,
        tournamentRecord: tournamentRecord,
        suppressErrors: suppressErrors,
    });
    var removed = result.removed, error = result.error;
    if (error)
        return decorateResult({ result: result, stack: stack });
    if (addIndividualParticipantsToEvents) {
        var _loop_1 = function (event_1) {
            var enteredIds = ((_e = event_1.entries) !== null && _e !== void 0 ? _e : [])
                .map(function (_a) {
                var participantId = _a.participantId;
                return participantId;
            })
                .filter(Boolean);
            if (enteredIds.includes(groupingParticipantId)) {
                var participantIdsToEnter = removed === null || removed === void 0 ? void 0 : removed.filter(function (participantId) { return !enteredIds.includes(participantId); });
                addEventEntries({
                    participantIds: participantIdsToEnter,
                    entryStatus: UNGROUPED,
                    tournamentRecord: tournamentRecord,
                    event: event_1,
                });
            }
        };
        try {
            for (var _f = __values((_d = tournamentRecord.events) !== null && _d !== void 0 ? _d : []), _g = _f.next(); !_g.done; _g = _f.next()) {
                var event_1 = _g.value;
                _loop_1(event_1);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    if (removed) {
        addNotice({
            topic: MODIFY_PARTICIPANTS,
            payload: {
                tournamentId: tournamentRecord.tournamentId,
                participants: [groupingParticipant],
            },
        });
    }
    return __assign(__assign({}, SUCCESS), result);
}
function removeParticipantIdsFromGroupingParticipant(_a) {
    var _b;
    var _c, _d;
    var _e = _a.individualParticipantIds, individualParticipantIds = _e === void 0 ? [] : _e, groupingParticipant = _a.groupingParticipant, tournamentRecord = _a.tournamentRecord, suppressErrors = _a.suppressErrors, mappedMatchUps = _a.mappedMatchUps, participants = _a.participants;
    var removed = [];
    if (!groupingParticipant)
        return { removed: removed };
    var notRemoved = [];
    var cannotRemove = [];
    if (!participants) {
        (_b = getParticipants({
            withMatchUps: true,
            tournamentRecord: tournamentRecord,
            withEvents: true,
        }), participants = _b.participants, mappedMatchUps = _b.mappedMatchUps);
    }
    var inContextGroupingParticipant = participants === null || participants === void 0 ? void 0 : participants.find(function (_a) {
        var participantId = _a.participantId;
        return participantId === groupingParticipant.participantId;
    });
    var groupingParticipantEventIds = (_c = inContextGroupingParticipant === null || inContextGroupingParticipant === void 0 ? void 0 : inContextGroupingParticipant.events) === null || _c === void 0 ? void 0 : _c.map(function (_a) {
        var eventId = _a.eventId;
        return eventId;
    });
    var updatedIndividualParticipantIds = ((_d = groupingParticipant.individualParticipantIds) !== null && _d !== void 0 ? _d : []).filter(function (participantId) {
        var e_2, _a, e_3, _b, e_4, _c, e_5, _d;
        var _e, _f, _g, _h, _j, _k;
        var targetParticipant = individualParticipantIds === null || individualParticipantIds === void 0 ? void 0 : individualParticipantIds.includes(participantId);
        var scoredParticipantGroupingMatchUps = targetParticipant &&
            ((_e = participants === null || participants === void 0 ? void 0 : participants.find(function (participant) { return participant.participantId === participantId; })) === null || _e === void 0 ? void 0 : _e.matchUps.filter(function (_a) {
                var eventId = _a.eventId;
                return groupingParticipantEventIds.includes(eventId);
            }).map(function (_a) {
                var matchUpId = _a.matchUpId;
                return mappedMatchUps === null || mappedMatchUps === void 0 ? void 0 : mappedMatchUps[matchUpId];
            }).filter(function (_a) {
                var winningSide = _a.winningSide, score = _a.score;
                return winningSide || checkScoreHasValue({ score: score });
            }));
        var removeParticipant = targetParticipant && !(scoredParticipantGroupingMatchUps === null || scoredParticipantGroupingMatchUps === void 0 ? void 0 : scoredParticipantGroupingMatchUps.length);
        if (targetParticipant && !removeParticipant) {
            cannotRemove.push(participantId);
        }
        if (removeParticipant) {
            removed.push(participantId);
            try {
                for (var _l = __values((_f = tournamentRecord.events) !== null && _f !== void 0 ? _f : []), _m = _l.next(); !_m.done; _m = _l.next()) {
                    var event_2 = _m.value;
                    try {
                        for (var _o = (e_3 = void 0, __values((_g = event_2.drawDefinitions) !== null && _g !== void 0 ? _g : [])), _p = _o.next(); !_p.done; _p = _o.next()) {
                            var drawDefinition = _p.value;
                            var extension = findExtension({
                                element: drawDefinition,
                                name: LINEUPS,
                            }).extension;
                            var lineUp = extension === null || extension === void 0 ? void 0 : extension.value[groupingParticipant.participantId];
                            if (extension && lineUp) {
                                extension.value[groupingParticipant.participantId] = lineUp.filter(function (assignment) { return assignment.participantId !== participantId; });
                                addExtension({ element: drawDefinition, extension: extension });
                                addDrawNotice({ drawDefinition: drawDefinition });
                            }
                            var matchUps = (_h = allDrawMatchUps({ drawDefinition: drawDefinition, inContext: false }).matchUps) !== null && _h !== void 0 ? _h : [];
                            try {
                                for (var matchUps_1 = (e_4 = void 0, __values(matchUps)), matchUps_1_1 = matchUps_1.next(); !matchUps_1_1.done; matchUps_1_1 = matchUps_1.next()) {
                                    var matchUp = matchUps_1_1.value;
                                    var sides = (_j = matchUp.sides) !== null && _j !== void 0 ? _j : [];
                                    try {
                                        for (var sides_1 = (e_5 = void 0, __values(sides)), sides_1_1 = sides_1.next(); !sides_1_1.done; sides_1_1 = sides_1.next()) {
                                            var side = sides_1_1.value;
                                            var lineUp_1 = (_k = side.lineUp) !== null && _k !== void 0 ? _k : [];
                                            var containsParticipant = lineUp_1.find(function (assignment) { return assignment.participantId === participantId; });
                                            if (containsParticipant) {
                                                side.lineUp = lineUp_1.filter(function (assignment) { return assignment.participantId !== participantId; });
                                                modifyMatchUpNotice({
                                                    tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                                                    drawDefinition: drawDefinition,
                                                    matchUp: matchUp,
                                                });
                                            }
                                        }
                                    }
                                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                                    finally {
                                        try {
                                            if (sides_1_1 && !sides_1_1.done && (_d = sides_1.return)) _d.call(sides_1);
                                        }
                                        finally { if (e_5) throw e_5.error; }
                                    }
                                }
                            }
                            catch (e_4_1) { e_4 = { error: e_4_1 }; }
                            finally {
                                try {
                                    if (matchUps_1_1 && !matchUps_1_1.done && (_c = matchUps_1.return)) _c.call(matchUps_1);
                                }
                                finally { if (e_4) throw e_4.error; }
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_p && !_p.done && (_b = _o.return)) _b.call(_o);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_m && !_m.done && (_a = _l.return)) _a.call(_l);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        else {
            notRemoved.push(participantId);
        }
        return !removeParticipant;
    });
    groupingParticipant.individualParticipantIds =
        updatedIndividualParticipantIds;
    var result = {
        groupingParticipantId: groupingParticipant.participantId,
        cannotRemove: cannotRemove,
        notRemoved: notRemoved,
        removed: removed,
    };
    return ((cannotRemove.length &&
        !suppressErrors && __assign(__assign({}, result), { cannotRemove: cannotRemove, error: CANNOT_REMOVE_PARTICIPANTS })) ||
        result);
}
function removeParticipantIdsFromAllTeams(_a) {
    var _b;
    var _c = _a.participantRole, participantRole = _c === void 0 ? COMPETITOR : _c, _d = _a.individualParticipantIds, individualParticipantIds = _d === void 0 ? [] : _d, _e = _a.groupingTypes, groupingTypes = _e === void 0 ? [TEAM_PARTICIPANT, GROUP] : _e, tournamentRecord = _a.tournamentRecord;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var tournamentParticipants = (_b = tournamentRecord.participants) !== null && _b !== void 0 ? _b : [];
    var _f = getParticipants({
        withMatchUps: true,
        tournamentRecord: tournamentRecord,
        withEvents: true,
    }), participants = _f.participants, mappedMatchUps = _f.mappedMatchUps;
    var modifications = 0;
    tournamentParticipants
        .filter(function (participant) {
        return ((participant.participantRole === participantRole ||
            !participant.participantRole) &&
            participant.participantType &&
            groupingTypes.includes(participant.participantType));
    })
        .forEach(function (grouping) {
        var removed = removeParticipantIdsFromGroupingParticipant({
            groupingParticipant: grouping,
            individualParticipantIds: individualParticipantIds,
            tournamentRecord: tournamentRecord,
            mappedMatchUps: mappedMatchUps,
            participants: participants,
        }).removed;
        if (removed)
            modifications++;
    });
    return modifications ? SUCCESS : { error: NO_PARTICIPANT_REMOVED };
}

/**
 *
 * @param {boolean=} addIndividualParticipantsToEvents
 * @param {object} tournamentRecord
 * @param {string[]} participantIds
 * @returns {object}
 */
function deleteParticipants(params) {
    var e_1, _a, e_2, _b;
    var _c, _d, _e, _f;
    if (!(params === null || params === void 0 ? void 0 : params.tournamentRecord))
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!((_c = params === null || params === void 0 ? void 0 : params.participantIds) === null || _c === void 0 ? void 0 : _c.length))
        return { error: MISSING_PARTICIPANT_IDS };
    var addIndividualParticipantsToEvents = params.addIndividualParticipantsToEvents, tournamentRecord = params.tournamentRecord, participantIds = params.participantIds;
    var participantsCount = ((_d = tournamentRecord.participants) === null || _d === void 0 ? void 0 : _d.length) || 0;
    if (!participantsCount)
        return __assign({}, SUCCESS);
    var teamDrawIds = (_e = (tournamentRecord.events || [])) === null || _e === void 0 ? void 0 : _e.filter(function (_a) {
        var eventType = _a.eventType;
        return eventType === TEAM$2;
    }).map(function (event) { var _a; return (_a = event === null || event === void 0 ? void 0 : event.drawDefinitions) === null || _a === void 0 ? void 0 : _a.map(function (_a) {
        var drawId = _a.drawId;
        return drawId;
    }); }).flat(Infinity);
    // cannot use getParticipants() because event objects don't have drawIds array
    var tournamentParticipants = (_f = getParticipants({
        participantFilters: { participantIds: participantIds },
        tournamentRecord: tournamentRecord,
        withDraws: true,
    }).participants) !== null && _f !== void 0 ? _f : [];
    var getPlacedPairParticipantIds = function () {
        var _a;
        var matchUps = (_a = allTournamentMatchUps({
            matchUpFilters: { drawIds: teamDrawIds, matchUpTypes: [DOUBLES] },
            tournamentRecord: tournamentRecord,
        }).matchUps) !== null && _a !== void 0 ? _a : [];
        var placedPairParticipantIds = matchUps
            .map(function (_a) {
            var sides = _a.sides;
            return sides === null || sides === void 0 ? void 0 : sides.map(function (_a) {
                var participantId = _a.participantId;
                return participantId;
            });
        })
            .flat()
            .filter(Boolean);
        return intersection(placedPairParticipantIds, participantIds);
    };
    // for team draws it is necessary to check matchUps for pair participantIds "discovered" in collectionAssignments
    var placedPairParticipantIds = (teamDrawIds === null || teamDrawIds === void 0 ? void 0 : teamDrawIds.length) && getPlacedPairParticipantIds();
    var participantsInDraws = tournamentParticipants.filter(function (participant) {
        var _a;
        return (_a = participant.draws) === null || _a === void 0 ? void 0 : _a.filter(function (drawInfo) {
            return (!(teamDrawIds === null || teamDrawIds === void 0 ? void 0 : teamDrawIds.length) || !(teamDrawIds === null || teamDrawIds === void 0 ? void 0 : teamDrawIds.includes(drawInfo.drawId))) &&
                drawInfo.positionAssignments;
        }).length;
    });
    if ((placedPairParticipantIds === null || placedPairParticipantIds === void 0 ? void 0 : placedPairParticipantIds.length) || participantsInDraws.length) {
        return { error: EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT };
    }
    var eventParticipantIdsRemoved = {};
    var mappedIndividualParticipantIdsToAdd = {};
    try {
        // If not active in draws, remove participantIds from all entries
        for (var _g = __values(tournamentRecord.events || []), _h = _g.next(); !_h.done; _h = _g.next()) {
            var event_1 = _h.value;
            var result = removeEventEntries({
                participantIds: participantIds,
                event: event_1,
            });
            if (result.error)
                return result;
            eventParticipantIdsRemoved[event_1.eventId] = result.participantIdsRemoved;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
        }
        finally { if (e_1) throw e_1.error; }
    }
    tournamentRecord.participants = tournamentRecord.participants.filter(function (participant) {
        var e_3, _a;
        var participantToRemove = participantIds.includes(participant.participantId) ||
            (participant.participantType === PAIR &&
                participant.individualParticipantIds.some(function (id) {
                    return participantIds.includes(id);
                }));
        // remove deleted individualParticipantIds from TEAMs
        if (!participantToRemove &&
            participant.participantType === TEAM$2 &&
            participant.individualParticipantIds.some(function (id) {
                return participantIds.includes(id);
            })) {
            participant.individualParticipantIds =
                participant.individualParticipantIds.filter(function (id) { return !participantIds.includes(id); });
        }
        if (participantToRemove &&
            addIndividualParticipantsToEvents &&
            [PAIR, TEAM$1].includes(participant.participantType)) {
            try {
                for (var _b = __values(participant.individualParticipantIds ||
                    []), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var individualParticipantId = _c.value;
                    if (!participantIds.includes(individualParticipantId)) {
                        if (!mappedIndividualParticipantIdsToAdd[participant.participantId])
                            mappedIndividualParticipantIdsToAdd[participant.participantId] =
                                [];
                        mappedIndividualParticipantIdsToAdd[participant.participantId].push(individualParticipantId);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        return !participantToRemove;
    });
    var participantsRemovedCount = participantsCount - tournamentRecord.participants.length;
    removeParticipantIdsFromAllTeams({
        individualParticipantIds: participantIds,
        tournamentRecord: tournamentRecord,
    });
    if (addIndividualParticipantsToEvents) {
        try {
            for (var _j = __values(tournamentRecord.events || []), _k = _j.next(); !_k.done; _k = _j.next()) {
                var event_2 = _k.value;
                var groupParticipantIds = eventParticipantIdsRemoved[event_2.eventId];
                var individualParticipantIds = groupParticipantIds
                    .map(function (participantId) {
                    return mappedIndividualParticipantIdsToAdd[participantId] || [];
                })
                    .flat();
                addEventEntries({
                    participantIds: individualParticipantIds,
                    entryStatus: UNGROUPED,
                    tournamentRecord: tournamentRecord,
                    event: event_2,
                });
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_k && !_k.done && (_b = _j.return)) _b.call(_j);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    if (participantsRemovedCount) {
        addNotice({
            payload: { participantIds: participantIds, tournamentId: tournamentRecord.tournamentId },
            topic: DELETE_PARTICIPANTS,
        });
    }
    return participantsRemovedCount
        ? __assign(__assign({}, SUCCESS), { participantsRemovedCount: participantsRemovedCount }) : { error: CANNOT_REMOVE_PARTICIPANTS };
}

function getStageEntries(_a) {
    var _b, _c;
    var _d = _a.selected, selected = _d === void 0 ? true : _d, drawDefinition = _a.drawDefinition, entryStatuses = _a.entryStatuses, drawId = _a.drawId, event = _a.event, stage = _a.stage;
    var entries = (_b = event.entries) !== null && _b !== void 0 ? _b : [];
    if (drawId) {
        var flightProfile = getFlightProfile({ event: event }).flightProfile;
        var flight = (_c = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _c === void 0 ? void 0 : _c.find(function (flight) { return flight.drawId === drawId; });
        if (flight) {
            entries = flight.drawEntries;
        }
        else if (drawDefinition.entries) {
            entries = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries;
        }
    }
    var stageEntries = entries.filter(function (entry) {
        return (!(entryStatuses === null || entryStatuses === void 0 ? void 0 : entryStatuses.length) ||
            !entry.entryStatus ||
            entryStatuses.includes(entry.entryStatus)) &&
            (!stage || !entry.entryStage || entry.entryStage === stage) &&
            (!selected ||
                (entry.entryStatus &&
                    STRUCTURE_SELECTED_STATUSES.includes(entry.entryStatus)));
    });
    return { entries: entries, stageEntries: stageEntries };
}

function destroyGroupEntry(_a) {
    var _b, _c, _d;
    var removeGroupParticipant = _a.removeGroupParticipant, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, participantId = _a.participantId, drawId = _a.drawId, stage = _a.stage, event = _a.event;
    var stack = 'destroyGroupEntry';
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!participantId)
        return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack: stack });
    if (!event)
        return { error: MISSING_EVENT };
    if (!event.eventType ||
        ![DOUBLES_EVENT, TEAM_EVENT].includes(event.eventType)) {
        return decorateResult({ result: { error: INVALID_EVENT_TYPE }, stack: stack });
    }
    var tournamentParticipants = (_b = tournamentRecord.participants) !== null && _b !== void 0 ? _b : [];
    var participant = tournamentParticipants.find(function (participant) { return participant.participantId === participantId; });
    if (!participant) {
        return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack: stack });
    }
    if (!participant.participantType ||
        ![PAIR, TEAM_PARTICIPANT].includes(participant.participantType) ||
        (participant.participantType === TEAM_PARTICIPANT &&
            event.eventType !== TEAM_EVENT) ||
        (participant.participantType === PAIR && event.eventType !== DOUBLES_EVENT)) {
        return { error: INVALID_PARTICIPANT_TYPE };
    }
    var eventEntries = (_c = event.entries) !== null && _c !== void 0 ? _c : [];
    var entry = eventEntries.find(function (entry) { return entry.participantId === participantId; });
    if (!entry)
        return { error: PARTICIPANT_ENTRY_NOT_FOUND };
    var stageEntries = getStageEntries({
        selected: false,
        drawDefinition: drawDefinition,
        drawId: drawId,
        event: event,
        stage: stage,
    }).stageEntries;
    var groupedParticipantIds = stageEntries.map(getParticipantId);
    var individualParticipantIdsInGroups = tournamentParticipants
        .filter(function (_a) {
        var participantId = _a.participantId;
        return groupedParticipantIds.includes(participantId);
    })
        .map(function (_a) {
        var individualParticipantIds = _a.individualParticipantIds;
        return individualParticipantIds;
    })
        .flat()
        .filter(Boolean);
    // find only those individualParticipantIds which do not occur MULTIPLE TIMES in PAIRs/GROUPs in the event.entries or drawEntries
    // this scenario can occur in e.g. ITA tournaments where an individual participant is paired multiple times across flights
    var individualParticipantIds = (_d = participant.individualParticipantIds) === null || _d === void 0 ? void 0 : _d.filter(function (participantId) {
        return arrayIndices(participantId, individualParticipantIdsInGroups).length === 1;
    });
    // remove the group participant from event entries
    var result = removeEventEntries({
        participantIds: [participantId],
        event: event,
    });
    if (result.error)
        return result;
    if (individualParticipantIds === null || individualParticipantIds === void 0 ? void 0 : individualParticipantIds.length) {
        result = addEventEntries({
            participantIds: individualParticipantIds,
            entryStatus: UNGROUPED,
            entryStage: entry.entryStage,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            drawId: drawId,
            event: event,
        });
        if (result.error)
            return result;
    }
    var participantRemoved;
    if (removeGroupParticipant) {
        var result_1 = deleteParticipants({
            participantIds: [participantId],
            tournamentRecord: tournamentRecord,
        });
        if (result_1.success)
            participantRemoved = true;
    }
    return __assign(__assign({}, SUCCESS), { participantRemoved: participantRemoved });
}

function destroyPairEntry(_a) {
    var removeGroupParticipant = _a.removeGroupParticipant, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, participantId = _a.participantId, drawId = _a.drawId, event = _a.event;
    return destroyGroupEntry({
        removeGroupParticipant: removeGroupParticipant,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        participantId: participantId,
        drawId: drawId,
        event: event,
    });
}
function destroyPairEntries(params) {
    var e_1, _a;
    if (!params.tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var participantIds = params.participantIds, rest = __rest(params, ["participantIds"]);
    var destroyedCount = 0;
    var errors = [];
    try {
        for (var participantIds_1 = __values(participantIds), participantIds_1_1 = participantIds_1.next(); !participantIds_1_1.done; participantIds_1_1 = participantIds_1.next()) {
            var participantId = participantIds_1_1.value;
            var result = destroyGroupEntry(__assign({ participantId: participantId }, rest));
            if (result.success)
                destroyedCount += 1;
            if (result.error)
                errors.push(result.error);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (participantIds_1_1 && !participantIds_1_1.done && (_a = participantIds_1.return)) _a.call(participantIds_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return destroyedCount ? __assign({ destroyedCount: destroyedCount }, SUCCESS) : { error: errors };
}

function removeDrawPositionAssignment(params) {
    var tournamentRecord = params.tournamentRecord, replaceWithBye = params.replaceWithBye, drawDefinition = params.drawDefinition, destroyPair = params.destroyPair, entryStatus = params.entryStatus, matchUpsMap = params.matchUpsMap, drawId = params.drawId;
    var stack = 'removeDrawPositionAssignment';
    var result = clearDrawPosition(params);
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    var participantId = result.participantId;
    var drawPosition = params.drawPosition, event = params.event, structureId = params.structureId;
    if ([ALTERNATE, WITHDRAWN].includes(entryStatus) && participantId) {
        var tournamentRecord_1 = params.tournamentRecord;
        var participant = findTournamentParticipant({
            tournamentRecord: tournamentRecord_1,
            participantId: participantId,
        }).participant;
        var _a = participant !== null && participant !== void 0 ? participant : {}, participantType = _a.participantType, individualParticipantIds = _a.individualParticipantIds;
        if (destroyPair && participantType === PAIR) {
            var result_1 = destroyPairEntry({
                tournamentRecord: tournamentRecord_1,
                drawDefinition: drawDefinition,
                participantId: participantId,
                event: event,
            });
            if (result_1.error)
                return decorateResult({ result: result_1, stack: stack });
            if (individualParticipantIds)
                modifyEntriesStatus({
                    participantIds: individualParticipantIds,
                    tournamentRecord: tournamentRecord_1,
                    drawDefinition: drawDefinition,
                    entryStatus: entryStatus,
                    drawId: drawId,
                    event: event,
                });
        }
        else {
            modifyEntriesStatus({
                participantIds: [participantId],
                tournamentRecord: tournamentRecord_1,
                drawDefinition: drawDefinition,
                entryStatus: entryStatus,
                drawId: drawId,
                event: event,
            });
        }
    }
    if (replaceWithBye) {
        var result_2 = assignDrawPositionBye({
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            drawPosition: drawPosition,
            structureId: structureId,
            matchUpsMap: matchUpsMap,
            event: event,
        });
        if (result_2.error)
            return decorateResult({ result: result_2, stack: stack });
    }
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    conditionallyDisableLinkPositioning({
        structure: structure,
        drawPositions: [drawPosition],
    });
    var positionAction = {
        name: 'removeDrawPositionAssignment',
        replaceWithBye: replaceWithBye,
        drawPosition: drawPosition,
        entryStatus: entryStatus,
        structureId: structureId,
    };
    addPositionActionTelemetry({ drawDefinition: drawDefinition, positionAction: positionAction });
    return result;
}

/*
 *
 * @param {string} drawId - id of drawDefinition within which structure is found
 * @param {string} structureId - id of structure of drawPosition
 * @param {number} drawPosition - number of drawPosition for which actions are to be returned
 * @param {boolean} replaceWithBye - boolean whether or not to replace with BYE
 * @param {boolean} destroyPair - if { participantType: PAIR } it is possible to destroy pair entry before modifying entryStatus
 *
 */
function withdrawParticipantAtDrawPosition(params) {
    Object.assign(params, { entryStatus: WITHDRAWN });
    return removeDrawPositionAssignment(params);
}

function capitalizeFirst(str) {
    return !isString(str)
        ? str
        : str
            .split(' ')
            .map(function (name) {
            return name
                .split('')
                .map(function (c, i) { return (i ? c.toLowerCase() : c.toUpperCase()); })
                .join('');
        })
            .join(' ');
}
function constantToString(str) {
    return !isString(str) ? str : capitalizeFirst(str.replace(/_/g, ' '));
}

var structureTemplate = function (_a) {
    var _b = _a.finishingPosition, finishingPosition = _b === void 0 ? ROUND_OUTCOME : _b, qualifyingRoundNumber = _a.qualifyingRoundNumber, structureAbbreviation = _a.structureAbbreviation, _c = _a.seedAssignments, seedAssignments = _c === void 0 ? [] : _c, _d = _a.stageSequence, stageSequence = _d === void 0 ? 1 : _d, structureOrder = _a.structureOrder, seedingProfile = _a.seedingProfile, matchUpFormat = _a.matchUpFormat, structureType = _a.structureType, structureName = _a.structureName, matchUpType = _a.matchUpType, _e = _a.matchUps, matchUps = _e === void 0 ? [] : _e, structureId = _a.structureId, roundOffset = _a.roundOffset, roundLimit = _a.roundLimit, stageOrder = _a.stageOrder, structures = _a.structures, stage = _a.stage;
    var structure = {
        structureId: structureId !== null && structureId !== void 0 ? structureId : UUID(),
        structureAbbreviation: structureAbbreviation,
        finishingPosition: finishingPosition,
        seedAssignments: seedAssignments,
        matchUpFormat: matchUpFormat,
        stageSequence: stageSequence,
        structureName: structureName,
    };
    if (structureOrder)
        structure.structureOrder = structureOrder;
    if (structureType)
        structure.structureType = structureType;
    if (seedingProfile) {
        if (typeof seedingProfile === 'string') {
            structure.seedingProfile = seedingProfile;
        }
        else if (typeof seedingProfile === 'object' &&
            typeof seedingProfile.positioning === 'string') {
            structure.seedingProfile = seedingProfile.positioning;
        }
    }
    if (matchUpType)
        structure.matchUpType = matchUpType;
    if (roundOffset)
        structure.roundOffset = roundOffset;
    if (stageOrder)
        structure.stageOrder = stageOrder;
    if (roundLimit)
        structure.roundLimit = roundLimit;
    if (stage)
        structure.stage = stage;
    if (qualifyingRoundNumber)
        structure.qualifyingRoundNumber = qualifyingRoundNumber;
    var drawPositions = matchUps
        .flatMap(function (_a) {
        var drawPositions = _a.drawPositions;
        return drawPositions;
    })
        .filter(Boolean);
    if (structures) {
        structure.structures = structures;
    }
    else {
        structure.matchUps = matchUps;
        structure.positionAssignments = unique(drawPositions)
            .sort(function (a, b) { return a - b; })
            .map(function (drawPosition) { return ({ drawPosition: drawPosition }); });
    }
    return structure;
};

function addVoluntaryConsolationStructure(_a) {
    var _b = _a.structureName, structureName = _b === void 0 ? constantToString(VOLUNTARY_CONSOLATION) : _b, structureAbbreviation = _a.structureAbbreviation, drawDefinition = _a.drawDefinition, matchUpType = _a.matchUpType, structureId = _a.structureId;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var structure = structureTemplate({
        stage: VOLUNTARY_CONSOLATION,
        structureAbbreviation: structureAbbreviation,
        structureName: structureName,
        matchUps: [],
        structureId: structureId,
        matchUpType: matchUpType,
    });
    if (!drawDefinition.structures)
        drawDefinition.structures = [];
    drawDefinition.structures.push(structure);
    modifyDrawNotice({ drawDefinition: drawDefinition, structureIds: [structure.structureId] });
    return __assign({}, SUCCESS);
}

function getPositionAssignments(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, _c = _a.stage, stage = _c === void 0 ? MAIN : _c, structureId = _a.structureId, structure = _a.structure;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!structure && !drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structure &&
        !structureId &&
        ((_b = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) === null || _b === void 0 ? void 0 : _b.filter(function (structure) { return structure.stage === stage; }).length) === 1) {
        structure = drawDefinition.structures.find(function (structure) { return structure.stage === stage; });
    }
    if (!structure && !structureId)
        return { error: MISSING_STRUCTURE_ID };
    var _d = getPositionAssignments$1({
        drawDefinition: drawDefinition,
        structureId: structureId,
        structure: structure,
    }), error = _d.error, assignments = _d.positionAssignments;
    return {
        positionAssignments: assignments !== null && assignments !== void 0 ? assignments : [],
        structureId: structure === null || structure === void 0 ? void 0 : structure.structureId,
        error: error,
    };
}

function getUpdatedSchedulingProfile(_a) {
    var schedulingProfile = _a.schedulingProfile, venueIds = _a.venueIds, eventIds = _a.eventIds, drawIds = _a.drawIds;
    var issues = [];
    var updatedSchedulingProfile = schedulingProfile === null || schedulingProfile === void 0 ? void 0 : schedulingProfile.map(function (dateSchedulingProfile) {
        var date = extractDate(dateSchedulingProfile === null || dateSchedulingProfile === void 0 ? void 0 : dateSchedulingProfile.scheduleDate);
        if (!date) {
            issues.push("Invalid date: ".concat(dateSchedulingProfile === null || dateSchedulingProfile === void 0 ? void 0 : dateSchedulingProfile.scheduledDate));
            return;
        }
        var venues = ((dateSchedulingProfile === null || dateSchedulingProfile === void 0 ? void 0 : dateSchedulingProfile.venues) || [])
            .map(function (venue) {
            var rounds = venue.rounds, venueId = venue.venueId;
            var venueExists = venueIds === null || venueIds === void 0 ? void 0 : venueIds.includes(venueId);
            if (!venueExists) {
                issues.push("Missing venueId: ".concat(venueId));
                return;
            }
            var filteredRounds = rounds.filter(function (round) {
                var validEventIdAndDrawId = eventIds.includes(round.eventId) &&
                    drawIds.includes(round.drawId);
                if (!validEventIdAndDrawId)
                    issues.push("Invalid eventId: ".concat(round.eventId, " or drawId: ").concat(round.drawId));
                return validEventIdAndDrawId;
            });
            if (!filteredRounds.length)
                return;
            return { venueId: venueId, rounds: filteredRounds };
        })
            .filter(Boolean);
        return venues.length && date && __assign(__assign({}, dateSchedulingProfile), { venues: venues });
    }).filter(Boolean);
    var modifications = issues.length;
    return { updatedSchedulingProfile: updatedSchedulingProfile, modifications: modifications, issues: issues };
}

function validateSchedulingProfile(_a) {
    var tournamentRecords = _a.tournamentRecords, schedulingProfile = _a.schedulingProfile;
    if (!schedulingProfile)
        return { valid: true };
    if (!Array.isArray(schedulingProfile))
        return { valid: false, error: INVALID_VALUES };
    var _b = getAllRelevantSchedulingIds({
        tournamentRecords: tournamentRecords,
    }), venueIds = _b.venueIds, tournamentsMap = _b.tournamentsMap;
    var error, info;
    var isValid = schedulingProfile.every(function (dateSchedule) {
        var scheduleDate = dateSchedule.scheduleDate, venues = dateSchedule.venues;
        if (!isValidDateString(scheduleDate)) {
            return false;
        }
        return venues.every(function (venueProfile) {
            var venueId = venueProfile.venueId, rounds = venueProfile.rounds;
            if (typeof venueId !== 'string') {
                info = 'venueId should be a string';
                return false;
            }
            if (!Array.isArray(rounds)) {
                info = 'rounds should be an array';
                return false;
            }
            if (!venueIds.includes(venueId)) {
                error = VENUE_NOT_FOUND;
                return false;
            }
            var validRounds = rounds.every(function (round) {
                var _a, _b, _c;
                if (!round) {
                    info = 'empty round';
                    return false;
                }
                var roundSegment = round.roundSegment, tournamentId = round.tournamentId, structureId = round.structureId, roundNumber = round.roundNumber, eventId = round.eventId, drawId = round.drawId;
                var rounds = (_c = (_b = (_a = tournamentsMap === null || tournamentsMap === void 0 ? void 0 : tournamentsMap[tournamentId]) === null || _a === void 0 ? void 0 : _a[eventId]) === null || _b === void 0 ? void 0 : _b[drawId]) === null || _c === void 0 ? void 0 : _c[structureId];
                var validRound = rounds === null || rounds === void 0 ? void 0 : rounds.includes(roundNumber);
                if (!validRound)
                    info = 'Invalid rounds';
                var _d = roundSegment || {}, segmentNumber = _d.segmentNumber, segmentsCount = _d.segmentsCount;
                var validSegment = !roundSegment ||
                    (isConvertableInteger(segmentNumber) && isPowerOf2(segmentsCount) && segmentNumber <= segmentsCount);
                if (!validSegment)
                    info = 'Invalid segment';
                return validRound && validSegment;
            });
            return !validRounds ? false : true;
        });
    });
    if (!isValid && !error) {
        error = INVALID_VALUES;
    }
    return { valid: !!isValid, error: error, info: info };
}
function tournamentRelevantSchedulingIds(params) {
    var _a = params.tournamentRecord, tournamentRecord = _a === void 0 ? {} : _a, _b = params.tournamentMap, tournamentMap = _b === void 0 ? {} : _b, requireCourts = params.requireCourts;
    var tournamentIds = [];
    var structureIds = [];
    var eventIds = [];
    var drawIds = [];
    var venueIds = ((tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.venues) || []).map(function (_a) {
        var venueId = _a.venueId, courts = _a.courts;
        return (!requireCourts || (courts === null || courts === void 0 ? void 0 : courts.length)) && venueId;
    });
    var tournamentId = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId;
    if (tournamentId) {
        tournamentIds.push(tournamentId);
        tournamentMap[tournamentId] = {};
        var events = (tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.events) || [];
        events.forEach(function (event) {
            var eventId = event.eventId;
            eventIds.push(eventId);
            tournamentMap[tournamentId][eventId] = {};
            (event.drawDefinitions || []).forEach(function (drawDefinition) {
                var drawId = drawDefinition.drawId;
                drawIds.push(drawId);
                tournamentMap[tournamentId][eventId][drawId] = {};
                var structures = getDrawStructures({ drawDefinition: drawDefinition }).structures;
                (structures || []).forEach(function (structure) {
                    var _a;
                    var structureId = structure.structureId;
                    var matchUps = getAllStructureMatchUps({ structure: structure }).matchUps;
                    var roundMatchUps = getRoundMatchUps({ matchUps: matchUps }).roundMatchUps;
                    var rounds = roundMatchUps && Object.keys(roundMatchUps).map(function (roundNumber) { return parseInt(roundNumber); });
                    tournamentMap[tournamentId][eventId][drawId][structureId] = rounds;
                    structureIds.push(structureId);
                    if ((_a = structure.structures) === null || _a === void 0 ? void 0 : _a.length) {
                        structure.structures.forEach(function (itemStructure) {
                            structureIds.push(itemStructure.structureId);
                            tournamentMap[tournamentId][eventId][drawId][itemStructure.structureId] = rounds;
                        });
                    }
                });
            });
        });
    }
    return {
        tournamentMap: tournamentMap,
        tournamentIds: tournamentIds,
        structureIds: structureIds,
        venueIds: venueIds,
        eventIds: eventIds,
        drawIds: drawIds,
    };
}
function getAllRelevantSchedulingIds(params) {
    var records = ((params === null || params === void 0 ? void 0 : params.tournamentRecords) && Object.values(params === null || params === void 0 ? void 0 : params.tournamentRecords)) || [];
    var tournamentsMap = {};
    var _a = records.reduce(function (aggregator, tournamentRecord) {
        var _a, _b, _c, _d;
        var _e = tournamentRelevantSchedulingIds({
            tournamentRecord: tournamentRecord,
        }), tournamentIds = _e.tournamentIds, tournamentMap = _e.tournamentMap, structureIds = _e.structureIds, venueIds = _e.venueIds, eventIds = _e.eventIds, drawIds = _e.drawIds;
        venueIds.forEach(function (venueId) {
            if (!aggregator.venueIds.includes(venueId))
                aggregator.venueIds.push(venueId);
        });
        (_a = aggregator.tournamentIds).push.apply(_a, __spreadArray([], __read(tournamentIds), false));
        (_b = aggregator.structureIds).push.apply(_b, __spreadArray([], __read(structureIds), false));
        (_c = aggregator.eventIds).push.apply(_c, __spreadArray([], __read(eventIds), false));
        (_d = aggregator.drawIds).push.apply(_d, __spreadArray([], __read(drawIds), false));
        Object.assign(tournamentsMap, tournamentMap);
        return aggregator;
    }, {
        tournamentIds: [],
        structureIds: [],
        venueIds: [],
        eventIds: [],
        drawIds: [],
    }), venueIds = _a.venueIds, eventIds = _a.eventIds, drawIds = _a.drawIds, structureIds = _a.structureIds, tournamentIds = _a.tournamentIds;
    return {
        tournamentsMap: tournamentsMap,
        tournamentIds: tournamentIds,
        structureIds: structureIds,
        venueIds: venueIds,
        eventIds: eventIds,
        drawIds: drawIds,
    };
}

function getInContextCourt(_a) {
    var _b;
    var convertExtensions = _a.convertExtensions, ignoreDisabled = _a.ignoreDisabled, venue = _a.venue, court = _a.court;
    var inContextCourt = __assign(__assign({}, makeDeepCopy(court, convertExtensions, true)), { venueId: venue.venueId });
    var extension = findExtension({
        name: DISABLED,
        element: court,
    }).extension;
    if (ignoreDisabled && extension) {
        var disabledDates_1 = isObject(extension.value)
            ? (_b = extension.value) === null || _b === void 0 ? void 0 : _b.dates
            : undefined;
        var dateAvailability = (extension === null || extension === void 0 ? void 0 : extension.value) === true
            ? []
            : inContextCourt.dateAvailability
                .map(function (availability) {
                var date = availability.date;
                if (!date || disabledDates_1.includes(date))
                    return; // ignore defaultAvailility (no date)
                return availability;
            })
                .filter(Boolean);
        inContextCourt.dateAvailability = dateAvailability;
    }
    return { inContextCourt: inContextCourt };
}

function getDisabledStatus(_a) {
    var _b;
    var _c = _a.dates, dates = _c === void 0 ? [] : _c, extension = _a.extension;
    if (!extension)
        return false;
    // boolean value false means court is entirely disabled
    if (typeof extension.value === 'boolean' && extension.value)
        return true;
    // even if a court is disabled for specific dates, if no dates are provided then it is not considered disabled
    // REFINEMENT: if disabledDates include all dates from tournament.startDate to tournament.endDate then court is disabled
    if (!dates.length)
        return false;
    var disabledDates = isObject(extension.value)
        ? (_b = extension.value) === null || _b === void 0 ? void 0 : _b.dates
        : undefined;
    if (Array.isArray(disabledDates)) {
        if (!(disabledDates === null || disabledDates === void 0 ? void 0 : disabledDates.length))
            return false;
        var datesToConsider = disabledDates.filter(function (date) { return !dates.length || dates.includes(date); });
        // only if all provided dates appear in disabled dates is the court considered disabled
        return !!datesToConsider.length;
    }
    return undefined;
}

function getVenuesAndCourts(params) {
    var _a;
    var convertExtensions = params.convertExtensions, ignoreDisabled = params.ignoreDisabled, _b = params.venueIds, venueIds = _b === void 0 ? [] : _b, dates = params.dates;
    var tournamentRecords = params.tournamentRecords ||
        (params.tournamentRecord && (_a = {},
            _a[params.tournamentRecord.tournamentId] = params.tournamentRecord,
            _a)) ||
        {};
    var uniqueVenueIds = [];
    var uniqueCourtIds = [];
    var courts = [];
    var venues = [];
    var tournamentIds = Object.keys(tournamentRecords).filter(function (id) { return !params.tournamentId || id === params.tournamentId; });
    tournamentIds.forEach(function (tournamentId) {
        var e_1, _a, e_2, _b;
        var _c, _d;
        var tournamentRecord = tournamentRecords[tournamentId];
        try {
            for (var _e = __values((_c = tournamentRecord.venues) !== null && _c !== void 0 ? _c : []), _f = _e.next(); !_f.done; _f = _e.next()) {
                var venue = _f.value;
                if (venueIds.length && !venueIds.includes(venue.venueId))
                    continue;
                if (ignoreDisabled) {
                    var extension = findExtension({
                        name: DISABLED,
                        element: venue,
                    }).extension;
                    if (extension === null || extension === void 0 ? void 0 : extension.value)
                        continue;
                }
                if (!uniqueVenueIds.includes(venue.venueId)) {
                    venues.push(makeDeepCopy(venue, convertExtensions, true));
                    uniqueVenueIds.push(venue.venueId);
                }
                try {
                    for (var _g = (e_2 = void 0, __values((_d = venue.courts) !== null && _d !== void 0 ? _d : [])), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var court = _h.value;
                        if (!uniqueCourtIds.includes(court.courtId)) {
                            // if dates are provided, only ignore the court if it is disabled for all given dates
                            if (ignoreDisabled) {
                                var extension = findExtension({
                                    name: DISABLED,
                                    element: court,
                                }).extension;
                                var isDisabled = getDisabledStatus({ extension: extension, dates: dates });
                                if (isDisabled)
                                    continue;
                            }
                            var inContextCourt = getInContextCourt({
                                convertExtensions: convertExtensions,
                                ignoreDisabled: ignoreDisabled,
                                venue: venue,
                                court: court,
                            }).inContextCourt;
                            courts.push(inContextCourt);
                            uniqueCourtIds.push(court.courtId);
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
    return __assign({ courts: courts, venues: venues }, SUCCESS);
}
function getTournamentVenuesAndCourts(_a) {
    var _b;
    var convertExtensions = _a.convertExtensions, tournamentRecord = _a.tournamentRecord, ignoreDisabled = _a.ignoreDisabled, dates = _a.dates;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var venues = makeDeepCopy((_b = tournamentRecord.venues) !== null && _b !== void 0 ? _b : [], convertExtensions)
        .filter(function (venue) {
        if (!ignoreDisabled)
            return venue;
        var extension = findExtension({
            name: DISABLED,
            element: venue,
        }).extension;
        return !(extension === null || extension === void 0 ? void 0 : extension.value) && venue;
    })
        .filter(Boolean);
    var courts = venues.reduce(function (courts, venue) {
        var additionalCourts = ((venue === null || venue === void 0 ? void 0 : venue.courts) || [])
            .filter(function (court) {
            if (!ignoreDisabled && !(dates === null || dates === void 0 ? void 0 : dates.length))
                return court;
            var extension = findExtension({
                name: DISABLED,
                element: court,
            }).extension;
            return getDisabledStatus({ extension: extension, dates: dates });
        })
            .filter(Boolean)
            .map(function (court) {
            var inContextCourt = getInContextCourt({
                convertExtensions: convertExtensions,
                ignoreDisabled: ignoreDisabled,
                venue: venue,
                court: court,
            }).inContextCourt;
            return inContextCourt;
        });
        return additionalCourts.length ? courts.concat(additionalCourts) : courts;
    }, []);
    return { venues: venues, courts: courts };
}
function getCompetitionVenues(_a) {
    var tournamentRecords = _a.tournamentRecords, requireCourts = _a.requireCourts, dates = _a.dates;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var tournamentIds = Object.keys(tournamentRecords);
    return tournamentIds.reduce(function (accumulator, tournamentId) {
        var tournamentRecord = tournamentRecords[tournamentId];
        var venues = getTournamentVenuesAndCourts({
            tournamentRecord: tournamentRecord,
            dates: dates,
        }).venues;
        venues === null || venues === void 0 ? void 0 : venues.forEach(function (venue) {
            var venueId = venue.venueId, courts = venue.courts;
            var includeVenue = !requireCourts || (courts === null || courts === void 0 ? void 0 : courts.length);
            if (includeVenue && !accumulator.venueIds.includes(venueId)) {
                accumulator.venues.push(venue);
                accumulator.venueIds.push(venueId);
            }
        });
        return accumulator;
    }, { venues: [], venueIds: [] });
}

// Returns arrays of all drawIds and eventIds across tournamentRecords
// Returns an combined array of drawIds and eventIds for each tournamentId
function getEventIdsAndDrawIds(params) {
    var _a;
    var paramCheck = checkRequiredParameters(params, [(_a = {}, _a[TOURNAMENT_RECORDS] = true, _a)]);
    if (paramCheck.error)
        return paramCheck;
    var tournamentIds = Object.keys(params.tournamentRecords);
    return tournamentIds.reduce(function (aggregator, tournamentId) {
        var _a, _b, _c;
        aggregator.tournamentIdMap[tournamentId] = [];
        var tournamentRecord = params.tournamentRecords[tournamentId];
        var events = tournamentRecord.events || [];
        var eventIds = events.map(function (_a) {
            var eventId = _a.eventId;
            return eventId;
        });
        var drawIds = events.map(function (event) { return (event.drawDefinitions || []).map(function (_a) {
            var drawId = _a.drawId;
            return drawId;
        }); }).flat();
        (_a = aggregator.tournamentIdMap[tournamentId]).push.apply(_a, __spreadArray(__spreadArray([], __read(eventIds), false), __read(drawIds), false));
        (_b = aggregator.eventIds).push.apply(_b, __spreadArray([], __read(eventIds), false));
        (_c = aggregator.drawIds).push.apply(_c, __spreadArray([], __read(drawIds), false));
        return aggregator;
    }, { eventIds: [], drawIds: [], tournamentIdMap: {} });
}

function getSchedulingProfile(_a) {
    var tournamentRecords = _a.tournamentRecords, tournamentRecord = _a.tournamentRecord;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var extension = findExtension({
        element: tournamentRecord, // if tournamentRecord is provided, use it
        name: SCHEDULING_PROFILE,
        tournamentRecords: tournamentRecords,
        discover: true,
    }).extension;
    var schedulingProfile = (extension === null || extension === void 0 ? void 0 : extension.value) || [];
    if (schedulingProfile.length) {
        var venueIds = getCompetitionVenues({
            requireCourts: true,
            tournamentRecords: tournamentRecords,
        }).venueIds;
        var _b = getEventIdsAndDrawIds({ tournamentRecords: tournamentRecords }), eventIds = _b.eventIds, drawIds = _b.drawIds;
        var _c = getUpdatedSchedulingProfile({
            schedulingProfile: schedulingProfile,
            venueIds: venueIds,
            eventIds: eventIds,
            drawIds: drawIds,
        }), updatedSchedulingProfile = _c.updatedSchedulingProfile, modifications = _c.modifications, issues = _c.issues;
        if (modifications) {
            schedulingProfile = updatedSchedulingProfile;
            var result = setSchedulingProfile({
                tournamentRecords: tournamentRecords,
                tournamentRecord: tournamentRecord,
                schedulingProfile: schedulingProfile,
            });
            if (result.error)
                return result;
            return { schedulingProfile: schedulingProfile, modifications: modifications, issues: issues };
        }
    }
    return { schedulingProfile: schedulingProfile, modifications: 0 };
}
function setSchedulingProfile(_a) {
    var tournamentRecords = _a.tournamentRecords, tournamentRecord = _a.tournamentRecord, schedulingProfile = _a.schedulingProfile;
    var profileValidity = validateSchedulingProfile({
        tournamentRecords: tournamentRecords,
        schedulingProfile: schedulingProfile,
    });
    if (profileValidity.error)
        return profileValidity;
    if (!schedulingProfile)
        return removeExtension({
            element: tournamentRecord,
            name: SCHEDULING_PROFILE,
            tournamentRecords: tournamentRecords,
            discover: true,
        });
    var extension = {
        name: SCHEDULING_PROFILE,
        value: schedulingProfile,
    };
    return addExtension({ tournamentRecords: tournamentRecords, discover: true, extension: extension });
}
function checkAndUpdateSchedulingProfile(params) {
    var _a;
    var tournamentRecord = params.tournamentRecord;
    var tournamentRecords = params.tournamentRecords ||
        (tournamentRecord && (_a = {},
            _a[tournamentRecord.tournamentId] = tournamentRecord,
            _a)) ||
        {};
    if (!params.schedulingProfile) {
        var _b = getSchedulingProfile({
            tournamentRecords: tournamentRecords,
            tournamentRecord: tournamentRecord,
        }), modifications_1 = _b.modifications, issues_1 = _b.issues;
        return { success: !modifications_1, modifications: modifications_1, issues: issues_1 };
    }
    var venueIds = getCompetitionVenues({ tournamentRecords: tournamentRecords }).venueIds;
    var _c = getEventIdsAndDrawIds({ tournamentRecords: tournamentRecords }), eventIds = _c.eventIds, drawIds = _c.drawIds;
    var _d = getUpdatedSchedulingProfile({
        schedulingProfile: params.schedulingProfile,
        venueIds: venueIds,
        eventIds: eventIds,
        drawIds: drawIds,
    }), updatedSchedulingProfile = _d.updatedSchedulingProfile, modifications = _d.modifications, issues = _d.issues;
    if (modifications) {
        return __assign(__assign({}, setSchedulingProfile({
            schedulingProfile: updatedSchedulingProfile,
            tournamentRecords: tournamentRecords,
        })), { modifications: modifications, issues: issues });
    }
    return __assign(__assign({}, SUCCESS), { modifications: modifications, issues: issues });
}

function addTimeItem(params) {
    var _a;
    var _b = params.duplicateValues, duplicateValues = _b === void 0 ? true : _b, _c = params.creationTime, creationTime = _c === void 0 ? true : _c, removePriorValues = params.removePriorValues, timeItem = params.timeItem, element = params.element;
    if (!timeItem)
        return { error: MISSING_TIME_ITEM };
    if (!element)
        return { error: MISSING_VALUE, info: ELEMENT_REQUIRED };
    var timeItemAttributes = timeItem && Object.keys(timeItem);
    var requiredAttributes = ['itemType', 'itemValue'];
    var validTimeItem = requiredAttributes.filter(function (attribute) {
        return timeItemAttributes.includes(attribute);
    }).length === requiredAttributes.length;
    if (!validTimeItem)
        return { error: INVALID_TIME_ITEM };
    if (!element.timeItems) {
        element.timeItems = [];
    }
    else {
        // check if timeItem with equivalent value already exists
        var itemType = timeItem.itemType, itemSubTypes = timeItem.itemSubTypes, itemValue = timeItem.itemValue;
        var existingTimeItem = itemType &&
            ((_a = getTimeItem({
                itemSubTypes: itemSubTypes,
                itemType: itemType,
                element: element,
            })) === null || _a === void 0 ? void 0 : _a.timeItem);
        if (existingTimeItem &&
            JSON.stringify(existingTimeItem === null || existingTimeItem === void 0 ? void 0 : existingTimeItem.itemValue) ===
                JSON.stringify(itemValue) &&
            !duplicateValues) {
            return __assign({}, SUCCESS);
        }
    }
    if (timeItem.itemSubTypes && !timeItem.itemSubTypes.length) {
        delete timeItem.itemSubTypes;
    }
    if (creationTime) {
        var createdAt = new Date().toISOString();
        Object.assign(timeItem, { createdAt: createdAt });
    }
    if (removePriorValues) {
        element.timeItems = element.timeItems.filter(function (_a) {
            var itemType = _a.itemType;
            return timeItem.itemType !== itemType;
        });
    }
    // if priorValues are being remvoed and there is no new itemValue, do not add by pushing
    var doNotAdd = removePriorValues && !timeItem.itemValue;
    if (!doNotAdd) {
        element.timeItems.push(timeItem);
    }
    return __assign({}, SUCCESS);
}
function addParticipantTimeItem(_a) {
    var _b = _a.creationTime, creationTime = _b === void 0 ? true : _b, removePriorValues = _a.removePriorValues, tournamentRecord = _a.tournamentRecord, duplicateValues = _a.duplicateValues, participantId = _a.participantId, timeItem = _a.timeItem;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!participantId)
        return { error: MISSING_PARTICIPANT_ID };
    var result = findTournamentParticipant({ tournamentRecord: tournamentRecord, participantId: participantId });
    if (result.error)
        return result;
    return addTimeItem({
        element: result.participant,
        removePriorValues: removePriorValues,
        duplicateValues: duplicateValues,
        creationTime: creationTime,
        timeItem: timeItem,
    });
}
function addTournamentTimeItem(params) {
    var removePriorValues = params.removePriorValues, tournamentRecord = params.tournamentRecord, duplicateValues = params.duplicateValues, creationTime = params.creationTime, timeItem = params.timeItem;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    return addTimeItem({
        element: tournamentRecord,
        removePriorValues: removePriorValues,
        duplicateValues: duplicateValues,
        creationTime: creationTime,
        timeItem: timeItem,
    });
}
function addEventTimeItem(params) {
    var removePriorValues = params.removePriorValues, duplicateValues = params.duplicateValues, creationTime = params.creationTime, timeItem = params.timeItem, event = params.event;
    if (!event)
        return { error: EVENT_NOT_FOUND };
    return addTimeItem({
        removePriorValues: removePriorValues,
        duplicateValues: duplicateValues,
        element: event,
        creationTime: creationTime,
        timeItem: timeItem,
    });
}

function modifyEventPublishStatus(_a) {
    var _b;
    var _c = _a.removePriorValues, removePriorValues = _c === void 0 ? true : _c, _d = _a.status, status = _d === void 0 ? PUBLIC : _d, statusObject = _a.statusObject, event = _a.event;
    if (!isObject(statusObject))
        return { error: INVALID_VALUES };
    var publishStatus = getEventPublishStatus({ event: event, status: status });
    var itemType = "".concat(PUBLISH, ".").concat(STATUS$1);
    var updatedTimeItem = {
        itemValue: (_b = {}, _b[status] = __assign(__assign({}, publishStatus), statusObject), _b),
        itemType: itemType,
    };
    return addEventTimeItem({
        timeItem: updatedTimeItem,
        removePriorValues: removePriorValues,
        event: event,
    });
}

function getTournamentInfo(_a) {
    var tournamentRecord = _a.tournamentRecord;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var tournamentInfo = (function (_a) {
        var tournamentId = _a.tournamentId, tournamentRank = _a.tournamentRank, tournamentStatus = _a.tournamentStatus, formalName = _a.formalName, tournamentName = _a.tournamentName, promotionalName = _a.promotionalName, onlineResources = _a.onlineResources, localTimeZone = _a.localTimeZone, startDate = _a.startDate, endDate = _a.endDate, hostCountryCode = _a.hostCountryCode, tournamentContacts = _a.tournamentContacts, tournamentAddresses = _a.tournamentAddresses;
        return ({
            tournamentId: tournamentId,
            tournamentRank: tournamentRank,
            tournamentStatus: tournamentStatus,
            formalName: formalName,
            tournamentName: tournamentName,
            promotionalName: promotionalName,
            onlineResources: onlineResources,
            localTimeZone: localTimeZone,
            startDate: startDate,
            endDate: endDate,
            hostCountryCode: hostCountryCode,
            tournamentContacts: tournamentContacts,
            tournamentAddresses: tournamentAddresses,
        });
    })(tournamentRecord);
    return __assign(__assign({}, SUCCESS), { tournamentInfo: makeDeepCopy(tournamentInfo, false, true) });
}

/**
 * return an array of arrays of grouped structureIds => structureGroups
 * the expectation is that all structures within a drawDefintion are linked
 * return a boolean whether this condition is met => allSructuresLinked
 */
function getStructureGroups(_a) {
    var e_1, _b, e_2, _c, e_3, _d;
    var _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    var drawDefinition = _a.drawDefinition;
    var structures = (_e = drawDefinition.structures) !== null && _e !== void 0 ? _e : [];
    var links = (_f = drawDefinition.links) !== null && _f !== void 0 ? _f : [];
    var structureProfiles = new Map();
    var initStructureProfile = function (structureId) {
        var profile = structureProfiles.get(structureId) ||
            (structureProfiles.set(structureId, {
                drawSources: [],
                drawTargets: [],
                progeny: [],
                sources: [],
                targets: [],
            }) &&
                structureProfiles.get(structureId));
        if (profile && !(profile === null || profile === void 0 ? void 0 : profile.stage)) {
            var structure = structures.find(function (structure) { return structure.structureId === structureId; });
            profile.stage = structure === null || structure === void 0 ? void 0 : structure.stage;
        }
        return profile;
    };
    var sourceStructureIds = {};
    var hasDrawFeedProfile = {};
    var linkedStructureIds = links.map(function (link) {
        var sourceId = link.source.structureId;
        var targetId = link.target.structureId;
        var sourceProfile = initStructureProfile(sourceId);
        var targetProfile = initStructureProfile(targetId);
        if ([BOTTOM_UP, TOP_DOWN, RANDOM, WATERFALL].includes(link.target.feedProfile)) {
            sourceProfile === null || sourceProfile === void 0 ? void 0 : sourceProfile.targets.push(targetId);
            targetProfile === null || targetProfile === void 0 ? void 0 : targetProfile.sources.push(sourceId);
        }
        else if (link.target.feedProfile === DRAW) {
            targetProfile === null || targetProfile === void 0 ? void 0 : targetProfile.drawSources.push(sourceId);
            sourceProfile === null || sourceProfile === void 0 ? void 0 : sourceProfile.drawTargets.push(targetId);
        }
        hasDrawFeedProfile[targetId] =
            hasDrawFeedProfile[targetId] || link.target.feedProfile === DRAW;
        sourceStructureIds[targetId] = unique(__spreadArray(__spreadArray([], __read((sourceStructureIds[targetId] || [])), false), [
            sourceId,
        ], false)).filter(Boolean);
        return [link.source.structureId, link.target.structureId];
    });
    try {
        for (var _r = __values(structureProfiles.keys()), _s = _r.next(); !_s.done; _s = _r.next()) {
            var structureId = _s.value;
            var profile = structureProfiles.get(structureId);
            if (profile) {
                var sourceIds = (_g = profile.targets) !== null && _g !== void 0 ? _g : [];
                while (sourceIds.length) {
                    var sourceId = sourceIds.pop();
                    var sourceProfile = sourceId && structureProfiles[sourceId];
                    if ((_h = sourceProfile === null || sourceProfile === void 0 ? void 0 : sourceProfile.targets) === null || _h === void 0 ? void 0 : _h.length) {
                        sourceIds.push.apply(sourceIds, __spreadArray([], __read(sourceProfile.targets), false));
                    }
                    else if (sourceProfile) {
                        profile.rootStage = sourceProfile.stage;
                    }
                }
                if (!profile.rootStage)
                    profile.rootStage = profile.stage;
                if (!((_j = profile.targets) === null || _j === void 0 ? void 0 : _j.length)) {
                    var targetIds = (_k = profile.sources) !== null && _k !== void 0 ? _k : [];
                    while (targetIds.length) {
                        var targetId = targetIds.pop();
                        var targetProfile = targetId && structureProfiles[targetId];
                        if ((_l = targetProfile === null || targetProfile === void 0 ? void 0 : targetProfile.sources) === null || _l === void 0 ? void 0 : _l.length) {
                            try {
                                for (var _t = (e_2 = void 0, __values(targetProfile.sources)), _u = _t.next(); !_u.done; _u = _t.next()) {
                                    var id = _u.value;
                                    if (!((_m = profile.progeny) === null || _m === void 0 ? void 0 : _m.includes(id)))
                                        (_o = profile.progeny) === null || _o === void 0 ? void 0 : _o.push(id);
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (_u && !_u.done && (_c = _t.return)) _c.call(_t);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                            targetIds.push.apply(targetIds, __spreadArray([], __read(targetProfile.sources), false));
                        }
                    }
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_s && !_s.done && (_b = _r.return)) _b.call(_r);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var maxQualifyingDepth = 0;
    try {
        for (var _v = __values(structureProfiles.keys()), _w = _v.next(); !_w.done; _w = _v.next()) {
            var structureId = _w.value;
            var profile = structureProfiles.get(structureId);
            if (profile && profile.rootStage === QUALIFYING) {
                var drawTargets = [(_p = profile.drawTargets) === null || _p === void 0 ? void 0 : _p[0]];
                var distanceFromMain = 0;
                while (drawTargets.length) {
                    distanceFromMain += 1;
                    var drawTarget = drawTargets.pop();
                    var targetProfile = drawTarget
                        ? structureProfiles.get(drawTarget)
                        : undefined;
                    if ((_q = targetProfile === null || targetProfile === void 0 ? void 0 : targetProfile.drawTargets) === null || _q === void 0 ? void 0 : _q.length) {
                        drawTargets.push(targetProfile.drawTargets[0]);
                    }
                }
                profile.distanceFromMain = distanceFromMain;
                if (distanceFromMain > maxQualifyingDepth)
                    maxQualifyingDepth = distanceFromMain;
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_w && !_w.done && (_d = _v.return)) _d.call(_v);
        }
        finally { if (e_3) throw e_3.error; }
    }
    // iterate through all groups of structureIds to flatten tree of links between structures
    var iterations = linkedStructureIds.length;
    generateRange(0, Math.ceil(iterations / 2)).forEach(function () {
        linkedStructureIds = generateRange(0, iterations).map(function (index) {
            var structureIds = linkedStructureIds[index];
            var mergedWithOverlappingIds = linkedStructureIds.reduce(function (biggest, ids) {
                var hasOverlap = overlap(structureIds, ids);
                return hasOverlap ? biggest.concat.apply(biggest, __spreadArray([], __read(ids), false)) : biggest;
            }, []) || [];
            return unique(structureIds.concat.apply(structureIds, __spreadArray([], __read(mergedWithOverlappingIds), false)));
        });
    });
    // at this point all linkedStructureIds arrays should be equivalent
    // use the first of these as the identity array
    var groupedStructureIds = linkedStructureIds[0];
    // utility method to recognize equivalent arrays of structureIds
    var identityLink = function (a, b) { return intersection(a, b).length === a.length; };
    // check that all arrays of linkedStructureIds are equivalent to identity array
    var allLinkStructuresLinked = linkedStructureIds
        .slice(1)
        .reduce(function (allLinkStructuresLinked, ids) {
        return allLinkStructuresLinked && identityLink(ids, groupedStructureIds);
    }, true);
    // if a drawDefinition contains no links then no structure groups will exist
    // filter out undefined when there are no links in a drawDefinition
    var structureGroups = [groupedStructureIds].filter(Boolean);
    // this is the same as structureGroups, but excludes VOLUNTARY_CONSOLATION
    var linkCheck = [groupedStructureIds].filter(Boolean);
    // iterate through all structures to add missing structureIds
    structures.forEach(function (structure) {
        var structureId = structure.structureId, stage = structure.stage;
        var existingGroup = structureGroups.find(function (group) {
            return group.includes(structureId);
        });
        if (!existingGroup) {
            structureGroups.push([structureId]);
            if (stage !== VOLUNTARY_CONSOLATION)
                linkCheck.push([structureId]);
        }
    });
    var allStructuresLinked = allLinkStructuresLinked && linkCheck.length === 1;
    if (!(links === null || links === void 0 ? void 0 : links.length) && structures.length === 1) {
        initStructureProfile(structures[0].structureId);
    }
    return {
        structureProfiles: Object.fromEntries(structureProfiles),
        allStructuresLinked: allStructuresLinked,
        maxQualifyingDepth: maxQualifyingDepth,
        sourceStructureIds: sourceStructureIds,
        hasDrawFeedProfile: hasDrawFeedProfile,
        structureGroups: structureGroups,
    };
}

function getDrawData(params) {
    var _a = params.tournamentParticipants, tournamentParticipants = _a === void 0 ? [] : _a, includePositionAssignments = params.includePositionAssignments, policyDefinitions = params.policyDefinitions, tournamentRecord = params.tournamentRecord, _b = params.inContext, inContext = _b === void 0 ? true : _b, usePublishState = params.usePublishState, drawDefinition = params.drawDefinition, publishStatus = params.publishStatus, noDeepCopy = params.noDeepCopy, sortConfig = params.sortConfig, context = params.context, event = params.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var drawInfo = (function (_a) {
        var matchUpFormat = _a.matchUpFormat, updatedAt = _a.updatedAt, drawType = _a.drawType, drawName = _a.drawName, drawId = _a.drawId;
        return ({
            matchUpFormat: matchUpFormat,
            updatedAt: updatedAt,
            drawName: drawName,
            drawType: drawType,
            drawId: drawId,
        });
    })(drawDefinition);
    var mainStageSeedAssignments, qualificationStageSeedAssignments;
    var _c = getStructureGroups({
        drawDefinition: drawDefinition,
    }), allStructuresLinked = _c.allStructuresLinked, sourceStructureIds = _c.sourceStructureIds, hasDrawFeedProfile = _c.hasDrawFeedProfile, structureGroups = _c.structureGroups;
    if (!allStructuresLinked) {
        return { error: UNLINKED_STRUCTURES };
    }
    var drawActive = false;
    var participantPlacements = false; // if any positionAssignments include a participantId
    var groupedStructures = structureGroups.map(function (structureIds) {
        var completedStructures = {};
        var structures = structureIds
            .map(function (structureId) {
            var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
            var seedAssignments = getStructureSeedAssignments({
                drawDefinition: drawDefinition,
                structure: structure,
            }).seedAssignments;
            // capture the seedAssignments for MAIN/QUALIFYING { stageSequence: 1 }
            if ((structure === null || structure === void 0 ? void 0 : structure.stage) === MAIN && structure.stageSequence === 1) {
                mainStageSeedAssignments = seedAssignments;
            }
            if ((structure === null || structure === void 0 ? void 0 : structure.stage) === QUALIFYING && structure.stageSequence === 1) {
                qualificationStageSeedAssignments = seedAssignments;
            }
            return structure;
        })
            .sort(function (a, b) { return structureSort(a, b, sortConfig); })
            .map(function (structure) {
            var _a;
            if (!structure)
                return;
            var structureId = structure === null || structure === void 0 ? void 0 : structure.structureId;
            var seedAssignments = [];
            // pass seedAssignments from { stageSequence: 1 } to other stages
            if (structure.stage && [MAIN, CONSOLATION, PLAY_OFF].includes(structure.stage)) {
                seedAssignments = mainStageSeedAssignments;
            }
            if ((structure === null || structure === void 0 ? void 0 : structure.stage) === QUALIFYING) {
                seedAssignments = qualificationStageSeedAssignments;
            }
            var _b = getAllStructureMatchUps({
                // only propagate seedAssignments where none are present
                seedAssignments: !((_a = structure === null || structure === void 0 ? void 0 : structure.seedAssignments) === null || _a === void 0 ? void 0 : _a.length) ? seedAssignments : undefined,
                context: __assign({ drawId: drawInfo.drawId }, context),
                tournamentParticipants: tournamentParticipants,
                policyDefinitions: policyDefinitions,
                tournamentRecord: tournamentRecord,
                usePublishState: usePublishState,
                publishStatus: publishStatus,
                drawDefinition: drawDefinition,
                inContext: inContext,
                structure: structure,
                event: event,
            }), matchUps = _b.matchUps, roundMatchUps = _b.roundMatchUps, roundProfile = _b.roundProfile;
            var positionAssignments = getPositionAssignments$1({
                structure: structure,
            }).positionAssignments;
            var participantResults = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(xa(PARTICIPANT_ID)).map(function (assignment) {
                participantPlacements = true;
                var drawPosition = assignment.drawPosition, participantId = assignment.participantId;
                var extension = findExtension({
                    element: assignment,
                    name: TALLY,
                }).extension;
                return (extension && {
                    drawPosition: drawPosition,
                    participantId: participantId,
                    participantResult: extension.value,
                });
            }).filter(function (f) { return f === null || f === void 0 ? void 0 : f.participantResult; });
            var structureInfo = structure
                ? (function (_a) {
                    var stageSequence = _a.stageSequence, structureName = _a.structureName, structureType = _a.structureType, matchUpFormat = _a.matchUpFormat, stage = _a.stage;
                    return ({
                        stageSequence: stageSequence,
                        structureName: structureName,
                        structureType: structureType,
                        matchUpFormat: matchUpFormat,
                        stage: stage,
                    });
                })(structure)
                : {};
            structureInfo.sourceStructureIds = sourceStructureIds[structureId];
            structureInfo.hasDrawFeedProfile = hasDrawFeedProfile[structureId];
            structureInfo.positionAssignments = positionAssignments;
            structureInfo.structureActive = matchUps.reduce(function (active, matchUp) {
                var _a;
                var activeMatchUpStatus = [
                    COMPLETED$1,
                    CANCELLED$1,
                    DEFAULTED,
                    RETIRED$1,
                    WALKOVER$2,
                    IN_PROGRESS$1,
                    DOUBLE_DEFAULT,
                    DOUBLE_WALKOVER,
                ].includes(matchUp.matchUpStatus);
                return active || activeMatchUpStatus || !!matchUp.winningSide || !!((_a = matchUp.score) === null || _a === void 0 ? void 0 : _a.scoreStringSide1);
            }, false);
            var structureCompleted = matchUps.reduce(function (completed, matchUp) {
                return completed && [BYE, COMPLETED$1, RETIRED$1, WALKOVER$2, DEFAULTED, ABANDONED$1].includes(matchUp.matchUpStatus);
            }, !!matchUps.length);
            structureInfo.structureCompleted = structureCompleted;
            completedStructures[structureId] = structureCompleted;
            if (structureInfo.structureActive)
                drawActive = true;
            return __assign(__assign({}, structureInfo), { participantResults: participantResults, seedAssignments: seedAssignments, roundMatchUps: roundMatchUps, roundProfile: roundProfile, structureId: structureId });
        });
        // cleanup attribute used for sorting
        structures.forEach(function (structure) {
            var _a;
            if (!includePositionAssignments)
                delete structure.positionAssignments;
            structure.sourceStructuresComplete = (_a = structure.sourceStructureIds) === null || _a === void 0 ? void 0 : _a.every(function (id) { return completedStructures[id]; });
        });
        return structures;
    });
    var structures = groupedStructures.flat();
    drawInfo.drawActive = drawActive;
    drawInfo.participantPlacements = participantPlacements;
    drawInfo.drawGenerated = structures === null || structures === void 0 ? void 0 : structures.reduce(function (generated, structure) {
        return generated || !!(structure === null || structure === void 0 ? void 0 : structure.roundMatchUps);
    }, false);
    drawInfo.drawCompleted = structures === null || structures === void 0 ? void 0 : structures.reduce(function (completed, structure) { return completed && structure.structureCompleted; }, true);
    return __assign({ structures: noDeepCopy ? structures : makeDeepCopy(structures, false, true), drawInfo: noDeepCopy ? drawInfo : makeDeepCopy(drawInfo, false, true) }, SUCCESS);
}

function getEventData(params) {
    var includePositionAssignments = params.includePositionAssignments, t = params.tournamentRecord, participantsProfile = params.participantsProfile, policyDefinitions = params.policyDefinitions, usePublishState = params.usePublishState, _a = params.status, status = _a === void 0 ? PUBLIC : _a, sortConfig = params.sortConfig, e = params.event;
    var tournamentRecord = makeDeepCopy(t, false, true);
    var event = makeDeepCopy(e, false, true);
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    var eventId = event.eventId;
    var tournamentId = tournamentRecord.tournamentId, endDate = tournamentRecord.endDate;
    var publishStatus = getEventPublishStatus({ event: event, status: status });
    var publishState = getPublishState({ event: event }).publishState;
    var tournamentParticipants = getParticipants(__assign(__assign({ withGroupings: true, withEvents: false, withDraws: false }, participantsProfile), { // order is important!!
        tournamentRecord: tournamentRecord })).participants;
    var stageFilter = function (_a) {
        var _b, _c, _d;
        var stage = _a.stage, drawId = _a.drawId;
        if (!usePublishState)
            return true;
        var stageDetails = (_c = (_b = publishStatus === null || publishStatus === void 0 ? void 0 : publishStatus.drawDetails) === null || _b === void 0 ? void 0 : _b[drawId]) === null || _c === void 0 ? void 0 : _c.stageDetails;
        if (!stageDetails || !Object.keys(stageDetails).length)
            return true;
        return (_d = stageDetails[stage]) === null || _d === void 0 ? void 0 : _d.published;
    };
    var structureFilter = function (_a) {
        var _b, _c, _d;
        var structureId = _a.structureId, drawId = _a.drawId;
        if (!usePublishState)
            return true;
        var structureDetails = (_c = (_b = publishStatus === null || publishStatus === void 0 ? void 0 : publishStatus.drawDetails) === null || _b === void 0 ? void 0 : _b[drawId]) === null || _c === void 0 ? void 0 : _c.structureDetails;
        if (!structureDetails || !Object.keys(structureDetails).length)
            return true;
        return (_d = structureDetails[structureId]) === null || _d === void 0 ? void 0 : _d.published;
    };
    var drawFilter = function (_a) {
        var _b, _c;
        var drawId = _a.drawId;
        if (!usePublishState)
            return true;
        if (publishStatus.drawDetails) {
            return (_c = (_b = publishStatus.drawDetails[drawId]) === null || _b === void 0 ? void 0 : _b.publishingDetail) === null || _c === void 0 ? void 0 : _c.published;
        }
        else if (publishStatus.drawIds) {
            return publishStatus.drawIds.includes(drawId);
        }
        return true;
    };
    var roundLimitMapper = function (_a) {
        var e_1, _b;
        var _c, _d, _e, _f;
        var drawId = _a.drawId, structure = _a.structure;
        if (!usePublishState)
            return structure;
        var roundLimit = (_f = (_e = (_d = (_c = publishStatus === null || publishStatus === void 0 ? void 0 : publishStatus.drawDetails) === null || _c === void 0 ? void 0 : _c[drawId]) === null || _d === void 0 ? void 0 : _d.structureDetails) === null || _e === void 0 ? void 0 : _e[structure.structureId]) === null || _f === void 0 ? void 0 : _f.roundLimit;
        if (isConvertableInteger(roundLimit)) {
            var roundNumbers = generateRange(1, roundLimit + 1);
            var roundMatchUps = {};
            var roundProfile = {};
            try {
                for (var roundNumbers_1 = __values(roundNumbers), roundNumbers_1_1 = roundNumbers_1.next(); !roundNumbers_1_1.done; roundNumbers_1_1 = roundNumbers_1.next()) {
                    var roundNumber = roundNumbers_1_1.value;
                    if (structure.roundMatchUps[roundNumber]) {
                        roundMatchUps[roundNumber] = structure.roundMatchUps[roundNumber];
                        roundProfile[roundNumber] = structure.roundProfile[roundNumber];
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (roundNumbers_1_1 && !roundNumbers_1_1.done && (_b = roundNumbers_1.return)) _b.call(roundNumbers_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            structure.roundMatchUps = roundMatchUps;
            structure.roundProfile = roundProfile;
        }
        return structure;
    };
    var drawDefinitions = event.drawDefinitions || [];
    var drawsData = drawDefinitions
        .filter(drawFilter)
        .map(function (drawDefinition) {
        return (function (_a) {
            var drawInfo = _a.drawInfo, structures = _a.structures;
            return (__assign(__assign({}, drawInfo), { structures: structures }));
        })(getDrawData({
            context: { eventId: eventId, tournamentId: tournamentId, endDate: endDate },
            includePositionAssignments: includePositionAssignments,
            tournamentParticipants: tournamentParticipants,
            noDeepCopy: true,
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            usePublishState: usePublishState,
            drawDefinition: drawDefinition,
            publishStatus: publishStatus,
            sortConfig: sortConfig,
            event: event,
        }));
    })
        .map(function (_a) {
        var structures = _a.structures, drawData = __rest(_a, ["structures"]);
        var filteredStructures = structures === null || structures === void 0 ? void 0 : structures.filter(function (_a) {
            var stage = _a.stage, structureId = _a.structureId;
            return structureFilter({ structureId: structureId, drawId: drawData.drawId }) &&
                stageFilter({ stage: stage, drawId: drawData.drawId });
        }).map(function (structure) {
            return roundLimitMapper({ drawId: drawData.drawId, structure: structure });
        });
        return __assign(__assign({}, drawData), { structures: filteredStructures });
    })
        .filter(function (drawData) { var _a; return (_a = drawData.structures) === null || _a === void 0 ? void 0 : _a.length; });
    var tournamentInfo = getTournamentInfo({ tournamentRecord: tournamentRecord }).tournamentInfo;
    var venues = tournamentRecord.venues || [];
    var venuesData = venues.map(function (venue) {
        return (function (_a) {
            var venueData = _a.venueData;
            return (__assign({}, venueData));
        })(getVenueData({
            tournamentRecord: tournamentRecord,
            venueId: venue.venueId,
        }));
    });
    var eventInfo = (function (_a) {
        var eventId = _a.eventId, eventName = _a.eventName, eventType = _a.eventType, eventLevel = _a.eventLevel, surfaceCategory = _a.surfaceCategory, matchUpFormat = _a.matchUpFormat, category = _a.category, gender = _a.gender, startDate = _a.startDate, endDate = _a.endDate, ballType = _a.ballType, discipline = _a.discipline;
        return ({
            eventId: eventId,
            eventName: eventName,
            eventType: eventType,
            eventLevel: eventLevel,
            surfaceCategory: surfaceCategory,
            matchUpFormat: matchUpFormat,
            category: category,
            gender: gender,
            startDate: startDate,
            endDate: endDate,
            ballType: ballType,
            discipline: discipline,
        });
    })(event);
    var eventData = {
        tournamentInfo: tournamentInfo,
        venuesData: venuesData,
        eventInfo: eventInfo,
        drawsData: drawsData,
    };
    eventData.eventInfo.publishState = publishState;
    eventData.eventInfo.publish = publishStatus;
    return __assign(__assign({}, SUCCESS), { eventData: eventData });
}

function publishEvent(params) {
    var _a, e_1, _b;
    var _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    var includePositionAssignments = params.includePositionAssignments, removePriorValues = params.removePriorValues, tournamentRecord = params.tournamentRecord, _q = params.status, status = _q === void 0 ? PUBLIC : _q, event = params.event, drawIdsToRemove = params.drawIdsToRemove, drawIdsToAdd = params.drawIdsToAdd;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    // publishing will draw on scoring policy, round naming policy and participant (privacy) policy
    var appliedPolicies = getAppliedPolicies({ tournamentRecord: tournamentRecord, event: event }).appliedPolicies;
    var policyDefinitions = __assign(__assign({}, appliedPolicies), params.policyDefinitions);
    var eventDrawIds = (_d = (_c = event.drawDefinitions) === null || _c === void 0 ? void 0 : _c.map(function (_a) {
        var drawId = _a.drawId;
        return drawId;
    })) !== null && _d !== void 0 ? _d : [];
    var keyedDrawIds = params.drawDetails
        ? Object.keys(params.drawDetails)
        : [];
    var specifiedDrawIds = keyedDrawIds.length ? [] : params.drawIds;
    var drawIdsToValidate = (_a = (drawIdsToAdd !== null && drawIdsToAdd !== void 0 ? drawIdsToAdd : [])).concat.apply(_a, __spreadArray(__spreadArray(__spreadArray([], __read((drawIdsToRemove !== null && drawIdsToRemove !== void 0 ? drawIdsToRemove : [])), false), __read((specifiedDrawIds !== null && specifiedDrawIds !== void 0 ? specifiedDrawIds : [])), false), __read(keyedDrawIds), false));
    var invalidDrawIds = drawIdsToValidate.filter(function (drawId) { return !eventDrawIds.includes(drawId); });
    if (invalidDrawIds.length) {
        return decorateResult({
            result: { error: DRAW_DEFINITION_NOT_FOUND },
            context: { invalidDrawIds: invalidDrawIds },
        });
    }
    var pubStatus = getEventPublishStatus({ event: event, status: status });
    // filter out any drawIds that do not have corresponding drawDefinitions not in the event
    var drawDetails = Object.keys((pubStatus === null || pubStatus === void 0 ? void 0 : pubStatus.drawDetails) || {})
        .filter(function (drawId) { return eventDrawIds.includes(drawId); })
        .reduce(function (details, drawId) {
        details[drawId] = pubStatus.drawDetails[drawId];
        return details;
    }, {});
    var _loop_1 = function (drawId) {
        var e_2, _r, e_3, _s, e_4, _t, e_5, _u, e_6, _v;
        if (!drawIdsToValidate.length || drawIdsToValidate.includes(drawId)) {
            if ((drawIdsToRemove === null || drawIdsToRemove === void 0 ? void 0 : drawIdsToRemove.includes(drawId)) ||
                ((specifiedDrawIds === null || specifiedDrawIds === void 0 ? void 0 : specifiedDrawIds.length) && !specifiedDrawIds.includes(drawId))) {
                drawDetails[drawId] = __assign(__assign({}, drawDetails[drawId]), { publishingDetail: { published: false } });
            }
            else if ((drawIdsToAdd === null || drawIdsToAdd === void 0 ? void 0 : drawIdsToAdd.includes(drawId)) ||
                (specifiedDrawIds === null || specifiedDrawIds === void 0 ? void 0 : specifiedDrawIds.includes(drawId)) ||
                !(specifiedDrawIds === null || specifiedDrawIds === void 0 ? void 0 : specifiedDrawIds.length)) {
                drawDetails[drawId] = __assign(__assign({}, drawDetails[drawId]), { publishingDetail: { published: true } });
            }
        }
        if ((_e = params.drawDetails) === null || _e === void 0 ? void 0 : _e[drawId]) {
            var newDetail = params.drawDetails[drawId];
            var structureDetails = (_f = newDetail.structureDetails) !== null && _f !== void 0 ? _f : drawDetails[drawId].structureDetails;
            var stageDetails = (_h = (_g = newDetail.stageDetails) !== null && _g !== void 0 ? _g : drawDetails[drawId].stageDetails) !== null && _h !== void 0 ? _h : {};
            var _w = newDetail.structureIdsToRemove, structureIdsToRemove = _w === void 0 ? [] : _w, _x = newDetail.structureIdsToAdd, structureIdsToAdd = _x === void 0 ? [] : _x, _y = newDetail.publishingDetail, publishingDetail = _y === void 0 ? {} : _y, _z = newDetail.stagesToRemove, stagesToRemove = _z === void 0 ? [] : _z, _0 = newDetail.stagesToAdd, stagesToAdd = _0 === void 0 ? [] : _0;
            if (structureIdsToAdd || stagesToAdd)
                publishingDetail.published = true;
            drawDetails[drawId] = {
                publishingDetail: publishingDetail,
                structureDetails: structureDetails,
                stageDetails: stageDetails,
            };
            if (structureIdsToAdd.length || structureIdsToRemove.length) {
                var drawStructureIds_2 = ((_l = (_k = (_j = event.drawDefinitions) === null || _j === void 0 ? void 0 : _j.find(function (drawDefinition) { return drawDefinition.drawId === drawId; })) === null || _k === void 0 ? void 0 : _k.structures) !== null && _l !== void 0 ? _l : []).map(function (_a) {
                    var structureId = _a.structureId;
                    return structureId;
                });
                var structureIdsToValidate = (structureIdsToAdd !== null && structureIdsToAdd !== void 0 ? structureIdsToAdd : []).concat(structureIdsToRemove !== null && structureIdsToRemove !== void 0 ? structureIdsToRemove : []);
                var invalidStructureIds = structureIdsToValidate.filter(function (structureId) { return !drawStructureIds_2.includes(structureId); });
                if (invalidStructureIds.length) {
                    return { value: decorateResult({
                            result: { error: STRUCTURE_NOT_FOUND },
                            context: { invalidStructureIds: invalidStructureIds },
                        }) };
                }
                structureDetails = structureDetails !== null && structureDetails !== void 0 ? structureDetails : {};
                try {
                    for (var drawStructureIds_1 = (e_2 = void 0, __values(drawStructureIds_2)), drawStructureIds_1_1 = drawStructureIds_1.next(); !drawStructureIds_1_1.done; drawStructureIds_1_1 = drawStructureIds_1.next()) {
                        var structureId = drawStructureIds_1_1.value;
                        if (structureIdsToRemove.includes(structureId)) {
                            structureDetails[structureId] = { published: false };
                        }
                        else {
                            structureDetails[structureId] = { published: true };
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (drawStructureIds_1_1 && !drawStructureIds_1_1.done && (_r = drawStructureIds_1.return)) _r.call(drawStructureIds_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                drawDetails[drawId].structureDetails = structureDetails;
            }
            var drawStages = ((_p = (_o = (_m = event.drawDefinitions) === null || _m === void 0 ? void 0 : _m.find(function (drawDefinition) { return drawDefinition.drawId === drawId; })) === null || _o === void 0 ? void 0 : _o.structures) !== null && _p !== void 0 ? _p : []).map(function (_a) {
                var stage = _a.stage;
                return stage;
            });
            if (stagesToAdd.length) {
                try {
                    for (var stagesToAdd_1 = (e_3 = void 0, __values(stagesToAdd)), stagesToAdd_1_1 = stagesToAdd_1.next(); !stagesToAdd_1_1.done; stagesToAdd_1_1 = stagesToAdd_1.next()) {
                        var stage = stagesToAdd_1_1.value;
                        stageDetails[stage] = { published: true };
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (stagesToAdd_1_1 && !stagesToAdd_1_1.done && (_s = stagesToAdd_1.return)) _s.call(stagesToAdd_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                try {
                    for (var drawStages_1 = (e_4 = void 0, __values(drawStages)), drawStages_1_1 = drawStages_1.next(); !drawStages_1_1.done; drawStages_1_1 = drawStages_1.next()) {
                        var stage = drawStages_1_1.value;
                        if (!stageDetails[stage]) {
                            stageDetails[stage] = { published: false };
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (drawStages_1_1 && !drawStages_1_1.done && (_t = drawStages_1.return)) _t.call(drawStages_1);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
            if (stagesToAdd.length || stagesToRemove.length) {
                try {
                    for (var stagesToRemove_1 = (e_5 = void 0, __values(stagesToRemove)), stagesToRemove_1_1 = stagesToRemove_1.next(); !stagesToRemove_1_1.done; stagesToRemove_1_1 = stagesToRemove_1.next()) {
                        var stage = stagesToRemove_1_1.value;
                        stageDetails[stage] = { published: false };
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (stagesToRemove_1_1 && !stagesToRemove_1_1.done && (_u = stagesToRemove_1.return)) _u.call(stagesToRemove_1);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                try {
                    for (var drawStages_2 = (e_6 = void 0, __values(drawStages)), drawStages_2_1 = drawStages_2.next(); !drawStages_2_1.done; drawStages_2_1 = drawStages_2.next()) {
                        var stage = drawStages_2_1.value;
                        if (!stageDetails[stage]) {
                            stageDetails[stage] = { published: true };
                        }
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (drawStages_2_1 && !drawStages_2_1.done && (_v = drawStages_2.return)) _v.call(drawStages_2);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
            if (stagesToAdd.length || stagesToRemove.length) {
                drawDetails[drawId].stageDetails = stageDetails;
            }
        }
    };
    try {
        for (var eventDrawIds_1 = __values(eventDrawIds), eventDrawIds_1_1 = eventDrawIds_1.next(); !eventDrawIds_1_1.done; eventDrawIds_1_1 = eventDrawIds_1.next()) {
            var drawId = eventDrawIds_1_1.value;
            var state_1 = _loop_1(drawId);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (eventDrawIds_1_1 && !eventDrawIds_1_1.done && (_b = eventDrawIds_1.return)) _b.call(eventDrawIds_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    modifyEventPublishStatus({
        statusObject: { drawDetails: drawDetails },
        removePriorValues: removePriorValues,
        status: status,
        event: event,
    });
    var eventData = getEventData({
        includePositionAssignments: includePositionAssignments,
        usePublishState: true,
        tournamentRecord: tournamentRecord,
        policyDefinitions: policyDefinitions,
        event: event,
    }).eventData;
    addNotice({
        payload: { eventData: eventData, tournamentId: tournamentRecord.tournamentId },
        topic: PUBLISH_EVENT,
    });
    return __assign(__assign({}, SUCCESS), { eventData: eventData });
}

var DELETE_DRAW_DEFINITIONS = 'deleteDrawDefinitions';
var AUTO_SCHEDULING_AUDIT = 'autoSchedulingAudit';
var DELETE_EVENTS = 'deleteEvents';
var auditConstants = {
    AUTO_SCHEDULING_AUDIT: AUTO_SCHEDULING_AUDIT,
    DELETE_EVENTS: DELETE_EVENTS,
    DELETE_DRAW_DEFINITIONS: DELETE_DRAW_DEFINITIONS,
};

function deleteDrawDefinitions(params) {
    var e_1, _a;
    var _b, _c, _d, _e, _f, _g, _h, _j;
    if (!params.tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var stack = 'deleteDrawDefinitions';
    var drawIds = (_b = params.drawIds) !== null && _b !== void 0 ? _b : [];
    var event = params.event;
    var _k = params.autoPublish, autoPublish = _k === void 0 ? true : _k, tournamentRecord = params.tournamentRecord, auditData = params.auditData, eventId = params.eventId, force = params.force;
    var appliedPolicies = getAppliedPolicies({ tournamentRecord: tournamentRecord, event: event }).appliedPolicies;
    var policyDefinitions = __assign(__assign({}, appliedPolicies), params.policyDefinitions);
    var drawId = Array.isArray(drawIds) ? drawIds[0] : undefined;
    if (!event) {
        var result = findEvent({ tournamentRecord: tournamentRecord, eventId: eventId, drawId: drawId });
        if (result.error)
            return result;
        event = result.event;
    }
    var deletedDrawsDetail = [];
    var matchUpIds = [];
    var auditTrail = [];
    if (!(event === null || event === void 0 ? void 0 : event.drawDefinitions))
        return decorateResult({
            info: 'event has no drawDefinition',
            result: __assign({}, SUCCESS),
            stack: stack,
        });
    var eventDrawIds = event.drawDefinitions.map(function (_a) {
        var drawId = _a.drawId;
        return drawId;
    });
    // if drawIds were not provided, assume that the intent is to delete all drawDefinitions
    if (!drawIds.length)
        drawIds = eventDrawIds;
    drawIds = drawIds.filter(function (drawId) { return eventDrawIds.includes(drawId); });
    if (!drawIds.length)
        return decorateResult({
            info: 'nothing to do; no matching drawIds in event.',
            result: __assign({}, SUCCESS),
            stack: stack,
        });
    var flightProfile = makeDeepCopy(getFlightProfile({ event: event }).flightProfile, false, true);
    var positionAssignmentMap = function (_a) {
        var participantId = _a.participantId, drawPosition = _a.drawPosition, qualifier = _a.qualifier, bye = _a.bye;
        return ({ bye: bye, qualifier: qualifier, drawPosition: drawPosition, participantId: participantId });
    };
    var allowDeletionWithScoresPresent = force !== null && force !== void 0 ? force : (_d = (_c = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_SCORING]) === null || _c === void 0 ? void 0 : _c.allowDeletionWithScoresPresent) === null || _d === void 0 ? void 0 : _d.drawDefinitions;
    var publishStatus = (_e = getEventPublishStatus({ event: event })) !== null && _e !== void 0 ? _e : {};
    var updatedDrawIds = (_g = (_f = publishStatus.drawIds) !== null && _f !== void 0 ? _f : (publishStatus.drawDetails && Object.keys(publishStatus.drawDetails))) !== null && _g !== void 0 ? _g : [];
    var publishedDrawsDeleted;
    var drawIdsWithScoresPresent = [];
    var filteredDrawDefinitions = event.drawDefinitions.filter(function (drawDefinition) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (drawIds.includes(drawDefinition.drawId)) {
            var matchUps = (_b = (_a = allDrawMatchUps({ event: event, drawDefinition: drawDefinition })) === null || _a === void 0 ? void 0 : _a.matchUps) !== null && _b !== void 0 ? _b : [];
            var scoresPresent = matchUps.some(function (_a) {
                var score = _a.score;
                return checkScoreHasValue({ score: score });
            });
            if (scoresPresent && !allowDeletionWithScoresPresent) {
                drawIdsWithScoresPresent.push(drawDefinition.drawId);
                return true;
            }
            var drawId_1 = drawDefinition.drawId, drawType = drawDefinition.drawType, drawName = drawDefinition.drawName;
            var flight = (_c = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _c === void 0 ? void 0 : _c.find(function (flight) { return flight.drawId === drawDefinition.drawId; });
            if (flight) {
                flight.drawEntries = (_d = flight.drawEntries) === null || _d === void 0 ? void 0 : _d.filter(function (entry) {
                    return STRUCTURE_SELECTED_STATUSES.includes(entry.entryStatus);
                });
            }
            if (updatedDrawIds.includes(drawId_1)) {
                updatedDrawIds = updatedDrawIds.filter(function (id) { return id !== drawId_1; });
                publishedDrawsDeleted = true;
            }
            var mainStructure = (_f = (_e = getDrawStructures({
                stageSequence: 1,
                drawDefinition: drawDefinition,
                stage: MAIN,
            })) === null || _e === void 0 ? void 0 : _e.structures) === null || _f === void 0 ? void 0 : _f[0];
            var pa = mainStructure
                ? getPositionAssignments({
                    structureId: mainStructure.structureId,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                })
                : undefined;
            var positionAssignments = (_g = pa === null || pa === void 0 ? void 0 : pa.positionAssignments) === null || _g === void 0 ? void 0 : _g.map(positionAssignmentMap);
            var qualifyingStructures = (_h = getDrawStructures({
                stage: QUALIFYING,
                drawDefinition: drawDefinition,
            })) === null || _h === void 0 ? void 0 : _h.structures;
            var qualifyingPositionAssignments = (qualifyingStructures === null || qualifyingStructures === void 0 ? void 0 : qualifyingStructures.length)
                ? qualifyingStructures.map(function (qualifyingStructure) {
                    var stageSequence = qualifyingStructure.stageSequence;
                    var pa = getPositionAssignments({
                        structureId: qualifyingStructure.structureId,
                        tournamentRecord: tournamentRecord,
                        drawDefinition: drawDefinition,
                    });
                    var positionAssignments = pa === null || pa === void 0 ? void 0 : pa.positionAssignments.map(positionAssignmentMap);
                    return { positionAssignments: positionAssignments, stageSequence: stageSequence };
                })
                : undefined;
            // TODO: conditionally add auditTrail based on policyDefinitions
            var audit = {
                action: DELETE_DRAW_DEFINITIONS,
                payload: {
                    drawDefinitions: [drawDefinition],
                    eventId: eventId !== null && eventId !== void 0 ? eventId : event === null || event === void 0 ? void 0 : event.eventId,
                    auditData: auditData,
                },
            };
            auditTrail.push(audit);
            deletedDrawsDetail.push(definedAttributes({
                tournamentId: tournamentRecord.tournamentId,
                eventId: eventId !== null && eventId !== void 0 ? eventId : event === null || event === void 0 ? void 0 : event.eventId,
                qualifyingPositionAssignments: qualifyingPositionAssignments,
                positionAssignments: positionAssignments,
                auditData: auditData,
                drawType: drawType,
                drawName: drawName,
                drawId: drawId_1,
            }));
            matchUps === null || matchUps === void 0 ? void 0 : matchUps.forEach(function (_a) {
                var matchUpId = _a.matchUpId;
                return matchUpIds.push(matchUpId);
            });
        }
        return !drawIds.includes(drawDefinition.drawId);
    });
    if (drawIdsWithScoresPresent.length && !force) {
        return decorateResult({
            context: { drawIdsWithScoresPresent: drawIdsWithScoresPresent },
            result: { error: SCORES_PRESENT },
            stack: stack,
        });
    }
    event.drawDefinitions = filteredDrawDefinitions;
    if (flightProfile) {
        var extension = {
            name: FLIGHT_PROFILE,
            value: flightProfile,
        };
        addEventExtension({ event: event, extension: extension });
    }
    // cleanup references to drawId in schedulingProfile extension
    checkAndUpdateSchedulingProfile({ tournamentRecord: tournamentRecord });
    if (publishedDrawsDeleted) {
        var drawDetails = {};
        try {
            for (var updatedDrawIds_1 = __values(updatedDrawIds), updatedDrawIds_1_1 = updatedDrawIds_1.next(); !updatedDrawIds_1_1.done; updatedDrawIds_1_1 = updatedDrawIds_1.next()) {
                var drawId_2 = updatedDrawIds_1_1.value;
                drawDetails[drawId_2] = (_j = (_h = publishStatus.drawDetails) === null || _h === void 0 ? void 0 : _h[drawId_2]) !== null && _j !== void 0 ? _j : {
                    published: true,
                };
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (updatedDrawIds_1_1 && !updatedDrawIds_1_1.done && (_a = updatedDrawIds_1.return)) _a.call(updatedDrawIds_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var result = modifyEventPublishStatus({
            statusObject: { drawDetails: drawDetails },
            event: event,
        });
        if (result.error)
            return { error: result.error };
    }
    if (auditTrail.length) {
        addNotice({ topic: AUDIT, payload: auditTrail });
    }
    if (matchUpIds.length) {
        deleteMatchUpsNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            matchUpIds: matchUpIds,
        });
    }
    drawIds.forEach(function (drawId) {
        deleteDrawNotice({ drawId: drawId });
    });
    addDrawDeletionTelemetry({ event: event, deletedDrawsDetail: deletedDrawsDetail, auditData: auditData });
    if (autoPublish && publishedDrawsDeleted) {
        var result = publishEvent({
            drawIdsToRemove: drawIds,
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            event: event,
        });
        if (result.error)
            return __assign(__assign({}, SUCCESS), { info: result.error });
    }
    return __assign({}, SUCCESS);
}
function addDrawDeletionTelemetry(_a) {
    var event = _a.event, deletedDrawsDetail = _a.deletedDrawsDetail, auditData = _a.auditData;
    var extension = findExtension({
        name: DRAW_DELETIONS,
        element: event,
    }).extension;
    var deletionData = __assign(__assign({}, auditData), { deletedDrawsDetail: deletedDrawsDetail });
    var updatedExtension = {
        name: DRAW_DELETIONS,
        value: Array.isArray(extension === null || extension === void 0 ? void 0 : extension.value)
            ? extension === null || extension === void 0 ? void 0 : extension.value.concat(deletionData)
            : [deletionData],
    };
    addExtension({ element: event, extension: updatedExtension });
}

function deleteFlightProfileAndFlightDraws(_a) {
    var _b;
    var _c = _a.autoPublish, autoPublish = _c === void 0 ? true : _c, tournamentRecord = _a.tournamentRecord, auditData = _a.auditData, event = _a.event, force = _a.force;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    var flightProfile = getFlightProfile({ event: event }).flightProfile;
    if (flightProfile) {
        var drawIds = (_b = flightProfile.flights) === null || _b === void 0 ? void 0 : _b.map(function (_a) {
            var drawId = _a.drawId;
            return drawId;
        }).filter(Boolean);
        var result = deleteDrawDefinitions({
            eventId: event.eventId,
            tournamentRecord: tournamentRecord,
            autoPublish: autoPublish,
            auditData: auditData,
            drawIds: drawIds,
            event: event,
            force: force,
        });
        if (result.error)
            return result;
        return removeEventExtension({ event: event, name: FLIGHT_PROFILE });
    }
    return __assign({}, SUCCESS);
}

function getMatchUp$1(_a) {
    var matchUps = _a.matchUps, matchUpId = _a.matchUpId;
    var matchUp = (matchUps || []).find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
    return { matchUp: matchUp };
}

function findDrawMatchUp(_a) {
    var e_1, _b;
    var tournamentParticipants = _a.tournamentParticipants, afterRecoveryTimes = _a.afterRecoveryTimes, contextContent = _a.contextContent, contextProfile = _a.contextProfile, drawDefinition = _a.drawDefinition, matchUpsMap = _a.matchUpsMap, matchUpId = _a.matchUpId, inContext = _a.inContext, context = _a.context, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    if (typeof matchUpId !== 'string')
        return { error: INVALID_VALUES };
    var _c = getDrawStructures({ drawDefinition: drawDefinition }).structures, structures = _c === void 0 ? [] : _c;
    if (contextProfile && !contextContent)
        contextContent = getContextContent({ contextProfile: contextProfile, drawDefinition: drawDefinition });
    try {
        for (var structures_1 = __values(structures), structures_1_1 = structures_1.next(); !structures_1_1.done; structures_1_1 = structures_1.next()) {
            var structure = structures_1_1.value;
            var matchUps = getAllStructureMatchUps({
                tournamentParticipants: tournamentParticipants,
                afterRecoveryTimes: afterRecoveryTimes,
                contextContent: contextContent,
                drawDefinition: drawDefinition,
                contextProfile: contextProfile,
                matchUpsMap: matchUpsMap,
                inContext: inContext,
                structure: structure,
                context: context,
                event: event,
            }).matchUps;
            var matchUp = getMatchUp$1({ matchUps: matchUps, matchUpId: matchUpId }).matchUp;
            if (matchUp)
                return { matchUp: matchUp, structure: structure };
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (structures_1_1 && !structures_1_1.done && (_b = structures_1.return)) _b.call(structures_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { error: MATCHUP_NOT_FOUND };
}

// method only currently used for AD_HOC matchUps where there are no drawPositions
function assignMatchUpSideParticipant(_a) {
    var e_1, _b;
    var _c, _d;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, participantId = _a.participantId, sideNumber = _a.sideNumber, matchUpId = _a.matchUpId, event = _a.event;
    if (participantId && typeof participantId !== 'string')
        return { error: INVALID_PARTICIPANT_ID };
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    var noSideNumberProvided = sideNumber === undefined;
    if (noSideNumberProvided)
        sideNumber = 1;
    if (![1, 2].includes(sideNumber))
        return decorateResult({
            result: { error: INVALID_VALUES, context: { sideNumber: sideNumber } },
        });
    var _e = findDrawMatchUp({
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
        event: event,
    }), matchUp = _e.matchUp, structure = _e.structure;
    if (!matchUp)
        return { error: MATCHUP_NOT_FOUND };
    var isAdHoc = !(structure === null || structure === void 0 ? void 0 : structure.structures) &&
        !(drawDefinition.drawType && drawDefinition.drawType !== AD_HOC) &&
        !((_c = structure === null || structure === void 0 ? void 0 : structure.matchUps) === null || _c === void 0 ? void 0 : _c.find(function (_a) {
            var roundPosition = _a.roundPosition;
            return !!roundPosition;
        }));
    if (!isAdHoc)
        return { error: INVALID_DRAW_TYPE };
    // if no participantId / participant is being un-assigned, there cannot be a score or completed outcome
    if (!participantId &&
        (((_d = matchUp === null || matchUp === void 0 ? void 0 : matchUp.score) === null || _d === void 0 ? void 0 : _d.scoreStringSide1) ||
            completedMatchUpStatuses.includes(matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpstatus) ||
            ((matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpStatus) &&
                [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUp.matchUpStatus))))
        return {
            error: CANNOT_REMOVE_PARTICIPANTS,
            info: 'matchUp has completed status or score',
        };
    if (matchUp) {
        matchUp.sides = [1, 2].map(function (currentSideNumber) {
            var _a, _b;
            var existingSide = (_b = (_a = matchUp.sides) === null || _a === void 0 ? void 0 : _a.find(function (side) { return side.sideNumber === currentSideNumber; })) !== null && _b !== void 0 ? _b : { sideNumber: currentSideNumber };
            return sideNumber === currentSideNumber
                ? __assign(__assign({}, existingSide), { participantId: participantId }) : existingSide;
        });
        // makes it possible to use this method with no sideNumber provided
        // each time a participant is assigned the sides are swapped
        if (noSideNumberProvided) {
            try {
                for (var _f = __values(matchUp.sides), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var side = _g.value;
                    if (side.sideNumber)
                        side.sideNumber = 3 - side.sideNumber;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        modifyMatchUpNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            context: 'assignSideParticipant',
            drawDefinition: drawDefinition,
            matchUp: matchUp,
        });
    }
    return __assign(__assign({}, SUCCESS), { sidesSwapped: noSideNumberProvided });
}

function getPairedPreviousMatchUpIsDoubleExit(params) {
    var sourceMatchUp = params.sourceMatchUp;
    var targetMatchUp = params.targetMatchUp, structure = params.structure, matchUpsMap = params.matchUpsMap, drawPosition = params.drawPosition;
    var previousRoundNumber = targetMatchUp.roundNumber > 1 && targetMatchUp.roundNumber - 1;
    var structureMatchUps = getMappedStructureMatchUps({
        structureId: structure.structureId,
        matchUpsMap: matchUpsMap,
    });
    if (!sourceMatchUp && drawPosition) {
        sourceMatchUp = structureMatchUps.find(function (_a) {
            var drawPositions = _a.drawPositions, roundNumber = _a.roundNumber;
            return roundNumber === previousRoundNumber &&
                (drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(drawPosition));
        });
    }
    // look for paired round position in previous round
    // missing sourceMatchUp causes pairedRoundPosition to be NaN, which is OK
    var sourceRoundPosition = sourceMatchUp === null || sourceMatchUp === void 0 ? void 0 : sourceMatchUp.roundPosition;
    var offset = sourceRoundPosition % 2 ? 1 : -1;
    var pairedRoundPosition = sourceRoundPosition + offset;
    var pairedPreviousMatchUp = previousRoundNumber &&
        structureMatchUps.find(function (_a) {
            var roundNumber = _a.roundNumber, roundPosition = _a.roundPosition;
            return roundNumber === previousRoundNumber &&
                roundPosition === pairedRoundPosition;
        });
    var pairedPreviousMatchUpStatus = pairedPreviousMatchUp === null || pairedPreviousMatchUp === void 0 ? void 0 : pairedPreviousMatchUp.matchUpStatus;
    var pairedPreviousMatchUpIsDoubleExit = [
        DOUBLE_WALKOVER,
        DOUBLE_DEFAULT,
    ].includes(pairedPreviousMatchUpStatus);
    return { pairedPreviousMatchUp: pairedPreviousMatchUp, pairedPreviousMatchUpIsDoubleExit: pairedPreviousMatchUpIsDoubleExit };
}

function getUpdatedDrawPositions(_a) {
    var drawPosition = _a.drawPosition, drawPositions = _a.drawPositions;
    var positionAdded = false;
    var positionAssigned = !!(drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(drawPosition));
    var updated = positionAssigned
        ? drawPositions || []
        : __spreadArray(__spreadArray([], __read(drawPositions), false), [undefined, undefined], false).slice(0, 2) // accounts for empty array, should always have length 2
            .map(function (position) {
            if (!position && !positionAssigned) {
                positionAssigned = true;
                positionAdded = true;
                return drawPosition;
            }
            else {
                return position;
            }
        })
            .sort(numericSort)
            .filter(Boolean);
    var updatedDrawPositions = updated;
    return { updatedDrawPositions: updatedDrawPositions, positionAdded: positionAdded, positionAssigned: positionAssigned };
}

function getPairedPreviousMatchUp(_a) {
    var structureId = _a.structureId, matchUpsMap = _a.matchUpsMap, matchUp = _a.matchUp;
    var sourceRoundPosition = matchUp === null || matchUp === void 0 ? void 0 : matchUp.roundPosition;
    var offset = sourceRoundPosition % 2 ? 1 : -1;
    var pairedRoundPosition = sourceRoundPosition + offset;
    var structureMatchUps = getMappedStructureMatchUps({
        matchUpsMap: matchUpsMap,
        structureId: structureId,
    });
    var pairedPreviousMatchUp = structureMatchUps.find(function (_a) {
        var roundNumber = _a.roundNumber, roundPosition = _a.roundPosition;
        return roundNumber === (matchUp === null || matchUp === void 0 ? void 0 : matchUp.roundNumber) &&
            roundPosition === pairedRoundPosition;
    });
    return { pairedPreviousMatchUp: pairedPreviousMatchUp };
}

function updateMatchUpStatusCodes(_a) {
    var _b;
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, sourceMatchUpStatus = _a.sourceMatchUpStatus, sourceMatchUpId = _a.sourceMatchUpId, matchUpsMap = _a.matchUpsMap, matchUp = _a.matchUp;
    // find sourceMatchUp and matchUp paired with sourceMatchUp to workout sourceSideNumber
    var sourceMatchUp = inContextDrawMatchUps.find(function (matchUp) { return matchUp.matchUpId === sourceMatchUpId; });
    var pairedPreviousMatchUp = getPairedPreviousMatchUp({
        structureId: sourceMatchUp === null || sourceMatchUp === void 0 ? void 0 : sourceMatchUp.structureId,
        matchUp: sourceMatchUp,
        matchUpsMap: matchUpsMap,
    }).pairedPreviousMatchUp;
    if (sourceMatchUp && pairedPreviousMatchUp) {
        var pairedPreviousMatchUpId_1 = pairedPreviousMatchUp === null || pairedPreviousMatchUp === void 0 ? void 0 : pairedPreviousMatchUp.matchUpId;
        var pairedMatchUp = inContextDrawMatchUps.find(function (matchUp) { return matchUp.matchUpId === pairedPreviousMatchUpId_1; });
        var sourceSideNumber_1 = (sourceMatchUp === null || sourceMatchUp === void 0 ? void 0 : sourceMatchUp.structureId) === (pairedMatchUp === null || pairedMatchUp === void 0 ? void 0 : pairedMatchUp.structureId)
            ? // if structureIds are equivalent then sideNumber is inferred from roundPositions
                ((sourceMatchUp === null || sourceMatchUp === void 0 ? void 0 : sourceMatchUp.roundPosition) < (pairedMatchUp === null || pairedMatchUp === void 0 ? void 0 : pairedMatchUp.roundPosition) && 1) ||
                    2
            : // if different structureIds then structureId that is not equivalent to noContextWinnerMatchUp.structureId is fed
                // ... and fed positions are always sideNumber 1
                (sourceMatchUp.structureId === (pairedMatchUp === null || pairedMatchUp === void 0 ? void 0 : pairedMatchUp.structureId) && 2) || 1;
        matchUp.matchUpStatusCodes = ((_b = matchUp.matchUpStatusCodes) !== null && _b !== void 0 ? _b : []).map(function (code) {
            var value = isString(code) || !isNaN(code) ? { code: code } : code;
            if (value.sideNumber === sourceSideNumber_1) {
                return __assign(__assign({}, value), { previousMatchUpStatus: sourceMatchUpStatus });
            }
            return value;
        });
    }
}

function getExitWinningSide(_a) {
    // determine which sideNumber { drawPosition } will be and assign winningSide
    // NOTE: at present this is dependent on presence of .winnerMatchUpId and .loserMatchUpId
    // TODO: reusable function that will be able to use position targeting using links
    // which will need to filter by previous round then get positionTargets for each matchUp in the round
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, drawPosition = _a.drawPosition, matchUpId = _a.matchUpId;
    var sourceMatchUps = inContextDrawMatchUps
        .filter(function (_a) {
        var winnerMatchUpId = _a.winnerMatchUpId, loserMatchUpId = _a.loserMatchUpId;
        return loserMatchUpId === matchUpId || winnerMatchUpId === matchUpId;
    })
        // sourceMatchUps MUST be sorted by roundPosition
        .sort(function (a, b) { return a.roundPosition - b.roundPosition; });
    var matchUp = inContextDrawMatchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
    var feedRound = matchUp.feedRound;
    return feedRound
        ? 1
        : sourceMatchUps.reduce(function (sideNumber, sourceMatchUp, index) {
            var _a;
            if ((_a = sourceMatchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.includes(drawPosition))
                return index + 1;
            return sideNumber;
        }, undefined);
}

function updateSideLineUp(_a) {
    var _b, _c, _d, _e;
    var inContextTargetMatchUp = _a.inContextTargetMatchUp, drawPositionSideIndex = _a.drawPositionSideIndex, teamParticipantId = _a.teamParticipantId, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, matchUp = _a.matchUp, event = _a.event;
    // update matchUp.sides to include lineUps
    var drawPositionSideNumber = (_c = (_b = inContextTargetMatchUp === null || inContextTargetMatchUp === void 0 ? void 0 : inContextTargetMatchUp.sides) === null || _b === void 0 ? void 0 : _b[drawPositionSideIndex]) === null || _c === void 0 ? void 0 : _c.sideNumber;
    var sideExists = drawPositionSideNumber &&
        ((_d = matchUp.sides) === null || _d === void 0 ? void 0 : _d.find(function (side) { return side.sideNumber === drawPositionSideNumber; }));
    var existingExtension = findExtension({
        element: drawDefinition,
        name: LINEUPS,
    }).extension;
    var lineUps = (existingExtension === null || existingExtension === void 0 ? void 0 : existingExtension.value) || {};
    var lineUp = makeDeepCopy(lineUps[teamParticipantId], false, true);
    if (sideExists) {
        (_e = matchUp === null || matchUp === void 0 ? void 0 : matchUp.sides) === null || _e === void 0 ? void 0 : _e.forEach(function (side) {
            if (side.sideNumber === drawPositionSideNumber) {
                side.lineUp = lineUp;
            }
        });
    }
    else {
        matchUp.sides = [1, 2].map(function (sideNumber) {
            var _a, _b;
            var existingSide = (_b = (_a = matchUp.sides) === null || _a === void 0 ? void 0 : _a.find(function (side) { return side.sideNumber === sideNumber; })) !== null && _b !== void 0 ? _b : {};
            return __assign(__assign({}, existingSide), { sideNumber: sideNumber });
        });
        var targetSide = matchUp.sides.find(function (side) { return side.sideNumber === drawPositionSideNumber; });
        if (targetSide)
            targetSide.lineUp = lineUp;
    }
    modifyMatchUpNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        context: 'updateSidLineUp',
        eventId: event === null || event === void 0 ? void 0 : event.eventId,
        drawDefinition: drawDefinition,
        matchUp: matchUp,
    });
}

function assignMatchUpDrawPosition(_a) {
    var _b, _c, _d, _e, _f, _g, _h;
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, sourceMatchUpStatus = _a.sourceMatchUpStatus, tournamentRecord = _a.tournamentRecord, sourceMatchUpId = _a.sourceMatchUpId, drawDefinition = _a.drawDefinition, matchUpStatus = _a.matchUpStatus, drawPosition = _a.drawPosition, matchUpsMap = _a.matchUpsMap, matchUpId = _a.matchUpId, event = _a.event;
    var stack = 'assignMatchUpDrawPosition';
    if (!matchUpsMap) {
        matchUpsMap = getMatchUpsMap({ drawDefinition: drawDefinition });
    }
    if (!inContextDrawMatchUps) {
        inContextDrawMatchUps =
            (_b = getAllDrawMatchUps({
                inContext: true,
                drawDefinition: drawDefinition,
                matchUpsMap: matchUpsMap,
            }).matchUps) !== null && _b !== void 0 ? _b : [];
    }
    var inContextMatchUp = inContextDrawMatchUps.find(function (m) { return m.matchUpId === matchUpId; });
    var structureId = inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.structureId;
    var structure = (_c = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) === null || _c === void 0 ? void 0 : _c.find(function (structure) { return structure.structureId === structureId; });
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    var matchUp = (_d = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.drawMatchUps) === null || _d === void 0 ? void 0 : _d.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
    var drawPositions = (_e = matchUp === null || matchUp === void 0 ? void 0 : matchUp.drawPositions) !== null && _e !== void 0 ? _e : [];
    var _j = getUpdatedDrawPositions({ drawPosition: drawPosition, drawPositions: drawPositions }), positionAdded = _j.positionAdded, positionAssigned = _j.positionAssigned, updatedDrawPositions = _j.updatedDrawPositions;
    var positionAssignments = getPositionAssignments$1({
        drawDefinition: drawDefinition,
        structure: structure,
    }).positionAssignments;
    var matchUpAssignments = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) {
        return updatedDrawPositions.includes(assignment.drawPosition);
    });
    var isByeMatchUp = matchUpAssignments === null || matchUpAssignments === void 0 ? void 0 : matchUpAssignments.find(function (_a) {
        var bye = _a.bye;
        return bye;
    });
    var isDoubleExitExit = (matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpStatus) &&
        [WALKOVER$2, DEFAULTED].includes(matchUp.matchUpStatus) &&
        updatedDrawPositions.filter(Boolean).length < 2;
    matchUpStatus =
        (isByeMatchUp && BYE) ||
            matchUpStatus ||
            (isDoubleExitExit && matchUp.matchUpStatus) ||
            ((matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpStatus) &&
                [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUp.matchUpStatus) &&
                matchUp.matchUpStatus) ||
            TO_BE_PLAYED;
    if (matchUp && positionAdded) {
        // necessary to update inContextDrawMatchUps
        inContextDrawMatchUps =
            (_f = getAllDrawMatchUps({
                inContext: true,
                drawDefinition: drawDefinition,
                matchUpsMap: matchUpsMap,
            }).matchUps) !== null && _f !== void 0 ? _f : [];
        var exitWinningSide = (isDoubleExitExit &&
            getExitWinningSide({
                inContextDrawMatchUps: inContextDrawMatchUps,
                drawPosition: drawPosition,
                matchUpId: matchUpId,
            })) ||
            undefined;
        if (matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpStatusCodes) {
            updateMatchUpStatusCodes({
                inContextDrawMatchUps: inContextDrawMatchUps,
                sourceMatchUpStatus: sourceMatchUpStatus,
                sourceMatchUpId: sourceMatchUpId,
                matchUpsMap: matchUpsMap,
                matchUp: matchUp,
            });
        }
        // only in the case of "Double Exit" produced "Exit" can a winningSide be assigned at the same time as a position
        Object.assign(matchUp, {
            drawPositions: updatedDrawPositions,
            winningSide: exitWinningSide,
            matchUpStatus: matchUpStatus,
        });
        modifyMatchUpNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            eventId: inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.eventId,
            context: stack,
            drawDefinition: drawDefinition,
            matchUp: matchUp,
        });
    }
    var targetData = positionTargets({
        inContextDrawMatchUps: inContextDrawMatchUps,
        inContextMatchUp: inContextMatchUp,
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
    });
    var _k = targetData.targetMatchUps, winnerMatchUp = _k.winnerMatchUp, loserMatchUp = _k.loserMatchUp, loserTargetDrawPosition = _k.loserTargetDrawPosition, loserTargetLink = targetData.targetLinks.loserTargetLink;
    var structureMatchUps = getMappedStructureMatchUps({
        structureId: structure.structureId,
        matchUpsMap: matchUpsMap,
    });
    if (positionAssigned && isByeMatchUp) {
        if (winnerMatchUp) {
            if ([BYE, DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUpStatus)) {
                var result = assignMatchUpDrawPosition({
                    matchUpId: winnerMatchUp.matchUpId,
                    inContextDrawMatchUps: inContextDrawMatchUps,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    drawPosition: drawPosition,
                    matchUpsMap: matchUpsMap,
                });
                if (result.error)
                    return result;
            }
            else {
                var structureId_1 = winnerMatchUp.structureId;
                if (structureId_1 !== structure.structureId) {
                    console.log('winnerMatchUp in different structure... participant is in different targetDrawPosition');
                }
            }
        }
    }
    else if (winnerMatchUp && inContextMatchUp && !inContextMatchUp.feedRound) {
        var pairedPreviousMatchUpIsDoubleExit = getPairedPreviousMatchUpIsDoubleExit({
            targetMatchUp: matchUp,
            drawPosition: drawPosition,
            matchUpsMap: matchUpsMap,
            structure: structure,
        }).pairedPreviousMatchUpIsDoubleExit;
        if (pairedPreviousMatchUpIsDoubleExit) {
            var result = assignMatchUpDrawPosition({
                matchUpId: winnerMatchUp.matchUpId,
                inContextDrawMatchUps: inContextDrawMatchUps,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                drawPosition: drawPosition,
                matchUpsMap: matchUpsMap,
            });
            if (result.error)
                return result;
        }
    }
    // if { matchUpType: TEAM } then also assign the default lineUp to the appopriate side
    if ((matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpType) === TEAM) {
        var inContextTargetMatchUp = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.find(function (_a) {
            var matchUpId = _a.matchUpId;
            return matchUpId === matchUp.matchUpId;
        });
        var sides = (_g = inContextTargetMatchUp === null || inContextTargetMatchUp === void 0 ? void 0 : inContextTargetMatchUp.sides) !== null && _g !== void 0 ? _g : [];
        var drawPositionSideIndex = sides.reduce(function (index, side, i) { return (side.drawPosition === drawPosition ? i : index); }, undefined);
        var teamParticipantId = (_h = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (assignment) { return assignment.drawPosition === drawPosition; })) === null || _h === void 0 ? void 0 : _h.participantId;
        if (teamParticipantId && drawPositionSideIndex !== undefined) {
            updateSideLineUp({
                inContextTargetMatchUp: inContextTargetMatchUp,
                drawPositionSideIndex: drawPositionSideIndex,
                teamParticipantId: teamParticipantId,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                matchUp: matchUp,
            });
        }
    }
    // if FIRST_MATCH_LOSER_CONSOLATION, check whether a BYE should be placed in consolation feed
    if ((loserTargetLink === null || loserTargetLink === void 0 ? void 0 : loserTargetLink.linkCondition) === FIRST_MATCHUP &&
        updatedDrawPositions.filter(Boolean).length === 2 &&
        !isByeMatchUp) {
        var firstRoundMatchUps = structureMatchUps.filter(function (_a) {
            var drawPositions = _a.drawPositions, roundNumber = _a.roundNumber;
            return roundNumber === 1 && overlap(drawPositions, updatedDrawPositions);
        });
        var byePropagation = firstRoundMatchUps.every(function (_a) {
            var matchUpStatus = _a.matchUpStatus;
            return [COMPLETED$1, RETIRED$1].includes(matchUpStatus);
        });
        if (byePropagation && loserMatchUp) {
            var structureId_2 = loserMatchUp.structureId;
            var result = assignDrawPositionBye({
                drawPosition: loserTargetDrawPosition,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                structureId: structureId_2,
                matchUpsMap: matchUpsMap,
                event: event,
            });
            if (result.error)
                return result;
        }
    }
    if (positionAssigned) {
        return __assign({}, SUCCESS);
    }
    else {
        return decorateResult({
            result: { error: DRAW_POSITION_ASSIGNED },
            context: { drawPosition: drawPosition },
            stack: stack,
        });
    }
}

function getRoundRobinGroupMatchUps(_a) {
    var drawPositions = _a.drawPositions;
    var positionMatchUps = function (position) {
        return drawPositions
            .filter(function (p) { return p !== position; })
            .map(function (o) { return [position, o]; });
    };
    var groupMatchUps = [].concat.apply([], __spreadArray([], __read(drawPositions.map(positionMatchUps)), false));
    var uniqueMatchUpGroupings = unique(groupMatchUps.map(drawPositionsHash)).map(function (h) { return h.split('|').map(function (p) { return +p; }); });
    return { groupMatchUps: groupMatchUps, uniqueMatchUpGroupings: uniqueMatchUpGroupings };
}
function drawPositionsHash(drawPositions) {
    return __spreadArray([], __read(drawPositions), false).sort(numericSort).join('|');
}
function groupRounds(_a) {
    var groupSize = _a.groupSize, drawPositionOffset = _a.drawPositionOffset;
    var numArr = function (count) { return __spreadArray([], __read(Array(count)), false).map(function (_, i) { return i; }); };
    var groupPositions = numArr(2 * Math.round(groupSize / 2) + 1).slice(1);
    var rounds = numArr(groupPositions.length - 1).map(function () { return []; });
    var aRow = groupPositions.slice(0, groupPositions.length / 2);
    var bRow = groupPositions.slice(groupPositions.length / 2);
    groupPositions.slice(1).forEach(function (_, i) {
        aRow.forEach(function (_, j) {
            rounds[i].push([aRow[j], bRow[j]]);
        });
        var aHead = aRow.shift();
        var aDown = aRow.pop();
        var bUp = bRow.shift();
        aRow = __spreadArray([aHead, bUp], __read(aRow), false).filter(Boolean);
        bRow = __spreadArray(__spreadArray([], __read(bRow), false), [aDown], false).filter(Boolean);
    });
    var aHead = aRow.shift();
    var aDown = aRow.pop();
    var bUp = bRow.shift();
    aRow = __spreadArray([aHead, bUp], __read(aRow), false).filter(Boolean);
    bRow = __spreadArray(__spreadArray([], __read(bRow), false), [aDown], false).filter(Boolean);
    var sum = function (x) { return x[0].reduce(function (a, b) { return a + b; }); };
    return __spreadArray([], __read(rounds), false).reverse()
        .sort(function (a, b) { return sum(a) - sum(b); })
        .map(function (round) {
        return round
            .filter(function (groupPositions) {
            return groupPositions.every(function (position) { return position <= groupSize; });
        })
            .map(function (groupPositions) {
            var drawPositions = groupPositions.map(function (groupPosition) { return groupPosition + drawPositionOffset; });
            return drawPositionsHash(drawPositions);
        });
    });
}
function determineRoundNumber(_a) {
    var rounds = _a.rounds, hash = _a.hash;
    return rounds.reduce(function (p, round, i) { return (round.includes(hash) ? i + 1 : p); }, undefined);
}
var roundRobinGroups = {
    getRoundRobinGroupMatchUps: getRoundRobinGroupMatchUps,
    determineRoundNumber: determineRoundNumber,
    drawPositionsHash: drawPositionsHash,
    groupRounds: groupRounds,
};

function generateRoundRobin(params) {
    var _a, _b, _c;
    var _d = params.groupNameBase, groupNameBase = _d === void 0 ? 'Group' : _d, playoffAttributes = params.playoffAttributes, _e = params.stageSequence, stageSequence = _e === void 0 ? 1 : _e, structureOptions = params.structureOptions, appliedPolicies = params.appliedPolicies, seedingProfile = params.seedingProfile, _f = params.stage, stage = _f === void 0 ? MAIN : _f, matchUpType = params.matchUpType, roundTarget = params.roundTarget, structureId = params.structureId, groupNames = params.groupNames, drawSize = params.drawSize, idPrefix = params.idPrefix, isMock = params.isMock, uuids = params.uuids;
    var structureName = (_c = (_a = params.structureName) !== null && _a !== void 0 ? _a : (_b = playoffAttributes === null || playoffAttributes === void 0 ? void 0 : playoffAttributes['0']) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : constantToString(MAIN);
    var _g = deriveGroups({
        structureOptions: structureOptions,
        appliedPolicies: appliedPolicies,
        drawSize: drawSize,
    }), groupCount = _g.groupCount, groupSize = _g.groupSize;
    var finishingPosition = WIN_RATIO$1;
    var maxRoundNumber;
    var structures = generateRange(1, groupCount + 1).map(function (structureOrder) {
        var _a;
        var matchUps = roundRobinMatchUps({
            groupSize: groupSize,
            structureOrder: structureOrder,
            matchUpType: matchUpType,
            drawSize: drawSize,
            idPrefix: idPrefix,
            isMock: isMock,
        });
        maxRoundNumber = Math.max.apply(Math, __spreadArray([], __read(matchUps.map(function (_a) {
            var roundNumber = _a.roundNumber;
            return roundNumber;
        })), false));
        var structureName = (_a = groupNames === null || groupNames === void 0 ? void 0 : groupNames[structureOrder - 1]) !== null && _a !== void 0 ? _a : "".concat(groupNameBase, " ").concat(structureOrder);
        return structureTemplate({
            structureId: uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
            structureType: ITEM,
            finishingPosition: finishingPosition,
            structureOrder: structureOrder,
            structureName: structureName,
            matchUps: matchUps,
        });
    });
    var structure = structureTemplate({
        structureId: structureId !== null && structureId !== void 0 ? structureId : uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
        structureType: CONTAINER,
        finishingPosition: finishingPosition,
        seedingProfile: seedingProfile,
        structureName: structureName,
        stageSequence: stageSequence,
        structures: structures,
        stage: stage,
    });
    if (roundTarget)
        addExtension({
            extension: { name: ROUND_TARGET, value: roundTarget },
            element: structure,
        });
    return __assign({ structures: [structure], maxRoundNumber: maxRoundNumber, groupCount: groupCount, links: [], groupSize: groupSize }, SUCCESS);
}
function deriveGroups(_a) {
    _a.appliedPolicies; var structureOptions = _a.structureOptions, drawSize = _a.drawSize;
    var groupSize = structureOptions === null || structureOptions === void 0 ? void 0 : structureOptions.groupSize;
    var groupSizeLimit = (structureOptions === null || structureOptions === void 0 ? void 0 : structureOptions.groupSizeLimit) || 8;
    var validGroupSizes = getValidGroupSizes({
        groupSizeLimit: groupSizeLimit,
        drawSize: drawSize,
    }).validGroupSizes;
    var maxValidGroupSize = validGroupSizes && Math.max.apply(Math, __spreadArray([], __read(validGroupSizes), false));
    var validGroupSize = groupSize && (validGroupSizes === null || validGroupSizes === void 0 ? void 0 : validGroupSizes.includes(groupSize));
    if (!validGroupSize) {
        // if no groupSize specified or if groupSize is not valid
        if ((groupSize && groupSize > 4) || !(validGroupSizes === null || validGroupSizes === void 0 ? void 0 : validGroupSizes.includes(4))) {
            groupSize = maxValidGroupSize;
        }
        else {
            groupSize = 4;
        }
    }
    var groupCount = Math.ceil(drawSize / groupSize);
    return { groupSize: groupSize, groupCount: groupCount };
}
function getValidGroupSizes(_a) {
    var drawSize = _a.drawSize, _b = _a.groupSizeLimit, groupSizeLimit = _b === void 0 ? 10 : _b;
    var validGroupSizes = generateRange(3, groupSizeLimit + 1).filter(function (groupSize) {
        var groupsCount = Math.ceil(drawSize / groupSize);
        var byesCount = groupsCount * groupSize - drawSize;
        var maxParticipantsPerGroup = Math.ceil(drawSize / groupsCount);
        var maxByesPerGroup = Math.ceil(byesCount / groupsCount);
        return ((!byesCount || byesCount < groupSize) &&
            maxParticipantsPerGroup === groupSize &&
            maxParticipantsPerGroup >= 3 &&
            maxByesPerGroup < 2);
    });
    return __assign(__assign({}, SUCCESS), { validGroupSizes: validGroupSizes });
}
function roundRobinMatchUps(_a) {
    var structureOrder = _a.structureOrder, matchUpType = _a.matchUpType, groupSize = _a.groupSize, drawSize = _a.drawSize, idPrefix = _a.idPrefix, isMock = _a.isMock, uuids = _a.uuids;
    var drawPositionOffset = (structureOrder - 1) * groupSize;
    var drawPositions = generateRange(1 + drawPositionOffset, groupSize + 1 + drawPositionOffset);
    var uniqueMatchUpGroupings = getRoundRobinGroupMatchUps({
        drawPositions: drawPositions,
    }).uniqueMatchUpGroupings;
    var rounds = groupRounds({ groupSize: groupSize, drawPositionOffset: drawPositionOffset });
    var matchUps = uniqueMatchUpGroupings
        .map(positionMatchUp)
        .sort(function (a, b) { return (a.roundNumber || Infinity) - (b.roundNumber || Infinity); });
    return matchUps;
    function determineRoundNumber(hash) {
        return rounds.reduce(function (p, round, i) { return (round.includes(hash) ? i + 1 : p); }, undefined);
    }
    // returns a range for array of possible finishing drawPositions
    function positionMatchUp(drawPositions) {
        var hash = drawPositionsHash(drawPositions);
        var roundNumber = determineRoundNumber(hash);
        var range = [1, drawSize];
        var matchUpId = roundRobinMatchUpId({
            structureOrder: structureOrder,
            drawPositions: drawPositions,
            roundNumber: roundNumber,
            idPrefix: idPrefix,
            uuids: uuids,
        });
        var matchUp = {
            matchUpStatus: roundNumber ? TO_BE_PLAYED : BYE,
            matchUpType: matchUpType, // does not (perhaps) need to be included; but because structures[].structure unsure about derivation inContext
            // finishingPositionRange in RR is not very useful, but provided for consistency
            finishingPositionRange: { winner: range, loser: range },
            drawPositions: drawPositions,
            roundNumber: roundNumber,
            matchUpId: matchUpId,
        };
        if (isMock)
            matchUp.isMock = true;
        return matchUp;
    }
}
function roundRobinMatchUpId(_a) {
    var structureOrder = _a.structureOrder, drawPositions = _a.drawPositions, roundNumber = _a.roundNumber, idPrefix = _a.idPrefix, uuids = _a.uuids;
    return idPrefix
        ? "".concat(idPrefix, "-").concat(structureOrder, "-").concat(roundNumber, "-DP-").concat(drawPositions.join('-'))
        : (uuids === null || uuids === void 0 ? void 0 : uuids.pop()) || UUID();
}

function getSeedBlocks(params) {
    var roundRobinGroupsCount = params.roundRobinGroupsCount, participantsCount = params.participantsCount, cluster = params.cluster;
    if (!isConvertableInteger(participantsCount))
        return __assign({ seedBlocks: undefined }, decorateResult({
            result: { error: INVALID_VALUES },
            context: { participantsCount: participantsCount },
            stack: 'getSeedBlocks',
        }));
    var drawSize = nextPowerOf2(participantsCount);
    if (roundRobinGroupsCount) {
        // ensure that drawSize has not already been subdivided
        // e.g. each group treated as a separate drawSize whilst passing total groupsCount
        var increment = Math.min(roundRobinGroupsCount, drawSize);
        var seedBlocks_1 = [];
        var position_1 = 1;
        generateRange(0, increment).forEach(function () {
            seedBlocks_1.push([position_1]);
            position_1++;
        });
        while (position_1 < drawSize) {
            var range_1 = generateRange(position_1, position_1 + increment);
            position_1 += increment;
            seedBlocks_1.push(range_1);
        }
        return __assign(__assign({}, SUCCESS), { seedBlocks: seedBlocks_1 });
    }
    var range = generateRange(1, drawSize + 1);
    var positions = [];
    var chunkSize = drawSize / 2;
    var _loop_1 = function () {
        var chunks = chunkArray(range, chunkSize);
        var chunksCount = chunks.length;
        // for each chunk generate candidates
        // throw out candidates if the chunk positions include an already selected position
        // this has the effect of skipping chunks where seeds have already been identified
        chunks.forEach(function (chunk, i) {
            var candidate;
            var top = i < chunksCount / 2;
            var isEven = i % 2 === 0;
            var first = chunk[0];
            var last = chunk[chunk.length - 1];
            if (cluster && chunksCount > 4) {
                // for ITF/CLUSTER seeding the pattern changes and then stabilizes
                if (chunksCount === 8) {
                    candidate = top ? last : first;
                }
                else {
                    candidate = isEven ? first : last;
                }
            }
            else {
                // for USTA/SEPARATE seeding the pattern is simple: first on top, last on bottom
                candidate = top ? first : last;
            }
            if (!overlap(chunk, positions)) {
                positions.push(candidate);
            }
        });
        chunkSize = chunkSize / 2;
    };
    // first two seed blocks are always [[1], [drawSize]], e.g. [[1], [32]] for a 32 drawSize
    // While loop generates an array of ordered drawPositions which are later broken into blocks
    while (chunkSize > 1) {
        _loop_1();
    }
    var remainingPositions = range.filter(function (position) { return !positions.includes(position); });
    while (remainingPositions.length) {
        // for remaining positions alternately select from bottom/top
        if (remainingPositions.length % 2 === 0) {
            positions.push(remainingPositions.pop());
        }
        else {
            positions.push(remainingPositions.shift());
        }
    }
    // generate an array of seed block sizes... [1, 1, 2, 4, 8, 16...]
    // 20 ensures a more than adequate number of seedBlocks!
    var seedBlockSizes = generateRange(0, 20).map(function (x) { return Math.pow(2, x); });
    seedBlockSizes.unshift(1);
    // the number of seedBlocks is given by the index of drawSize in seedBlockSizes
    var iterations = seedBlockSizes.indexOf(drawSize);
    var sum = 0;
    var seedBlocks = [];
    // iterate over seed block sizes to generate seedBlocks
    generateRange(0, iterations).forEach(function (i) {
        seedBlocks.push(positions.slice(sum, sum + seedBlockSizes[i]));
        sum += seedBlockSizes[i];
    });
    return __assign(__assign({}, SUCCESS), { seedBlocks: seedBlocks });
}
function getSeedGroups(_a) {
    var roundRobinGroupsCount = _a.roundRobinGroupsCount, drawSize = _a.drawSize;
    var stack = 'getSeedGroups';
    if (!isConvertableInteger(drawSize))
        return __assign({ seedGroups: undefined }, decorateResult({
            result: { error: INVALID_VALUES },
            context: { drawSize: drawSize },
            stack: stack,
        }));
    if (roundRobinGroupsCount) {
        if (!isConvertableInteger(roundRobinGroupsCount))
            return __assign({ seedGroups: undefined }, decorateResult({
                context: { roundRobinGroupsCount: roundRobinGroupsCount },
                result: { error: INVALID_VALUES },
                stack: stack,
            }));
        var seedNumber_1 = 1;
        var roundsCount = Math.floor(drawSize / roundRobinGroupsCount);
        var seedGroups = generateRange(0, roundsCount).map(function () {
            var seedNumbers = generateRange(seedNumber_1, seedNumber_1 + roundRobinGroupsCount);
            seedNumber_1 += roundRobinGroupsCount;
            return seedNumbers;
        });
        return { seedGroups: seedGroups };
    }
    else {
        var seedBlocks = getSeedBlocks({
            participantsCount: drawSize,
            roundRobinGroupsCount: roundRobinGroupsCount,
        }).seedBlocks;
        var seedNumber_2 = 0;
        var seedGroups = (seedBlocks || []).map(function (seedBlock) {
            return (seedBlock || []).map(function () {
                seedNumber_2 += 1;
                return seedNumber_2;
            });
        });
        return { seedGroups: seedGroups };
    }
}
function getSeedingThresholds(_a) {
    var roundRobinGroupsCount = _a.roundRobinGroupsCount, participantsCount = _a.participantsCount;
    if (roundRobinGroupsCount) {
        var validGroupSizes = getValidGroupSizes({
            drawSize: participantsCount,
        }).validGroupSizes;
        var validGroupsCounts = validGroupSizes === null || validGroupSizes === void 0 ? void 0 : validGroupSizes.map(function (groupSize) {
            return Math.ceil(participantsCount / groupSize);
        });
        var invalid = !(validGroupsCounts === null || validGroupsCounts === void 0 ? void 0 : validGroupsCounts.includes(roundRobinGroupsCount));
        if (invalid) {
            return decorateResult({
                context: { roundRobinGroupsCount: roundRobinGroupsCount },
                result: { error: INVALID_VALUES },
            });
        }
    }
    var seedGroups = getSeedGroups({
        drawSize: participantsCount,
        roundRobinGroupsCount: roundRobinGroupsCount,
    }).seedGroups;
    var seedingThresholds = (seedGroups === null || seedGroups === void 0 ? void 0 : seedGroups.map(function (seedNumberBlock) { return Math.min.apply(Math, __spreadArray([], __read(seedNumberBlock), false)); })) || [];
    return __assign(__assign({}, SUCCESS), { seedingThresholds: seedingThresholds });
}

function getNumericSeedValue(seedValue) {
    if (!seedValue)
        return Infinity;
    if (isConvertableInteger(seedValue))
        return ensureInt(seedValue);
    var firstValue = seedValue.split('-')[0];
    if (isConvertableInteger(firstValue))
        return ensureInt(firstValue);
    return Infinity;
}

function getDivisions(_a) {
    var size = _a.size;
    var divisions = [size];
    var division = size;
    while (division / 2 === Math.floor(division / 2)) {
        division = division / 2;
        divisions.push(division);
    }
    if (!divisions.includes(1))
        divisions.push(1);
    divisions.sort(numericSort);
    divisions.reverse();
    return divisions;
}
function getSubBlock(_a) {
    var e_1, _b;
    var blockPattern = _a.blockPattern, index = _a.index;
    var i = 0;
    try {
        for (var blockPattern_1 = __values(blockPattern), blockPattern_1_1 = blockPattern_1.next(); !blockPattern_1_1.done; blockPattern_1_1 = blockPattern_1.next()) {
            var subBlock = blockPattern_1_1.value;
            if (i === index)
                return subBlock;
            var j = 0;
            while (j < subBlock.length) {
                if (i === index)
                    return subBlock;
                i += 1;
                j++;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (blockPattern_1_1 && !blockPattern_1_1.done && (_b = blockPattern_1.return)) _b.call(blockPattern_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
function generateBlockPattern(_a) {
    var e_2, _b;
    var positioning = _a.positioning, size = _a.size;
    var divisions = getDivisions({ size: size });
    var divisionGroupings = [];
    var selected = [];
    var firstMember = function (arr) { return arr[0]; };
    var lastMember = function (arr) { return arr[arr.length - 1]; };
    var getMember = function (arr, i) {
        return (positioning && [CLUSTER, WATERFALL].includes(positioning) && i % 2 ? lastMember(arr) : firstMember(arr)) ||
            firstMember(arr);
    };
    var noneSelected = function (chunk, i) {
        if (chunk.every(function (member) { return !selected.includes(member); })) {
            var member = getMember(chunk, i);
            selected.push(member);
            return member;
        }
    };
    var notSelected = function (chunk) {
        var notSelected = chunk.filter(function (member) { return !selected.includes(member); });
        if (notSelected.length) {
            selected.push.apply(selected, __spreadArray([], __read(notSelected), false));
            return notSelected;
        }
    };
    var select = function (chunk, i) {
        var member = getMember(chunk, i);
        if (!selected.includes(member)) {
            selected.push(member);
            return member;
        }
    };
    var range = generateRange(1, size + 1);
    try {
        for (var divisions_1 = __values(divisions), divisions_1_1 = divisions_1.next(); !divisions_1_1.done; divisions_1_1 = divisions_1.next()) {
            var division = divisions_1_1.value;
            if (division === 1) {
                var chunks = chunkArray(range, 2);
                // first check all pairs for pair that has no member included in selected
                var positions = chunks.map(noneSelected).filter(Boolean);
                if (positions.length)
                    divisionGroupings.push(positions);
                // then return positions from each chunk which are not selected
                var lastPositions = chunks.flatMap(notSelected).filter(Boolean);
                if (lastPositions.length)
                    divisionGroupings.push(lastPositions);
            }
            else {
                var chunks = chunkArray(range, division);
                var positions = chunks.map(select).filter(Boolean);
                if (positions.length)
                    divisionGroupings.push(positions);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (divisions_1_1 && !divisions_1_1.done && (_b = divisions_1.return)) _b.call(divisions_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return { divisions: divisions, divisionGroupings: divisionGroupings };
}

function getValidSeedBlocks(_a) {
    var _b, _c;
    var provisionalPositioning = _a.provisionalPositioning, returnAllProxies = _a.returnAllProxies, appliedPolicies = _a.appliedPolicies, seedingProfile = _a.seedingProfile, drawDefinition = _a.drawDefinition, allPositions = _a.allPositions, structure = _a.structure;
    var validSeedBlocks = [];
    if (!structure)
        return { error: MISSING_STRUCTURE };
    var _d = getAllStructureMatchUps({
        matchUpFilters: { roundNumbers: [1] },
        provisionalPositioning: provisionalPositioning,
        structure: structure,
    }), matchUps = _d.matchUps, roundMatchUps = _d.roundMatchUps;
    var seedAssignments = getStructureSeedAssignments({
        provisionalPositioning: provisionalPositioning,
        returnAllProxies: returnAllProxies,
        drawDefinition: drawDefinition,
        structure: structure,
    }).seedAssignments;
    var positionAssignments = structureAssignedDrawPositions({ structure: structure }).positionAssignments;
    var positionsCount = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.length;
    var seedsCount = (_b = seedAssignments === null || seedAssignments === void 0 ? void 0 : seedAssignments.length) !== null && _b !== void 0 ? _b : 0;
    var allDrawPositions = [];
    var roundNumbers = Object.keys(roundMatchUps)
        .map(function (n) { return parseInt(n); })
        .sort(function (a, b) { return a - b; });
    var uniqueDrawPositionsByRound = roundNumbers
        .map(function (roundNumber) {
        var roundDrawPositions = roundMatchUps[roundNumber]
            .map(function (matchUp) { return matchUp.drawPositions; })
            .flat(Infinity)
            .filter(Boolean);
        var uniqueRoundDrawPositions = roundDrawPositions.filter(function (drawPosition) { return !allDrawPositions.includes(drawPosition); });
        allDrawPositions = allDrawPositions.concat.apply(allDrawPositions, __spreadArray([], __read(roundDrawPositions), false));
        return uniqueRoundDrawPositions;
    })
        .filter(function (f) { return f.length; })
        .reverse();
    var firstRoundDrawPositions = uniqueDrawPositionsByRound.pop();
    var firstRoundDrawPositionOffset = (firstRoundDrawPositions && Math.min.apply(Math, __spreadArray([], __read(firstRoundDrawPositions), false)) - 1) || 0;
    seedingProfile = seedingProfile !== null && seedingProfile !== void 0 ? seedingProfile : (_c = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.seeding) === null || _c === void 0 ? void 0 : _c.seedingProfile;
    var baseDrawSize = (firstRoundDrawPositions === null || firstRoundDrawPositions === void 0 ? void 0 : firstRoundDrawPositions.length) || 0;
    // firstRoundDrawPositions have been popped
    // seedRangeDrawPositionBlocks determines FEED_IN
    var seedRangeDrawPositionBlocks = uniqueDrawPositionsByRound.filter(function (block) { return block.filter(function (drawPosition) { return drawPosition <= seedsCount; }).length; });
    var stage = structure.stage, structureType = structure.structureType, roundLimit = structure.roundLimit;
    var isContainer = structureType === CONTAINER;
    var isFeedIn = !isContainer && (uniqueDrawPositionsByRound === null || uniqueDrawPositionsByRound === void 0 ? void 0 : uniqueDrawPositionsByRound.length);
    var qualifyingBlocks = !isContainer && stage === QUALIFYING && roundLimit;
    var fedSeedBlockPositions = seedRangeDrawPositionBlocks.flat(Infinity);
    var fedSeedNumberOffset = isFeedIn ? fedSeedBlockPositions === null || fedSeedBlockPositions === void 0 ? void 0 : fedSeedBlockPositions.length : 0;
    var countLimit = allPositions ? positionsCount : seedsCount;
    var isLuckyStructure = isLucky({
        drawDefinition: drawDefinition,
        structure: structure,
        matchUps: matchUps,
    });
    var firstRoundSeedsCount = isLuckyStructure
        ? 0
        : (!isFeedIn && countLimit) ||
            (countLimit && fedSeedBlockPositions.length < countLimit && countLimit - fedSeedBlockPositions.length) ||
            0;
    if (qualifyingBlocks) {
        var seedingBlocksCount = (structure === null || structure === void 0 ? void 0 : structure.matchUps)
            ? structure.matchUps.filter(function (_a) {
                var roundNumber = _a.roundNumber;
                return roundNumber === structure.roundLimit;
            }).length
            : 0;
        var chunkSize = firstRoundDrawPositions.length / seedingBlocksCount;
        if (isFeedIn) ;
        else {
            var positioning = getSeedPattern(seedingProfile);
            var drawPositionChunks_1 = chunkArray(firstRoundDrawPositions, chunkSize);
            var groupNumber_1 = 1;
            var seedGroups = generateRange(0, drawPositionChunks_1[0].length).map(function () {
                var seedNumbers = generateRange(groupNumber_1, groupNumber_1 + drawPositionChunks_1.length);
                groupNumber_1 += drawPositionChunks_1.length;
                return seedNumbers;
            });
            (validSeedBlocks = getSeedBlockPattern({
                drawPositionBlocks: drawPositionChunks_1,
                nonRandom: seedingProfile === null || seedingProfile === void 0 ? void 0 : seedingProfile.nonRandom,
                positioning: positioning,
                seedGroups: seedGroups,
            }).validSeedBlocks);
        }
    }
    else if (isContainer) {
        var result = getContainerBlocks({
            nonRandom: seedingProfile === null || seedingProfile === void 0 ? void 0 : seedingProfile.nonRandom,
            seedingProfile: seedingProfile,
            structure: structure,
        });
        (validSeedBlocks = result.validSeedBlocks);
    }
    else if (isFeedIn) {
        // for FEED_IN structures, block seeding proceeds from final rounds
        // to earlier rounds.  If there are more seeds than fed positions,
        // then seeds must be assigned to first round drawPositions
        validSeedBlocks = seedRangeDrawPositionBlocks.map(function (block) {
            return { seedNumbers: block, drawPositions: block };
        });
    }
    else if (isLuckyStructure) {
        var blocks = chunkArray(firstRoundDrawPositions, 2).map(function (block, i) { return ({
            drawPositions: [block[0]],
            seedNumbers: [i + 1],
        }); });
        blocks.forEach(function (block) { return validSeedBlocks.push(block); });
    }
    if (!isContainer && !isLuckyStructure && !qualifyingBlocks) {
        var blocks = constructPower2Blocks({
            drawPositionOffset: firstRoundDrawPositionOffset,
            seedNumberOffset: fedSeedNumberOffset,
            seedCountGoal: firstRoundSeedsCount,
            seedingProfile: seedingProfile,
            baseDrawSize: baseDrawSize,
        }).blocks;
        blocks.forEach(function (block) { return validSeedBlocks.push(block); });
    }
    var seedDrawPositions = validSeedBlocks.flatMap(function (seedBlock) { return seedBlock.drawPositions; });
    var validSeedPositions = seedDrawPositions.reduce(function (result, drawPosition) {
        return (firstRoundDrawPositions === null || firstRoundDrawPositions === void 0 ? void 0 : firstRoundDrawPositions.includes(drawPosition)) && result;
    }, true);
    if (!isLuckyStructure && !isFeedIn && !isContainer && !validSeedPositions) {
        return {
            error: INVALID_SEED_POSITION,
            validSeedBlocks: [],
            isContainer: isContainer,
            isFeedIn: isFeedIn,
        };
    }
    return {
        isLuckyStructure: isLuckyStructure,
        validSeedBlocks: validSeedBlocks,
        isContainer: isContainer,
        isFeedIn: isFeedIn,
    };
}
function getContainerBlocks(_a) {
    var _b, _c;
    var seedingProfile = _a.seedingProfile, structure = _a.structure, nonRandom = _a.nonRandom;
    var containedStructures = structure.structures || [];
    var roundRobinGroupsCount = containedStructures.length;
    var positionAssignments = (_b = getPositionAssignments$1({
        structure: structure,
    })) === null || _b === void 0 ? void 0 : _b.positionAssignments;
    var positioning = getSeedPattern(seedingProfile);
    var drawSize = (_c = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.length) !== null && _c !== void 0 ? _c : 0;
    var seedGroups = getSeedGroups({
        roundRobinGroupsCount: roundRobinGroupsCount,
        drawSize: drawSize,
    }).seedGroups;
    var drawPositionBlocks = containedStructures.map(function (containedStructure) {
        var _a;
        return (_a = getPositionAssignments$1({
            structure: containedStructure,
        }).positionAssignments) === null || _a === void 0 ? void 0 : _a.map(function (assignment) { return assignment.drawPosition; });
    });
    return getSeedBlockPattern({
        drawPositionBlocks: drawPositionBlocks,
        positioning: positioning,
        seedGroups: seedGroups,
        nonRandom: nonRandom,
    });
}
function getSeedBlockPattern(_a) {
    var drawPositionBlocks = _a.drawPositionBlocks, positioning = _a.positioning, seedGroups = _a.seedGroups, nonRandom = _a.nonRandom;
    var validSeedBlocks = [];
    var divisionGroupings = generateBlockPattern({
        size: seedGroups.length,
        positioning: positioning,
    }).divisionGroupings;
    var assignedPositions = [];
    seedGroups.forEach(function (seedGroup, i) {
        var relativePositions = getSubBlock({
            blockPattern: divisionGroupings,
            index: i,
        });
        seedGroup.forEach(function (seedNumber, j) {
            var blockIndex = i % 2 ? drawPositionBlocks.length - j - 1 : j;
            var block = drawPositionBlocks[blockIndex].slice();
            var consideredDrawPositions = block.filter(function (drawPosition, i) { return relativePositions.includes(i + 1) && drawPosition; });
            if (positioning !== WATERFALL) {
                consideredDrawPositions = nonRandom ? consideredDrawPositions : shuffleArray(consideredDrawPositions);
            }
            else if (i % 2) {
                consideredDrawPositions.reverse();
            }
            var drawPosition = consideredDrawPositions.find(function (drawPosition) { return !assignedPositions.includes(drawPosition); });
            if (drawPosition) {
                assignedPositions.push(drawPosition);
                validSeedBlocks.push({
                    drawPositions: [drawPosition],
                    seedNumbers: [seedNumber],
                });
            }
        });
    });
    return { validSeedBlocks: validSeedBlocks };
}
function constructPower2Blocks(params) {
    var e_1, _a;
    var _b = params.drawPositionOffset, drawPositionOffset = _b === void 0 ? 0 : _b, roundRobinGroupsCount = params.roundRobinGroupsCount, _c = params.seedNumberOffset, seedNumberOffset = _c === void 0 ? 0 : _c, seedingProfile = params.seedingProfile, seedCountGoal = params.seedCountGoal, baseDrawSize = params.baseDrawSize;
    var count = 1;
    var blocks = [];
    var seedBlocks = getSeedBlocks({
        cluster: getSeedPattern(seedingProfile) === CLUSTER,
        participantsCount: baseDrawSize,
        roundRobinGroupsCount: roundRobinGroupsCount,
    }).seedBlocks;
    count = 0;
    try {
        for (var seedBlocks_1 = __values(seedBlocks), seedBlocks_1_1 = seedBlocks_1.next(); !seedBlocks_1_1.done; seedBlocks_1_1 = seedBlocks_1.next()) {
            var seedBlock = seedBlocks_1_1.value;
            if (count + 1 > seedCountGoal)
                break;
            var drawPositions = seedBlock.map(function (drawPosition) { return drawPosition + drawPositionOffset; });
            var seedNumbers = getSeeds(count + 1, seedBlock.length).map(function (seedNumber) { return +seedNumber + seedNumberOffset; });
            count += seedBlock.length;
            blocks.push({ drawPositions: drawPositions, seedNumbers: seedNumbers });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (seedBlocks_1_1 && !seedBlocks_1_1.done && (_a = seedBlocks_1.return)) _a.call(seedBlocks_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { blocks: blocks };
    function getSeeds(s, n) {
        return Array.from(new Array(n), function (_, i) { return i + s; });
    }
}
function isValidSeedPosition(_a) {
    var _b, _c, _d, _e, _f;
    var appliedPolicies = _a.appliedPolicies, drawDefinition = _a.drawDefinition, seedBlockInfo = _a.seedBlockInfo, drawPosition = _a.drawPosition, structureId = _a.structureId, seedNumber = _a.seedNumber;
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    if (!appliedPolicies) {
        appliedPolicies = getAppliedPolicies({ drawDefinition: drawDefinition }).appliedPolicies;
    }
    var validSeedBlocks = seedBlockInfo === null || seedBlockInfo === void 0 ? void 0 : seedBlockInfo.validSeedBlocks;
    if (!validSeedBlocks && structure) {
        validSeedBlocks = (_b = getValidSeedBlocks({
            appliedPolicies: appliedPolicies,
            drawDefinition: drawDefinition,
            structure: structure,
        })) === null || _b === void 0 ? void 0 : _b.validSeedBlocks;
    }
    if ((_d = (_c = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.seeding) === null || _c === void 0 ? void 0 : _c.validSeedPositions) === null || _d === void 0 ? void 0 : _d.ignore)
        return true;
    if ((_f = (_e = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.seeding) === null || _e === void 0 ? void 0 : _e.validSeedPositions) === null || _f === void 0 ? void 0 : _f.strict) {
        var targetSeedBlock = validSeedBlocks.find(function (seedBlock) { return seedBlock.seedNumbers.includes(seedNumber); });
        var validSeedPositions_1 = (targetSeedBlock === null || targetSeedBlock === void 0 ? void 0 : targetSeedBlock.drawPositions) || [];
        return validSeedPositions_1.includes(drawPosition);
    }
    var validSeedPositions = [].concat.apply([], __spreadArray([], __read(validSeedBlocks.map(function (seedBlock) { return seedBlock.drawPositions; })), false));
    return validSeedPositions.includes(drawPosition);
}
function getNextSeedBlock(params) {
    var _a, _b, _c;
    var provisionalPositioning = params.provisionalPositioning, drawDefinition = params.drawDefinition, seedingProfile = params.seedingProfile, seedBlockInfo = params.seedBlockInfo, structureId = params.structureId, randomize = params.randomize;
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    var seedAssignments = getStructureSeedAssignments({
        returnAllProxies: params.returnAllProxies,
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        structure: structure,
    }).seedAssignments;
    var positionAssignments = structureAssignedDrawPositions({ structure: structure }).positionAssignments;
    var positionsWithParticipants = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) { var _a, _b; return (_b = (_a = assignment.participantId) !== null && _a !== void 0 ? _a : assignment.bye) !== null && _b !== void 0 ? _b : assignment.qualifier; });
    var assignedDrawPositions = positionsWithParticipants === null || positionsWithParticipants === void 0 ? void 0 : positionsWithParticipants.map(function (assignment) { return assignment.drawPosition; }).filter(Boolean);
    var appliedPolicies = getAppliedPolicies({ drawDefinition: drawDefinition }).appliedPolicies;
    var validSeedBlocks = (seedBlockInfo === null || seedBlockInfo === void 0 ? void 0 : seedBlockInfo.validSeedBlocks) ||
        (structure &&
            ((_a = getValidSeedBlocks({
                returnAllProxies: params.returnAllProxies,
                provisionalPositioning: provisionalPositioning,
                appliedPolicies: appliedPolicies,
                drawDefinition: drawDefinition,
                seedingProfile: seedingProfile,
                structure: structure,
            })) === null || _a === void 0 ? void 0 : _a.validSeedBlocks));
    var unfilledSeedBlocks = (validSeedBlocks || []).filter(function (seedBlock) {
        var unfilledPositions = seedBlock.drawPositions.filter(function (drawPosition) { return !(assignedDrawPositions === null || assignedDrawPositions === void 0 ? void 0 : assignedDrawPositions.includes(drawPosition)); });
        return unfilledPositions.length;
    });
    var nextSeedBlock = unfilledSeedBlocks[0];
    var assignedSeedParticipantIds = seedAssignments === null || seedAssignments === void 0 ? void 0 : seedAssignments.map(function (assignment) { return assignment.participantId; }).filter(Boolean);
    var assignedPositionParticipantIds = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.map(function (assignment) { return assignment.participantId; }).filter(Boolean);
    var placedSeedParticipantIds = assignedSeedParticipantIds === null || assignedSeedParticipantIds === void 0 ? void 0 : assignedSeedParticipantIds.filter(function (participantId) { return assignedPositionParticipantIds === null || assignedPositionParticipantIds === void 0 ? void 0 : assignedPositionParticipantIds.includes(participantId); });
    var unplacedSeedIds = assignedSeedParticipantIds === null || assignedSeedParticipantIds === void 0 ? void 0 : assignedSeedParticipantIds.filter(function (participantId) { return !(assignedPositionParticipantIds === null || assignedPositionParticipantIds === void 0 ? void 0 : assignedPositionParticipantIds.includes(participantId)); });
    var unplacedSeedAssignments = seedAssignments === null || seedAssignments === void 0 ? void 0 : seedAssignments.filter(function (assignment) { return unplacedSeedIds === null || unplacedSeedIds === void 0 ? void 0 : unplacedSeedIds.includes(assignment.participantId); });
    var seedsWithoutDrawPositions = seedAssignments === null || seedAssignments === void 0 ? void 0 : seedAssignments.filter(function (assignment) { return !assignment.participantId; });
    var seedsLeftToAssign = (unplacedSeedAssignments === null || unplacedSeedAssignments === void 0 ? void 0 : unplacedSeedAssignments.length) && unplacedSeedAssignments.length > 0
        ? unplacedSeedAssignments.length
        : (_b = seedsWithoutDrawPositions === null || seedsWithoutDrawPositions === void 0 ? void 0 : seedsWithoutDrawPositions.length) !== null && _b !== void 0 ? _b : 0;
    var unfilled = (seedsLeftToAssign &&
        (nextSeedBlock === null || nextSeedBlock === void 0 ? void 0 : nextSeedBlock.drawPositions.filter(function (drawPosition) { return !(assignedDrawPositions === null || assignedDrawPositions === void 0 ? void 0 : assignedDrawPositions.includes(drawPosition)); }))) ||
        [];
    var unfilledPositions = randomize ? shuffleArray(unfilled) : unfilled;
    var selectedParticipantIds = [];
    var randomlySelectedUnplacedSeedValueIds = unfilledPositions
        .map(function () {
        var assignment = randomlySelectLowestSeedValue(unplacedSeedAssignments, selectedParticipantIds);
        var participantId = assignment === null || assignment === void 0 ? void 0 : assignment.participantId;
        if (participantId)
            selectedParticipantIds.push(participantId);
        return participantId;
    })
        .filter(Boolean);
    var placedSeedNumbers = seedAssignments === null || seedAssignments === void 0 ? void 0 : seedAssignments.filter(function (assignment) { return placedSeedParticipantIds === null || placedSeedParticipantIds === void 0 ? void 0 : placedSeedParticipantIds.includes(assignment.participantId); }).map(function (assignment) { return assignment.seedNumber; });
    var blockSeedNumbers = (nextSeedBlock === null || nextSeedBlock === void 0 ? void 0 : nextSeedBlock.seedNumbers) || [];
    // unplacedSeedNumbers and unplacedSeedNumberIds will only be used
    // when policy specifies that seedNumbers/seedValues must be unique
    var unplacedSeedNumbers = blockSeedNumbers.filter(function (seedNumber) { return !(placedSeedNumbers === null || placedSeedNumbers === void 0 ? void 0 : placedSeedNumbers.includes(seedNumber)); });
    var unplacedSeedNumberIds = seedAssignments === null || seedAssignments === void 0 ? void 0 : seedAssignments.filter(function (assignment) { return unplacedSeedNumbers.includes(assignment.seedNumber); }).map(function (assignment) { return assignment.participantId; });
    var duplicateSeedNumbers = (_c = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.seeding) === null || _c === void 0 ? void 0 : _c.duplicateSeedNumbers;
    var allowsDuplicateSeedNumbers = duplicateSeedNumbers !== undefined ? duplicateSeedNumbers : true;
    var unplacedSeedParticipantIds = allowsDuplicateSeedNumbers
        ? randomlySelectedUnplacedSeedValueIds
        : unplacedSeedNumberIds;
    return {
        nextSeedBlock: nextSeedBlock,
        unplacedSeedParticipantIds: unplacedSeedParticipantIds,
        unplacedSeedNumbers: unplacedSeedNumbers,
        unfilledPositions: unfilledPositions,
        unplacedSeedAssignments: unplacedSeedAssignments,
    };
    function randomlySelectLowestSeedValue(assignments, selectedParticipantIds) {
        var filteredAssignments = assignments.filter(function (assignment) { return !selectedParticipantIds.includes(assignment.participantId); });
        var lowestSeedValue = Math.min.apply(Math, __spreadArray([], __read(filteredAssignments.map(function (assignment) { return getNumericSeedValue(assignment.seedValue); })), false));
        var assignmentsWithLowestSeedValue = filteredAssignments.filter(function (assignment) { return getNumericSeedValue(assignment.seedValue) === lowestSeedValue; });
        var randomizedAssignments = shuffleArray(assignmentsWithLowestSeedValue);
        return randomizedAssignments.pop();
    }
}
function getSeedPattern(seedingProfile) {
    if (typeof seedingProfile === 'string')
        return seedingProfile;
    if (typeof seedingProfile === 'object')
        return seedingProfile.positioning;
}

function assignSeed(_a) {
    var _b, _c;
    var provisionalPositioning = _a.provisionalPositioning, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, seedingProfile = _a.seedingProfile, participantId = _a.participantId, seedBlockInfo = _a.seedBlockInfo, structureId = _a.structureId, seedNumber = _a.seedNumber, seedValue = _a.seedValue, eventId = _a.eventId, event = _a.event;
    var stack = 'assignSeed';
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    var positionAssignments = structureAssignedDrawPositions({ structure: structure }).positionAssignments;
    var seedAssignments = getStructureSeedAssignments({
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        structure: structure,
    }).seedAssignments;
    var seedNumbers = seedAssignments.map(function (assignment) { return assignment.seedNumber; });
    var validParticipantId = participantInEntries({
        drawDefinition: drawDefinition,
        participantId: participantId,
    });
    if (participantId && !validParticipantId)
        return decorateResult({
            result: { error: INVALID_PARTICIPANT_ID },
            context: { participantId: participantId },
            stack: stack,
        });
    var flightsCount = event ? (_c = (_b = getFlightProfile({ event: event }).flightProfile) === null || _b === void 0 ? void 0 : _b.flights) === null || _c === void 0 ? void 0 : _c.length : 0;
    var flighted = flightsCount && flightsCount > 1;
    var relevantAssignment = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (assignment) { return assignment.participantId === participantId; });
    var assignedDrawPosition = relevantAssignment === null || relevantAssignment === void 0 ? void 0 : relevantAssignment.drawPosition;
    if (assignedDrawPosition) {
        var positionIsValid = isValidSeedPosition({
            drawPosition: assignedDrawPosition,
            drawDefinition: drawDefinition,
            seedBlockInfo: seedBlockInfo,
            structureId: structureId,
            seedNumber: seedNumber,
        });
        if (!positionIsValid)
            return decorateResult({
                result: { error: INVALID_DRAW_POSITION_FOR_SEEDING },
                context: { assignedDrawPosition: assignedDrawPosition },
                info: 'invalid seed position',
                stack: stack,
            });
    }
    if (!seedNumbers.includes(seedNumber)) {
        seedAssignments.push({ seedNumber: seedNumber, seedValue: seedValue });
    }
    var success;
    seedAssignments.forEach(function (assignment) {
        // ensure that this participantId is not assigned to any other seedNumber
        if (assignment.participantId === participantId && assignment.seedNumber !== seedNumber) {
            assignment.participantId = undefined;
        }
        // assign participantId to target seedNumber
        if (assignment.seedNumber === seedNumber) {
            assignment.participantId = participantId;
            if (!(seedingProfile === null || seedingProfile === void 0 ? void 0 : seedingProfile.groupSeedingThreshold) && !flighted)
                assignment.seedValue = seedValue !== null && seedValue !== void 0 ? seedValue : seedNumber;
            success = true;
        }
    });
    if (success) {
        modifySeedAssignmentsNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            drawDefinition: drawDefinition,
            structure: structure,
            eventId: eventId,
        });
        return __assign({}, SUCCESS);
    }
    return decorateResult({ result: { error: INVALID_SEED_NUMBER }, stack: stack });
}

function getTargetMatchUps(_a) {
    var _b, _c, _d, _e, _f;
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, drawDefinition = _a.drawDefinition, assignments = _a.assignments, matchUpsMap = _a.matchUpsMap, structure = _a.structure;
    // to support ROUND_ROBIN contained structures
    var containedStructures = (_b = getContainedStructures({
        drawDefinition: drawDefinition,
    })) === null || _b === void 0 ? void 0 : _b.containedStructures;
    var targetStructureIds = ((_c = containedStructures === null || containedStructures === void 0 ? void 0 : containedStructures[structure.structureId]) === null || _c === void 0 ? void 0 : _c.map(function (_a) {
        var structureId = _a.structureId;
        return structureId;
    })) || [];
    targetStructureIds.push(structure === null || structure === void 0 ? void 0 : structure.structureId);
    var drawPositions = (assignments === null || assignments === void 0 ? void 0 : assignments.map(function (_a) {
        var drawPosition = _a.drawPosition;
        return drawPosition;
    })) || [];
    // find all matchUps in the specified structure which contain the target drawPositions
    var targetMatchUps = (_d = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.filter(function (matchUp) {
        var _a;
        return targetStructureIds.includes(matchUp.structureId) &&
            intersection((_a = matchUp.drawPositions) !== null && _a !== void 0 ? _a : [], drawPositions).length;
    })) !== null && _d !== void 0 ? _d : [];
    var targetMatchUpIds = targetMatchUps.map(function (_a) {
        var matchUpId = _a.matchUpId;
        return matchUpId;
    });
    var matchUps = (_f = (_e = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.drawMatchUps) === null || _e === void 0 ? void 0 : _e.filter(function (matchUp) {
        return targetMatchUpIds.includes(matchUp.matchUpId);
    })) !== null && _f !== void 0 ? _f : [];
    return { drawPositions: drawPositions, matchUps: matchUps, targetMatchUps: targetMatchUps };
}

function removeLineUpSubstitutions(_a) {
    var lineUp = _a.lineUp;
    if (!Array.isArray(lineUp))
        return;
    var participantAssignments = {};
    var permutations = unique(lineUp
        .flatMap(function (_a) {
        var collectionAssignments = _a.collectionAssignments;
        return collectionAssignments === null || collectionAssignments === void 0 ? void 0 : collectionAssignments.map(function (_a) {
            var collectionId = _a.collectionId, collectionPosition = _a.collectionPosition;
            return [collectionId, collectionPosition].join('|');
        });
    })
        .filter(Boolean));
    permutations.forEach(function (permutation) {
        var _a = __read(permutation.split('|'), 2), collectionId = _a[0], position = _a[1];
        var collectionPosition = parseInt(position);
        var assignedParticipantIds = getCollectionPositionAssignments({
            collectionPosition: collectionPosition,
            collectionId: collectionId,
            lineUp: lineUp,
        }).assignedParticipantIds;
        assignedParticipantIds.forEach(function (participantId) {
            if (!participantAssignments[participantId])
                participantAssignments[participantId] = [];
            participantAssignments[participantId].push({
                collectionId: collectionId,
                collectionPosition: collectionPosition,
            });
        });
    });
    return Object.keys(participantAssignments).map(function (participantId) { return ({
        participantId: participantId,
        collectionAssignments: participantAssignments[participantId],
    }); });
}

function mustBeAnArray(value) {
    return "".concat(value, " must be an array");
}

function validateLineUp(_a) {
    var lineUp = _a.lineUp; _a.tieFormat;
    var errors = [];
    if (!Array.isArray(lineUp)) {
        errors.push(mustBeAnArray('lineUp'));
        return { valid: false, errors: errors, error: INVALID_VALUES };
    }
    var validItems = lineUp.every(function (item) {
        if (typeof item !== 'object') {
            errors.push("lineUp entries must be objects");
            return false;
        }
        var participantId = item.participantId, collectionAssignments = item.collectionAssignments;
        if (!participantId) {
            errors.push('Missing participantId');
            return false;
        }
        if (typeof participantId !== 'string') {
            errors.push('participantIds must be strings');
            return false;
        }
        if (!Array.isArray(collectionAssignments)) {
            errors.push(mustBeAnArray('collectionAssignments'));
            return false;
        }
        return collectionAssignments.every(function (collectionAssignment) {
            if (typeof collectionAssignment !== 'object') {
                errors.push('collectionAssignments must be objects');
                return false;
            }
            var collectionPosition = collectionAssignment.collectionPosition;
            if (typeof collectionPosition !== 'number') {
                errors.push('collectionPosition must be a number');
                return false;
            }
            return true;
        });
    });
    var noDuplicates = unique(lineUp.map(getParticipantId)).length === lineUp.length;
    if (!noDuplicates)
        errors.push('Duplicated participantId(s)');
    var valid = validItems && noDuplicates;
    return { valid: valid, errors: errors, error: errors.length ? INVALID_VALUES : undefined };
}

function updateTeamLineUp(_a) {
    var drawDefinition = _a.drawDefinition, participantId = _a.participantId, tieFormat = _a.tieFormat, lineUp = _a.lineUp;
    if (typeof drawDefinition !== 'object')
        return { error: MISSING_DRAW_DEFINITION };
    if (typeof participantId !== 'string')
        return { error: MISSING_PARTICIPANT_ID };
    var validation = validateLineUp({ lineUp: lineUp, tieFormat: tieFormat });
    if (!validation.valid)
        return validation;
    var existingExtension = findExtension({
        element: drawDefinition,
        name: LINEUPS,
    }).extension;
    var value = (existingExtension === null || existingExtension === void 0 ? void 0 : existingExtension.value) || {};
    value[participantId] = removeLineUpSubstitutions({ lineUp: lineUp });
    var extension = { name: LINEUPS, value: value };
    addExtension({ element: drawDefinition, extension: extension });
    addDrawNotice({ drawDefinition: drawDefinition });
    return __assign({}, SUCCESS);
}

function resetLineUps(_a) {
    var e_1, _b;
    var _c;
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, _d = _a.inheritance, inheritance = _d === void 0 ? true : _d, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, matchUpsMap = _a.matchUpsMap, assignments = _a.assignments, structure = _a.structure, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var _e = getTargetMatchUps({
        inContextDrawMatchUps: inContextDrawMatchUps,
        matchUpsMap: matchUpsMap,
        assignments: assignments,
        structure: structure,
    }), drawPositions = _e.drawPositions, matchUps = _e.matchUps, targetMatchUps = _e.targetMatchUps;
    var _loop_1 = function (inContextMatchUp) {
        if (inContextMatchUp.matchUpType !== TEAM_MATCHUP)
            return "continue";
        ((_c = inContextMatchUp.sides) !== null && _c !== void 0 ? _c : []).forEach(function (side, sideIndex) {
            var _a;
            if ((side === null || side === void 0 ? void 0 : side.drawPosition) && (drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(side.drawPosition))) {
                var matchUp = matchUps.find(function (_a) {
                    var matchUpId = _a.matchUpId;
                    return matchUpId === inContextMatchUp.matchUpId;
                });
                if ((_a = matchUp === null || matchUp === void 0 ? void 0 : matchUp.sides) === null || _a === void 0 ? void 0 : _a[sideIndex]) {
                    delete matchUp.sides[sideIndex].lineUp;
                    if (inheritance === false) {
                        // remove lineup for team participantId from drawDefinition LINE_UP extension
                        var tieFormat = inContextMatchUp.tieFormat;
                        var participantId = side.participantId;
                        if (tieFormat && participantId) {
                            updateTeamLineUp({
                                drawDefinition: drawDefinition,
                                participantId: participantId,
                                lineUp: [],
                                tieFormat: tieFormat,
                            });
                        }
                    }
                    modifyMatchUpNotice({
                        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                        context: 'resetLineUps',
                        eventId: event === null || event === void 0 ? void 0 : event.eventId,
                        drawDefinition: drawDefinition,
                        matchUp: matchUp,
                    });
                }
            }
        });
    };
    try {
        // remove all lineUps on appropriate sides of matchUps which include drawPositions
        // this will cause all lineUps to revert back to the team default lineUps (last modification) stored in LINEUPS extension
        for (var targetMatchUps_1 = __values(targetMatchUps), targetMatchUps_1_1 = targetMatchUps_1.next(); !targetMatchUps_1_1.done; targetMatchUps_1_1 = targetMatchUps_1.next()) {
            var inContextMatchUp = targetMatchUps_1_1.value;
            _loop_1(inContextMatchUp);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (targetMatchUps_1_1 && !targetMatchUps_1_1.done && (_b = targetMatchUps_1.return)) _b.call(targetMatchUps_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}

function assignDrawPosition$1(_a) {
    var _b, _c, _d;
    var provisionalPositioning = _a.provisionalPositioning, inContextDrawMatchUps = _a.inContextDrawMatchUps, isQualifierPosition = _a.isQualifierPosition, // internal use
    sourceMatchUpStatus = _a.sourceMatchUpStatus, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, seedingProfile = _a.seedingProfile, participantId = _a.participantId, seedBlockInfo = _a.seedBlockInfo, drawPosition = _a.drawPosition, matchUpsMap = _a.matchUpsMap, structureId = _a.structureId, event = _a.event;
    var stack = 'assignDrawPosition';
    if (!participantId && !isQualifierPosition)
        return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack: stack });
    matchUpsMap = matchUpsMap !== null && matchUpsMap !== void 0 ? matchUpsMap : getMatchUpsMap({ drawDefinition: drawDefinition });
    if (!inContextDrawMatchUps) {
        (inContextDrawMatchUps = getAllDrawMatchUps({
            inContext: true,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
        }).matchUps);
    }
    var result = findStructure({ drawDefinition: drawDefinition, structureId: structureId });
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    var structure = result.structure;
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    // there are no drawPositions assigned for ADHOC structures
    if (isAdHoc({ drawDefinition: drawDefinition, structure: structure }))
        return decorateResult({ result: { error: INVALID_MATCHUP }, stack: stack });
    var seedAssignments = getStructureSeedAssignments({
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        structure: structure,
    }).seedAssignments;
    var relevantAssignment = seedAssignments === null || seedAssignments === void 0 ? void 0 : seedAssignments.find(function (assignment) { return assignment.participantId === participantId; });
    var participantSeedNumber = relevantAssignment === null || relevantAssignment === void 0 ? void 0 : relevantAssignment.seedNumber;
    var appliedPolicies = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    }).appliedPolicies;
    if (participantSeedNumber) {
        var isValidDrawPosition = isValidSeedPosition({
            seedNumber: participantSeedNumber,
            appliedPolicies: appliedPolicies,
            drawDefinition: drawDefinition,
            seedBlockInfo: seedBlockInfo,
            drawPosition: drawPosition,
            structureId: structureId,
        });
        if (!isValidDrawPosition)
            return decorateResult({
                result: { error: INVALID_DRAW_POSITION_FOR_SEEDING },
                context: { drawPosition: drawPosition },
                stack: stack,
            });
    }
    var sadp = structureAssignedDrawPositions({ structure: structure });
    var positionAssignments = sadp.positionAssignments || [];
    var positionAssignment = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (assignment) { return assignment.drawPosition === drawPosition; });
    if (!positionAssignment)
        return decorateResult({
            result: { error: INVALID_DRAW_POSITION },
            context: { drawPosition: drawPosition },
            stack: stack,
        });
    var participantAlreadyAssigned = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.map(getParticipantId).includes(participantId);
    if (participantAlreadyAssigned) {
        return decorateResult({
            result: { error: EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT },
            context: { drawPosition: drawPosition },
            stack: stack,
        });
    }
    var _e = drawPositionFilled(positionAssignment), containsParticipant = _e.containsParticipant, containsBye = _e.containsBye;
    if (containsBye) {
        var result_1 = clearDrawPosition({
            inContextDrawMatchUps: inContextDrawMatchUps,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            drawPosition: drawPosition,
            structureId: structureId,
            matchUpsMap: matchUpsMap,
            event: event,
        });
        if (result_1.error)
            return decorateResult({ result: result_1, stack: stack });
    }
    if (containsParticipant &&
        positionAssignment.participantId !== participantId) {
        var activeDrawPositions = getStructureDrawPositionProfiles({
            drawDefinition: drawDefinition,
            structureId: structureId,
        }).activeDrawPositions;
        var drawPositionIsActive = activeDrawPositions.includes(drawPosition);
        if (drawPositionIsActive) {
            return decorateResult({ result: { error: DRAW_POSITION_ACTIVE }, stack: stack });
        }
        // cleanup side[].lineUps of previous participantId in TEAM matchUps
        resetLineUps({
            assignments: [positionAssignment],
            inContextDrawMatchUps: inContextDrawMatchUps,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
            structure: structure,
        });
    }
    positionAssignment.participantId = participantId;
    if (isQualifierPosition)
        positionAssignment.qualifier = true;
    if (((structure === null || structure === void 0 ? void 0 : structure.stageSequence) || 0) > 1 ||
        (structure.stage && [CONSOLATION, PLAY_OFF].includes(structure.stage))) {
        var targetStage_1 = structure.stage === QUALIFYING ? QUALIFYING : MAIN;
        var targetStructure = (_b = drawDefinition.structures) === null || _b === void 0 ? void 0 : _b.find(function (structure) {
            return (structure === null || structure === void 0 ? void 0 : structure.stage) === targetStage_1 && (structure === null || structure === void 0 ? void 0 : structure.stageSequence) === 1;
        });
        var seedAssignments_1 = (_c = targetStructure === null || targetStructure === void 0 ? void 0 : targetStructure.seedAssignments) !== null && _c !== void 0 ? _c : [];
        var assignment = seedAssignments_1.find(function (assignment) { return assignment.participantId === participantId; });
        if (assignment === null || assignment === void 0 ? void 0 : assignment.participantId) {
            var participantId_1 = assignment.participantId, seedNumber = assignment.seedNumber, seedValue = assignment.seedValue;
            assignSeed({
                eventId: event === null || event === void 0 ? void 0 : event.eventId,
                provisionalPositioning: provisionalPositioning,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                seedingProfile: seedingProfile,
                participantId: participantId_1,
                seedNumber: seedNumber,
                seedValue: seedValue,
                // ...assignment,
                structureId: structureId,
                event: event,
            });
        }
    }
    if (structure.structureType !== CONTAINER) {
        addDrawPositionToMatchUps({
            provisionalPositioning: provisionalPositioning,
            inContextDrawMatchUps: inContextDrawMatchUps,
            sourceMatchUpStatus: sourceMatchUpStatus,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            drawPosition: drawPosition,
            matchUpsMap: matchUpsMap,
            structure: structure,
            event: event,
        });
    }
    else {
        modifyRoundRobinMatchUpsStatus({
            positionAssignments: positionAssignments,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
            structure: structure,
        });
        // for ROUND_ROBIN events with TEAM matchUps, attach default lineUp
        var _f = getTargetMatchUps({
            assignments: [positionAssignment],
            inContextDrawMatchUps: inContextDrawMatchUps,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
            structure: structure,
        }), drawPositions_1 = _f.drawPositions, matchUps = _f.matchUps, targetMatchUps = _f.targetMatchUps;
        // if a team participant is being assigned and there is a default lineUp, attach to side
        if (drawPositions_1 &&
            (matchUps === null || matchUps === void 0 ? void 0 : matchUps.length) === 1 &&
            matchUps[0].matchUpType === TEAM) {
            var sides = (_d = targetMatchUps === null || targetMatchUps === void 0 ? void 0 : targetMatchUps[0].sides) !== null && _d !== void 0 ? _d : [];
            var drawPositionSideIndex = sides.reduce(function (sideIndex, side, i) {
                return (drawPositions_1 === null || drawPositions_1 === void 0 ? void 0 : drawPositions_1.includes(side.drawPosition)) ? i : sideIndex;
            }, undefined);
            updateSideLineUp({
                inContextTargetMatchUp: targetMatchUps[0],
                teamParticipantId: participantId,
                matchUp: matchUps[0],
                drawPositionSideIndex: drawPositionSideIndex,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
            });
        }
    }
    modifyPositionAssignmentsNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    });
    return __assign({ positionAssignments: positionAssignments }, SUCCESS);
    function drawPositionFilled(positionAssignment) {
        var containsBye = positionAssignment.bye;
        var containsQualifier = positionAssignment.qualifier;
        var containsParticipant = positionAssignment.participantId;
        var filled = containsBye || containsQualifier || containsParticipant;
        return { containsBye: containsBye, containsQualifier: containsQualifier, containsParticipant: containsParticipant, filled: filled };
    }
}
// used for matchUps which are NOT in a ROUND_ROBIN { structureType: CONTAINER }
function addDrawPositionToMatchUps(_a) {
    var provisionalPositioning = _a.provisionalPositioning, inContextDrawMatchUps = _a.inContextDrawMatchUps, sourceMatchUpStatus = _a.sourceMatchUpStatus, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawPosition = _a.drawPosition, matchUpsMap = _a.matchUpsMap, structure = _a.structure, event = _a.event;
    var matchUpFilters = { isCollectionMatchUp: false };
    var matchUps = getAllStructureMatchUps({
        provisionalPositioning: provisionalPositioning,
        matchUpFilters: matchUpFilters,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        structure: structure,
        event: event,
    }).matchUps;
    var roundMatchUps = getRoundMatchUps({ matchUps: matchUps }).roundMatchUps;
    var initialRoundNumber = getInitialRoundNumber({
        drawPosition: drawPosition,
        matchUps: matchUps,
    }).initialRoundNumber;
    var matchUp = initialRoundNumber &&
        (roundMatchUps === null || roundMatchUps === void 0 ? void 0 : roundMatchUps[initialRoundNumber].find(function (matchUp) { var _a; return (_a = matchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.includes(drawPosition); }));
    if (matchUp) {
        var result = assignMatchUpDrawPosition({
            matchUpId: matchUp.matchUpId,
            inContextDrawMatchUps: inContextDrawMatchUps,
            sourceMatchUpStatus: sourceMatchUpStatus,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            drawPosition: drawPosition,
            matchUpsMap: matchUpsMap,
        });
        if (result.error)
            return decorateResult({
                stack: 'assignDrawPositionToMatchUps',
                context: { drawPosition: drawPosition },
                result: result,
            });
    }
    return __assign({}, SUCCESS);
}

function positionParticipantAction(params) {
    var _a = params.participantIdAttributeName, participantIdAttributeName = _a === void 0 ? 'participantId' : _a, isQualifierPosition = params.isQualifierPosition, positionActionName = params.positionActionName, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, participantId = params.participantId, drawPosition = params.drawPosition, structureId = params.structureId, event = params.event;
    var stack = 'positionParticipantAction';
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var inContextDrawMatchUps = params.inContextDrawMatchUps, matchUpsMap = params.matchUpsMap;
    if (!matchUpsMap) {
        matchUpsMap = getMatchUpsMap({ drawDefinition: drawDefinition });
        Object.assign(params, { matchUpsMap: matchUpsMap });
    }
    if (!inContextDrawMatchUps) {
        (inContextDrawMatchUps = getAllDrawMatchUps({
            inContext: true,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
        }).matchUps);
        Object.assign(params, { inContextDrawMatchUps: inContextDrawMatchUps });
    }
    var positionAssignments = getPositionAssignments$1({
        drawDefinition: drawDefinition,
        structureId: structureId,
    }).positionAssignments;
    var positionAssignment = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (assignment) { return assignment.drawPosition === drawPosition; });
    if (positionAssignment === null || positionAssignment === void 0 ? void 0 : positionAssignment.participantId) {
        var removedParticipantId_1 = positionAssignment.participantId;
        var result_1 = assignDrawPosition$1({
            inContextDrawMatchUps: inContextDrawMatchUps,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            participantId: participantId,
            drawPosition: drawPosition,
            structureId: structureId,
            matchUpsMap: matchUpsMap,
            event: event,
        });
        if (!result_1.success) {
            return decorateResult({ result: result_1, stack: stack });
        }
        return successNotice({
            removedParticipantId: removedParticipantId_1,
        });
    }
    var result = clearDrawPosition({
        inContextDrawMatchUps: inContextDrawMatchUps,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        drawPosition: drawPosition,
        structureId: structureId,
        matchUpsMap: matchUpsMap,
        event: event,
    });
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    var removedParticipantId = result.participantId;
    var assignResult = assignDrawPosition$1({
        inContextDrawMatchUps: inContextDrawMatchUps,
        isQualifierPosition: isQualifierPosition,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        participantId: participantId,
        drawPosition: drawPosition,
        structureId: structureId,
        matchUpsMap: matchUpsMap,
        event: event,
    });
    if (!assignResult.success)
        return decorateResult({ result: assignResult, stack: stack });
    return successNotice({ removedParticipantId: removedParticipantId });
    function successNotice(_a) {
        var _b;
        var removedParticipantId = _a.removedParticipantId;
        var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
        conditionallyDisableLinkPositioning({
            drawPositions: [drawPosition],
            structure: structure,
        });
        var positionAction = (_b = {},
            _b[participantIdAttributeName] = participantId,
            _b.name = positionActionName,
            _b.drawPosition = drawPosition,
            _b.structureId = structureId,
            _b);
        addPositionActionTelemetry({ drawDefinition: drawDefinition, positionAction: positionAction });
        return decorateResult({
            context: { removedParticipantId: removedParticipantId },
            result: __assign({}, SUCCESS),
            stack: stack,
        });
    }
}

function luckyLoserDrawPositionAssignment$1(_a) {
    var luckyLoserParticipantId = _a.luckyLoserParticipantId, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawPosition = _a.drawPosition, structureId = _a.structureId;
    return positionParticipantAction({
        positionActionName: 'luckyLoserDrawPositionAssignment',
        participantId: luckyLoserParticipantId,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        drawPosition: drawPosition,
        structureId: structureId,
    });
}

/**
 *
 * @param {string} drawId - id of drawDefinition within which structure is found
 * @param {string} structureId - id of structure of drawPosition
 * @param {number} drawPosition - drawPosition where lucky loser participantId will be assigned
 * @param {string} luckyLoserParticipantId - id of participant
 *
 */
function luckyLoserDrawPositionAssignment(params) {
    return luckyLoserDrawPositionAssignment$1(params);
}

function publicFindMatchUp(params) {
    Object.assign(params, { inContext: true });
    var _a = findMatchUp(params), matchUp = _a.matchUp, error = _a.error;
    return { matchUp: makeDeepCopy(matchUp, true, true), error: error };
}
function findMatchUp(_a) {
    var _b;
    var _c, _d, _e, _f, _g, _h;
    var participantsProfile = _a.participantsProfile, afterRecoveryTimes = _a.afterRecoveryTimes, tournamentRecord = _a.tournamentRecord, contextContent = _a.contextContent, contextProfile = _a.contextProfile, drawDefinition = _a.drawDefinition, nextMatchUps = _a.nextMatchUps, matchUpId = _a.matchUpId, inContext = _a.inContext, eventId = _a.eventId, drawId = _a.drawId, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (typeof matchUpId !== 'string')
        return { error: MISSING_MATCHUP_ID };
    // brute force
    if (!drawDefinition || !event) {
        var matchUps = (_c = allTournamentMatchUps({ tournamentRecord: tournamentRecord, nextMatchUps: nextMatchUps }).matchUps) !== null && _c !== void 0 ? _c : [];
        var inContextMatchUp = matchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
        if (!inContextMatchUp)
            return { error: MATCHUP_NOT_FOUND };
        // since drawEngineFindMatchUp is being used, additional context needs to be provided
        (eventId = inContextMatchUp.eventId, drawId = inContextMatchUp.drawId);
        (_b = findEvent({
            tournamentRecord: tournamentRecord,
            eventId: eventId,
            drawId: drawId,
        }), event = _b.event, drawDefinition = _b.drawDefinition);
    }
    if (!drawDefinition)
        return { error: DRAW_DEFINITION_NOT_FOUND };
    if (contextProfile && !contextContent)
        contextContent = getContextContent({ tournamentRecord: tournamentRecord, contextProfile: contextProfile });
    var additionalContext = {
        surfaceCategory: (_d = event === null || event === void 0 ? void 0 : event.surfaceCategory) !== null && _d !== void 0 ? _d : tournamentRecord.surfaceCategory,
        indoorOutDoor: (_e = event === null || event === void 0 ? void 0 : event.indoorOutdoor) !== null && _e !== void 0 ? _e : tournamentRecord.indoorOutdoor,
        endDate: (_f = event === null || event === void 0 ? void 0 : event.endDate) !== null && _f !== void 0 ? _f : tournamentRecord.endDate,
        tournamentId: tournamentRecord.tournamentId,
        eventId: eventId !== null && eventId !== void 0 ? eventId : event === null || event === void 0 ? void 0 : event.eventId,
        drawId: drawId,
    };
    var _j = hydrateParticipants({
        participantsProfile: participantsProfile,
        tournamentRecord: tournamentRecord,
        contextProfile: contextProfile,
        inContext: inContext,
    }).participants, tournamentParticipants = _j === void 0 ? [] : _j;
    if (nextMatchUps) {
        var matchUps = (_g = allDrawMatchUps({
            context: inContext ? additionalContext : undefined,
            participants: tournamentParticipants,
            afterRecoveryTimes: afterRecoveryTimes,
            contextContent: contextContent,
            contextProfile: contextProfile,
            drawDefinition: drawDefinition,
            nextMatchUps: nextMatchUps,
            inContext: inContext,
            event: event,
        }).matchUps) !== null && _g !== void 0 ? _g : [];
        var inContextMatchUp_1 = matchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
        if (!inContextMatchUp_1)
            return { error: MATCHUP_NOT_FOUND };
        var structure = (_h = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) === null || _h === void 0 ? void 0 : _h.find(function (structure) { return structure.structureId === inContextMatchUp_1.structureId; });
        return { drawDefinition: drawDefinition, structure: structure, matchUp: inContextMatchUp_1 };
    }
    else {
        var _k = findDrawMatchUp({
            context: inContext ? additionalContext : undefined,
            tournamentParticipants: tournamentParticipants,
            afterRecoveryTimes: afterRecoveryTimes,
            contextContent: contextContent,
            drawDefinition: drawDefinition,
            contextProfile: contextProfile,
            matchUpId: matchUpId,
            inContext: inContext,
            event: event,
        }), matchUp = _k.matchUp, structure = _k.structure;
        return { matchUp: matchUp, structure: structure, drawDefinition: drawDefinition };
    }
}

function resolveFromParameters(params, paramsToResolve) {
    var e_1, _a;
    if (!isObject(params))
        return { error: INVALID_VALUES };
    if (!Array.isArray(paramsToResolve))
        return { error: INVALID_VALUES };
    var resolutions = {};
    try {
        for (var paramsToResolve_1 = __values(paramsToResolve), paramsToResolve_1_1 = paramsToResolve_1.next(); !paramsToResolve_1_1.done; paramsToResolve_1_1 = paramsToResolve_1.next()) {
            var _b = paramsToResolve_1_1.value, param = _b.param, error = _b.error, attr = _b.attr;
            var resolution = findResolution({ params: params, param: param, attr: attr, error: error });
            if (resolution === null || resolution === void 0 ? void 0 : resolution.error)
                return resolution;
            resolutions[param] = resolution;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (paramsToResolve_1_1 && !paramsToResolve_1_1.done && (_a = paramsToResolve_1.return)) _a.call(paramsToResolve_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return resolutions;
}
function findResolution(_a) {
    var _b;
    var params = _a.params, param = _a.param, attr = _a.attr, error = _a.error;
    if (param === STRUCTURE &&
        isObject(params.drawDefinition) &&
        isString(params.structureId)) {
        var result = ((_b = params.drawDefinition.structures) !== null && _b !== void 0 ? _b : []).find(function (_a) {
            var structureId = _a.structureId;
            return structureId === params.structureId;
        });
        return !result.length && error ? { error: error } : { structure: result };
    }
    if (param === MATCHUP) {
        var result = findMatchUp(__assign(__assign({}, params), attr));
        return result.error && error ? __assign(__assign({}, result), { error: error }) : result;
    }
    return { error: NOT_FOUND, info: { param: param } };
}

function addMatchUpTimeItem(_a) {
    var removePriorValues = _a.removePriorValues, tournamentRecord = _a.tournamentRecord, duplicateValues = _a.duplicateValues, drawDefinition = _a.drawDefinition, disableNotice = _a.disableNotice, matchUpId = _a.matchUpId, timeItem = _a.timeItem, event = _a.event;
    var matchUp = findDrawMatchUp({ drawDefinition: drawDefinition, event: event, matchUpId: matchUpId }).matchUp;
    if (!matchUp)
        return { error: MATCHUP_NOT_FOUND };
    var result = addTimeItem({
        removePriorValues: removePriorValues,
        element: matchUp,
        duplicateValues: duplicateValues,
        timeItem: timeItem,
    });
    if (!disableNotice) {
        modifyMatchUpNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            context: 'addTimeItem',
            drawDefinition: drawDefinition,
            matchUp: matchUp,
        });
    }
    return result;
}

function checkOutParticipant(params) {
    var _a, _b, _c, _d, _e, _f;
    var _g, _h;
    var requiredParams = [
        (_a = {}, _a[TOURNAMENT_RECORD] = true, _a),
        (_b = {}, _b[DRAW_DEFINITION] = true, _b),
        (_c = {}, _c[PARTICIPANT_ID] = true, _c),
        (_d = {}, _d[MATCHUP_ID] = true, _d),
    ];
    var paramCheck = checkRequiredParameters(params, requiredParams);
    if (paramCheck.error)
        return paramCheck;
    var resolutions = resolveFromParameters(params, [(_e = {}, _e[PARAM] = MATCHUP, _e.attr = (_f = {}, _f[IN_CONTEXT] = true, _f), _e)]);
    if (resolutions.error)
        return resolutions;
    var tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, participantId = params.participantId, matchUpId = params.matchUpId;
    var matchUp = (_g = resolutions === null || resolutions === void 0 ? void 0 : resolutions.matchUp) === null || _g === void 0 ? void 0 : _g.matchUp;
    var _j = matchUp !== null && matchUp !== void 0 ? matchUp : {}, matchUpStatus = _j.matchUpStatus, score = _j.score;
    if ((matchUpStatus && activeMatchUpStatuses.includes(matchUpStatus)) ||
        (matchUpStatus && completedMatchUpStatuses.includes(matchUpStatus)) ||
        checkScoreHasValue({ score: score })) {
        return { error: INVALID_ACTION };
    }
    var getCheckedResult = getCheckedInParticipantIds({
        matchUp: matchUp,
    });
    if (getCheckedResult === null || getCheckedResult === void 0 ? void 0 : getCheckedResult.error)
        return getCheckedResult;
    var _k = getCheckedResult !== null && getCheckedResult !== void 0 ? getCheckedResult : {}, checkedInParticipantIds = _k.checkedInParticipantIds, allRelevantParticipantIds = _k.allRelevantParticipantIds;
    if (!(allRelevantParticipantIds === null || allRelevantParticipantIds === void 0 ? void 0 : allRelevantParticipantIds.includes(participantId))) {
        return { error: INVALID_PARTICIPANT_ID };
    }
    if (!(checkedInParticipantIds === null || checkedInParticipantIds === void 0 ? void 0 : checkedInParticipantIds.includes(participantId))) {
        return { error: PARTICIPANT_NOT_CHECKED_IN };
    }
    var getIdsResult = getMatchUpParticipantIds({ matchUp: matchUp });
    if (getIdsResult === null || getIdsResult === void 0 ? void 0 : getIdsResult.error)
        return getIdsResult;
    var _l = getIdsResult !== null && getIdsResult !== void 0 ? getIdsResult : {}, sideParticipantIds = _l.sideParticipantIds, nestedIndividualParticipantIds = _l.nestedIndividualParticipantIds;
    var sideIndex = sideParticipantIds === null || sideParticipantIds === void 0 ? void 0 : sideParticipantIds.indexOf(participantId);
    if (sideIndex !== undefined && [0, 1].includes(sideIndex)) {
        ((_h = nestedIndividualParticipantIds === null || nestedIndividualParticipantIds === void 0 ? void 0 : nestedIndividualParticipantIds[sideIndex]) !== null && _h !== void 0 ? _h : []).forEach(function (participantId) {
            var timeItem = {
                itemType: CHECK_OUT,
                itemValue: participantId,
            };
            addMatchUpTimeItem({ drawDefinition: drawDefinition, matchUpId: matchUpId, timeItem: timeItem });
        });
    }
    var timeItem = {
        itemValue: participantId,
        itemType: CHECK_OUT,
    };
    return addMatchUpTimeItem({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
        timeItem: timeItem,
    });
}

function checkInParticipant(params) {
    var _a, _b, _c, _d, _e, _f, _g;
    var _h;
    var requiredParams = [
        (_a = {}, _a[TOURNAMENT_RECORD] = true, _a),
        (_b = {}, _b[DRAW_DEFINITION] = true, _b),
        (_c = {}, _c[PARTICIPANT_ID] = true, _c),
        (_d = {}, _d[MATCHUP_ID] = true, _d),
    ];
    var paramCheck = checkRequiredParameters(params, requiredParams);
    if (paramCheck[ERROR])
        return paramCheck;
    var resolutions = resolveFromParameters(params, [(_e = {}, _e[PARAM] = MATCHUP, _e.attr = (_f = {}, _f[IN_CONTEXT] = true, _f), _e)]);
    if (resolutions[ERROR])
        return resolutions;
    var tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, participantId = params.participantId, matchUpId = params.matchUpId;
    var result = getCheckedInParticipantIds({
        matchUp: (_h = resolutions === null || resolutions === void 0 ? void 0 : resolutions.matchUp) === null || _h === void 0 ? void 0 : _h.matchUp,
    });
    if (result === null || result === void 0 ? void 0 : result.error)
        return result;
    var _j = result !== null && result !== void 0 ? result : {}, checkedInParticipantIds = _j.checkedInParticipantIds, allRelevantParticipantIds = _j.allRelevantParticipantIds;
    if (checkedInParticipantIds === null || checkedInParticipantIds === void 0 ? void 0 : checkedInParticipantIds.includes(participantId))
        return __assign({}, SUCCESS);
    if (!(allRelevantParticipantIds === null || allRelevantParticipantIds === void 0 ? void 0 : allRelevantParticipantIds.includes(participantId)))
        return _g = {}, _g[ERROR] = INVALID_PARTICIPANT_ID, _g;
    var timeItem = {
        itemValue: participantId,
        itemType: CHECK_IN,
    };
    return addMatchUpTimeItem({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
        timeItem: timeItem,
    });
}

function toggleParticipantCheckInState(params) {
    var _a, _b;
    var _c, _d, _e, _f;
    var paramCheck = checkRequiredParameters(params, [
        (_a = {}, _a[PARTICIPANT_ID] = true, _a[DRAW_DEFINITION] = true, _a[MATCHUP_ID] = true, _a),
    ]);
    if (paramCheck.error)
        return paramCheck;
    var tournamentId = (_c = params.tournamentId) !== null && _c !== void 0 ? _c : params.activeTournamentId;
    var tournamentRecord = (_d = params.tournamentRecord) !== null && _d !== void 0 ? _d : (tournamentId && ((_e = params.tournamentRecords) === null || _e === void 0 ? void 0 : _e[tournamentId]));
    var participantId = params.participantId, matchUpId = params.matchUpId, drawDefinition = params.drawDefinition;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var resolutions = resolveFromParameters(params, [(_b = {}, _b[PARAM] = MATCHUP, _b[ERROR] = MATCHUP_NOT_FOUND, _b)]);
    var matchUp = (_f = resolutions.matchUp) === null || _f === void 0 ? void 0 : _f.matchUp;
    if (!matchUp)
        return { error: MATCHUP_NOT_FOUND };
    var _g = getCheckedInParticipantIds({
        matchUp: matchUp,
    }).checkedInParticipantIds, checkedInParticipantIds = _g === void 0 ? [] : _g;
    if (participantId && checkedInParticipantIds.includes(participantId)) {
        return checkOutParticipant({
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            participantId: participantId,
            matchUpId: matchUpId,
            matchUp: matchUp,
        });
    }
    else {
        return checkInParticipant({
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            participantId: participantId,
            matchUpId: matchUpId,
            matchUp: matchUp,
        });
    }
}

function alternateDrawPositionAssignment$1(_a) {
    var alternateParticipantId = _a.alternateParticipantId, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawPosition = _a.drawPosition, structureId = _a.structureId;
    return positionParticipantAction({
        positionActionName: 'alternateDrawPositionAssignment',
        participantIdAttributeName: 'alternateParticipantid',
        participantId: alternateParticipantId,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        drawPosition: drawPosition,
        structureId: structureId,
    });
}

/**
 *
 * @param {string} drawId - id of drawDefinition within which structure is found
 * @param {string} structureId - id of structure of drawPosition
 * @param {number} drawPosition - drawPosition where alternate participantId will be assigned
 * @param {string} alternateParticipantId - id of participant
 *
 */
function alternateDrawPositionAssignment(params) {
    return alternateDrawPositionAssignment$1(params);
}

function qualifierDrawPositionAssignment$1(_a) {
    var qualifyingParticipantId = _a.qualifyingParticipantId, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawPosition = _a.drawPosition, structureId = _a.structureId;
    return positionParticipantAction({
        positionActionName: 'qualifierDrawPositionAssignment',
        participantId: qualifyingParticipantId,
        isQualifierPosition: true,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        drawPosition: drawPosition,
        structureId: structureId,
    });
}

/**
 *
 * @param {string} drawId - id of drawDefinition within which structure is found
 * @param {string} structureId - id of structure of drawPosition
 * @param {number} drawPosition - drawPosition where lucky loser participantId will be assigned
 * @param {string} qualifierParticipantId - id of participant
 *
 */
function qualifierDrawPositionAssignment(params) {
    return qualifierDrawPositionAssignment$1(params);
}

function getTieMatchUpContext(_a) {
    var _b, _c, _d, _e;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, tieMatchUpId = _a.tieMatchUpId, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!drawDefinition)
        return { error: MISSING_DRAW_ID };
    if (!event)
        return { error: EVENT_NOT_FOUND };
    var matchUpsMap = getMatchUpsMap({ drawDefinition: drawDefinition });
    // tieMatchUp is matchUpType: SINGLES or DOUBLES
    var tieMatchUp = findDrawMatchUp({
        matchUpId: tieMatchUpId,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
    }).matchUp;
    if (!tieMatchUp)
        return { error: MATCHUP_NOT_FOUND };
    var _f = findDrawMatchUp({
        tournamentParticipants: tournamentRecord.participants,
        matchUpId: tieMatchUpId,
        inContext: true,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        event: event,
    }), inContextTieMatchUp = _f.matchUp, structure = _f.structure;
    if (!inContextTieMatchUp)
        return { error: MATCHUP_NOT_FOUND };
    var collectionPosition = inContextTieMatchUp.collectionPosition, drawPositions = inContextTieMatchUp.drawPositions, collectionId = inContextTieMatchUp.collectionId, matchUpTieId = inContextTieMatchUp.matchUpTieId, matchUpType = inContextTieMatchUp.matchUpType;
    if (matchUpType && ![SINGLES, DOUBLES].includes(matchUpType))
        return { error: INVALID_MATCHUP };
    var positionAssignments = getPositionAssignments$1({ structure: structure }).positionAssignments;
    var relevantAssignments = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) { return drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(assignment.drawPosition); });
    var dualMatchUp = findDrawMatchUp({
        matchUpId: matchUpTieId,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
    }).matchUp;
    var sideParticipantIds = (_c = (_b = dualMatchUp === null || dualMatchUp === void 0 ? void 0 : dualMatchUp.sides) === null || _b === void 0 ? void 0 : _b.map(xa('participantId'))) !== null && _c !== void 0 ? _c : [];
    var assignedParticipantIds = (_d = relevantAssignments === null || relevantAssignments === void 0 ? void 0 : relevantAssignments.map(xa('participantId'))) !== null && _d !== void 0 ? _d : [];
    var participantIds = __spreadArray(__spreadArray([], __read(sideParticipantIds), false), __read(assignedParticipantIds), false);
    var teamParticipants = getParticipants({
        tournamentRecord: tournamentRecord,
        participantFilters: {
            participantTypes: [TEAM$1],
            participantIds: participantIds,
        },
    }).participants;
    var inContextDualMatchUp = findDrawMatchUp({
        matchUpId: matchUpTieId,
        inContext: true,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
    }).matchUp;
    var tieFormat = (_e = resolveTieFormat({
        matchUp: dualMatchUp,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    })) === null || _e === void 0 ? void 0 : _e.tieFormat;
    return __assign({ inContextDualMatchUp: inContextDualMatchUp, inContextTieMatchUp: inContextTieMatchUp, relevantAssignments: relevantAssignments, collectionPosition: collectionPosition, teamParticipants: teamParticipants, collectionId: collectionId, matchUpType: matchUpType, dualMatchUp: dualMatchUp, tieMatchUp: tieMatchUp, tieFormat: tieFormat, structure: structure }, SUCCESS);
}

function addParticipant(params) {
    var e_1, _a;
    var _b, _c, _d, _e, _f, _g;
    var stack = 'addParticipant';
    var allowDuplicateParticipantIdPairs = params.allowDuplicateParticipantIdPairs, returnParticipant = params.returnParticipant, disableNotice = params.disableNotice, pairOverride = params.pairOverride, participant = params.participant;
    var tournamentRecord = params.tournamentId // if a tournamentId is specified, use it!
        ? (_b = params.tournamentRecords) === null || _b === void 0 ? void 0 : _b[params.tournamentId]
        : (_c = params.tournamentRecord) !== null && _c !== void 0 ? _c : (params.activeTournamentId &&
            ((_d = params.tournamentRecords) === null || _d === void 0 ? void 0 : _d[params.activeTournamentId]));
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!participant)
        return decorateResult({ result: { error: MISSING_PARTICIPANT }, stack: stack });
    if (!participant.participantId)
        participant.participantId = UUID();
    if (!tournamentRecord.participants)
        tournamentRecord.participants = [];
    var participantId = participant.participantId, individualParticipantIds = participant.individualParticipantIds;
    var idExists = tournamentRecord.participants.reduce(function (p, c) { return c.participantId === participantId || p; }, false);
    if (idExists)
        return { error: PARTICIPANT_ID_EXISTS };
    var participantType = participant.participantType, participantRole = participant.participantRole;
    if (!participantType ||
        !Object.keys(participantTypes).includes(participantType))
        return { error: INVALID_PARTICIPANT_TYPE, participantType: participantType };
    if (!participantRole)
        return { error: MISSING_PARTICIPANT_ROLE };
    var tournamentParticipants = tournamentRecord.participants || [];
    var tournamentIndividualParticipantIds = tournamentParticipants
        .filter(function (tournamentParticipant) {
        return tournamentParticipant.participantType === INDIVIDUAL;
    })
        .map(function (individualParticipant) { return individualParticipant.participantId; });
    if (participantType !== INDIVIDUAL && participant.person)
        return { error: INVALID_VALUES, person: participant.person };
    if (individualParticipantIds && !Array.isArray(individualParticipantIds))
        return { error: INVALID_VALUES, individualParticipantIds: individualParticipantIds };
    if (participantType === PAIR) {
        if (participant.person)
            return { error: INVALID_VALUES, person: participant.person };
        if (!participant.individualParticipantIds) {
            return decorateResult({
                result: { error: MISSING_PARTICIPANT_IDS },
                stack: stack,
            });
        }
        else if (participant.individualParticipantIds.length !== 2 &&
            !pairOverride) {
            return decorateResult({
                info: 'PAIR must be 2 individualParticipantIds',
                result: { error: INVALID_PARTICIPANT_IDS },
                stack: stack,
            });
        }
        else {
            var individualParticipantIds_1 = tournamentParticipants
                .filter(function (participant) { return participant.participantType === INDIVIDUAL; })
                .map(function (participant) { return participant.participantId; });
            if (!Array.isArray(participant.individualParticipantIds))
                return decorateResult({
                    result: { error: INVALID_PARTICIPANT_IDS },
                    stack: stack,
                });
            var validPairParticipants = participant.individualParticipantIds.reduce(function (valid, participantId) {
                return individualParticipantIds_1.includes(participantId) && valid;
            }, true);
            if (!validPairParticipants)
                return decorateResult({
                    result: { error: INVALID_PARTICIPANT_IDS },
                    stack: stack,
                });
        }
        var existingPairParticipants = tournamentParticipants
            .filter(function (participant) { return participant.participantType === PAIR; })
            .map(function (participant) { return ({
            individualParticipantIds: participant.individualParticipantIds,
            participant: participant,
        }); });
        // determine whether a PAIR participant already exists
        var existingPairParticipant = participant.participantType === PAIR &&
            existingPairParticipants.find(function (existingPairParticipant) {
                return intersection(existingPairParticipant.individualParticipantIds, participant.individualParticipantIds).length === 2;
            });
        if (existingPairParticipant && !allowDuplicateParticipantIdPairs) {
            return __assign(__assign({}, SUCCESS), { existingParticipant: true, participant: returnParticipant &&
                    makeDeepCopy(existingPairParticipant.participant) });
        }
        if (!participant.participantName) {
            var individualParticipants = tournamentParticipants.filter(function (tournamentParticipant) {
                var _a;
                return (_a = participant.individualParticipantIds) === null || _a === void 0 ? void 0 : _a.includes(tournamentParticipant.participantId);
            });
            var participantName = individualParticipants
                .map(function (participant) { var _a; return (_a = participant.person) === null || _a === void 0 ? void 0 : _a.standardFamilyName; })
                .filter(Boolean)
                .join('/');
            if (individualParticipants.length === 1)
                participantName += '/Unknown';
            participant.participantName = participantName;
        }
    }
    else if (participantType === INDIVIDUAL) {
        if (!((_e = participant.person) === null || _e === void 0 ? void 0 : _e.standardFamilyName) ||
            !((_f = participant.person) === null || _f === void 0 ? void 0 : _f.standardGivenName))
            return { error: MISSING_PERSON_DETAILS };
        if (!participant.participantName) {
            var participantName = "".concat(participant.person.standardFamilyName.toUpperCase(), ", ").concat(participant.person.standardGivenName);
            participant.participantName = participantName;
        }
    }
    else if (participantType && [TEAM$1, GROUP].includes(participantType)) {
        if (!individualParticipantIds)
            participant.individualParticipantIds = [];
        if ((_g = participant.individualParticipantIds) === null || _g === void 0 ? void 0 : _g.length) {
            try {
                for (var _h = __values(participant.individualParticipantIds), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var individualParticipantId = _j.value;
                    if (typeof individualParticipantId !== 'string') {
                        return decorateResult({
                            result: {
                                participantId: individualParticipantId,
                                error: INVALID_VALUES,
                            },
                            stack: stack,
                        });
                    }
                    if (!tournamentIndividualParticipantIds.includes(individualParticipantId)) {
                        return decorateResult({
                            result: {
                                participantId: individualParticipantId,
                                error: PARTICIPANT_NOT_FOUND,
                            },
                            stack: stack,
                        });
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_j && !_j.done && (_a = _h.return)) _a.call(_h);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
    else {
        return { error: INVALID_PARTICIPANT_TYPE };
    }
    tournamentRecord.participants.push(participant);
    if (!disableNotice) {
        addNotice({
            payload: {
                tournamentId: tournamentRecord.tournamentId,
                participants: [participant],
            },
            topic: ADD_PARTICIPANTS,
        });
    }
    var result = __assign({ participant: returnParticipant && makeDeepCopy(participant) }, SUCCESS);
    return definedAttributes(result);
}

function ensureSideLineUps(_a) {
    var _b, _c;
    var inContextDualMatchUp = _a.inContextDualMatchUp, drawDefinition = _a.drawDefinition, tournamentId = _a.tournamentId, dualMatchUp = _a.dualMatchUp, eventId = _a.eventId;
    if (dualMatchUp) {
        if (!inContextDualMatchUp) {
            inContextDualMatchUp = (_b = findDrawMatchUp({
                matchUpId: dualMatchUp.matchUpId,
                inContext: true,
                drawDefinition: drawDefinition,
            })) === null || _b === void 0 ? void 0 : _b.matchUp;
        }
        var extension = findExtension({
            element: drawDefinition,
            name: LINEUPS,
        }).extension;
        var lineUps_1 = makeDeepCopy((extension === null || extension === void 0 ? void 0 : extension.value) || {}, false, true);
        var extractSideDetail_1 = function (_a) {
            var displaySideNumber = _a.displaySideNumber, drawPosition = _a.drawPosition, sideNumber = _a.sideNumber;
            return ({
                drawPosition: drawPosition,
                sideNumber: sideNumber,
                displaySideNumber: displaySideNumber,
            });
        };
        dualMatchUp.sides = (_c = inContextDualMatchUp === null || inContextDualMatchUp === void 0 ? void 0 : inContextDualMatchUp.sides) === null || _c === void 0 ? void 0 : _c.map(function (contextSide) {
            var _a, _b;
            var participantId = contextSide.participantId;
            var referenceLineUp = (participantId && lineUps_1[participantId]) || undefined;
            var _c = (_b = (_a = dualMatchUp.sides) === null || _a === void 0 ? void 0 : _a.find(function (_a) {
                var sideNumber = _a.sideNumber;
                return sideNumber === contextSide.sideNumber;
            })) !== null && _b !== void 0 ? _b : {}, noContextLineUp = _c.lineUp, noContextSideDetail = __rest(_c, ["lineUp"]);
            var lineUp = (noContextLineUp === null || noContextLineUp === void 0 ? void 0 : noContextLineUp.length) ? noContextLineUp : referenceLineUp;
            return __assign(__assign(__assign({}, extractSideDetail_1(contextSide)), noContextSideDetail), { lineUp: lineUp });
        });
        modifyMatchUpNotice({
            context: 'ensureSidLineUps',
            matchUp: dualMatchUp,
            drawDefinition: drawDefinition,
            tournamentId: tournamentId,
            eventId: eventId,
        });
    }
}

function replaceTieMatchUpParticipantId(params) {
    var e_1, _a;
    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    var matchUpContext = getTieMatchUpContext(params);
    if (matchUpContext.error)
        return matchUpContext;
    var stack = 'replaceTieMatchUpParticipantid';
    var existingParticipantId = params.existingParticipantId, tournamentRecord = params.tournamentRecord, newParticipantId = params.newParticipantId, drawDefinition = params.drawDefinition, substitution = params.substitution, event = params.event;
    if (!existingParticipantId || !newParticipantId)
        return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack: stack });
    if (existingParticipantId === newParticipantId)
        return __assign({}, SUCCESS);
    var inContextDualMatchUp = matchUpContext.inContextDualMatchUp, inContextTieMatchUp = matchUpContext.inContextTieMatchUp, collectionPosition = matchUpContext.collectionPosition, collectionId = matchUpContext.collectionId, dualMatchUp = matchUpContext.dualMatchUp, tieMatchUp = matchUpContext.tieMatchUp, tieFormat = matchUpContext.tieFormat;
    var matchUpType = inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.matchUpType;
    var side = (_b = inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.sides) === null || _b === void 0 ? void 0 : _b.find(function (side) {
        var _a, _b, _c;
        return ((_a = side.participant) === null || _a === void 0 ? void 0 : _a.participantId) === existingParticipantId ||
            ((_c = (_b = side.participant) === null || _b === void 0 ? void 0 : _b.individualParticipantIds) === null || _c === void 0 ? void 0 : _c.includes(existingParticipantId));
    });
    if (!side)
        return { error: PARTICIPANT_NOT_FOUND };
    var targetParticipants = (_d = (_c = getParticipants({
        tournamentRecord: tournamentRecord,
        participantFilters: {
            participantIds: [existingParticipantId, newParticipantId],
        },
    })) === null || _c === void 0 ? void 0 : _c.participants) !== null && _d !== void 0 ? _d : [];
    if (targetParticipants.length !== 2)
        return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack: stack });
    if (targetParticipants[0].participantType !==
        targetParticipants[1].participantType)
        return decorateResult({
            result: { error: INVALID_PARTICIPANT_TYPE },
            stack: stack,
        });
    var appliedPolicies = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        event: event,
    }).appliedPolicies;
    var matchUpActionsPolicy = (_g = (_f = (_e = params.policyDefinitions) === null || _e === void 0 ? void 0 : _e[POLICY_TYPE_MATCHUP_ACTIONS]) !== null && _f !== void 0 ? _f : appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_MATCHUP_ACTIONS]) !== null && _g !== void 0 ? _g : POLICY_MATCHUP_ACTIONS_DEFAULT[POLICY_TYPE_MATCHUP_ACTIONS];
    var newParticipant = targetParticipants.find(function (_a) {
        var participantId = _a.participantId;
        return participantId === newParticipantId;
    });
    var genderEnforced = ((_h = params.enforceGender) !== null && _h !== void 0 ? _h : (_j = matchUpActionsPolicy === null || matchUpActionsPolicy === void 0 ? void 0 : matchUpActionsPolicy.participants) === null || _j === void 0 ? void 0 : _j.enforceGender) !== false;
    if (genderEnforced &&
        [MALE, FEMALE].includes(inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.gender) &&
        (inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.gender) !== ((_k = newParticipant === null || newParticipant === void 0 ? void 0 : newParticipant.person) === null || _k === void 0 ? void 0 : _k.sex)) {
        return { error: INVALID_PARTICIPANT, info: 'Gender mismatch' };
    }
    var substitutionProcessCodes = (_l = matchUpActionsPolicy === null || matchUpActionsPolicy === void 0 ? void 0 : matchUpActionsPolicy.processCodes) === null || _l === void 0 ? void 0 : _l.substitution;
    ensureSideLineUps({
        tournamentId: tournamentRecord.tournamentId,
        eventId: event.eventId,
        inContextDualMatchUp: inContextDualMatchUp,
        drawDefinition: drawDefinition,
        dualMatchUp: dualMatchUp,
    });
    var dualMatchUpSide = (_m = dualMatchUp === null || dualMatchUp === void 0 ? void 0 : dualMatchUp.sides) === null || _m === void 0 ? void 0 : _m.find(function (_a) {
        var sideNumber = _a.sideNumber;
        return sideNumber === side.sideNumber;
    });
    if (!dualMatchUpSide) {
        return decorateResult({
            result: {
                sideNumber: side.sideNumber,
                existingParticipantId: existingParticipantId,
                error: NOT_FOUND,
            },
            stack: stack,
        });
    }
    var allTieIndividualParticipantIds = (_o = inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.sides) === null || _o === void 0 ? void 0 : _o.flatMap(function (side) {
        var _a, _b;
        return ((_a = side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipantIds) ||
            ((_b = side.participant) === null || _b === void 0 ? void 0 : _b.participantId) ||
            [];
    });
    if (allTieIndividualParticipantIds === null || allTieIndividualParticipantIds === void 0 ? void 0 : allTieIndividualParticipantIds.includes(newParticipantId)) {
        return decorateResult({ result: { error: EXISTING_PARTICIPANT }, stack: stack });
    }
    var teamParticipantId = (_q = (_p = inContextDualMatchUp === null || inContextDualMatchUp === void 0 ? void 0 : inContextDualMatchUp.sides) === null || _p === void 0 ? void 0 : _p.find(function (_a) {
        var sideNumber = _a.sideNumber;
        return sideNumber === side.sideNumber;
    })) === null || _q === void 0 ? void 0 : _q.participantId;
    var teamLineUp = dualMatchUpSide.lineUp;
    var newParticipantIdInLineUp = teamLineUp === null || teamLineUp === void 0 ? void 0 : teamLineUp.find(function (_a) {
        var participantId = _a.participantId;
        return newParticipantId === participantId;
    });
    var substitutionOrder = teamLineUp === null || teamLineUp === void 0 ? void 0 : teamLineUp.reduce(function (order, teamCompetitor) {
        return teamCompetitor.substitutionOrder > order
            ? teamCompetitor.substitutionOrder
            : order;
    }, 0);
    var modifiedLineUp = (_r = teamLineUp === null || teamLineUp === void 0 ? void 0 : teamLineUp.map(function (teamCompetitor) {
        var _a;
        var modifiedCompetitor = makeDeepCopy(teamCompetitor, false, true);
        // if the current competitor is not either id, return as is
        if (![existingParticipantId, newParticipantId].includes(modifiedCompetitor.participantId)) {
            return modifiedCompetitor;
        }
        // if current competitor includes an id then filter out current assignment
        if (!substitution &&
            [existingParticipantId, newParticipantId].includes(modifiedCompetitor.participantId)) {
            modifiedCompetitor.collectionAssignments =
                (_a = modifiedCompetitor.collectionAssignments) === null || _a === void 0 ? void 0 : _a.filter(function (assignment) {
                    return !(assignment.collectionPosition === collectionPosition &&
                        assignment.collectionId === collectionId);
                });
        }
        if (substitution &&
            existingParticipantId === modifiedCompetitor.participantId) {
            modifiedCompetitor.collectionAssignments =
                modifiedCompetitor.collectionAssignments.map(function (assignment) {
                    if (assignment.collectionPosition === collectionPosition &&
                        assignment.collectionId === collectionId &&
                        assignment.substitutionOrder === undefined) {
                        return __assign(__assign({}, assignment), { substitutionOrder: substitutionOrder });
                    }
                    return assignment;
                });
        }
        // if current competitor is newParticipantId, push the new assignment
        if (modifiedCompetitor.participantId === newParticipantId) {
            if (!modifiedCompetitor.collectionAssignments)
                modifiedCompetitor.collectionAssignments = [];
            var assignment = { collectionId: collectionId, collectionPosition: collectionPosition };
            if (substitution) {
                assignment.previousParticipantId = existingParticipantId;
                assignment.substitutionOrder = (substitutionOrder !== null && substitutionOrder !== void 0 ? substitutionOrder : 0) + 1;
            }
            modifiedCompetitor.collectionAssignments.push(assignment);
        }
        return modifiedCompetitor;
    })) !== null && _r !== void 0 ? _r : [];
    if (!newParticipantIdInLineUp) {
        var collectionAssignment = { collectionId: collectionId, collectionPosition: collectionPosition };
        if (substitution) {
            collectionAssignment.substitutionOrder = (substitutionOrder !== null && substitutionOrder !== void 0 ? substitutionOrder : 0) + 1;
            collectionAssignment.previousParticipantId = existingParticipantId;
        }
        var assignment = {
            collectionAssignments: [collectionAssignment],
            participantId: newParticipantId,
        };
        modifiedLineUp.push(assignment);
    }
    var isDoubles = matchUpType === DOUBLES;
    var existingIndividualParticipantIds = getCollectionPositionAssignments({
        lineUp: teamLineUp,
        collectionPosition: collectionPosition,
        collectionId: collectionId,
    }).assignedParticipantIds;
    // now check whether new pairParticipant exists
    var individualParticipantIds = getCollectionPositionAssignments({
        lineUp: modifiedLineUp,
        collectionPosition: collectionPosition,
        collectionId: collectionId,
    }).assignedParticipantIds;
    dualMatchUpSide.lineUp = modifiedLineUp;
    if (teamParticipantId && tieFormat) {
        var result = updateTeamLineUp({
            participantId: teamParticipantId,
            lineUp: modifiedLineUp,
            drawDefinition: drawDefinition,
            tieFormat: tieFormat,
        });
        if (result.error)
            return decorateResult({ result: result, stack: stack });
    }
    else {
        console.log('team participantId not found');
    }
    var participantAdded, participantRemoved;
    if (isDoubles) {
        var tournamentRecord_1 = params.tournamentRecord;
        var result = getPairedParticipant({
            participantIds: individualParticipantIds,
            tournamentRecord: tournamentRecord_1,
        });
        if (!result.participant) {
            var participant = {
                participantRole: COMPETITOR,
                individualParticipantIds: individualParticipantIds,
                participantType: PAIR,
            };
            var result_1 = addParticipant({
                returnParticipant: true,
                pairOverride: true,
                tournamentRecord: tournamentRecord_1,
                participant: participant,
            });
            if (result_1.error)
                return decorateResult({ result: result_1, stack: stack });
            participantAdded = (_s = result_1.participant) === null || _s === void 0 ? void 0 : _s.participantId;
        }
        // now attempt to cleanup/delete previous pairParticipant
        result = getPairedParticipant({
            participantIds: existingIndividualParticipantIds,
            tournamentRecord: tournamentRecord_1,
        });
        var existingPairParticipantId = (_t = result.participant) === null || _t === void 0 ? void 0 : _t.participantId;
        if (existingPairParticipantId) {
            var result_2 = deleteParticipants({
                participantIds: [existingPairParticipantId],
                tournamentRecord: tournamentRecord_1,
            });
            if (result_2.success)
                participantRemoved = existingPairParticipantId;
        }
    }
    if (substitution || ((_u = side.substitutions) === null || _u === void 0 ? void 0 : _u.length) === 1) {
        if (substitution) {
            if (substitutionProcessCodes && tieMatchUp) {
                tieMatchUp.processCodes = unique(__spreadArray(__spreadArray([], __read(((_v = tieMatchUp === null || tieMatchUp === void 0 ? void 0 : tieMatchUp.processCodes) !== null && _v !== void 0 ? _v : [])), false), __read(substitutionProcessCodes), false));
            }
        }
        else {
            try {
                // if there was only one substitution, remove processCode(s)
                for (var _y = __values(substitutionProcessCodes || []), _z = _y.next(); !_z.done; _z = _y.next()) {
                    var substitutionProcessCode = _z.value;
                    var codeIndex = (_w = tieMatchUp === null || tieMatchUp === void 0 ? void 0 : tieMatchUp.processCodes) === null || _w === void 0 ? void 0 : _w.lastIndexOf(substitutionProcessCode);
                    // remove only one instance of substitutionProcessCode
                    codeIndex !== undefined &&
                        ((_x = tieMatchUp === null || tieMatchUp === void 0 ? void 0 : tieMatchUp.processCodes) === null || _x === void 0 ? void 0 : _x.splice(codeIndex, 1));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_z && !_z.done && (_a = _y.return)) _a.call(_y);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        if (tieMatchUp) {
            modifyMatchUpNotice({
                tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                matchUp: tieMatchUp,
                context: stack,
                drawDefinition: drawDefinition,
            });
        }
    }
    if (dualMatchUp) {
        modifyMatchUpNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            matchUp: dualMatchUp,
            context: stack,
            drawDefinition: drawDefinition,
        });
    }
    return __assign(__assign({}, SUCCESS), { modifiedLineUp: modifiedLineUp, participantRemoved: participantRemoved, participantAdded: participantAdded });
}

function removeCollectionAssignments(_a) {
    var _b;
    var collectionPosition = _a.collectionPosition, teamParticipantId = _a.teamParticipantId, dualMatchUpSide = _a.dualMatchUpSide, drawDefinition = _a.drawDefinition, participantIds = _a.participantIds, collectionId = _a.collectionId;
    if (!collectionId || !collectionPosition || !Array.isArray(participantIds))
        return {
            modifiedLineUp: (dualMatchUpSide === null || dualMatchUpSide === void 0 ? void 0 : dualMatchUpSide.lineUp) || [],
            error: INVALID_VALUES,
        };
    var lineUp = (dualMatchUpSide === null || dualMatchUpSide === void 0 ? void 0 : dualMatchUpSide.lineUp) ||
        ((_b = getTeamLineUp({
            participantId: teamParticipantId,
            drawDefinition: drawDefinition,
        })) === null || _b === void 0 ? void 0 : _b.lineUp);
    var previousParticipantIds = [];
    var assignmentsRemoved = [];
    var modifiedLineUp = (lineUp === null || lineUp === void 0 ? void 0 : lineUp.map(function (teamCompetitor) {
        var _a;
        // don't modify an individual team competitor unless it appears in participantIds
        if (!participantIds.includes(teamCompetitor.participantId)) {
            return teamCompetitor;
        }
        var collectionAssignments = (_a = teamCompetitor.collectionAssignments) === null || _a === void 0 ? void 0 : _a.filter(function (assignment) {
            var target = assignment.collectionId === collectionId &&
                assignment.collectionPosition === collectionPosition;
            if (target) {
                if (assignment.previousParticipantId) {
                    previousParticipantIds.push(assignment.previousParticipantId);
                }
                assignmentsRemoved.push(__assign({ participantId: teamCompetitor.participantId }, assignment));
            }
            return !target;
        });
        return {
            participantId: teamCompetitor.participantId,
            collectionAssignments: collectionAssignments,
        };
    }).filter(Boolean)) || [];
    return { modifiedLineUp: modifiedLineUp, assignmentsRemoved: assignmentsRemoved, previousParticipantIds: previousParticipantIds };
}

/**
 * function called internally to cleanup event entries when individuals have been added to team events
 */
function updateTeamEventEntries(_a) {
    var e_1, _b;
    var _c, _d;
    var individualParticipantIds = _a.individualParticipantIds, groupingParticipantId = _a.groupingParticipantId, tournamentRecord = _a.tournamentRecord;
    var relevantEvents = (tournamentRecord.events || []).filter(function (event) {
        var _a;
        return (event === null || event === void 0 ? void 0 : event.eventType) === TEAM$2 &&
            ((_a = event === null || event === void 0 ? void 0 : event.entries) === null || _a === void 0 ? void 0 : _a.some(function (entry) { return entry.participantId === groupingParticipantId; }));
    });
    var filterEntry = function (entry) {
        return !individualParticipantIds.includes(entry.participantId);
    };
    try {
        for (var relevantEvents_1 = __values(relevantEvents), relevantEvents_1_1 = relevantEvents_1.next(); !relevantEvents_1_1.done; relevantEvents_1_1 = relevantEvents_1.next()) {
            var event_1 = relevantEvents_1_1.value;
            event_1.entries = (event_1.entries || []).filter(filterEntry);
            var flightProfile = getFlightProfile({ event: event_1 }).flightProfile;
            (_c = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _c === void 0 ? void 0 : _c.forEach(function (flight) {
                flight.drawEntries = (flight.drawEntries || []).filter(filterEntry);
            });
            (_d = event_1 === null || event_1 === void 0 ? void 0 : event_1.drawDefinitions) === null || _d === void 0 ? void 0 : _d.forEach(function (drawDefinition) {
                drawDefinition.entries = (drawDefinition.entries || []).filter(filterEntry);
            });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (relevantEvents_1_1 && !relevantEvents_1_1.done && (_b = relevantEvents_1.return)) _b.call(relevantEvents_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}

function addIndividualParticipantIds(_a) {
    var _b;
    var _c;
    var individualParticipantIds = _a.individualParticipantIds, groupingParticipantId = _a.groupingParticipantId, removeFromOtherTeams = _a.removeFromOtherTeams, tournamentRecord = _a.tournamentRecord;
    var stack = 'addIndividualParticipantIds';
    if (!tournamentRecord)
        return decorateResult({
            result: { error: MISSING_TOURNAMENT_RECORD },
            stack: stack,
        });
    if (!groupingParticipantId || !individualParticipantIds)
        return decorateResult({ result: { error: MISSING_VALUE }, stack: stack });
    var tournamentParticipants = (_c = tournamentRecord.participants) !== null && _c !== void 0 ? _c : [];
    var groupingParticipant = tournamentParticipants.find(function (participant) { return participant.participantId === groupingParticipantId; });
    if (!groupingParticipant)
        return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack: stack });
    if ((groupingParticipant === null || groupingParticipant === void 0 ? void 0 : groupingParticipant.participantType) &&
        ![TEAM$1, GROUP].includes(groupingParticipant.participantType)) {
        return decorateResult({
            context: { participantType: groupingParticipant.participantType },
            result: { error: INVALID_PARTICIPANT_TYPE },
            stack: stack,
        });
    }
    // integrity chck to ensure only individuals can be added to groupings
    var invalidParticipantIds = individualParticipantIds.filter(function (participantId) {
        var participant = tournamentParticipants.find(function (tournamentParticipant) {
            return tournamentParticipant.participantId === participantId;
        });
        return (participant === null || participant === void 0 ? void 0 : participant.participantType) !== INDIVIDUAL;
    });
    if (invalidParticipantIds.length)
        return decorateResult({
            result: { error: INVALID_PARTICIPANT_IDS, invalidParticipantIds: invalidParticipantIds },
            stack: stack,
        });
    if (!groupingParticipant.individualParticipantIds)
        groupingParticipant.individualParticipantIds = [];
    var existingIndividualParticipantIds = groupingParticipant.individualParticipantIds;
    var participantIdsToAdd = individualParticipantIds.filter(function (participantId) {
        var participantIsMember = existingIndividualParticipantIds.includes(participantId);
        return !participantIsMember;
    });
    if (participantIdsToAdd.length) {
        if (removeFromOtherTeams) {
            removeParticipantIdsFromAllTeams({
                individualParticipantIds: participantIdsToAdd,
                tournamentRecord: tournamentRecord,
            });
        }
        groupingParticipant.individualParticipantIds = (_b = groupingParticipant.individualParticipantIds).concat.apply(_b, __spreadArray([], __read(participantIdsToAdd), false));
    }
    var topics = getTopics().topics;
    if (topics.includes(MODIFY_PARTICIPANTS)) {
        var updatedParticipant = tournamentParticipants.find(function (_a) {
            var participantId = _a.participantId;
            return participantId === groupingParticipantId;
        });
        addNotice({
            topic: MODIFY_PARTICIPANTS,
            payload: { participants: [updatedParticipant] },
        });
    }
    updateTeamEventEntries({
        individualParticipantIds: individualParticipantIds,
        groupingParticipantId: groupingParticipantId,
        tournamentRecord: tournamentRecord,
    });
    return __assign({ groupingParticipant: makeDeepCopy(groupingParticipant, false, true), added: participantIdsToAdd.length }, SUCCESS);
}

function modifyParticipant(params) {
    var _a = params.updateParticipantName, updateParticipantName = _a === void 0 ? true : _a, groupingParticipantId = params.groupingParticipantId, removeFromOtherTeams = params.removeFromOtherTeams, tournamentRecord = params.tournamentRecord, pairOverride = params.pairOverride, participant = params.participant;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!participant)
        return { error: MISSING_PARTICIPANT };
    if (!participant.participantId)
        return addParticipant({ tournamentRecord: tournamentRecord, participant: participant });
    var existingParticipant = findTournamentParticipant({
        participantId: participant.participantId,
        tournamentRecord: tournamentRecord,
    }).participant;
    if (!existingParticipant)
        return addParticipant({ tournamentRecord: tournamentRecord, participant: participant });
    var participantRoleResponsibilties = participant.participantRoleResponsibilties, individualParticipantIds = participant.individualParticipantIds, participantOtherName = participant.participantOtherName, participantName = participant.participantName, participantRole = participant.participantRole, participantType = participant.participantType, onlineResources = participant.onlineResources, // TODO: validate onlineResources
    contacts = participant.contacts, // TODO: validate contacts
    person = participant.person;
    if (participantType &&
        existingParticipant.participantType !== participantType)
        return { error: CANNOT_MODIFY_PARTICIPANT_TYPE };
    var newValues = {};
    // validate participant attributes
    if (contacts)
        newValues.contacts = contacts;
    if (onlineResources)
        newValues.onlineResources = onlineResources;
    if (participantName && typeof participantName === 'string')
        newValues.participantName = participantName;
    if (participantOtherName && typeof participantOtherName === 'string')
        newValues.participantOtherName = participantOtherName;
    if (Array.isArray(individualParticipantIds)) {
        var individualParticipants = getParticipants({
            participantFilters: { participantTypes: [INDIVIDUAL] },
            tournamentRecord: tournamentRecord,
        }).participants;
        var allIndividualParticipantIds_1 = individualParticipants === null || individualParticipants === void 0 ? void 0 : individualParticipants.map(getParticipantId);
        if (allIndividualParticipantIds_1) {
            // check that all new individualParticipantIds exist and are { participantType: INDIVIDUAL }
            var updatedIndividualParticipantIds = individualParticipantIds.filter(function (participantId) {
                return typeof participantId === 'string' &&
                    allIndividualParticipantIds_1.includes(participantId);
            });
            if ([GROUP, TEAM].includes(participantType || existingParticipant.participantType) ||
                (participantType === PAIR &&
                    (updatedIndividualParticipantIds.length === 2 || pairOverride))) {
                newValues.individualParticipantIds = updatedIndividualParticipantIds;
            }
            // check whether to update PAIR participantName
            if (existingParticipant.participantType === participantTypes.PAIR &&
                updateParticipantName) {
                newValues.participantName = generatePairParticipantName$1({
                    individualParticipants: individualParticipants,
                    newValues: newValues,
                });
            }
        }
    }
    if (Object.keys(participantRoles).includes(participantRole))
        newValues.participantRole = participantRole;
    if (Object.keys(participantTypes).includes(participantType))
        newValues.participantType = participantType;
    if (Array.isArray(participantRoleResponsibilties))
        newValues.participantRoleResponsibilties = participantRoleResponsibilties;
    if (existingParticipant.participantType === participantTypes.INDIVIDUAL &&
        person) {
        updatePerson({
            updateParticipantName: updateParticipantName,
            existingParticipant: existingParticipant,
            newValues: newValues,
            person: person,
        });
    }
    Object.assign(existingParticipant, definedAttributes(newValues));
    if (groupingParticipantId) {
        addIndividualParticipantIds({
            individualParticipantIds: [existingParticipant.participantId],
            groupingParticipantId: groupingParticipantId,
            removeFromOtherTeams: removeFromOtherTeams,
            tournamentRecord: tournamentRecord,
        });
    }
    addNotice({
        topic: MODIFY_PARTICIPANTS,
        payload: {
            tournamentId: tournamentRecord.tournamentId,
            participants: [existingParticipant],
        },
    });
    return __assign({ participant: makeDeepCopy(existingParticipant) }, SUCCESS);
}
function generatePairParticipantName$1(_a) {
    var individualParticipants = _a.individualParticipants, newValues = _a.newValues;
    var individualParticipantIds = newValues.individualParticipantIds;
    var participantName = individualParticipants
        .filter(function (_a) {
        var participantId = _a.participantId;
        return individualParticipantIds.includes(participantId);
    })
        .map(function (_a) {
        var person = _a.person;
        return person === null || person === void 0 ? void 0 : person.standardFamilyName;
    })
        .filter(Boolean)
        .sort()
        .join('/');
    if (individualParticipantIds.length === 1)
        participantName += '/Unknown';
    return participantName;
}
function updatePerson(_a) {
    var updateParticipantName = _a.updateParticipantName, existingParticipant = _a.existingParticipant, newValues = _a.newValues, person = _a.person;
    var newPersonValues = {};
    var standardFamilyName = person.standardFamilyName, standardGivenName = person.standardGivenName, nationalityCode = person.nationalityCode, personId = person.personId, sex = person.sex;
    if (sex && Object.keys(genderConstants).includes(sex))
        newPersonValues.sex = sex;
    var personNameModified;
    if (personId && typeof personId === 'string') {
        newPersonValues.personId = personId;
    }
    if (nationalityCode &&
        typeof nationalityCode === 'string' &&
        (validNationalityCode(nationalityCode) || nationalityCode === '') // empty string to remove value
    ) {
        newPersonValues.nationalityCode = nationalityCode;
    }
    if (standardFamilyName &&
        typeof standardFamilyName === 'string' &&
        standardFamilyName.length > 1) {
        newPersonValues.standardFamilyName = standardFamilyName;
        personNameModified = true;
    }
    if (standardGivenName &&
        typeof standardGivenName === 'string' &&
        standardGivenName.length > 1) {
        newPersonValues.standardGivenName = standardGivenName;
        personNameModified = true;
    }
    if (personNameModified && updateParticipantName) {
        var participantName = "".concat(newPersonValues.standardGivenName, " ").concat(newPersonValues.standardFamilyName);
        newValues.participantName = participantName;
    }
    Object.assign(existingParticipant.person, newPersonValues);
}
function validNationalityCode(code) {
    return countries
        .flatMap(function (_a) {
        var iso = _a.iso, ioc = _a.ioc;
        return [iso, ioc];
    })
        .filter(Boolean)
        .includes(code);
}

function assignTieMatchUpParticipantId(params) {
    var e_1, _a;
    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    var matchUpContext = getTieMatchUpContext(params);
    if (matchUpContext.error)
        return matchUpContext;
    var stack = 'assignTieMatchUpParticipantId';
    var teamParticipantId = params.teamParticipantId;
    var tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, participantId = params.participantId, event = params.event;
    if (!participantId) {
        return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack: stack });
    }
    if (params.sideNumber && ![1, 2].includes(params.sideNumber)) {
        return decorateResult({ result: { error: INVALID_SIDE_NUMBER }, stack: stack });
    }
    var inContextDualMatchUp = matchUpContext.inContextDualMatchUp, inContextTieMatchUp = matchUpContext.inContextTieMatchUp, relevantAssignments = matchUpContext.relevantAssignments, collectionPosition = matchUpContext.collectionPosition, teamParticipants = matchUpContext.teamParticipants, collectionId = matchUpContext.collectionId, matchUpType = matchUpContext.matchUpType, dualMatchUp = matchUpContext.dualMatchUp, tieFormat = matchUpContext.tieFormat;
    var allTieIndividualParticipantIds = (_b = inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.sides) === null || _b === void 0 ? void 0 : _b.flatMap(function (side) { var _a, _b; return ((_a = side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipantIds) || ((_b = side.participant) === null || _b === void 0 ? void 0 : _b.participantId) || []; });
    if (allTieIndividualParticipantIds === null || allTieIndividualParticipantIds === void 0 ? void 0 : allTieIndividualParticipantIds.includes(participantId)) {
        return decorateResult({ result: __assign({}, SUCCESS), stack: stack });
    }
    teamParticipantId =
        teamParticipantId !== null && teamParticipantId !== void 0 ? teamParticipantId : (params.sideNumber
            ? (_d = (_c = inContextDualMatchUp === null || inContextDualMatchUp === void 0 ? void 0 : inContextDualMatchUp.sides) === null || _c === void 0 ? void 0 : _c.find(function (side) { return side.sideNumber === params.sideNumber; })) === null || _d === void 0 ? void 0 : _d.participantId
            : undefined);
    var participantToAssign = (_f = (_e = getParticipants({
        participantFilters: { participantIds: [participantId] },
        tournamentRecord: tournamentRecord,
    })) === null || _e === void 0 ? void 0 : _e.participants) === null || _f === void 0 ? void 0 : _f[0];
    if (!participantToAssign) {
        return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack: stack });
    }
    var appliedPolicies = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        event: event,
    }).appliedPolicies;
    var matchUpActionsPolicy = (_j = (_h = (_g = params.policyDefinitions) === null || _g === void 0 ? void 0 : _g[POLICY_TYPE_MATCHUP_ACTIONS]) !== null && _h !== void 0 ? _h : appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_MATCHUP_ACTIONS]) !== null && _j !== void 0 ? _j : POLICY_MATCHUP_ACTIONS_DEFAULT[POLICY_TYPE_MATCHUP_ACTIONS];
    var genderEnforced = ((_k = params.enforceGender) !== null && _k !== void 0 ? _k : (_l = matchUpActionsPolicy === null || matchUpActionsPolicy === void 0 ? void 0 : matchUpActionsPolicy.participants) === null || _l === void 0 ? void 0 : _l.enforceGender) !== false;
    if (genderEnforced &&
        [MALE, FEMALE].includes(inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.gender) &&
        (inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.gender) !== ((_m = participantToAssign.person) === null || _m === void 0 ? void 0 : _m.sex)) {
        return { error: INVALID_PARTICIPANT, info: 'Gender mismatch' };
    }
    var individualParticipantIds = participantToAssign.individualParticipantIds, participantType = participantToAssign.participantType;
    // check that the participantToAssign is the correct participantType for tieMatchUp.matchUpType
    if (matchUpType === SINGLES && participantType !== INDIVIDUAL) {
        return { error: INVALID_PARTICIPANT_TYPE };
    }
    var relevantParticipantIds = participantType === INDIVIDUAL ? [participantId] : individualParticipantIds;
    var participantTeam = (teamParticipantId && (teamParticipants === null || teamParticipants === void 0 ? void 0 : teamParticipants.find(function (_a) {
        var participantId = _a.participantId;
        return participantId === teamParticipantId;
    }))) ||
        (teamParticipants === null || teamParticipants === void 0 ? void 0 : teamParticipants.find(function (_a) {
            var individualParticipantIds = _a.individualParticipantIds;
            return overlap(relevantParticipantIds, individualParticipantIds);
        }));
    if (!participantTeam)
        return { error: TEAM_NOT_FOUND };
    if (!teamParticipantId)
        teamParticipantId = participantTeam.participantId;
    if (!teamParticipantId)
        return { error: PARTICIPANT_NOT_FOUND };
    var teamAssignment = relevantAssignments === null || relevantAssignments === void 0 ? void 0 : relevantAssignments.find(function (assignment) { return assignment.participantId === (participantTeam === null || participantTeam === void 0 ? void 0 : participantTeam.participantId); });
    var teamDrawPosition = teamAssignment === null || teamAssignment === void 0 ? void 0 : teamAssignment.drawPosition;
    var dualTeamSideNumber = (_p = (_o = dualMatchUp === null || dualMatchUp === void 0 ? void 0 : dualMatchUp.sides) === null || _o === void 0 ? void 0 : _o.find(function (side) { return side.participantId === teamParticipantId; })) === null || _p === void 0 ? void 0 : _p.sideNumber;
    var teamSideNumber = (_r = (_q = inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.sides) === null || _q === void 0 ? void 0 : _q.find(function (side) { return teamDrawPosition && side.drawPosition === teamDrawPosition; })) === null || _r === void 0 ? void 0 : _r.sideNumber;
    var sideNumber = (_s = dualTeamSideNumber !== null && dualTeamSideNumber !== void 0 ? dualTeamSideNumber : teamSideNumber) !== null && _s !== void 0 ? _s : params.sideNumber;
    if (!tieFormat) {
        return { error: MISSING_TIE_FORMAT };
    }
    var collectionDefinition = (_t = tieFormat.collectionDefinitions) === null || _t === void 0 ? void 0 : _t.find(function (collectionDefinition) { return collectionDefinition.collectionId === collectionId; });
    if (!collectionDefinition)
        return { error: MISSING_COLLECTION_DEFINITION };
    ensureSideLineUps({
        tournamentId: tournamentRecord.tournamentId,
        eventId: event.eventId,
        inContextDualMatchUp: inContextDualMatchUp,
        drawDefinition: drawDefinition,
        dualMatchUp: dualMatchUp,
    });
    var dualMatchUpSide = (_u = dualMatchUp === null || dualMatchUp === void 0 ? void 0 : dualMatchUp.sides) === null || _u === void 0 ? void 0 : _u.find(function (side) { return side.sideNumber === sideNumber; });
    var tieMatchUpSide = (_v = inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.sides) === null || _v === void 0 ? void 0 : _v.find(function (side) { return side.sideNumber === sideNumber; });
    var lineUp = (_w = dualMatchUpSide === null || dualMatchUpSide === void 0 ? void 0 : dualMatchUpSide.lineUp) !== null && _w !== void 0 ? _w : (_x = getTeamLineUp({
        participantId: teamParticipantId,
        drawDefinition: drawDefinition,
    })) === null || _x === void 0 ? void 0 : _x.lineUp;
    var targetAssignments = lineUp === null || lineUp === void 0 ? void 0 : lineUp.filter(function (participantAssignment) {
        var _a;
        return (_a = participantAssignment.collectionAssignments) === null || _a === void 0 ? void 0 : _a.find(function (assignment) {
            return assignment.collectionPosition === collectionPosition &&
                assignment.collectionId === collectionId &&
                !assignment.previousParticipantId;
        });
    });
    var assignedParticipantIds = targetAssignments === null || targetAssignments === void 0 ? void 0 : targetAssignments.map(function (assignment) { return assignment === null || assignment === void 0 ? void 0 : assignment.participantId; });
    // participantIds is an array of ids for individual team participants whose assignments should be modified
    var participantIds = ((assignedParticipantIds === null || assignedParticipantIds === void 0 ? void 0 : assignedParticipantIds.length) > 1 && assignedParticipantIds) ||
        (participantType === PAIR ? participantToAssign.individualParticipantIds : [participantId]);
    // first filter out any collectionAssignment with equivalent collectionId/collectionPosition/participantId
    var removeResult = removeCollectionAssignments({
        collectionPosition: collectionPosition,
        teamParticipantId: teamParticipantId,
        dualMatchUpSide: dualMatchUpSide,
        drawDefinition: drawDefinition,
        participantIds: participantIds,
        collectionId: collectionId,
    });
    if (removeResult.error)
        return decorateResult({ result: removeResult, stack: stack });
    var modifiedLineUp = removeResult.modifiedLineUp;
    var deletedParticipantId;
    if (matchUpType === DOUBLES) {
        if (participantType !== PAIR) {
            var result = updateLineUp({
                collectionPosition: collectionPosition,
                teamParticipantId: teamParticipantId,
                drawDefinition: drawDefinition,
                modifiedLineUp: modifiedLineUp,
                participantId: participantId,
                collectionId: collectionId,
                tieFormat: tieFormat,
            });
            if (result === null || result === void 0 ? void 0 : result.error)
                return decorateResult({ result: result, stack: stack });
            result = addParticipantId2Pair({
                side: tieMatchUpSide,
            });
            if (result.error)
                return result;
            deletedParticipantId = result.deletedParticipantId;
            if (dualMatchUpSide)
                dualMatchUpSide.lineUp = modifiedLineUp;
            if (dualMatchUp) {
                modifyMatchUpNotice({
                    tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                    matchUp: dualMatchUp,
                    context: stack,
                    drawDefinition: drawDefinition,
                });
            }
        }
        else if (participantType === PAIR) {
            try {
                for (var participantIds_1 = __values(participantIds), participantIds_1_1 = participantIds_1.next(); !participantIds_1_1.done; participantIds_1_1 = participantIds_1.next()) {
                    var participantId_1 = participantIds_1_1.value;
                    updateLineUp({
                        collectionPosition: collectionPosition,
                        teamParticipantId: teamParticipantId,
                        drawDefinition: drawDefinition,
                        modifiedLineUp: modifiedLineUp,
                        participantId: participantId_1,
                        collectionId: collectionId,
                        tieFormat: tieFormat,
                    });
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (participantIds_1_1 && !participantIds_1_1.done && (_a = participantIds_1.return)) _a.call(participantIds_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
    else {
        var result = updateLineUp({
            collectionPosition: collectionPosition,
            teamParticipantId: teamParticipantId,
            drawDefinition: drawDefinition,
            modifiedLineUp: modifiedLineUp,
            participantId: participantId,
            collectionId: collectionId,
            tieFormat: tieFormat,
        });
        if (result === null || result === void 0 ? void 0 : result.error)
            return result;
    }
    if (dualMatchUpSide)
        dualMatchUpSide.lineUp = modifiedLineUp;
    if (dualMatchUp)
        modifyMatchUpNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            matchUp: dualMatchUp,
            context: stack,
            drawDefinition: drawDefinition,
        });
    if (deletedParticipantId) {
        var error = deleteParticipants({
            participantIds: [deletedParticipantId],
            tournamentRecord: tournamentRecord,
        }).error;
        if (error)
            console.log('cleanup');
    }
    return __assign(__assign({}, SUCCESS), { modifiedLineUp: modifiedLineUp });
    function addParticipantId2Pair(_a) {
        var side = _a.side;
        var deletedParticipantId;
        if (!side.participant) {
            var newPairParticipant = {
                individualParticipantIds: [participantId],
                participantRole: COMPETITOR,
                participantType: PAIR,
            };
            var result = addParticipant({
                participant: newPairParticipant,
                pairOverride: true,
                tournamentRecord: tournamentRecord,
            });
            if (result.error)
                return result;
        }
        else {
            var individualParticipantIds_1 = side.participant.individualParticipantIds || [];
            var sideParticipantsCount = individualParticipantIds_1.filter(Boolean).length;
            if (sideParticipantsCount === 1) {
                var participant = getPairedParticipant({
                    participantIds: individualParticipantIds_1,
                    tournamentRecord: tournamentRecord,
                }).participant;
                individualParticipantIds_1.push(participantId);
                var existingParticipant = getPairedParticipant({
                    participantIds: individualParticipantIds_1,
                    tournamentRecord: tournamentRecord,
                }).participant;
                if (!existingParticipant && participant) {
                    participant.individualParticipantIds = individualParticipantIds_1;
                    var result = modifyParticipant({
                        pairOverride: true,
                        tournamentRecord: tournamentRecord,
                        participant: participant,
                    });
                    if (result.error)
                        return result;
                }
                else {
                    // check if there is a pairParticipant that includes both individualParticipantIds
                    // if there is, use that and delete the PAIR participant with only one [individualParticipantId]
                    deletedParticipantId = participant === null || participant === void 0 ? void 0 : participant.participantId;
                }
            }
        }
        return __assign(__assign({}, SUCCESS), { deletedParticipantId: deletedParticipantId });
    }
}
function updateLineUp(_a) {
    var _b, _c;
    var collectionPosition = _a.collectionPosition, teamParticipantId = _a.teamParticipantId, drawDefinition = _a.drawDefinition, modifiedLineUp = _a.modifiedLineUp, participantId = _a.participantId, collectionId = _a.collectionId, tieFormat = _a.tieFormat;
    var templateTeamLineUp = (_b = getTeamLineUp({
        participantId: teamParticipantId,
        drawDefinition: drawDefinition,
    })) === null || _b === void 0 ? void 0 : _b.lineUp;
    var participantCompetitiorProfile = (_c = (modifiedLineUp || templateTeamLineUp)) === null || _c === void 0 ? void 0 : _c.find(function (teamCompetitor) { return (teamCompetitor === null || teamCompetitor === void 0 ? void 0 : teamCompetitor.participantId) === participantId; });
    var newAssignment = { collectionId: collectionId, collectionPosition: collectionPosition };
    if (participantCompetitiorProfile) {
        participantCompetitiorProfile.collectionAssignments.push(newAssignment);
    }
    else {
        var teamCompetitor = {
            collectionAssignments: [newAssignment],
            participantId: participantId,
        };
        modifiedLineUp.push(teamCompetitor);
    }
    return updateTeamLineUp({
        participantId: teamParticipantId,
        lineUp: modifiedLineUp,
        drawDefinition: drawDefinition,
        tieFormat: tieFormat,
    });
}

function removeTieMatchUpParticipantId(params) {
    var e_1, _a;
    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    var tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, participantId = params.participantId, event = params.event;
    var stack = 'removeTieMatchUpParticiapantId';
    if (!participantId)
        return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack: stack });
    var matchUpContext = getTieMatchUpContext(params);
    if (matchUpContext.error)
        return matchUpContext;
    var appliedPolicies = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        event: event,
    }).appliedPolicies;
    var matchUpActionsPolicy = (_d = (_c = (_b = params.policyDefinitions) === null || _b === void 0 ? void 0 : _b[POLICY_TYPE_MATCHUP_ACTIONS]) !== null && _c !== void 0 ? _c : appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_MATCHUP_ACTIONS]) !== null && _d !== void 0 ? _d : POLICY_MATCHUP_ACTIONS_DEFAULT[POLICY_TYPE_MATCHUP_ACTIONS];
    var substitutionProcessCodes = (_e = matchUpActionsPolicy === null || matchUpActionsPolicy === void 0 ? void 0 : matchUpActionsPolicy.processCodes) === null || _e === void 0 ? void 0 : _e.substitution;
    var inContextDualMatchUp = matchUpContext.inContextDualMatchUp, inContextTieMatchUp = matchUpContext.inContextTieMatchUp, relevantAssignments = matchUpContext.relevantAssignments, collectionPosition = matchUpContext.collectionPosition, teamParticipants = matchUpContext.teamParticipants, collectionId = matchUpContext.collectionId, matchUpType = matchUpContext.matchUpType, dualMatchUp = matchUpContext.dualMatchUp, tieMatchUp = matchUpContext.tieMatchUp, tieFormat = matchUpContext.tieFormat;
    if (!dualMatchUp)
        return decorateResult({ result: { error: MISSING_MATCHUP }, stack: stack });
    var side = (_f = inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.sides) === null || _f === void 0 ? void 0 : _f.find(function (side) {
        var _a, _b, _c;
        return ((_a = side.participant) === null || _a === void 0 ? void 0 : _a.participantId) === participantId ||
            ((_c = (_b = side.participant) === null || _b === void 0 ? void 0 : _b.individualParticipantIds) === null || _c === void 0 ? void 0 : _c.includes(participantId));
    });
    if (!side)
        return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack: stack });
    if (!((_g = side.substitutions) === null || _g === void 0 ? void 0 : _g.length) &&
        (checkScoreHasValue({ score: inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.score }) || (inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.winningSide)))
        return decorateResult({ result: { error: EXISTING_OUTCOME }, stack: stack });
    var teamParticipantId = (_j = (_h = inContextDualMatchUp === null || inContextDualMatchUp === void 0 ? void 0 : inContextDualMatchUp.sides) === null || _h === void 0 ? void 0 : _h.find(function (_a) {
        var sideNumber = _a.sideNumber;
        return sideNumber === side.sideNumber;
    })) === null || _j === void 0 ? void 0 : _j.participantId;
    if (!teamParticipantId)
        return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack: stack });
    var participantToRemove = (_l = (_k = getParticipants({
        participantFilters: { participantIds: [participantId] },
        tournamentRecord: tournamentRecord,
    })) === null || _k === void 0 ? void 0 : _k.participants) === null || _l === void 0 ? void 0 : _l[0];
    if (!participantToRemove) {
        return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack: stack });
    }
    if (matchUpType === SINGLES && participantToRemove.participantType === PAIR) {
        return decorateResult({ result: { error: INVALID_PARTICIPANT }, stack: stack });
    }
    var participantIds = participantToRemove.participantType === INDIVIDUAL ? [participantId] : participantToRemove.individualParticipantIds;
    ensureSideLineUps({
        tournamentId: tournamentRecord.tournamentId,
        eventId: event.eventId,
        inContextDualMatchUp: inContextDualMatchUp,
        drawDefinition: drawDefinition,
        dualMatchUp: dualMatchUp,
    });
    var dualMatchUpSide = (_m = dualMatchUp.sides) === null || _m === void 0 ? void 0 : _m.find(function (_a) {
        var sideNumber = _a.sideNumber;
        return sideNumber === side.sideNumber;
    });
    if (!dualMatchUpSide && (((_o = dualMatchUp.sides) === null || _o === void 0 ? void 0 : _o.filter(function (_a) {
        var lineUp = _a.lineUp;
        return !lineUp;
    }).length) || 0) < 2) {
        var drawPositionMap_1 = teamParticipants === null || teamParticipants === void 0 ? void 0 : teamParticipants.map(function (_a) {
            var _b;
            var teamParticipantId = _a.participantId;
            return ({
                drawPosition: (_b = relevantAssignments === null || relevantAssignments === void 0 ? void 0 : relevantAssignments.find(function (assignment) { return assignment.participantId === teamParticipantId; })) === null || _b === void 0 ? void 0 : _b.drawPosition,
                teamParticipantId: teamParticipantId,
            });
        });
        dualMatchUpSide = (_p = dualMatchUp.sides) === null || _p === void 0 ? void 0 : _p.find(function (side) {
            var _a;
            return ((_a = drawPositionMap_1 === null || drawPositionMap_1 === void 0 ? void 0 : drawPositionMap_1.find(function (_a) {
                var drawPosition = _a.drawPosition;
                return drawPosition === side.drawPosition;
            })) === null || _a === void 0 ? void 0 : _a.teamParticipantId) ===
                teamParticipantId;
        });
    }
    if (!dualMatchUpSide) {
        return decorateResult({
            result: { error: PARTICIPANT_NOT_FOUND, context: { participantId: participantId } },
        });
    }
    var _0 = removeCollectionAssignments({
        collectionPosition: collectionPosition,
        teamParticipantId: teamParticipantId,
        dualMatchUpSide: dualMatchUpSide,
        participantIds: participantIds,
        drawDefinition: drawDefinition,
        collectionId: collectionId,
    }), modifiedLineUp = _0.modifiedLineUp, previousParticipantIds = _0.previousParticipantIds;
    dualMatchUpSide.lineUp = modifiedLineUp;
    teamParticipantId &&
        tieFormat &&
        updateTeamLineUp({
            participantId: teamParticipantId,
            lineUp: modifiedLineUp,
            drawDefinition: drawDefinition,
            tieFormat: tieFormat,
        });
    // if an INDIVIDUAL participant is being removed from a DOUBLES matchUp
    // ...then the PAIR participant may need to be modified
    if (matchUpType === DOUBLES && participantToRemove.participantType === INDIVIDUAL) {
        var tieMatchUpSide = (_q = inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.sides) === null || _q === void 0 ? void 0 : _q.find(function (side) { return side.sideNumber === (dualMatchUpSide === null || dualMatchUpSide === void 0 ? void 0 : dualMatchUpSide.sideNumber); });
        var pairParticipantId = (tieMatchUpSide !== null && tieMatchUpSide !== void 0 ? tieMatchUpSide : {}).participantId;
        var pairParticipant = pairParticipantId &&
            ((_s = (_r = getParticipants({
                participantFilters: { participantIds: [pairParticipantId] },
                tournamentRecord: tournamentRecord,
                withDraws: true,
            })) === null || _r === void 0 ? void 0 : _r.participants) === null || _s === void 0 ? void 0 : _s[0]);
        if (pairParticipant) {
            var individualParticipantIds = (_u = (_t = pairParticipant === null || pairParticipant === void 0 ? void 0 : pairParticipant.individualParticipantIds) === null || _t === void 0 ? void 0 : _t.filter(function (currentId) { return currentId !== participantId; })) !== null && _u !== void 0 ? _u : [];
            if (previousParticipantIds)
                individualParticipantIds.push.apply(individualParticipantIds, __spreadArray([], __read(previousParticipantIds), false));
            if (individualParticipantIds.length > 2) {
                return decorateResult({
                    result: { error: INVALID_PARTICIPANT_IDS },
                    stack: stack,
                });
            }
            // don't modify pair participant that is part of other events/draws
            if (!((_v = pairParticipant.draws) === null || _v === void 0 ? void 0 : _v.length)) {
                if (individualParticipantIds.length) {
                    pairParticipant.individualParticipantIds = individualParticipantIds;
                    var result = modifyParticipant({
                        participant: pairParticipant,
                        pairOverride: true,
                        tournamentRecord: tournamentRecord,
                    });
                    if (result.error)
                        return decorateResult({ result: result, stack: stack });
                }
                else {
                    var result = deleteParticipants({
                        participantIds: [pairParticipantId],
                        tournamentRecord: tournamentRecord,
                    });
                    if (result.error)
                        console.log('cleanup', { result: result });
                }
            }
            else if (individualParticipantIds.length === 1) {
                var existingParticipant = getPairedParticipant({
                    participantIds: individualParticipantIds,
                    tournamentRecord: tournamentRecord,
                }).participant;
                if (!existingParticipant) {
                    var newPairParticipant = {
                        participantRole: COMPETITOR,
                        individualParticipantIds: individualParticipantIds,
                        participantType: PAIR,
                    };
                    var result = addParticipant({
                        participant: newPairParticipant,
                        pairOverride: true,
                        tournamentRecord: tournamentRecord,
                    });
                    if (result.error)
                        return decorateResult({ result: result, stack: stack });
                }
            }
        }
        else {
            return decorateResult({
                result: { error: PARTICIPANT_NOT_FOUND },
                stack: stack,
            });
        }
    }
    // if there was only one subsitution on target side and there are no substiutions on other side
    if (((_w = side.substitutions) === null || _w === void 0 ? void 0 : _w.length) === 1) {
        var otherSide = (_x = inContextTieMatchUp === null || inContextTieMatchUp === void 0 ? void 0 : inContextTieMatchUp.sides) === null || _x === void 0 ? void 0 : _x.find(function (s) { return s.sideNumber !== side.sideNumber; });
        if (!((_y = otherSide === null || otherSide === void 0 ? void 0 : otherSide.substitutions) === null || _y === void 0 ? void 0 : _y.length) && ((_z = tieMatchUp === null || tieMatchUp === void 0 ? void 0 : tieMatchUp.processCodes) === null || _z === void 0 ? void 0 : _z.length)) {
            try {
                // remove processCode(s)
                for (var _1 = __values(substitutionProcessCodes || []), _2 = _1.next(); !_2.done; _2 = _1.next()) {
                    var substitutionProcessCode = _2.value;
                    var codeIndex = tieMatchUp.processCodes.lastIndexOf(substitutionProcessCode);
                    // remove only one instance of substitutionProcessCode
                    tieMatchUp.processCodes.splice(codeIndex, 1);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_2 && !_2.done && (_a = _1.return)) _a.call(_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            modifyMatchUpNotice({
                tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                matchUp: tieMatchUp,
                context: stack,
                drawDefinition: drawDefinition,
            });
        }
    }
    modifyMatchUpNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        matchUp: dualMatchUp,
        context: stack,
        drawDefinition: drawDefinition,
    });
    return __assign(__assign({}, SUCCESS), { modifiedLineUp: modifiedLineUp });
}

function removeMatchUpSideParticipant(_a) {
    var _b, _c;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, sideNumber = _a.sideNumber, matchUpId = _a.matchUpId, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    if (!sideNumber)
        return { error: MISSING_VALUE };
    if (![1, 2].includes(sideNumber))
        return { error: INVALID_VALUES, sideNumber: sideNumber };
    var _d = findDrawMatchUp({
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
        event: event,
    }), matchUp = _d.matchUp, structure = _d.structure;
    if (!matchUp)
        return { error: MATCHUP_NOT_FOUND };
    var isAdHoc = !(structure === null || structure === void 0 ? void 0 : structure.structures) &&
        !(drawDefinition.drawType && drawDefinition.drawType !== AD_HOC) &&
        !((_b = structure === null || structure === void 0 ? void 0 : structure.matchUps) === null || _b === void 0 ? void 0 : _b.find(function (_a) {
            var roundPosition = _a.roundPosition;
            return !!roundPosition;
        }));
    if (!isAdHoc)
        return { error: INVALID_DRAW_TYPE };
    (_c = matchUp.sides) === null || _c === void 0 ? void 0 : _c.forEach(function (side) {
        if (side.sideNumber === sideNumber)
            delete side.participantId;
    });
    modifyMatchUpNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        context: 'assignSideParticipant',
        drawDefinition: drawDefinition,
        matchUp: matchUp,
    });
    return __assign({}, SUCCESS);
}

function validateCollectionValueProfiles(_a) {
    var e_1, _b;
    var collectionValueProfiles = _a.collectionValueProfiles, matchUpCount = _a.matchUpCount;
    var errors = [];
    if (!Array.isArray(collectionValueProfiles)) {
        errors.push("collectionValueProfiles is not an array: ".concat(collectionValueProfiles));
        return { errors: errors };
    }
    if (collectionValueProfiles.length &&
        collectionValueProfiles.length !== matchUpCount) {
        errors.push("collectionValueProfiles do not align with matchUpsCount");
        return { errors: errors };
    }
    try {
        for (var collectionValueProfiles_1 = __values(collectionValueProfiles), collectionValueProfiles_1_1 = collectionValueProfiles_1.next(); !collectionValueProfiles_1_1.done; collectionValueProfiles_1_1 = collectionValueProfiles_1.next()) {
            var valueProfile = collectionValueProfiles_1_1.value;
            if (typeof valueProfile !== 'object') {
                errors.push("valueProfile is not type object: ".concat(valueProfile));
                return { errors: errors };
            }
            var matchUpValue = valueProfile.matchUpValue, collectionPosition = valueProfile.collectionPosition;
            if (typeof matchUpValue !== 'number' ||
                typeof collectionPosition !== 'number' ||
                collectionPosition > matchUpCount ||
                collectionPosition < 1) {
                errors.push("Invalid value profile: value and collectionPosition must be numeric. collectionPosition cannot be greater than matchUpCount");
                return { errors: errors };
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (collectionValueProfiles_1_1 && !collectionValueProfiles_1_1.done && (_b = collectionValueProfiles_1.return)) _b.call(collectionValueProfiles_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var collectionPositions = collectionValueProfiles.map(function (valueProfile) { return valueProfile.collectionPosition; });
    if (collectionPositions.length !== unique(collectionPositions).length) {
        errors.push('collectionPositions are not unique');
        return { errors: errors };
    }
    return __assign({}, SUCCESS);
}

function copyTieFormat(tieFormat) {
    if (!tieFormat)
        return undefined;
    return makeDeepCopy(tieFormat, false, true);
}

function getGroupValueGroups(_a) {
    var _b = _a.collectionGroups, collectionGroups = _b === void 0 ? [] : _b;
    // set up to handle groupValue
    var groupValueGroups = Object.assign.apply(Object, __spreadArray([{}], __read(collectionGroups
        .filter(function (group) {
        return isConvertableInteger(group === null || group === void 0 ? void 0 : group.groupValue) && (group === null || group === void 0 ? void 0 : group.groupNumber);
    })
        .map(function (group) {
        var _a;
        return (_a = {},
            _a[group.groupNumber] = __assign(__assign({}, group), { allGroupMatchUpsCompleted: true, matchUpsCount: 0, sideWins: [0, 0], values: [0, 0] }),
            _a);
    })), false));
    // must be coerced to numbers
    var groupValueNumbers = Object.keys(groupValueGroups).map(function (num) {
        return ensureInt(num);
    });
    return { groupValueGroups: groupValueGroups, groupValueNumbers: groupValueNumbers };
}

function calculateWinCriteria(_a) {
    var e_1, _b, e_2, _c, e_3, _d;
    var _e;
    var _f = _a.collectionDefinitions, collectionDefinitions = _f === void 0 ? [] : _f, _g = _a.collectionGroups, collectionGroups = _g === void 0 ? [] : _g;
    var valueTotal = 0;
    var groupValueNumbers = getGroupValueGroups({ collectionGroups: collectionGroups }).groupValueNumbers;
    var aggregateValueImperative;
    try {
        for (var _h = __values(collectionDefinitions || []), _j = _h.next(); !_j.done; _j = _h.next()) {
            var collectionDefinition = _j.value;
            var collectionValueProfiles = collectionDefinition.collectionValueProfiles, collectionGroupNumber = collectionDefinition.collectionGroupNumber, collectionValue = collectionDefinition.collectionValue, matchUpCount = collectionDefinition.matchUpCount, matchUpValue = collectionDefinition.matchUpValue, scoreValue = collectionDefinition.scoreValue, setValue = collectionDefinition.setValue;
            var belongsToValueGroup = collectionGroupNumber &&
                groupValueNumbers.includes(collectionGroupNumber);
            if (isConvertableInteger(setValue || scoreValue)) {
                // because setValues and scoreValues are unpredictable,
                // any collectionDefintion that has either of these two values without a collectionValue forces the tieFormat to aggregateValue
                aggregateValueImperative = true;
            }
            else if (belongsToValueGroup) {
                continue;
            }
            else if (typeof collectionValue === 'number' &&
                isConvertableInteger(collectionValue)) {
                valueTotal += collectionValue;
            }
            else if (collectionValueProfiles === null || collectionValueProfiles === void 0 ? void 0 : collectionValueProfiles.length) {
                try {
                    for (var collectionValueProfiles_1 = (e_2 = void 0, __values(collectionValueProfiles)), collectionValueProfiles_1_1 = collectionValueProfiles_1.next(); !collectionValueProfiles_1_1.done; collectionValueProfiles_1_1 = collectionValueProfiles_1.next()) {
                        var collectionValueProfile = collectionValueProfiles_1_1.value;
                        valueTotal += collectionValueProfile.matchUpValue;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (collectionValueProfiles_1_1 && !collectionValueProfiles_1_1.done && (_c = collectionValueProfiles_1.return)) _c.call(collectionValueProfiles_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            else if (typeof matchUpValue === 'number' &&
                isConvertableInteger(matchUpValue)) {
                valueTotal += (matchUpCount !== null && matchUpCount !== void 0 ? matchUpCount : 0) * matchUpValue;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var collectionGroups_1 = __values(collectionGroups), collectionGroups_1_1 = collectionGroups_1.next(); !collectionGroups_1_1.done; collectionGroups_1_1 = collectionGroups_1.next()) {
            var collectionGroup = collectionGroups_1_1.value;
            valueTotal += (_e = collectionGroup.groupValue) !== null && _e !== void 0 ? _e : 0;
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (collectionGroups_1_1 && !collectionGroups_1_1.done && (_d = collectionGroups_1.return)) _d.call(collectionGroups_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    if (aggregateValueImperative || !valueTotal)
        return __assign({ aggregateValue: true }, SUCCESS);
    var valueGoal = Math.floor(valueTotal / 2) + 1;
    return __assign({ valueGoal: valueGoal }, SUCCESS);
}

function getTieFormat$1(_a) {
    var _b, _c, _d;
    var drawDefinition = _a.drawDefinition, structureId = _a.structureId, matchUpId = _a.matchUpId, structure = _a.structure, matchUp = _a.matchUp, eventId = _a.eventId, // optional - if an eventId is present only return tieFormat for event
    event = _a.event;
    var stack = 'getTieFormat';
    var tieFormat;
    structureId = (_b = structure === null || structure === void 0 ? void 0 : structure.structureId) !== null && _b !== void 0 ? _b : structureId;
    matchUpId = (_c = matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpId) !== null && _c !== void 0 ? _c : matchUpId;
    if ((matchUpId || structureId) && !drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (eventId && event) {
        tieFormat = getObjectTieFormat(event);
    }
    else if (matchUpId) {
        // if matchUpId is present, structure and drawDefinition are always required
        if (drawDefinition && (!matchUp || !structure)) {
            var result = findDrawMatchUp({
                drawDefinition: drawDefinition,
                matchUpId: matchUpId,
            });
            if (result.error)
                return result;
            if (((_d = result.matchUp) === null || _d === void 0 ? void 0 : _d.matchUpType) !== TEAM_MATCHUP) {
                return decorateResult({ result: { error: INVALID_MATCHUP }, stack: stack });
            }
            if (!structure)
                structure = result.structure;
            if (!matchUp)
                matchUp = result.matchUp;
        }
        tieFormat =
            getItemTieFormat({
                item: matchUp,
                drawDefinition: drawDefinition,
                structure: structure,
                event: event,
            }) ||
                getItemTieFormat({
                    item: structure,
                    drawDefinition: drawDefinition,
                    structure: structure,
                    event: event,
                }) ||
                getObjectTieFormat(drawDefinition) ||
                getObjectTieFormat(event);
    }
    else if (drawDefinition && structureId) {
        if (!structure) {
            var result = findStructure({ drawDefinition: drawDefinition, structureId: structureId });
            if (result.error)
                return result;
            structure = result === null || result === void 0 ? void 0 : result.structure;
        }
        tieFormat =
            getItemTieFormat({
                item: structure,
                drawDefinition: drawDefinition,
                structure: structure,
                event: event,
            }) ||
                getObjectTieFormat(drawDefinition) ||
                getObjectTieFormat(event);
    }
    else {
        tieFormat = getObjectTieFormat(drawDefinition) || getObjectTieFormat(event);
    }
    if (!tieFormat)
        return decorateResult({ result: { error: MISSING_TIE_FORMAT }, stack: stack });
    return __assign(__assign({}, SUCCESS), { structure: structure, tieFormat: tieFormat, matchUp: matchUp });
}

function stringify(matchUpFormatObject, preserveRedundant) {
    if (((matchUpFormatObject === null || matchUpFormatObject === void 0 ? void 0 : matchUpFormatObject.bestOf) || (matchUpFormatObject === null || matchUpFormatObject === void 0 ? void 0 : matchUpFormatObject.exactly)) &&
        (matchUpFormatObject === null || matchUpFormatObject === void 0 ? void 0 : matchUpFormatObject.setFormat)) {
        return getSetFormat(matchUpFormatObject, preserveRedundant);
    }
    return undefined;
}
function getNumber(formatstring) {
    return !isNaN(Number(formatstring)) && Number(formatstring);
}
function timedSetFormat(matchUpFormatObject) {
    var value = "T".concat(matchUpFormatObject.minutes);
    if (matchUpFormatObject.based)
        value += matchUpFormatObject.based;
    if (matchUpFormatObject.modifier)
        value += "@".concat(matchUpFormatObject.modifier);
    return value;
}
function getSetFormat(matchUpFormatObject, preserveRedundant) {
    var _a;
    var bestOfValue = getNumber(matchUpFormatObject.bestOf) || undefined;
    var exactly = getNumber(matchUpFormatObject.exactly) || undefined;
    var setLimit = bestOfValue || exactly;
    if (((_a = matchUpFormatObject.setFormat) === null || _a === void 0 ? void 0 : _a.timed) &&
        matchUpFormatObject.simplified &&
        setLimit === 1) {
        return timedSetFormat(matchUpFormatObject.setFormat);
    }
    var setLimitCode = (setLimit && "".concat(SET).concat(setLimit)) || '';
    var setCountValue = stringifySet(matchUpFormatObject.setFormat, preserveRedundant);
    var setCode = (setCountValue && "S:".concat(setCountValue)) || '';
    var finalSetCountValue = stringifySet(matchUpFormatObject.finalSetFormat, preserveRedundant);
    var finalSetCode = (setLimit &&
        setLimit > 1 &&
        finalSetCountValue &&
        setCountValue !== finalSetCountValue && // don't include final set code if equivalent to other sets
        "F:".concat(finalSetCountValue)) ||
        '';
    var valid = setLimitCode && setCountValue;
    if (valid) {
        return [setLimitCode, setCode, finalSetCode].filter(function (f) { return f; }).join('-');
    }
    return undefined;
}
function stringifySet(setObject, preserveRedundant) {
    if (typeof setObject === 'object' && Object.keys(setObject).length) {
        if (setObject.timed)
            return timedSetFormat(setObject);
        if (setObject.tiebreakSet)
            return tiebreakFormat(setObject.tiebreakSet);
        var setToValue = getNumber(setObject.setTo);
        if (setToValue) {
            var NoAD = (setObject.NoAD && NOAD) || '';
            var setTiebreakValue = tiebreakFormat(setObject.tiebreakFormat);
            var setTiebreakCode = (setTiebreakValue && "/".concat(setTiebreakValue)) || '';
            var tiebreakAtValue = getNumber(setObject.tiebreakAt);
            var tiebreakAtCode = (tiebreakAtValue &&
                (tiebreakAtValue !== setToValue || preserveRedundant) &&
                "@".concat(tiebreakAtValue)) ||
                '';
            if (setTiebreakValue !== false) {
                return "".concat(setToValue).concat(NoAD).concat(setTiebreakCode).concat(tiebreakAtCode);
            }
        }
    }
    return undefined;
}
function tiebreakFormat(tieobject) {
    if (tieobject) {
        if (typeof tieobject === 'object' && !tieobject.tiebreakTo) {
            return '';
        }
        else if (typeof tieobject === 'object' &&
            getNumber(tieobject.tiebreakTo)) {
            var value = "TB".concat(tieobject.tiebreakTo).concat(tieobject.NoAD ? NOAD : '');
            if (tieobject.modifier)
                value += "@".concat(tieobject.modifier);
            return value;
        }
        else {
            return false;
        }
    }
    return undefined;
}

function isValidMatchUpFormat(_a) {
    var matchUpFormat = _a.matchUpFormat;
    if (typeof matchUpFormat !== 'string')
        return false;
    var parsedFormat = parse(matchUpFormat);
    var setParts = matchUpFormat.match(/-S:([1-9])+\/TB([0-9]{1,2})@?([1-9]?)*/);
    var setsTo = setParts === null || setParts === void 0 ? void 0 : setParts[1];
    var tiebreakTo = setParts === null || setParts === void 0 ? void 0 : setParts[2];
    var tiebreakAt = setParts === null || setParts === void 0 ? void 0 : setParts[3];
    var finalSetParts = matchUpFormat.match(/-F:([1-9])+\/TB([0-9]{1,2})@?([1-9]?)*/);
    var finalSetTo = finalSetParts === null || finalSetParts === void 0 ? void 0 : finalSetParts[1];
    var finalSetTiebreakTo = finalSetParts === null || finalSetParts === void 0 ? void 0 : finalSetParts[2];
    var finalTiebreakAt = finalSetParts === null || finalSetParts === void 0 ? void 0 : finalSetParts[3];
    var preserveRedundant = !!((setParts && tiebreakTo && setsTo === tiebreakAt) ||
        (finalSetParts && finalSetTiebreakTo && finalSetTo === finalTiebreakAt));
    var stringified = stringify(parsedFormat, preserveRedundant);
    return stringified === matchUpFormat;
}

var mixedGenderError = 'MIXED events can not contain mixed singles or { gender: ANY } collections';
var anyMixedError = 'events with { gender: ANY } can not contain MIXED singles collections';
function tieFormatGenderValidityCheck(params) {
    var stack = 'tieFormatGenderValidityCheck';
    var referenceGender = params.referenceGender, matchUpType = params.matchUpType, gender = params.gender;
    if (referenceGender &&
        gender &&
        [MALE, FEMALE].includes(referenceGender) &&
        referenceGender !== gender)
        return decorateResult({
            result: { valid: false, error: INVALID_GENDER },
            context: { gender: gender },
            stack: stack,
        });
    if (referenceGender === MIXED &&
        (gender === ANY || (gender === MIXED && matchUpType !== DOUBLES))) {
        return decorateResult({
            result: { error: INVALID_GENDER, valid: false },
            info: mixedGenderError,
            stack: stack,
        });
    }
    if (referenceGender === ANY && gender === MIXED && matchUpType !== DOUBLES)
        return decorateResult({
            result: { error: INVALID_GENDER, valid: false },
            info: anyMixedError,
            stack: stack,
        });
    return { valid: true };
}

var typeMatch = function (arr, type) {
    return arr.filter(Boolean).every(function (i) { return typeof i === type; });
};
var allNumeric = function (arr) { return arr.filter(Boolean).every(isNumeric); };
function getCategoryAgeDetails(params) {
    var _a, _b;
    var category = params.category;
    if (typeof category !== 'object')
        return { error: INVALID_CATEGORY };
    var ageCategoryCode = category.ageCategoryCode, ageMaxDate = category.ageMaxDate, ageMinDate = category.ageMinDate, ageMax = category.ageMax, ageMin = category.ageMin;
    var categoryName = category.categoryName;
    var combinedAge;
    if (!typeMatch([ageCategoryCode, ageMaxDate, ageMinDate, categoryName], 'string') ||
        !allNumeric([ageMax, ageMin] ||
            ![ageMaxDate, ageMinDate].filter(Boolean).every(isValidDateString)))
        return { error: INVALID_CATEGORY };
    var consideredDate = (_a = params.consideredDate) !== null && _a !== void 0 ? _a : extractDate(new Date().toLocaleDateString('sv'));
    if (!isValidDateString(consideredDate))
        return { error: INVALID_DATE };
    // const [consideredYear, month, day] = consideredDate
    var _c = __read(consideredDate
        .split('-')
        .slice(0, 3)
        .map(function (n) { return parseInt(n); }), 1), consideredYear = _c[0];
    // const monthDay = `${zeroPad(month)}-${zeroPad(day)}`;
    var previousDayDate = dateStringDaysChange(consideredDate, -1);
    var _d = __read(previousDayDate
        .split('-')
        .slice(1, 3)
        .map(function (n) { return parseInt(n); }), 2), previousDayMonth = _d[0], previousDay = _d[1];
    var previousMonthDay = "".concat(zeroPad(previousDayMonth), "-").concat(zeroPad(previousDay));
    var nextDayDate = dateStringDaysChange(consideredDate, 1);
    var _e = __read(nextDayDate
        .split('-')
        .slice(1, 3)
        .map(function (n) { return parseInt(n); }), 2), nextDayMonth = _e[0], nextDay = _e[1];
    var nextMonthDay = "".concat(zeroPad(nextDayMonth), "-").concat(zeroPad(nextDay));
    var calculatedAgeMaxDate = ageMin && dateStringDaysChange(consideredDate, -1 * 365 * ageMin);
    var calculatedAgeMinDate = ageMax && dateStringDaysChange(consideredDate, -1 * 365 * ageMax);
    // collect errors; e.g. provided ageMin does not equal calculated ageMin
    var errors = [];
    var addError = function (errorString) {
        return !errors.includes(errorString) && errors.push(errorString);
    };
    ageCategoryCode = ageCategoryCode !== null && ageCategoryCode !== void 0 ? ageCategoryCode : categoryName;
    var prePost = /^([UO]?)(\d{1,2})([UO]?)$/;
    var extractCombined = /^C(\d{1,2})-(\d{1,2})$/;
    var isBetween = ageCategoryCode === null || ageCategoryCode === void 0 ? void 0 : ageCategoryCode.includes('-');
    var isCombined = isBetween && (ageCategoryCode === null || ageCategoryCode === void 0 ? void 0 : ageCategoryCode.match(extractCombined));
    var isCoded = ageCategoryCode === null || ageCategoryCode === void 0 ? void 0 : ageCategoryCode.match(prePost);
    // construct min or max date with or without year
    //const isYYMM = (datePart) => datePart.match(/^\d{2}-\d{2}$/);
    var constructedDate = function (y, df) { return "".concat(y, "-").concat(df); };
    var uPre = function (ageInt) {
        var ageMinYear = consideredYear - ageInt;
        var newMinDate = constructedDate(ageMinYear, nextMonthDay);
        if (category.ageMinDate && category.ageMinDate !== newMinDate)
            addError("Invalid submitted ageMinDate: ".concat(ageMinDate));
        ageMinDate = newMinDate;
        if (ageCategoryCode) {
            if (category.ageMax && category.ageMax !== ageInt - 1) {
                addError("Invalid submitted ageMax: ".concat(ageMax));
                calculatedAgeMinDate = undefined;
            }
            ageMax = ageInt - 1;
        }
    };
    var uPost = function (ageInt) {
        var ageMinYear = consideredYear - ageInt - 1;
        var newMinDate = constructedDate(ageMinYear, nextMonthDay);
        if (category.ageMin && category.ageMin > ageInt) {
            addError("Invalid submitted ageMin: ".concat(ageMin));
        }
        if (category.ageMax && category.ageMax > ageInt) {
            addError("Invalid submitted ageMax: ".concat(ageMax));
        }
        if (category.ageMinDate && category.ageMinDate !== newMinDate)
            addError("Invalid submitted ageMinDate: ".concat(ageMinDate));
        ageMinDate = newMinDate;
        if (ageCategoryCode) {
            if (category.ageMax && category.ageMax !== ageInt) {
                addError("Invalid submitted ageMax: ".concat(ageMax));
                calculatedAgeMaxDate = undefined;
            }
            ageMax = ageInt;
        }
    };
    var oPre = function (ageInt) {
        var ageMaxYear = consideredYear - ageInt;
        var newMaxDate = constructedDate(ageMaxYear, previousMonthDay);
        if (category.ageMaxDate && category.ageMaxDate !== newMaxDate)
            addError("Invalid submitted ageMaxDate: ".concat(ageMaxDate));
        ageMaxDate = newMaxDate;
        if (ageCategoryCode) {
            if (category.ageMin && category.ageMin !== ageInt + 1) {
                addError("Invalid submitted ageMin: ".concat(ageMin));
                calculatedAgeMaxDate = undefined;
            }
            ageMin = ageInt + 1;
        }
    };
    var oPost = function (ageInt) {
        var ageMaxYear = consideredYear - ageInt - 1;
        var newMaxDate = constructedDate(ageMaxYear, previousMonthDay);
        if (category.ageMaxDate && category.ageMaxDate !== newMaxDate)
            addError("Invalid submitted ageMaxDate: ".concat(ageMaxDate));
        ageMaxDate = newMaxDate;
        if (ageCategoryCode) {
            if (category.ageMin && category.ageMin !== ageInt) {
                addError("Invalid submitted ageMin: ".concat(ageMin));
                calculatedAgeMaxDate = undefined;
            }
            ageMin = ageInt;
        }
    };
    var processCode = function (code) {
        var _a = __read((code.match(prePost) || []).slice(1), 3), pre = _a[0], age = _a[1], post = _a[2];
        var ageInt = parseInt(age);
        if (pre === 'U') {
            if (category.ageMaxDate && category.ageMaxDate !== ageMaxDate) {
                addError("Invalid submitted ageMaxDate: ".concat(category.ageMaxDate));
            }
            uPre(ageInt);
        }
        else if (pre === 'O') {
            oPre(ageInt);
        }
        if (post === 'U') {
            if (category.ageMaxDate && category.ageMaxDate !== ageMaxDate) {
                addError("Invalid submitted ageMaxDate: ".concat(category.ageMaxDate));
            }
            uPost(ageInt);
        }
        else if (post === 'O') {
            oPost(ageInt);
        }
        ageMaxDate = ageMaxDate !== null && ageMaxDate !== void 0 ? ageMaxDate : calculatedAgeMaxDate;
        ageMinDate = ageMinDate !== null && ageMinDate !== void 0 ? ageMinDate : calculatedAgeMinDate;
    };
    if (isCombined) {
        // min and max birthdates are not relevant
        // TODO: utility function to calculate combined age given two birthdates?
        ageMaxDate = undefined;
        ageMinDate = undefined;
        ageMax = undefined;
        ageMin = undefined;
        if (category.ageMin) {
            // calculate ageMaxDate
            var ageMaxYear = consideredYear - category.ageMin;
            ageMaxDate = constructedDate(ageMaxYear, previousMonthDay);
        }
        if (category.ageMax) {
            // calculate ageMinDate
            var ageMinYear = consideredYear - category.ageMax - 1;
            ageMinDate = constructedDate(ageMinYear, nextMonthDay);
        }
        var _f = __read(((_b = ageCategoryCode === null || ageCategoryCode === void 0 ? void 0 : ageCategoryCode.match(extractCombined)) !== null && _b !== void 0 ? _b : [])
            .slice(1)
            .map(function (n) { return parseInt(n); }), 2), lowAge = _f[0], highAge = _f[1];
        if (lowAge <= highAge) {
            ageMin = lowAge;
            ageMax = highAge;
            combinedAge = true;
        }
        else {
            addError("Invalid combined age range ".concat(ageCategoryCode));
        }
    }
    else if (isBetween) {
        ageCategoryCode === null || ageCategoryCode === void 0 ? void 0 : ageCategoryCode.split('-').forEach(processCode);
    }
    else if (isCoded) {
        processCode(ageCategoryCode);
    }
    else {
        if (ageMin)
            oPre(ageMin);
        if (ageMax)
            uPost(ageMax);
    }
    if (ageMax && category.ageMin && category.ageMin > ageMax) {
        addError("Invalid submitted ageMin: ".concat(category.ageMin));
        ageMin = undefined;
    }
    var result = definedAttributes({
        consideredDate: consideredDate,
        combinedAge: combinedAge,
        ageMaxDate: ageMaxDate,
        ageMinDate: ageMinDate,
        ageMax: ageMax,
        ageMin: ageMin,
    });
    if (errors.length)
        result.errors = errors;
    return result;
}

function validateCategory(_a) {
    var category = _a.category;
    if (!isObject(category))
        return { error: INVALID_VALUES };
    var categoryDetails = getCategoryAgeDetails({ category: category });
    if (categoryDetails.error)
        return { error: categoryDetails };
    var ratingMax = category.ratingMax, ratingMin = category.ratingMin;
    if (ratingMax && !isNumeric(ratingMax))
        return decorateResult({
            result: { error: INVALID_VALUES },
            context: { ratingMax: ratingMax },
        });
    if (ratingMin && !isNumeric(ratingMin))
        return decorateResult({
            result: { error: INVALID_VALUES },
            context: { ratingMin: ratingMin },
        });
    return __assign({}, categoryDetails);
}

function categoryCanContain(_a) {
    var childCategory = _a.childCategory, withDetails = _a.withDetails, category = _a.category;
    var categoryDetails = validateCategory({ category: category });
    var childCategoryDetails = validateCategory({
        category: childCategory,
    });
    var invalidAgeMin = childCategoryDetails.ageMin &&
        ((categoryDetails.ageMin &&
            childCategoryDetails.ageMin < categoryDetails.ageMin) ||
            (categoryDetails.ageMax &&
                childCategoryDetails.ageMin > categoryDetails.ageMax));
    var invalidAgeMax = childCategoryDetails.ageMax &&
        ((categoryDetails.ageMax &&
            childCategoryDetails.ageMax > categoryDetails.ageMax) ||
            (categoryDetails.ageMin &&
                childCategoryDetails.ageMax < categoryDetails.ageMin));
    var invalidAgeMinDate = childCategoryDetails.ageMinDate &&
        categoryDetails.ageMaxDate &&
        new Date(childCategoryDetails.ageMinDate) >
            new Date(categoryDetails.ageMaxDate);
    var invalidAgeMaxDate = childCategoryDetails.ageMaxDate &&
        categoryDetails.ageMinDate &&
        new Date(childCategoryDetails.ageMaxDate) <
            new Date(categoryDetails.ageMinDate);
    var ratingComparison = (category === null || category === void 0 ? void 0 : category.ratingType) &&
        (childCategory === null || childCategory === void 0 ? void 0 : childCategory.ratingType) &&
        category.ratingType === childCategory.ratingType;
    var invalidRatingRange = ratingComparison &&
        ((category.ratingMin &&
            childCategory.ratingMin &&
            childCategory.ratingMin < category.ratingMin) ||
            (category.ratingMax &&
                childCategory.ratingMax &&
                childCategory.ratingMax > category.ratingMax) ||
            (category.ratingMin &&
                childCategory.ratingMax &&
                childCategory.ratingMax < category.ratingMin) ||
            (category.ratingMax &&
                childCategory.ratingMin &&
                childCategory.ratingMin > category.ratingMax));
    var invalidBallType = (category === null || category === void 0 ? void 0 : category.ballType) &&
        (childCategory === null || childCategory === void 0 ? void 0 : childCategory.ballType) &&
        category.ballType !== childCategory.ballType;
    var valid = !invalidRatingRange &&
        !invalidAgeMinDate &&
        !invalidAgeMaxDate &&
        !invalidBallType &&
        !invalidAgeMax &&
        !invalidAgeMin;
    var ignoreFalse = true;
    var result = definedAttributes({
        invalidRatingRange: invalidRatingRange,
        invalidAgeMinDate: invalidAgeMinDate,
        invalidAgeMaxDate: invalidAgeMaxDate,
        invalidBallType: invalidBallType,
        invalidAgeMax: invalidAgeMax,
        invalidAgeMin: invalidAgeMin,
        valid: valid,
    }, ignoreFalse);
    if (withDetails) {
        Object.assign(result, { categoryDetails: categoryDetails, childCategoryDetails: childCategoryDetails });
    }
    return result;
}

var matchUpFormatCode = {
    isValid: isValidMatchUpFormat,
    isValidMatchUpFormat: isValidMatchUpFormat,
    stringify: stringify,
    parse: parse,
};

function validateCollectionDefinition(_a) {
    var _b = _a.checkCategory, checkCategory = _b === void 0 ? true : _b, collectionDefinition = _a.collectionDefinition, checkCollectionIds = _a.checkCollectionIds, _c = _a.checkGender, checkGender = _c === void 0 ? true : _c, referenceCategory = _a.referenceCategory, referenceGender = _a.referenceGender, event = _a.event;
    referenceGender = referenceGender !== null && referenceGender !== void 0 ? referenceGender : event === null || event === void 0 ? void 0 : event.gender;
    var stack = 'validateCollectionDefinition';
    var errors = [];
    if (typeof collectionDefinition !== 'object') {
        errors.push("collectionDefinition must be an object: ".concat(collectionDefinition));
        return decorateResult({ result: { errors: errors, error: INVALID_OBJECT }, stack: stack });
    }
    var collectionValueProfiles = collectionDefinition.collectionValueProfiles, collectionGroupNumber = collectionDefinition.collectionGroupNumber, collectionValue = collectionDefinition.collectionValue, collectionId = collectionDefinition.collectionId, matchUpCount = collectionDefinition.matchUpCount, matchUpFormat = collectionDefinition.matchUpFormat, matchUpValue = collectionDefinition.matchUpValue, matchUpType = collectionDefinition.matchUpType, scoreValue = collectionDefinition.scoreValue, setValue = collectionDefinition.setValue, category = collectionDefinition.category, gender = collectionDefinition.gender;
    if (checkCollectionIds && typeof collectionId !== 'string') {
        errors.push("collectionId is not type string: ".concat(collectionId));
    }
    if (typeof matchUpCount !== 'number') {
        errors.push("matchUpCount is not type number: ".concat(matchUpCount));
    }
    if (matchUpType && ![SINGLES, DOUBLES].includes(matchUpType)) {
        errors.push("matchUpType must be SINGLES or DOUBLES: ".concat(matchUpType));
    }
    var valueDeclarations = [!!(collectionValueProfiles === null || collectionValueProfiles === void 0 ? void 0 : collectionValueProfiles.length)]
        .concat([matchUpValue, collectionValue, scoreValue, setValue].map(isConvertableInteger))
        .filter(Boolean);
    if (valueDeclarations.length !== 1) {
        errors.push('Missing value definition for matchUps: matchUpValue, collectionValue, or collectionValueProfiles');
    }
    if (matchUpValue && typeof matchUpValue !== 'number') {
        errors.push("matchUpValue is not type number: ".concat(matchUpValue));
    }
    if (collectionValue && typeof collectionValue !== 'number') {
        errors.push("collectionValue is not type number: ".concat(collectionValue));
    }
    if (collectionValueProfiles && matchUpCount) {
        var result = validateCollectionValueProfiles({
            collectionValueProfiles: collectionValueProfiles,
            matchUpCount: matchUpCount,
        });
        if (result.errors) {
            errors.push.apply(errors, __spreadArray([], __read(result.errors), false));
        }
    }
    if (collectionGroupNumber && typeof collectionGroupNumber !== 'number') {
        errors.push("collectionGroupNumber is not type number: ".concat(collectionValue));
    }
    if (matchUpFormat &&
        !matchUpFormatCode.isValidMatchUpFormat({ matchUpFormat: matchUpFormat })) {
        errors.push("Invalid matchUpFormat: ".concat(matchUpFormat));
    }
    if (checkGender) {
        var result = tieFormatGenderValidityCheck({
            referenceGender: referenceGender,
            matchUpType: matchUpType,
            gender: gender,
        });
        if (result.error) {
            return decorateResult({
                context: { referenceGender: referenceGender, gender: gender },
                result: result,
                stack: stack,
            });
        }
    }
    if (checkCategory && referenceCategory && category) {
        var result = categoryCanContain({
            category: referenceCategory,
            childCategory: category,
        });
        if (!result.valid)
            return decorateResult({
                result: { error: INVALID_CATEGORY },
                context: result,
                stack: stack,
            });
    }
    if (errors.length)
        return decorateResult({
            result: { errors: errors, error: INVALID_COLLECTION_DEFINITION },
            stack: stack,
        });
    return { valid: true };
}

function validateTieFormat(params) {
    var _a, _b, _c, _d;
    var checkCategory = !!((params === null || params === void 0 ? void 0 : params.enforceCategory) !== false && (params === null || params === void 0 ? void 0 : params.category));
    var checkGender = !!((params === null || params === void 0 ? void 0 : params.enforceGender) !== false && (params === null || params === void 0 ? void 0 : params.gender));
    var checkCollectionIds = params === null || params === void 0 ? void 0 : params.checkCollectionIds;
    var tieFormat = params === null || params === void 0 ? void 0 : params.tieFormat;
    var event = params === null || params === void 0 ? void 0 : params.event;
    var stack = 'validateTieFormat';
    var errors = [];
    if (!params || !tieFormat || typeof tieFormat !== 'object') {
        errors.push('tieFormat must be an object');
        return decorateResult({
            result: { error: INVALID_TIE_FORMAT },
            context: { tieFormat: tieFormat, errors: errors },
            stack: stack,
        });
    }
    if (typeof tieFormat.winCriteria !== 'object') {
        errors.push('tieFormat.winCriteria must be an object');
        return decorateResult({
            result: { error: INVALID_TIE_FORMAT },
            context: { tieFormat: tieFormat, errors: errors },
            stack: stack,
        });
    }
    if (!Array.isArray(tieFormat.collectionDefinitions)) {
        errors.push(mustBeAnArray('tieFormat.collectionDefinitions'));
        return decorateResult({
            result: { error: INVALID_TIE_FORMAT },
            context: { tieFormat: tieFormat, errors: errors },
            stack: stack,
        });
    }
    var aggregateValueImperative;
    var validCollections = tieFormat.collectionDefinitions.every(function (collectionDefinition) {
        var setValue = collectionDefinition.setValue, scoreValue = collectionDefinition.scoreValue, collectionValue = collectionDefinition.collectionValue;
        if ((setValue || scoreValue) && !collectionValue)
            aggregateValueImperative = true;
        var _a = validateCollectionDefinition({
            referenceCategory: params.category,
            referenceGender: params.gender,
            collectionDefinition: collectionDefinition,
            checkCollectionIds: checkCollectionIds,
            checkCategory: checkCategory,
            checkGender: checkGender,
            event: event,
        }), valid = _a.valid, collectionDefinitionErrors = _a.errors;
        if (valid) {
            return true;
        }
        else if (Array.isArray(collectionDefinitionErrors)) {
            errors.push.apply(errors, __spreadArray([], __read(collectionDefinitionErrors), false));
        }
        return false;
    });
    var validWinCriteria = (typeof ((_a = tieFormat.winCriteria) === null || _a === void 0 ? void 0 : _a.valueGoal) === 'number' &&
        ((_b = tieFormat.winCriteria) === null || _b === void 0 ? void 0 : _b.valueGoal) > 0 &&
        !aggregateValueImperative) ||
        ((_c = tieFormat.winCriteria) === null || _c === void 0 ? void 0 : _c.aggregateValue);
    if (!(validWinCriteria || ((_d = tieFormat.winCriteria) === null || _d === void 0 ? void 0 : _d.aggregateValue))) {
        if (aggregateValueImperative) {
            errors.push('aggregateValue is required');
        }
        else {
            errors.push('Either non-zero valueGoal, or { aggregateValue: true } must be specified in winCriteria');
        }
        return decorateResult({
            context: { tieFormat: tieFormat, errors: errors, aggregateValueImperative: aggregateValueImperative },
            result: { error: INVALID_TIE_FORMAT },
            stack: stack,
        });
    }
    var collectionIds = tieFormat.collectionDefinitions.map(function (_a) {
        var collectionId = _a.collectionId;
        return collectionId;
    });
    var uniqueCollectionIds = !checkCollectionIds ||
        collectionIds.length === unique(collectionIds).length;
    var valid = validCollections && validWinCriteria && uniqueCollectionIds;
    var result = { valid: valid, errors: errors };
    if (!valid) {
        return decorateResult({
            result: { error: INVALID_TIE_FORMAT },
            context: { tieFormat: tieFormat, errors: errors },
            stack: stack,
        });
    }
    return result;
}

function generateTieMatchUps(_a) {
    var matchUp = _a.matchUp, tieFormat = _a.tieFormat, isMock = _a.isMock, uuids = _a.uuids;
    var collectionDefinitions = (tieFormat !== null && tieFormat !== void 0 ? tieFormat : {}).collectionDefinitions;
    var tieMatchUps = (collectionDefinitions !== null && collectionDefinitions !== void 0 ? collectionDefinitions : [])
        .map(function (collectionDefinition) { return generateCollectionMatchUps({ matchUp: matchUp, collectionDefinition: collectionDefinition, uuids: uuids, isMock: isMock }); })
        .filter(Boolean)
        .flat();
    return { tieMatchUps: tieMatchUps };
}
function generateCollectionMatchUps(_a) {
    var _b;
    var _c = _a.collectionPositionOffset, collectionPositionOffset = _c === void 0 ? 0 : _c, collectionDefinition = _a.collectionDefinition, matchUpsLimit = _a.matchUpsLimit, // internal use allows generation of missing matchUps on "reset"
    matchUp = _a.matchUp, isMock = _a.isMock, uuids = _a.uuids;
    var _d = collectionDefinition || {}, matchUpCount = _d.matchUpCount, matchUpType = _d.matchUpType, collectionId = _d.collectionId, processCodes = _d.processCodes;
    var numberToGenerate = (_b = matchUpsLimit !== null && matchUpsLimit !== void 0 ? matchUpsLimit : matchUpCount) !== null && _b !== void 0 ? _b : 0;
    var getMatchUpId = function (index) {
        var _a, _b;
        if (!isMock && !(matchUp === null || matchUp === void 0 ? void 0 : matchUp.isMock))
            return (_a = uuids === null || uuids === void 0 ? void 0 : uuids.pop()) !== null && _a !== void 0 ? _a : UUID();
        var collectionId = collectionDefinition === null || collectionDefinition === void 0 ? void 0 : collectionDefinition.collectionId;
        return (_b = uuids === null || uuids === void 0 ? void 0 : uuids.pop()) !== null && _b !== void 0 ? _b : "".concat(matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpId, "-").concat(collectionId, "-TMU-").concat(index + 1);
    };
    return generateRange(0, numberToGenerate).map(function (index) {
        var collectionPosition = collectionPositionOffset + index + 1;
        return {
            sides: [{ sideNumber: 1 }, { sideNumber: 2 }],
            matchUpId: getMatchUpId(index),
            matchUpStatus: TO_BE_PLAYED,
            collectionPosition: collectionPosition,
            collectionId: collectionId,
            processCodes: processCodes,
            matchUpType: matchUpType,
            isMock: isMock,
        };
    });
}

function getTieFormatDesc(tieFormat) {
    var _a;
    if (!tieFormat)
        return {};
    var matchUpFormats = [];
    var tieFormatName = tieFormat.tieFormatName;
    var tieFormatDesc = (_a = tieFormat.collectionDefinitions) === null || _a === void 0 ? void 0 : _a.map(function (def) {
        var matchUpType = def.matchUpType, matchUpFormat = def.matchUpFormat, matchUpCount = def.matchUpCount, category = def.category, gender = def.gender;
        if (!matchUpFormats.includes(matchUpFormat))
            matchUpFormats.push(matchUpFormat);
        var ageCategoryCode = category === null || category === void 0 ? void 0 : category.ageCategoryCode;
        var matchUpTypeCode = matchUpType === DOUBLES_MATCHUP ? 'D' : 'S';
        return [
            matchUpCount,
            matchUpTypeCode,
            ageCategoryCode,
            matchUpFormat,
            gender,
        ].join(';');
    }).join('|');
    return {
        tieFormatName: (tieFormat && tieFormatName) || 'UNNAMED',
        matchUpFormats: matchUpFormats,
        tieFormatDesc: tieFormatDesc,
    };
}

function compareTieFormats(_a) {
    var _b, _c, _d, _e;
    var _f = _a.considerations, considerations = _f === void 0 ? {} : _f, descendant = _a.descendant, ancestor = _a.ancestor;
    var descendantDifferences = {};
    var ancestorDifferences = {};
    var _g = getTieFormatDesc(descendant), descendantMatchUpFormats = _g.matchUpFormats, descendantDesc = _g.tieFormatDesc;
    var _h = getTieFormatDesc(ancestor), ancestorMatchUpFormats = _h.matchUpFormats, ancestorDesc = _h.tieFormatDesc;
    var matchUpFormatDifferences = unique((descendantMatchUpFormats !== null && descendantMatchUpFormats !== void 0 ? descendantMatchUpFormats : [])
        .filter(function (format) { return !(ancestorMatchUpFormats !== null && ancestorMatchUpFormats !== void 0 ? ancestorMatchUpFormats : []).includes(format); })
        .concat((ancestorMatchUpFormats !== null && ancestorMatchUpFormats !== void 0 ? ancestorMatchUpFormats : []).filter(function (format) { return !(descendantMatchUpFormats !== null && descendantMatchUpFormats !== void 0 ? descendantMatchUpFormats : []).includes(format); })));
    var nameDifference = !!((considerations === null || considerations === void 0 ? void 0 : considerations.collectionName) &&
        descendant.collectionDefinitions
            .map(function (_a) {
            var collectionName = _a.collectionName;
            return collectionName;
        })
            .join('|') !==
            ancestor.collectionDefinitions
                .map(function (_a) {
                var collectionName = _a.collectionName;
                return collectionName;
            })
                .join('|'));
    var orderDifference = !!((considerations === null || considerations === void 0 ? void 0 : considerations.collectionOrder) &&
        descendant.collectionDefinitions
            .map(function (_a) {
            var collectionOrder = _a.collectionOrder;
            return collectionOrder;
        })
            .join('|') !==
            ancestor.collectionDefinitions
                .map(function (_a) {
                var collectionOrder = _a.collectionOrder;
                return collectionOrder;
            })
                .join('|'));
    var descendantCollectionDefinitions = Object.assign.apply(Object, __spreadArray([{}], __read(((descendant === null || descendant === void 0 ? void 0 : descendant.collectionDefinitions) || []).map(function (collectionDefinition) {
        var _a;
        return (_a = {},
            _a[collectionDefinition.collectionId] = collectionDefinition,
            _a);
    })), false));
    var ancestorCollectionDefinitions = Object.assign.apply(Object, __spreadArray([{}], __read(((ancestor === null || ancestor === void 0 ? void 0 : ancestor.collectionDefinitions) || []).map(function (collectionDefinition) {
        var _a;
        return (_a = {},
            _a[collectionDefinition.collectionId] = collectionDefinition,
            _a);
    })), false));
    descendantDifferences.collectionIds = difference(Object.keys(descendantCollectionDefinitions), Object.keys(ancestorCollectionDefinitions));
    ancestorDifferences.collectionIds = difference(Object.keys(ancestorCollectionDefinitions), Object.keys(descendantCollectionDefinitions));
    descendantDifferences.collectionsValue = getCollectionsValue(descendantCollectionDefinitions);
    ancestorDifferences.collectionsValue = getCollectionsValue(ancestorCollectionDefinitions);
    descendantDifferences.groupsCount =
        (_c = (_b = ancestor === null || ancestor === void 0 ? void 0 : ancestor.collectionGroups) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : (0 - ((_e = (_d = descendant === null || descendant === void 0 ? void 0 : descendant.collectionGroups) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) || 0);
    ancestorDifferences.groupsCount = descendantDifferences.groupsCount
        ? -1 * descendantDifferences.groupsCount
        : 0;
    var valueDifference = descendantDifferences.collectionsValue.totalValue -
        ancestorDifferences.collectionsValue.totalValue;
    var matchUpCountDifference = descendantDifferences.collectionsValue.totalMatchUps -
        ancestorDifferences.collectionsValue.totalMatchUps;
    var assignmentValuesCountDifference = ancestorDifferences.collectionsValue.assignmentValues.length !==
        descendantDifferences.collectionsValue.assignmentValues.length;
    var assignmentValuesDifference = ancestorDifferences.collectionsValue.assignmentValues.some(function (assignment, i) {
        var comparisonAssignment = descendantDifferences.collectionsValue.assignmentValues[i];
        if (!comparisonAssignment)
            return true;
        if (assignment.valueKey !== comparisonAssignment.valueKey)
            return true;
        if (assignment.value !== comparisonAssignment.value)
            return true;
        if (Array.isArray(assignment.value)) {
            return assignment.value.every(function (value, i) { return comparisonAssignment.value[i] === value; });
        }
        return false;
    });
    var different = nameDifference ||
        orderDifference ||
        ancestorDesc !== descendantDesc ||
        assignmentValuesCountDifference ||
        assignmentValuesDifference ||
        valueDifference !== 0;
    var invalidValues = __spreadArray(__spreadArray([], __read(ancestorDifferences.collectionsValue.invalidValues), false), __read(descendantDifferences.collectionsValue.invalidValues), false);
    var invalid = invalidValues.length && invalidValues;
    return __assign(__assign({ matchUpFormatDifferences: matchUpFormatDifferences, matchUpCountDifference: matchUpCountDifference, descendantDifferences: descendantDifferences, ancestorDifferences: ancestorDifferences, orderDifference: orderDifference, valueDifference: valueDifference, nameDifference: nameDifference, descendantDesc: descendantDesc, ancestorDesc: ancestorDesc }, SUCCESS), { different: different, invalid: invalid });
}
function getCollectionsValue(definitions) {
    var invalidValues = [];
    var assignmentValues = [];
    var totalMatchUps = 0;
    var collectionIds = Object.keys(definitions).sort(stringSort);
    var totalValue = collectionIds.reduce(function (total, collectionId) {
        var collectionDefinition = definitions[collectionId];
        var collectionValueProfiles = collectionDefinition.collectionValueProfiles, collectionValue = collectionDefinition.collectionValue, matchUpCount = collectionDefinition.matchUpCount, matchUpValue = collectionDefinition.matchUpValue, scoreValue = collectionDefinition.scoreValue, setValue = collectionDefinition.setValue;
        var valueAssignments = {
            collectionValueProfiles: collectionValueProfiles,
            collectionValue: collectionValue,
            matchUpValue: matchUpValue,
            scoreValue: scoreValue,
            setValue: setValue,
        };
        var valueKeys = Object.keys(valueAssignments).filter(function (key) { return ![undefined, null].includes(valueAssignments[key]); });
        if (valueKeys.length !== 1) {
            invalidValues.push({ collectionId: collectionId });
        }
        var valueKey = valueKeys[0];
        if (valueKey) {
            var value = valueKey === 'collectionValueProfiles'
                ? Object.values(collectionValueProfiles)
                : valueAssignments[valueKey];
            assignmentValues.push({ valueKey: valueKey, value: value });
        }
        totalMatchUps += matchUpCount;
        if (collectionValueProfiles)
            return (total +
                collectionValueProfiles.reduce(function (total, profile) { return total + profile.value; }, 0));
        if (matchUpCount) {
            if (isConvertableInteger(matchUpValue))
                return total + matchUpValue * matchUpCount;
            if (isConvertableInteger(scoreValue))
                return total + scoreValue * matchUpCount;
            if (isConvertableInteger(setValue))
                return total + setValue * matchUpCount;
            return total + collectionValue;
        }
        return total;
    }, 0);
    return { totalValue: totalValue, totalMatchUps: totalMatchUps, invalidValues: invalidValues, assignmentValues: assignmentValues };
}

function validUpdate(_a) {
    var matchUp = _a.matchUp, updateInProgressMatchUps = _a.updateInProgressMatchUps;
    return (!matchUp.winningSide &&
        ![completedMatchUpStatuses].includes(matchUp.matchUpStatus) &&
        (updateInProgressMatchUps ||
            (matchUp.matchUpStatus !== IN_PROGRESS$1 && !checkScoreHasValue(matchUp))));
}

// used to determine that all collections have the same collectionIds
function checkStructureMatchUpCounts(_a) {
    var from = _a.from, to = _a.to;
    var referenceKeys = Object.keys(from);
    var sameKeys = intersection(referenceKeys, Object.keys(to)).length === referenceKeys.length;
    var differentMatchUpsCount = referenceKeys.filter(function (collectionId) { return from[collectionId] !== to[collectionId]; });
    var matchUpsCountChanges = differentMatchUpsCount.map(function (collectionId) { return ({
        countChange: to[collectionId] - from[collectionId],
        collectionId: collectionId,
    }); });
    var sameMatchUpsCount = referenceKeys.every(function (key) { return from[key] === to[key]; });
    var equivalent = sameKeys && sameMatchUpsCount;
    return { equivalent: equivalent, matchUpsCountChanges: matchUpsCountChanges };
}
function updateTieFormat(_a) {
    var e_1, _b;
    var _c, _d, _e, _f, _g;
    var updateInProgressMatchUps = _a.updateInProgressMatchUps, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, structure = _a.structure, tieFormat = _a.tieFormat, eventId = _a.eventId, matchUp = _a.matchUp, event = _a.event, uuids = _a.uuids;
    var stack = 'updateTieFormat';
    var tournamentId = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId;
    var modifiedStructuresCount = 0;
    var modifiedMatchUpsCount = 0;
    var addedMatchUpsCount = 0;
    var modifiedCount = 0;
    var collectionMap = tieFormat === null || tieFormat === void 0 ? void 0 : tieFormat.collectionDefinitions.reduce(function (instanceMap, def) {
        instanceMap[def.collectionId] = (instanceMap[def.collectionId] || 0) + def.matchUpCount;
        return instanceMap;
    }, {});
    var matchingCollections = function (_a) {
        var tieFormat = _a.tieFormat;
        var cMap = tieFormat === null || tieFormat === void 0 ? void 0 : tieFormat.collectionDefinitions.reduce(function (instanceMap, def) {
            instanceMap[def.collectionId] = (instanceMap[def.collectionId] || 0) + def.matchUpCount;
            return instanceMap;
        }, {});
        return checkStructureMatchUpCounts({ from: cMap, to: collectionMap }).equivalent;
    };
    var drawDefaultTieFormat = (_c = getTieFormat$1({ drawDefinition: drawDefinition })) === null || _c === void 0 ? void 0 : _c.tieFormat;
    var eventDefaultTieFormat = (_d = getTieFormat$1({ event: event })) === null || _d === void 0 ? void 0 : _d.tieFormat;
    if (event && eventId) {
        try {
            for (var _h = __values((_e = event.drawDefinitions) !== null && _e !== void 0 ? _e : []), _j = _h.next(); !_j.done; _j = _h.next()) {
                var drawDefinition_1 = _j.value;
                processDrawDefinition({ drawDefinition: drawDefinition_1 });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
            }
            finally { if (e_1) throw e_1.error; }
        }
        event.tieFormat = copyTieFormat(tieFormat);
        modifiedCount += 1;
    }
    else if (matchUp) {
        if (!matchUp.tieMatchUps) {
            return decorateResult({ result: { error: INVALID_MATCHUP }, stack: stack });
        }
        // ensure that all tieMatchUps are referenced by tieFormat
        var matchUpMap = instanceCount((_f = matchUp.tieMatchUps) === null || _f === void 0 ? void 0 : _f.map(function (_a) {
            var collectionId = _a.collectionId;
            return collectionId;
        }));
        var check = checkStructureMatchUpCounts({
            to: collectionMap,
            from: matchUpMap,
        });
        var _k = getMatchUpChangesArePossible({
            matchUp: matchUp,
            check: check,
        }), changes = _k.changes, changesArePossible = _k.changesArePossible, cannotChangeReaon = _k.cannotChangeReaon;
        if (check.equivalent) {
            if (validUpdate({ matchUp: matchUp, updateInProgressMatchUps: updateInProgressMatchUps })) {
                matchUp.tieFormat = copyTieFormat(tieFormat);
                modifiedCount += 1;
            }
            else {
                return decorateResult({
                    result: { error: CANNOT_MODIFY_TIEFORMAT },
                    info: 'matchUp is IN_PROGRESS or COMPLETE',
                    stack: stack,
                });
            }
        }
        else if (changesArePossible) {
            makeChanges({ tieFormat: tieFormat, matchUp: matchUp, changes: changes, uuids: uuids });
        }
        else {
            return decorateResult({
                context: { collectionMap: collectionMap, matchUpMap: matchUpMap },
                result: { error: INVALID_TIE_FORMAT },
                info: cannotChangeReaon || 'specified changes not possible',
                stack: stack,
            });
        }
        modifiedMatchUpsCount += 1;
        modifyMatchUpNotice({
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            context: stack,
            drawDefinition: drawDefinition,
            tournamentId: tournamentId,
            matchUp: matchUp,
        });
    }
    else if (structure) {
        // all TEAM matchUps within the structure have tieMatchUps which were created following a tieFormat which occurs higher in the hierarchy
        // attaching a tieFormat to the structure must ensure that affected TEAM matchUps within the structure all have appropriate tieMatchUps
        // therefore those that fail to match the modified tieFormat MUST have an appropriate tieFormat attached from higher in the hierarchy
        var inheritedTieFormat = drawDefaultTieFormat !== null && drawDefaultTieFormat !== void 0 ? drawDefaultTieFormat : eventDefaultTieFormat;
        var modified = (_g = processStructure({
            inheritedTieFormat: inheritedTieFormat,
            structure: structure,
        })) === null || _g === void 0 ? void 0 : _g.modifiedMatchUpsCount;
        if (modified) {
            modifiedMatchUpsCount += modified;
            modifiedStructuresCount += 1;
            modifiedCount += 1;
        }
        var different = !structure.tieFormat ||
            compareTieFormats({
                ancestor: structure.tieFormat,
                descendant: tieFormat,
            }).different;
        if (different) {
            structure.tieFormat = copyTieFormat(tieFormat);
            modifiedStructuresCount += 1;
            modifiedCount += 1;
        }
        (modified || different) &&
            drawDefinition &&
            modifyDrawNotice({
                structureIds: [structure.structureId],
                eventId: event === null || event === void 0 ? void 0 : event.eventId,
                drawDefinition: drawDefinition,
            });
    }
    else if (drawDefinition) {
        processDrawDefinition({ drawDefinition: drawDefinition });
        drawDefinition.tieFormat = copyTieFormat(tieFormat);
        modifiedCount += 1;
    }
    else {
        return { error: MISSING_DRAW_DEFINITION };
    }
    return __assign(__assign({ modifiedStructuresCount: modifiedStructuresCount, modifiedMatchUpsCount: modifiedMatchUpsCount, addedMatchUpsCount: addedMatchUpsCount, modifiedCount: modifiedCount }, SUCCESS), { tieFormat: tieFormat });
    function processDrawDefinition(_a) {
        var e_2, _b;
        var _c;
        var drawDefinition = _a.drawDefinition;
        var structures = drawDefinition.structures || [];
        var modifiedStructureIds = [];
        try {
            for (var structures_1 = __values(structures), structures_1_1 = structures_1.next(); !structures_1_1.done; structures_1_1 = structures_1.next()) {
                var structure_1 = structures_1_1.value;
                // if a sub-structure has a tieFormat then setting drawDefinition.tieFormat will have no effect
                if (structure_1.tieFormat)
                    continue;
                var inheritedTieFormat = eventDefaultTieFormat;
                var modifiedCount_1 = (_c = processStructure({
                    inheritedTieFormat: inheritedTieFormat,
                    structure: structure_1,
                })) === null || _c === void 0 ? void 0 : _c.modifiedMatchUpsCount;
                if (modifiedCount_1) {
                    modifiedStructuresCount += 1;
                    modifiedMatchUpsCount += modifiedCount_1;
                    var structureId = structure_1.structureId;
                    modifiedStructureIds.push(structureId);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (structures_1_1 && !structures_1_1.done && (_b = structures_1.return)) _b.call(structures_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        modifyDrawNotice({
            structureIds: modifiedStructureIds,
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            drawDefinition: drawDefinition,
        });
        return modifiedStructureIds.length;
    }
    function processStructure(_a) {
        var e_3, _b;
        var _c, _d;
        var inheritedTieFormat = _a.inheritedTieFormat, structure = _a.structure;
        var modifiedMatchUpsCount = 0;
        var structureMatchUps = ((_c = getAllStructureMatchUps({
            matchUpFilters: { matchUpTypes: [TEAM] },
            structure: structure,
        })) === null || _c === void 0 ? void 0 : _c.matchUps) || [];
        try {
            for (var structureMatchUps_1 = __values(structureMatchUps), structureMatchUps_1_1 = structureMatchUps_1.next(); !structureMatchUps_1_1.done; structureMatchUps_1_1 = structureMatchUps_1.next()) {
                var matchUp_1 = structureMatchUps_1_1.value;
                var validToUpdate = validUpdate({ matchUp: matchUp_1, updateInProgressMatchUps: updateInProgressMatchUps });
                var modified = false;
                var tieMatchUpsMap = instanceCount((_d = matchUp_1.tieMatchUps) === null || _d === void 0 ? void 0 : _d.map(function (_a) {
                    var collectionId = _a.collectionId;
                    return collectionId;
                }));
                var check = checkStructureMatchUpCounts({
                    from: tieMatchUpsMap,
                    to: collectionMap,
                });
                if (!check.equivalent) {
                    var _e = getMatchUpChangesArePossible({
                        matchUp: matchUp_1,
                        check: check,
                    }), changes = _e.changes, changesArePossible = _e.changesArePossible;
                    if (changesArePossible && !matchUp_1.tieFormat) {
                        makeChanges({ changes: changes, matchUp: matchUp_1, tieFormat: tieFormat, uuids: uuids });
                    }
                    else if (inheritedTieFormat) {
                        var different = !matchUp_1.tieFormat ||
                            compareTieFormats({
                                ancestor: inheritedTieFormat,
                                descendant: matchUp_1.tieFormat,
                            }).different;
                        if (different) {
                            matchUp_1.tieFormat = inheritedTieFormat;
                            modified = true;
                        }
                    }
                    else {
                        return decorateResult({
                            result: { error: MISSING_TIE_FORMAT },
                            stack: stack,
                        });
                    }
                }
                else if (matchUp_1.tieFormat && matchingCollections(matchUp_1) && validToUpdate) {
                    matchUp_1.tieFormat = copyTieFormat(tieFormat);
                    modified = true;
                }
                if (modified) {
                    modifiedMatchUpsCount += 1;
                    modifyMatchUpNotice({
                        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                        drawDefinition: drawDefinition,
                        context: stack,
                        eventId: eventId,
                        matchUp: matchUp_1,
                    });
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (structureMatchUps_1_1 && !structureMatchUps_1_1.done && (_b = structureMatchUps_1.return)) _b.call(structureMatchUps_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return { modifiedMatchUpsCount: modifiedMatchUpsCount };
    }
    function makeChanges(_a) {
        var uuids = _a.uuids, matchUp = _a.matchUp, tieFormat = _a.tieFormat, changes = _a.changes;
        matchUp.tieFormat = copyTieFormat(tieFormat);
        var matchUpIdsRemoved = [];
        var matchUpsAdded = [];
        changes.forEach(function (change) {
            var _a;
            if (change.countChange > 0) {
                var collectionPositionOffset = Math.max.apply(Math, __spreadArray([0], __read(matchUp.tieMatchUps
                    .filter(function (tieMatchUp) { return tieMatchUp.collectionId === change.collectionId; })
                    .map(xa('collectionPosition'))), false));
                var collectionDefinition = tieFormat.collectionDefinitions.find(function (def) { return def.collectionId === change.collectionId; });
                var newMatchUps = generateCollectionMatchUps({
                    matchUpsLimit: change.countChange,
                    collectionPositionOffset: collectionPositionOffset,
                    collectionDefinition: collectionDefinition,
                    matchUp: matchUp,
                    uuids: uuids,
                });
                matchUpsAdded.push.apply(matchUpsAdded, __spreadArray([], __read(makeDeepCopy(newMatchUps, false, true)), false));
                addedMatchUpsCount += matchUpsAdded.length;
                (_a = matchUp.tieMatchUps).push.apply(_a, __spreadArray([], __read(newMatchUps), false));
            }
            else {
                var tieMatchUpIdsToRemove_1 = change.toBePlayedTieMatchUpIds.slice(0, Math.abs(change.countChange));
                console.log('remove', tieMatchUpIdsToRemove_1.length);
                matchUpIdsRemoved.push.apply(matchUpIdsRemoved, __spreadArray([], __read(tieMatchUpIdsToRemove_1), false));
                matchUp.tieMatchUps = matchUp.tieMatchUps.filter(function (_a) {
                    var matchUpId = _a.matchUpId;
                    return !tieMatchUpIdsToRemove_1.includes(matchUpId);
                });
            }
        });
        matchUpsAdded.length &&
            addMatchUpsNotice({
                matchUps: matchUpsAdded,
                drawDefinition: drawDefinition,
                tournamentId: tournamentId,
                eventId: eventId,
            });
        matchUpIdsRemoved.length &&
            deleteMatchUpsNotice({
                matchUpIds: matchUpIdsRemoved,
                action: 'updateTieFormat',
                drawDefinition: drawDefinition,
                tournamentId: tournamentId,
                eventId: eventId,
            });
        return { matchUpIdsRemoved: matchUpIdsRemoved, matchUpsAdded: matchUpsAdded };
    }
}
function getMatchUpChangesArePossible(_a) {
    var check = _a.check, matchUp = _a.matchUp;
    var cannotChangeReaon = '';
    var changes = [];
    var changesArePossible = check.matchUpsCountChanges.every(function (_a) {
        var collectionId = _a.collectionId, countChange = _a.countChange;
        var toBePlayedTieMatchUpIds = matchUp.tieMatchUps
            .filter(function (tieMatchUp) { return tieMatchUp.collectionId === collectionId && tieMatchUp.matchUpStatus === TO_BE_PLAYED; })
            .map(xa('matchUpId'));
        var possibleToChange = toBePlayedTieMatchUpIds.length + countChange >= 0 || countChange > 0;
        if (!possibleToChange && countChange < 0)
            cannotChangeReaon = 'Insufficient TO_BE_PLAYED matchUps';
        changes.push({
            toBePlayedTieMatchUpIds: toBePlayedTieMatchUpIds,
            collectionId: collectionId,
            countChange: countChange,
        });
        return possibleToChange;
    });
    return { changesArePossible: changesArePossible, changes: changes, cannotChangeReaon: cannotChangeReaon };
}

function tieFormatTelemetry(_a) {
    var drawDefinition = _a.drawDefinition, auditData = _a.auditData;
    var extension = findExtension({
        name: TIE_FORMAT_MODIFICATIONS,
        element: drawDefinition,
    }).extension;
    var updatedExtension = {
        name: TIE_FORMAT_MODIFICATIONS,
        value: Array.isArray(extension === null || extension === void 0 ? void 0 : extension.value)
            ? extension === null || extension === void 0 ? void 0 : extension.value.concat(auditData)
            : [auditData],
    };
    addExtension({ element: drawDefinition, extension: updatedExtension });
}

function modifyCollectionDefinition(_a) {
    var _b, _c, _d, _e;
    var _f = _a.updateInProgressMatchUps, updateInProgressMatchUps = _f === void 0 ? false : _f, tournamentRecord = _a.tournamentRecord, collectionOrder = _a.collectionOrder, collectionName = _a.collectionName, tieFormatName = _a.tieFormatName, drawDefinition = _a.drawDefinition, matchUpFormat = _a.matchUpFormat, matchUpCount = _a.matchUpCount, collectionId = _a.collectionId, matchUpType = _a.matchUpType, structureId = _a.structureId, matchUpId = _a.matchUpId, category = _a.category, eventId = _a.eventId, gender = _a.gender, event = _a.event, 
    // value assignment, only one is allowed to have a value
    collectionValueProfiles = _a.collectionValueProfiles, collectionValue = _a.collectionValue, matchUpValue = _a.matchUpValue, scoreValue = _a.scoreValue, setValue = _a.setValue;
    var stack = 'modifyCollectionDefinition';
    if (matchUpFormat && !isValidMatchUpFormat({ matchUpFormat: matchUpFormat })) {
        return decorateResult({
            result: { error: INVALID_VALUES },
            context: { matchUpFormat: matchUpFormat },
            stack: stack,
        });
    }
    if (collectionName && typeof collectionName !== 'string') {
        return decorateResult({
            result: { error: INVALID_VALUES },
            context: { collectionName: collectionName },
            stack: stack,
        });
    }
    if (gender && !Object.values(genderConstants).includes(gender)) {
        return decorateResult({
            result: { error: INVALID_VALUES },
            context: { gender: gender },
            stack: stack,
        });
    }
    if (category && typeof category !== 'object') {
        return decorateResult({
            result: { error: INVALID_VALUES },
            context: { category: category },
            stack: stack,
        });
    }
    var valueAssignments = {
        collectionValueProfiles: collectionValueProfiles,
        collectionValue: collectionValue,
        matchUpValue: matchUpValue,
        scoreValue: scoreValue,
        setValue: setValue,
    };
    if (!Object.values(valueAssignments).filter(Boolean).length &&
        !collectionOrder &&
        !collectionName &&
        !matchUpFormat &&
        !matchUpCount &&
        !matchUpType)
        return decorateResult({ result: { error: MISSING_VALUE }, stack: stack });
    if (Object.values(valueAssignments).filter(Boolean).length > 1)
        return decorateResult({
            info: 'Only one value assignment allowed per collectionDefinition',
            result: { error: INVALID_VALUES },
            stack: stack,
        });
    var result = getTieFormat$1({
        drawDefinition: drawDefinition,
        structureId: structureId,
        matchUpId: matchUpId,
        eventId: eventId,
        event: event,
    });
    if (result.error) {
        return decorateResult({ result: result, stack: stack });
    }
    var matchUp = result.matchUp, structure = result.structure, existingTieFormat = result.tieFormat;
    var tieFormat = copyTieFormat(existingTieFormat);
    var sourceCollectionDefinition = existingTieFormat === null || existingTieFormat === void 0 ? void 0 : existingTieFormat.collectionDefinitions.find(function (collectionDefinition) {
        return collectionDefinition.collectionId === collectionId;
    });
    var targetCollectionDefinition = tieFormat === null || tieFormat === void 0 ? void 0 : tieFormat.collectionDefinitions.find(function (collectionDefinition) { return collectionDefinition.collectionId === collectionId; });
    if (!sourceCollectionDefinition)
        return decorateResult({
            info: 'source collectionDefinition',
            result: { error: NOT_FOUND },
            context: { collectionId: collectionId },
            stack: stack,
        });
    var value = (_c = (_b = collectionValue !== null && collectionValue !== void 0 ? collectionValue : matchUpValue) !== null && _b !== void 0 ? _b : scoreValue) !== null && _c !== void 0 ? _c : setValue;
    if (collectionValueProfiles) {
        var result_1 = validateCollectionValueProfiles({
            matchUpCount: (_d = matchUpCount !== null && matchUpCount !== void 0 ? matchUpCount : sourceCollectionDefinition === null || sourceCollectionDefinition === void 0 ? void 0 : sourceCollectionDefinition.matchUpCount) !== null && _d !== void 0 ? _d : 0,
            collectionValueProfiles: collectionValueProfiles,
        });
        if (result_1.errors) {
            return decorateResult({
                result: { error: INVALID_VALUES },
                info: result_1.errors,
                stack: stack,
            });
        }
    }
    else if (value && !isConvertableInteger(value)) {
        return decorateResult({
            result: { error: INVALID_VALUES },
            info: 'value is not an integer',
            context: { value: value },
            stack: stack,
        });
    }
    var equivalentValueProfiles = function (a, b) {
        return intersection(Object.keys(a), Object.keys(b)).length ===
            Object.keys(a).length &&
            intersection(Object.values(a), Object.values(b)).length ===
                Object.values(a).length;
    };
    var valueProfileModified = collectionValueProfiles &&
        (!sourceCollectionDefinition.collectionValueProfiles ||
            !equivalentValueProfiles(sourceCollectionDefinition.collectionValueProfiles, collectionValueProfiles));
    var valueModified = (isConvertableInteger(collectionValue) &&
        sourceCollectionDefinition.collectionValue !== collectionValue) ||
        (isConvertableInteger(matchUpValue) &&
            sourceCollectionDefinition.matchUpValue !== matchUpValue) ||
        (isConvertableInteger(scoreValue) &&
            sourceCollectionDefinition.scoreValue !== scoreValue) ||
        (isConvertableInteger(setValue) &&
            sourceCollectionDefinition.setValue !== setValue) ||
        valueProfileModified;
    var modifications = [];
    if (valueModified) {
        // cleanup any previously existing value assignment
        targetCollectionDefinition.collectionValueProfiles = undefined;
        targetCollectionDefinition.collectionValue = undefined;
        targetCollectionDefinition.matchUpValue = undefined;
        targetCollectionDefinition.scoreValue = undefined;
        targetCollectionDefinition.setValue = undefined;
        // add new value assignment
        Object.assign(targetCollectionDefinition, valueAssignments);
        modifications.push(__assign({ collectionId: collectionId }, definedAttributes(valueAssignments)));
    }
    // must remove all collectionGroups which contain the collection which has been modified
    if ((isConvertableInteger(scoreValue) || isConvertableInteger(setValue)) &&
        targetCollectionDefinition.collectionGroupNumber) {
        var targetCollectionGroupNumber_1 = targetCollectionDefinition.collectionGroupNumber;
        tieFormat.collectionDefinitions = tieFormat.collectionDefinitions.map(function (collectionDefinition) {
            var collectionGroupNumber = collectionDefinition.collectionGroupNumber, rest = __rest(collectionDefinition, ["collectionGroupNumber"]);
            if (collectionGroupNumber === targetCollectionGroupNumber_1) {
                return rest;
            }
            else {
                return collectionDefinition;
            }
        });
        tieFormat.collectionGroups = tieFormat.collectionGroups.filter(function (_a) {
            var groupNumber = _a.groupNumber;
            return groupNumber !== targetCollectionGroupNumber_1;
        });
        modifications.push({
            collectionId: collectionId,
            change: 'collectionGroupNumber removed',
        });
    }
    // calculate new winCriteria for tieFormat
    // if existing winCriteria is aggregateValue, retain
    var _g = calculateWinCriteria(tieFormat), aggregateValue = _g.aggregateValue, valueGoal = _g.valueGoal;
    var winCriteria = definedAttributes({ aggregateValue: aggregateValue, valueGoal: valueGoal });
    if (winCriteria.aggregateValue !==
        (existingTieFormat === null || existingTieFormat === void 0 ? void 0 : existingTieFormat.winCriteria.aggregateValue) ||
        winCriteria.valueGoal !== (existingTieFormat === null || existingTieFormat === void 0 ? void 0 : existingTieFormat.winCriteria.valueGoal)) {
        tieFormat.winCriteria = winCriteria;
        modifications.push({ collectionId: collectionId, winCriteria: winCriteria });
    }
    if (isConvertableInteger(collectionOrder) &&
        sourceCollectionDefinition.collectionOrder !== collectionOrder) {
        targetCollectionDefinition.collectionOrder = collectionOrder;
        modifications.push({ collectionId: collectionId, collectionOrder: collectionOrder });
    }
    if (collectionName &&
        sourceCollectionDefinition.collectionName !== collectionName) {
        targetCollectionDefinition.collectionName = collectionName;
        modifications.push({ collectionId: collectionId, collectionName: collectionName });
    }
    if (matchUpFormat &&
        sourceCollectionDefinition.matchUpFormat !== matchUpFormat) {
        targetCollectionDefinition.matchUpFormat = matchUpFormat;
        modifications.push({ collectionId: collectionId, matchUpFormat: matchUpFormat });
    }
    if (isConvertableInteger(matchUpCount) &&
        sourceCollectionDefinition.matchUpCount !== matchUpCount) {
        targetCollectionDefinition.matchUpCount = matchUpCount;
        modifications.push({ collectionId: collectionId, matchUpCount: matchUpCount });
    }
    if (matchUpType && sourceCollectionDefinition.matchUpType !== matchUpType) {
        // TODO: updateTieFormat needs to support
        // targetCollectionDefinition.matchUpType = matchUpType;
        // modifications.push({ collectionId, matchUpType });
        return decorateResult({
            result: { error: NOT_IMPLEMENTED },
            context: { matchUpType: matchUpType },
            stack: stack,
        });
    }
    if (category && sourceCollectionDefinition.category !== category) {
        targetCollectionDefinition.category = category;
        modifications.push({ collectionId: collectionId, category: category });
    }
    if (gender && sourceCollectionDefinition.gender !== gender) {
        // TODO: remove all inappropriately gendered participants
        targetCollectionDefinition.gender = gender;
        modifications.push({ collectionId: collectionId, gender: gender });
    }
    var modifiedTieFormat = definedAttributes(tieFormat);
    result = validateTieFormat({ tieFormat: modifiedTieFormat });
    if (result.error) {
        return decorateResult({ result: result, stack: stack });
    }
    if (!modifications.length) {
        return decorateResult({ result: __assign(__assign({}, SUCCESS), { modifications: modifications }) });
    }
    // Note: this logic needs to exist both here and in `modifyTieFormat`
    // it is duplicated because this method can be called independently
    var changedTieFormatName = (existingTieFormat === null || existingTieFormat === void 0 ? void 0 : existingTieFormat.tieFormatName) !== tieFormatName;
    // if tieFormat has changed, force renaming of the tieFormat
    if (changedTieFormatName) {
        modifiedTieFormat.tieFormatName = tieFormatName;
        modifications.push({ tieFormatName: tieFormatName });
    }
    else if (modifications.length) {
        delete modifiedTieFormat.tieFormatName;
        modifications.push('tieFormatName removed: modifications without new tieFormatName');
    }
    result = updateTieFormat({
        tieFormat: modifiedTieFormat,
        updateInProgressMatchUps: updateInProgressMatchUps,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        structure: structure,
        eventId: eventId,
        matchUp: matchUp,
        event: event,
    });
    if (!result.error) {
        var appliedPolicies = getAppliedPolicies({ tournamentRecord: tournamentRecord }).appliedPolicies;
        if ((_e = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.audit) === null || _e === void 0 ? void 0 : _e[TIE_FORMAT_MODIFICATIONS]) {
            var auditData = definedAttributes({
                collectionDefinition: targetCollectionDefinition,
                drawId: drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.drawId,
                action: stack,
                structureId: structureId,
                matchUpId: matchUpId,
                eventId: eventId,
            });
            tieFormatTelemetry({ drawDefinition: drawDefinition, auditData: auditData });
        }
    }
    return decorateResult({ result: __assign(__assign({}, result), { modifications: modifications }), stack: stack });
}

function swapDrawPositionAssignments$1(_a) {
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawPositions = _a.drawPositions, structureId = _a.structureId, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structureId)
        return { error: MISSING_STRUCTURE_ID };
    if ((drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.length) !== 2) {
        return { error: INVALID_VALUES, drawPositions: drawPositions };
    }
    var matchUpsMap = getMatchUpsMap({ drawDefinition: drawDefinition });
    var inContextDrawMatchUps = getAllDrawMatchUps({
        inContext: true,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
    }).matchUps;
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    var result;
    if (structure.structureType === CONTAINER) {
        // { structureType: CONTAINER } indicates that the swap is within a ROUND ROBIN structure
        result = roundRobinSwap({
            inContextDrawMatchUps: inContextDrawMatchUps,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            drawPositions: drawPositions,
            matchUpsMap: matchUpsMap,
            structure: structure,
            event: event,
        });
    }
    else {
        // if not a CONTAINER then swap occurs within elimination structure
        result = eliminationSwap({
            inContextDrawMatchUps: inContextDrawMatchUps,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            drawPositions: drawPositions,
            matchUpsMap: matchUpsMap,
            structure: structure,
            event: event,
        });
    }
    if (result.error)
        return result;
    conditionallyDisableLinkPositioning({ structure: structure, drawPositions: drawPositions });
    var positionAction = {
        name: 'swapDrawPositionAssignments',
        drawPositions: drawPositions,
        structureId: structureId,
    };
    addPositionActionTelemetry({ drawDefinition: drawDefinition, positionAction: positionAction });
    modifyPositionAssignmentsNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    });
    if (event.eventType === TEAM_EVENT) {
        // update side lineUps for drawPositions that were swapped
        var inContextTargetMatchUps = getAllStructureMatchUps({
            matchUpFilters: { matchUpTypes: [TEAM_MATCHUP] },
            inContext: true,
            structure: structure,
        }).matchUps.filter(function (matchUp) {
            var _a;
            return (_a = matchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.some(function (drawPosition) {
                return drawPositions.includes(drawPosition);
            });
        });
        var structureMatchUps_1 = getAllStructureMatchUps({
            structure: structure,
            matchUpFilters: { matchUpTypes: [TEAM_MATCHUP] },
        }).matchUps;
        inContextTargetMatchUps.forEach(function (inContextTargetMatchUp) {
            (inContextTargetMatchUp.sides || []).forEach(function (inContextSide) {
                var _a;
                var drawPosition = inContextSide === null || inContextSide === void 0 ? void 0 : inContextSide.drawPosition;
                if (drawPositions.includes(drawPosition)) {
                    var teamParticipantId = inContextSide.participantId;
                    var matchUp = structureMatchUps_1.find(function (_a) {
                        var matchUpId = _a.matchUpId;
                        return matchUpId === inContextTargetMatchUp.matchUpId;
                    });
                    var drawPositionSideIndex = (_a = inContextTargetMatchUp === null || inContextTargetMatchUp === void 0 ? void 0 : inContextTargetMatchUp.sides) === null || _a === void 0 ? void 0 : _a.reduce(function (index, side, i) {
                        return side.drawPosition === drawPosition ? i : index;
                    }, undefined);
                    updateSideLineUp({
                        inContextTargetMatchUp: inContextTargetMatchUp,
                        drawPositionSideIndex: drawPositionSideIndex,
                        teamParticipantId: teamParticipantId,
                        tournamentRecord: tournamentRecord,
                        drawDefinition: drawDefinition,
                        matchUp: matchUp,
                        event: event,
                    });
                }
            });
        });
    }
    modifyDrawNotice({ drawDefinition: drawDefinition, structureIds: [structureId] });
    return __assign({}, SUCCESS);
}
function eliminationSwap(_a) {
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawPositions = _a.drawPositions, matchUpsMap = _a.matchUpsMap, structure = _a.structure, event = _a.event;
    // if not a CONTAINER then swap occurs within elimination structure
    var assignments = structure === null || structure === void 0 ? void 0 : structure.positionAssignments.filter(function (assignment) { return drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(assignment.drawPosition); });
    if (!assignments) {
        return {
            error: INVALID_VALUES,
            structure: structure,
            info: 'Missing positionAssignments',
        };
    }
    // if both positions are BYE no need to do anything
    if (assignments.filter(function (_a) {
        var bye = _a.bye;
        return bye;
    }).length === 2)
        return __assign({}, SUCCESS);
    // if both positions are qualifier no need to do anything
    if (assignments.filter(function (_a) {
        var qualifier = _a.qualifier;
        return qualifier;
    }).length === 2)
        return __assign({}, SUCCESS);
    var isQualifierSwap = assignments.some(function (_a) {
        var qualifier = _a.qualifier;
        return qualifier;
    });
    var isByeSwap = assignments.some(function (_a) {
        var bye = _a.bye;
        return bye;
    });
    if (isByeSwap && !isQualifierSwap) {
        return swapParticipantIdWithBYE({
            inContextDrawMatchUps: inContextDrawMatchUps,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            assignments: assignments,
            matchUpsMap: matchUpsMap,
            structure: structure,
            event: event,
        });
    }
    else {
        return eliminationPosiitonSwap({
            inContextDrawMatchUps: inContextDrawMatchUps,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            assignments: assignments,
            matchUpsMap: matchUpsMap,
            structure: structure,
            event: event,
        });
    }
}
function swapParticipantIdWithBYE(_a) {
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, assignments = _a.assignments, matchUpsMap = _a.matchUpsMap, structure = _a.structure, event = _a.event;
    // remove the assignment that has a participantId
    var originalByeAssignment = assignments.find(function (_a) {
        var bye = _a.bye;
        return bye;
    });
    var originalParticipantIdAssignment = assignments.find(function (_a) {
        var participantId = _a.participantId;
        return participantId;
    });
    var originalByeDrawPosition = originalByeAssignment.drawPosition;
    var participantId = originalParticipantIdAssignment.participantId, originalParticipantIdDrawPosition = originalParticipantIdAssignment.drawPosition;
    var structureId = structure.structureId;
    // remove both drawPosition assignments
    var result = removeDrawPositionAssignment({
        drawPosition: originalByeDrawPosition,
        inContextDrawMatchUps: inContextDrawMatchUps,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        structureId: structureId,
        matchUpsMap: matchUpsMap,
    });
    if (result.error)
        return result;
    result = removeDrawPositionAssignment({
        drawPosition: originalParticipantIdDrawPosition,
        inContextDrawMatchUps: inContextDrawMatchUps,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        structureId: structureId,
        matchUpsMap: matchUpsMap,
    });
    if (result.error)
        return result;
    assignDrawPositionBye({
        drawPosition: originalParticipantIdDrawPosition,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        structureId: structureId,
        matchUpsMap: matchUpsMap,
        event: event,
    });
    // replace the original byeAssignment with participantId
    result = assignDrawPosition$1({
        drawPosition: originalByeDrawPosition,
        inContextDrawMatchUps: inContextDrawMatchUps,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        structureId: structureId,
        participantId: participantId,
        matchUpsMap: matchUpsMap,
        event: event,
    });
    if (result.error)
        return result;
    return __assign({}, SUCCESS);
}
function eliminationPosiitonSwap(_a) {
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, assignments = _a.assignments, matchUpsMap = _a.matchUpsMap, structure = _a.structure, event = _a.event;
    // preserves order of drawPositions in original positionAssignments array
    // while insuring that all attributes are faithfully copied over and only drawPosition is swapped
    var newAssignments = Object.assign.apply(Object, __spreadArray([{}], __read(assignments.map(function (assignment, index) {
        var _a;
        var drawPosition = assignment.drawPosition;
        var newAssignment = __assign(__assign({}, assignments[1 - index]), { drawPosition: drawPosition });
        return _a = {}, _a[drawPosition] = newAssignment, _a;
    })), false));
    structure.positionAssignments = structure.positionAssignments.map(function (assignment) { return newAssignments[assignment.drawPosition] || assignment; });
    resetLineUps({
        inContextDrawMatchUps: inContextDrawMatchUps,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        assignments: assignments,
        structure: structure,
        event: event,
    });
    return __assign({}, SUCCESS);
}
function roundRobinSwap(_a) {
    var _b;
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawPositions = _a.drawPositions, matchUpsMap = _a.matchUpsMap, structure = _a.structure, event = _a.event;
    var assignments = (_b = structure.structures) === null || _b === void 0 ? void 0 : _b.reduce(function (assignments, structure) {
        var structureAssignments = structure === null || structure === void 0 ? void 0 : structure.positionAssignments.filter(function (assignment) { return drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(assignment.drawPosition); });
        if (structureAssignments)
            assignments.push.apply(assignments, __spreadArray([], __read(structureAssignments), false));
        return assignments;
    }, []);
    // if both positions are BYE no need to do anything
    if (assignments.filter(function (_a) {
        var bye = _a.bye;
        return bye;
    }).length === 2)
        return __assign({}, SUCCESS);
    // if both positions are QUALIFIER no need to do anything
    if (assignments.filter(function (_a) {
        var qualifier = _a.qualifier;
        return qualifier;
    }).length === 2)
        return __assign({}, SUCCESS);
    resetLineUps({
        inContextDrawMatchUps: inContextDrawMatchUps,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        assignments: assignments,
        structure: structure,
        event: event,
    });
    var isQualifierSwap = assignments.some(function (_a) {
        var qualifier = _a.qualifier;
        return qualifier;
    });
    var isByeSwap = assignments.some(function (_a) {
        var bye = _a.bye;
        return bye;
    });
    if (isByeSwap && !isQualifierSwap) {
        swapParticipantIdWithBYE({
            inContextDrawMatchUps: inContextDrawMatchUps,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            assignments: assignments,
            matchUpsMap: matchUpsMap,
            structure: structure,
            event: event,
        });
    }
    else {
        // for Round Robin the positionAssignments are distributed across structures
        // so the strategy of creating a new positionAssignments array won't work
        var originalAssignments_1 = makeDeepCopy(assignments, false, true);
        assignments.forEach(function (assignment, index) {
            var newParticipantId = originalAssignments_1[1 - index].participantId;
            assignment.qualifier = originalAssignments_1[1 - index].qualifier;
            assignment.participantId = newParticipantId;
        });
    }
    return __assign({}, SUCCESS);
}

/**
 *
 * @param {string} drawId - id of drawDefinition within which structure is found
 * @param {string} structureId - id of structure of drawPosition
 * @param {number[]} drawPositions - drawPositions for which participants will be swapped
 *
 */
function swapDrawPositionAssignments(params) {
    return swapDrawPositionAssignments$1(params);
}

function getPlayoffStructures(_a) {
    var drawDefinition = _a.drawDefinition, structureId = _a.structureId;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    var targetStructureIds = ((drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.links) || [])
        .filter(function (link) { var _a; return ((_a = link.source) === null || _a === void 0 ? void 0 : _a.structureId) === structureId; })
        .map(function (link) { var _a; return (_a = link.target) === null || _a === void 0 ? void 0 : _a.structureId; });
    var playoffStructures = ((drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) || []).filter(function (structure) { return targetStructureIds.includes(structure.structureId); });
    return { playoffStructures: playoffStructures, structure: structure };
}
function getEventStructures(_a) {
    var e_1, _b, e_2, _c, _d;
    var withStageGrouping = _a.withStageGrouping, stageSequences = _a.stageSequences, stageSequence = _a.stageSequence, roundTarget = _a.roundTarget, stages = _a.stages, event = _a.event, stage = _a.stage;
    if (!event)
        return { error: MISSING_EVENT };
    var stageStructures = {};
    var structures = [];
    try {
        for (var _e = __values(event.drawDefinitions || []), _f = _e.next(); !_f.done; _f = _e.next()) {
            var drawDefinition = _f.value;
            var _g = getDrawStructures({
                withStageGrouping: withStageGrouping,
                stageSequences: stageSequences,
                drawDefinition: drawDefinition,
                stageSequence: stageSequence,
                roundTarget: roundTarget,
                stages: stages,
                stage: stage,
            }), drawStructures = _g.structures, drawStageStructures = _g.stageStructures;
            structures.push.apply(structures, __spreadArray([], __read(drawStructures), false));
            if (drawStageStructures) {
                try {
                    for (var _h = (e_2 = void 0, __values(Object.keys(drawStageStructures))), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var stage_1 = _j.value;
                        if (!stageStructures[stage_1])
                            stageStructures[stage_1] = [];
                        (_d = stageStructures[stage_1]).push.apply(_d, __spreadArray([], __read(drawStageStructures[stage_1]), false));
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { structures: structures, stageStructures: stageStructures };
}
function getTournamentStructures(_a) {
    var e_3, _b, e_4, _c, _d;
    var withStageGrouping = _a.withStageGrouping, tournamentRecord = _a.tournamentRecord, stageSequences = _a.stageSequences, stageSequence = _a.stageSequence, roundTarget = _a.roundTarget, stages = _a.stages, stage = _a.stage;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var stageStructures = {};
    var structures = [];
    try {
        for (var _e = __values(tournamentRecord.events || []), _f = _e.next(); !_f.done; _f = _e.next()) {
            var event_1 = _f.value;
            var _g = getEventStructures({
                withStageGrouping: withStageGrouping,
                stageSequences: stageSequences,
                stageSequence: stageSequence,
                roundTarget: roundTarget,
                stages: stages,
                event: event_1,
                stage: stage,
            }), eventStructures = _g.structures, eventStageStructures = _g.stageStructures;
            if (eventStructures)
                structures.push.apply(structures, __spreadArray([], __read(eventStructures), false));
            if (eventStageStructures) {
                try {
                    for (var _h = (e_4 = void 0, __values(Object.keys(eventStageStructures))), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var stage_2 = _j.value;
                        if (!stageStructures[stage_2])
                            stageStructures[stage_2] = [];
                        (_d = stageStructures[stage_2]).push.apply(_d, __spreadArray([], __read(eventStageStructures[stage_2]), false));
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return { structures: structures, stageStructures: stageStructures };
}

function isCompletedStructure(params) {
    if (!(params === null || params === void 0 ? void 0 : params.drawDefinition))
        return false;
    var structureMatchUps = getStructureMatchUps(params);
    var includesTeamMatchUps = structureMatchUps === null || structureMatchUps === void 0 ? void 0 : structureMatchUps.includesTeamMatchUps;
    var _a = structureMatchUps || {}, completedMatchUps = _a.completedMatchUps, pendingMatchUps = _a.pendingMatchUps, upcomingMatchUps = _a.upcomingMatchUps;
    if (includesTeamMatchUps) {
        completedMatchUps = completedMatchUps === null || completedMatchUps === void 0 ? void 0 : completedMatchUps.filter(function (_a) {
            var matchUpType = _a.matchUpType;
            return matchUpType === TEAM;
        });
        pendingMatchUps = pendingMatchUps === null || pendingMatchUps === void 0 ? void 0 : pendingMatchUps.filter(function (_a) {
            var matchUpType = _a.matchUpType;
            return matchUpType === TEAM;
        });
        upcomingMatchUps = upcomingMatchUps === null || upcomingMatchUps === void 0 ? void 0 : upcomingMatchUps.filter(function (_a) {
            var matchUpType = _a.matchUpType;
            return matchUpType === TEAM;
        });
    }
    var isComplete = (completedMatchUps === null || completedMatchUps === void 0 ? void 0 : completedMatchUps.length) &&
        !(pendingMatchUps === null || pendingMatchUps === void 0 ? void 0 : pendingMatchUps.length) &&
        !(upcomingMatchUps === null || upcomingMatchUps === void 0 ? void 0 : upcomingMatchUps.length);
    return !!isComplete;
}
function allPlayoffPositionsFilled(params) {
    var _a, _b, _c;
    var drawDefinition = params.drawDefinition, structureId = params.structureId;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var playoffStructures = getPlayoffStructures({
        drawDefinition: drawDefinition,
        structureId: structureId,
    }).playoffStructures;
    if (!(playoffStructures === null || playoffStructures === void 0 ? void 0 : playoffStructures.length))
        return false;
    var enteredParticipantsCount = (_c = (_b = (_a = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) === null || _a === void 0 ? void 0 : _a.filter(function (entry) {
        return (entry === null || entry === void 0 ? void 0 : entry.entryStatus) &&
            STRUCTURE_SELECTED_STATUSES.includes(entry.entryStatus);
    })) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
    var participantIdsCount = 0;
    var allPositionsFilled = (playoffStructures || []).reduce(function (allFilled, structure) {
        var _a;
        var positionAssignments = (_a = getPositionAssignments$1({ structure: structure }).positionAssignments) !== null && _a !== void 0 ? _a : [];
        var structurePositionsFilled = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) {
            var _a;
            if (assignment.participantId)
                participantIdsCount++;
            return (_a = assignment === null || assignment === void 0 ? void 0 : assignment.bye) !== null && _a !== void 0 ? _a : assignment === null || assignment === void 0 ? void 0 : assignment.participantId;
        }).length;
        return !!(structurePositionsFilled && allFilled);
    }, !!playoffStructures.length);
    // account for playoffStructure with only one participant
    var allParticipantIdsPlaced = participantIdsCount === enteredParticipantsCount;
    return allPositionsFilled || allParticipantIdsPlaced;
}

function processAccessors(_a) {
    var significantCharacters = _a.significantCharacters, _b = _a.accessors, accessors = _b === void 0 ? [] : _b, value = _a.value;
    var extractedValues = [];
    var accessor = accessors[0];
    if (value === null || value === void 0 ? void 0 : value[accessor]) {
        var remainingKeys_1 = accessors.slice(1);
        if (Array.isArray(value[accessor])) {
            var values = value[accessor];
            values.forEach(function (nestedValue) {
                var result = processAccessors({
                    accessors: remainingKeys_1,
                    significantCharacters: significantCharacters,
                    value: nestedValue,
                });
                extractedValues.push.apply(extractedValues, __spreadArray([], __read(result), false));
            });
        }
        else {
            value = value[accessor];
            if (remainingKeys_1.length) {
                var result = processAccessors({
                    accessors: remainingKeys_1,
                    significantCharacters: significantCharacters,
                    value: value,
                });
                extractedValues.push.apply(extractedValues, __spreadArray([], __read(result), false));
            }
            else {
                checkValue({ value: value });
            }
        }
    }
    function checkValue(_a) {
        var value = _a.value;
        if (value && ['string', 'number'].includes(typeof value)) {
            var extractedValue = significantCharacters
                ? value.slice(0, significantCharacters)
                : value;
            extractedValues.push(extractedValue);
        }
    }
    return extractedValues;
}

function getAttributeGroupings(_a) {
    var targetParticipantIds = _a.targetParticipantIds, policyAttributes = _a.policyAttributes, idCollections = _a.idCollections, participants = _a.participants;
    if (!Array.isArray(policyAttributes)) {
        return { error: MISSING_POLICY_ATTRIBUTES };
    }
    if (!Array.isArray(participants)) {
        return { error: MISSING_PARTICIPANTS };
    }
    var groupings = {};
    targetParticipantIds.forEach(function (participantId) {
        var participant = participants.find(function (candidate) { return candidate.participantId === participantId; });
        var values = extractAttributeValues({
            policyAttributes: policyAttributes,
            idCollections: idCollections,
            participants: participants,
            participant: participant,
        }).values;
        if (values) {
            values.forEach(function (value) {
                if (!groupings[value])
                    groupings[value] = [];
                if (!groupings[value].includes(participantId)) {
                    groupings[value].push(participantId);
                }
            });
        }
    });
    return groupings;
}
function extractAttributeValues(_a) {
    var policyAttributes = _a.policyAttributes, idCollections = _a.idCollections, participants = _a.participants, participant = _a.participant;
    if (!Array.isArray(policyAttributes)) {
        return { error: MISSING_POLICY_ATTRIBUTES };
    }
    if (!participant) {
        return { error: MISSING_PARTICIPANT };
    }
    var extractedValues = [];
    policyAttributes.forEach(function (policyAttribute) {
        var _a = policyAttribute || {}, directive = _a.directive, groupings = _a.groupings, key = _a.key, significantCharacters = _a.significantCharacters;
        if (key) {
            var accessors = key.split('.');
            extractedValues.push.apply(extractedValues, __spreadArray([], __read(processAccessors({
                significantCharacters: significantCharacters,
                value: participant,
                accessors: accessors,
            })), false));
        }
        else if (directive) {
            // extractedValues are values to be avoided
            // e.g. for { directive: 'pairParticipants' } the extractedValues would be [ 'partnerParticipantId' ]
            var includeIds_1 = policyAttribute === null || policyAttribute === void 0 ? void 0 : policyAttribute.includeIds;
            var collectionIds = ((idCollections === null || idCollections === void 0 ? void 0 : idCollections[directive]) || []).filter(function (participantId) { return !includeIds_1 || includeIds_1.includes(participantId); });
            if ((collectionIds === null || collectionIds === void 0 ? void 0 : collectionIds.length) && (participants === null || participants === void 0 ? void 0 : participants.length)) {
                collectionIds.forEach(function (collectionParticipantId) {
                    var _a;
                    var collectionParticipant = participants.find(function (participant) {
                        return participant.participantId === collectionParticipantId;
                    });
                    if ((_a = collectionParticipant === null || collectionParticipant === void 0 ? void 0 : collectionParticipant.individualParticipantIds) === null || _a === void 0 ? void 0 : _a.includes(participant.participantId)) {
                        var participantId = collectionParticipant === null || collectionParticipant === void 0 ? void 0 : collectionParticipant.participantId;
                        extractedValues.push(participantId);
                    }
                });
            }
        }
        else if (groupings) {
            Object.keys(groupings).forEach(function (key) {
                if (groupings[key].includes(participant.participantId)) {
                    extractedValues.push(key);
                }
            });
        }
    });
    var values = unique(extractedValues);
    return { values: values };
}

function getPositionedParticipants(_a) {
    var candidatePositionAssignments = _a.candidatePositionAssignments, participantsWithGroupings = _a.participantsWithGroupings, policyAttributes = _a.policyAttributes, idCollections = _a.idCollections;
    var participantsMap = Object.assign.apply(Object, __spreadArray([{}], __read(participantsWithGroupings.map(function (participant) {
        var _a;
        return (_a = {},
            _a[participant.participantId] = participant,
            _a);
    })), false));
    return candidatePositionAssignments.map(function (assignment) {
        var participant = participantsMap[assignment.participantId];
        var values = extractAttributeValues({
            participants: participantsWithGroupings,
            policyAttributes: policyAttributes,
            idCollections: idCollections,
            participant: participant,
        }).values;
        return __assign(__assign({}, assignment), { values: values });
    });
}

/**
 *
 * @param {string[]} allGroups - group names derived from participant attributes which match policyAttributes
 * @param {string[]} groupsToAvoid - names of groups which contain the participantId currently being placed
 * @param {object[]} positionAssignments - array of assignment objects { drawPosition, participantId }
 *
 */
function getPositionProfiles(_a) {
    var participantIdGroups = _a.participantIdGroups, positionAssignments = _a.positionAssignments, groupsToAvoid = _a.groupsToAvoid;
    return Object.assign.apply(Object, __spreadArray([{}], __read(positionAssignments
        .filter(function (assignment) { return assignment === null || assignment === void 0 ? void 0 : assignment.participantId; })
        .map(function (assginment) {
        var _a;
        var drawPosition = assginment.drawPosition, participantId = assginment.participantId;
        var participantGroups = participantIdGroups
            ? participantIdGroups[participantId] || []
            : [];
        var includesGroupsToAvoid = !!groupsToAvoid.some(function (group) {
            return participantGroups.includes(group);
        });
        return _a = {}, _a[drawPosition] = { participantGroups: participantGroups, includesGroupsToAvoid: includesGroupsToAvoid }, _a;
    })), false));
}
/**
 *
 * @param {string[]} allGroups - group names derived from participant attributes which match policyAttributes
 * @param {string[]} groupsToAvoid - names of groups which contain the participantId currently being placed
 * @param {number[]} unfilledPositions - drawPositions which have not been assigned a participantid
 * @param {object[]} positionAssignments - array of assignment objects { drawPosition, participantId }
 * @param {object[]} chunkedDrawPositions - array of arrays of drawPositions
 *
 * Returns different types of placement options.
 * 1. positions which are unassigned
 * 2. unassigned positions which are not paired with any other participantId
 * 3. unassigned positions which are paired and which have no conflicting groupings (groupings to avoid)
 *
 */
function analyzeEliminationDrawPositions(params) {
    var unfilledPositions = params.unfilledPositions, chunkedDrawPositions = params.chunkedDrawPositions;
    var profiledPositions = getPositionProfiles(params);
    var checkedChunk = chunkedDrawPositions.map(function (chunkedGrouping) {
        var unassigned = unfilledPositions.filter(function (unfilledPosition) {
            return chunkedGrouping.includes(unfilledPosition);
        });
        var unpaired = unpairedPositions(unassigned);
        var paired = unassigned.filter(function (drawPosition) { return !unpaired.includes(drawPosition); });
        var pairedNoConflict = paired.filter(function (drawPosition) {
            var _a;
            var pairedPosition = getPairedPosition(drawPosition);
            return !((_a = profiledPositions[pairedPosition]) === null || _a === void 0 ? void 0 : _a.includesGroupsToAvoid);
        });
        return { unassigned: unassigned, unpaired: unpaired, pairedNoConflict: pairedNoConflict };
    });
    return checkedChunk;
    function unpairedPositions(unassigned) {
        return unassigned.filter(function (u) { return !pairAssigned(u); });
        function pairAssigned(drawPosition) {
            var pairedPosition = getPairedPosition(drawPosition);
            return !unassigned.includes(pairedPosition);
        }
    }
}
/**
 *
 * @param {string[]} allGroups - group names derived from participant attributes which match policyAttributes
 * @param {string[]} groupsToAvoid - names of groups which contain the participantId currently being placed
 * @param {number[]} unfilledPositions - drawPositions which have not been assigned a participantid
 * @param {object[]} positionAssignments - array of assignment objects
 * @param {object[]} chunkedDrawPositions - array of arrays of drawPositions
 *
 * Returns different types of placement options.
 * 1. positions which are unassigned
 * 2. unassigned positions which are not paired with any other participantId
 * 3. unassigned positions which are paired and which have no conflicting groupings (groupings to avoid)
 *
 */
function analyzeRoundRobinDrawPositions(params) {
    var unfilledPositions = params.unfilledPositions, chunkedDrawPositions = params.chunkedDrawPositions;
    var profiledPositions = getPositionProfiles(params);
    return chunkedDrawPositions.map(function (chunkedGrouping) {
        var unassigned = unfilledPositions.filter(function (unfilledPosition) {
            return chunkedGrouping.includes(unfilledPosition);
        });
        var unpaired = unassigned.length === chunkedGrouping.length ? unassigned : [];
        var conflictsCount = chunkedGrouping.filter(function (drawPosition) { var _a; return (_a = profiledPositions[drawPosition]) === null || _a === void 0 ? void 0 : _a.includesGroupsToAvoid; }).length;
        var pairedNoConflict = conflictsCount ? [] : unassigned;
        return { unassigned: unassigned, unpaired: unpaired, pairedNoConflict: pairedNoConflict, conflictsCount: conflictsCount };
    });
}
/**
 *
 * @param {string} drawPosition
 *
 * Returns paired position for first round matches in elimination structures
 */
function getPairedPosition(drawPosition) {
    return Number(drawPosition % 2 ? drawPosition + 1 : drawPosition - 1);
}
/**
 *
 * @param {sring[]} allGroups - array of group names (attribute values) for all groups under consideration
 * @param {string} participantId - ID of the participant in question
 *
 * Returns the group name for all groups including participantid
 *
 */
function getParticipantGroups(_a) {
    var allGroups = _a.allGroups, participantId = _a.participantId;
    return Object.keys(allGroups).filter(function (key) {
        return allGroups[key].includes(participantId);
    });
}

/**
 *
 * @param {string[]} allGroups - group names derived from participant attributes which match policyAttributes
 * @param {number[]} unfilledPositions - drawPositions which have not been assigned a participantid
 * @param {object[]} drawPositionChunks - ranges of drawPositions grouped by levels of separation
 * @param {object[]} positionAssignments - array of assignment objects
 * @param {boolean} isRoundRobin - use round robin draw position analysis
 * @param {string[]} selectedParticipantGroups - names of groups which contain the participantId currently being placed
 *
 * Returns different types of placement options.
 * Similar to analyzeDraawPositions, but aggregates options.
 * Options are arranged from largest to smallest chunk sizes.
 * To achieve maximum separation start with largest chunk sizes.
 *
 * 1. positions which are unassigned
 * 2. unassigned positions which are not paired with any other participantId
 * 3. unassigned positions which are paired and which have no conflicting groupings (groupings to avoid)
 *
 */
function organizeDrawPositionOptions(_a) {
    var selectedParticipantGroups = _a.selectedParticipantGroups, participantIdGroups = _a.participantIdGroups, positionAssignments = _a.positionAssignments, drawPositionChunks = _a.drawPositionChunks, unfilledPositions = _a.unfilledPositions, isRoundRobin = _a.isRoundRobin;
    var vettedChunks = drawPositionChunks.map(function (chunkedDrawPositions) {
        if (isRoundRobin) {
            return analyzeRoundRobinDrawPositions({
                groupsToAvoid: selectedParticipantGroups,
                chunkedDrawPositions: chunkedDrawPositions,
                participantIdGroups: participantIdGroups,
                positionAssignments: positionAssignments,
                unfilledPositions: unfilledPositions,
            });
        }
        else {
            return analyzeEliminationDrawPositions({
                groupsToAvoid: selectedParticipantGroups,
                chunkedDrawPositions: chunkedDrawPositions,
                participantIdGroups: participantIdGroups,
                positionAssignments: positionAssignments,
                unfilledPositions: unfilledPositions,
            });
        }
    });
    // each type of vettedChunk is first extracted and filtered...
    // ...then combined with others of the same type and filtered
    if (isRoundRobin) {
        var unassigned = vettedChunks
            .map(function (chunk) {
            return chunk
                .map(function (grouping) { return grouping.unassigned; })
                .filter(function (unassigned) { return unassigned === null || unassigned === void 0 ? void 0 : unassigned.length; });
        })
            .filter(function (f) { return f === null || f === void 0 ? void 0 : f.length; })
            .sort(function (a, b) { return (b.length || 0) - (a.length || 0); });
        var unpaired = vettedChunks
            .map(function (chunk) {
            return chunk
                .map(function (grouping) { return grouping.unpaired; })
                .filter(function (unpaired) { return unpaired === null || unpaired === void 0 ? void 0 : unpaired.length; });
        })
            .filter(function (f) { return f === null || f === void 0 ? void 0 : f.length; });
        var pairedNoConflict = vettedChunks
            .map(function (chunk) {
            return chunk
                .map(function (grouping) { return grouping.pairedNoConflict; })
                .filter(function (pairedNoConflict) { return pairedNoConflict === null || pairedNoConflict === void 0 ? void 0 : pairedNoConflict.length; });
        })
            .filter(function (f) { return f === null || f === void 0 ? void 0 : f.length; })
            .sort(function (a, b) { return (b.length || 0) - (a.length || 0); });
        return { unassigned: unassigned, unpaired: unpaired, pairedNoConflict: pairedNoConflict };
    }
    else {
        var unassigned = vettedChunks
            .map(function (chunk) {
            return chunk
                .map(function (grouping) { return grouping.unassigned; })
                .filter(function (unassigned) { return unassigned === null || unassigned === void 0 ? void 0 : unassigned.length; });
        })
            .filter(function (f) { return f === null || f === void 0 ? void 0 : f.length; });
        var unpaired = vettedChunks
            .map(function (chunk) {
            return chunk
                .map(function (grouping) { return grouping.unpaired; })
                .filter(function (unpaired) { return unpaired === null || unpaired === void 0 ? void 0 : unpaired.length; });
        })
            .filter(function (f) { return f === null || f === void 0 ? void 0 : f.length; });
        var pairedNoConflict = vettedChunks
            .map(function (chunk) {
            return chunk
                .map(function (grouping) { return grouping.pairedNoConflict; })
                .filter(function (pairedNoConflict) { return pairedNoConflict === null || pairedNoConflict === void 0 ? void 0 : pairedNoConflict.length; });
        })
            .filter(function (f) { return f === null || f === void 0 ? void 0 : f.length; });
        return { unassigned: unassigned, unpaired: unpaired, pairedNoConflict: pairedNoConflict };
    }
}

function getUnplacedParticipantIds(_a) {
    var positionAssignments = _a.positionAssignments, participantIds = _a.participantIds;
    var assignedParticipantIds = positionAssignments.map(function (assignment) { return assignment.participantId; });
    return participantIds.filter(function (participantId) { return !assignedParticipantIds.includes(participantId); });
}

function getNextParticipantId(_a) {
    var _b;
    var _c = _a.useSpecifiedGroupKey, useSpecifiedGroupKey = _c === void 0 ? false : _c, targetParticipantIds = _a.targetParticipantIds, _d = _a.largestFirst, largestFirst = _d === void 0 ? true : _d, allGroups = _a.allGroups, groupKey = _a.groupKey;
    var groupings = Object.assign.apply(Object, __spreadArray([{}], __read(Object.keys(allGroups)
        .map(function (group) { return [
        group,
        allGroups[group].filter(function (id) { return targetParticipantIds.includes(id); }),
    ]; })
        .filter(function (item) { return item[1].length; })
        .map(function (_a) {
        var _b;
        var _c = __read(_a, 2), group = _c[0], ids = _c[1];
        return (_b = {}, _b[group] = ids, _b);
    })), false));
    var largestGroupSize = Object.keys(groupings).reduce(function (size, key) {
        return groupings[key].length > size ? groupings[key].length : size;
    }, 0);
    var largestSizedGroupings = Object.keys(groupings).filter(function (key) { return groupings[key].length === largestGroupSize; });
    var randomGroupKey = largestFirst
        ? randomMember(largestSizedGroupings)
        : randomMember(Object.keys(groupings));
    groupKey =
        useSpecifiedGroupKey && ((_b = groupings[groupKey]) === null || _b === void 0 ? void 0 : _b.length)
            ? groupKey
            : randomGroupKey;
    var participantId = groupKey && groupings[groupKey]
        ? randomMember(groupings[groupKey])
        : randomMember(targetParticipantIds);
    return { participantId: participantId, groupKey: groupKey };
}

/**
 *
 * @param {object[]} matchUps
 * @param {object[]} positionAssignments - assignment objects which associate drawPositions with participantIds
 *
 * Returns an array of drawPositions which have not been filled
 */
function getUnfilledPositions(_a) {
    var drawPositionGroups = _a.drawPositionGroups, positionAssignments = _a.positionAssignments;
    var assignmentMap = Object.assign.apply(Object, __spreadArray([{}], __read(positionAssignments.map(function (assignment) {
        var _a;
        return (_a = {},
            _a[assignment.drawPosition] = assignment,
            _a);
    })), false));
    return drawPositionGroups
        .map(function (drawPositions) {
        return drawPositions
            .filter(Boolean)
            .map(function (drawPosition) { return assignmentMap[drawPosition]; })
            .filter(Boolean)
            .filter(function (assignment) { return !assignment.participantId && !assignment.bye; })
            .map(function (assignment) { return assignment.drawPosition; });
    })
        .flat()
        .filter(Boolean);
}

function getParticipantPlacement(_a) {
    var candidatePositionAssignments = _a.candidatePositionAssignments, unseededParticipantIds = _a.unseededParticipantIds, participantIdGroups = _a.participantIdGroups, drawPositionChunks = _a.drawPositionChunks, drawPositionGroups = _a.drawPositionGroups, pairedPriority = _a.pairedPriority, allGroups = _a.allGroups, groupKey = _a.groupKey;
    var largestGroupSize = drawPositionGroups.reduce(function (largest, group) {
        return group.length > largest ? group.length : largest;
    }, 0);
    var useSpecifiedGroupKey = largestGroupSize <= 2;
    var targetParticipantIds = getUnplacedParticipantIds({
        positionAssignments: candidatePositionAssignments,
        participantIds: unseededParticipantIds,
    });
    var unfilledPositions = getUnfilledPositions({
        positionAssignments: candidatePositionAssignments,
        drawPositionGroups: drawPositionGroups,
    });
    var _b = getNextParticipantId({
        targetParticipantIds: targetParticipantIds,
        useSpecifiedGroupKey: useSpecifiedGroupKey,
        allGroups: allGroups,
        groupKey: groupKey,
    }), selectedParticipantId = _b.participantId, newGroupKey = _b.groupKey;
    var selectedParticipantGroups = getParticipantGroups({
        participantId: selectedParticipantId,
        allGroups: allGroups,
    });
    var drawPositionOptions = organizeDrawPositionOptions({
        positionAssignments: candidatePositionAssignments,
        isRoundRobin: useSpecifiedGroupKey,
        selectedParticipantGroups: selectedParticipantGroups,
        participantIdGroups: participantIdGroups,
        drawPositionChunks: drawPositionChunks,
        unfilledPositions: unfilledPositions,
    });
    var unassigned = drawPositionOptions.unassigned, unpaired = drawPositionOptions.unpaired, pairedNoConflict = drawPositionOptions.pairedNoConflict;
    // the first element of each options array represents the greatest possible round separation
    var pnc = (pairedNoConflict === null || pairedNoConflict === void 0 ? void 0 : pairedNoConflict.length) && pairedNoConflict[0];
    var up = (unpaired === null || unpaired === void 0 ? void 0 : unpaired.length) && unpaired[0];
    var desiredOptions = pairedPriority && pnc ? pnc : up;
    var fallbackOptions = pairedPriority ? up : pnc;
    var prioritizedOptions = ((desiredOptions === null || desiredOptions === void 0 ? void 0 : desiredOptions.length) && desiredOptions) ||
        ((fallbackOptions === null || fallbackOptions === void 0 ? void 0 : fallbackOptions.length) && fallbackOptions);
    var targetDrawPosition;
    if (prioritizedOptions === null || prioritizedOptions === void 0 ? void 0 : prioritizedOptions.length) {
        var section = randomPop(prioritizedOptions);
        targetDrawPosition = randomPop(section);
    }
    else {
        var section = randomPop(unassigned[0]);
        targetDrawPosition = randomPop(section);
    }
    return { newGroupKey: newGroupKey, selectedParticipantId: selectedParticipantId, targetDrawPosition: targetDrawPosition };
}

function getAvoidanceConflicts(_a) {
    var isRoundRobin = _a.isRoundRobin, groupedParticipants = _a.groupedParticipants;
    var avoidanceConflicts = [];
    if (isRoundRobin) {
        groupedParticipants.forEach(function (participantGroup) {
            var drawPositions = participantGroup.map(function (participant) { return participant.drawPosition; });
            var uniqueMatchUpGroupings = getRoundRobinGroupMatchUps({
                drawPositions: drawPositions,
            }).uniqueMatchUpGroupings;
            var drawPositionValuesMap = Object.assign.apply(Object, __spreadArray([{}], __read(participantGroup.map(function (participant) {
                var _a;
                return (_a = {},
                    _a[participant.drawPosition] = participant,
                    _a);
            })), false));
            uniqueMatchUpGroupings.forEach(function (grouping) {
                var avoidanceConflict = overlap(drawPositionValuesMap[grouping[0]].values || [], drawPositionValuesMap[grouping[1]].values || []);
                if (avoidanceConflict) {
                    avoidanceConflicts.push(grouping);
                    participantGroup.conflict = true;
                }
            });
        });
    }
    else {
        groupedParticipants.forEach(function (matchUpPair) {
            var _a, _b;
            var avoidanceConflict = overlap(((_a = matchUpPair[0]) === null || _a === void 0 ? void 0 : _a.values) || [], ((_b = matchUpPair[1]) === null || _b === void 0 ? void 0 : _b.values) || []);
            if (avoidanceConflict) {
                avoidanceConflicts.push(matchUpPair);
                matchUpPair.conflict = true;
            }
        });
    }
    return avoidanceConflicts;
}

function getSwapOptions(_a) {
    var positionedParticipants = _a.positionedParticipants, potentialDrawPositions = _a.potentialDrawPositions, drawPositionGroups = _a.drawPositionGroups, avoidanceConflicts = _a.avoidanceConflicts, isRoundRobin = _a.isRoundRobin;
    return avoidanceConflicts
        .map(function (conflict) {
        var drawPositions = conflict.map(function (c) { return c.drawPosition; });
        var moveableParticipants = conflict.filter(function (placedParticipant) {
            return potentialDrawPositions.includes(placedParticipant.drawPosition);
        });
        return moveableParticipants
            .map(function (moveableParticipant) {
            var possibleDrawPositions = potentialDrawPositions.filter(function (position) { return !(drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(position)); });
            var possibleDrawPositionsNoConflict = possibleDrawPositions.filter(function (possibleDrawPosition) {
                var potentialOpponentDrawPosition = drawPositionGroups
                    .find(function (pair) { return pair.includes(possibleDrawPosition); })
                    .find(function (drawPosition) { return drawPosition !== possibleDrawPosition; });
                var potentialOpponent = positionedParticipants.find(function (placement) {
                    return placement.drawPosition === potentialOpponentDrawPosition;
                });
                var possibleDrawPositionGroup = [
                    moveableParticipant,
                    potentialOpponent,
                ];
                var conflictPotential = getAvoidanceConflicts({
                    isRoundRobin: isRoundRobin,
                    groupedParticipants: [possibleDrawPositionGroup],
                });
                var swappedParticipant = positionedParticipants.find(function (placement) { return placement.drawPosition === possibleDrawPosition; });
                var possibleExistingOpponentGroup = [
                    swappedParticipant,
                    potentialOpponent,
                ];
                var existingOpponentConflictPotential = getAvoidanceConflicts({
                    isRoundRobin: isRoundRobin,
                    groupedParticipants: [possibleExistingOpponentGroup],
                });
                return (!conflictPotential.length &&
                    !existingOpponentConflictPotential.length);
            });
            if (possibleDrawPositionsNoConflict.length) {
                return {
                    drawPosition: moveableParticipant.drawPosition,
                    possibleDrawPositions: possibleDrawPositionsNoConflict,
                };
            }
            return undefined;
        })
            .filter(Boolean);
    })
        .flat(1);
}

function generatePositioningCandidate(params) {
    var initialPositionAssignments = params.initialPositionAssignments, participantsWithGroupings = params.participantsWithGroupings, opponentsToPlaceCount = params.opponentsToPlaceCount, unseededByePositions = params.unseededByePositions, drawPositionGroups = params.drawPositionGroups, policyAttributes = params.policyAttributes, idCollections = params.idCollections, allGroups = params.allGroups;
    var errors = [];
    var groupKey;
    var groupSize = Math.min.apply(Math, __spreadArray([], __read((drawPositionGroups || []).map(function (dpg) { return dpg === null || dpg === void 0 ? void 0 : dpg.length; }).filter(Boolean)), false));
    var isRoundRobin = groupSize > 2;
    var candidatePositionAssignments = makeDeepCopy(initialPositionAssignments, false, true).filter(function (assignment) { return !assignment.qualifier; });
    // all drawPositions which are available for placement
    var potentialDrawPositions = initialPositionAssignments
        .filter(function (assignment) {
        return !assignment.participantId &&
            (!assignment.bye ||
                (unseededByePositions === null || unseededByePositions === void 0 ? void 0 : unseededByePositions.includes(assignment.drawPosition)));
    })
        .map(function (assignment) { return assignment.drawPosition; });
    generateRange(0, opponentsToPlaceCount).forEach(function () {
        var _a = getParticipantPlacement(__assign(__assign({}, params), { candidatePositionAssignments: candidatePositionAssignments, allGroups: allGroups, groupKey: groupKey })), newGroupKey = _a.newGroupKey, selectedParticipantId = _a.selectedParticipantId, targetDrawPosition = _a.targetDrawPosition;
        groupKey = newGroupKey;
        candidatePositionAssignments.forEach(function (assignment) {
            if (assignment.drawPosition === targetDrawPosition) {
                assignment.participantId = selectedParticipantId;
            }
        });
    });
    var positionedParticipants = getPositionedParticipants({
        candidatePositionAssignments: candidatePositionAssignments,
        participantsWithGroupings: participantsWithGroupings,
        policyAttributes: policyAttributes,
        idCollections: idCollections,
    });
    var groupedParticipants = chunkArray(positionedParticipants, groupSize);
    var avoidanceConflicts = getAvoidanceConflicts({
        groupedParticipants: groupedParticipants,
        isRoundRobin: isRoundRobin,
    });
    var attempts = 0;
    while (attempts < 20 && avoidanceConflicts.length) {
        var swapOptions = getSwapOptions({
            positionedParticipants: positionedParticipants,
            potentialDrawPositions: potentialDrawPositions,
            avoidanceConflicts: avoidanceConflicts,
            drawPositionGroups: drawPositionGroups,
            isRoundRobin: isRoundRobin,
        });
        if (swapOptions.length) {
            var result = swapAssignedPositions({
                candidatePositionAssignments: candidatePositionAssignments,
                swapOptions: swapOptions,
            });
            if (result.error)
                console.log({ result: result });
            positionedParticipants = getPositionedParticipants({
                candidatePositionAssignments: candidatePositionAssignments,
                participantsWithGroupings: participantsWithGroupings,
                policyAttributes: policyAttributes,
                idCollections: idCollections,
            });
            groupedParticipants = chunkArray(positionedParticipants, groupSize);
            avoidanceConflicts = getAvoidanceConflicts({
                groupedParticipants: groupedParticipants,
                isRoundRobin: isRoundRobin,
            });
            attempts++;
        }
        else {
            attempts = 20;
        }
    }
    candidatePositionAssignments.forEach(function (assignment) {
        // TODO: Investigate this scenario
        if (assignment.bye && assignment.participantId) {
            var error = INVALID_ASSIGNMENT;
            errors.push(error);
        }
        if (assignment.qualifier && assignment.participantId) {
            var error = INVALID_ASSIGNMENT;
            errors.push(error);
        }
    });
    return {
        positionAssignments: candidatePositionAssignments,
        conflicts: avoidanceConflicts.length,
        groupedParticipants: groupedParticipants,
        errors: errors,
    };
}
function swapAssignedPositions(_a) {
    var _b;
    var candidatePositionAssignments = _a.candidatePositionAssignments, swapOptions = _a.swapOptions;
    var swapOption = randomPop(swapOptions);
    if (!swapOption)
        return { error: { message: 'No swap options' } };
    var firstPosition = swapOption.drawPosition;
    var secondPosition = randomPop(swapOption.possibleDrawPositions);
    var firstAssignment = candidatePositionAssignments.find(function (assignment) { return assignment.drawPosition === firstPosition; });
    var secondAssignment = (_b = candidatePositionAssignments.find(function (assignment) { return assignment.drawPosition === secondPosition; })) !== null && _b !== void 0 ? _b : {};
    var updatedFirstAssignmentAttributes = {
        participantId: secondAssignment === null || secondAssignment === void 0 ? void 0 : secondAssignment.participantId,
        qualifier: secondAssignment === null || secondAssignment === void 0 ? void 0 : secondAssignment.qualifier,
        bye: secondAssignment === null || secondAssignment === void 0 ? void 0 : secondAssignment.bye,
    };
    var updatedSecondAssignmentAttributes = {
        participantId: firstAssignment.participantId,
        qualifier: firstAssignment.qualifier,
        bye: firstAssignment.bye,
    };
    Object.assign(firstAssignment, updatedFirstAssignmentAttributes);
    Object.assign(secondAssignment, updatedSecondAssignmentAttributes);
    return __assign({}, SUCCESS);
}

function randomUnseededSeparation(_a) {
    var e_1, _b;
    var _c, _d;
    var provisionalPositioning = _a.provisionalPositioning, unseededParticipantIds = _a.unseededParticipantIds, inContextDrawMatchUps = _a.inContextDrawMatchUps, unseededByePositions = _a.unseededByePositions, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, seedBlockInfo = _a.seedBlockInfo, participants = _a.participants, matchUpsMap = _a.matchUpsMap, structureId = _a.structureId, avoidance = _a.avoidance, drawSize = _a.drawSize, 
    // entries, // entries for the specific stage of drawDefinition
    event = _a.event;
    if (!avoidance) {
        return { error: MISSING_AVOIDANCE_POLICY };
    }
    var _e = avoidance.candidatesCount, candidatesCount = _e === void 0 ? 1 : _e, policyAttributes = avoidance.policyAttributes, targetDivisions = avoidance.targetDivisions;
    var roundsToSeparate = avoidance.roundsToSeparate;
    var stack = 'randomUnseededSeparation';
    // policyAttributes determines participant attributes which are to be used for avoidance
    // roundsToSeparate determines desired degree of separation between players with matching attribute values
    // targetDivisions derives roundsToSeparate from the number of rounds
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    var matchUps = getAllStructureMatchUps({
        provisionalPositioning: provisionalPositioning,
        matchUpsMap: matchUpsMap,
        structure: structure,
        event: event,
    }).matchUps;
    if (targetDivisions && isPowerOf2(targetDivisions) && !roundsToSeparate) {
        var exponent = deriveExponent(targetDivisions) || 0;
        var roundsCount = matchUps.reduce(function (count, matchUp) {
            return matchUp.roundNumber > count ? matchUp.roundNumber : count;
        }, 0);
        roundsToSeparate = roundsCount < exponent ? 1 : roundsCount - exponent + 1;
    }
    var positionAssignments = structureAssignedDrawPositions({ structure: structure }).positionAssignments;
    var participantsWithGroupings = addParticipantGroupings({
        participantsProfile: { convertExtensions: true },
        deepCopy: false,
        participants: participants,
    }).participantsWithGroupings;
    var unassignedPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) { return !assignment.participantId; });
    var allDrawPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.map(function (assignment) { return assignment.drawPosition; });
    var isRoundRobin = (structure === null || structure === void 0 ? void 0 : structure.structureType) === CONTAINER;
    var params = isRoundRobin
        ? { structure: structure, matchUps: matchUps, allDrawPositions: allDrawPositions, roundsToSeparate: roundsToSeparate }
        : { matchUps: matchUps, allDrawPositions: allDrawPositions, roundsToSeparate: roundsToSeparate };
    var _f = isRoundRobin
        ? roundRobinParticipantGroups(params)
        : eliminationParticipantGroups(params), drawPositionGroups = _f.drawPositionGroups, drawPositionChunks = _f.drawPositionChunks;
    var idCollections = {
        groupParticipants: participants
            .filter(function (participant) { return participant.participantType === GROUP; })
            .map(function (participant) { return participant.participantId; }),
        teamParticipants: participants
            .filter(function (participant) { return participant.participantType === TEAM$1; })
            .map(function (participant) { return participant.participantId; }),
        pairParticipants: participants
            .filter(function (participant) { return participant.participantType === PAIR; })
            .map(function (participant) { return participant.participantId; }),
    };
    var allGroups = getAttributeGroupings({
        targetParticipantIds: unseededParticipantIds,
        policyAttributes: policyAttributes,
        idCollections: idCollections,
        participants: participants,
    });
    if (allGroups.error) {
        return decorateResult({ result: allGroups, stack: stack });
    }
    var participantIdGroups = Object.assign.apply(Object, __spreadArray([{}], __read(unseededParticipantIds.map(function (participantId) {
        var _a;
        var groups = Object.keys(allGroups).filter(function (key) { var _a; return ((_a = allGroups[key]) !== null && _a !== void 0 ? _a : []).includes(participantId); });
        return _a = {}, _a[participantId] = groups, _a;
    })), false));
    var unplacedParticipantIds = getUnplacedParticipantIds({
        participantIds: unseededParticipantIds,
        positionAssignments: positionAssignments,
    });
    if (unplacedParticipantIds.length > ((unassignedPositions === null || unassignedPositions === void 0 ? void 0 : unassignedPositions.length) || 0)) {
        return { error: INSUFFICIENT_DRAW_POSITIONS };
    }
    var candidate;
    var opponentsToPlaceCount = unplacedParticipantIds.length;
    var noPairPriorityCandidates = generateRange(0, candidatesCount).map(function () {
        return generatePositioningCandidate({
            initialPositionAssignments: positionAssignments,
            participantsWithGroupings: participantsWithGroupings,
            unseededParticipantIds: unseededParticipantIds,
            opponentsToPlaceCount: opponentsToPlaceCount,
            pairedPriority: false,
            unseededByePositions: unseededByePositions,
            participantIdGroups: participantIdGroups,
            drawPositionChunks: drawPositionChunks,
            drawPositionGroups: drawPositionGroups,
            policyAttributes: policyAttributes,
            idCollections: idCollections,
            allGroups: allGroups,
            drawSize: drawSize,
        });
    });
    candidate = noPairPriorityCandidates.reduce(function (p, c) { return (!p || (c.conflicts || 0) < (p.conflicts || 0) ? c : p); }, undefined);
    if (!candidate || candidate.conflicts) {
        var pairedPriorityCandidates = generateRange(0, candidatesCount).map(function () {
            return generatePositioningCandidate({
                initialPositionAssignments: positionAssignments,
                participantsWithGroupings: participantsWithGroupings,
                unseededParticipantIds: unseededParticipantIds,
                opponentsToPlaceCount: opponentsToPlaceCount,
                pairedPriority: true,
                unseededByePositions: unseededByePositions,
                participantIdGroups: participantIdGroups,
                drawPositionChunks: drawPositionChunks,
                drawPositionGroups: drawPositionGroups,
                policyAttributes: policyAttributes,
                idCollections: idCollections,
                allGroups: allGroups,
                drawSize: drawSize,
                // entries,
            });
        });
        var candidates = noPairPriorityCandidates
            .concat.apply(noPairPriorityCandidates, __spreadArray([], __read(pairedPriorityCandidates), false)).filter(function (candidate) { var _a; return !((_a = candidate.errors) === null || _a === void 0 ? void 0 : _a.length); });
        candidate = candidates.reduce(function (p, c) { return (!p || (c.conflicts || 0) < (p.conflicts || 0) ? c : p); }, undefined);
    }
    if (!candidate)
        return { error: NO_CANDIDATES };
    var alreadyAssignedParticipantIds = ((_d = (_c = getPositionAssignments$1({ structure: structure })) === null || _c === void 0 ? void 0 : _c.positionAssignments) !== null && _d !== void 0 ? _d : [])
        .filter(function (assignment) { return assignment.participantId; })
        .map(function (assignment) { return assignment.participantId; });
    var filteredAssignments = candidate.positionAssignments.filter(function (assignment) {
        return !alreadyAssignedParticipantIds.includes(assignment.participantId);
    });
    try {
        for (var filteredAssignments_1 = __values(filteredAssignments), filteredAssignments_1_1 = filteredAssignments_1.next(); !filteredAssignments_1_1.done; filteredAssignments_1_1 = filteredAssignments_1.next()) {
            var assignment = filteredAssignments_1_1.value;
            if (assignment.bye) {
                var result = assignDrawPositionBye(__assign({ tournamentRecord: tournamentRecord, drawDefinition: drawDefinition, seedBlockInfo: seedBlockInfo, structureId: structureId, matchUpsMap: matchUpsMap, event: event }, assignment));
                if (result.error)
                    return decorateResult({ result: result, stack: stack });
            }
            else if (assignment.participantId) {
                var result = assignDrawPosition$1(__assign({ automaticPlacement: true, inContextDrawMatchUps: inContextDrawMatchUps, tournamentRecord: tournamentRecord, drawDefinition: drawDefinition, seedBlockInfo: seedBlockInfo, structureId: structureId, matchUpsMap: matchUpsMap, event: event }, assignment));
                if (result.error) {
                    return decorateResult({ result: result, stack: stack, context: { assignment: assignment } });
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (filteredAssignments_1_1 && !filteredAssignments_1_1.done && (_b = filteredAssignments_1.return)) _b.call(filteredAssignments_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}
function roundRobinParticipantGroups(params) {
    var structures = params.structure.structures;
    var drawPositionGroups = structures.map(function (structure) {
        return structure.positionAssignments.map(function (assignment) { return assignment.drawPosition; });
    });
    return { drawPositionGroups: drawPositionGroups, drawPositionChunks: [drawPositionGroups] };
}
function eliminationParticipantGroups(_a) {
    var allDrawPositions = _a.allDrawPositions, roundsToSeparate = _a.roundsToSeparate, matchUps = _a.matchUps;
    var drawPositionPairs = matchUps
        .filter(function (matchUp) { return matchUp.roundNumber === 1; })
        .map(function (matchUp) { return matchUp.drawPositions; });
    var firstRoundMatchUpDrawPositions = drawPositionPairs
        .flat()
        .sort(numericSort);
    var greatestFirstRoundDrawPosition = Math.max.apply(Math, __spreadArray([], __read(firstRoundMatchUpDrawPositions), false));
    var fedDrawPositions = allDrawPositions.filter(function (drawPositon) { return drawPositon > greatestFirstRoundDrawPosition; });
    var structureSize = firstRoundMatchUpDrawPositions.length;
    var rangeStart = structureSize === 2 ? 1 : 2;
    var roundSizes = generateRange(rangeStart, structureSize).filter(function (f) { return f === nearestPowerOf2(f); });
    var chunkSizes = roundSizes
        .slice(0, roundsToSeparate || roundSizes.length)
        .reverse();
    var drawPositionChunks = chunkSizes.map(function (size) {
        return chunkArray(firstRoundMatchUpDrawPositions, size);
    });
    if (fedDrawPositions.length) {
        // TODO: calculate chunking for fed drawPositions and add to appropriate drawPositionChunks
        // This calculation will be based on "{ roundPosition, roundNumber } = matchUp"
        // ...for matchUps which include fedDrawPositions
        console.log({ fedDrawPositions: fedDrawPositions });
    }
    return { drawPositionGroups: drawPositionPairs, drawPositionChunks: drawPositionChunks };
}

function positionUnseededParticipants(_a) {
    var _b, _c;
    var provisionalPositioning = _a.provisionalPositioning, inContextDrawMatchUps = _a.inContextDrawMatchUps, unseededByePositions = _a.unseededByePositions, multipleStructures = _a.multipleStructures, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, seedBlockInfo = _a.seedBlockInfo, participants = _a.participants, matchUpsMap = _a.matchUpsMap, structureId = _a.structureId, structure = _a.structure, drawSize = _a.drawSize, event = _a.event;
    var stack = 'positionUnseededParticipants';
    if (!structure)
        (structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure);
    if (!structureId)
        (structureId = structure.structureId);
    var positionAssignments = structureAssignedDrawPositions({ structure: structure }).positionAssignments;
    var seedAssignments = getStructureSeedAssignments({
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        structure: structure,
    }).seedAssignments;
    var assignedSeedParticipantIds = seedAssignments === null || seedAssignments === void 0 ? void 0 : seedAssignments.map(function (assignment) { return assignment.participantId; }).filter(Boolean);
    var stage = structure.stage, stageSequence = structure.stageSequence;
    var roundTarget = stage === QUALIFYING
        ? (_c = (_b = findExtension({ element: structure, name: ROUND_TARGET })) === null || _b === void 0 ? void 0 : _b.extension) === null || _c === void 0 ? void 0 : _c.value
        : undefined;
    var entryStatuses = DIRECT_ENTRY_STATUSES;
    var entries = getStageEntries$1({
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        stageSequence: stageSequence,
        entryStatuses: entryStatuses,
        structureId: structureId,
        roundTarget: roundTarget,
        stage: stage,
    });
    var unseededEntries = entries.filter(function (entry) { return !(assignedSeedParticipantIds === null || assignedSeedParticipantIds === void 0 ? void 0 : assignedSeedParticipantIds.includes(entry.participantId)); });
    var unseededParticipantIds = unseededEntries.map(function (entry) { return entry.participantId; });
    var unfilledDrawPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) {
        return (!assignment.participantId && !assignment.bye && !assignment.qualifier);
    }).map(function (assignment) { return assignment.drawPosition; });
    if (!multipleStructures &&
        unseededParticipantIds.length > ((unfilledDrawPositions === null || unfilledDrawPositions === void 0 ? void 0 : unfilledDrawPositions.length) || 0)) {
        return decorateResult({
            result: { error: INSUFFICIENT_DRAW_POSITIONS },
            context: {
                unseededParticipantsCount: unseededParticipantIds.length,
                unfilledDrawPositionsCount: unfilledDrawPositions === null || unfilledDrawPositions === void 0 ? void 0 : unfilledDrawPositions.length,
            },
            stack: stack,
        });
    }
    var appliedPolicies = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        event: event,
    }).appliedPolicies;
    var avoidance = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_AVOIDANCE];
    if (structure.stage === PLAY_OFF) {
        // generate avoidance policies automatically for Playoffs from Round Robin Groups
        var groupings = entries.reduce(function (groupings, entry) {
            if (!groupings[entry.groupingValue])
                groupings[entry.groupingValue] = [];
            groupings[entry.groupingValue].push(entry.participantId);
            return groupings;
        }, {});
        if (Object.keys(groupings).length) {
            if (!avoidance)
                avoidance = { policyName: 'Playoff Avoidance' };
            if (!avoidance.policyAttributes)
                avoidance.policyAttributes = [];
            avoidance.policyAttributes.push({ groupings: groupings });
        }
    }
    if (avoidance && participants) {
        return randomUnseededSeparation({
            provisionalPositioning: provisionalPositioning,
            unseededParticipantIds: unseededParticipantIds,
            inContextDrawMatchUps: inContextDrawMatchUps,
            unseededByePositions: unseededByePositions,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            seedBlockInfo: seedBlockInfo,
            participants: participants,
            matchUpsMap: matchUpsMap,
            structureId: structureId,
            avoidance: avoidance,
            drawSize: drawSize,
            entries: entries,
        });
    }
    else {
        return randomUnseededDistribution({
            provisionalPositioning: provisionalPositioning,
            unseededParticipantIds: unseededParticipantIds,
            inContextDrawMatchUps: inContextDrawMatchUps,
            unfilledDrawPositions: unfilledDrawPositions,
            multipleStructures: multipleStructures,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            seedBlockInfo: seedBlockInfo,
            structureId: structureId,
            matchUpsMap: matchUpsMap,
            drawSize: drawSize,
            event: event,
        });
    }
}
function randomUnseededDistribution(_a) {
    var e_1, _b;
    var provisionalPositioning = _a.provisionalPositioning, unseededParticipantIds = _a.unseededParticipantIds, inContextDrawMatchUps = _a.inContextDrawMatchUps, unfilledDrawPositions = _a.unfilledDrawPositions, multipleStructures = _a.multipleStructures, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, seedBlockInfo = _a.seedBlockInfo, matchUpsMap = _a.matchUpsMap, structureId = _a.structureId, drawSize = _a.drawSize, event = _a.event;
    // when { drawSize: 2 } reverse the order so that popping results in equivalent order
    var shuffledDrawPositions = drawSize > 2
        ? shuffleArray(unfilledDrawPositions)
        : unfilledDrawPositions.reverse();
    try {
        for (var unseededParticipantIds_1 = __values(unseededParticipantIds), unseededParticipantIds_1_1 = unseededParticipantIds_1.next(); !unseededParticipantIds_1_1.done; unseededParticipantIds_1_1 = unseededParticipantIds_1.next()) {
            var participantId = unseededParticipantIds_1_1.value;
            var drawPosition = shuffledDrawPositions.pop();
            if (!multipleStructures || drawPosition) {
                var result = assignDrawPosition$1({
                    provisionalPositioning: provisionalPositioning,
                    inContextDrawMatchUps: inContextDrawMatchUps,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    seedBlockInfo: seedBlockInfo,
                    participantId: participantId,
                    drawPosition: drawPosition,
                    matchUpsMap: matchUpsMap,
                    structureId: structureId,
                    event: event,
                });
                if (result === null || result === void 0 ? void 0 : result.error)
                    console.log('!!!!!', { result: result });
                if (result === null || result === void 0 ? void 0 : result.error)
                    return decorateResult({ result: result, stack: 'randomUnseededDistribution' });
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (unseededParticipantIds_1_1 && !unseededParticipantIds_1_1.done && (_b = unseededParticipantIds_1.return)) _b.call(unseededParticipantIds_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}

function positionQualifiers(params) {
    var e_1, _a;
    var _b;
    var structure = (_b = params.structure) !== null && _b !== void 0 ? _b : findStructure(params).structure;
    var stack = 'positionQualifiers';
    var qualifierDrawPositions = [];
    if (structure.stage === CONSOLATION) {
        return decorateResult({ result: { error: INVALID_STAGE }, stack: stack });
    }
    var _c = getQualifiersData(params), unplacedRoundQualifierCounts = _c.unplacedRoundQualifierCounts, positionAssignments = _c.positionAssignments, roundDrawPositions = _c.roundDrawPositions;
    var _loop_1 = function (roundNumber) {
        var unfilledDrawPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) {
            return (roundDrawPositions[roundNumber].includes(assignment.drawPosition) &&
                !assignment.participantId &&
                !assignment.qualifier &&
                !assignment.bye);
        }).map(function (assignment) { return assignment.drawPosition; });
        if (unplacedRoundQualifierCounts[roundNumber] > (unfilledDrawPositions || 0))
            return { value: decorateResult({
                    result: { error: NO_DRAW_POSITIONS_AVAILABLE_FOR_QUALIFIERS },
                    context: { unfilledDrawPositions: unfilledDrawPositions },
                    stack: stack,
                }) };
        generateRange(0, unplacedRoundQualifierCounts[roundNumber]).forEach(function () {
            var drawPosition = randomPop(unfilledDrawPositions);
            qualifierDrawPositions.push(drawPosition);
            positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.forEach(function (assignment) {
                if (assignment.drawPosition === drawPosition) {
                    assignment.qualifier = true;
                    delete assignment.participantId;
                    delete assignment.bye;
                }
            });
        });
    };
    try {
        for (var _d = __values(Object.keys(unplacedRoundQualifierCounts)), _e = _d.next(); !_e.done; _e = _d.next()) {
            var roundNumber = _e.value;
            var state_1 = _loop_1(roundNumber);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign(__assign({}, SUCCESS), { qualifierDrawPositions: qualifierDrawPositions });
}
function getQualifiersData(_a) {
    var _b;
    var drawDefinition = _a.drawDefinition, structure = _a.structure, structureId = _a.structureId;
    if (!structure)
        (structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure);
    if (!structureId)
        (structureId = structure.structureId);
    var positionAssignments = structureAssignedDrawPositions({ structure: structure }).positionAssignments;
    var stage = structure.stage, stageSequence = structure.stageSequence;
    var _c = getQualifiersCount({
        drawDefinition: drawDefinition,
        stageSequence: stageSequence,
        structureId: structureId,
        stage: stage,
    }), qualifiersCount = _c.qualifiersCount, roundQualifiersCounts = _c.roundQualifiersCounts;
    // now figure out which drawPositions are in which rounds
    var trn = roundQualifiersCounts ? Object.keys(roundQualifiersCounts) : [];
    var targetRoundNumbers = trn.map(function (n) { return ensureInt(n); });
    var matchUps = getAllStructureMatchUps({ structure: structure }).matchUps;
    var roundProfile = getRoundMatchUps({ matchUps: matchUps }).roundProfile;
    var roundDrawPositions = Object.assign.apply(Object, __spreadArray([{}], __read(targetRoundNumbers
        .filter(function (roundNumber) { return roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber]; })
        .map(function (roundNumber) {
        var _a;
        var _b, _c, _d;
        return (_a = {},
            _a[roundNumber] = (_d = (_c = (_b = roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber]) === null || _b === void 0 ? void 0 : _b.drawPositions) === null || _c === void 0 ? void 0 : _c.filter(Boolean)) !== null && _d !== void 0 ? _d : [],
            _a);
    })), false));
    var assignedQualifierPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) { return assignment.qualifier; }).map(function (assignment) { return assignment.drawPosition; });
    var unplacedQualifiersCount = qualifiersCount - ((_b = assignedQualifierPositions === null || assignedQualifierPositions === void 0 ? void 0 : assignedQualifierPositions.length) !== null && _b !== void 0 ? _b : 0);
    var placedQualifiersCount = assignedQualifierPositions === null || assignedQualifierPositions === void 0 ? void 0 : assignedQualifierPositions.length;
    var unplacedRoundQualifierCounts = Object.assign.apply(Object, __spreadArray([{}], __read(targetRoundNumbers.map(function (roundNumber) {
        var _a;
        var _b, _c;
        var assignedQualifierPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) {
            var _a, _b;
            return assignment.qualifier &&
                ((_b = (_a = roundDrawPositions[roundNumber]) === null || _a === void 0 ? void 0 : _a.drawPositions) === null || _b === void 0 ? void 0 : _b.includes(assignment.drawPosition));
        }).map(function (assignment) { return assignment.drawPosition; });
        return _a = {},
            _a[roundNumber] = ((_b = roundQualifiersCounts === null || roundQualifiersCounts === void 0 ? void 0 : roundQualifiersCounts[roundNumber]) !== null && _b !== void 0 ? _b : 0) -
                ((_c = assignedQualifierPositions === null || assignedQualifierPositions === void 0 ? void 0 : assignedQualifierPositions.length) !== null && _c !== void 0 ? _c : 0),
            _a;
    })), false));
    return {
        unplacedRoundQualifierCounts: unplacedRoundQualifierCounts,
        unplacedQualifiersCount: unplacedQualifiersCount,
        placedQualifiersCount: placedQualifiersCount,
        roundQualifiersCounts: roundQualifiersCounts,
        positionAssignments: positionAssignments,
        roundDrawPositions: roundDrawPositions,
        qualifiersCount: qualifiersCount,
    };
}

function getByesData(_a) {
    var _b;
    var provisionalPositioning = _a.provisionalPositioning, drawDefinition = _a.drawDefinition, matchUpsMap = _a.matchUpsMap, structure = _a.structure, event = _a.event;
    var matchUpFilters = { isCollectionMatchUp: false };
    var _c = getAllStructureMatchUps({
        afterRecoveryTimes: false,
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        matchUpFilters: matchUpFilters,
        matchUpsMap: matchUpsMap,
        structure: structure,
        event: event,
    }), matchUps = _c.matchUps, roundMatchUps = _c.roundMatchUps;
    var firstRoundMatchUps = (roundMatchUps === null || roundMatchUps === void 0 ? void 0 : roundMatchUps[1]) || [];
    // firstRoundMatchUps don't work for CONTAINER / ROUND_ROBIN structures
    var isRoundRobin = (structure === null || structure === void 0 ? void 0 : structure.structureType) === CONTAINER;
    var relevantMatchUps = isRoundRobin ? matchUps : firstRoundMatchUps;
    // maxByes for RR can only be the number of structures... no more than one bye per structure
    var maxByes = isRoundRobin
        ? ((_b = structure === null || structure === void 0 ? void 0 : structure.structures) === null || _b === void 0 ? void 0 : _b.length) || 0
        : matchUps.length;
    // get stage/stageSequence Entries and qualifiers
    var structureId = structure.structureId, stage = structure.stage, stageSequence = structure.stageSequence;
    var entries = getStageEntries$1({
        entryStatuses: STRUCTURE_SELECTED_STATUSES,
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        stageSequence: stageSequence,
        structureId: structureId,
        stage: stage,
    });
    var qualifiersCount = getQualifiersCount({
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        stageSequence: stageSequence,
        structureId: structureId,
        stage: stage,
    }).qualifiersCount;
    var entriesCount = entries.length + qualifiersCount;
    // # Byes = drawSize (positionAssignments) - total entries
    // const { positionAssignments, qualifierPositions, byePositions, unassignedPositions } = structureAssignedDrawPositions({structure});
    var _d = structureAssignedDrawPositions({ structure: structure }), positionAssignments = _d.positionAssignments, unassignedPositions = _d.unassignedPositions;
    var unassignedDrawPositions = unassignedPositions === null || unassignedPositions === void 0 ? void 0 : unassignedPositions.map(function (position) { return position.drawPosition; });
    var placedByes = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) { return assignment.bye; }).length;
    var placedByePositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) { return assignment.bye; }).map(function (assignment) { return assignment.drawPosition; });
    var positionsToAvoidDoubleBye = relevantMatchUps
        .map(function (matchUp) { return matchUp.drawPositions; })
        .filter(function (drawPositions) {
        return drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.reduce(function (noBye, drawPosition) {
            return !(placedByePositions === null || placedByePositions === void 0 ? void 0 : placedByePositions.includes(drawPosition)) && noBye;
        }, true);
    })
        .flat(Infinity)
        .filter(function (drawPosition) { return unassignedDrawPositions === null || unassignedDrawPositions === void 0 ? void 0 : unassignedDrawPositions.includes(drawPosition); });
    var drawSize = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.length;
    var byesCount = drawSize ? drawSize - entriesCount : 0;
    if (byesCount > maxByes &&
        structure.stageSequence === 1 &&
        structure.stage !== CONSOLATION) {
        byesCount = maxByes;
    }
    return {
        placedByes: placedByes,
        byesCount: byesCount,
        relevantMatchUps: relevantMatchUps,
        placedByePositions: placedByePositions,
        roundMatchUps: roundMatchUps,
        positionsToAvoidDoubleBye: positionsToAvoidDoubleBye,
    };
}

function getStructurePositionedSeeds(_a) {
    var provisionalPositioning = _a.provisionalPositioning, drawDefinition = _a.drawDefinition, structure = _a.structure;
    var positionAssignments = structureAssignedDrawPositions({ structure: structure }).positionAssignments;
    var seedAssignments = getStructureSeedAssignments({
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        structure: structure,
    }).seedAssignments;
    var seedMap = Object.assign.apply(Object, __spreadArray([{}], __read((seedAssignments || [])
        .filter(function (assignment) { return assignment.participantId; })
        .map(function (assignment) {
        var _a;
        return (_a = {},
            // because we already know participantId is present!
            _a[assignment.participantId] = assignment,
            _a);
    })), false));
    return positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.map(function (assignment) {
        return !seedMap[assignment.participantId]
            ? ''
            : __assign(__assign({}, assignment), { seedNumber: seedMap[assignment.participantId].seedNumber, seedValue: seedMap[assignment.participantId].seedValue });
    }).filter(Boolean);
}

/*
  seedBlocks for 32 seeds in a draw of 128 are as follows:

  [
    { drawPositions: [ 1 ], seedNumbers: [ 1 ] },
    { drawPositions: [ 128 ], seedNumbers: [ 2 ] },
    { drawPositions: [ 33, 96 ], seedNumbers: [ 3, 4 ] },
    { drawPositions: [ 17, 49, 80, 112 ], seedNumbers: [ 5, 6, 7, 8 ] },
    {
      drawPositions: [ 9, 25,  41,  57, 72, 88, 104, 120 ],
      seedNumbers: [ 9, 10, 11, 12, 13, 14, 15, 16 ] },
    {
      drawPositions: [ 5,  13, 21, 29, 37, 45, 53, 61, 68, 76, 84, 92, 100, 108, 116, 124 ],
      seedNumbers: [ 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32 ]
    }
  ]

  When the number of BYEs to be distributed for a seedBlock is LESS than the number of seed position in the block
  it is necessary to evenly distribute the BYEs across all divisions, e.g. 1/2, 1/4, 1/8

  For instance, in a draw of 128 with 116 participants there are 12 BYEs.  The first 8 BYEs are consumed by the
  first four seedBlocks leaving 4 BYEs to b distributed  across the 8 drawPositions claimed by seeds 9-16.

  The drawPositions for seeds 9-16 are:
  [ 9, 25,  41,  57, 72, 88, 104, 120 ]

  These are sorted low to high and grouped in chunks of 2 drawPositions:
  [9, 25],  [41,  57], [72, 88], [104, 120]

  These are then transformed into nested arrays which are each level an array of 2 items:
  [[9, 25],  [41, 57]], [[72, 88], [104, 120]]

  This nesting corresponds to the initial round of elimination structures which always contains power-of-2 drawPositions

  An even distribution of BYEs to seeded drawPositions is achieved by iteratively popping a drawPosition from the nested structure,
  at each level comparing the flattened length of the 2 items of the array

  For comparison, the nesting of seed 17-32 would be as follows:
  [[[5,  13], [21, 29]], [[37, 45], [53, 61]]], [[[68, 76], [84, 92]], [[100, 108], [116, 124]]],
 */
function getBlockSortedRandomDrawPositions(_a) {
    var strictOrder = _a.orderedSortedFirstRoundSeededDrawPositions, validSeedBlocks = _a.validSeedBlocks, byesToPlace = _a.byesToPlace;
    var drawPositions = [];
    validSeedBlocks.forEach(function (seedBlock) {
        var leftToPlace = byesToPlace - drawPositions.length;
        if (leftToPlace > seedBlock.drawPositions.length) {
            drawPositions.push.apply(drawPositions, __spreadArray([], __read(seedBlock.drawPositions), false));
        }
        else {
            var nestedDrawPositions = nestArray(chunkArray(seedBlock.drawPositions, 2));
            var drawPosition = void 0;
            var desiredPosition = strictOrder[drawPositions.length];
            while ((drawPosition = popFromLargerSide(nestedDrawPositions, desiredPosition))) {
                drawPositions.push(drawPosition);
                desiredPosition = strictOrder[drawPositions.length];
            }
        }
    });
    var blockSortedRandom = drawPositions
        .map(function (p) { return (Array.isArray(p) ? shuffleArray(p) : p); })
        .flat(Infinity);
    if (isOdd(byesToPlace)) {
        var blockFirstSeedNumbers = validSeedBlocks.map(function (block) { return block.seedNumbers[0]; });
        if (blockFirstSeedNumbers.includes(byesToPlace))
            return strictOrder;
    }
    return blockSortedRandom;
}
// desiredPosition is provided by strict seed order bye placement
// when the sides are balanced, side selection is driven by desiredPosition
function popFromLargerSide(arr, desiredPosition) {
    if (Array.isArray(arr) && arr.length !== 2)
        return arr.pop();
    if (!Array.isArray(arr[0])) {
        if (arr.includes(desiredPosition))
            return arr.indexOf(desiredPosition) ? arr.pop() : arr.shift();
        return Math.round(Math.random()) ? arr.pop() : arr.shift();
    }
    var side1 = arr[0].flat(Infinity).length;
    var side2 = arr[1].flat(Infinity).length;
    if (side1 === side2) {
        var desiredSide = arr[0].flat(Infinity).includes(desiredPosition)
            ? arr[0]
            : arr[1];
        if (desiredPosition)
            return popFromLargerSide(desiredSide, desiredPosition);
        return popFromLargerSide(arr[Math.round(Math.random())], desiredPosition);
    }
    return side1 < side2
        ? popFromLargerSide(arr[1], desiredPosition)
        : popFromLargerSide(arr[0], desiredPosition);
}
function nestArray(arr) {
    var midPoint = Math.floor(arr.length / 2);
    return arr.length > 2
        ? [nestArray(arr.slice(0, midPoint)), nestArray(arr.slice(midPoint))]
        : arr;
}

function getSeedOrderByePositions(_a) {
    var _b, _c;
    var provisionalPositioning = _a.provisionalPositioning, relevantMatchUps = _a.relevantMatchUps, appliedPolicies = _a.appliedPolicies, drawDefinition = _a.drawDefinition, seedingProfile = _a.seedingProfile, seedBlockInfo = _a.seedBlockInfo, byesToPlace = _a.byesToPlace, structure = _a.structure;
    if (!seedBlockInfo) {
        seedBlockInfo = getValidSeedBlocks({
            provisionalPositioning: provisionalPositioning,
            appliedPolicies: appliedPolicies,
            drawDefinition: drawDefinition,
            seedingProfile: seedingProfile,
            structure: structure,
        });
    }
    var isFeedIn = seedBlockInfo.isFeedIn, isLuckyStructure = seedBlockInfo.isLuckyStructure, isContainer = seedBlockInfo.isContainer;
    var validSeedBlocks = seedBlockInfo.validSeedBlocks;
    if ((_b = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.seeding) === null || _b === void 0 ? void 0 : _b.containerByesIgnoreSeeding)
        validSeedBlocks = [];
    var positionedSeeds = (_c = getStructurePositionedSeeds({
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        structure: structure,
    })) !== null && _c !== void 0 ? _c : [];
    var relevantDrawPositions = unique([].concat.apply([], __spreadArray([], __read(relevantMatchUps.map(function (matchUp) { return matchUp.drawPositions; })), false)));
    var relevantPositionedSeeds = positionedSeeds.filter(function (positionedSeed) {
        return relevantDrawPositions.includes(positionedSeed.drawPosition);
    });
    // within seedBlocks positionedSeeds are sorted by seedValue to handle the situation
    // where there are multiple players seeded with the same seedValue which have been
    // randomly assigned to different seedBlocks
    // Example: more than one 4th seed, but only one of them placed in the 3-4 seed block
    // 3rd seed must get 3rd Bye, and 4th seed placed in the 3-4 seed block must get 4th bye
    var seedValueSort = function (a, b) {
        return getNumericSeedValue(a.seedValue) - getNumericSeedValue(b.seedValue);
    };
    var valueOrderedBlockSortedPositionedSeeds = validSeedBlocks.reduce(function (result, seedBlock) {
        var positionedSeedsInBlock = relevantPositionedSeeds
            .filter(function (positionedSeed) { var _a; return (_a = seedBlock.drawPositions) === null || _a === void 0 ? void 0 : _a.includes(positionedSeed.drawPosition); })
            .sort(seedValueSort);
        return result.concat.apply(result, __spreadArray([], __read(positionedSeedsInBlock), false));
    }, []);
    var orderedSortedFirstRoundSeededDrawPositions = valueOrderedBlockSortedPositionedSeeds.map(function (positionedSeed) { return positionedSeed.drawPosition; });
    var blockSortedRandomDrawPositions = getBlockSortedRandomDrawPositions({
        orderedSortedFirstRoundSeededDrawPositions: orderedSortedFirstRoundSeededDrawPositions,
        validSeedBlocks: validSeedBlocks,
        byesToPlace: byesToPlace,
    });
    // returns list of bye positions which strictly follows where seeds
    // have been placed according to sorted seedNumbers
    var strictSeedOrderByePositions = getOrderedByePositions({
        orderedSeedDrawPositions: orderedSortedFirstRoundSeededDrawPositions,
        relevantMatchUps: relevantMatchUps,
    }).slice(0, byesToPlace);
    var blockSeedOrderByePositions = getOrderedByePositions({
        orderedSeedDrawPositions: blockSortedRandomDrawPositions,
        relevantMatchUps: relevantMatchUps,
    }).slice(0, byesToPlace);
    return {
        strictSeedOrderByePositions: strictSeedOrderByePositions,
        blockSeedOrderByePositions: blockSeedOrderByePositions,
        isLuckyStructure: isLuckyStructure,
        positionedSeeds: positionedSeeds,
        isContainer: isContainer,
        isFeedIn: isFeedIn,
    };
}
function getOrderedByePositions(_a) {
    // if relevantMatchUps excludes FEED_IN rounds...
    // matchUpDrawPositions will equal firstRoundDrawPositions
    // In CONTAINER/ROUND_ROBIN structures drawPositions are duplicated
    // and therefore must placed in drawOrder within Groups
    var orderedSeedDrawPositions = _a.orderedSeedDrawPositions, relevantMatchUps = _a.relevantMatchUps;
    var matchUpDrawPositionPairs = relevantMatchUps.map(function (matchUp) { return matchUp.drawPositions; });
    var consideredDrawPositionPairs = matchUpDrawPositionPairs
        .map(function (pair) { return pair === null || pair === void 0 ? void 0 : pair.sort(function (a, b) { return a - b; }); })
        .filter(function (pair) { return (pair === null || pair === void 0 ? void 0 : pair[0]) + 1 === (pair === null || pair === void 0 ? void 0 : pair[1]); });
    // sort seededMatchUps so that pairedPositions represent seed order
    var seedOrderSortedDrawPositionPairs = orderedSeedDrawPositions
        .map(function (drawPosition) {
        return consideredDrawPositionPairs.find(function (drawPositions) { return drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(drawPosition); });
    })
        .filter(Boolean);
    return seedOrderSortedDrawPositionPairs
        .map(function (drawPositions) {
        return drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.reduce(function (byePosition, drawPosition) {
            var included = orderedSeedDrawPositions.includes(drawPosition);
            return included ? byePosition : drawPosition;
        }, undefined);
    })
        .filter(Boolean);
}

function getUnseededByePositions(_a) {
    var _b, _c;
    var provisionalPositioning = _a.provisionalPositioning, seedOrderByePositions = _a.seedOrderByePositions; _a.isLuckyStructure; var appliedPolicies = _a.appliedPolicies, drawDefinition = _a.drawDefinition, seedLimit = _a.seedLimit, structure = _a.structure, isFeedIn = _a.isFeedIn;
    var seedingProfile = (_b = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.seeding) === null || _b === void 0 ? void 0 : _b.seedingProfile;
    var isQualifying = structure.stage === QUALIFYING;
    var positionAssignments = structureAssignedDrawPositions({ structure: structure }).positionAssignments;
    var filledDrawPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) { return assignment.participantId; }).map(function (assignment) { return assignment.drawPosition; });
    var matchUpFilters = { isCollectionMatchUp: false };
    var _d = getAllStructureMatchUps({
        provisionalPositioning: provisionalPositioning,
        matchUpFilters: matchUpFilters,
        structure: structure,
    }), matchUps = _d.matchUps, roundMatchUps = _d.roundMatchUps;
    var firstRoundMatchUps = (roundMatchUps === null || roundMatchUps === void 0 ? void 0 : roundMatchUps[1]) || [];
    // firstRoundMatchUps don't work for CONTAINER / ROUND_ROBIN structures
    var relevantMatchUps = structure.structureType === CONTAINER ? matchUps : firstRoundMatchUps;
    var relevantDrawPositions = unique([].concat.apply([], __spreadArray([], __read(relevantMatchUps.map(function (matchUp) { return matchUp.drawPositions; })), false)));
    var drawPositionOffset = Math.min.apply(Math, __spreadArray([], __read(relevantDrawPositions), false)) - 1;
    var filledRelevantDrawPositions = filledDrawPositions === null || filledDrawPositions === void 0 ? void 0 : filledDrawPositions.filter(function (drawPosition) {
        return relevantDrawPositions.includes(drawPosition);
    });
    var getHalves = function (chunk) {
        var halfLength = Math.ceil(chunk.length / 2);
        var halves = [chunk.slice(0, halfLength), chunk.slice(halfLength)];
        var halfLengths = halves.map(function (half) { return [].concat.apply([], __spreadArray([], __read(half.flat(Infinity)), false)).length; });
        var shortLength = Math.min.apply(Math, __spreadArray([], __read(halfLengths.flat(Infinity)), false));
        var longLength = Math.max.apply(Math, __spreadArray([], __read(halfLengths.flat(Infinity)), false));
        var longIndex = halfLengths.indexOf(longLength);
        var unequalHalves = shortLength !== longLength;
        var shuffledHalves = shuffleArray(halves);
        var _a = __read(!shortLength || unequalHalves
            ? [halves[longIndex], halves[1 - longIndex]]
            : [shuffledHalves[0], shuffledHalves[1]], 2), greaterHalf = _a[0], lesserHalf = _a[1];
        return { greaterHalf: greaterHalf, lesserHalf: lesserHalf };
    };
    var getNextDrawPosition = function (chunks) {
        var _a = getHalves(chunks), greaterHalf = _a.greaterHalf, lesserHalf = _a.lesserHalf;
        var _b = getHalves(greaterHalf), greaterQuarter = _b.greaterHalf, lesserQuarter = _b.lesserHalf;
        var shuffledQuarter = shuffleArray(greaterQuarter.flat(Infinity));
        var drawPosition = shuffledQuarter.pop();
        var diminishedQuarter = greaterQuarter.flat().filter(function (position) { return position !== drawPosition; });
        var newlyFilteredChunks = __spreadArray(__spreadArray(__spreadArray([], __read(lesserHalf), false), __read(lesserQuarter), false), [diminishedQuarter], false);
        return { newlyFilteredChunks: newlyFilteredChunks, drawPosition: drawPosition };
    };
    var notSeedByePosition = function (drawPosition) { return !seedOrderByePositions.includes(drawPosition); };
    var unfilledDrawPosition = function (drawPosition) { return !(filledRelevantDrawPositions === null || filledRelevantDrawPositions === void 0 ? void 0 : filledRelevantDrawPositions.includes(drawPosition)); };
    var quarterSeparateBlock = function (block) {
        var sortedChunked = chunkArray(block.sort(numericSort), Math.ceil(block.length / 4));
        var filteredChunks = sortedChunked.map(function (chunk) { return chunk.filter(unfilledDrawPosition); });
        var drawPositionCount = [].concat.apply([], __spreadArray([], __read(filteredChunks.flat(Infinity)), false)).length;
        var orderedDrawPositions = [];
        for (var i = 0; i < drawPositionCount; i++) {
            var _a = getNextDrawPosition(filteredChunks), newlyFilteredChunks = _a.newlyFilteredChunks, drawPosition = _a.drawPosition;
            orderedDrawPositions.push(drawPosition);
            filteredChunks = newlyFilteredChunks;
        }
        return orderedDrawPositions;
    };
    // The goal here is to get an order for assigning bye positions which is well distributed
    // setting allPositions: true returns seedBlocks for all positions
    // overriding the default which returns only seedBlocks for seedsCount
    var validSeedBlocks = getValidSeedBlocks({
        provisionalPositioning: provisionalPositioning,
        allPositions: true,
        appliedPolicies: appliedPolicies,
        drawDefinition: drawDefinition,
        structure: structure,
    }).validSeedBlocks;
    var validBlockDrawPositions = validSeedBlocks === null || validSeedBlocks === void 0 ? void 0 : validSeedBlocks.map(function (block) { var _a; return (_a = block.drawPositions) === null || _a === void 0 ? void 0 : _a.map(function (drawPosition) { return drawPosition + drawPositionOffset; }); });
    var unfilledSeedBlocks;
    if (isFeedIn) {
        // FEED_IN structures calculate seedDrawPositions uniquely
        // and require a special case to properly calculate bye positions
        var baseDrawSize = relevantDrawPositions.length;
        var seedBlocks = getSeedBlocks({
            cluster: getSeedPattern(seedingProfile) === CLUSTER,
            participantsCount: baseDrawSize,
        }).seedBlocks;
        var blockDrawPositions = seedBlocks.map(function (seedBlock) {
            return seedBlock.map(function (drawPosition) { return drawPosition + drawPositionOffset; });
        });
        unfilledSeedBlocks = blockDrawPositions.map(quarterSeparateBlock).filter(function (block) { return block.length; });
    }
    else if (isQualifying) {
        unfilledSeedBlocks = validBlockDrawPositions === null || validBlockDrawPositions === void 0 ? void 0 : validBlockDrawPositions.map(function (block) { return block.filter(unfilledDrawPosition); });
    }
    else {
        unfilledSeedBlocks = validBlockDrawPositions === null || validBlockDrawPositions === void 0 ? void 0 : validBlockDrawPositions.map(quarterSeparateBlock).filter(function (block) { return block.length; });
    }
    // for Round Robins pairs need to be reduced to pairs in drawPosition order
    var matchUpPairedDrawPositions = relevantMatchUps
        .map(function (matchUp) { return matchUp.drawPositions; })
        .map(function (pair) { return pair === null || pair === void 0 ? void 0 : pair.sort(function (a, b) { return a - b; }); })
        .filter(function (pair) { return (pair === null || pair === void 0 ? void 0 : pair[0]) + 1 === (pair === null || pair === void 0 ? void 0 : pair[1]); });
    var findDrawPositionPair = function (drawPosition) {
        return matchUpPairedDrawPositions.reduce(function (pair, candidate) {
            return candidate.includes(drawPosition)
                ? candidate.reduce(function (p, c) { return (c !== drawPosition ? c : p); }, undefined)
                : pair;
        }, undefined);
    };
    var unseededByePositions = unfilledSeedBlocks
        .map(function (block) { return block.map(findDrawPositionPair); })
        .flat(Infinity)
        .filter(unfilledDrawPosition)
        .filter(notSeedByePosition)
        .filter(Boolean);
    if (isQualifying && !structure.structures) {
        // need to know how many qualifying blocks so that unseededByePositions can be shuffled
        // (after removing blocks.length time blocks which had seeds placed)
        // console.log(validBlockDrawPositions.length, unseededByePositions.length);
        var seedingOverhang = seedLimit % 4;
        var overhangDrawPositions = unseededByePositions.slice(0, seedingOverhang);
        var qualifierBlocksCount = (_c = roundMatchUps[structure.roundLimit]) === null || _c === void 0 ? void 0 : _c.length;
        var shuffledRemainder = chunkArray(unseededByePositions.slice(seedingOverhang), qualifierBlocksCount)
            .map(shuffleArray)
            .flat();
        unseededByePositions = overhangDrawPositions.concat(shuffledRemainder);
    }
    return { unseededByePositions: unseededByePositions };
}

function positionByes(_a) {
    var e_1, _b;
    var _c, _d;
    var provisionalPositioning = _a.provisionalPositioning, tournamentRecord = _a.tournamentRecord, appliedPolicies = _a.appliedPolicies, drawDefinition = _a.drawDefinition, seedBlockInfo = _a.seedBlockInfo, seedingProfile = _a.seedingProfile, matchUpsMap = _a.matchUpsMap, structureId = _a.structureId, structure = _a.structure, seedLimit = _a.seedLimit, seedsOnly = _a.seedsOnly, event = _a.event;
    if (!structure)
        (structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure);
    if (!structureId)
        structureId = structure === null || structure === void 0 ? void 0 : structure.structureId;
    var blockOrdered = !((_c = structure === null || structure === void 0 ? void 0 : structure.structures) !== null && _c !== void 0 ? _c : (structure === null || structure === void 0 ? void 0 : structure.stage) === QUALIFYING);
    var _e = getByesData({
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        structure: structure,
        event: event,
    }), byesCount = _e.byesCount, placedByes = _e.placedByes, relevantMatchUps = _e.relevantMatchUps;
    var byesToPlace = byesCount - (placedByes || 0);
    if (byesToPlace <= 0)
        return __assign({}, SUCCESS);
    var _f = getSeedOrderByePositions({
        provisionalPositioning: provisionalPositioning,
        relevantMatchUps: relevantMatchUps,
        appliedPolicies: appliedPolicies,
        drawDefinition: drawDefinition,
        seedingProfile: seedingProfile,
        seedBlockInfo: seedBlockInfo,
        byesToPlace: byesToPlace,
        structure: structure,
    }), strictSeedOrderByePositions = _f.strictSeedOrderByePositions, blockSeedOrderByePositions = _f.blockSeedOrderByePositions, isLuckyStructure = _f.isLuckyStructure, isFeedIn = _f.isFeedIn;
    var ignoreSeededByes = (structure === null || structure === void 0 ? void 0 : structure.structureType) &&
        [CONTAINER, ITEM].includes(structure.structureType) &&
        ((_d = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.seeding) === null || _d === void 0 ? void 0 : _d.containerByesIgnoreSeeding);
    var seedOrderByePositions = blockOrdered && (blockSeedOrderByePositions === null || blockSeedOrderByePositions === void 0 ? void 0 : blockSeedOrderByePositions.length)
        ? blockSeedOrderByePositions
        : strictSeedOrderByePositions;
    var unseededByePositions = getUnseededByePositions({
        provisionalPositioning: provisionalPositioning,
        seedOrderByePositions: seedOrderByePositions,
        isLuckyStructure: isLuckyStructure,
        appliedPolicies: appliedPolicies,
        drawDefinition: drawDefinition,
        seedLimit: seedLimit,
        structure: structure,
        isFeedIn: isFeedIn,
    }).unseededByePositions;
    var isOdd = function (x) { return x % 2; };
    // method determines whether candidate c is paired to elements in an array
    var isNotPaired = function (arr, c) {
        return (arr || []).every(function (a) { return (isOdd(a) ? c !== a + 1 : c !== a - 1); });
    };
    // first add all drawPositions paired with sorted seeds drawPositions
    // then add quarter separated and evenly distributed drawPositions
    // derived from theoretical seeding of firstRoundParticipants
    // HOWEVER, if separated and evenly distributed drawPositions result
    // in a BYE/BYE pairing, prioritize remaining unpaired positions
    var byePositions = [].concat.apply([], __spreadArray([], __read(seedOrderByePositions), false));
    if (!seedsOnly) {
        var _loop_1 = function () {
            var unPairedPosition = unseededByePositions.find(function (position) {
                return isNotPaired(byePositions, position);
            });
            if (unPairedPosition) {
                byePositions.push(unPairedPosition);
                unseededByePositions = unseededByePositions.filter(function (position) { return position !== unPairedPosition; });
            }
            else {
                byePositions.push.apply(byePositions, __spreadArray([], __read(unseededByePositions), false));
                unseededByePositions = [];
            }
        };
        while (unseededByePositions.length) {
            _loop_1();
        }
    }
    if (ignoreSeededByes) {
        byePositions = shuffleArray(byePositions);
        if (getDevContext({ ignoreSeededByes: ignoreSeededByes }))
            console.log({ byePositions: byePositions });
    }
    // then take only the number of required byes
    var byeDrawPositions = byePositions.slice(0, byesToPlace);
    try {
        for (var byeDrawPositions_1 = __values(byeDrawPositions), byeDrawPositions_1_1 = byeDrawPositions_1.next(); !byeDrawPositions_1_1.done; byeDrawPositions_1_1 = byeDrawPositions_1.next()) {
            var drawPosition = byeDrawPositions_1_1.value;
            var result = assignDrawPositionBye({
                provisionalPositioning: provisionalPositioning,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                drawPosition: drawPosition,
                matchUpsMap: matchUpsMap,
                structureId: structureId,
                structure: structure,
                event: event,
            });
            if (result === null || result === void 0 ? void 0 : result.error)
                return result;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (byeDrawPositions_1_1 && !byeDrawPositions_1_1.done && (_b = byeDrawPositions_1.return)) _b.call(byeDrawPositions_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign(__assign({}, SUCCESS), { unseededByePositions: unseededByePositions, byeDrawPositions: byeDrawPositions });
}

function positionSeedBlocks(_a) {
    var _b;
    var provisionalPositioning = _a.provisionalPositioning, inContextDrawMatchUps = _a.inContextDrawMatchUps, tournamentRecord = _a.tournamentRecord, appliedPolicies = _a.appliedPolicies, validSeedBlocks = _a.validSeedBlocks, drawDefinition = _a.drawDefinition, seedingProfile = _a.seedingProfile, seedBlockInfo = _a.seedBlockInfo, participants = _a.participants, groupsCount = _a.groupsCount, structureId = _a.structureId, matchUpsMap = _a.matchUpsMap, structure = _a.structure, event = _a.event;
    var seedPositions = [];
    var errors = [];
    var placedSeedBlocks = 0;
    if (!structure)
        (structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure);
    if (!structureId)
        structureId = structure === null || structure === void 0 ? void 0 : structure.structureId;
    if (!appliedPolicies) {
        appliedPolicies = getAppliedPolicies({ drawDefinition: drawDefinition }).appliedPolicies;
    }
    if (!validSeedBlocks) {
        var result = structure &&
            getValidSeedBlocks({
                provisionalPositioning: provisionalPositioning,
                appliedPolicies: appliedPolicies,
                drawDefinition: drawDefinition,
                seedingProfile: seedingProfile,
                structure: structure,
            });
        if (result === null || result === void 0 ? void 0 : result.error)
            errors.push(result.error);
        validSeedBlocks = result === null || result === void 0 ? void 0 : result.validSeedBlocks;
    }
    groupsCount = (_b = groupsCount !== null && groupsCount !== void 0 ? groupsCount : validSeedBlocks === null || validSeedBlocks === void 0 ? void 0 : validSeedBlocks.length) !== null && _b !== void 0 ? _b : 0;
    generateRange(0, groupsCount).forEach(function () {
        var _a;
        if (placedSeedBlocks < (groupsCount || 0)) {
            var result = positionSeedBlock({
                provisionalPositioning: provisionalPositioning,
                inContextDrawMatchUps: inContextDrawMatchUps,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                seedingProfile: seedingProfile,
                seedBlockInfo: seedBlockInfo,
                participants: participants,
                structureId: structureId,
                matchUpsMap: matchUpsMap,
                event: event,
            });
            if (result === null || result === void 0 ? void 0 : result.success) {
                placedSeedBlocks++;
                seedPositions.push.apply(seedPositions, __spreadArray([], __read(((_a = result.seedPositions) !== null && _a !== void 0 ? _a : [])), false));
            }
            if (result.error) {
                errors.push({ seedPositionError: result.error });
            }
        }
    });
    if (errors.length)
        return { error: errors };
    return __assign(__assign({}, SUCCESS), { seedPositions: seedPositions });
}
function positionSeedBlock(_a) {
    var e_1, _b;
    var provisionalPositioning = _a.provisionalPositioning, inContextDrawMatchUps = _a.inContextDrawMatchUps, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, seedingProfile = _a.seedingProfile, seedBlockInfo = _a.seedBlockInfo, participants = _a.participants, structureId = _a.structureId, matchUpsMap = _a.matchUpsMap, event = _a.event;
    var _c = getNextSeedBlock({
        provisionalPositioning: provisionalPositioning,
        randomize: true,
        drawDefinition: drawDefinition,
        seedingProfile: seedingProfile,
        seedBlockInfo: seedBlockInfo,
        structureId: structureId,
        event: event,
    }), unplacedSeedParticipantIds = _c.unplacedSeedParticipantIds, unfilledPositions = _c.unfilledPositions;
    var appliedPolicies = getAppliedPolicies({ drawDefinition: drawDefinition }).appliedPolicies;
    var avoidance = (appliedPolicies !== null && appliedPolicies !== void 0 ? appliedPolicies : {}).avoidance;
    if (avoidance && participants && (unplacedSeedParticipantIds === null || unplacedSeedParticipantIds === void 0 ? void 0 : unplacedSeedParticipantIds.length) > 2) ;
    var seedPositions = [];
    try {
        for (var unplacedSeedParticipantIds_1 = __values(unplacedSeedParticipantIds), unplacedSeedParticipantIds_1_1 = unplacedSeedParticipantIds_1.next(); !unplacedSeedParticipantIds_1_1.done; unplacedSeedParticipantIds_1_1 = unplacedSeedParticipantIds_1.next()) {
            var participantId = unplacedSeedParticipantIds_1_1.value;
            var drawPosition = unfilledPositions.pop();
            if (!drawPosition)
                return { error: MISSING_DRAW_POSITION };
            seedPositions.push(drawPosition);
            var result = assignDrawPosition$1({
                provisionalPositioning: provisionalPositioning,
                inContextDrawMatchUps: inContextDrawMatchUps,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                seedingProfile: seedingProfile,
                participantId: participantId,
                seedBlockInfo: seedBlockInfo,
                drawPosition: drawPosition,
                matchUpsMap: matchUpsMap,
                structureId: structureId,
                event: event,
            });
            if (!result.success)
                return result;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (unplacedSeedParticipantIds_1_1 && !unplacedSeedParticipantIds_1_1.done && (_b = unplacedSeedParticipantIds_1.return)) _b.call(unplacedSeedParticipantIds_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign(__assign({}, SUCCESS), { seedPositions: seedPositions });
}

function automatedPositioning(_a) {
    var _b, _c;
    var _d = _a.applyPositioning, applyPositioning = _d === void 0 ? true : _d, provisionalPositioning = _a.provisionalPositioning, inContextDrawMatchUps = _a.inContextDrawMatchUps, multipleStructures = _a.multipleStructures, _e = _a.placeByes, placeByes = _e === void 0 ? true : _e, tournamentRecord = _a.tournamentRecord, appliedPolicies = _a.appliedPolicies, placementGroup = _a.placementGroup, drawDefinition = _a.drawDefinition, seedingProfile = _a.seedingProfile, structureId = _a.structureId, matchUpsMap = _a.matchUpsMap, seedLimit = _a.seedLimit, seedsOnly = _a.seedsOnly, drawType = _a.drawType, drawSize = _a.drawSize, event = _a.event;
    var positioningReport = [];
    //-----------------------------------------------------------
    // handle notification state for all exit conditions
    if (!applyPositioning) {
        // when positioning is not being applied no notifications are generated
        // because only the positionAssignments are returned
        disableNotifications();
        // positioningAssignments are applied to a copy of the drawDefinition,
        // not the actual drawDefinition...
        drawDefinition = makeDeepCopy(drawDefinition, false, true);
    }
    var handleErrorCondition = function (result) {
        if (!applyPositioning)
            enableNotifications();
        return decorateResult({ result: result, stack: 'automatedPositioning' });
    };
    var handleSuccessCondition = function (result) {
        if (!applyPositioning)
            enableNotifications();
        return result;
    };
    //-----------------------------------------------------------
    var result = findStructure({ drawDefinition: drawDefinition, structureId: structureId });
    if (result.error)
        return handleErrorCondition(result);
    var structure = result.structure;
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    if (!appliedPolicies) {
        appliedPolicies = (_b = getAppliedPolicies({
            drawDefinition: drawDefinition,
            structure: structure,
            event: event,
        })) === null || _b === void 0 ? void 0 : _b.appliedPolicies;
    }
    var qualifiersCount = getQualifiersCount({
        stageSequence: structure.stageSequence,
        provisionalPositioning: provisionalPositioning,
        stage: structure.stage,
        drawDefinition: drawDefinition,
        structureId: structureId,
    }).qualifiersCount;
    var entryStatuses = DIRECT_ENTRY_STATUSES;
    var entries = getStageEntries$1({
        stageSequence: structure.stageSequence,
        provisionalPositioning: provisionalPositioning,
        stage: structure.stage,
        placementGroup: placementGroup,
        drawDefinition: drawDefinition,
        entryStatuses: entryStatuses,
        structureId: structureId,
    });
    if (!(entries === null || entries === void 0 ? void 0 : entries.length) && !qualifiersCount)
        return handleSuccessCondition(__assign({}, SUCCESS));
    matchUpsMap = matchUpsMap !== null && matchUpsMap !== void 0 ? matchUpsMap : getMatchUpsMap({ drawDefinition: drawDefinition });
    if (!inContextDrawMatchUps) {
        (inContextDrawMatchUps = getAllDrawMatchUps({
            inContext: true,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
        }).matchUps);
    }
    var unseededByePositions = [];
    var seedBlockInfo = getValidSeedBlocks({
        provisionalPositioning: provisionalPositioning,
        appliedPolicies: appliedPolicies,
        drawDefinition: drawDefinition,
        seedingProfile: seedingProfile,
        structure: structure,
    });
    if (seedBlockInfo.error)
        return seedBlockInfo;
    var validSeedBlocks = seedBlockInfo.validSeedBlocks;
    positioningReport.push({ validSeedBlocks: validSeedBlocks });
    var participants = tournamentRecord
        ? (_c = getParticipants({
            withIndividualParticipants: true,
            tournamentRecord: tournamentRecord,
        })) === null || _c === void 0 ? void 0 : _c.participants
        : [];
    if (getSeedPattern(structure.seedingProfile || seedingProfile) === WATERFALL) {
        // since WATERFALL attempts to place ALL participants
        // BYEs must be placed first to ensure lower seeds get BYEs
        var result_1 = placeByes
            ? positionByes({
                provisionalPositioning: provisionalPositioning,
                tournamentRecord: tournamentRecord,
                appliedPolicies: appliedPolicies,
                drawDefinition: drawDefinition,
                seedBlockInfo: seedBlockInfo,
                matchUpsMap: matchUpsMap,
                structure: structure,
                seedLimit: seedLimit,
                seedsOnly: seedsOnly,
                event: event,
            })
            : undefined;
        if (result_1 === null || result_1 === void 0 ? void 0 : result_1.error)
            return handleErrorCondition(result_1);
        unseededByePositions = result_1.unseededByePositions;
        positioningReport.push({ action: 'positionByes', unseededByePositions: unseededByePositions });
        var profileSeeding = structure.seedingProfile ? { positioning: structure.seedingProfile } : seedingProfile;
        result_1 = positionSeedBlocks({
            seedingProfile: profileSeeding,
            provisionalPositioning: provisionalPositioning,
            inContextDrawMatchUps: inContextDrawMatchUps,
            tournamentRecord: tournamentRecord,
            appliedPolicies: appliedPolicies,
            validSeedBlocks: validSeedBlocks,
            drawDefinition: drawDefinition,
            seedBlockInfo: seedBlockInfo,
            participants: participants,
            matchUpsMap: matchUpsMap,
            structure: structure,
            event: event,
        });
        if (result_1.error)
            return handleErrorCondition(result_1);
        positioningReport.push({
            seedPositions: result_1.seedPositions,
            action: 'positionSeedBlocks',
        });
    }
    else {
        // otherwise... seeds need to be placed first so that BYEs
        // can follow the seedValues of placed seeds
        if (drawType !== LUCKY_DRAW) {
            var profileSeeding = structure.seedingProfile ? { positioning: structure.seedingProfile } : seedingProfile;
            var result_2 = positionSeedBlocks({
                seedingProfile: profileSeeding,
                provisionalPositioning: provisionalPositioning,
                inContextDrawMatchUps: inContextDrawMatchUps,
                tournamentRecord: tournamentRecord,
                appliedPolicies: appliedPolicies,
                validSeedBlocks: validSeedBlocks,
                drawDefinition: drawDefinition,
                seedBlockInfo: seedBlockInfo,
                participants: participants,
                matchUpsMap: matchUpsMap,
                structure: structure,
                event: event,
            });
            if (result_2.error)
                return handleErrorCondition(result_2);
            positioningReport.push({
                action: 'positionSeedBlocks',
                seedPositions: result_2.seedPositions,
            });
        }
        var result_3 = placeByes
            ? positionByes({
                provisionalPositioning: provisionalPositioning,
                tournamentRecord: tournamentRecord,
                appliedPolicies: appliedPolicies,
                drawDefinition: drawDefinition,
                seedBlockInfo: seedBlockInfo,
                matchUpsMap: matchUpsMap,
                structure: structure,
                seedLimit: seedLimit,
                seedsOnly: seedsOnly,
                event: event,
            })
            : undefined;
        if (result_3 === null || result_3 === void 0 ? void 0 : result_3.error) {
            return handleErrorCondition(result_3);
        }
        unseededByePositions = result_3 === null || result_3 === void 0 ? void 0 : result_3.unseededByePositions;
        positioningReport.push({
            action: 'positionByes',
            byeDrawPositions: result_3 === null || result_3 === void 0 ? void 0 : result_3.byeDrawPositions,
            unseededByePositions: unseededByePositions,
        });
    }
    var conflicts = {};
    if (!seedsOnly) {
        // qualifiers are randomly placed BEFORE unseeded because in FEED_IN draws they may have roundTargets
        // this can be modified ONLY if a check is place for round targeting and qualifiers are placed first
        // in this specific circumstance
        var result_4 = positionQualifiers({
            inContextDrawMatchUps: inContextDrawMatchUps,
            tournamentRecord: tournamentRecord,
            appliedPolicies: appliedPolicies,
            validSeedBlocks: validSeedBlocks,
            drawDefinition: drawDefinition,
            seedBlockInfo: seedBlockInfo,
            participants: participants,
            matchUpsMap: matchUpsMap,
            structure: structure,
        });
        if (result_4.error) {
            return handleErrorCondition(result_4);
        }
        if (result_4.conflicts)
            conflicts.qualifierConflicts = result_4.conflicts;
        positioningReport.push({
            action: 'positionQualifiers',
            qualifierDrawPositions: result_4.qualifierDrawPositions,
        });
        result_4 = positionUnseededParticipants({
            provisionalPositioning: provisionalPositioning,
            inContextDrawMatchUps: inContextDrawMatchUps,
            unseededByePositions: unseededByePositions,
            multipleStructures: multipleStructures,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            seedBlockInfo: seedBlockInfo,
            participants: participants,
            matchUpsMap: matchUpsMap,
            structureId: structureId,
            structure: structure,
            drawSize: drawSize,
            event: event,
        });
        if (result_4.error) {
            return handleErrorCondition(result_4);
        }
        if (result_4.conflicts)
            conflicts.unseededConflicts = result_4.conflicts;
        positioningReport.push({ action: 'positionUnseededParticipants' });
    }
    var positionAssignments = getPositionAssignments$1({
        drawDefinition: drawDefinition,
        structure: structure,
    }).positionAssignments;
    modifyDrawNotice({ drawDefinition: drawDefinition, structureIds: [structureId] });
    //-----------------------------------------------------------
    // re-enable notifications, if they have been disabled
    if (!applyPositioning)
        enableNotifications();
    //-----------------------------------------------------------
    return __assign(__assign({ positionAssignments: positionAssignments, conflicts: conflicts }, SUCCESS), { positioningReport: positioningReport });
}

function automatedPlayoffPositioning(params) {
    var e_1, _a;
    var _b;
    var _c = params.applyPositioning, applyPositioning = _c === void 0 ? true : _c, provisionalPositioning = params.provisionalPositioning, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, seedingProfile = params.seedingProfile, structureId = params.structureId, placeByes = params.placeByes, seedsOnly = params.seedsOnly, event = params.event;
    if (!event)
        return { error: EVENT_NOT_FOUND };
    if (!drawDefinition)
        return { error: DRAW_DEFINITION_NOT_FOUND };
    var structureIsComplete = isCompletedStructure({
        drawDefinition: drawDefinition,
        structureId: structureId,
    });
    if (!structureIsComplete && !provisionalPositioning) {
        return { error: INCOMPLETE_SOURCE_STRUCTURE };
    }
    var playoffStructures = (_b = getPlayoffStructures({
        drawDefinition: drawDefinition,
        structureId: structureId,
    }).playoffStructures) === null || _b === void 0 ? void 0 : _b.sort(function (a, b) { return getMinFinishingPositionRange(a) - getMinFinishingPositionRange(b); });
    var structurePositionAssignments = [];
    var positioningReports = [];
    if (playoffStructures) {
        try {
            for (var playoffStructures_1 = __values(playoffStructures), playoffStructures_1_1 = playoffStructures_1.next(); !playoffStructures_1_1.done; playoffStructures_1_1 = playoffStructures_1.next()) {
                var structure = playoffStructures_1_1.value;
                var playoffStructureId = structure.structureId;
                var result = automatedPositioning({
                    structureId: playoffStructureId,
                    provisionalPositioning: provisionalPositioning,
                    applyPositioning: applyPositioning,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    seedingProfile: seedingProfile,
                    placeByes: placeByes,
                    seedsOnly: seedsOnly,
                });
                if (result.error)
                    return result;
                if (result.positionAssignments) {
                    structurePositionAssignments.push({
                        positionAssignments: result.positionAssignments,
                        structureId: playoffStructureId,
                    });
                }
                if (result.positioningReport)
                    positioningReports.push(result.positioningReport);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (playoffStructures_1_1 && !playoffStructures_1_1.done && (_a = playoffStructures_1.return)) _a.call(playoffStructures_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return __assign(__assign({}, SUCCESS), { structurePositionAssignments: structurePositionAssignments, positioningReports: positioningReports });
}

function setStructureOrder(_a) {
    var drawDefinition = _a.drawDefinition, orderMap = _a.orderMap;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (typeof orderMap !== 'object' ||
        !Object.values(orderMap).every(function (val) { return isConvertableInteger(val); }))
        decorateResult({
            result: { error: INVALID_VALUES },
            context: { orderMap: orderMap },
        });
    if (!drawDefinition.structures)
        drawDefinition.structures = [];
    drawDefinition.structures.forEach(function (structure) {
        var structureOrder = orderMap[structure.structureId];
        if (structureOrder)
            structure.structureOrder = structureOrder;
    });
    drawDefinition.structures.sort(function (a, b) {
        return numericSortValue(a.structureOrder) - numericSortValue(b.structureOrder);
    });
    return __assign({}, SUCCESS);
}

function resequenceStructures(_a) {
    var e_1, _b;
    var drawDefinition = _a.drawDefinition;
    var _c = getStructureGroups({
        drawDefinition: drawDefinition,
    }), maxQualifyingDepth = _c.maxQualifyingDepth, structureProfiles = _c.structureProfiles;
    try {
        for (var _d = __values(drawDefinition.structures), _e = _d.next(); !_e.done; _e = _d.next()) {
            var structure = _e.value;
            var profile = structureProfiles[structure.structureId];
            if (profile.distanceFromMain) {
                structure.stageSequence =
                    maxQualifyingDepth + 1 - profile.distanceFromMain;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}

function attachQualifyingStructure(_a) {
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, structure = _a.structure, link = _a.link;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var result = attachQualifying({
        tournamentId: tournamentRecord.tournamentId,
        drawDefinition: drawDefinition,
        structure: structure,
        link: link,
    });
    if (result.error)
        return result;
    var qualifyingDetails = {
        structureId: structure.structureId,
        drawId: drawDefinition.drawId,
    };
    var timeItem = {
        itemType: 'attachQualifyingStructures',
        itemValue: qualifyingDetails,
    };
    addTournamentTimeItem({ tournamentRecord: tournamentRecord, timeItem: timeItem });
    return result;
}
function attachQualifying(_a) {
    var _b;
    var drawDefinition = _a.drawDefinition, tournamentId = _a.tournamentId, structure = _a.structure, eventId = _a.eventId, link = _a.link;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structure)
        return { error: MISSING_STRUCTURE };
    if (!link)
        return { error: MISSING_TARGET_LINK };
    var targetStructureId = link.target.structureId;
    var result = findStructure({
        drawDefinition: drawDefinition,
        structureId: targetStructureId,
    });
    if (result.error)
        return decorateResult({
            stack: 'attachQualifyingStructure',
            context: { targetStructureId: targetStructureId },
            result: result,
        });
    if (!drawDefinition.structures)
        drawDefinition.structures = [];
    if (!drawDefinition.links)
        drawDefinition.links = [];
    drawDefinition.structures.push(structure);
    drawDefinition.links.push(link);
    resequenceStructures({ drawDefinition: drawDefinition });
    var matchUps = ((_b = getAllStructureMatchUps({ structure: structure })) === null || _b === void 0 ? void 0 : _b.matchUps) || [];
    addMatchUpsNotice({
        drawDefinition: drawDefinition,
        tournamentId: tournamentId,
        matchUps: matchUps,
        eventId: eventId,
    });
    modifyDrawNotice({ drawDefinition: drawDefinition, structureIds: [structure.structureId] });
    return __assign({}, SUCCESS);
}

var FORMAT_STANDARD = 'SET3-S:6/TB7'; // Best of 3 Tiebreak Sets to 6
var FORMAT_STANDARD_NOAD = 'SET3-S:6NOAD'; // Best of 3 NOAD Sets to 6 with deciding game at 5-5
var FORMAT_ATP_DOUBLES = 'SET3-S:6/TB7-F:TB10'; // Best of 3 Sets to 6, no Ad, Final Set Tiebreak to 10
var FORMAT_SHORT_SETS = 'SET3-S:4/TB7'; // Best of 3 Sets to 4'
var FORMAT_FAST4 = 'SET3-S:4/TB5@3'; // Best of 3 Sets to 4, Tiebreak at 3
var TIMED20 = 'SET1-S:T20'; // Timed 20 minute set
var FORMAT_PRO_SET = 'SET1-S:8/TB7'; // One Set to 8 with Advantage with tiebreak at 8-8
var FORMAT_COLLEGE_PRO_SET = 'SET1-S:8/TB7@7'; // One Set to 8 with tiebreak at 7-7
var matchUpFormats = {
    FORMAT_STANDARD: FORMAT_STANDARD,
    FORMAT_STANDARD_NOAD: FORMAT_STANDARD_NOAD,
    FORMAT_ATP_DOUBLES: FORMAT_ATP_DOUBLES,
    FORMAT_SHORT_SETS: FORMAT_SHORT_SETS,
    FORMAT_FAST4: FORMAT_FAST4,
    FORMAT_PRO_SET: FORMAT_PRO_SET,
    FORMAT_COLLEGE_PRO_SET: FORMAT_COLLEGE_PRO_SET,
    TIMED20: TIMED20,
};

function countSets(_a) {
    var e_1, _b;
    var _c;
    var matchUpWinningSide = _a.winningSide, _d = _a.matchUpFormat, matchUpFormat = _d === void 0 ? FORMAT_STANDARD : _d, matchUpStatus = _a.matchUpStatus, tallyPolicy = _a.tallyPolicy, score = _a.score;
    var setsTally = [0, 0];
    var sets = score === null || score === void 0 ? void 0 : score.sets;
    var matchUpWinnerIndex = typeof matchUpWinningSide === 'number' && matchUpWinningSide - 1;
    var parsedMatchUpFormat = parse(matchUpFormat);
    var setsToWin = getSetsToWin((_c = parsedMatchUpFormat === null || parsedMatchUpFormat === void 0 ? void 0 : parsedMatchUpFormat.bestOf) !== null && _c !== void 0 ? _c : 1);
    if (typeof matchUpWinnerIndex === 'number' &&
        ((matchUpStatus === DEFAULTED && (tallyPolicy === null || tallyPolicy === void 0 ? void 0 : tallyPolicy.setsCreditForDefaults)) ||
            (matchUpStatus === WALKOVER$2 && (tallyPolicy === null || tallyPolicy === void 0 ? void 0 : tallyPolicy.setsCreditForWalkovers)))) {
        // in the case of WALKOVER or DEFAULT, matchUp winner gets full sets to win value
        setsTally[matchUpWinnerIndex] = setsToWin;
    }
    else {
        try {
            for (var _e = __values(sets || []), _f = _e.next(); !_f.done; _f = _e.next()) {
                var set = _f.value;
                var setWinningSide = set.winningSide;
                if (setWinningSide)
                    setsTally[setWinningSide - 1] += 1;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    if (typeof matchUpWinnerIndex === 'number' && matchUpStatus === RETIRED$1) {
        // if the loser has setsToWin then last set was incomplete and needs to be subtracted from loser
        if (+setsTally[1 - matchUpWinnerIndex] === setsToWin)
            setsTally[1 - matchUpWinnerIndex] -= 1;
        if (tallyPolicy === null || tallyPolicy === void 0 ? void 0 : tallyPolicy.setsCreditForRetirements)
            setsTally[matchUpWinnerIndex] = setsToWin;
    }
    return setsTally;
}
function countGames(_a) {
    var _b, _c, _d;
    var _e = _a.matchUpFormat, matchUpFormat = _e === void 0 ? FORMAT_STANDARD : _e, matchUpWinningSide = _a.winningSide, matchUpStatus = _a.matchUpStatus, tallyPolicy = _a.tallyPolicy, score = _a.score;
    // IMPORTANT: recognize finalSetFormat
    var sets = (score || {}).sets;
    if (!sets)
        return [0, 0];
    var matchUpWinnerIndex = typeof matchUpWinningSide === 'number' && matchUpWinningSide - 1;
    var parsedMatchUpFormat = parse(matchUpFormat);
    var bestOf = (_b = parsedMatchUpFormat === null || parsedMatchUpFormat === void 0 ? void 0 : parsedMatchUpFormat.bestOf) !== null && _b !== void 0 ? _b : 1;
    var setsToWin = getSetsToWin(bestOf);
    var tiebreakAt = ((_c = parsedMatchUpFormat === null || parsedMatchUpFormat === void 0 ? void 0 : parsedMatchUpFormat.setFormat) === null || _c === void 0 ? void 0 : _c.tiebreakAt) || 0;
    var gamesTally = [[], []];
    if (typeof matchUpWinnerIndex === 'number' &&
        ((matchUpStatus === DEFAULTED && (tallyPolicy === null || tallyPolicy === void 0 ? void 0 : tallyPolicy.gamesCreditForDefaults)) ||
            (matchUpStatus === WALKOVER$2 && (tallyPolicy === null || tallyPolicy === void 0 ? void 0 : tallyPolicy.gamesCreditForWalkovers)))) {
        var gamesForSet = ((_d = parsedMatchUpFormat === null || parsedMatchUpFormat === void 0 ? void 0 : parsedMatchUpFormat.setFormat) === null || _d === void 0 ? void 0 : _d.setTo) || 0;
        var minimumGameWins = setsToWin * gamesForSet;
        gamesTally[matchUpWinnerIndex].push(minimumGameWins);
    }
    else {
        sets.forEach(function (set, i) {
            var _a;
            var setNumber = set.setNumber || i + 1;
            var whichFormat = setNumber > setsToWin && (parsedMatchUpFormat === null || parsedMatchUpFormat === void 0 ? void 0 : parsedMatchUpFormat.finalSetFormat)
                ? 'finalSetFormat'
                : 'setFormat';
            var based = (_a = parsedMatchUpFormat === null || parsedMatchUpFormat === void 0 ? void 0 : parsedMatchUpFormat[whichFormat]) === null || _a === void 0 ? void 0 : _a.based;
            var isTiebreakSet = parsedMatchUpFormat === null || parsedMatchUpFormat === void 0 ? void 0 : parsedMatchUpFormat[whichFormat].tiebreakSet;
            var side1Score = set.side1Score, side2Score = set.side2Score;
            if (isGamesBased(based)) {
                gamesTally[0].push(ensureInt(side1Score || 0));
                gamesTally[1].push(ensureInt(side2Score || 0));
            }
            // count a tiebreak set also as a game won
            if (isTiebreakSet &&
                set.winningSide &&
                (tallyPolicy === null || tallyPolicy === void 0 ? void 0 : tallyPolicy.gamesCreditForTiebreakSets) !== false) {
                gamesTally[set.winningSide - 1].push(1);
            }
        });
    }
    if (matchUpStatus === RETIRED$1 && typeof matchUpWinnerIndex === 'number') {
        // setFormat must consider whether retirment occurred in a finalSet which has a different format
        var whichFormat = sets.length > setsToWin && (parsedMatchUpFormat === null || parsedMatchUpFormat === void 0 ? void 0 : parsedMatchUpFormat.finalSetFormat)
            ? 'finalSetFormat'
            : 'setFormat';
        var format = parsedMatchUpFormat === null || parsedMatchUpFormat === void 0 ? void 0 : parsedMatchUpFormat[whichFormat];
        if (isGamesBased(format.based)) {
            var gamesForSet_1 = (format === null || format === void 0 ? void 0 : format.setTo) || 0;
            var getComplement = function (value) {
                if (!parsedMatchUpFormat || value === '')
                    return;
                if (+value === tiebreakAt - 1 || +value === tiebreakAt)
                    return ensureInt(tiebreakAt || 0) + 1;
                if (+value < tiebreakAt)
                    return gamesForSet_1;
                return tiebreakAt;
            };
            var setsTally = countSets({
                winningSide: matchUpWinningSide,
                score: { sets: sets },
                matchUpStatus: matchUpStatus,
                matchUpFormat: matchUpFormat,
                tallyPolicy: tallyPolicy,
            });
            var loserLeadSet = gamesTally
                .map(function (g) { return g[matchUpWinnerIndex] <= g[1 - matchUpWinnerIndex]; })
                .reduce(function (a, b) { return a + (b ? 1 : 0); }, 0);
            // if sets where loser lead > awarded sets, adjust last game to winner
            if (loserLeadSet > setsTally[1 - matchUpWinnerIndex]) {
                var talliedGames = gamesTally[matchUpWinnerIndex].length;
                var complement = getComplement(gamesTally[1 - matchUpWinnerIndex][talliedGames - 1]);
                if (complement)
                    gamesTally[matchUpWinnerIndex][talliedGames - 1] = complement;
            }
            // if the gamesTally[x].length is less than the number of sets to win award gamesForSet to winner
            // gamesTally[x].length is an array of games won for each set, so length is number of sets
            if (setsToWin > gamesTally[matchUpWinnerIndex].length &&
                (tallyPolicy === null || tallyPolicy === void 0 ? void 0 : tallyPolicy.gamesCreditForRetirements)) {
                gamesTally[matchUpWinnerIndex].push(gamesForSet_1);
            }
        }
    }
    return [
        gamesTally[0].reduce(function (a, b) { return a + b; }, 0),
        gamesTally[1].reduce(function (a, b) { return a + b; }, 0),
    ];
}
function countPoints(_a) {
    var _b, _c;
    var matchUpFormat = _a.matchUpFormat, score = _a.score;
    var parsedMatchUpFormat = matchUpFormat ? parse(matchUpFormat) : undefined;
    var bestOf = (_b = parsedMatchUpFormat === null || parsedMatchUpFormat === void 0 ? void 0 : parsedMatchUpFormat.bestOf) !== null && _b !== void 0 ? _b : 1;
    var setsToWin = getSetsToWin(bestOf);
    var tiebreaksTally = [0, 0];
    var pointsTally = [0, 0];
    (_c = score === null || score === void 0 ? void 0 : score.sets) === null || _c === void 0 ? void 0 : _c.forEach(function (set, i) {
        var _a;
        var setNumber = set.setNumber || i + 1;
        var whichFormat = setNumber > setsToWin && (parsedMatchUpFormat === null || parsedMatchUpFormat === void 0 ? void 0 : parsedMatchUpFormat.finalSetFormat)
            ? 'finalSetFormat'
            : 'setFormat';
        var based = (_a = parsedMatchUpFormat === null || parsedMatchUpFormat === void 0 ? void 0 : parsedMatchUpFormat[whichFormat]) === null || _a === void 0 ? void 0 : _a.based;
        if (isPointsBased(based)) {
            var side1Score = set.side1Score, side2Score = set.side2Score;
            if (side1Score)
                pointsTally[0] += ensureInt(side1Score || 0);
            if (side2Score)
                pointsTally[1] += ensureInt(side2Score || 0);
        }
        else {
            if (set.side1TiebreakScore)
                pointsTally[0] += ensureInt(set.side1TiebreakScore || 0);
            if (set.side2TiebreakScore)
                pointsTally[1] += ensureInt(set.side2TiebreakScore || 0);
            if ((set.side1TiebreakScore || set.side2TiebreakScore) && set.winningSide)
                tiebreaksTally[set.winningSide - 1] += 1;
        }
    });
    return { pointsTally: pointsTally, tiebreaksTally: tiebreaksTally };
}
function getSetsToWin(bestOfGames) {
    return (bestOfGames && Math.ceil(bestOfGames / 2)) || 1;
}
function isPointsBased(based) {
    return based === 'P';
}
function isGamesBased(based) {
    return !isPointsBased(based);
}

function calculatePercentages(_a) {
    var _b;
    var participantResults = _a.participantResults, matchUpFormat = _a.matchUpFormat, tallyPolicy = _a.tallyPolicy, perPlayer = _a.perPlayer, totalSets = _a.totalSets;
    var parsedGroupMatchUpFormat = (matchUpFormat && parse(matchUpFormat)) || {};
    var bestOfGames = parsedGroupMatchUpFormat.bestOf;
    var bracketSetsToWin = (bestOfGames && Math.ceil(bestOfGames / 2)) || 1;
    var bracketGamesForSet = (_b = parsedGroupMatchUpFormat.setFormat) === null || _b === void 0 ? void 0 : _b.setTo;
    Object.keys(participantResults).forEach(function (participantId) {
        var setsWon = participantResults[participantId].setsWon;
        var setsLost = participantResults[participantId].setsLost;
        var setsTotal = (tallyPolicy === null || tallyPolicy === void 0 ? void 0 : tallyPolicy.groupTotalSetsPlayed)
            ? totalSets
            : perPlayer * (bracketSetsToWin || 0) || setsWon + setsLost;
        var setsPct = Math.round((setsWon / setsTotal) * 1000) / 1000;
        if (setsPct === Infinity || isNaN(setsPct))
            setsPct = setsTotal;
        var tieMatchUpsWon = participantResults[participantId].tieMatchUpsWon;
        var tieMatchUpsLost = participantResults[participantId].tieMatchUpsLost;
        var tieMatchUpsTotal = tieMatchUpsWon + tieMatchUpsLost;
        var tieMatchUpsPct = Math.round((tieMatchUpsWon / tieMatchUpsTotal) * 1000) / 1000;
        if (tieMatchUpsPct === Infinity || isNaN(tieMatchUpsPct))
            tieMatchUpsPct = tieMatchUpsWon;
        var matchUpsWon = participantResults[participantId].matchUpsWon;
        var matchUpsLost = participantResults[participantId].matchUpsLost;
        var matchUpsTotal = matchUpsWon + matchUpsLost;
        var matchUpsPct = Math.round((matchUpsWon / matchUpsTotal) * 1000) / 1000;
        if (matchUpsPct === Infinity || isNaN(matchUpsPct))
            matchUpsPct = matchUpsWon;
        var gamesWon = participantResults[participantId].gamesWon || 0;
        var gamesLost = participantResults[participantId].gamesLost || 0;
        var minimumExpectedGames = (perPlayer || 0) * (bracketSetsToWin || 0) * (bracketGamesForSet || 0);
        var gamesTotal = Math.max(minimumExpectedGames, gamesWon + gamesLost);
        var gamesPct = Math.round((gamesWon / gamesTotal) * 1000) / 1000;
        if (gamesPct === Infinity || isNaN(gamesPct))
            gamesPct = 0;
        var pointsPct = Math.round((participantResults[participantId].pointsWon /
            participantResults[participantId].pointsLost) *
            1000) / 1000;
        if (pointsPct === Infinity || isNaN(pointsPct))
            pointsPct = 0;
        participantResults[participantId].setsWon = setsWon;
        participantResults[participantId].setsLost = setsLost;
        participantResults[participantId].setsPct = setsPct;
        participantResults[participantId].tieMatchUpsWon = tieMatchUpsWon;
        participantResults[participantId].tieMatchUpsPct = tieMatchUpsPct;
        participantResults[participantId].matchUpsPct = matchUpsPct;
        participantResults[participantId].gamesWon = gamesWon;
        participantResults[participantId].gamesLost = gamesLost;
        participantResults[participantId].gamesPct = gamesPct;
        participantResults[participantId].pointsPct = pointsPct;
        participantResults[participantId].result =
            "".concat(participantResults[participantId].matchUpsWon, "/").concat(participantResults[participantId].matchUpsLost);
    });
}

function getParticipantResults(_a) {
    var e_1, _b, e_2, _c, e_3, _d;
    var _e, _f, _g, _h, _j, _k, _l;
    var participantIds = _a.participantIds, matchUpFormat = _a.matchUpFormat, tallyPolicy = _a.tallyPolicy, perPlayer = _a.perPlayer, matchUps = _a.matchUps;
    var participantResults = {};
    var excludeMatchUpStatuses = (tallyPolicy === null || tallyPolicy === void 0 ? void 0 : tallyPolicy.excludeMatchUpStatuses) || [];
    var filteredMatchUps = matchUps.filter(function (matchUp) {
        return (
        // Do not filter out team matchUps based on matchUpStatus
        (matchUp.tieMatchUps ||
            !excludeMatchUpStatuses.includes(matchUp.matchUpStatus)) &&
            // include if no participantIds (idsFilter active) have been specified
            // if idsFilter is active then exclude matchUps which are not between specified participantIds
            (!(participantIds === null || participantIds === void 0 ? void 0 : participantIds.length) ||
                intersection(participantIds, [
                    getSideId(matchUp, 0),
                    getSideId(matchUp, 1),
                ]).length === 2));
    });
    var allSets = filteredMatchUps.flatMap(function (_a) {
        var _b, _c;
        var score = _a.score, tieMatchUps = _a.tieMatchUps;
        return tieMatchUps
            ? tieMatchUps
                .filter(function (_a) {
                var matchUpStatus = _a.matchUpStatus;
                return !excludeMatchUpStatuses.includes(matchUpStatus);
            })
                .flatMap(function (_a) {
                var _b, _c;
                var score = _a.score;
                return (_c = (_b = score === null || score === void 0 ? void 0 : score.sets) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
            })
            : (_c = (_b = score === null || score === void 0 ? void 0 : score.sets) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
    });
    var totalSets = allSets.reduce(function (a, b) { return a + b; }, 0);
    try {
        for (var filteredMatchUps_1 = __values(filteredMatchUps), filteredMatchUps_1_1 = filteredMatchUps_1.next(); !filteredMatchUps_1_1.done; filteredMatchUps_1_1 = filteredMatchUps_1.next()) {
            var matchUp = filteredMatchUps_1_1.value;
            var matchUpStatus = matchUp.matchUpStatus, tieMatchUps = matchUp.tieMatchUps, tieFormat = matchUp.tieFormat, score = matchUp.score, winningSide = matchUp.winningSide, sides = matchUp.sides;
            var manualGamesOverride = tieFormat &&
                matchUp._disableAutoCalc &&
                tieFormat.collectionDefinitions.every(function (_a) {
                    var scoreValue = _a.scoreValue;
                    return scoreValue;
                });
            var winningParticipantId = winningSide && getWinningSideId(matchUp);
            var losingParticipantId = winningSide && getLosingSideId(matchUp);
            if (!winningParticipantId && !losingParticipantId) {
                if (matchUpStatus && completedMatchUpStatuses.includes(matchUpStatus)) {
                    var participantIdSide1 = getSideId(matchUp, 0);
                    var participantIdSide2 = getSideId(matchUp, 1);
                    if (participantIdSide1) {
                        checkInitializeParticipant(participantResults, participantIdSide1);
                        participantResults[participantIdSide1].matchUpsCancelled += 1;
                    }
                    if (participantIdSide2) {
                        checkInitializeParticipant(participantResults, participantIdSide2);
                        participantResults[participantIdSide2].matchUpsCancelled += 1;
                    }
                }
                else if (tieMatchUps === null || tieMatchUps === void 0 ? void 0 : tieMatchUps.length) {
                    perPlayer = 0; // if any matchUps are matchUpType: TEAM don't calculate perPlayer
                    var _loop_1 = function (tieMatchUp) {
                        if (tieMatchUp.winningSide) {
                            var tieWinningParticipantId = (_e = sides === null || sides === void 0 ? void 0 : sides.find(function (_a) {
                                var sideNumber = _a.sideNumber;
                                return sideNumber === tieMatchUp.winningSide;
                            })) === null || _e === void 0 ? void 0 : _e.participantId;
                            var tieLosingParticipantId = (_f = sides === null || sides === void 0 ? void 0 : sides.find(function (_a) {
                                var sideNumber = _a.sideNumber;
                                return sideNumber === tieMatchUp.winningSide;
                            })) === null || _f === void 0 ? void 0 : _f.participantId;
                            if (tieWinningParticipantId && tieLosingParticipantId) {
                                checkInitializeParticipant(participantResults, tieWinningParticipantId);
                                checkInitializeParticipant(participantResults, tieLosingParticipantId);
                                participantResults[tieWinningParticipantId].tieMatchUpsWon += 1;
                                participantResults[tieLosingParticipantId].tieMatchUpsLost += 1;
                                if (tieMatchUp.matchUpType === SINGLES) {
                                    participantResults[tieWinningParticipantId].tieSinglesWon += 1;
                                    participantResults[tieLosingParticipantId].tieSinglesLost += 1;
                                }
                                else if (tieMatchUp.matchUpType === DOUBLES) {
                                    participantResults[tieWinningParticipantId].tieDoublesWon += 1;
                                    participantResults[tieLosingParticipantId].tieDoublesLost += 1;
                                }
                            }
                        }
                        processScore({
                            score: tieMatchUp.score,
                            manualGamesOverride: manualGamesOverride,
                            participantResults: participantResults,
                            sides: sides,
                        });
                    };
                    try {
                        for (var tieMatchUps_1 = (e_2 = void 0, __values(tieMatchUps)), tieMatchUps_1_1 = tieMatchUps_1.next(); !tieMatchUps_1_1.done; tieMatchUps_1_1 = tieMatchUps_1.next()) {
                            var tieMatchUp = tieMatchUps_1_1.value;
                            _loop_1(tieMatchUp);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (tieMatchUps_1_1 && !tieMatchUps_1_1.done && (_c = tieMatchUps_1.return)) _c.call(tieMatchUps_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                else {
                    processScore({
                        manualGamesOverride: manualGamesOverride,
                        participantResults: participantResults,
                        score: score,
                        sides: sides,
                    });
                }
            }
            else {
                checkInitializeParticipant(participantResults, winningParticipantId);
                checkInitializeParticipant(participantResults, losingParticipantId);
                if (tieMatchUps === null || tieMatchUps === void 0 ? void 0 : tieMatchUps.length) {
                    perPlayer = 0; // if any matchUps are matchUpType: TEAM don't calculate perPlayer
                    try {
                        for (var tieMatchUps_2 = (e_3 = void 0, __values(tieMatchUps)), tieMatchUps_2_1 = tieMatchUps_2.next(); !tieMatchUps_2_1.done; tieMatchUps_2_1 = tieMatchUps_2.next()) {
                            var tieMatchUp = tieMatchUps_2_1.value;
                            var matchUpType = tieMatchUp.matchUpType;
                            var isDoubles = matchUpType === DOUBLES;
                            var isSingles = matchUpType === SINGLES;
                            if (tieMatchUp.winningSide) {
                                // logic ensures that losing TEAM participant gets credit for tieMatchUps won & etc.
                                if (tieMatchUp.winningSide === winningSide) {
                                    if (winningParticipantId) {
                                        participantResults[winningParticipantId].tieMatchUpsWon += 1;
                                        if (isSingles)
                                            participantResults[winningParticipantId].tieSinglesWon += 1;
                                        if (isDoubles)
                                            participantResults[winningParticipantId].tieDoublesWon += 1;
                                    }
                                    if (losingParticipantId) {
                                        participantResults[losingParticipantId].tieMatchUpsLost += 1;
                                        if (isSingles)
                                            participantResults[losingParticipantId].tieSinglesLost += 1;
                                        if (isDoubles) {
                                            participantResults[losingParticipantId].tieDoublesLost += 1;
                                        }
                                    }
                                }
                                else if (tieMatchUp.winningSide !== winningSide) {
                                    if (losingParticipantId) {
                                        participantResults[losingParticipantId].tieMatchUpsWon += 1;
                                        if (isSingles)
                                            participantResults[losingParticipantId].tieSinglesWon += 1;
                                        if (isDoubles) {
                                            participantResults[losingParticipantId].tieDoublesWon += 1;
                                        }
                                    }
                                    if (winningParticipantId) {
                                        participantResults[winningParticipantId].tieMatchUpsLost += 1;
                                        if (isSingles)
                                            participantResults[winningParticipantId].tieSinglesLost += 1;
                                        if (isDoubles) {
                                            participantResults[winningParticipantId].tieDoublesLost += 1;
                                        }
                                    }
                                }
                            }
                            processMatchUp({
                                matchUpFormat: tieMatchUp.matchUpFormat,
                                matchUpStatus: tieMatchUp.matchUpStatus,
                                score: tieMatchUp.score,
                                winningParticipantId: winningParticipantId,
                                losingParticipantId: losingParticipantId,
                                participantResults: participantResults,
                                isTieMatchUp: true,
                                manualGamesOverride: manualGamesOverride,
                                tallyPolicy: tallyPolicy,
                                winningSide: winningSide,
                            });
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (tieMatchUps_2_1 && !tieMatchUps_2_1.done && (_d = tieMatchUps_2.return)) _d.call(tieMatchUps_2);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                    processOutcome$1({
                        winningParticipantId: winningParticipantId,
                        losingParticipantId: losingParticipantId,
                        participantResults: participantResults,
                        matchUpStatus: matchUpStatus,
                    });
                }
                else {
                    processMatchUp({
                        matchUpFormat: (_g = matchUp.matchUpFormat) !== null && _g !== void 0 ? _g : matchUpFormat,
                        isTieMatchUp: undefined,
                        winningParticipantId: winningParticipantId,
                        manualGamesOverride: manualGamesOverride,
                        losingParticipantId: losingParticipantId,
                        participantResults: participantResults,
                        matchUpStatus: matchUpStatus,
                        tallyPolicy: tallyPolicy,
                        winningSide: winningSide,
                        score: score,
                    });
                }
            }
            if (manualGamesOverride) {
                var side1participantId = (_h = sides === null || sides === void 0 ? void 0 : sides.find(function (_a) {
                    var sideNumber = _a.sideNumber;
                    return sideNumber === 1;
                })) === null || _h === void 0 ? void 0 : _h.participantId;
                var side2participantId = (_j = sides === null || sides === void 0 ? void 0 : sides.find(function (_a) {
                    var sideNumber = _a.sideNumber;
                    return sideNumber === 2;
                })) === null || _j === void 0 ? void 0 : _j.participantId;
                checkInitializeParticipant(participantResults, side1participantId);
                checkInitializeParticipant(participantResults, side2participantId);
                var gamesWonSide1 = (_k = score === null || score === void 0 ? void 0 : score.sets) === null || _k === void 0 ? void 0 : _k.reduce(function (total, set) { var _a; return total + ((_a = set === null || set === void 0 ? void 0 : set.side1Score) !== null && _a !== void 0 ? _a : 0); }, 0);
                var gamesWonSide2 = (_l = score === null || score === void 0 ? void 0 : score.sets) === null || _l === void 0 ? void 0 : _l.reduce(function (total, set) { var _a; return total + ((_a = set.side2Score) !== null && _a !== void 0 ? _a : 0); }, 0);
                if (side1participantId) {
                    participantResults[side1participantId].gamesWon += gamesWonSide1;
                    participantResults[side1participantId].gamesLost += gamesWonSide2;
                }
                if (side2participantId) {
                    participantResults[side2participantId].gamesWon += gamesWonSide2;
                    participantResults[side2participantId].gamesLost += gamesWonSide1;
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (filteredMatchUps_1_1 && !filteredMatchUps_1_1.done && (_b = filteredMatchUps_1.return)) _b.call(filteredMatchUps_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    calculatePercentages({
        participantResults: participantResults,
        matchUpFormat: matchUpFormat,
        tallyPolicy: tallyPolicy,
        perPlayer: perPlayer,
        totalSets: totalSets,
    });
    return { participantResults: participantResults };
}
function getWinningSideId(matchUp) {
    var winnerIndex = matchUp.winningSide - 1;
    return getSideId(matchUp, winnerIndex);
}
function getLosingSideId(matchUp) {
    var loserIndex = 1 - (matchUp.winningSide - 1);
    return getSideId(matchUp, loserIndex);
}
function getSideId(matchUp, index) {
    if (!(matchUp === null || matchUp === void 0 ? void 0 : matchUp.sides)) {
        console.log('no sides:', { matchUp: matchUp });
        return 'foo';
    }
    var Side = matchUp.sides[index];
    if (!Side) {
        console.log('No Side', { matchUp: matchUp, index: index });
        return 'foo';
    }
    return Side.participantId;
}
function checkInitializeParticipant(participantResults, participantId) {
    if (participantId && !participantResults[participantId])
        participantResults[participantId] = {
            allDefaults: 0,
            defaults: 0,
            defeats: [],
            gamesLost: 0,
            gamesWon: 0,
            matchUpsCancelled: 0,
            matchUpsLost: 0,
            matchUpsWon: 0,
            pointsLost: 0,
            pointsWon: 0,
            retirements: 0,
            setsLost: 0,
            setsWon: 0,
            tieSinglesWon: 0,
            tieSinglesLost: 0,
            tieDoublesWon: 0,
            tieDoublesLost: 0,
            tieMatchUpsLost: 0,
            tieMatchUpsWon: 0,
            victories: [],
            walkovers: 0,
        };
}
function processScore(_a) {
    var e_4, _b;
    var manualGamesOverride = _a.manualGamesOverride, participantResults = _a.participantResults, score = _a.score, sides = _a.sides;
    var sets = (score || {}).sets;
    var gamesTally = [[], []];
    var setsTally = [0, 0];
    try {
        for (var _c = __values(sets || []), _d = _c.next(); !_d.done; _d = _c.next()) {
            var set = _d.value;
            var setWinningSide = set.winningSide, side1Score = set.side1Score, side2Score = set.side2Score;
            if (setWinningSide)
                setsTally[setWinningSide - 1] += 1;
            gamesTally[0].push(ensureInt(side1Score || 0));
            gamesTally[1].push(ensureInt(side2Score || 0));
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_4) throw e_4.error; }
    }
    var gamesTotal = [
        gamesTally[0].reduce(function (a, b) { return a + b; }, 0),
        gamesTally[1].reduce(function (a, b) { return a + b; }, 0),
    ];
    sides.forEach(function (side, i) {
        var participantId = side.participantId;
        if (participantId) {
            checkInitializeParticipant(participantResults, participantId);
            participantResults[participantId].setsWon += setsTally[i];
            participantResults[participantId].setsLost += setsTally[1 - i];
            if (!manualGamesOverride) {
                participantResults[participantId].gamesWon += gamesTotal[i];
                participantResults[participantId].gamesLost += gamesTotal[1 - i];
            }
        }
    });
}
function processMatchUp(_a) {
    var winningParticipantId = _a.winningParticipantId, losingParticipantId = _a.losingParticipantId, participantResults = _a.participantResults, manualGamesOverride = _a.manualGamesOverride, matchUpFormat = _a.matchUpFormat, matchUpStatus = _a.matchUpStatus, isTieMatchUp = _a.isTieMatchUp, tallyPolicy = _a.tallyPolicy, winningSide = _a.winningSide, score = _a.score;
    var winningSideIndex = winningSide && winningSide - 1;
    var losingSideIndex = 1 - winningSideIndex;
    if (!isTieMatchUp) {
        processOutcome$1({
            winningParticipantId: winningParticipantId,
            losingParticipantId: losingParticipantId,
            participantResults: participantResults,
            matchUpStatus: matchUpStatus,
        });
    }
    var setsTally = countSets({
        matchUpStatus: matchUpStatus,
        matchUpFormat: matchUpFormat,
        tallyPolicy: tallyPolicy,
        winningSide: winningSide,
        score: score,
    });
    var gamesTally = countGames({
        matchUpStatus: matchUpStatus,
        matchUpFormat: matchUpFormat,
        tallyPolicy: tallyPolicy,
        winningSide: winningSide,
        score: score,
    });
    var pointsTally = countPoints({ score: score, matchUpFormat: matchUpFormat }).pointsTally;
    if (winningParticipantId) {
        participantResults[winningParticipantId].setsWon +=
            setsTally[winningSideIndex];
        participantResults[winningParticipantId].setsLost +=
            setsTally[losingSideIndex];
        if (!manualGamesOverride) {
            participantResults[winningParticipantId].gamesWon +=
                gamesTally[winningSideIndex];
            participantResults[winningParticipantId].gamesLost +=
                gamesTally[losingSideIndex];
        }
        participantResults[winningParticipantId].pointsWon +=
            pointsTally[winningSideIndex];
        participantResults[winningParticipantId].pointsLost +=
            pointsTally[losingSideIndex];
    }
    if (losingParticipantId) {
        participantResults[losingParticipantId].setsWon +=
            setsTally[losingSideIndex];
        participantResults[losingParticipantId].setsLost +=
            setsTally[winningSideIndex];
        if (!manualGamesOverride) {
            participantResults[losingParticipantId].gamesWon +=
                gamesTally[losingSideIndex];
            participantResults[losingParticipantId].gamesLost +=
                gamesTally[winningSideIndex];
        }
        participantResults[losingParticipantId].pointsWon +=
            pointsTally[losingSideIndex];
        participantResults[losingParticipantId].pointsLost +=
            pointsTally[winningSideIndex];
    }
}
function processOutcome$1(_a) {
    var winningParticipantId = _a.winningParticipantId, losingParticipantId = _a.losingParticipantId, participantResults = _a.participantResults, matchUpStatus = _a.matchUpStatus;
    if (losingParticipantId) {
        if (matchUpStatus === WALKOVER$2)
            participantResults[losingParticipantId].walkovers += 1;
        if (matchUpStatus === DEFAULTED)
            participantResults[losingParticipantId].defaults += 1;
        if (matchUpStatus === RETIRED$1)
            participantResults[losingParticipantId].retirements += 1;
        // attribute to catch all scenarios where participant terminated matchUp irregularly
        if ([DEFAULTED, RETIRED$1, WALKOVER$2].includes(matchUpStatus))
            participantResults[losingParticipantId].allDefaults += 1;
        participantResults[losingParticipantId].matchUpsLost += 1;
    }
    if (winningParticipantId) {
        participantResults[winningParticipantId].matchUpsWon += 1;
    }
    if (losingParticipantId && winningParticipantId) {
        participantResults[losingParticipantId].defeats.push(winningParticipantId);
        participantResults[winningParticipantId].victories.push(losingParticipantId);
    }
}

function getTallyReport(_a) {
    var matchUps = _a.matchUps, order = _a.order, report = _a.report;
    var participants = {};
    matchUps.forEach(function (_a) {
        var sides = _a.sides;
        sides.forEach(function (side) {
            if (side.participantId && side.participant) {
                participants[side.participantId] = side.participant.participantName;
            }
        });
    });
    var readable = [];
    if (Array.isArray(report)) {
        report.forEach(function (step, i) {
            var _a, _b, _c;
            if ((_a = step.excludedDirectives) === null || _a === void 0 ? void 0 : _a.length) {
                var attributes = step.excludedDirectives
                    .map(function (_a) {
                    var attribute = _a.attribute;
                    return attribute;
                })
                    .join(', ');
                var note = "".concat(attributes.length, " directives were excluded due to participants limit}");
                readable.push(note);
                var excluded = "Excluded: ".concat(attributes);
                readable.push(excluded);
            }
            else {
                var floatSort_1 = function (a, b) {
                    return parseFloat(step.reversed ? a : b) - parseFloat(step.reversed ? b : a);
                };
                var participantsCount = step.groups
                    ? Object.values(step.groups).flat(Infinity).length
                    : (_c = (_b = step.participantIds) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
                var getExplanation = function (step) {
                    step.groups &&
                        Object.keys(step.groups)
                            .sort(floatSort_1)
                            .forEach(function (key) {
                            var participantNames = step.groups[key]
                                .map(function (participantId) { return participants[participantId]; })
                                .join(', ');
                            var explanation = "".concat(key, " ").concat(step.attribute, ": ").concat(participantNames);
                            readable.push(explanation);
                        });
                };
                var reversed = step.reversed ? ' in reverse order' : '';
                var action = step.groups ? 'grouped' : 'separated';
                var description = "Step ".concat(i + 1, ": ").concat(participantsCount, " particiants were ").concat(action).concat(reversed, " by ").concat(step.attribute);
                readable.push(description);
                if (step.idsFilter) {
                    var note = "".concat(step.attribute, " was calculated considering ONLY TIED PARTICIPANTS");
                    readable.push(note);
                }
                getExplanation(step);
            }
            readable.push('----------------------');
        });
    }
    readable.push('Final Order:');
    order.forEach(function (orderEntry) {
        var participantId = orderEntry.participantId, resolved = orderEntry.resolved;
        var pOrder = orderEntry.groupOrder || orderEntry.provisionalOrder;
        readable.push("".concat(pOrder, ": ").concat(participants[participantId], " => resolved: ").concat(!!resolved));
    });
    return readable.join('\r\n');
}

function getGroups(_a) {
    var participantResults = _a.participantResults, participantIds = _a.participantIds, attribute = _a.attribute;
    var resultsArray = getResultsArray({ participantResults: participantResults, participantIds: participantIds });
    return resultsArray.reduce(function (groups, participantResult) {
        var participantId = participantResult.participantId, results = participantResult.results;
        var value = results === null || results === void 0 ? void 0 : results[attribute];
        if (!isNaN(value) && participantId) {
            if (groups[value]) {
                groups[value].push(participantId);
            }
            else {
                groups[value] = [participantId];
            }
        }
        return groups;
    }, {});
}
function getResultsArray(params) {
    var participantIds = params.participantIds || Object.keys(params.participantResults);
    return participantIds.reduce(function (arr, participantId, i) {
        arr.push({
            participantId: participantId,
            i: i,
            results: params.participantResults[participantId],
        });
        return arr;
    }, []);
}

/*
Round Robin group tally logic by default implements the following guidelines:

The participant who wins the most matches is the winner.
If two players are tied, then the winner of their head-to-head match is the winner.

If three or more players are tied, tie are broken as follows:
• The head-to-head win-loss record in matches involving just the tied players;
• The participant with the highest percentage of sets won of all sets completed;
• The head-to-head win-loss record in matches involving the players who remain tied;
• The participant with the highest percentage of games won of all games completed;
• The head-to-head win-loss record in matches involving the players who remain tied;
• The participant with the highest percentage of sets won of sets completed among players in the group under consideration;
• The head-to-head win-loss record in matches involving the players who remain tied;
• The participant with the highest percentage of games won of games completed among the players under consideration; and
• The head-to-head win-loss record in matches involving the players who remain tied.

After initial separation of participants by `matchUpsWon`,
the implementation is configurable by supplying an array of `tallyDirectives` in the `tallyPolicy`.

The algorithm relies on the values avaialble in the calculated `participantResults` and works as follows:
• separate participants into groups by a given attribute
• a group with a single participant is 'resolved'
• groups of two participants are resolved by head-to-head (if not disabled/if participants faced each other)
• groups of three or more search for an attribute that will separate them into smaller groups
• participantResults scoped to the members of a group and recalculated when `{ idsFilter: true }`
• when { maxParticipants: 2 } is defined the rule is skipped if there are more than maxParticipants tied
*/
var headToHeadTallyDirectives = [
    { attribute: 'matchUpsPct', idsFilter: false },
    { attribute: 'allDefaults', reversed: true, idsFilter: false },
    { attribute: 'defaults', reversed: true, idsFilter: false },
    { attribute: 'walkovers', reversed: true, idsFilter: false },
    { attribute: 'retirements', reversed: true, idsFilter: false },
    { attribute: 'setsPct', idsFilter: false },
    { attribute: 'gamesPct', idsFilter: false },
    { attribute: 'pointsPct', idsFilter: false },
    { attribute: 'matchUpsPct', idsFilter: true },
    { attribute: 'setsPct', idsFilter: true },
    { attribute: 'gamesPct', idsFilter: true },
    { attribute: 'pointsPct', idsFilter: true },
];
// defines offsets for generating large integer for comparison
var GEMScoreValueMap = {
    matchUpsPct: 20,
    tieMatchUpsPct: 16,
    setsPct: 12,
    gamesPct: 8,
    pointsPct: 4,
};
/**
 *
 * @param {object[]} participantResults - calculated results for each participant
 * @param {number} participantsCount - number of participants in round robin group
 * @param {object} subOrderMap - { [participantId]: subOrder }
 *
 */
function getGroupOrder(params) {
    var _a = params.requireCompletion, requireCompletion = _a === void 0 ? true : _a, participantResults = params.participantResults, subOrderMap = params.subOrderMap, tallyPolicy = params.tallyPolicy;
    var report = [];
    // if not all opponents have completed their matchUps, no orders are assigned
    if (requireCompletion && !isComplete(params)) {
        return {};
    }
    var attribute = [
        'tieMatchUpsWon',
        'tieSinglesWon',
        'tieDoublesWon',
        'matchUpsWon',
        'pointsWon',
        'gamesWon',
        'setsWon',
        'gamesPct',
        'setsPct',
        'pointsPct',
        'matchUpsPct',
    ].includes(tallyPolicy === null || tallyPolicy === void 0 ? void 0 : tallyPolicy.groupOrderKey)
        ? tallyPolicy.groupOrderKey
        : 'matchUpsWon';
    var orderedTallyGroups = getGroups({
        participantResults: participantResults,
        attribute: attribute,
    });
    report.push({ attribute: attribute, groups: orderedTallyGroups });
    var groupOrder = Object.keys(orderedTallyGroups)
        .map(function (key) { return parseFloat(key); })
        .sort(function (a, b) { return b - a; })
        .map(function (key) { return orderedTallyGroups[key]; })
        .map(function (participantIds) {
        var _a;
        var result = groupSubSort(__assign({ participantIds: participantIds }, params));
        report.push.apply(report, __spreadArray([], __read(((_a = result.report) !== null && _a !== void 0 ? _a : [])), false));
        return result.order;
    })
        .flat(Infinity);
    var groupPosition = 1;
    var priorPositionResolution;
    groupOrder.forEach(function (finishingPosition, index) {
        if (
        // after the first position, which is always 1,
        index &&
            // increment group position if position is resolved
            (finishingPosition.resolved ||
                // increment group position if position is unresolved and prior position was resolved
                (priorPositionResolution && !finishingPosition.resolved))) {
            groupPosition += 1;
        }
        // update prior position resolution
        priorPositionResolution = finishingPosition.resolved;
        if (finishingPosition.resolved) {
            // if a position is resolved, position is index + 1
            finishingPosition.position = index + 1;
            // if a position is resolved, update groupPosition
            groupPosition = finishingPosition.position;
        }
        else {
            // if a position is unresovled, position is groupPosition
            finishingPosition.position = groupPosition;
        }
    });
    var positions = groupOrder.map(function (_a) {
        var position = _a.position;
        return position;
    });
    var positionsCount = instanceCount(positions);
    groupOrder.forEach(function (finishingPosition) {
        var _a = finishingPosition || {}, participantId = _a.participantId, position = _a.position;
        var participantResult = participantResults[participantId];
        finishingPosition.GEMscore = getRatioHash(participantResult);
        var positionInstances = positionsCount[position];
        if ((finishingPosition === null || finishingPosition === void 0 ? void 0 : finishingPosition.position) !== undefined) {
            // subOrder is only assigned if there are ties
            if (positionInstances > 1) {
                finishingPosition.ties = positionInstances;
                if (subOrderMap) {
                    finishingPosition.subOrder = subOrderMap[participantId];
                }
            }
            finishingPosition.rankOrder = position;
            finishingPosition.groupOrder =
                position + (finishingPosition.subOrder || 1) - 1;
        }
    });
    return { groupOrder: groupOrder, report: report.flat(Infinity).filter(Boolean) };
    // NOTE: TallyPolicy.GEMscore could be an object instead of an array of attributes
    // which would allow for custom valueMaps... or valueMap could use index as multiplier
    function getRatioHash(result) {
        var attributes = Array.isArray(tallyPolicy === null || tallyPolicy === void 0 ? void 0 : tallyPolicy.GEMscore)
            ? Object.keys(GEMScoreValueMap).filter(function (attribute) {
                return tallyPolicy.GEMscore.includes(attribute);
            })
            : Object.keys(GEMScoreValueMap);
        var attributeValues = attributes.map(function (attribute) {
            return (result[attribute] || 0) *
                Math.pow(10, GEMScoreValueMap[attribute].toFixed(3));
        });
        return attributeValues.reduce(function (a, b) { return a + b; }, 0);
    }
}
function isComplete(_a) {
    var participantResults = _a.participantResults, participantsCount = _a.participantsCount;
    var resultsArray = getResultsArray({ participantResults: participantResults });
    var participantsFinished = resultsArray.filter(function (r) {
        return participantsCount - 1 ===
            r.results.matchUpsWon +
                r.results.matchUpsLost +
                r.results.matchUpsCancelled;
    });
    return participantsCount === participantsFinished.length;
}
function processAttribute(_a) {
    var disableHeadToHead = _a.disableHeadToHead, participantIds = _a.participantIds, matchUpFormat = _a.matchUpFormat, tallyPolicy = _a.tallyPolicy, attribute = _a.attribute, idsFilter = _a.idsFilter, matchUps = _a.matchUps, reversed = _a.reversed;
    var participantResults = getParticipantResults({
        participantIds: idsFilter && participantIds,
        matchUpFormat: matchUpFormat,
        tallyPolicy: tallyPolicy,
        matchUps: matchUps,
    }).participantResults;
    var groups = getGroups({
        participantResults: participantResults,
        participantIds: participantIds,
        attribute: attribute,
    });
    var report = [{ attribute: attribute, reversed: reversed, groups: groups, idsFilter: idsFilter }];
    var order;
    if (Object.keys(groups).length > 1 && participantIds.length) {
        // separation by attribute was successful
        order = Object.keys(groups)
            .map(function (key) { return parseFloat(key); })
            .sort(function (a, b) { return (reversed ? a - b : b - a); })
            .map(function (key) { return groups[key]; })
            .map(function (participantIds) {
            var _a;
            var result = groupSubSort({
                participantResults: participantResults,
                disableHeadToHead: disableHeadToHead,
                participantIds: participantIds,
                matchUpFormat: matchUpFormat,
                tallyPolicy: tallyPolicy,
                matchUps: matchUps,
            });
            report.push.apply(report, __spreadArray([], __read(((_a = result.report) !== null && _a !== void 0 ? _a : [])), false));
            return result.order;
        })
            .flat(Infinity);
    }
    return { order: order, report: report };
}
function groupSubSort(_a) {
    var participantResults = _a.participantResults, disableHeadToHead = _a.disableHeadToHead, participantIds = _a.participantIds, matchUpFormat = _a.matchUpFormat, tallyPolicy = _a.tallyPolicy, matchUps = _a.matchUps;
    var excludedDirectives = [];
    var report = [];
    var result;
    if ((participantIds === null || participantIds === void 0 ? void 0 : participantIds.length) === 1) {
        var participantId = participantIds[0];
        return {
            order: [{ resolved: true, participantId: participantId }],
        };
    }
    if ((participantIds === null || participantIds === void 0 ? void 0 : participantIds.length) === 2 &&
        (!(tallyPolicy === null || tallyPolicy === void 0 ? void 0 : tallyPolicy.headToHead) ||
            (!tallyPolicy.headToHead.disabled && !disableHeadToHead))) {
        var result_1 = headToHeadWinner({ participantIds: participantIds, participantResults: participantResults });
        if (result_1) {
            var headToHeadWinner_1 = result_1[0].participantId;
            report.push({ attribute: 'head2Head', participantIds: participantIds, headToHeadWinner: headToHeadWinner_1 });
            return { order: [result_1], headToHeadWinner: headToHeadWinner_1, report: report };
        }
    }
    var directives = (tallyPolicy === null || tallyPolicy === void 0 ? void 0 : tallyPolicy.tallyDirectives) || headToHeadTallyDirectives;
    var filteredDirectives = directives.filter(function (directive) {
        // if maxParticipants is defined, filter out the rule if # of participants is greater than maxParticipants
        var keepDirective = !(isNumeric(directive.maxParticipants) &&
            (participantIds === null || participantIds === void 0 ? void 0 : participantIds.length) > directive.maxParticipants);
        if (!keepDirective)
            excludedDirectives.push(directive);
        return keepDirective;
    });
    if (excludedDirectives.length)
        report.push({ excludedDirectives: excludedDirectives, participantIds: participantIds });
    filteredDirectives.every(function (_a) {
        var attribute = _a.attribute, reversed = _a.reversed, idsFilter = _a.idsFilter, disableHeadToHead = _a.disableHeadToHead;
        result = processAttribute({
            disableHeadToHead: disableHeadToHead,
            participantIds: participantIds,
            matchUpFormat: matchUpFormat,
            tallyPolicy: tallyPolicy,
            attribute: attribute,
            idsFilter: idsFilter,
            matchUps: matchUps,
            reversed: reversed,
        });
        report.push(result.report);
        // return false if a rule has successfully broken the tie
        return result.order ? false : true;
    });
    if (result.order)
        return { order: result.order, report: report };
    return {
        order: participantIds === null || participantIds === void 0 ? void 0 : participantIds.map(function (participantId) { return ({ participantId: participantId }); }),
        report: report,
    };
}
// NOTE: This currently considers one victory rather than a head2head win/loss record (considering rounds of play where participants may encounter each other more than once)
function headToHeadWinner(_a) {
    var participantIds = _a.participantIds, participantResults = _a.participantResults;
    if (!participantIds)
        return;
    if (participantResults[participantIds[0]].victories.includes(participantIds[1])) {
        return participantIds.map(function (participantId) { return ({
            resolved: true,
            participantId: participantId,
        }); });
    }
    else if (participantResults[participantIds[1]].victories.includes(participantIds[0])) {
        return participantIds
            .reverse()
            .map(function (participantId) { return ({ resolved: true, participantId: participantId }); });
    }
}

function tallyParticipantResults(_a) {
    var policyDefinitions = _a.policyDefinitions, generateReport = _a.generateReport, matchUpFormat = _a.matchUpFormat, _b = _a.matchUps, matchUps = _b === void 0 ? [] : _b, subOrderMap = _a.subOrderMap, perPlayer = _a.perPlayer;
    if (!validMatchUps(matchUps))
        return { error: MISSING_MATCHUPS };
    var structureIds = matchUps.reduce(function (structureIds, _a) {
        var structureId = _a.structureId;
        return structureIds.includes(structureId)
            ? structureIds
            : structureIds.concat(structureId);
    }, []);
    if (structureIds.length !== 1)
        return { error: INVALID_VALUES, info: 'Maximum one structureId' };
    var relevantMatchUps = matchUps.filter(function (matchUp) { return matchUp && matchUp.matchUpStatus !== BYE; });
    var participantsCount = relevantMatchUps.length &&
        unique(relevantMatchUps.map(function (_a) {
            var drawPositions = _a.drawPositions;
            return drawPositions;
        }).flat())
            .length;
    var bracketComplete = relevantMatchUps.filter(function (matchUp) { return checkMatchUpIsComplete({ matchUp: matchUp }); })
        .length === relevantMatchUps.length;
    // if bracket is incomplete don't use expected matchUps perPlayer for calculating
    if (!bracketComplete)
        perPlayer = 0;
    var completedTieMatchUps = matchUps.every(function (_a) {
        var matchUpType = _a.matchUpType, tieMatchUps = _a.tieMatchUps;
        return matchUpType === TEAM &&
            (tieMatchUps === null || tieMatchUps === void 0 ? void 0 : tieMatchUps.every(function (matchUp) { return checkMatchUpIsComplete({ matchUp: matchUp }); }));
    });
    var tallyPolicy = policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_ROUND_ROBIN_TALLY];
    var consideredMatchUps = matchUps.filter(function (matchUp) {
        return checkMatchUpIsComplete({ matchUp: matchUp }) || matchUp.matchUpType === TEAM;
    });
    var participantResults = getParticipantResults({
        matchUps: consideredMatchUps,
        matchUpFormat: matchUpFormat,
        tallyPolicy: tallyPolicy,
        perPlayer: perPlayer,
    }).participantResults;
    var report, order;
    var _c = getGroupOrder({
        matchUps: consideredMatchUps,
        participantResults: participantResults,
        participantsCount: participantsCount,
        matchUpFormat: matchUpFormat,
        tallyPolicy: tallyPolicy,
        subOrderMap: subOrderMap,
    }), groupOrder = _c.groupOrder, groupOrderReport = _c.report;
    // do not add groupOrder if bracket is not complete
    if (bracketComplete && groupOrder) {
        report = groupOrderReport;
        order = groupOrder;
        groupOrder.forEach(function (finishingPosition) {
            var participantId = finishingPosition.participantId, groupOrder = finishingPosition.groupOrder, rankOrder = finishingPosition.rankOrder, subOrder = finishingPosition.subOrder, ties = finishingPosition.ties, GEMscore = finishingPosition.GEMscore;
            var participantResult = participantResults[participantId];
            Object.assign(participantResult, {
                groupOrder: groupOrder,
                rankOrder: rankOrder,
                GEMscore: GEMscore,
                subOrder: subOrder,
                ties: ties,
            });
        });
    }
    else {
        var _d = getGroupOrder({
            requireCompletion: false,
            participantResults: participantResults,
            participantsCount: participantsCount,
            matchUpFormat: matchUpFormat,
            tallyPolicy: tallyPolicy,
            subOrderMap: subOrderMap,
            matchUps: matchUps,
        }), provisionalOrder = _d.groupOrder, provisionalOrderReport = _d.report;
        report = provisionalOrderReport;
        order = provisionalOrder;
        if (provisionalOrder) {
            provisionalOrder.forEach(function (finishingPosition) {
                var participantId = finishingPosition.participantId, groupOrder = finishingPosition.groupOrder, GEMscore = finishingPosition.GEMscore;
                var participantResult = participantResults[participantId];
                Object.assign(participantResult, {
                    provisionalOrder: groupOrder,
                    GEMscore: GEMscore,
                });
            });
        }
    }
    var result = {
        completedTieMatchUps: completedTieMatchUps,
        readableReport: '',
        participantResults: participantResults,
        bracketComplete: bracketComplete,
        order: [],
        report: report,
    };
    if (bracketComplete || completedTieMatchUps) {
        result.order = order;
    }
    if (generateReport || getDevContext({ tally: true })) {
        var readable = getTallyReport({ matchUps: matchUps, report: report, order: order });
        if (getDevContext({ tally: true }))
            console.log(readable);
        result.readableReport = readable;
    }
    return result;
}

function evaluateCollectionResult(_a) {
    var collectionDefinition = _a.collectionDefinition, groupValueNumbers = _a.groupValueNumbers, groupValueGroups = _a.groupValueGroups, sideTieValues = _a.sideTieValues, tieMatchUps = _a.tieMatchUps;
    var collectionMatchUps = tieMatchUps.filter(function (matchUp) { return matchUp.collectionId === collectionDefinition.collectionId; });
    // keep track of the values derived from matchUps
    var sideMatchUpValues = [0, 0];
    // will be equivalent to sideMatchUpValues unless there is a collectionValue,
    // in which case the sideMatchUpValues are used in comparision with winCriteria
    var sideCollectionValues = [0, 0];
    var allCollectionMatchUpsCompleted = collectionMatchUps.every(function (matchUp) {
        return completedMatchUpStatuses.includes(matchUp.matchUpStatus);
    });
    var collectionValueProfiles = collectionDefinition.collectionValueProfiles, collectionGroupNumber = collectionDefinition.collectionGroupNumber, collectionValue = collectionDefinition.collectionValue, matchUpValue = collectionDefinition.matchUpValue, winCriteria = collectionDefinition.winCriteria, scoreValue = collectionDefinition.scoreValue, setValue = collectionDefinition.setValue;
    var belongsToValueGroup = collectionGroupNumber && groupValueNumbers.includes(collectionGroupNumber);
    var sideWins = [0, 0];
    collectionMatchUps.forEach(function (matchUp) {
        if (matchUp.winningSide)
            sideWins[matchUp.winningSide - 1] += 1;
    });
    if (isConvertableInteger(matchUpValue)) {
        // if tiebreak set count as set value and game value
        collectionMatchUps.forEach(function (matchUp) {
            if (matchUp.winningSide) {
                sideMatchUpValues[matchUp.winningSide - 1] += matchUpValue;
            }
        });
    }
    else if (isConvertableInteger(setValue)) {
        collectionMatchUps.forEach(function (matchUp) {
            var _a, _b;
            (_b = (_a = matchUp.score) === null || _a === void 0 ? void 0 : _a.sets) === null || _b === void 0 ? void 0 : _b.forEach(function (set) {
                if (set.winningSide)
                    sideMatchUpValues[set.winningSide - 1] += setValue;
            });
        });
    }
    else if (isConvertableInteger(scoreValue)) {
        collectionMatchUps.forEach(function (matchUp) {
            var _a, _b;
            (_b = (_a = matchUp.score) === null || _a === void 0 ? void 0 : _a.sets) === null || _b === void 0 ? void 0 : _b.forEach(function (set) {
                var _a = set.side1TiebreakScore, side1TiebreakScore = _a === void 0 ? 0 : _a, _b = set.side2TiebreakScore, side2TiebreakScore = _b === void 0 ? 0 : _b, _c = set.side1Score, side1Score = _c === void 0 ? 0 : _c, _d = set.side2Score, side2Score = _d === void 0 ? 0 : _d;
                if (matchUp.matchUpStatus === COMPLETED$1 ||
                    matchUp.winningSide ||
                    set.winningSide) {
                    if (side1Score || side2Score) {
                        sideMatchUpValues[0] += side1Score;
                        sideMatchUpValues[1] += side2Score;
                    }
                    else if ((side1TiebreakScore || side2TiebreakScore) &&
                        set.winningSide) {
                        sideMatchUpValues[set.winningSide - 1] += 1;
                    }
                }
            });
        });
    }
    else if (Array.isArray(collectionValueProfiles)) {
        // this must come last because it will be true for []
        collectionMatchUps.forEach(function (matchUp) {
            if (matchUp.winningSide) {
                var collectionPosition = matchUp.collectionPosition;
                var matchUpValue_1 = getCollectionPositionValue({
                    collectionDefinition: collectionDefinition,
                    collectionPosition: collectionPosition,
                });
                if (isConvertableInteger(matchUpValue_1)) {
                    sideMatchUpValues[matchUp.winningSide - 1] += matchUpValue_1;
                }
            }
        });
    }
    // processed separately so that setValue, scoreValue and collecitonValueProfile can be used in conjunction with collectionValue
    if (isConvertableInteger(collectionValue)) {
        var collectionWinningSide = void 0;
        if (winCriteria === null || winCriteria === void 0 ? void 0 : winCriteria.aggregateValue) {
            if (allCollectionMatchUpsCompleted) {
                if (isConvertableInteger(matchUpValue || setValue || scoreValue) &&
                    sideMatchUpValues[0] !== sideMatchUpValues[1]) {
                    collectionWinningSide =
                        sideMatchUpValues[0] > sideMatchUpValues[1] ? 1 : 2;
                }
                else if (sideWins[0] !== sideWins[1]) {
                    collectionWinningSide = sideWins[0] > sideWins[1] ? 1 : 2;
                }
            }
        }
        else if (winCriteria === null || winCriteria === void 0 ? void 0 : winCriteria.valueGoal) {
            collectionWinningSide = sideMatchUpValues.reduce(function (winningSide, side, i) {
                return side >= winCriteria.valueGoal ? i + 1 : winningSide;
            }, 0);
        }
        else {
            var winGoal_1 = Math.floor(collectionDefinition.matchUpCount / 2) + 1;
            collectionWinningSide = sideWins.reduce(function (winningSide, side, i) {
                return side >= winGoal_1 ? i + 1 : winningSide;
            }, 0);
        }
        if (collectionWinningSide) {
            if (belongsToValueGroup) {
                groupValueGroups[collectionGroupNumber].values[collectionWinningSide - 1] += collectionValue;
            }
            else {
                sideCollectionValues[collectionWinningSide - 1] += collectionValue;
            }
        }
    }
    else if (belongsToValueGroup) {
        groupValueGroups[collectionGroupNumber].values[0] +=
            sideMatchUpValues[0] || 0;
        groupValueGroups[collectionGroupNumber].values[1] +=
            sideMatchUpValues[1] || 0;
    }
    else {
        sideCollectionValues = sideMatchUpValues;
    }
    if (!belongsToValueGroup) {
        sideCollectionValues.forEach(function (sideCollectionValue, i) { return (sideTieValues[i] += sideCollectionValue || 0); });
    }
    else {
        groupValueGroups[collectionGroupNumber].sideWins[0] += sideWins[0] || 0;
        groupValueGroups[collectionGroupNumber].sideWins[1] += sideWins[1] || 0;
        groupValueGroups[collectionGroupNumber].allGroupMatchUpsCompleted =
            groupValueGroups[collectionGroupNumber].allGroupMatchUpsCompleted &&
                allCollectionMatchUpsCompleted;
        groupValueGroups[collectionGroupNumber].matchUpsCount +=
            collectionMatchUps.length;
    }
}
function getCollectionPositionValue(_a) {
    var collectionDefinition = _a.collectionDefinition, collectionPosition = _a.collectionPosition;
    var collectionValueProfiles = collectionDefinition.collectionValueProfiles || [];
    var profile = collectionValueProfiles === null || collectionValueProfiles === void 0 ? void 0 : collectionValueProfiles.find(function (profile) { return profile.collectionPosition === collectionPosition; });
    return profile === null || profile === void 0 ? void 0 : profile.matchUpValue;
}

function generateTieMatchUpScore(params) {
    var e_1, _a, e_2, _b;
    var _c, _d, _e, _f, _g;
    var _h = params.sideAdjustments, sideAdjustments = _h === void 0 ? [0, 0] : _h, // currently unused?
    _j = params.separator, // currently unused?
    separator = _j === void 0 ? '-' : _j, drawDefinition = params.drawDefinition, matchUpsMap = params.matchUpsMap, structure = params.structure, matchUp = params.matchUp, event = params.event;
    if (!Array.isArray(sideAdjustments) ||
        sideAdjustments.length !== 2 ||
        isNaN(sideAdjustments.reduce(function (a, b) { return a + b; }))) {
        return { error: INVALID_VALUES };
    }
    if (!matchUp)
        return { error: MISSING_MATCHUP };
    var tieFormat = ((_c = resolveTieFormat({ matchUp: matchUp, drawDefinition: drawDefinition, structure: structure, event: event })) === null || _c === void 0 ? void 0 : _c.tieFormat) || (params === null || params === void 0 ? void 0 : params.tieFormat);
    if (!tieFormat)
        return { error: MISSING_TIE_FORMAT };
    var result = validateTieFormat({ tieFormat: tieFormat });
    if (result.error)
        return result;
    var collectionDefinitions = (tieFormat === null || tieFormat === void 0 ? void 0 : tieFormat.collectionDefinitions) || [];
    var tieMatchUps = (_d = matchUp === null || matchUp === void 0 ? void 0 : matchUp.tieMatchUps) !== null && _d !== void 0 ? _d : [];
    var sideTieValues = [0, 0];
    var _k = getGroupValueGroups(tieFormat), groupValueGroups = _k.groupValueGroups, groupValueNumbers = _k.groupValueNumbers;
    try {
        for (var collectionDefinitions_1 = __values(collectionDefinitions), collectionDefinitions_1_1 = collectionDefinitions_1.next(); !collectionDefinitions_1_1.done; collectionDefinitions_1_1 = collectionDefinitions_1.next()) {
            var collectionDefinition = collectionDefinitions_1_1.value;
            evaluateCollectionResult({
                collectionDefinition: collectionDefinition,
                groupValueNumbers: groupValueNumbers,
                groupValueGroups: groupValueGroups,
                sideTieValues: sideTieValues,
                tieMatchUps: tieMatchUps,
            });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (collectionDefinitions_1_1 && !collectionDefinitions_1_1.done && (_a = collectionDefinitions_1.return)) _a.call(collectionDefinitions_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var _loop_1 = function (groupNumber) {
        var group = groupValueGroups[groupNumber];
        var allGroupMatchUpsCompleted = group.allGroupMatchUpsCompleted, matchUpCount = group.matchUpCount, winCriteria = group.winCriteria, groupValue = group.groupValue, sideWins = group.sideWins, values = group.values;
        var groupWinningSide = void 0;
        if (winCriteria === null || winCriteria === void 0 ? void 0 : winCriteria.aggregateValue) {
            if (allGroupMatchUpsCompleted && values[0] !== values[1]) {
                groupWinningSide = values[0] > values[1] ? 1 : 2;
            }
        }
        else if (winCriteria === null || winCriteria === void 0 ? void 0 : winCriteria.valueGoal) {
            groupWinningSide = values.reduce(function (winningSide, side, i) {
                return side >= winCriteria.valueGoal ? i + 1 : winningSide;
            }, undefined);
        }
        else {
            var winGoal_1 = Math.floor(matchUpCount / 2) + 1;
            groupWinningSide = sideWins.reduce(function (winningSide, side, i) {
                return side >= winGoal_1 ? i + 1 : winningSide;
            }, undefined);
        }
        if (groupWinningSide) {
            sideTieValues[groupWinningSide - 1] += groupValue || 0;
        }
    };
    try {
        // process each relevant group for groupValue
        for (var groupValueNumbers_1 = __values(groupValueNumbers), groupValueNumbers_1_1 = groupValueNumbers_1.next(); !groupValueNumbers_1_1.done; groupValueNumbers_1_1 = groupValueNumbers_1.next()) {
            var groupNumber = groupValueNumbers_1_1.value;
            _loop_1(groupNumber);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (groupValueNumbers_1_1 && !groupValueNumbers_1_1.done && (_b = groupValueNumbers_1.return)) _b.call(groupValueNumbers_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var sideScores = sideTieValues.map(function (sideTieValue, i) { return (sideTieValue || 0) + sideAdjustments[i]; });
    var set = {
        side1Score: sideScores[0],
        side2Score: sideScores[1],
        winningSide: undefined,
    };
    var scoreStringSide1 = sideScores.join(separator);
    var scoreStringSide2 = sideScores.slice().reverse().join(separator);
    // now calculate if there is a winningSide
    var winningSide;
    if (tieFormat === null || tieFormat === void 0 ? void 0 : tieFormat.winCriteria) {
        var _l = tieFormat.winCriteria, valueGoal_1 = _l.valueGoal, aggregateValue = _l.aggregateValue, tallyDirectives = _l.tallyDirectives;
        if (valueGoal_1) {
            var sideThatWon = sideScores
                .map(function (points, sideIndex) { return ({ sideNumber: sideIndex + 1, points: points }); })
                .find(function (_a) {
                var points = _a.points;
                return points >= valueGoal_1;
            });
            winningSide = sideThatWon === null || sideThatWon === void 0 ? void 0 : sideThatWon.sideNumber;
        }
        else if (aggregateValue) {
            var allTieMatchUpsCompleted = tieMatchUps.every(function (matchUp) {
                return (matchUp.matchUpStatus &&
                    completedMatchUpStatuses.includes(matchUp.matchUpStatus)) ||
                    matchUp.winningSide;
            });
            if (allTieMatchUpsCompleted && sideScores[0] !== sideScores[1]) {
                winningSide = sideScores[0] > sideScores[1] ? 1 : 2;
            }
        }
        if (!winningSide && tallyDirectives) {
            var matchUpId = matchUp.matchUpId;
            var inContextMatchUp = matchUp.hasContext
                ? matchUp
                : ((_e = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.drawMatchUps) === null || _e === void 0 ? void 0 : _e[matchUpId]) ||
                    (drawDefinition &&
                        ((_f = findDrawMatchUp({
                            inContext: true,
                            drawDefinition: drawDefinition,
                            matchUpId: matchUpId,
                        })) === null || _f === void 0 ? void 0 : _f.matchUp));
            if (inContextMatchUp) {
                var _m = tallyParticipantResults({
                    matchUps: [inContextMatchUp],
                }), completedTieMatchUps = _m.completedTieMatchUps, order = _m.order;
                if (completedTieMatchUps && (order === null || order === void 0 ? void 0 : order.length)) {
                    var winningParticipantId_1 = order[0].participantId;
                    winningSide = (_g = inContextMatchUp.sides.find(function (_a) {
                        var participantId = _a.participantId;
                        return participantId === winningParticipantId_1;
                    })) === null || _g === void 0 ? void 0 : _g.sideNumber;
                }
            }
        }
    }
    if (winningSide)
        set.winningSide = winningSide;
    return {
        scoreStringSide1: scoreStringSide1,
        scoreStringSide2: scoreStringSide2,
        winningSide: winningSide,
        set: set,
    };
}

var toBePlayed = {
    matchUpStatus: TO_BE_PLAYED,
    matchUpStatusCodes: [],
    score: {
        scoreStringSide1: '',
        scoreStringSide2: '',
        sets: undefined,
    },
    matchUpFormat: undefined,
    winningSide: undefined,
};

function getProjectedDualWinningSide(_a) {
    var e_1, _b;
    var _c;
    var drawDefinition = _a.drawDefinition, matchUpStatus = _a.matchUpStatus, matchUpsMap = _a.matchUpsMap, winningSide = _a.winningSide, dualMatchUp = _a.dualMatchUp, tieFormat = _a.tieFormat, structure = _a.structure, matchUp = _a.matchUp, event = _a.event, score = _a.score;
    var projectedDualMatchUp = makeDeepCopy(dualMatchUp, undefined, true);
    try {
        for (var _d = __values((projectedDualMatchUp === null || projectedDualMatchUp === void 0 ? void 0 : projectedDualMatchUp.tieMatchUps) || []), _e = _d.next(); !_e.done; _e = _d.next()) {
            var tieMatchUp = _e.value;
            if (tieMatchUp.matchUpId === matchUp.matchUpId) {
                tieMatchUp.winningSide = winningSide;
                tieMatchUp.score = score;
                if (!checkScoreHasValue({ score: score }) && !matchUpStatus) {
                    Object.assign(tieMatchUp, __assign({}, toBePlayed));
                }
                else if (matchUpStatus) {
                    tieMatchUp.matchUpStatus = matchUpStatus;
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    tieFormat =
        tieFormat !== null && tieFormat !== void 0 ? tieFormat : (_c = resolveTieFormat({ matchUp: matchUp, structure: structure, drawDefinition: drawDefinition, event: event })) === null || _c === void 0 ? void 0 : _c.tieFormat;
    var projectedWinningSide = generateTieMatchUpScore({
        matchUp: projectedDualMatchUp,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        structure: structure,
        tieFormat: tieFormat,
        event: event,
    }).winningSide;
    return { projectedWinningSide: projectedWinningSide };
}

function lastSetFormatIsTimed(inContextMatchUp) {
    var _a;
    var matchUpFormat = inContextMatchUp.matchUpFormat, score = inContextMatchUp.score;
    var lastSetNumber = (_a = score === null || score === void 0 ? void 0 : score.sets) === null || _a === void 0 ? void 0 : _a.length;
    var matchUpScoringFormat = matchUpFormat && parse(matchUpFormat);
    var _b = matchUpScoringFormat !== null && matchUpScoringFormat !== void 0 ? matchUpScoringFormat : {}, setFormat = _b.setFormat, finalSetFormat = _b.finalSetFormat, bestOf = _b.bestOf;
    var isLastSet = bestOf && lastSetNumber === bestOf;
    var lastSetFormat = isLastSet ? finalSetFormat || setFormat : setFormat;
    return (lastSetFormat === null || lastSetFormat === void 0 ? void 0 : lastSetFormat.timed) || false;
}

function includesMatchUpStatuses(_a) {
    var _b;
    var _c = _a.matchUpStatuses, matchUpStatuses = _c === void 0 ? [BYE, WALKOVER$2, DEFAULTED] : _c, drawPositionMatchUps = _a.drawPositionMatchUps, loserDrawPosition = _a.loserDrawPosition, sourceMatchUps = _a.sourceMatchUps;
    var sourceMatchUp = drawPositionMatchUps === null || drawPositionMatchUps === void 0 ? void 0 : drawPositionMatchUps.reduce(function (sourceMatchUp, matchUp) {
        return !sourceMatchUp || matchUp.roundNumber > sourceMatchUp.roundNumber
            ? matchUp
            : sourceMatchUp;
    }, undefined);
    var winnerDrawPosition = (_b = sourceMatchUp === null || sourceMatchUp === void 0 ? void 0 : sourceMatchUp.drawPositions) === null || _b === void 0 ? void 0 : _b.find(function (drawPosition) { return drawPosition !== loserDrawPosition; });
    var winnerMatchUpStatuses = sourceMatchUps
        .filter(function (matchUp) { var _a; return (_a = matchUp === null || matchUp === void 0 ? void 0 : matchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.includes(winnerDrawPosition); })
        .map(function (matchUp) { return matchUp.matchUpStatus; });
    var loserMatchUpStatuses = sourceMatchUps
        .filter(function (matchUp) { var _a; return (_a = matchUp === null || matchUp === void 0 ? void 0 : matchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.includes(loserDrawPosition); })
        .map(function (matchUp) { return matchUp.matchUpStatus; });
    var winnerHadMatchUpStatus = overlap(winnerMatchUpStatuses || [], matchUpStatuses);
    var loserHadMatchUpStatus = overlap(loserMatchUpStatuses || [], matchUpStatuses);
    return {
        sourceMatchUp: sourceMatchUp,
        winnerHadMatchUpStatus: winnerHadMatchUpStatus,
        winnerMatchUpStatuses: winnerMatchUpStatuses,
        loserHadMatchUpStatus: loserHadMatchUpStatus,
        loserMatchUpStatuses: loserMatchUpStatuses,
    };
}

function removeSubsequentRoundsParticipant(_a) {
    var e_1, _b;
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, sourceMatchUpStatus = _a.sourceMatchUpStatus, targetDrawPosition = _a.targetDrawPosition, tournamentRecord = _a.tournamentRecord, sourceMatchUpId = _a.sourceMatchUpId, drawDefinition = _a.drawDefinition, structureId = _a.structureId, dualMatchUp = _a.dualMatchUp, roundNumber = _a.roundNumber, matchUpsMap = _a.matchUpsMap, event = _a.event;
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    if ((structure === null || structure === void 0 ? void 0 : structure.structureType) === CONTAINER)
        return __assign({}, SUCCESS);
    matchUpsMap = matchUpsMap !== null && matchUpsMap !== void 0 ? matchUpsMap : getMatchUpsMap({ drawDefinition: drawDefinition });
    var mappedMatchUps = (matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.mappedMatchUps) || {};
    var matchUps = mappedMatchUps[structureId].matchUps;
    var initialRoundNumber = getInitialRoundNumber({
        drawPosition: targetDrawPosition,
        matchUps: matchUps,
    }).initialRoundNumber;
    var relevantMatchUps = matchUps === null || matchUps === void 0 ? void 0 : matchUps.filter(function (matchUp) {
        var _a;
        return matchUp.roundNumber >= roundNumber &&
            matchUp.roundNumber !== initialRoundNumber &&
            ((_a = matchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.includes(targetDrawPosition));
    });
    var positionAssignments = getPositionAssignments$1({
        drawDefinition: drawDefinition,
        structureId: structureId,
    }).positionAssignments;
    try {
        for (var _c = __values(relevantMatchUps !== null && relevantMatchUps !== void 0 ? relevantMatchUps : []), _d = _c.next(); !_d.done; _d = _c.next()) {
            var matchUp = _d.value;
            removeDrawPosition({
                inContextDrawMatchUps: inContextDrawMatchUps,
                sourceMatchUpStatus: sourceMatchUpStatus,
                positionAssignments: positionAssignments,
                targetDrawPosition: targetDrawPosition,
                tournamentRecord: tournamentRecord,
                sourceMatchUpId: sourceMatchUpId,
                drawDefinition: drawDefinition,
                dualMatchUp: dualMatchUp,
                matchUpsMap: matchUpsMap,
                matchUp: matchUp,
                event: event,
            });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}
function removeDrawPosition(_a) {
    var _b, _c, _d;
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, positionAssignments = _a.positionAssignments, sourceMatchUpStatus = _a.sourceMatchUpStatus, targetDrawPosition = _a.targetDrawPosition, tournamentRecord = _a.tournamentRecord, sourceMatchUpId = _a.sourceMatchUpId, drawDefinition = _a.drawDefinition, dualMatchUp = _a.dualMatchUp, matchUpsMap = _a.matchUpsMap, matchUp = _a.matchUp, event = _a.event;
    var stack = 'removeSubsequentDrawPosition';
    if (dualMatchUp) {
        // remove propagated lineUp
        var inContextMatchUp = inContextDrawMatchUps.find(function (_a) {
            var matchUpId = _a.matchUpId;
            return matchUp.matchUpId === matchUpId;
        });
        var targetSideNumber_1 = (_c = (_b = inContextMatchUp.sides) === null || _b === void 0 ? void 0 : _b.find(function (side) { return side.drawPosition === targetDrawPosition; })) === null || _c === void 0 ? void 0 : _c.sideNumber;
        var targetSide = (_d = matchUp.sides) === null || _d === void 0 ? void 0 : _d.find(function (side) { return side.sideNumber === targetSideNumber_1; });
        if (targetSide) {
            delete targetSide.lineUp;
        }
    }
    matchUp.drawPositions = (matchUp.drawPositions || [])
        .map(function (drawPosition) {
        return drawPosition === targetDrawPosition ? undefined : drawPosition;
    })
        .filter(Boolean);
    var matchUpAssignments = positionAssignments.filter(function (_a) {
        var _b;
        var drawPosition = _a.drawPosition;
        return (_b = matchUp.drawPositions) === null || _b === void 0 ? void 0 : _b.includes(drawPosition);
    });
    var matchUpContainsBye = matchUpAssignments.filter(function (assignment) { return assignment.bye; }).length;
    matchUp.matchUpStatus =
        (matchUpContainsBye && BYE) ||
            ([DEFAULTED, WALKOVER$2].includes(matchUp.matchUpStatus) &&
                matchUp.matchUpStatus) ||
            TO_BE_PLAYED;
    // if the matchUpStatus is WALKOVER then it is DOUBLE_WALKOVER produced
    // ... and the winningSide must be removed
    if ([WALKOVER$2, DEFAULTED].includes(matchUp.matchUpStatus))
        matchUp.winningSide = undefined;
    if (matchUp.matchUpStatusCodes) {
        updateMatchUpStatusCodes({
            inContextDrawMatchUps: inContextDrawMatchUps,
            sourceMatchUpStatus: sourceMatchUpStatus,
            sourceMatchUpId: sourceMatchUpId,
            matchUpsMap: matchUpsMap,
            matchUp: matchUp,
        });
    }
    modifyMatchUpNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        eventId: event === null || event === void 0 ? void 0 : event.eventId,
        context: "".concat(stack, "-").concat(targetDrawPosition),
        drawDefinition: drawDefinition,
        matchUp: matchUp,
    });
    return __assign({}, SUCCESS);
}

function findTournamentId(_a) {
    var tournamentRecords = _a.tournamentRecords, eventId = _a.eventId, drawId = _a.drawId;
    var tournamentIdMap = getEventIdsAndDrawIds({ tournamentRecords: tournamentRecords }).tournamentIdMap;
    var tournamentIds = tournamentIdMap
        ? Object.keys(tournamentIdMap)
        : [];
    return tournamentIds.find(function (tournamentId) {
        return (eventId && (tournamentIdMap === null || tournamentIdMap === void 0 ? void 0 : tournamentIdMap[tournamentId].includes(eventId))) ||
            (drawId && (tournamentIdMap === null || tournamentIdMap === void 0 ? void 0 : tournamentIdMap[tournamentId].includes(drawId)));
    });
}

function createSubOrderMap(_a) {
    var positionAssignments = _a.positionAssignments;
    var subOrderArray = (positionAssignments || [])
        .filter(xa(PARTICIPANT_ID))
        .map(function (assignment) {
        var extension = findExtension({
            element: assignment,
            name: SUB_ORDER,
        }).extension;
        var value = ensureInt(extension === null || extension === void 0 ? void 0 : extension.value);
        var subOrder = !isNaN(value) && value;
        return subOrder && { participantId: assignment.participantId, subOrder: subOrder };
    })
        .filter(Boolean);
    // we only want subOrders that are unique, and we want them sorted and re-assigned to ordered values
    var subOrders = subOrderArray.map(function (_a) {
        var subOrder = _a.subOrder;
        return subOrder;
    });
    var subOrdersCount = instanceCount(subOrders);
    var subOrderMap = Object.assign.apply(Object, __spreadArray([{}], __read(subOrderArray
        .filter(function (_a) {
        var subOrder = _a.subOrder;
        return subOrdersCount[subOrder] === 1;
    })
        .map(function (_a) {
        var _b;
        var participantId = _a.participantId, subOrder = _a.subOrder;
        return (_b = {},
            _b[participantId] = subOrder,
            _b);
    })), false));
    return { subOrderMap: subOrderMap };
}

function updateAssignmentParticipantResults(_a) {
    var positionAssignments = _a.positionAssignments, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, matchUpFormat = _a.matchUpFormat, matchUps = _a.matchUps, event = _a.event;
    if (!validMatchUps(matchUps))
        return { error: INVALID_VALUES };
    if (!positionAssignments)
        return { error: INVALID_VALUES };
    var policyDefinitions = getPolicyDefinitions({
        policyTypes: [POLICY_TYPE_ROUND_ROBIN_TALLY],
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        event: event,
    }).policyDefinitions;
    var subOrderMap = createSubOrderMap({ positionAssignments: positionAssignments }).subOrderMap;
    var result = tallyParticipantResults({
        policyDefinitions: policyDefinitions,
        matchUpFormat: matchUpFormat,
        subOrderMap: subOrderMap,
        matchUps: matchUps,
    });
    if (result.error)
        return result;
    var participantResults = result.participantResults, bracketComplete = result.bracketComplete, report = result.report;
    var participantIds = Object.keys(participantResults);
    positionAssignments.forEach(function (assignment) {
        var participantId = assignment.participantId;
        if (participantIds.includes(participantId)) {
            var extension = {
                value: participantResults[participantId],
                name: TALLY,
            };
            addExtension({ element: assignment, extension: extension });
            if (!participantResults[participantId].ties) {
                removeExtension({
                    element: assignment,
                    name: SUB_ORDER,
                });
            }
        }
        else {
            removeExtension({
                element: assignment,
                name: TALLY,
            });
            removeExtension({
                element: assignment,
                name: SUB_ORDER,
            });
        }
    });
    modifyDrawNotice({ drawDefinition: drawDefinition });
    return __assign(__assign({}, SUCCESS), { participantResults: participantResults, bracketComplete: bracketComplete, report: report });
}

function addNotes(params) {
    var _a;
    if (typeof params !== 'object')
        return { error: MISSING_VALUE };
    if (typeof params.element !== 'object')
        return { error: INVALID_VALUES };
    if (!params.notes)
        return { error: MISSING_VALUE };
    if (typeof params.notes !== 'string' && !((_a = params.notes) === null || _a === void 0 ? void 0 : _a.testing))
        return { error: INVALID_VALUES };
    Object.assign(params.element, { notes: params.notes });
    return __assign({}, SUCCESS);
}
function removeNotes(params) {
    if (typeof params !== 'object')
        return { error: MISSING_VALUE };
    if (typeof params.element !== 'object')
        return { error: INVALID_VALUES };
    if (params.element.notes)
        delete params.element.notes;
    return __assign({}, SUCCESS);
}

function modifyMatchUpScore(_a) {
    var e_1, _b;
    var _c, _d, _e, _f, _g, _h, _j, _k, _l;
    var matchUpStatusCodes = _a.matchUpStatusCodes, removeWinningSide = _a.removeWinningSide, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, matchUpFormat = _a.matchUpFormat, matchUpStatus = _a.matchUpStatus, removeScore = _a.removeScore, winningSide = _a.winningSide, matchUpId = _a.matchUpId, matchUp = _a.matchUp, // matchUp without context
    event = _a.event, notes = _a.notes, score = _a.score;
    var stack = 'modifyMatchUpScore';
    var structure;
    var isDualMatchUp = matchUp.matchUpType === TEAM;
    if (isDualMatchUp && drawDefinition) {
        if (matchUpId && matchUp.matchUpId !== matchUpId) {
            // the modification is to be applied to a tieMatchUp
            var findResult = findDrawMatchUp({
                drawDefinition: drawDefinition,
                matchUpId: matchUpId,
                event: event,
            });
            if (!findResult.matchUp)
                return { error: MATCHUP_NOT_FOUND };
            (matchUp = findResult.matchUp, structure = findResult.structure);
        }
    }
    else if (matchUp.matchUpId !== matchUpId) {
        console.log('!!!!!');
    }
    if ((matchUpStatus && [WALKOVER$2, DOUBLE_WALKOVER].includes(matchUpStatus)) ||
        removeScore) {
        Object.assign(matchUp, __assign({}, toBePlayed));
    }
    else if (score) {
        matchUp.score = score;
    }
    var wasDefaulted = matchUpStatus &&
        (matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpStatus) === DEFAULTED &&
        matchUpStatus !== DEFAULTED;
    if (matchUpStatus)
        matchUp.matchUpStatus = matchUpStatus;
    if (matchUpFormat)
        matchUp.matchUpFormat = matchUpFormat;
    if (matchUpStatusCodes)
        matchUp.matchUpStatusCodes = matchUpStatusCodes;
    if (winningSide)
        matchUp.winningSide = winningSide;
    if (removeWinningSide)
        matchUp.winningSide = undefined;
    if (!structure && drawDefinition) {
        (structure = findDrawMatchUp({
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
            event: event,
        }).structure);
    }
    if (matchUpStatus &&
        !matchUp.winningSide &&
        checkScoreHasValue(matchUp) &&
        !completedMatchUpStatuses.includes(matchUpStatus) &&
        ![AWAITING_RESULT, SUSPENDED].includes(matchUpStatus)) {
        matchUp.matchUpStatus = IN_PROGRESS$1;
    }
    var defaultedProcessCodes;
    if ((wasDefaulted && ((_c = matchUp === null || matchUp === void 0 ? void 0 : matchUp.processCodes) === null || _c === void 0 ? void 0 : _c.length)) ||
        matchUpStatus === DEFAULTED) {
        var appliedPolicies = (_d = getAppliedPolicies({
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            structure: structure,
            event: event,
        })) === null || _d === void 0 ? void 0 : _d.appliedPolicies;
        defaultedProcessCodes =
            (_f = (_e = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_SCORING]) === null || _e === void 0 ? void 0 : _e.processCodes) === null || _f === void 0 ? void 0 : _f.incompleteAssignmentsOnDefault;
    }
    if (!matchUp.collectionId) {
        var isRoundRobin = (structure === null || structure === void 0 ? void 0 : structure.structureType) === CONTAINER;
        var isAdHocStructure_1 = isAdHoc({ drawDefinition: drawDefinition, structure: structure });
        if (isLucky({ drawDefinition: drawDefinition, structure: structure }) ||
            isAdHocStructure_1 ||
            isRoundRobin) {
            var updateTally = function (structure) {
                var _a, _b, _c;
                // matchUpFormat set here is only used in updateAssignmentParticipantResults
                matchUpFormat = isDualMatchUp
                    ? 'SET1-S:T100'
                    : (_c = (_b = (_a = matchUpFormat !== null && matchUpFormat !== void 0 ? matchUpFormat : matchUp.matchUpFormat) !== null && _a !== void 0 ? _a : structure === null || structure === void 0 ? void 0 : structure.matchUpFormat) !== null && _b !== void 0 ? _b : drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.matchUpFormat) !== null && _c !== void 0 ? _c : event === null || event === void 0 ? void 0 : event.matchUpFormat;
                var matchUpFilters = isDualMatchUp
                    ? { matchUpTypes: [TEAM] }
                    : undefined;
                var matchUps = getAllStructureMatchUps({
                    afterRecoveryTimes: false,
                    tournamentRecord: tournamentRecord,
                    inContext: true,
                    matchUpFilters: matchUpFilters,
                    drawDefinition: drawDefinition,
                    structure: structure,
                    event: event,
                }).matchUps;
                if (isAdHocStructure_1) {
                    structure.positionAssignments = unique(matchUps
                        .flatMap(function (matchUp) { var _a; return ((_a = matchUp.sides) !== null && _a !== void 0 ? _a : []).map(function (side) { return side.participantId; }); })
                        .filter(Boolean)).map(function (participantId) { return ({ participantId: participantId }); });
                }
                return updateAssignmentParticipantResults({
                    positionAssignments: structure.positionAssignments,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    matchUpFormat: matchUpFormat,
                    matchUps: matchUps,
                    event: event,
                });
            };
            var itemStructure = isRoundRobin &&
                structure.structures.find(function (itemStructure) {
                    return itemStructure === null || itemStructure === void 0 ? void 0 : itemStructure.matchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
                });
            var result = updateTally(itemStructure || structure);
            if (result.error)
                return decorateResult({ result: result, stack: stack });
        }
    }
    if (notes) {
        var result = addNotes({ element: matchUp, notes: notes });
        if (result.error)
            return decorateResult({ result: result, stack: stack });
    }
    var tournamentId = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId;
    var sendInContext = getTopics().topics.includes(UPDATE_INCONTEXT_MATCHUP);
    var matchUpsMap = (sendInContext || defaultedProcessCodes) &&
        getMatchUpsMap({ drawDefinition: drawDefinition });
    var inContextMatchUp = matchUpsMap &&
        ((_g = getAllDrawMatchUps({
            // client will not normally be receiving participants for the first time...
            // ... and should therefore already have groupings / ratings / rankings for participants
            // participantsProfile: { withGroupings: true },
            matchUpFilters: { matchUpIds: [matchUpId] },
            nextMatchUps: true,
            tournamentRecord: tournamentRecord, // required to hydrate participants
            inContext: true,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
        }).matchUps) === null || _g === void 0 ? void 0 : _g[0]);
    if (sendInContext && inContextMatchUp) {
        updateInContextMatchUp({ tournamentId: tournamentId, inContextMatchUp: inContextMatchUp });
    }
    if (Array.isArray(defaultedProcessCodes) &&
        inContextMatchUp &&
        !((_h = inContextMatchUp.sides) === null || _h === void 0 ? void 0 : _h.every(function (_a) {
            var participantId = _a.participantId;
            return participantId;
        }))) {
        if (matchUpStatus === DEFAULTED) {
            matchUp.processCodes = unique(__spreadArray(__spreadArray([], __read(((_j = matchUp.processCodes) !== null && _j !== void 0 ? _j : [])), false), __read(defaultedProcessCodes), false));
        }
        else {
            try {
                for (var _m = __values(defaultedProcessCodes || []), _o = _m.next(); !_o.done; _o = _m.next()) {
                    var processCode = _o.value;
                    var codeIndex = processCode && ((_k = matchUp === null || matchUp === void 0 ? void 0 : matchUp.processCodes) === null || _k === void 0 ? void 0 : _k.lastIndexOf(processCode));
                    // remove only one instance of processCode
                    (_l = matchUp === null || matchUp === void 0 ? void 0 : matchUp.processCodes) === null || _l === void 0 ? void 0 : _l.splice(codeIndex, 1);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_o && !_o.done && (_b = _m.return)) _b.call(_m);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
    modifyMatchUpNotice({
        eventId: event === null || event === void 0 ? void 0 : event.eventId,
        context: stack,
        drawDefinition: drawDefinition,
        tournamentId: tournamentId,
        matchUp: matchUp,
    });
    return __assign({}, SUCCESS);
}

function updateTieMatchUpScore(params) {
    var _a;
    var _b, _c, _d, _e;
    var exitWhenNoValues = params.exitWhenNoValues, drawDefinition = params.drawDefinition, matchUpStatus = params.matchUpStatus, removeScore = params.removeScore, matchUpsMap = params.matchUpsMap, matchUpId = params.matchUpId, event = params.event;
    var tournamentRecords = params.tournamentRecords ||
        (params.tournamentRecord && (_a = {},
            _a[(_b = params.tournamentRecord) === null || _b === void 0 ? void 0 : _b.tournamentId] = params.tournamentRecord,
            _a)) ||
        {};
    var tournamentId = params.tournamentId || ((_c = params.tournamentRecord) === null || _c === void 0 ? void 0 : _c.tournamentId);
    tournamentRecords && findTournamentId(__assign({ tournamentRecords: tournamentRecords }, params));
    var tournamentRecord = tournamentId && tournamentRecords[tournamentId];
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var result = findDrawMatchUp({ drawDefinition: drawDefinition, event: event, matchUpId: matchUpId });
    if (result.error)
        return result;
    if (!result.matchUp)
        return { error: MATCHUP_NOT_FOUND };
    var matchUp = result.matchUp, structure = result.structure;
    if (!matchUp.tieMatchUps)
        return { error: INVALID_MATCHUP };
    ensureSideLineUps({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        eventId: event === null || event === void 0 ? void 0 : event.eventId,
        dualMatchUp: matchUp,
        drawDefinition: drawDefinition,
    });
    var extension = findExtension({
        name: DISABLE_AUTO_CALC,
        element: matchUp,
    }).extension;
    if (extension === null || extension === void 0 ? void 0 : extension.value) {
        if (!removeScore) {
            return __assign(__assign({}, SUCCESS), { score: matchUp.score });
        }
        else {
            removeExtension({ element: matchUp, name: DISABLE_AUTO_CALC });
        }
    }
    var tieFormat = (_d = resolveTieFormat({
        drawDefinition: drawDefinition,
        structure: structure,
        matchUp: matchUp,
        event: event,
    })) === null || _d === void 0 ? void 0 : _d.tieFormat;
    matchUp.tieFormat = copyTieFormat(tieFormat);
    var scoreResult = generateTieMatchUpScore({
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        structure: structure,
        matchUp: matchUp,
        event: event,
    });
    var winningSide = scoreResult.winningSide, set = scoreResult.set, scoreStringSide1 = scoreResult.scoreStringSide1, scoreStringSide2 = scoreResult.scoreStringSide2;
    var setHasValue = (set === null || set === void 0 ? void 0 : set.side1Score) || (set === null || set === void 0 ? void 0 : set.side2Score);
    if (exitWhenNoValues && !matchUp.score && !setHasValue) {
        return __assign({}, SUCCESS);
    }
    var scoreObject = {
        scoreStringSide1: scoreStringSide1,
        scoreStringSide2: scoreStringSide2,
        sets: set ? [set] : [],
    };
    var hasWinner = winningSide && [1, 2].includes(winningSide);
    var newMatchUpStatus = (hasWinner && COMPLETED$1) ||
        (isActiveMatchUp({
            matchUpStatus: matchUpStatus !== null && matchUpStatus !== void 0 ? matchUpStatus : matchUp.matchUpStatus,
            tieMatchUps: matchUp.tieMatchUps,
            winningSide: matchUp.winningSide,
            score: scoreObject,
        }) &&
            IN_PROGRESS$1) ||
        TO_BE_PLAYED;
    var removeWinningSide = !!(matchUp.winningSide && !hasWinner);
    var hasResults = matchUp.tieMatchUps.find(function (_a) {
        var _b;
        var score = _a.score, winningSide = _a.winningSide, matchUpStatus = _a.matchUpStatus;
        return (((_b = score === null || score === void 0 ? void 0 : score.sets) === null || _b === void 0 ? void 0 : _b.length) &&
            (score.sets[0].side1Score || score.sets[0].side2Score)) ||
            (matchUpStatus && completedMatchUpStatuses.includes(matchUpStatus)) ||
            winningSide;
    });
    var tieFormatRemoved;
    if (matchUp.tieFormat && !hasWinner && !hasResults) {
        // if matchUp.tieFormat is equivalent to hierarchical tieFormat, remove
        var inheritedTieFormat = (_e = resolveTieFormat({
            drawDefinition: drawDefinition,
            structure: structure,
            event: event,
        })) === null || _e === void 0 ? void 0 : _e.tieFormat;
        if (inheritedTieFormat &&
            JSON.stringify(tieFormat) === JSON.stringify(inheritedTieFormat)) {
            matchUp.tieFormatId = undefined;
            matchUp.tieFormat = undefined;
            tieFormatRemoved = true;
        }
    }
    modifyMatchUpScore({
        matchUpStatus: newMatchUpStatus,
        score: scoreObject,
        removeWinningSide: removeWinningSide,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        removeScore: removeScore,
        winningSide: winningSide,
        matchUpId: matchUpId,
        matchUp: matchUp,
        event: event,
    });
    return __assign(__assign({}, SUCCESS), { score: scoreObject, removeWinningSide: removeWinningSide, tieFormatRemoved: tieFormatRemoved, winningSide: winningSide });
}

function removeDirectedParticipants(params) {
    var dualWinningSideChange = params.dualWinningSideChange, inContextDrawMatchUps = params.inContextDrawMatchUps, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, matchUpStatus = params.matchUpStatus, matchUpsMap = params.matchUpsMap, dualMatchUp = params.dualMatchUp, targetData = params.targetData, matchUpId = params.matchUpId, structure = params.structure, event = params.event;
    var isCollectionMatchUp = Boolean(params.matchUp.collectionId);
    var isAdHocMatchUp = isAdHoc({ drawDefinition: drawDefinition, structure: structure });
    // targetData will have team matchUp when params.matchUp is a collectionMatchUp
    var _a = targetData.matchUp || {}, drawPositions = _a.drawPositions, winningSide = _a.winningSide;
    if (!isAdHocMatchUp && !drawPositions) {
        return { error: MISSING_DRAW_POSITIONS };
    }
    var _b = targetData.targetLinks, loserTargetLink = _b.loserTargetLink, winnerTargetLink = _b.winnerTargetLink, byeTargetLink = _b.byeTargetLink, _c = targetData.targetMatchUps, loserMatchUp = _c.loserMatchUp, winnerMatchUp = _c.winnerMatchUp, byeMatchUp = _c.byeMatchUp;
    var result = modifyMatchUpScore(__assign(__assign({}, params), { matchUpStatus: matchUpStatus || TO_BE_PLAYED, removeWinningSide: true }));
    if (result.error)
        return result;
    var tieMatchUpResult;
    if (isCollectionMatchUp) {
        var matchUpTieId = params.matchUpTieId, matchUpsMap_1 = params.matchUpsMap;
        tieMatchUpResult = updateTieMatchUpScore({
            matchUpId: matchUpTieId,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap_1,
            event: event,
        });
        if (!dualWinningSideChange && !tieMatchUpResult.removeWinningSide)
            return __assign({}, SUCCESS);
    }
    if (isAdHocMatchUp)
        return __assign({}, SUCCESS);
    var sourceMatchUps = getAllStructureMatchUps({
        afterRecoveryTimes: false,
        inContext: true,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        structure: structure,
    }).matchUps;
    var positionAssignments = structureAssignedDrawPositions({ structure: structure }).positionAssignments;
    var winningIndex = winningSide - 1;
    var losingIndex = 1 - winningIndex;
    var winningDrawPosition = drawPositions[winningIndex];
    var loserDrawPosition = drawPositions[losingIndex];
    // use reduce for single pass resolution of both
    var _d = (positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.reduce(function (assignments, assignment) {
        if (assignment.drawPosition === loserDrawPosition)
            assignments.loserParticipantId = assignment.participantId;
        if (assignment.drawPosition === winningDrawPosition)
            assignments.winnerParticipantId = assignment.participantId;
        return assignments;
    }, { winnerParticipantId: undefined, loserParticipantId: undefined })) || {}, winnerParticipantId = _d.winnerParticipantId, loserParticipantId = _d.loserParticipantId;
    var drawPositionMatchUps = sourceMatchUps.filter(function (matchUp) { var _a; return (_a = matchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.includes(loserDrawPosition); });
    if (winnerMatchUp) {
        removeDirectedWinner({
            sourceMatchUpStatus: matchUpStatus,
            sourceMatchUpId: matchUpId,
            inContextDrawMatchUps: inContextDrawMatchUps,
            winningDrawPosition: winningDrawPosition,
            winnerParticipantId: winnerParticipantId,
            tournamentRecord: tournamentRecord,
            winnerTargetLink: winnerTargetLink,
            drawDefinition: drawDefinition,
            winnerMatchUp: winnerMatchUp,
            dualMatchUp: dualMatchUp,
            matchUpsMap: matchUpsMap,
        });
    }
    if (loserMatchUp) {
        var winnerHadBye = includesMatchUpStatuses({
            drawPositionMatchUps: drawPositionMatchUps,
            loserDrawPosition: loserDrawPosition,
            sourceMatchUps: sourceMatchUps,
        }).winnerHadMatchUpStatus;
        var loserLinkCondition = loserTargetLink.linkCondition;
        var firstMatchUpLoss = loserLinkCondition === FIRST_MATCHUP;
        if (winnerHadBye && firstMatchUpLoss) {
            // The fed drawPosition is always the lowest number
            var drawPosition = Math.min.apply(Math, __spreadArray([], __read(loserMatchUp.drawPositions), false));
            removeDirectedBye({
                targetLink: loserTargetLink,
                inContextDrawMatchUps: inContextDrawMatchUps,
                drawDefinition: drawDefinition,
                drawPosition: drawPosition,
                matchUpsMap: matchUpsMap,
                event: event,
            });
        }
        var removeLoserResult = removeDirectedLoser({
            sourceMatchUpStatus: matchUpStatus,
            sourceMatchUpId: matchUpId,
            loserParticipantId: loserParticipantId,
            tournamentRecord: tournamentRecord,
            loserTargetLink: loserTargetLink,
            drawDefinition: drawDefinition,
            loserMatchUp: loserMatchUp,
            dualMatchUp: dualMatchUp,
            matchUpsMap: matchUpsMap,
            event: event,
        });
        if (removeLoserResult.error)
            return removeLoserResult;
    }
    if (byeMatchUp) {
        // check whether byeMatchUp includes an active drawPosition
        var drawPosition = Math.min.apply(Math, __spreadArray([], __read(byeMatchUp.drawPositions), false));
        removeDirectedBye({
            sourceMatchUpId: matchUpId,
            targetLink: byeTargetLink,
            inContextDrawMatchUps: inContextDrawMatchUps,
            drawDefinition: drawDefinition,
            drawPosition: drawPosition,
            matchUpsMap: matchUpsMap,
            event: event,
        });
    }
    var annotate = tieMatchUpResult && { tieMatchUpResult: tieMatchUpResult };
    return __assign(__assign({}, SUCCESS), annotate);
}
function removeDirectedWinner(_a) {
    var _b, _c;
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, winningDrawPosition = _a.winningDrawPosition, sourceMatchUpStatus = _a.sourceMatchUpStatus, winnerParticipantId = _a.winnerParticipantId, tournamentRecord = _a.tournamentRecord, winnerTargetLink = _a.winnerTargetLink, sourceMatchUpId = _a.sourceMatchUpId, drawDefinition = _a.drawDefinition, winnerMatchUp = _a.winnerMatchUp, matchUpsMap = _a.matchUpsMap, dualMatchUp = _a.dualMatchUp, event = _a.event;
    var structureId = winnerMatchUp.structureId, roundNumber = winnerMatchUp.roundNumber;
    var stack = 'removeDirectedWinner';
    if (winnerTargetLink) {
        var structureId_1 = winnerTargetLink.target.structureId;
        var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId_1 }).structure;
        if (!structure)
            return { error: STRUCTURE_NOT_FOUND };
        var positionAssignments = structureAssignedDrawPositions({
            structure: structure,
        }).positionAssignments;
        // remove participant from seedAssignments
        structure.seedAssignments = ((_b = structure.seedAssignments) !== null && _b !== void 0 ? _b : []).filter(function (assignment) { return assignment.participantId !== winnerParticipantId; });
        var relevantAssignment = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (assignment) { return assignment.participantId === winnerParticipantId; });
        var winnerDrawPosition_1 = relevantAssignment === null || relevantAssignment === void 0 ? void 0 : relevantAssignment.drawPosition;
        var matchUps = getAllStructureMatchUps({
            drawDefinition: drawDefinition,
            structure: structure,
            event: event,
        }).matchUps;
        var allDrawPositionInstances = matchUps
            .map(function (matchUp) { return matchUp.drawPositions; })
            .flat(Infinity)
            .filter(Boolean);
        var drawPositionInstanceCount = instanceCount(allDrawPositionInstances);
        var winnerDrawPositionInstances = winnerDrawPosition_1
            ? drawPositionInstanceCount[winnerDrawPosition_1]
            : undefined;
        if (winnerDrawPositionInstances === 1) {
            // only remove position assignment if it has a single instance...
            // if there are multiple instances then a participant has been fed back into a draw
            positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.forEach(function (assignment) {
                if (assignment.participantId === winnerParticipantId) {
                    delete assignment.participantId;
                }
            });
        }
        else {
            var drawPositionMatchUps = matchUps.filter(function (_a) {
                var drawPositions = _a.drawPositions;
                return drawPositions.includes(winnerDrawPosition_1);
            });
            console.log('not removing from position assignments since instances > 1', { drawPositionMatchUps: drawPositionMatchUps, winnerTargetLink: winnerTargetLink });
        }
        var targetMatchUp = (_c = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.drawMatchUps) === null || _c === void 0 ? void 0 : _c.find(function (_a) {
            var matchUpId = _a.matchUpId;
            return matchUpId === winnerMatchUp.matchUpId;
        });
        targetMatchUp &&
            modifyMatchUpNotice({
                tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                eventId: event === null || event === void 0 ? void 0 : event.eventId,
                matchUp: targetMatchUp,
                context: stack,
                drawDefinition: drawDefinition,
            });
    }
    // Remove participant's drawPosition from current and subsequent round matchUps
    roundNumber &&
        removeSubsequentRoundsParticipant({
            targetDrawPosition: winningDrawPosition,
            inContextDrawMatchUps: inContextDrawMatchUps,
            sourceMatchUpStatus: sourceMatchUpStatus,
            tournamentRecord: tournamentRecord,
            sourceMatchUpId: sourceMatchUpId,
            drawDefinition: drawDefinition,
            dualMatchUp: dualMatchUp,
            matchUpsMap: matchUpsMap,
            roundNumber: roundNumber,
            structureId: structureId,
        });
    return __assign({}, SUCCESS);
}
function removeDirectedLoser(_a) {
    var _b, _c, _d, _e;
    _a.sourceMatchUpStatus; var loserParticipantId = _a.loserParticipantId, tournamentRecord = _a.tournamentRecord, loserTargetLink = _a.loserTargetLink; _a.sourceMatchUpId; var drawDefinition = _a.drawDefinition, loserMatchUp = _a.loserMatchUp, matchUpsMap = _a.matchUpsMap, dualMatchUp = _a.dualMatchUp, event = _a.event;
    var stack = 'removeDirectedLoser';
    var structureId = loserTargetLink.target.structureId;
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    var positionAssignments = structureAssignedDrawPositions({ structure: structure }).positionAssignments;
    var relevantDrawPosition = (_b = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (assignment) { return assignment.participantId === loserParticipantId; })) === null || _b === void 0 ? void 0 : _b.drawPosition;
    positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.forEach(function (assignment) {
        if (assignment.participantId === loserParticipantId) {
            delete assignment.participantId;
        }
    });
    // remove participant from seedAssignments
    structure.seedAssignments = ((_c = structure.seedAssignments) !== null && _c !== void 0 ? _c : []).filter(function (assignment) { return assignment.participantId !== loserParticipantId; });
    if (dualMatchUp) {
        // remove propagated lineUp
        var drawPositionSideIndex = loserMatchUp === null || loserMatchUp === void 0 ? void 0 : loserMatchUp.sides.reduce(function (sideIndex, side, i) {
            return side.drawPosition === relevantDrawPosition ? i : sideIndex;
        }, undefined);
        var targetMatchUp = (_d = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.drawMatchUps) === null || _d === void 0 ? void 0 : _d.find(function (_a) {
            var matchUpId = _a.matchUpId;
            return matchUpId === loserMatchUp.matchUpId;
        });
        var targetSide = (_e = targetMatchUp === null || targetMatchUp === void 0 ? void 0 : targetMatchUp.sides) === null || _e === void 0 ? void 0 : _e[drawPositionSideIndex];
        if (targetSide) {
            delete targetSide.lineUp;
            modifyMatchUpNotice({
                tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                eventId: event === null || event === void 0 ? void 0 : event.eventId,
                matchUp: targetMatchUp,
                context: stack,
                drawDefinition: drawDefinition,
            });
        }
    }
    return __assign({}, SUCCESS);
}
function removeDirectedBye(_a) {
    var inContextDrawMatchUps = _a.inContextDrawMatchUps, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawPosition = _a.drawPosition, matchUpsMap = _a.matchUpsMap, targetLink = _a.targetLink, event = _a.event;
    var structureId = targetLink.target.structureId;
    clearDrawPosition({
        inContextDrawMatchUps: inContextDrawMatchUps,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        drawPosition: drawPosition,
        structureId: structureId,
        event: event,
    });
    return __assign({}, SUCCESS);
}

function doubleExitAdvancement(params) {
    var _a;
    var tournamentRecord = params.tournamentRecord, appliedPolicies = params.appliedPolicies, drawDefinition = params.drawDefinition, matchUpsMap = params.matchUpsMap, targetData = params.targetData, structure = params.structure, event = params.event;
    var stack = 'doubleExitAdvancement';
    if (structure.structureType === CONTAINER)
        return decorateResult({ result: __assign({}, SUCCESS), stack: stack });
    var sourceMatchUp = targetData.matchUp, targetMatchUps = targetData.targetMatchUps, targetLinks = targetData.targetLinks;
    var loserMatchUp = targetMatchUps.loserMatchUp, winnerMatchUp = targetMatchUps.winnerMatchUp, loserTargetDrawPosition = targetMatchUps.loserTargetDrawPosition;
    if (loserMatchUp && loserMatchUp.matchUpStatus !== BYE) {
        var loserTargetLink = targetLinks.loserTargetLink;
        if ((_a = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.progression) === null || _a === void 0 ? void 0 : _a.doubleExitPropagateBye) {
            var result = advanceByeToLoserMatchUp({
                loserTargetDrawPosition: loserTargetDrawPosition,
                tournamentRecord: tournamentRecord,
                loserTargetLink: loserTargetLink,
                drawDefinition: drawDefinition,
                loserMatchUp: loserMatchUp,
                matchUpsMap: matchUpsMap,
                event: event,
            });
            if (result.error)
                return decorateResult({ result: result, stack: stack });
        }
        else {
            var feedRound = loserMatchUp.feedRound, drawPositions = loserMatchUp.drawPositions, matchUpId = loserMatchUp.matchUpId;
            var walkoverWinningSide = feedRound
                ? 2
                : 2 - drawPositions.indexOf(loserTargetDrawPosition);
            var result = conditionallyAdvanceDrawPosition(__assign(__assign({}, params), { targetMatchUp: loserMatchUp, walkoverWinningSide: walkoverWinningSide, tournamentRecord: tournamentRecord, sourceMatchUp: sourceMatchUp, matchUpId: matchUpId }));
            if (result.error)
                return decorateResult({ result: result, stack: stack });
        }
    }
    if (winnerMatchUp) {
        var result = conditionallyAdvanceDrawPosition(__assign(__assign({}, params), { matchUpId: winnerMatchUp.matchUpId, targetMatchUp: winnerMatchUp, tournamentRecord: tournamentRecord, sourceMatchUp: sourceMatchUp }));
        if (result.error)
            return decorateResult({ result: result, stack: stack });
    }
    return decorateResult({ result: __assign({}, SUCCESS), stack: stack });
}
// 1. Assigns a WALKOVER or DEFAULTED status to the winnerMatchUp
// 2. Advances any drawPosition that is already present
function conditionallyAdvanceDrawPosition(params) {
    var _a, _b, _c;
    var inContextDrawMatchUps = params.inContextDrawMatchUps, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, sourceMatchUp = params.sourceMatchUp, targetMatchUp = params.targetMatchUp, matchUpsMap = params.matchUpsMap;
    var structure = drawDefinition.structures.find(function (_a) {
        var structureId = _a.structureId;
        return structureId === targetMatchUp.structureId;
    });
    var DOUBLE_EXIT = params.matchUpStatus === DOUBLE_DEFAULT ? DOUBLE_DEFAULT : DOUBLE_WALKOVER;
    var EXIT = params.matchUpStatus === DOUBLE_DEFAULT ? DEFAULTED : WALKOVER$2;
    var stack = 'conditionallyAdvanceDrawPosition';
    var noContextTargetMatchUp = matchUpsMap.drawMatchUps.find(function (matchUp) { return matchUp.matchUpId === targetMatchUp.matchUpId; });
    if (!noContextTargetMatchUp)
        return { error: MISSING_MATCHUP };
    var sourceDrawPositions = (sourceMatchUp === null || sourceMatchUp === void 0 ? void 0 : sourceMatchUp.drawPositions) || [];
    var targetMatchUpDrawPositions = (_a = noContextTargetMatchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.filter(Boolean);
    var sameStructure = (sourceMatchUp === null || sourceMatchUp === void 0 ? void 0 : sourceMatchUp.structureId) === targetMatchUp.structureId;
    // ensure targetMatchUp.drawPositions does not contain sourceMatchUp.drawPositions
    // this covers the case where a pre-existing advancement was made
    if (sameStructure &&
        overlap(sourceDrawPositions, targetMatchUpDrawPositions)) {
        targetMatchUpDrawPositions = targetMatchUpDrawPositions.filter(function (drawPosition) { return !sourceDrawPositions.includes(drawPosition); });
    }
    // if there are 2 drawPositions in targetMatchUp, something is wrong
    if (sameStructure && targetMatchUpDrawPositions.length > 1)
        return decorateResult({ result: { error: DRAW_POSITION_ASSIGNED }, stack: stack });
    var _d = getPairedPreviousMatchUpIsDoubleExit(params), pairedPreviousMatchUpIsDoubleExit = _d.pairedPreviousMatchUpIsDoubleExit, pairedPreviousMatchUp = _d.pairedPreviousMatchUp;
    // get the targets for the targetMatchUp
    var targetData = positionTargets({
        matchUpId: targetMatchUp.matchUpId,
        inContextDrawMatchUps: inContextDrawMatchUps,
        drawDefinition: drawDefinition,
    });
    var targetMatchUps = targetData.targetMatchUps, targetLinks = targetData.targetLinks;
    var nextLoserTargetDrawPosition = targetMatchUps.loserTargetDrawPosition, nextWinnerMatchUp = targetMatchUps.winnerMatchUp, nextLoserMatchUp = targetMatchUps.loserMatchUp;
    if (nextLoserMatchUp) {
        var loserTargetLink = targetLinks.loserTargetLink;
        var result_1 = advanceByeToLoserMatchUp({
            loserTargetDrawPosition: nextLoserTargetDrawPosition,
            loserMatchUp: nextLoserMatchUp,
            tournamentRecord: tournamentRecord,
            loserTargetLink: loserTargetLink,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
        });
        if (result_1.error)
            return decorateResult({ result: result_1, stack: stack });
    }
    var drawPositions = ((_b = noContextTargetMatchUp.drawPositions) === null || _b === void 0 ? void 0 : _b.filter(Boolean)) || [];
    var hasDrawPosition = drawPositions.length === 1;
    var walkoverWinningSide = params.walkoverWinningSide ||
        (hasDrawPosition &&
            getExitWinningSide({
                drawPosition: drawPositions[0],
                matchUpId: targetMatchUp.matchUpId,
                inContextDrawMatchUps: inContextDrawMatchUps,
            })) ||
        undefined;
    // assign the WALKOVER status to targetMatchUp
    var existingExit = [WALKOVER$2, DEFAULTED].includes(noContextTargetMatchUp.matchUpStatus) &&
        !drawPositions.length;
    var isFinal = noContextTargetMatchUp.finishingRound === 1;
    var matchUpStatus = existingExit && !isFinal ? DOUBLE_EXIT : EXIT;
    var inContextPairedPreviousMatchUp = inContextDrawMatchUps.find(function (candidate) { return candidate.matchUpId === pairedPreviousMatchUp.matchUpId; });
    var matchUpStatusCodes = [];
    var sourceSideNumber;
    if (sourceMatchUp) {
        if ((sourceMatchUp === null || sourceMatchUp === void 0 ? void 0 : sourceMatchUp.structureId) === (inContextPairedPreviousMatchUp === null || inContextPairedPreviousMatchUp === void 0 ? void 0 : inContextPairedPreviousMatchUp.structureId)) {
            // if structureIds are equivalent then sideNumber is inferred from roundPositions
            if (sourceMatchUp.roundPosition < (pairedPreviousMatchUp === null || pairedPreviousMatchUp === void 0 ? void 0 : pairedPreviousMatchUp.roundPosition)) {
                sourceSideNumber = 1;
            }
            else {
                sourceSideNumber = 2;
            }
        }
        else if (targetMatchUp.feedRound) {
            // if different structureIds then structureId that is not equivalent to noContextTargetMatchUp.structureId is fed
            // ... and fed positions are always sideNumber 1
            if (sourceMatchUp.structureId === targetMatchUp.structureId) {
                sourceSideNumber = 2;
            }
            else {
                sourceSideNumber = 1;
            }
        }
        else if (walkoverWinningSide)
            sourceSideNumber = 3 - walkoverWinningSide;
    }
    var sourceMatchUpStatus = params.matchUpStatus;
    var pairedMatchUpStatus = pairedPreviousMatchUp === null || pairedPreviousMatchUp === void 0 ? void 0 : pairedPreviousMatchUp.matchUpStatus;
    if (sourceSideNumber === 1) {
        matchUpStatusCodes = [
            {
                matchUpStatus: producedMatchUpStatus(sourceMatchUpStatus),
                previousMatchUpStatus: sourceMatchUpStatus,
                sideNumber: 1,
            },
            {
                matchUpStatus: producedMatchUpStatus(pairedMatchUpStatus),
                previousMatchUpStatus: pairedMatchUpStatus,
                sideNumber: 2,
            },
        ];
    }
    else if (sourceSideNumber === 2) {
        matchUpStatusCodes = [
            {
                matchUpStatus: producedMatchUpStatus(pairedMatchUpStatus),
                previousMatchUpStatus: pairedMatchUpStatus,
                sideNumber: 1,
            },
            {
                matchUpStatus: producedMatchUpStatus(sourceMatchUpStatus),
                previousMatchUpStatus: sourceMatchUpStatus,
                sideNumber: 2,
            },
        ];
    }
    if (matchUpStatusCodes.length)
        matchUpStatusCodes = matchUpStatusCodes.map(function (code) {
            return definedAttributes(code);
        });
    var result = modifyMatchUpScore(__assign(__assign({}, params), { matchUp: noContextTargetMatchUp, winningSide: walkoverWinningSide, matchUpStatusCodes: matchUpStatusCodes, matchUpStatus: matchUpStatus }));
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    // when there is an existing 'Double Exit", the created "Exit" is replaced
    // with a "Double Exit" and move on to advancing from this position
    if (existingExit) {
        return doubleExitAdvancement(__assign(__assign({}, params), { matchUpStatus: matchUpStatus, targetData: targetData }));
    }
    if (!nextWinnerMatchUp)
        return decorateResult({ result: __assign({}, SUCCESS), stack: stack });
    // any remaining drawPosition in targetMatchUp should be advanced
    var drawPositionToAdvance = targetMatchUpDrawPositions.length === 2
        ? targetMatchUpDrawPositions[walkoverWinningSide - 1]
        : targetMatchUpDrawPositions[0];
    var positionAssignments = getPositionAssignments$1({ structure: structure }).positionAssignments;
    var assignment = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (assignment) { return assignment.drawPosition === drawPositionToAdvance; });
    var noContextNextWinnerMatchUp = matchUpsMap.drawMatchUps.find(function (matchUp) { return matchUp.matchUpId === nextWinnerMatchUp.matchUpId; });
    var nextWinnerMatchUpDrawPositions = (_c = noContextNextWinnerMatchUp === null || noContextNextWinnerMatchUp === void 0 ? void 0 : noContextNextWinnerMatchUp.drawPositions) === null || _c === void 0 ? void 0 : _c.filter(Boolean);
    var nextWinnerMatchUpHasDrawPosition = nextWinnerMatchUpDrawPositions.length === 1;
    if (drawPositionToAdvance) {
        if (assignment === null || assignment === void 0 ? void 0 : assignment.bye) {
            // WO/WO advanced by BYE
            var targetData_1 = positionTargets({
                matchUpId: noContextNextWinnerMatchUp.matchUpId,
                inContextDrawMatchUps: inContextDrawMatchUps,
                drawDefinition: drawDefinition,
            });
            if (nextWinnerMatchUpHasDrawPosition) {
                var nextDrawPositionToAdvance = nextWinnerMatchUpDrawPositions.filter(Boolean)[0];
                // if the next targetMatchUp already has a drawPosition
                var winningSide = getExitWinningSide({
                    drawPosition: nextDrawPositionToAdvance,
                    matchUpId: noContextNextWinnerMatchUp.matchUpId,
                    inContextDrawMatchUps: inContextDrawMatchUps,
                });
                var result_2 = modifyMatchUpScore({
                    matchUpId: noContextNextWinnerMatchUp.matchUpId,
                    matchUp: noContextNextWinnerMatchUp,
                    matchUpStatus: EXIT,
                    matchUpStatusCodes: [],
                    removeScore: true,
                    drawDefinition: drawDefinition,
                    winningSide: winningSide,
                });
                if (result_2.error)
                    return decorateResult({ result: result_2, stack: stack });
                return advanceDrawPosition({
                    drawPositionToAdvance: nextDrawPositionToAdvance,
                    matchUpId: noContextNextWinnerMatchUp.matchUpId,
                    inContextDrawMatchUps: inContextDrawMatchUps,
                    drawDefinition: drawDefinition,
                    matchUpsMap: matchUpsMap,
                });
            }
            else if ([WALKOVER$2, DEFAULTED].includes(nextWinnerMatchUp.matchUpStatus)) {
                // if the next targetMatchUp is a double walkover or double default
                var result_3 = doubleExitAdvancement(__assign(__assign({}, params), { matchUpId: noContextNextWinnerMatchUp.matchUpId, matchUpStatus: matchUpStatus, targetData: targetData_1 }));
                if (result_3.error)
                    return decorateResult({ result: result_3, stack: stack });
            }
            return decorateResult({ result: __assign({}, SUCCESS), stack: stack });
        }
        return assignMatchUpDrawPosition({
            matchUpId: nextWinnerMatchUp.matchUpId,
            drawPosition: drawPositionToAdvance,
            inContextDrawMatchUps: inContextDrawMatchUps,
            drawDefinition: drawDefinition,
        });
    }
    else if (pairedPreviousMatchUpIsDoubleExit) {
        if (!noContextNextWinnerMatchUp)
            return { error: MISSING_MATCHUP };
        if (nextWinnerMatchUpHasDrawPosition) {
            var drawPosition = nextWinnerMatchUpDrawPositions[0];
            var walkoverWinningSide_1 = getExitWinningSide({
                matchUpId: targetMatchUp.matchUpId,
                inContextDrawMatchUps: inContextDrawMatchUps,
                drawPosition: drawPosition,
            });
            console.log('existing drawPosition is winningSide', {
                walkoverWinningSide: walkoverWinningSide_1,
            });
        }
        var matchUpStatus_1 = [WALKOVER$2, DEFAULTED].includes(noContextNextWinnerMatchUp.matchUpStatus)
            ? EXIT
            : DOUBLE_EXIT;
        var result_4 = modifyMatchUpScore({
            matchUpId: noContextNextWinnerMatchUp.matchUpId,
            matchUp: noContextNextWinnerMatchUp,
            matchUpStatusCodes: [],
            removeScore: true,
            drawDefinition: drawDefinition,
            matchUpStatus: matchUpStatus_1,
        });
        if (result_4.error)
            return decorateResult({ result: result_4, stack: stack });
        if (matchUpStatus_1 === DOUBLE_EXIT) {
            var advancementResult = doubleExitAdvancement(__assign(__assign({}, params), { matchUpId: targetMatchUp.matchUpId, matchUpStatus: matchUpStatus_1, targetData: targetData }));
            if (advancementResult.error)
                return advancementResult;
        }
    }
    return decorateResult({ result: __assign({}, SUCCESS), stack: stack });
}
function advanceByeToLoserMatchUp(params) {
    var _a;
    var loserTargetDrawPosition = params.loserTargetDrawPosition, tournamentRecord = params.tournamentRecord, loserTargetLink = params.loserTargetLink, drawDefinition = params.drawDefinition, matchUpsMap = params.matchUpsMap, event = params.event;
    var structureId = (_a = loserTargetLink === null || loserTargetLink === void 0 ? void 0 : loserTargetLink.target) === null || _a === void 0 ? void 0 : _a.structureId;
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    if (!structure)
        return { error: MISSING_STRUCTURE };
    return assignDrawPositionBye({
        drawPosition: loserTargetDrawPosition,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        structureId: structureId,
        matchUpsMap: matchUpsMap,
        event: event,
    });
}
function producedMatchUpStatus(previousMatchUpStatus) {
    if (previousMatchUpStatus === DOUBLE_WALKOVER)
        return WALKOVER$2;
    if (previousMatchUpStatus === DOUBLE_DEFAULT)
        return DEFAULTED;
    return previousMatchUpStatus;
}

function attemptToSetMatchUpStatusBYE(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, structure = _a.structure, matchUp = _a.matchUp;
    var stack = 'attemptToSetMatchUpStatusBYE';
    if (matchUp === null || matchUp === void 0 ? void 0 : matchUp.winningSide) {
        return decorateResult({
            result: { error: INVALID_MATCHUP_STATUS },
            context: { matchUpStatus: BYE },
            stack: stack,
        });
    }
    // It is not possible to change matchUp status to BYE unless
    // matchUp.drawPositions includes BYE assigned position
    var positionAssignments = structureAssignedDrawPositions({
        structure: structure,
    }).positionAssignments;
    var byeAssignedDrawPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) { return assignment.bye; }).map(function (assignment) { return assignment.drawPosition; });
    var matchUpIncludesBye = (_b = matchUp.drawPositions) === null || _b === void 0 ? void 0 : _b.some(function (position) { return byeAssignedDrawPositions === null || byeAssignedDrawPositions === void 0 ? void 0 : byeAssignedDrawPositions.includes(position); });
    if (matchUpIncludesBye) {
        matchUp.matchUpStatus = BYE;
        matchUp.matchUpStatusCodes = [];
        modifyMatchUpNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            context: stack,
            drawDefinition: drawDefinition,
            matchUp: matchUp,
        });
        return __assign({}, SUCCESS);
    }
    else {
        return decorateResult({
            result: { error: INVALID_MATCHUP_STATUS_BYE },
            info: 'matchUp does not include BYE',
            stack: stack,
        });
    }
}

function attemptToSetMatchUpStatus(params) {
    var tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, matchUpStatus = params.matchUpStatus, structure = params.structure, matchUp = params.matchUp;
    var teamRoundRobinContext = !!(matchUp.tieMatchUps &&
        !matchUp.rondPosition &&
        params.inContextDrawMatchUps.find(function (icdm) { return icdm.matchUpId === matchUp.matchUpId; }).containerStructureId);
    var stack = 'attemptToSetMatchUpStatus';
    var isBYE = matchUpStatus === BYE;
    var existingWinningSide = matchUp.winningSide;
    var isDoubleExit = [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUpStatus);
    var directing = isDirectingMatchUpStatus({ matchUpStatus: matchUpStatus });
    var nonDirecting = isNonDirectingMatchUpStatus({ matchUpStatus: matchUpStatus });
    var unrecognized = !directing && !nonDirecting;
    // if matchUpTieId present a TEAM matchUp is being modified...
    var onlyModifyScore = params.matchUpTieId || (existingWinningSide && directing && !isDoubleExit);
    var changeCompletedToDoubleExit = existingWinningSide && isDoubleExit;
    var clearScore = function () {
        return modifyMatchUpScore(__assign(__assign({}, params), { removeScore: [CANCELLED$1, WALKOVER$2].includes(matchUpStatus), matchUpStatus: matchUpStatus || TO_BE_PLAYED }));
    };
    return ((unrecognized && { error: UNRECOGNIZED_MATCHUP_STATUS }) ||
        (onlyModifyScore && scoreModification$1(params)) ||
        (changeCompletedToDoubleExit &&
            removeWinningSideAndSetDoubleExit(params)) ||
        (existingWinningSide && removeDirectedParticipants(params)) ||
        (nonDirecting && clearScore()) ||
        (isBYE &&
            attemptToSetMatchUpStatusBYE({
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                structure: structure,
                matchUp: matchUp,
            })) ||
        (!directing && { error: UNRECOGNIZED_MATCHUP_STATUS }) ||
        (isDoubleExit && modifyScoreAndAdvanceDoubleExit(params)) ||
        (teamRoundRobinContext && scoreModification$1(params)) ||
        decorateResult({
            result: { error: INVALID_MATCHUP_STATUS },
            stack: stack,
        }));
}
function removeWinningSideAndSetDoubleExit(params) {
    var result = removeDirectedParticipants(params);
    if (result.error)
        return result;
    return doubleExitAdvancement(params);
}
function modifyScoreAndAdvanceDoubleExit(params) {
    var result = scoreModification$1(__assign(__assign({}, params), { removeScore: true }));
    if (result.error)
        return result;
    return doubleExitAdvancement(params);
}
function scoreModification$1(params) {
    var _a;
    var stack = 'scoreModification';
    var removeDirected = params.isCollectionMatchUp &&
        ((_a = params.dualMatchUp) === null || _a === void 0 ? void 0 : _a.winningSide) &&
        !params.projectedWinningSide;
    if (removeDirected) {
        var result_1 = removeDirectedParticipants(params);
        if (result_1.error)
            return decorateResult({ result: result_1, stack: stack });
    }
    var isCollectionMatchUp = Boolean(params.matchUp.collectionId);
    var result = modifyMatchUpScore(params);
    // recalculate dualMatchUp score if isCollectionMatchUp
    if (isCollectionMatchUp) {
        var matchUpTieId = params.matchUpTieId, drawDefinition = params.drawDefinition, matchUpsMap = params.matchUpsMap;
        var tieMatchUpResult = updateTieMatchUpScore({
            tournamentRecord: params.tournamentRecord,
            matchUpId: matchUpTieId,
            event: params.event,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
        });
        if (tieMatchUpResult.error) {
            return decorateResult({ result: tieMatchUpResult, stack: stack });
        }
        Object.assign(result, { tieMatchUpResult: tieMatchUpResult });
    }
    return decorateResult({ result: result, stack: stack });
}

function getAffectedTargetStructureIds(_a) {
    var _b, _c;
    var drawDefinition = _a.drawDefinition, structure = _a.structure, matchUp = _a.matchUp;
    var drawPositions = matchUp.drawPositions;
    var positionAssignments = getPositionAssignments$1({
        drawDefinition: drawDefinition,
        structure: structure,
    }).positionAssignments;
    var relevantAssignments = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (_a) {
        var drawPosition = _a.drawPosition;
        return drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(drawPosition);
    });
    var finishingPositions = relevantAssignments === null || relevantAssignments === void 0 ? void 0 : relevantAssignments.map(function (assignment) {
        var _a;
        var extension = findExtension({ element: assignment, name: TALLY }).extension;
        return (_a = extension === null || extension === void 0 ? void 0 : extension.value) === null || _a === void 0 ? void 0 : _a.groupOrder;
    });
    var containerStructures = getContainedStructures({ drawDefinition: drawDefinition }).containerStructures;
    var structureId = containerStructures[structure.structureId];
    var links = (_c = (_b = getStructureLinks({
        drawDefinition: drawDefinition,
        structureId: structureId,
    })) === null || _b === void 0 ? void 0 : _b.links) === null || _c === void 0 ? void 0 : _c.source;
    var structureIds = links === null || links === void 0 ? void 0 : links.filter(function (link) {
        var _a;
        return overlap(finishingPositions, ((_a = link.source) === null || _a === void 0 ? void 0 : _a.finishingPositions) || []);
    }).map(function (link) { return link.source.structureId; });
    return { structureIds: structureIds };
}

/**
 * check effect of winningSide change in a structure where progression is based on WIN_RATIO
 * For ROUND_ROBIN_WITH_PLAYOFF the movement of participants into different structures
 * will be changed and IF no matchUps are active in either structure then participants can be swapped
 */
function checkConnectedStructures(_a) {
    var drawDefinition = _a.drawDefinition, structure = _a.structure, matchUp = _a.matchUp;
    var connectedStructureIds = [];
    // check whether player movement is dependent on win ratio
    if (structure.finishingPosition === WIN_RATIO$1) {
        var structureIsComplete = isCompletedStructure({
            drawDefinition: drawDefinition,
            structure: structure,
        });
        if (structureIsComplete) {
            // if structure is complete then a changed outcome will have downstream effects
            var structureIds = getAffectedTargetStructureIds({
                drawDefinition: drawDefinition,
                structure: structure,
                matchUp: matchUp,
            }).structureIds;
            if (structureIds === null || structureIds === void 0 ? void 0 : structureIds.length) {
                connectedStructureIds.push.apply(connectedStructureIds, __spreadArray([], __read(structureIds), false));
            }
        }
    }
    return { connectedStructureIds: connectedStructureIds };
}

function attemptToModifyScore(params) {
    var dualWinningSideChange = params.dualWinningSideChange, matchUpStatusCodes = params.matchUpStatusCodes, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, matchUpFormat = params.matchUpFormat, matchUpStatus = params.matchUpStatus, winningSide = params.winningSide, matchUpId = params.matchUpId, structure = params.structure, matchUp = params.matchUp, event = params.event, score = params.score;
    var matchUpStatusIsValid = isDirectingMatchUpStatus({ matchUpStatus: matchUpStatus }) ||
        // in the case that CANCELLED or ABANDONED causes TEAM participant to advance
        ([CANCELLED$1, ABANDONED$1].includes(matchUpStatus) && dualWinningSideChange);
    var stack = 'attemptToModifyScore';
    var isCollectionMatchUp = Boolean(matchUp.collectionId);
    var isAdHocMatchUp = isAdHoc({ drawDefinition: drawDefinition, structure: structure });
    var validToScore = isCollectionMatchUp ||
        isAdHocMatchUp ||
        drawPositionsAssignedParticipantIds({ structure: structure, matchUp: matchUp });
    if (!validToScore) {
        return { error: MISSING_ASSIGNMENTS };
    }
    var removeScore = [WALKOVER$2].includes(matchUpStatus);
    var result = modifyMatchUpScore({
        matchUpStatusCodes: (matchUpStatusIsValid && matchUpStatusCodes) || [],
        matchUpStatus: (matchUpStatusIsValid && matchUpStatus) || COMPLETED$1,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        matchUpFormat: matchUpFormat,
        removeScore: removeScore,
        winningSide: winningSide,
        matchUpId: matchUpId,
        matchUp: matchUp,
        event: event,
        score: score,
    });
    return decorateResult({ result: result, stack: stack });
}
function drawPositionsAssignedParticipantIds(_a) {
    var structure = _a.structure, matchUp = _a.matchUp;
    var drawPositions = matchUp.drawPositions;
    var positionAssignments = structureAssignedDrawPositions({ structure: structure }).positionAssignments;
    var assignedParticipantIds = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) {
        return ((drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(assignment.drawPosition)) &&
            assignment.participantId);
    });
    return (assignedParticipantIds === null || assignedParticipantIds === void 0 ? void 0 : assignedParticipantIds.length) === 2;
}

function directWinner(_a) {
    var _b, _c, _d;
    var winnerMatchUpDrawPositionIndex = _a.winnerMatchUpDrawPositionIndex, inContextDrawMatchUps = _a.inContextDrawMatchUps, projectedWinningSide = _a.projectedWinningSide, sourceMatchUpStatus = _a.sourceMatchUpStatus, winningDrawPosition = _a.winningDrawPosition, tournamentRecord = _a.tournamentRecord, winnerTargetLink = _a.winnerTargetLink, sourceMatchUpId = _a.sourceMatchUpId, drawDefinition = _a.drawDefinition, winnerMatchUp = _a.winnerMatchUp, dualMatchUp = _a.dualMatchUp, matchUpsMap = _a.matchUpsMap, event = _a.event;
    var stack = 'directWinner';
    if (winnerTargetLink) {
        var targetMatchUpDrawPositions_1 = winnerMatchUp.drawPositions || [];
        var targetMatchUpDrawPosition = targetMatchUpDrawPositions_1[winnerMatchUpDrawPositionIndex];
        var sourceStructureId = winnerTargetLink.source.structureId;
        var result = findStructure({
            structureId: sourceStructureId,
            drawDefinition: drawDefinition,
        });
        if (result.error)
            return result;
        var structure = result.structure;
        var sourcePositionAssignments = structureAssignedDrawPositions({
            structureId: sourceStructureId,
            drawDefinition: drawDefinition,
        }).positionAssignments;
        var relevantSourceAssignment = sourcePositionAssignments === null || sourcePositionAssignments === void 0 ? void 0 : sourcePositionAssignments.find(function (assignment) { return assignment.drawPosition === winningDrawPosition; });
        var winnerParticipantId_1 = relevantSourceAssignment === null || relevantSourceAssignment === void 0 ? void 0 : relevantSourceAssignment.participantId;
        var targetStructureId = winnerTargetLink.target.structureId;
        var targetPositionAssignments = structureAssignedDrawPositions({
            structureId: targetStructureId,
            drawDefinition: drawDefinition,
        }).positionAssignments;
        var relevantAssignment = targetPositionAssignments === null || targetPositionAssignments === void 0 ? void 0 : targetPositionAssignments.find(function (assignment) { return assignment.participantId === winnerParticipantId_1; });
        var winnerExistingDrawPosition = relevantAssignment === null || relevantAssignment === void 0 ? void 0 : relevantAssignment.drawPosition;
        var unfilledTargetMatchUpDrawPositions = targetPositionAssignments === null || targetPositionAssignments === void 0 ? void 0 : targetPositionAssignments.filter(function (assignment) {
            var inTarget = targetMatchUpDrawPositions_1.includes(assignment.drawPosition);
            var unfilled = !assignment.participantId && !assignment.bye && !assignment.qualifier;
            return inTarget && unfilled;
        }).map(function (assignment) { return assignment.drawPosition; });
        var targetDrawPositionIsUnfilled = unfilledTargetMatchUpDrawPositions === null || unfilledTargetMatchUpDrawPositions === void 0 ? void 0 : unfilledTargetMatchUpDrawPositions.includes(targetMatchUpDrawPosition);
        if (winnerParticipantId_1 &&
            winnerTargetLink.target.roundNumber === 1 &&
            targetDrawPositionIsUnfilled) {
            assignDrawPosition$1({
                drawPosition: targetMatchUpDrawPosition,
                participantId: winnerParticipantId_1,
                structureId: targetStructureId,
                inContextDrawMatchUps: inContextDrawMatchUps,
                sourceMatchUpStatus: sourceMatchUpStatus,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                matchUpsMap: matchUpsMap,
                event: event,
            });
        }
        else if (winnerParticipantId_1 &&
            (unfilledTargetMatchUpDrawPositions === null || unfilledTargetMatchUpDrawPositions === void 0 ? void 0 : unfilledTargetMatchUpDrawPositions.length)) {
            var drawPosition = unfilledTargetMatchUpDrawPositions.pop();
            drawPosition &&
                assignDrawPosition$1({
                    participantId: winnerParticipantId_1,
                    structureId: targetStructureId,
                    inContextDrawMatchUps: inContextDrawMatchUps,
                    sourceMatchUpStatus: sourceMatchUpStatus,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    drawPosition: drawPosition,
                    matchUpsMap: matchUpsMap,
                    event: event,
                });
        }
        else if (winnerExistingDrawPosition) {
            var result_1 = assignMatchUpDrawPosition({
                drawPosition: winnerExistingDrawPosition,
                matchUpId: winnerMatchUp.matchUpId,
                inContextDrawMatchUps: inContextDrawMatchUps,
                sourceMatchUpStatus: sourceMatchUpStatus,
                tournamentRecord: tournamentRecord,
                sourceMatchUpId: sourceMatchUpId,
                drawDefinition: drawDefinition,
                matchUpsMap: matchUpsMap,
            });
            if (result_1.error)
                return decorateResult({ result: result_1, stack: stack });
        }
        else {
            // qualifiers do not get automatically directed
            if ((structure === null || structure === void 0 ? void 0 : structure.stage) !== QUALIFYING) {
                var error = 'winner target position unavaiallble';
                console.log(error);
                return { error: error };
            }
        }
        // propagate seedAssignments
        if ((structure === null || structure === void 0 ? void 0 : structure.seedAssignments) &&
            structure.structureId !== targetStructureId) {
            var seedAssignment = structure.seedAssignments.find(function (_a) {
                var participantId = _a.participantId;
                return participantId === winnerParticipantId_1;
            });
            var participantId = seedAssignment === null || seedAssignment === void 0 ? void 0 : seedAssignment.participantId;
            if (seedAssignment && participantId) {
                assignSeed(__assign(__assign({ eventId: winnerMatchUp === null || winnerMatchUp === void 0 ? void 0 : winnerMatchUp.eventId, structureId: targetStructureId }, seedAssignment), { tournamentRecord: tournamentRecord, drawDefinition: drawDefinition, participantId: participantId }));
            }
        }
    }
    else {
        var result = assignMatchUpDrawPosition({
            matchUpId: winnerMatchUp.matchUpId,
            drawPosition: winningDrawPosition,
            inContextDrawMatchUps: inContextDrawMatchUps,
            sourceMatchUpStatus: sourceMatchUpStatus,
            tournamentRecord: tournamentRecord,
            sourceMatchUpId: sourceMatchUpId,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
        });
        if (result.error)
            return result;
    }
    if (dualMatchUp && projectedWinningSide) {
        // propagate lineUp
        var side = (_b = dualMatchUp.sides) === null || _b === void 0 ? void 0 : _b.find(function (side) { return side.sideNumber === projectedWinningSide; });
        if (side === null || side === void 0 ? void 0 : side.lineUp) {
            var source = dualMatchUp.roundPosition;
            var target = winnerMatchUp.roundPosition;
            var targetSideNumber_1 = (source === target && source !== 1) || Math.floor(source / 2) === target
                ? 2
                : 1; // this may need to take roundNumber into consideration for cross structure propagation of lineUps
            var targetMatchUp_1 = (_c = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.drawMatchUps) === null || _c === void 0 ? void 0 : _c.find(function (_a) {
                var matchUpId = _a.matchUpId;
                return matchUpId === winnerMatchUp.matchUpId;
            });
            var updatedSides = [1, 2].map(function (sideNumber) {
                var _a;
                var existingSide = ((_a = targetMatchUp_1.sides) === null || _a === void 0 ? void 0 : _a.find(function (side) { return side.sideNumber === sideNumber; })) ||
                    {};
                return __assign(__assign({}, existingSide), { sideNumber: sideNumber });
            });
            targetMatchUp_1.sides = updatedSides;
            var targetSide = targetMatchUp_1.sides.find(function (side) { return side.sideNumber === targetSideNumber_1; });
            // attach to appropriate side of winnerMatchUp
            if (targetSide) {
                var filteredLineUp = (_d = side.lineUp) === null || _d === void 0 ? void 0 : _d.filter(function (assignment) { return assignment === null || assignment === void 0 ? void 0 : assignment.participantId; });
                targetSide.lineUp = removeLineUpSubstitutions({
                    lineUp: filteredLineUp,
                });
                modifyMatchUpNotice({
                    tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                    eventId: winnerMatchUp === null || winnerMatchUp === void 0 ? void 0 : winnerMatchUp.eventId,
                    matchUp: targetMatchUp_1,
                    context: stack,
                    drawDefinition: drawDefinition,
                });
            }
        }
    }
    return __assign({}, SUCCESS);
}

/*
  FIRST_MATCH_LOSER_CONSOLATION linkCondition... check whether it is a participant's first
*/
function directLoser(params) {
    var _a, _b;
    var loserMatchUpDrawPositionIndex = params.loserMatchUpDrawPositionIndex, inContextDrawMatchUps = params.inContextDrawMatchUps, projectedWinningSide = params.projectedWinningSide, sourceMatchUpStatus = params.sourceMatchUpStatus, loserDrawPosition = params.loserDrawPosition, tournamentRecord = params.tournamentRecord, loserTargetLink = params.loserTargetLink, drawDefinition = params.drawDefinition, loserMatchUp = params.loserMatchUp, dualMatchUp = params.dualMatchUp, matchUpsMap = params.matchUpsMap, event = params.event;
    var stack = 'directLoser';
    var loserLinkCondition = loserTargetLink.linkCondition;
    var targetMatchUpDrawPositions = loserMatchUp.drawPositions || [];
    var fedDrawPositionFMLC = loserLinkCondition === FIRST_MATCHUP &&
        loserMatchUp.roundNumber === 2 && Math.min.apply(Math, __spreadArray([], __read(targetMatchUpDrawPositions.filter(Boolean)), false));
    var targetMatchUpDrawPosition = fedDrawPositionFMLC ||
        targetMatchUpDrawPositions[loserMatchUpDrawPositionIndex];
    var loserBackdrawPosition = fedDrawPositionFMLC ||
        targetMatchUpDrawPositions[1 - loserMatchUpDrawPositionIndex];
    var sourceStructureId = loserTargetLink.source.structureId;
    var structure = findStructure({
        structureId: sourceStructureId,
        drawDefinition: drawDefinition,
    }).structure;
    var sourceMatchUps = getAllStructureMatchUps({
        afterRecoveryTimes: false,
        inContext: true,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    }).matchUps;
    var drawPositionMatchUps = sourceMatchUps.filter(function (matchUp) { var _a; return (_a = matchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.includes(loserDrawPosition); });
    // in this calculation BYEs and WALKOVERs are not counted as wins
    // as well as DEFAULTED when there is no score component
    var loserDrawPositionWins = drawPositionMatchUps.filter(function (matchUp) {
        var drawPositionSide = matchUp.sides.find(function (side) { return side.drawPosition === loserDrawPosition; });
        var unscoredOutcome = matchUp.matchUpStatus === WALKOVER$2 ||
            (matchUp.matchUpStatus === DEFAULTED && !checkScoreHasValue(matchUp));
        return ((drawPositionSide === null || drawPositionSide === void 0 ? void 0 : drawPositionSide.sideNumber) === matchUp.winningSide && !unscoredOutcome);
    });
    var validForConsolation = loserLinkCondition === FIRST_MATCHUP && loserDrawPositionWins.length === 0;
    var sourcePositionAssignments = structureAssignedDrawPositions({
        structureId: sourceStructureId,
        drawDefinition: drawDefinition,
    }).positionAssignments;
    var relevantAssignment = sourcePositionAssignments === null || sourcePositionAssignments === void 0 ? void 0 : sourcePositionAssignments.find(function (assignment) { return assignment.drawPosition === loserDrawPosition; });
    var loserParticipantId = relevantAssignment === null || relevantAssignment === void 0 ? void 0 : relevantAssignment.participantId;
    var targetStructureId = loserTargetLink.target.structureId;
    var targetPositionAssignments = structureAssignedDrawPositions({
        structureId: targetStructureId,
        drawDefinition: drawDefinition,
    }).positionAssignments;
    var targetMatchUpPositionAssignments = targetPositionAssignments === null || targetPositionAssignments === void 0 ? void 0 : targetPositionAssignments.filter(function (_a) {
        var drawPosition = _a.drawPosition;
        return targetMatchUpDrawPositions.includes(drawPosition);
    });
    var loserAlreadyDirected = targetMatchUpPositionAssignments === null || targetMatchUpPositionAssignments === void 0 ? void 0 : targetMatchUpPositionAssignments.some(function (assignment) { return assignment.participantId === loserParticipantId; });
    if (loserAlreadyDirected) {
        return __assign({}, SUCCESS);
    }
    var unfilledTargetMatchUpDrawPositions = targetMatchUpPositionAssignments === null || targetMatchUpPositionAssignments === void 0 ? void 0 : targetMatchUpPositionAssignments.filter(function (assignment) {
        var inTarget = targetMatchUpDrawPositions.includes(assignment.drawPosition);
        var unfilled = !assignment.participantId && !assignment.bye && !assignment.qualifier;
        return inTarget && unfilled;
    }).map(function (assignment) { return assignment.drawPosition; });
    var targetDrawPositionIsUnfilled = unfilledTargetMatchUpDrawPositions === null || unfilledTargetMatchUpDrawPositions === void 0 ? void 0 : unfilledTargetMatchUpDrawPositions.includes(targetMatchUpDrawPosition);
    var isFeedRound = loserTargetLink.target.roundNumber > 1 &&
        (unfilledTargetMatchUpDrawPositions === null || unfilledTargetMatchUpDrawPositions === void 0 ? void 0 : unfilledTargetMatchUpDrawPositions.length);
    var isFirstRoundValidDrawPosition = loserTargetLink.target.roundNumber === 1 && targetDrawPositionIsUnfilled;
    if (fedDrawPositionFMLC) {
        var result = loserLinkFedFMLC();
        if (result.error)
            return decorateResult({ result: result, stack: stack });
    }
    else if (isFirstRoundValidDrawPosition) {
        var result = asssignLoserDrawPosition();
        if (result.error)
            return decorateResult({ result: result, stack: stack });
    }
    else if (loserParticipantId && isFeedRound) {
        // if target.roundNumber > 1 then it is a feed round and should always take the lower drawPosition
        unfilledTargetMatchUpDrawPositions.sort(numericSort);
        var fedDrawPosition = unfilledTargetMatchUpDrawPositions[0];
        var result = assignDrawPosition$1({
            participantId: loserParticipantId,
            structureId: targetStructureId,
            drawPosition: fedDrawPosition,
            inContextDrawMatchUps: inContextDrawMatchUps,
            sourceMatchUpStatus: sourceMatchUpStatus,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
            event: event,
        });
        if (result.error)
            return decorateResult({ result: result, stack: stack });
    }
    else {
        return decorateResult({
            result: { error: INVALID_DRAW_POSITION },
            context: { loserDrawPosition: loserDrawPosition, loserTargetLink: loserTargetLink },
            stack: stack,
        });
    }
    if ((structure === null || structure === void 0 ? void 0 : structure.seedAssignments) &&
        structure.structureId !== targetStructureId) {
        var seedAssignment = structure.seedAssignments.find(function (_a) {
            var participantId = _a.participantId;
            return participantId === loserParticipantId;
        });
        var participantId = seedAssignment === null || seedAssignment === void 0 ? void 0 : seedAssignment.participantId;
        if (seedAssignment && participantId) {
            assignSeed(__assign(__assign({ eventId: loserMatchUp === null || loserMatchUp === void 0 ? void 0 : loserMatchUp.eventId, structureId: targetStructureId }, seedAssignment), { tournamentRecord: tournamentRecord, drawDefinition: drawDefinition, participantId: participantId }));
        }
    }
    if (dualMatchUp && projectedWinningSide) {
        // propagated lineUp
        var side = (_a = dualMatchUp.sides) === null || _a === void 0 ? void 0 : _a.find(function (side) { return side.sideNumber === 3 - projectedWinningSide; });
        if (side === null || side === void 0 ? void 0 : side.lineUp) {
            var roundNumber = loserMatchUp.roundNumber, eventId = loserMatchUp.eventId;
            var roundPosition = dualMatchUp.roundPosition;
            // for matchUps fed to different structures, sideNumber is always 1 when roundNumber > 1 (fed position)
            // when roundNumber === 1 then it is even/odd calculated as remainder of roundPositon % 2 + 1
            var targetSideNumber_1 = roundNumber === 1 ? 2 - (roundPosition % 2) : 1;
            var targetMatchUp_1 = (_b = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.drawMatchUps) === null || _b === void 0 ? void 0 : _b.find(function (_a) {
                var matchUpId = _a.matchUpId;
                return matchUpId === loserMatchUp.matchUpId;
            });
            var updatedSides = [1, 2].map(function (sideNumber) {
                var _a;
                var existingSide = ((_a = targetMatchUp_1.sides) === null || _a === void 0 ? void 0 : _a.find(function (side) { return side.sideNumber === sideNumber; })) ||
                    {};
                return __assign(__assign({}, existingSide), { sideNumber: sideNumber });
            });
            targetMatchUp_1.sides = updatedSides;
            var targetSide = targetMatchUp_1.sides.find(function (side) { return side.sideNumber === targetSideNumber_1; });
            // attach to appropriate side of winnerMatchUp
            if (targetSide) {
                targetSide.lineUp = removeLineUpSubstitutions({ lineUp: side.lineUp });
                modifyMatchUpNotice({
                    tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                    matchUp: targetMatchUp_1,
                    context: stack,
                    drawDefinition: drawDefinition,
                    eventId: eventId,
                });
            }
        }
    }
    return __assign({}, SUCCESS);
    function loserLinkFedFMLC() {
        var stack = 'loserLinkFedFMLC';
        if (validForConsolation) {
            return decorateResult({ result: asssignLoserDrawPosition(), stack: stack });
        }
        else {
            return decorateResult({ result: assignLoserPositionBye(), stack: stack });
        }
    }
    function assignLoserPositionBye() {
        var result = assignDrawPositionBye({
            drawPosition: loserBackdrawPosition,
            structureId: targetStructureId,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            event: event,
        });
        return decorateResult({ result: result, stack: 'assignLoserPositionBye' });
    }
    function asssignLoserDrawPosition() {
        var result = loserParticipantId
            ? assignDrawPosition$1({
                drawPosition: targetMatchUpDrawPosition,
                participantId: loserParticipantId,
                structureId: targetStructureId,
                inContextDrawMatchUps: inContextDrawMatchUps,
                sourceMatchUpStatus: sourceMatchUpStatus,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                matchUpsMap: matchUpsMap,
                event: event,
            })
            : { error: MISSING_PARTICIPANT_ID };
        return decorateResult({ result: result, stack: 'assignLoserDrawPosition' });
    }
}

function directParticipants(params) {
    var result = attemptToModifyScore(params);
    if (result.error)
        return result;
    var matchUpStatusIsValid = isDirectingMatchUpStatus({
        matchUpStatus: params.matchUpStatus,
    });
    var dualWinningSideChange = params.dualWinningSideChange, projectedWinningSide = params.projectedWinningSide, inContextDrawMatchUps = params.inContextDrawMatchUps, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, matchUpStatus = params.matchUpStatus, dualMatchUp = params.dualMatchUp, matchUpsMap = params.matchUpsMap, winningSide = params.winningSide, targetData = params.targetData, matchUpId = params.matchUpId, structure = params.structure, matchUp = params.matchUp, event = params.event;
    var stack = 'directParticipants';
    var isCollectionMatchUp = Boolean(matchUp.collectionId);
    var isAdHocMatchUp = isAdHoc({ drawDefinition: drawDefinition, structure: structure });
    var drawPositions = matchUp.drawPositions;
    var annotate;
    if (isCollectionMatchUp) {
        var matchUpTieId_1 = params.matchUpTieId, matchUpsMap_1 = params.matchUpsMap;
        var tieMatchUpResult = updateTieMatchUpScore({
            matchUpId: matchUpTieId_1,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap_1,
            event: event,
        });
        annotate = tieMatchUpResult && { tieMatchUpResult: tieMatchUpResult };
        var matchUpTie = inContextDrawMatchUps.find(function (_a) {
            var matchUpId = _a.matchUpId;
            return matchUpId === matchUpTieId_1;
        });
        drawPositions = matchUpTie === null || matchUpTie === void 0 ? void 0 : matchUpTie.drawPositions;
        if (!dualWinningSideChange) {
            return decorateResult({ result: __assign(__assign({}, SUCCESS), annotate), stack: stack });
        }
    }
    if (isAdHocMatchUp) {
        return decorateResult({ result: __assign(__assign({}, SUCCESS), annotate), stack: stack });
    }
    if (drawPositions) {
        // if projectedWinningSide is present then a TEAM matchUp is being directed, not the tieMatchUp
        var winningIndex = projectedWinningSide
            ? projectedWinningSide - 1
            : winningSide - 1;
        var losingIndex = 1 - winningIndex;
        var winningDrawPosition = drawPositions[winningIndex];
        var loserDrawPosition = drawPositions[losingIndex];
        var _a = targetData.targetLinks, loserTargetLink = _a.loserTargetLink, winnerTargetLink = _a.winnerTargetLink, byeTargetLink = _a.byeTargetLink, _b = targetData.targetMatchUps, winnerMatchUpDrawPositionIndex = _b.winnerMatchUpDrawPositionIndex, // only present when positionTargets found without winnerMatchUpId
        loserMatchUpDrawPositionIndex = _b.loserMatchUpDrawPositionIndex, // only present when positionTargets found without loserMatchUpId
        winnerMatchUp = _b.winnerMatchUp, loserMatchUp = _b.loserMatchUp, byeMatchUp = _b.byeMatchUp;
        if (winnerMatchUp) {
            var result_1 = directWinner({
                sourceMatchUpStatus: (matchUpStatusIsValid && matchUpStatus) || COMPLETED$1,
                winnerMatchUpDrawPositionIndex: winnerMatchUpDrawPositionIndex,
                sourceMatchUpId: matchUpId,
                inContextDrawMatchUps: inContextDrawMatchUps,
                projectedWinningSide: projectedWinningSide,
                winningDrawPosition: winningDrawPosition,
                tournamentRecord: tournamentRecord,
                winnerTargetLink: winnerTargetLink,
                drawDefinition: drawDefinition,
                winnerMatchUp: winnerMatchUp,
                dualMatchUp: dualMatchUp,
                matchUpsMap: matchUpsMap,
                event: event,
            });
            if (result_1.error)
                return decorateResult({ result: result_1, stack: stack });
        }
        if (loserMatchUp) {
            var result_2 = directLoser({
                sourceMatchUpStatus: (matchUpStatusIsValid && matchUpStatus) || COMPLETED$1,
                loserMatchUpDrawPositionIndex: loserMatchUpDrawPositionIndex,
                sourceMatchUpId: matchUpId,
                inContextDrawMatchUps: inContextDrawMatchUps,
                projectedWinningSide: projectedWinningSide,
                loserDrawPosition: loserDrawPosition,
                tournamentRecord: tournamentRecord,
                loserTargetLink: loserTargetLink,
                drawDefinition: drawDefinition,
                loserMatchUp: loserMatchUp,
                winningSide: winningSide,
                matchUpsMap: matchUpsMap,
                dualMatchUp: dualMatchUp,
                event: event,
            });
            if (result_2.error)
                return decorateResult({ result: result_2, stack: stack });
        }
        if (byeMatchUp) {
            var targetMatchUpDrawPositions = byeMatchUp.drawPositions || [];
            var backdrawPosition = Math.min.apply(Math, __spreadArray([], __read(targetMatchUpDrawPositions.filter(Boolean)), false));
            var targetStructureId = byeTargetLink.target.structureId;
            var result_3 = assignDrawPositionBye({
                drawPosition: backdrawPosition,
                structureId: targetStructureId,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                event: event,
            });
            if (result_3.error)
                return decorateResult({ result: result_3, stack: stack });
        }
    }
    else {
        return decorateResult({ result: { error: MISSING_DRAW_POSITIONS }, stack: stack });
    }
    return decorateResult({ result: __assign(__assign({}, SUCCESS), annotate), stack: stack });
}

// import { getMatchUpsMap } from '../../getters/getMatchUps/getMatchUpsMap';
function isActiveDownstream(params) {
    var _a, _b;
    // relevantLink is passed in iterative calls (see below)
    var inContextDrawMatchUps = params.inContextDrawMatchUps, targetData = params.targetData, drawDefinition = params.drawDefinition, relevantLink = params.relevantLink;
    // const matchUpsMap = params.matchUpsMap || getMatchUpsMap({ drawDefinition });
    var fmlcBYE = (relevantLink === null || relevantLink === void 0 ? void 0 : relevantLink.linkCondition) === FIRST_MATCHUP &&
        ((_a = targetData === null || targetData === void 0 ? void 0 : targetData.matchUp) === null || _a === void 0 ? void 0 : _a.matchUpStatus) === BYE;
    if (fmlcBYE)
        return false;
    var _c = targetData.targetMatchUps, loserMatchUp = _c.loserMatchUp, winnerMatchUp = _c.winnerMatchUp, targetLinks = targetData.targetLinks;
    var loserMatchUpExit = [DEFAULTED, WALKOVER$2].includes(loserMatchUp === null || loserMatchUp === void 0 ? void 0 : loserMatchUp.matchUpStatus);
    var winnerDrawPositionsCount = ((_b = winnerMatchUp === null || winnerMatchUp === void 0 ? void 0 : winnerMatchUp.drawPositions) === null || _b === void 0 ? void 0 : _b.filter(Boolean).length) || 0;
    // if a winnerMatchUp contains a WALKOVER and its source matchUps have no winningSides it cannot be considered active
    // unless one of its downstream matchUps is active
    /*
    const winnerSourceMatchUps =
      winnerMatchUp &&
      params.matchUpsMap.drawMatchUps.filter(
        ({ winnerMatchUpId }) => winnerMatchUpId === winnerMatchUp.matchUpId
      );
      */
    if (((loserMatchUp === null || loserMatchUp === void 0 ? void 0 : loserMatchUp.winningSide) && !loserMatchUpExit) ||
        // NOTE: produced WALKOVER, DEFAULTEED fed into consolation structures should NOT be considered active
        ((winnerMatchUp === null || winnerMatchUp === void 0 ? void 0 : winnerMatchUp.winningSide) &&
            winnerDrawPositionsCount === 2 &&
            (!winnerMatchUp.feedRound ||
                ![WALKOVER$2, DEFAULTED].includes(winnerMatchUp === null || winnerMatchUp === void 0 ? void 0 : winnerMatchUp.matchUpStatus)))) {
        return true;
    }
    var loserTargetData = loserMatchUp &&
        positionTargets({
            matchUpId: loserMatchUp.matchUpId,
            inContextDrawMatchUps: inContextDrawMatchUps,
            drawDefinition: drawDefinition,
        });
    var winnerTargetData = winnerMatchUp &&
        positionTargets({
            matchUpId: winnerMatchUp.matchUpId,
            inContextDrawMatchUps: inContextDrawMatchUps,
            drawDefinition: drawDefinition,
        });
    var loserActive = loserTargetData &&
        isActiveDownstream({
            relevantLink: targetLinks === null || targetLinks === void 0 ? void 0 : targetLinks.loserTargetLink,
            targetData: loserTargetData,
            inContextDrawMatchUps: inContextDrawMatchUps,
            drawDefinition: drawDefinition,
        });
    var winnerActive = winnerTargetData &&
        isActiveDownstream({
            targetData: winnerTargetData,
            inContextDrawMatchUps: inContextDrawMatchUps,
            drawDefinition: drawDefinition,
        });
    return !!(winnerActive || loserActive);
}

function replaceQualifier(params) {
    var e_1, _a;
    var _b, _c, _d;
    var qualifierReplaced;
    var inContextDrawMatchUps = params.inContextDrawMatchUps, inContextMatchUp = params.inContextMatchUp, drawDefinition = params.drawDefinition, winningSide = params.winningSide;
    var winnerTargetLink = (_b = params.targetData.targetLinks) === null || _b === void 0 ? void 0 : _b.winnerTargetLink;
    if (winnerTargetLink.target.feedProfile === DRAW) {
        var previousWinningParticipantId_1 = inContextMatchUp.sides.find(function (_a) {
            var sideNumber = _a.sideNumber;
            return sideNumber !== winningSide;
        }).participantId;
        var mainDrawTargetMatchUp = inContextDrawMatchUps.find(function (m) {
            return m.structureId === winnerTargetLink.target.structureId &&
                m.roundNumber === winnerTargetLink.target.roundNumber &&
                m.sides.some(function (_a) {
                    var participantId = _a.participantId;
                    return participantId === previousWinningParticipantId_1;
                });
        });
        if ((mainDrawTargetMatchUp === null || mainDrawTargetMatchUp === void 0 ? void 0 : mainDrawTargetMatchUp.matchUpStatus) === TO_BE_PLAYED) {
            // prevoius winningSide participant was placed in MAIN
            var targetData = positionTargets({
                matchUpId: mainDrawTargetMatchUp.matchUpId,
                inContextDrawMatchUps: inContextDrawMatchUps,
                drawDefinition: drawDefinition,
            });
            var activeDownstream = isActiveDownstream({
                inContextDrawMatchUps: inContextDrawMatchUps,
                drawDefinition: drawDefinition,
                targetData: targetData,
            });
            if (!activeDownstream) {
                var structure = findStructure({
                    structureId: mainDrawTargetMatchUp.structureId,
                    drawDefinition: drawDefinition,
                }).structure;
                var positionAssignments = getPositionAssignments$1({
                    structure: structure,
                }).positionAssignments;
                var _loop_1 = function (positionAssignment) {
                    var e_2, _g;
                    if (positionAssignment.participantId === previousWinningParticipantId_1) {
                        var newWinningParticipantId = inContextMatchUp.sides.find(function (_a) {
                            var sideNumber = _a.sideNumber;
                            return sideNumber === winningSide;
                        }).participantId;
                        positionAssignment.participantId = newWinningParticipantId;
                        // update positionAssignments on structure
                        if (structure === null || structure === void 0 ? void 0 : structure.positionAssignments) {
                            structure.positionAssignments = positionAssignments;
                        }
                        else if (structure === null || structure === void 0 ? void 0 : structure.structures) {
                            var assignmentMap_1 = Object.assign.apply(Object, __spreadArray([{}], __read((positionAssignments || []).map(function (assignment) {
                                var _a;
                                return (_a = {},
                                    _a[assignment.drawPosition] = assignment.participantId,
                                    _a);
                            })), false));
                            try {
                                for (var _h = (e_2 = void 0, __values(structure.structures)), _j = _h.next(); !_j.done; _j = _h.next()) {
                                    var subStructure = _j.value;
                                    (_c = subStructure.positionAssignments) === null || _c === void 0 ? void 0 : _c.forEach(function (assignment) {
                                        return (assignment.participantId =
                                            assignmentMap_1[assignment.drawPosition]);
                                    });
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (_j && !_j.done && (_g = _h.return)) _g.call(_h);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }
                        modifyPositionAssignmentsNotice({
                            tournamentId: (_d = params.tournamentRecord) === null || _d === void 0 ? void 0 : _d.tournamentId,
                            event: params.event,
                            drawDefinition: drawDefinition,
                            structure: structure,
                        });
                        qualifierReplaced = true;
                    }
                };
                try {
                    for (var _e = __values(positionAssignments || []), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var positionAssignment = _f.value;
                        _loop_1(positionAssignment);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
    }
    return __assign(__assign({}, SUCCESS), { qualifierReplaced: qualifierReplaced });
}

function placeQualifier(params) {
    var e_1, _a;
    var _b, _c, _d, _e, _f;
    var qualifierPlaced;
    var inContextDrawMatchUps = params.inContextDrawMatchUps, inContextMatchUp = params.inContextMatchUp, drawDefinition = params.drawDefinition, winningSide = params.winningSide;
    var winnerTargetLink = (_b = params.targetData.targetLinks) === null || _b === void 0 ? void 0 : _b.winnerTargetLink;
    if (winnerTargetLink.target.feedProfile === DRAW) {
        var winningQualifierId = (_c = inContextMatchUp.sides.find(function (_a) {
            var sideNumber = _a.sideNumber;
            return sideNumber === winningSide;
        })) === null || _c === void 0 ? void 0 : _c.participantId;
        var mainDrawQualifierMatchUps = inContextDrawMatchUps.filter(function (m) {
            return m.structureId === winnerTargetLink.target.structureId &&
                m.roundNumber === winnerTargetLink.target.roundNumber &&
                m.sides.some(function (_a) {
                    var participantId = _a.participantId, qualifier = _a.qualifier;
                    return qualifier && !participantId;
                });
        });
        var mainDrawTargetMatchUp = randomMember(mainDrawQualifierMatchUps);
        if ((mainDrawTargetMatchUp === null || mainDrawTargetMatchUp === void 0 ? void 0 : mainDrawTargetMatchUp.matchUpStatus) === TO_BE_PLAYED) {
            var targetData = positionTargets({
                matchUpId: mainDrawTargetMatchUp.matchUpId,
                inContextDrawMatchUps: inContextDrawMatchUps,
                drawDefinition: drawDefinition,
            });
            var activeDownstream = isActiveDownstream({
                inContextDrawMatchUps: inContextDrawMatchUps,
                drawDefinition: drawDefinition,
                targetData: targetData,
            });
            if (!activeDownstream) {
                var targetDrawPosition = (_d = mainDrawTargetMatchUp.sides.find(function (side) { return side.qualifier && !side.participantId; })) === null || _d === void 0 ? void 0 : _d.drawPosition;
                var structure = findStructure({
                    structureId: mainDrawTargetMatchUp.structureId,
                    drawDefinition: drawDefinition,
                }).structure;
                if (!structure)
                    return { error: STRUCTURE_NOT_FOUND };
                var positionAssignments = getPositionAssignments$1({
                    structure: structure,
                }).positionAssignments;
                var _loop_1 = function (positionAssignment) {
                    var e_2, _j;
                    if (positionAssignment.drawPosition === targetDrawPosition &&
                        !positionAssignment.participantId) {
                        positionAssignment.participantId = winningQualifierId;
                        // update positionAssignments on structure
                        if (structure.positionAssignments) {
                            structure.positionAssignments = positionAssignments;
                        }
                        else if (structure.structures) {
                            var assignmentMap_1 = Object.assign.apply(Object, __spreadArray([{}], __read((positionAssignments || []).map(function (assignment) {
                                var _a;
                                return (_a = {},
                                    _a[assignment.drawPosition] = assignment.participantId,
                                    _a);
                            })), false));
                            try {
                                for (var _k = (e_2 = void 0, __values(structure.structures)), _l = _k.next(); !_l.done; _l = _k.next()) {
                                    var subStructure = _l.value;
                                    (_e = subStructure.positionAssignments) === null || _e === void 0 ? void 0 : _e.forEach(function (assignment) {
                                        return (assignment.participantId =
                                            assignmentMap_1[assignment.drawPosition]);
                                    });
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (_l && !_l.done && (_j = _k.return)) _j.call(_k);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }
                        modifyPositionAssignmentsNotice({
                            tournamentId: (_f = params.tournamentRecord) === null || _f === void 0 ? void 0 : _f.tournamentId,
                            event: params.event,
                            drawDefinition: drawDefinition,
                            structure: structure,
                        });
                        qualifierPlaced = true;
                    }
                };
                try {
                    for (var _g = __values(positionAssignments || []), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var positionAssignment = _h.value;
                        _loop_1(positionAssignment);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
    }
    return __assign(__assign({}, SUCCESS), { qualifierPlaced: qualifierPlaced });
}

function attemptToSetWinningSide(params) {
    var _a, _b;
    var stack = 'attemptToSetWinningSide';
    var connectedStructures;
    var appliedPolicies = params.appliedPolicies, disableAutoCalc = params.disableAutoCalc, drawDefinition = params.drawDefinition, dualMatchUp = params.dualMatchUp, winningSide = params.winningSide, structure = params.structure, matchUp = params.matchUp;
    // disableAutoCalc means the score is being set manually
    if ((dualMatchUp === null || dualMatchUp === void 0 ? void 0 : dualMatchUp._disableAutoCalc) && disableAutoCalc !== false) {
        return attemptToModifyScore(params);
    }
    if (matchUp.winningSide && matchUp.winningSide !== winningSide) {
        // only applies when progression is based on WIN_RATIO, e.g. ROUND_ROBIN_WITH_PLAYOFF
        var connectedStructureIds = checkConnectedStructures({
            drawDefinition: drawDefinition,
            structure: structure,
            matchUp: matchUp,
        }).connectedStructureIds;
        if (connectedStructureIds.length) {
            // TODO: return a message if there are effects in connected structures
            console.log({ connectedStructureIds: connectedStructureIds });
            connectedStructures = true;
        }
        var result_1 = removeDirectedParticipants(params);
        if (result_1.error)
            return result_1;
    }
    var result = directParticipants(params);
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    var qualifierReplaced, qualifierPlaced;
    if (params.qualifierChanging &&
        ((_a = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_PROGRESSION]) === null || _a === void 0 ? void 0 : _a.autoReplaceQualifiers)) {
        qualifierReplaced = replaceQualifier(params).qualifierReplaced;
    }
    if (params.qualifierAdvancing &&
        ((_b = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_PROGRESSION]) === null || _b === void 0 ? void 0 : _b.autoPlaceQualifiers)) {
        qualifierPlaced = placeQualifier(params).qualifierPlaced;
    }
    return decorateResult({
        result: definedAttributes(__assign(__assign(__assign({}, SUCCESS), result), { // capture attributes from directParticipants
            connectedStructures: connectedStructures, qualifierReplaced: qualifierReplaced, qualifierPlaced: qualifierPlaced })),
        stack: stack,
    });
}

var keyColors = {
    drawPositionToRemove: 'green',
    iteration: 'brightred',
    winner: 'green',
    loser: 'brightred',
};
function removeDoubleExit(params) {
    var _a;
    var inContextDrawMatchUps = params.inContextDrawMatchUps, appliedPolicies = params.appliedPolicies, drawDefinition = params.drawDefinition, matchUpsMap = params.matchUpsMap, targetData = params.targetData, matchUp = params.matchUp;
    var _b = params.iteration, iteration = _b === void 0 ? 0 : _b;
    iteration += 1;
    var stack = 'removeDoubleExit';
    pushGlobalLog({
        method: stack,
        color: 'brightyellow',
        iteration: iteration,
        keyColors: keyColors,
    });
    var loserTargetLink = targetData.targetLinks.loserTargetLink, _c = targetData.targetMatchUps, loserMatchUp = _c.loserMatchUp, winnerMatchUp = _c.winnerMatchUp, loserTargetDrawPosition = _c.loserTargetDrawPosition;
    // only handles winnerMatchUps in the same structure
    if (winnerMatchUp && winnerMatchUp.matchUpStatus !== BYE) {
        var stage = winnerMatchUp.stage, roundNumber = winnerMatchUp.roundNumber, roundPosition = winnerMatchUp.roundPosition;
        pushGlobalLog({
            winner: 'winner',
            stage: stage,
            roundNumber: roundNumber,
            roundPosition: roundPosition,
            keyColors: keyColors,
        });
        conditionallyRemoveDrawPosition(__assign(__assign({}, params), { targetMatchUp: winnerMatchUp, sourceMatchUp: matchUp, iteration: iteration }));
    }
    if (loserMatchUp && loserMatchUp.matchUpStatus !== BYE) {
        var inContextLoserMatchUp = inContextDrawMatchUps.find(function (_a) {
            var matchUpId = _a.matchUpId;
            return matchUpId === loserMatchUp.matchUpId;
        });
        var loserStructure = findStructure({
            drawDefinition: drawDefinition,
            structureId: inContextLoserMatchUp.structureId,
        }).structure;
        var stage = loserMatchUp.stage, roundNumber = loserMatchUp.roundNumber, roundPosition = loserMatchUp.roundPosition, feedRound = loserMatchUp.feedRound;
        pushGlobalLog({
            loser: 'loser',
            stage: stage,
            roundNumber: roundNumber,
            roundPosition: roundPosition,
            keyColors: keyColors,
            feedRound: feedRound,
        });
        if ((_a = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.progression) === null || _a === void 0 ? void 0 : _a.doubleExitPropagateBye) {
            removeDirectedBye({
                drawPosition: loserTargetDrawPosition,
                targetLink: loserTargetLink,
                inContextDrawMatchUps: inContextDrawMatchUps,
                drawDefinition: drawDefinition,
                matchUpsMap: matchUpsMap,
            });
        }
        else {
            var result = conditionallyRemoveDrawPosition(__assign(__assign({}, params), { structure: loserStructure, targetMatchUp: loserMatchUp, iteration: iteration }));
            if (result.error)
                return decorateResult({ result: result, stack: stack });
        }
    }
    return decorateResult({ result: __assign({}, SUCCESS), stack: stack });
}
function conditionallyRemoveDrawPosition(params) {
    var _a, _b, _c, _d, _e;
    var inContextDrawMatchUps = params.inContextDrawMatchUps, appliedPolicies = params.appliedPolicies, drawDefinition = params.drawDefinition, sourceMatchUp = params.sourceMatchUp, targetMatchUp = params.targetMatchUp, matchUpsMap = params.matchUpsMap, structure = params.structure, iteration = params.iteration;
    var stack = 'conditionallyRemoveDrawPosition';
    pushGlobalLog({ method: stack });
    // only handles winnerMatchUps in the same structure
    var nextTargetData = positionTargets({
        matchUpId: targetMatchUp.matchUpId,
        inContextDrawMatchUps: inContextDrawMatchUps,
        drawDefinition: drawDefinition,
    });
    var nextWinnerMatchUp = nextTargetData.targetMatchUps.winnerMatchUp;
    var noContextTargetMatchUp = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.drawMatchUps.find(function (matchUp) { return matchUp.matchUpId === targetMatchUp.matchUpId; });
    var pairedPreviousDrawPositions = [];
    var pairedPreviousDoubleExit;
    var pairedPreviousMatchUp;
    var drawPositionToRemove;
    // targetMatchUp has context
    if (targetMatchUp.feedRound) {
        var nextWinnerDrawPositions = (_a = nextWinnerMatchUp === null || nextWinnerMatchUp === void 0 ? void 0 : nextWinnerMatchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.filter(Boolean);
        drawPositionToRemove = nextWinnerDrawPositions === null || nextWinnerDrawPositions === void 0 ? void 0 : nextWinnerDrawPositions.find(function (drawPosition) {
            return targetMatchUp.drawPositions.includes(drawPosition);
        });
    }
    else if (!sourceMatchUp) {
        drawPositionToRemove = (_b = intersection((targetMatchUp === null || targetMatchUp === void 0 ? void 0 : targetMatchUp.drawPositions) || [], (nextWinnerMatchUp === null || nextWinnerMatchUp === void 0 ? void 0 : nextWinnerMatchUp.drawPositions) || [])) === null || _b === void 0 ? void 0 : _b[0];
    }
    else {
        pairedPreviousMatchUp = (_c = getPairedPreviousMatchUp({
            structureId: structure.structureId,
            matchUp: sourceMatchUp,
            matchUpsMap: matchUpsMap,
        })) === null || _c === void 0 ? void 0 : _c.pairedPreviousMatchUp;
        pairedPreviousDoubleExit = [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(pairedPreviousMatchUp === null || pairedPreviousMatchUp === void 0 ? void 0 : pairedPreviousMatchUp.matchUpStatus);
        pairedPreviousDrawPositions =
            ((_d = pairedPreviousMatchUp === null || pairedPreviousMatchUp === void 0 ? void 0 : pairedPreviousMatchUp.drawPositions) === null || _d === void 0 ? void 0 : _d.filter(Boolean)) || [];
        var pairedPreviousMatchUpComplete = __spreadArray(__spreadArray([], __read(completedMatchUpStatuses), false), [BYE], false).includes(pairedPreviousMatchUp === null || pairedPreviousMatchUp === void 0 ? void 0 : pairedPreviousMatchUp.matchUpStatus) || (pairedPreviousMatchUp === null || pairedPreviousMatchUp === void 0 ? void 0 : pairedPreviousMatchUp.winningSide);
        if (pairedPreviousMatchUpComplete) {
            var sourceDrawPositions_1 = sourceMatchUp.drawPositions || [];
            var targetDrawPositions_1 = (_e = targetMatchUp.drawPositions) === null || _e === void 0 ? void 0 : _e.filter(Boolean);
            if (overlap(sourceDrawPositions_1, targetDrawPositions_1)) {
                targetDrawPositions_1 = targetDrawPositions_1 === null || targetDrawPositions_1 === void 0 ? void 0 : targetDrawPositions_1.filter(function (drawPosition) { return !sourceDrawPositions_1.includes(drawPosition); });
            }
            var possibleBranchDrawPositions = sourceDrawPositions_1.concat(pairedPreviousDrawPositions);
            drawPositionToRemove = possibleBranchDrawPositions.find(function (drawPosition) { return targetDrawPositions_1 === null || targetDrawPositions_1 === void 0 ? void 0 : targetDrawPositions_1.includes(drawPosition); });
        }
    }
    if (nextWinnerMatchUp && drawPositionToRemove) {
        var stage = nextWinnerMatchUp.stage, roundNumber = nextWinnerMatchUp.roundNumber, roundPosition = nextWinnerMatchUp.roundPosition;
        pushGlobalLog({
            method: 'removeDirectedWinner',
            drawPositionToRemove: drawPositionToRemove,
            keyColors: keyColors,
            color: 'brightgreen',
            stage: stage,
            roundNumber: roundNumber,
            roundPosition: roundPosition,
        });
        removeDirectedWinner({
            winningDrawPosition: drawPositionToRemove,
            winnerMatchUp: nextWinnerMatchUp,
            inContextDrawMatchUps: inContextDrawMatchUps,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
        });
    }
    var result = removeDoubleExit({
        targetData: nextTargetData,
        matchUp: targetMatchUp,
        inContextDrawMatchUps: inContextDrawMatchUps,
        appliedPolicies: appliedPolicies,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        structure: structure,
        iteration: iteration,
    });
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    var matchUpStatus = getMatchUpStatus({
        pairedPreviousDoubleExit: pairedPreviousDoubleExit,
        noContextTargetMatchUp: noContextTargetMatchUp,
    });
    var removeScore = !pairedPreviousDoubleExit;
    result = modifyMatchUpScore(__assign(__assign({}, params), { matchUpStatus: matchUpStatus, removeScore: removeScore, score: {
            scoreStringSide1: '',
            scoreStringSide2: '',
            sets: undefined,
        }, removeWinningSide: true, matchUp: noContextTargetMatchUp, matchUpId: targetMatchUp.matchUpId, matchUpStatusCodes: [] }));
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    return __assign({}, SUCCESS);
}
function getMatchUpStatus(_a) {
    var pairedPreviousDoubleExit = _a.pairedPreviousDoubleExit, noContextTargetMatchUp = _a.noContextTargetMatchUp;
    if (noContextTargetMatchUp.matchUpStatus === BYE)
        return BYE;
    if (!pairedPreviousDoubleExit)
        return TO_BE_PLAYED;
    return [DOUBLE_DEFAULT, DEFAULTED].includes(noContextTargetMatchUp === null || noContextTargetMatchUp === void 0 ? void 0 : noContextTargetMatchUp.matchUpStatus)
        ? DEFAULTED
        : WALKOVER$2;
}

function removeQualifier(params) {
    var e_1, _a;
    var _b, _c, _d, _e, _f;
    var qualifierRemoved;
    var inContextDrawMatchUps = params.inContextDrawMatchUps, inContextMatchUp = params.inContextMatchUp, drawDefinition = params.drawDefinition;
    var winnerTargetLink = (_b = params.targetData.targetLinks) === null || _b === void 0 ? void 0 : _b.winnerTargetLink;
    if (winnerTargetLink.target.feedProfile === DRAW) {
        var previousWinningParticipantId_1 = (_d = (_c = inContextMatchUp.sides) === null || _c === void 0 ? void 0 : _c.find(function (_a) {
            var sideNumber = _a.sideNumber;
            return sideNumber === inContextMatchUp.winningSide;
        })) === null || _d === void 0 ? void 0 : _d.participantId;
        var mainDrawTargetMatchUp = inContextDrawMatchUps.find(function (m) {
            var _a;
            return m.structureId === winnerTargetLink.target.structureId &&
                m.roundNumber === winnerTargetLink.target.roundNumber &&
                ((_a = m.sides) === null || _a === void 0 ? void 0 : _a.some(function (_a) {
                    var participantId = _a.participantId;
                    return participantId === previousWinningParticipantId_1;
                }));
        });
        if (mainDrawTargetMatchUp &&
            mainDrawTargetMatchUp.matchUpStatus === TO_BE_PLAYED) {
            // prevoius winningSide participant was placed in MAIN
            var targetData = positionTargets({
                matchUpId: mainDrawTargetMatchUp.matchUpId,
                inContextDrawMatchUps: inContextDrawMatchUps,
                drawDefinition: drawDefinition,
            });
            var activeDownstream = isActiveDownstream({
                inContextDrawMatchUps: inContextDrawMatchUps,
                drawDefinition: drawDefinition,
                targetData: targetData,
            });
            if (!activeDownstream) {
                var structure = findStructure({
                    structureId: mainDrawTargetMatchUp.structureId,
                    drawDefinition: drawDefinition,
                }).structure;
                var positionAssignments = getPositionAssignments$1({
                    structure: structure,
                }).positionAssignments;
                var _loop_1 = function (positionAssignment) {
                    var e_2, _j;
                    if (positionAssignment.participantId === previousWinningParticipantId_1) {
                        positionAssignment.participantId = undefined;
                        // update positionAssignments on structure
                        if (structure === null || structure === void 0 ? void 0 : structure.positionAssignments) {
                            structure.positionAssignments = positionAssignments;
                        }
                        else if (structure === null || structure === void 0 ? void 0 : structure.structures) {
                            var assignmentMap_1 = Object.assign.apply(Object, __spreadArray([{}], __read((positionAssignments || []).map(function (assignment) {
                                var _a;
                                return (_a = {},
                                    _a[assignment.drawPosition] = assignment.participantId,
                                    _a);
                            })), false));
                            try {
                                for (var _k = (e_2 = void 0, __values((structure === null || structure === void 0 ? void 0 : structure.structures) || [])), _l = _k.next(); !_l.done; _l = _k.next()) {
                                    var subStructure = _l.value;
                                    (_e = subStructure.positionAssignments) === null || _e === void 0 ? void 0 : _e.forEach(function (assignment) {
                                        return (assignment.participantId =
                                            assignmentMap_1[assignment.drawPosition]);
                                    });
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (_l && !_l.done && (_j = _k.return)) _j.call(_k);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }
                        modifyPositionAssignmentsNotice({
                            tournamentId: (_f = params.tournamentRecord) === null || _f === void 0 ? void 0 : _f.tournamentId,
                            event: params.event,
                            drawDefinition: drawDefinition,
                            structure: structure,
                        });
                        qualifierRemoved = true;
                    }
                };
                try {
                    for (var _g = __values(positionAssignments || []), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var positionAssignment = _h.value;
                        _loop_1(positionAssignment);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
    }
    return { qualifierRemoved: qualifierRemoved };
}

function noDownstreamDependencies(params) {
    var _a;
    var matchUp = params.matchUp, matchUpStatus = params.matchUpStatus, score = params.score, winningSide = params.winningSide;
    var stack = 'noDownStreamDependencies';
    var doubleExitCleanup = [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpStatus) &&
        ![DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUpStatus);
    if (doubleExitCleanup) {
        var result_1 = removeDoubleExit(params);
        if (result_1.error)
            return decorateResult({ result: result_1, stack: stack });
    }
    var doubleWalkover = matchUpStatus === DOUBLE_WALKOVER;
    var scoreWithNoWinningSide = checkScoreHasValue({ score: score }) &&
        !doubleWalkover &&
        ((params.isCollectionMatchUp && !params.projectedWinningSide) ||
            !winningSide);
    var timedTieMatchUp = ((_a = params === null || params === void 0 ? void 0 : params.inContextMatchUp) === null || _a === void 0 ? void 0 : _a.collectionId) &&
        lastSetFormatIsTimed(params.inContextMatchUp);
    var removeScore = params.removeScore ||
        (!timedTieMatchUp &&
            ![INCOMPLETE, ABANDONED$1].includes(matchUpStatus || INCOMPLETE));
    var removeWinningSide = (params.isCollectionMatchUp &&
        params.dualMatchUp.winningSide &&
        !params.projectedWinningSide) ||
        (matchUp.winningSide && !winningSide && !checkScoreHasValue({ score: score }));
    var statusNotTBP = matchUpStatus && matchUpStatus !== TO_BE_PLAYED;
    var removeDirected = function (removeScore) {
        var _a, _b;
        var connectedStructures;
        var structure = params.structure, drawDefinition = params.drawDefinition, dualMatchUp = params.dualMatchUp, disableAutoCalc = params.disableAutoCalc;
        // disableAutoCalc means the score is being set manually
        if ((dualMatchUp === null || dualMatchUp === void 0 ? void 0 : dualMatchUp._disableAutoCalc) && disableAutoCalc !== false) {
            return attemptToModifyScore(params);
        }
        var connectedStructureIds = checkConnectedStructures({
            drawDefinition: drawDefinition,
            structure: structure,
            matchUp: matchUp,
        }).connectedStructureIds; // only relevant to WIN_RATIO progression
        if (connectedStructureIds.length) {
            // TODO: return a message if there are effects in connected structures
            console.log({ connectedStructureIds: connectedStructureIds });
            connectedStructures = true;
        }
        Object.assign(params, { removeScore: removeScore });
        var result = removeDirectedParticipants(params);
        if (result.error)
            return result;
        if (params.removingQualifier &&
            ((_b = (_a = params.appliedPolicies) === null || _a === void 0 ? void 0 : _a[POLICY_TYPE_PROGRESSION]) === null || _b === void 0 ? void 0 : _b.autoRemoveQualifiers)) {
            var result_2 = removeQualifier(params);
            return __assign(__assign(__assign({}, SUCCESS), { connectedStructures: connectedStructures }), result_2);
        }
        return __assign(__assign({}, SUCCESS), { connectedStructures: connectedStructures });
    };
    if (removeWinningSide && winningSide && params.isCollectionMatchUp) {
        // this is only possible if a TEAM dualMatchUp has an SINGLES/DOUBLES matchUp winningSide change
        return scoreModification(params);
    }
    var triggerDualWinningSide = [CANCELLED$1, ABANDONED$1].includes(matchUpStatus) &&
        params.dualWinningSideChange;
    var result = ((winningSide || triggerDualWinningSide) &&
        attemptToSetWinningSide(params)) ||
        (scoreWithNoWinningSide && removeDirected(removeScore)) ||
        (statusNotTBP && attemptToSetMatchUpStatus(params)) ||
        (removeWinningSide && removeDirected(removeScore)) ||
        (matchUp && scoreModification(__assign(__assign({}, params), { removeScore: true }))) || __assign({}, SUCCESS);
    return decorateResult({ result: result, stack: stack });
}
function scoreModification(params) {
    var _a;
    var stack = 'scoreModification';
    var remove = params.isCollectionMatchUp &&
        ((_a = params.dualMatchUp) === null || _a === void 0 ? void 0 : _a.winningSide) &&
        !params.projectedWinningSide;
    if (remove) {
        var result_3 = removeDirectedParticipants(params);
        if (result_3.error)
            return result_3;
    }
    var result = modifyMatchUpScore(__assign({}, params));
    // recalculate dualMatchUp score if isCollectionMatchUp
    if (params.isCollectionMatchUp) {
        var matchUpTieId = params.matchUpTieId, drawDefinition = params.drawDefinition, event_1 = params.event, matchUpsMap = params.matchUpsMap;
        var removeWinningSide = updateTieMatchUpScore({
            tournamentRecord: params.tournamentRecord,
            matchUpId: matchUpTieId,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
            event: event_1,
        }).removeWinningSide;
        if (removeWinningSide)
            console.log('REMOVE WINNING SIDE');
    }
    return decorateResult({ result: result, stack: stack });
}

function allocateTeamMatchUpCourts(_a) {
    var _b;
    var _c, _d;
    var removePriorValues = _a.removePriorValues, tournamentRecords = _a.tournamentRecords, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, disableNotice = _a.disableNotice, courtDayDate = _a.courtDayDate, matchUpId = _a.matchUpId, courtIds = _a.courtIds;
    if (!tournamentRecord && !tournamentRecords)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    var result = findDrawMatchUp({
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
    });
    if (result.error)
        return result;
    if (((_c = result === null || result === void 0 ? void 0 : result.matchUp) === null || _c === void 0 ? void 0 : _c.matchUpType) !== TEAM_MATCHUP)
        return { error: INVALID_MATCHUP };
    var validCourtIds = courtIds === undefined ||
        (Array.isArray(courtIds) &&
            courtIds.length &&
            courtIds.every(function (id) { return typeof id === 'string'; }));
    if (!validCourtIds)
        return { error: INVALID_VALUES, context: { courtIds: courtIds } };
    var itemValue;
    if (courtIds) {
        var tournaments = tournamentRecords
            ? tournamentRecords
            : tournamentRecord && (_b = {},
                _b[tournamentRecord.tournamentId] = tournamentRecord,
                _b);
        var result_1 = getVenuesAndCourts({
            tournamentRecords: tournaments,
        });
        if (result_1.error)
            return result_1;
        var specifiedCourts = (_d = result_1.courts) === null || _d === void 0 ? void 0 : _d.filter(function (court) {
            return courtIds.includes(court.courtId);
        });
        if ((specifiedCourts === null || specifiedCourts === void 0 ? void 0 : specifiedCourts.length) !== courtIds.length) {
            return { error: INVALID_VALUES, context: { courtIds: courtIds } };
        }
        itemValue = specifiedCourts === null || specifiedCourts === void 0 ? void 0 : specifiedCourts.map(function (court) { return ({
            venueId: court.venueId,
            courtId: court.courtId,
        }); });
    }
    var timeItem = {
        itemType: ALLOCATE_COURTS,
        itemDate: courtDayDate,
        itemValue: itemValue,
    };
    return addMatchUpTimeItem({
        duplicateValues: false,
        removePriorValues: removePriorValues,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        disableNotice: disableNotice,
        matchUpId: matchUpId,
        timeItem: timeItem,
    });
}

function assignMatchUpVenue(_a) {
    var removePriorValues = _a.removePriorValues, tournamentRecords = _a.tournamentRecords, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, disableNotice = _a.disableNotice, matchUpId = _a.matchUpId, venueId = _a.venueId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    if (venueId) {
        var result = findVenue({
            tournamentRecords: tournamentRecords,
            tournamentRecord: tournamentRecord,
            venueId: venueId,
        });
        if (result.error)
            return result;
    }
    var timeItem = {
        itemType: ASSIGN_VENUE,
        itemValue: venueId,
    };
    return addMatchUpTimeItem({
        duplicateValues: false,
        removePriorValues: removePriorValues,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        disableNotice: disableNotice,
        matchUpId: matchUpId,
        timeItem: timeItem,
    });
}

function assignMatchUpCourt(_a) {
    var _b;
    var removePriorValues = _a.removePriorValues, tournamentRecords = _a.tournamentRecords, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, disableNotice = _a.disableNotice, courtDayDate = _a.courtDayDate, matchUpId = _a.matchUpId, courtId = _a.courtId;
    if (!tournamentRecord && !tournamentRecords)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    if (courtId) {
        var result = findCourt({
            tournamentRecords: tournamentRecords,
            tournamentRecord: tournamentRecord,
            courtId: courtId,
        });
        if (result.error)
            return result;
        var venueId = (_b = result.venue) === null || _b === void 0 ? void 0 : _b.venueId;
        assignMatchUpVenue({
            tournamentRecords: tournamentRecords,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            disableNotice: disableNotice,
            matchUpId: matchUpId,
            venueId: venueId,
        });
    }
    var timeItem = {
        itemType: ASSIGN_COURT,
        itemDate: courtDayDate,
        itemValue: courtId,
    };
    return addMatchUpTimeItem({
        duplicateValues: false,
        removePriorValues: removePriorValues,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        disableNotice: disableNotice,
        matchUpId: matchUpId,
        timeItem: timeItem,
    });
}

function addMatchUpScheduledTime(params) {
    var stack = 'addMatchUpScheduledTime';
    var matchUp = params.matchUp;
    var removePriorValues = params.removePriorValues, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, disableNotice = params.disableNotice, scheduledTime = params.scheduledTime, matchUpId = params.matchUpId;
    if (!matchUpId)
        return decorateResult({ result: { error: MISSING_MATCHUP_ID }, stack: stack });
    // must support undefined as a value so that scheduledTime can be cleared
    if (!validTimeValue(scheduledTime))
        return decorateResult({ result: { error: INVALID_TIME }, stack: stack });
    if (!matchUp) {
        var result = findDrawMatchUp({ drawDefinition: drawDefinition, matchUpId: matchUpId });
        if (result.error)
            return decorateResult({ result: result, stack: stack });
        matchUp = result.matchUp;
    }
    var timeDate = extractDate(scheduledTime);
    var scheduledDate = scheduledMatchUpDate({ matchUp: matchUp }).scheduledDate;
    var keepDate = timeDate && !scheduledDate;
    var existingTimeModifiers = matchUpTimeModifiers({ matchUp: matchUp }).timeModifiers || [];
    if (existingTimeModifiers === null || existingTimeModifiers === void 0 ? void 0 : existingTimeModifiers.length) {
        var result = addMatchUpTimeModifiers({
            disableNotice: true,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            timeModifiers: [],
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
            matchUp: matchUp,
        });
        if (result === null || result === void 0 ? void 0 : result.error)
            return decorateResult({ result: result, stack: stack });
    }
    // All times stored as military time
    var militaryTime = convertTime(scheduledTime, true, keepDate);
    var itemValue = militaryTime;
    var timeItem = {
        itemType: SCHEDULED_TIME,
        itemValue: itemValue,
    };
    return addMatchUpTimeItem({
        duplicateValues: false,
        removePriorValues: removePriorValues,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        disableNotice: disableNotice,
        matchUpId: matchUpId,
        timeItem: timeItem,
    });
}
function addMatchUpTimeModifiers(_a) {
    var removePriorValues = _a.removePriorValues, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, disableNotice = _a.disableNotice, timeModifiers = _a.timeModifiers, matchUpId = _a.matchUpId, matchUp = _a.matchUp;
    var stack = 'addMatchUpTimeModifiers';
    if (!matchUpId)
        return decorateResult({ result: { error: MISSING_MATCHUP_ID }, stack: stack });
    if (timeModifiers !== undefined && !Array.isArray(timeModifiers))
        return decorateResult({
            info: mustBeAnArray('timeModifiers'),
            result: { error: INVALID_VALUES },
            stack: stack,
        });
    if (!matchUp) {
        var result = findDrawMatchUp({ drawDefinition: drawDefinition, matchUpId: matchUpId });
        if (result.error)
            return decorateResult({ result: result, stack: stack });
        matchUp = result.matchUp;
    }
    var existingTimeModifiers = matchUpTimeModifiers({ matchUp: matchUp }).timeModifiers || [];
    var toBeAdded = timeModifiers.filter(function (modifier) { return !existingTimeModifiers.includes(modifier); });
    if (timeModifiers.length && !toBeAdded.length)
        return __assign({}, SUCCESS);
    // remove all existing exclusives if incoming includes exclusive
    var containsExclusive = toBeAdded.some(function (modifier) {
        return MUTUALLY_EXCLUSIVE_TIME_MODIFIERS.includes(modifier);
    });
    if (containsExclusive) {
        existingTimeModifiers = existingTimeModifiers.filter(function (modifier) { return !MUTUALLY_EXCLUSIVE_TIME_MODIFIERS.includes(modifier); });
        // scheduledTime should be removed for exclusive timeModifiers
        var result = addMatchUpScheduledTime({
            disableNotice: true,
            removePriorValues: removePriorValues,
            scheduledTime: '',
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
        });
        if (result.error)
            return decorateResult({ result: result, stack: stack });
    }
    // undefined value when array is empty;
    var itemValue = !(timeModifiers === null || timeModifiers === void 0 ? void 0 : timeModifiers.length)
        ? undefined
        : __spreadArray(__spreadArray([], __read(toBeAdded), false), __read(existingTimeModifiers), false);
    var timeItem = {
        itemType: TIME_MODIFIERS,
        itemValue: itemValue,
    };
    return addMatchUpTimeItem({
        duplicateValues: false,
        removePriorValues: removePriorValues,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        disableNotice: disableNotice,
        matchUpId: matchUpId,
        timeItem: timeItem,
    });
}

function timeDate(value, scheduledDate) {
    var time = validTimeString.test(value) ? value : extractTime(value);
    var date = extractDate(value) || extractDate(scheduledDate) || formatDate(new Date());
    // doesn't matter if this is invalid due to undefined time because this is used for sorting only
    return new Date("".concat(date, "T").concat(time)).getTime();
}
function addMatchUpScheduleItems(_a) {
    var _b;
    var _c;
    var _d = _a.errorOnAnachronism, errorOnAnachronism = _d === void 0 ? false : _d, _e = _a.checkChronology, checkChronology = _e === void 0 ? true : _e, matchUpDependencies = _a.matchUpDependencies, inContextMatchUps = _a.inContextMatchUps, removePriorValues = _a.removePriorValues, tournamentRecords = _a.tournamentRecords, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, disableNotice = _a.disableNotice, drawMatchUps = _a.drawMatchUps, matchUpId = _a.matchUpId, schedule = _a.schedule, event = _a.event;
    if (!schedule)
        return { error: MISSING_VALUE, info: 'Missing schedule' };
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    var stack = 'addMatchUpScheduleItems';
    var matchUp, warning;
    if (!drawMatchUps) {
        var result = findDrawMatchUp({ drawDefinition: drawDefinition, event: event, matchUpId: matchUpId });
        if (result.error)
            return result;
        matchUp = result.matchUp;
    }
    else {
        matchUp = drawMatchUps.find(function (drawMatchUp) { return drawMatchUp.matchUpId === matchUpId; });
    }
    var endTime = schedule.endTime, courtId = schedule.courtId, courtIds = schedule.courtIds, courtOrder = schedule.courtOrder, resumeTime = schedule.resumeTime, scheduledDate = schedule.scheduledDate, scheduledTime = schedule.scheduledTime, startTime = schedule.startTime, stopTime = schedule.stopTime, timeModifiers = schedule.timeModifiers, venueId = schedule.venueId;
    if (checkChronology && (!matchUpDependencies || !inContextMatchUps)) {
        (_b = getMatchUpDependencies({
            drawDefinition: drawDefinition,
        }), matchUpDependencies = _b.matchUpDependencies, inContextMatchUps = _b.matchUps);
    }
    var priorMatchUpIds = (_c = matchUpDependencies === null || matchUpDependencies === void 0 ? void 0 : matchUpDependencies[matchUpId]) === null || _c === void 0 ? void 0 : _c.matchUpIds;
    if (schedule.scheduledDate && checkChronology && priorMatchUpIds) {
        var priorMatchUpTimes = inContextMatchUps === null || inContextMatchUps === void 0 ? void 0 : inContextMatchUps.filter(function (matchUp) {
            var _a, _b;
            return (((_a = matchUp.schedule) === null || _a === void 0 ? void 0 : _a.scheduledDate) ||
                extractDate((_b = matchUp.schedule) === null || _b === void 0 ? void 0 : _b.scheduledTime)) &&
                priorMatchUpIds.includes(matchUp.matchUpId);
        }).map(function (_a) {
            var schedule = _a.schedule;
            var isoDateString = getIsoDateString(schedule);
            return new Date(isoDateString).getTime();
        });
        if (priorMatchUpTimes === null || priorMatchUpTimes === void 0 ? void 0 : priorMatchUpTimes.length) {
            var isoDateString = getIsoDateString(schedule);
            var matchUpTime = new Date(isoDateString).getTime();
            var maxPriorMatchUpTime = Math.max.apply(Math, __spreadArray([], __read(priorMatchUpTimes), false));
            if (maxPriorMatchUpTime >= matchUpTime) {
                if (errorOnAnachronism) {
                    return decorateResult({ result: { error: ANACHRONISM }, stack: stack });
                }
                else {
                    warning = ANACHRONISM;
                }
            }
        }
    }
    if (scheduledDate !== undefined) {
        var result = addMatchUpScheduledDate({
            disableNotice: true,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            scheduledDate: scheduledDate,
            matchUpId: matchUpId,
        });
        if (result === null || result === void 0 ? void 0 : result.error)
            return decorateResult({ result: result, stack: stack, context: { scheduledDate: scheduledDate } });
    }
    if (scheduledTime !== undefined) {
        var result = addMatchUpScheduledTime({
            disableNotice: true,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            scheduledTime: scheduledTime,
            matchUpId: matchUpId,
            matchUp: matchUp,
        });
        if (result === null || result === void 0 ? void 0 : result.error)
            return decorateResult({ result: result, stack: stack, context: { scheduledTime: scheduledTime } });
    }
    if (startTime !== undefined) {
        var result = addMatchUpStartTime({
            disableNotice: true,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
            startTime: startTime,
            event: event,
        });
        if (result === null || result === void 0 ? void 0 : result.error)
            return decorateResult({ result: result, stack: stack, context: { startTime: startTime } });
    }
    if (stopTime !== undefined) {
        var result = addMatchUpStopTime({
            disableNotice: true,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
            stopTime: stopTime,
            event: event,
        });
        if (result === null || result === void 0 ? void 0 : result.error)
            return decorateResult({ result: result, stack: stack, context: { stopTime: stopTime } });
    }
    if (resumeTime !== undefined) {
        var result = addMatchUpResumeTime({
            disableNotice: true,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            resumeTime: resumeTime,
            matchUpId: matchUpId,
            event: event,
        });
        if (result === null || result === void 0 ? void 0 : result.error)
            return decorateResult({ result: result, stack: stack, context: { resumeTime: resumeTime } });
    }
    if (endTime !== undefined) {
        var result = addMatchUpEndTime({
            disableNotice: true,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
            endTime: endTime,
            event: event,
        });
        if (result === null || result === void 0 ? void 0 : result.error)
            return decorateResult({ result: result, stack: stack, context: { endTime: endTime } });
    }
    if (courtIds !== undefined) {
        var result = allocateTeamMatchUpCourts({
            disableNotice: true,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
            courtIds: courtIds,
        });
        if (result === null || result === void 0 ? void 0 : result.error)
            return decorateResult({ result: result, stack: stack, context: { courtIds: courtIds } });
    }
    if (courtId !== undefined && scheduledDate !== undefined) {
        var result = assignMatchUpCourt({
            courtDayDate: scheduledDate,
            disableNotice: true,
            removePriorValues: removePriorValues,
            tournamentRecords: tournamentRecords,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
            courtId: courtId,
        });
        if (result === null || result === void 0 ? void 0 : result.error)
            return decorateResult({ result: result, stack: stack, context: { courtId: courtId } });
    }
    if (venueId !== undefined) {
        var result = assignMatchUpVenue({
            disableNotice: true,
            removePriorValues: removePriorValues,
            tournamentRecords: tournamentRecords,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
            venueId: venueId,
        });
        if (result === null || result === void 0 ? void 0 : result.error)
            return decorateResult({ result: result, stack: stack, context: { venueId: venueId } });
    }
    if (courtOrder !== undefined && isConvertableInteger(courtOrder)) {
        var result = addMatchUpCourtOrder({
            disableNotice: true,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            courtOrder: courtOrder,
            matchUpId: matchUpId,
        });
        if (result === null || result === void 0 ? void 0 : result.error)
            return decorateResult({ result: result, stack: stack, context: { courtOrder: courtOrder } });
    }
    if (timeModifiers !== undefined) {
        var result = addMatchUpTimeModifiers({
            disableNotice: true,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            timeModifiers: timeModifiers,
            matchUpId: matchUpId,
            matchUp: matchUp,
        });
        if (result === null || result === void 0 ? void 0 : result.error)
            return decorateResult({ result: result, stack: stack, context: { timeModifiers: timeModifiers } });
    }
    if (!disableNotice) {
        modifyMatchUpNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            context: stack,
            drawDefinition: drawDefinition,
            matchUp: matchUp,
        });
    }
    return warning ? __assign(__assign({}, SUCCESS), { warnings: [warning] }) : __assign({}, SUCCESS);
}
function addMatchUpScheduledDate(_a) {
    var dateToSchedule = _a.scheduledDate, removePriorValues = _a.removePriorValues, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, disableNotice = _a.disableNotice, matchUpId = _a.matchUpId;
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    // TODO: if there is existing scheduledDate and no other relevant timeItems, delete prior
    // TODO: check that scheduledDate is within range of event dates / tournament dates
    // TODO: check that 1) scheduledDate is valid date and 2) is in range for tournament
    // this must be done in tournamentEngine wrapper
    var validDate = dateToSchedule && dateValidation.test(dateToSchedule);
    if (dateToSchedule && !validDate)
        return { error: INVALID_DATE };
    var scheduledDate = extractDate(dateToSchedule);
    var timeItem = {
        itemValue: scheduledDate,
        itemType: SCHEDULED_DATE,
    };
    return addMatchUpTimeItem({
        duplicateValues: false,
        removePriorValues: removePriorValues,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        disableNotice: disableNotice,
        matchUpId: matchUpId,
        timeItem: timeItem,
    });
}
function addMatchUpCourtOrder(_a) {
    var removePriorValues = _a.removePriorValues, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, disableNotice = _a.disableNotice, courtOrder = _a.courtOrder, matchUpId = _a.matchUpId;
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    if (courtOrder && !isConvertableInteger(courtOrder))
        return { error: INVALID_VALUES, info: 'courtOrder must be numeric' };
    var itemValue = courtOrder && ensureInt(courtOrder);
    var timeItem = {
        itemType: COURT_ORDER,
        itemValue: itemValue,
    };
    return addMatchUpTimeItem({
        duplicateValues: false,
        removePriorValues: removePriorValues,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        disableNotice: disableNotice,
        matchUpId: matchUpId,
        timeItem: timeItem,
    });
}
function addMatchUpOfficial(_a) {
    var _b;
    var removePriorValues = _a.removePriorValues, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, disableNotice = _a.disableNotice, participantId = _a.participantId, officialType = _a.officialType, matchUpId = _a.matchUpId;
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    // TODO: check that 1) participantId has the appropriate participantRole
    if (!participantId)
        return { error: MISSING_PARTICIPANT_ID };
    if (tournamentRecord) {
        var tournamentParticipants = (_b = getParticipants({
            tournamentRecord: tournamentRecord,
            participantFilters: {
                participantTypes: [INDIVIDUAL],
                participantRoles: [OFFICIAL],
            },
        }).participants) !== null && _b !== void 0 ? _b : [];
        var participant = findParticipant({
            tournamentParticipants: tournamentParticipants,
            participantId: participantId,
        });
        if (!participant)
            return { error: PARTICIPANT_NOT_FOUND };
    }
    var timeItem = {
        itemType: 'SCHEDULE.ASSIGNMENT.OFFICIAL',
        itemValue: participantId,
    };
    if (officialType)
        timeItem.itemSubTypes = [officialType];
    return addMatchUpTimeItem({
        duplicateValues: false,
        removePriorValues: removePriorValues,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        disableNotice: disableNotice,
        matchUpId: matchUpId,
        timeItem: timeItem,
    });
}
function addMatchUpStartTime(_a) {
    var _b;
    var removePriorValues = _a.removePriorValues, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, disableNotice = _a.disableNotice, matchUpId = _a.matchUpId, startTime = _a.startTime, event = _a.event;
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    if (!validTimeValue(startTime))
        return { error: INVALID_TIME };
    var matchUp = findDrawMatchUp({ drawDefinition: drawDefinition, event: event, matchUpId: matchUpId }).matchUp;
    var scheduledDate = scheduledMatchUpDate({ matchUp: matchUp }).scheduledDate;
    var timeItems = (_b = matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) !== null && _b !== void 0 ? _b : [];
    var earliestRelevantTimeValue = timeItems
        .filter(function (timeItem) {
        return [STOP_TIME, RESUME_TIME, END_TIME].includes(timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType);
    })
        .map(function (timeItem) { return timeDate(timeItem.itemValue, scheduledDate); })
        .reduce(function (earliest, timeValue) {
        return !earliest || timeValue < earliest ? timeValue : earliest;
    }, undefined);
    // START_TIME must be prior to any STOP_TIMEs, RESUME_TIMEs and STOP_TIME
    if (!earliestRelevantTimeValue ||
        timeDate(startTime, scheduledDate) < earliestRelevantTimeValue) {
        // there can be only one START_TIME; if a prior START_TIME exists, remove it
        if (matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) {
            matchUp.timeItems = matchUp.timeItems.filter(function (timeItem) { return timeItem.itemType !== START_TIME; });
        }
        var militaryTime = convertTime(startTime, true, true);
        var timeItem = { itemType: START_TIME, itemValue: militaryTime };
        return addMatchUpTimeItem({
            duplicateValues: false,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            disableNotice: disableNotice,
            matchUpId: matchUpId,
            timeItem: timeItem,
        });
    }
    else {
        return { error: INVALID_START_TIME };
    }
}
function addMatchUpEndTime(_a) {
    var _b;
    var _c = _a.validateTimeSeries, validateTimeSeries = _c === void 0 ? true : _c, removePriorValues = _a.removePriorValues, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, disableNotice = _a.disableNotice, matchUpId = _a.matchUpId, endTime = _a.endTime, event = _a.event;
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    if (!validTimeValue(endTime))
        return { error: INVALID_TIME };
    var matchUp = findDrawMatchUp({ drawDefinition: drawDefinition, event: event, matchUpId: matchUpId }).matchUp;
    var scheduledDate = scheduledMatchUpDate({ matchUp: matchUp }).scheduledDate;
    var timeItems = (_b = matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) !== null && _b !== void 0 ? _b : [];
    var latestRelevantTimeValue = timeItems
        .filter(function (timeItem) {
        return [START_TIME, RESUME_TIME, STOP_TIME].includes(timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType);
    })
        .map(function (timeItem) { return timeDate(timeItem.itemValue, scheduledDate); })
        .reduce(function (latest, timeValue) {
        return !latest || timeValue > latest ? timeValue : latest;
    }, undefined);
    // END_TIME must be after any START_TIMEs, STOP_TIMEs, RESUME_TIMEs
    if (!validateTimeSeries ||
        !latestRelevantTimeValue ||
        timeDate(endTime, scheduledDate) > latestRelevantTimeValue) {
        // there can be only one END_TIME; if a prior END_TIME exists, remove it
        if (matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) {
            matchUp.timeItems = matchUp.timeItems.filter(function (timeItem) { return timeItem.itemType !== END_TIME; });
        }
        // All times stored as military time
        var militaryTime = convertTime(endTime, true, true);
        var timeItem = { itemType: END_TIME, itemValue: militaryTime };
        return addMatchUpTimeItem({
            duplicateValues: false,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            disableNotice: disableNotice,
            matchUpId: matchUpId,
            timeItem: timeItem,
        });
    }
    else {
        return { error: INVALID_END_TIME };
    }
}
function addMatchUpStopTime(_a) {
    var _b;
    var removePriorValues = _a.removePriorValues, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, disableNotice = _a.disableNotice, matchUpId = _a.matchUpId, stopTime = _a.stopTime, event = _a.event;
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    if (!validTimeValue(stopTime))
        return { error: INVALID_TIME };
    var matchUp = findDrawMatchUp({ drawDefinition: drawDefinition, event: event, matchUpId: matchUpId }).matchUp;
    var scheduledDate = scheduledMatchUpDate({ matchUp: matchUp }).scheduledDate;
    var timeItems = (_b = matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) !== null && _b !== void 0 ? _b : [];
    // can't add a STOP_TIME if the matchUp is not STARTED or RESUMED, or has START_TIME
    // if latest relevaant timeItem is a STOP_TIME then overwrite
    var hasEndTime = timeItems.reduce(function (hasEndTime, timeItem) {
        return timeItem.itemType === END_TIME || hasEndTime;
    }, undefined);
    if (hasEndTime)
        return { error: EXISTING_END_TIME };
    var relevantTimeItems = timeItems
        .filter(function (timeItem) {
        return [START_TIME, RESUME_TIME, STOP_TIME].includes(timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType);
    })
        .sort(function (a, b) {
        return timeDate(a.itemValue, scheduledDate) -
            timeDate(b.itemValue, scheduledDate);
    });
    var lastRelevantTimeItem = relevantTimeItems[relevantTimeItems.length - 1];
    var lastRelevantTimeItemIsStop = lastRelevantTimeItem && lastRelevantTimeItem.itemType === STOP_TIME;
    var latestRelevantTimeValue = relevantTimeItems
        .filter(function (timeItem) {
        return !lastRelevantTimeItemIsStop ||
            timeItem.createdAt !== lastRelevantTimeItem.createdAt;
    })
        .map(function (timeItem) { return timeDate(timeItem.itemValue, scheduledDate); })
        .reduce(function (latest, timeValue) {
        return !latest || timeValue > latest ? timeValue : latest;
    }, undefined);
    if (timeDate(stopTime, scheduledDate) > latestRelevantTimeValue) {
        if ((matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) && lastRelevantTimeItemIsStop) {
            var targetTimeStamp_1 = lastRelevantTimeItem.createdAt;
            matchUp.timeItems = matchUp.timeItems.filter(function (timeItem) { return timeItem.createdAt !== targetTimeStamp_1; });
        }
        // All times stored as military time
        var militaryTime = convertTime(stopTime, true, true);
        var timeItem = {
            itemValue: militaryTime,
            itemType: STOP_TIME,
        };
        return addMatchUpTimeItem({
            duplicateValues: true,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            disableNotice: disableNotice,
            matchUpId: matchUpId,
            timeItem: timeItem,
        });
    }
    else {
        return { error: INVALID_STOP_TIME };
    }
}
function addMatchUpResumeTime(_a) {
    var _b;
    var removePriorValues = _a.removePriorValues, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, disableNotice = _a.disableNotice, resumeTime = _a.resumeTime, matchUpId = _a.matchUpId, event = _a.event;
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    if (!validTimeValue(resumeTime))
        return { error: INVALID_TIME };
    var matchUp = findDrawMatchUp({ drawDefinition: drawDefinition, event: event, matchUpId: matchUpId }).matchUp;
    var scheduledDate = scheduledMatchUpDate({ matchUp: matchUp }).scheduledDate;
    var timeItems = (_b = matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) !== null && _b !== void 0 ? _b : [];
    // can't add a RESUME_TIME if the matchUp is not STOPPED, or if it has ENDED
    // if latest relevaant timeItem is a RESUME_TIME then overwrite
    var hasEndTime = timeItems.reduce(function (hasEndTime, timeItem) {
        return timeItem.itemType === END_TIME || hasEndTime;
    }, undefined);
    if (hasEndTime)
        return { error: EXISTING_END_TIME };
    var relevantTimeItems = timeItems
        .filter(function (timeItem) {
        return [START_TIME, RESUME_TIME, STOP_TIME].includes(timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType);
    })
        .sort(function (a, b) {
        return timeDate(a.itemValue, scheduledDate) -
            timeDate(b.itemValue, scheduledDate);
    });
    var lastRelevantTimeItem = relevantTimeItems[relevantTimeItems.length - 1];
    var lastRelevantTimeItemIsResume = lastRelevantTimeItem && lastRelevantTimeItem.itemType === RESUME_TIME;
    var latestRelevantTimeValue = relevantTimeItems
        .filter(function (timeItem) {
        return !lastRelevantTimeItemIsResume ||
            timeItem.createdAt !== lastRelevantTimeItem.createdAt;
    })
        .map(function (timeItem) { return timeDate(timeItem.itemValue, scheduledDate); })
        .reduce(function (latest, timeValue) {
        return !latest || timeValue > latest ? timeValue : latest;
    }, undefined);
    if (timeDate(resumeTime, scheduledDate) > latestRelevantTimeValue) {
        if ((matchUp === null || matchUp === void 0 ? void 0 : matchUp.timeItems) && lastRelevantTimeItemIsResume) {
            var targetTimeStamp_2 = lastRelevantTimeItem.createdAt;
            matchUp.timeItems = matchUp.timeItems.filter(function (timeItem) { return timeItem.createdAt !== targetTimeStamp_2; });
        }
        // All times stored as military time
        var militaryTime = convertTime(resumeTime, true, true);
        var timeItem = {
            itemValue: militaryTime,
            itemType: RESUME_TIME,
        };
        return addMatchUpTimeItem({
            duplicateValues: true,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            disableNotice: disableNotice,
            matchUpId: matchUpId,
            timeItem: timeItem,
        });
    }
    else {
        return { error: INVALID_RESUME_TIME };
    }
}

/**
 * for FMLC 2nd round matchUps test whether it if a first loss for both participants
 */
function swapWinnerLoser(params) {
    var _a;
    var tournamentRecord = params.tournamentRecord, inContextMatchUp = params.inContextMatchUp, structure = params.structure, drawDefinition = params.drawDefinition;
    var matchUpRoundNumber = inContextMatchUp.roundNumber;
    var existingWinnerSide = inContextMatchUp.sides.find(function (side) { return side.sideNumber === inContextMatchUp.winningSide; });
    var existingLoserSide = inContextMatchUp.sides.find(function (side) { return side.sideNumber !== inContextMatchUp.winningSide; });
    var existingWinnerDrawPosition = existingWinnerSide.drawPosition, existingWinnerParticipantId = existingWinnerSide.participantId;
    var existingLoserDrawPosition = existingLoserSide.drawPosition, existingLoserParticipantId = existingLoserSide.participantId;
    var stack = 'swapWinnerLoser';
    var matchUps = getAllStructureMatchUps(params).matchUps;
    var existingWinnerSubsequentMatchUps = matchUps.filter(function (_a) {
        var drawPositions = _a.drawPositions, roundNumber = _a.roundNumber;
        return (drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(existingWinnerDrawPosition)) &&
            roundNumber > matchUpRoundNumber;
    });
    if (getDevContext({ changeWinner: true }))
        console.log({ existingWinnerSubsequentMatchUps: existingWinnerSubsequentMatchUps });
    // replace new winningSide drawPosition in all subsequent matches in structure
    existingWinnerSubsequentMatchUps.forEach(function (matchUp) {
        var _a, _b;
        matchUp.drawPositions =
            ((_a = matchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.map(function (drawPosition) {
                return drawPosition === existingWinnerDrawPosition
                    ? existingLoserDrawPosition
                    : drawPosition;
            })) || [];
        modifyMatchUpNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            eventId: (_b = params.event) === null || _b === void 0 ? void 0 : _b.eventId,
            context: stack,
            drawDefinition: drawDefinition,
            matchUp: matchUp,
        });
    });
    var currentStage = structure.stage, currentStageSequence = structure.stageSequence;
    var subsequentStructureIds = drawDefinition.structures
        .filter(function (_a) {
        var stage = _a.stage, stageSequence = _a.stageSequence;
        return stage === currentStage && stageSequence > currentStageSequence;
    })
        .map(function (_a) {
        var structureId = _a.structureId;
        return structureId;
    });
    var _b = params.targetData.targetLinks, loserTargetLink = _b.loserTargetLink, winnerTargetLink = _b.winnerTargetLink;
    var targetStructureIds = [
        loserTargetLink === null || loserTargetLink === void 0 ? void 0 : loserTargetLink.target.structureId,
        (_a = winnerTargetLink === null || winnerTargetLink === void 0 ? void 0 : winnerTargetLink.target) === null || _a === void 0 ? void 0 : _a.structureId,
    ].filter(Boolean);
    // find target structures that are not part of current stage...
    // ... as well as any subsequent structures
    drawDefinition.structures
        .filter(function (_a) {
        var stage = _a.stage, structureId = _a.structureId;
        return stage !== currentStage && targetStructureIds.includes(structureId);
    })
        .forEach(function (_a) {
        var targetStage = _a.stage, targetStageSequence = _a.stageSequence, structureId = _a.structureId;
        if (!subsequentStructureIds.includes(structureId))
            subsequentStructureIds.push(structureId);
        drawDefinition.structures
            .filter(function (_a) {
            var stage = _a.stage, stageSequence = _a.stageSequence;
            return stage === targetStage && stageSequence > targetStageSequence;
        })
            .forEach(function (_a) {
            var structureId = _a.structureId;
            if (!subsequentStructureIds.includes(structureId))
                subsequentStructureIds.push(structureId);
        });
    });
    var subsequentStructures = drawDefinition.structures.filter(function (_a) {
        var structureId = _a.structureId;
        return subsequentStructureIds.includes(structureId);
    });
    // for each subsequent structure swap drawPosition assignments (where applicable)
    subsequentStructures.forEach(function (structure) {
        var positionAssignments = getPositionAssignments$1({ structure: structure }).positionAssignments;
        var existingWinnerAssignment = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (_a) {
            var participantId = _a.participantId;
            return participantId === existingWinnerParticipantId;
        });
        var existingLoserAssignment = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (_a) {
            var participantId = _a.participantId;
            return participantId === existingLoserParticipantId;
        });
        if (existingWinnerAssignment)
            existingWinnerAssignment.participantId = existingLoserParticipantId;
        if (existingLoserAssignment)
            existingLoserAssignment.participantId = existingWinnerParticipantId;
    });
    // apply new winningSide and any score updates
    return modifyMatchUpScore(params);
}

function analyzeScore(_a) {
    var _b;
    var existingMatchUpStatus = _a.existingMatchUpStatus, matchUpFormat = _a.matchUpFormat, matchUpStatus = _a.matchUpStatus, winningSide = _a.winningSide, score = _a.score;
    var sets = (_b = score === null || score === void 0 ? void 0 : score.sets) !== null && _b !== void 0 ? _b : [];
    var completedSets = (sets === null || sets === void 0 ? void 0 : sets.filter(function (set) { return set === null || set === void 0 ? void 0 : set.winningSide; })) || [];
    var setsWinCounts = completedSets.reduce(function (counts, set) {
        var winningSide = set.winningSide;
        if (!winningSide)
            return counts;
        var winningSideIndex = winningSide - 1;
        counts[winningSideIndex]++;
        return counts;
    }, [0, 0]);
    var matchUpWinningSideIndex = winningSide ? winningSide - 1 : undefined;
    var matchUpLosingSideIndex = matchUpWinningSideIndex !== undefined
        ? 1 - matchUpWinningSideIndex
        : undefined;
    var winningSideSetsCount = matchUpWinningSideIndex !== undefined &&
        setsWinCounts[matchUpWinningSideIndex];
    var losingSideSetsCount = matchUpLosingSideIndex !== undefined &&
        setsWinCounts[matchUpLosingSideIndex];
    var matchUpScoringFormat = matchUpFormat ? parse(matchUpFormat) : undefined;
    var maxSetsCount = Math.max.apply(Math, __spreadArray([], __read(setsWinCounts), false));
    var maxSetsInstances = instanceCount(setsWinCounts)[maxSetsCount];
    var bestOf = matchUpScoringFormat === null || matchUpScoringFormat === void 0 ? void 0 : matchUpScoringFormat.bestOf;
    var setsToWin = (bestOf && Math.ceil(bestOf / 2)) || 1;
    var relevantMatchUpStatus = matchUpStatus !== null && matchUpStatus !== void 0 ? matchUpStatus : existingMatchUpStatus;
    var irregularEnding = relevantMatchUpStatus &&
        [DEFAULTED, RETIRED$1, WALKOVER$2].includes(relevantMatchUpStatus);
    var validSets = !matchUpScoringFormat ||
        !sets.length ||
        sets.every(function (set, i) {
            var setNumber = i + 1;
            var isFinalSet = setNumber === bestOf;
            var isLastSet = setNumber === sets.length;
            var side1Score = set.side1Score, side2Score = set.side2Score, side1TiebreakScore = set.side1TiebreakScore, side2TiebreakScore = set.side2TiebreakScore, setWinningSide = set.winningSide;
            var maxSetScore = Math.max(side1Score !== null && side1Score !== void 0 ? side1Score : 0, side2Score !== null && side2Score !== void 0 ? side2Score : 0);
            var hasTiebreak = side1TiebreakScore !== null && side1TiebreakScore !== void 0 ? side1TiebreakScore : side2TiebreakScore;
            var finalSetFormat = matchUpScoringFormat.finalSetFormat, setFormat = matchUpScoringFormat.setFormat;
            var setValues = isFinalSet ? finalSetFormat || setFormat : setFormat;
            if (hasTiebreak) {
                var _a = (setValues === null || setValues === void 0 ? void 0 : setValues.tiebreakFormat) || {}, tiebreakTo = _a.tiebreakTo, NoAD = _a.NoAD;
                var maxTiebreakScore = Math.max(side1TiebreakScore !== null && side1TiebreakScore !== void 0 ? side1TiebreakScore : 0, side2TiebreakScore !== null && side2TiebreakScore !== void 0 ? side2TiebreakScore : 0);
                if (NoAD && maxTiebreakScore > tiebreakTo)
                    return false;
                if (maxTiebreakScore < tiebreakTo && setWinningSide) {
                    if (isLastSet && !irregularEnding)
                        return false;
                    if (!isLastSet)
                        return false;
                }
            }
            if (!setValues.setTo)
                return true;
            var excessiveSetScore = !setValues.noTiebreak && maxSetScore > setValues.setTo + 1;
            return !excessiveSetScore;
        });
    var calculatedWinningSide = ((!matchUpFormat || maxSetsCount === setsToWin) &&
        maxSetsInstances === 1 &&
        setsWinCounts.indexOf(maxSetsCount) + 1) ||
        undefined;
    var valid = validSets &&
        ((winningSide &&
            winningSideSetsCount > losingSideSetsCount &&
            winningSide === calculatedWinningSide) ||
            (!winningSide && !calculatedWinningSide) ||
            irregularEnding);
    return { valid: valid };
}

function validateScore(_a) {
    var e_1, _b;
    var existingMatchUpStatus = _a.existingMatchUpStatus, matchUpFormat = _a.matchUpFormat, matchUpStatus = _a.matchUpStatus, winningSide = _a.winningSide, score = _a.score;
    if (typeof score !== 'object')
        return { error: INVALID_VALUES };
    var sets = score.sets, scoreStringSide1 = score.scoreStringSide1, scoreStringSide2 = score.scoreStringSide2;
    var info = 'scoreString must be a string!';
    if (scoreStringSide1 !== undefined && typeof scoreStringSide1 !== 'string')
        return { error: INVALID_VALUES, info: info };
    if (scoreStringSide2 !== undefined && typeof scoreStringSide2 !== 'string')
        return { error: INVALID_VALUES, info: info };
    if (sets !== undefined && !Array.isArray(sets))
        return { error: INVALID_VALUES, info: mustBeAnArray('sets') };
    if (sets === null || sets === void 0 ? void 0 : sets.length) {
        var setNumbers = sets.map(function (set) { return set === null || set === void 0 ? void 0 : set.setNumber; }).filter(Boolean);
        if (setNumbers.length !== unique(setNumbers).length)
            return { error: INVALID_VALUES, info: 'setNumbers not unique' };
        try {
            for (var sets_1 = __values(sets), sets_1_1 = sets_1.next(); !sets_1_1.done; sets_1_1 = sets_1.next()) {
                var set = sets_1_1.value;
                var side1Score = set.side1Score, side2Score = set.side2Score, side1TiebreakScore = set.side1TiebreakScore, side2TiebreakScore = set.side2TiebreakScore, side1PointScore = set.side1PointScore, side2PointScore = set.side2PointScore, winningSide_1 = set.winningSide, setNumber = set.setNumber;
                // ensure that if one side has a numeric value then both sides should have a numeric value
                var numericValuePairs = [
                    [side1Score, side2Score],
                    [side1TiebreakScore, side2TiebreakScore],
                    [side1PointScore, side2PointScore],
                ]
                    .filter(function (pair) { return pair.some(function (value) { return value !== undefined; }); })
                    .every(function (pair) {
                    return pair.every(function (numericValue) { return isConvertableInteger(numericValue); });
                });
                if (!numericValuePairs) {
                    return { error: INVALID_VALUES, info: 'non-numeric values' };
                }
                var numericValues = [setNumber, winningSide_1]
                    .filter(function (value) { return value !== undefined; })
                    .every(function (numericValue) { return isConvertableInteger(numericValue); });
                if (!numericValues) {
                    return { error: INVALID_VALUES, info: 'non-numeric values' };
                }
                if (winningSide_1 && ![1, 2].includes(winningSide_1))
                    return { error: INVALID_VALUES, info: 'winningSide must be 1 or 2' };
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sets_1_1 && !sets_1_1.done && (_b = sets_1.return)) _b.call(sets_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var isValidScore = analyzeScore({
            existingMatchUpStatus: existingMatchUpStatus,
            matchUpStatus: matchUpStatus,
            matchUpFormat: matchUpFormat,
            winningSide: winningSide,
            score: score,
        }).valid;
        if (!isValidScore) {
            return {
                error: INVALID_SCORE,
                info: 'score is invalid for matchUpFormat or winningSide does not match calculated winningSide',
            };
        }
    }
    return { valid: true };
}

function setMatchUpState(params) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    var stack = 'setMatchUpStatus';
    // always clear score if DOUBLE_WALKOVER or WALKOVER
    if (params.matchUpStatus &&
        [WALKOVER$2, DOUBLE_WALKOVER].includes(params.matchUpStatus))
        params.score = undefined;
    // matchUpStatus in params is the new status
    // winningSide in params is new winningSide
    var allowChangePropagation = params.allowChangePropagation, disableScoreValidation = params.disableScoreValidation, tournamentRecords = params.tournamentRecords, tournamentRecord = params.tournamentRecord, disableAutoCalc = params.disableAutoCalc, enableAutoCalc = params.enableAutoCalc, drawDefinition = params.drawDefinition, matchUpStatus = params.matchUpStatus, winningSide = params.winningSide, matchUpId = params.matchUpId, event = params.event, score = params.score;
    // Check for missing parameters ---------------------------------------------
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    // Check matchUpStatus, matchUpStatus/winningSide validity ------------------
    if (matchUpStatus &&
        [CANCELLED$1, INCOMPLETE, ABANDONED$1, TO_BE_PLAYED].includes(matchUpStatus) &&
        winningSide)
        return { error: INVALID_VALUES, winningSide: winningSide, matchUpStatus: matchUpStatus };
    if (!__spreadArray([undefined], __read(validMatchUpStatuses), false).includes(matchUpStatus)) {
        return decorateResult({
            result: { error: INVALID_MATCHUP_STATUS },
            info: 'matchUpStatus does not exist',
            stack: 'setMatchUpStatus',
        });
    }
    // Get map of all drawMatchUps and inContextDrawMatchUps ---------------------
    var matchUpsMap = getMatchUpsMap({ drawDefinition: drawDefinition });
    var inContextDrawMatchUps = getAllDrawMatchUps({
        nextMatchUps: true,
        inContext: true,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        event: event,
    }).matchUps;
    // Find target matchUp ------------------------------------------------------
    var matchUp = matchUpsMap.drawMatchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
    var inContextMatchUp = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
    if (!matchUp || !inContextDrawMatchUps)
        return { error: MATCHUP_NOT_FOUND };
    if ((matchUp.winningSide || winningSide) && matchUpStatus === BYE) {
        return {
            context: 'Cannot have Bye with winningSide',
            error: INCOMPATIBLE_MATCHUP_STATUS,
            matchUpStatus: matchUpStatus,
        };
    }
    var structureId = inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.structureId;
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    // Check validity of matchUpStatus considering assigned drawPositions -------
    var assignedDrawPositions = (_a = inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.drawPositions) === null || _a === void 0 ? void 0 : _a.filter(Boolean);
    var dualWinningSideChange;
    if (matchUp.matchUpType === TEAM) {
        if (disableAutoCalc) {
            addExtension({
                extension: { name: DISABLE_AUTO_CALC, value: true },
                element: matchUp,
            });
        }
        else if (enableAutoCalc) {
            var existingDualMatchUpWinningSide = matchUp.winningSide;
            removeExtension({ name: DISABLE_AUTO_CALC, element: matchUp });
            var _j = generateTieMatchUpScore({
                drawDefinition: drawDefinition,
                matchUpsMap: matchUpsMap,
                structure: structure,
                matchUp: matchUp,
                event: event,
            }), projectedWinningSide = _j.winningSide, scoreStringSide1 = _j.scoreStringSide1, scoreStringSide2 = _j.scoreStringSide2, set = _j.set;
            var score_1 = {
                scoreStringSide1: scoreStringSide1,
                scoreStringSide2: scoreStringSide2,
                sets: set ? [set] : [],
            };
            dualWinningSideChange =
                projectedWinningSide !== existingDualMatchUpWinningSide;
            // setting these parameters will enable noDownStreamDependencies to attemptToSetWinningSide
            Object.assign(params, {
                winningSide: projectedWinningSide,
                dualWinningSideChange: dualWinningSideChange,
                projectedWinningSide: projectedWinningSide,
                score: score_1,
            });
        }
        ensureSideLineUps({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            inContextDualMatchUp: inContextMatchUp,
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            drawDefinition: drawDefinition,
            dualMatchUp: matchUp,
        });
    }
    if (matchUp.matchUpType === TEAM &&
        matchUpStatus &&
        [
            AWAITING_RESULT,
            // for the following statuses should all tieMatchUp results be removed?
            // CANCELLED,
            // DOUBLE_WALKOVER,
            // WALKOVER,
        ].includes(matchUpStatus)) {
        return {
            error: INVALID_VALUES,
            info: 'Not supported for matchUpType: TEAM',
        };
    }
    var matchUpTieId = inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.matchUpTieId;
    // Get winner/loser position targets ----------------------------------------
    var targetData = positionTargets({
        matchUpId: matchUpTieId || matchUpId, // get targets for TEAM matchUp if tieMatchUp
        inContextDrawMatchUps: inContextDrawMatchUps,
        drawDefinition: drawDefinition,
    });
    if (score && matchUp.matchUpType !== TEAM && !disableScoreValidation) {
        var matchUpFormat = (_d = (_c = (_b = matchUp.matchUpFormat) !== null && _b !== void 0 ? _b : structure === null || structure === void 0 ? void 0 : structure.matchUpFormat) !== null && _c !== void 0 ? _c : drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.matchUpFormat) !== null && _d !== void 0 ? _d : event === null || event === void 0 ? void 0 : event.matchUpFormat;
        var result_1 = validateScore({
            existingMatchUpStatus: matchUp.matchUpStatus,
            matchUpFormat: matchUpFormat,
            matchUpStatus: matchUpStatus,
            winningSide: winningSide,
            score: score,
        });
        if (result_1.error) {
            return result_1;
        }
    }
    var positionAssignments = !(matchUp === null || matchUp === void 0 ? void 0 : matchUp.sides)
        ? getPositionAssignments$1({
            drawDefinition: drawDefinition,
            structureId: structureId,
        }).positionAssignments
        : [];
    var bothSideParticipants = ((_e = matchUp.sides) === null || _e === void 0 ? void 0 : _e.map(function (side) { return side.participantId; }).filter(Boolean).length) ===
        2 ||
        ((assignedDrawPositions === null || assignedDrawPositions === void 0 ? void 0 : assignedDrawPositions.length) === 2 &&
            (positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) {
                return assignedDrawPositions.includes(assignment.drawPosition);
            }).every(function (assignment) { return assignment.participantId; })));
    if (matchUpStatus &&
        particicipantsRequiredMatchUpStatuses.includes(matchUpStatus) &&
        !bothSideParticipants) {
        return decorateResult({
            info: 'present in participantRequiredMatchUpStatuses',
            context: { matchUpStatus: matchUpStatus, bothSideParticipants: bothSideParticipants },
            result: { error: INVALID_MATCHUP_STATUS },
        });
    }
    var appliedPolicies = (_g = (_f = getAppliedPolicies({
        policyTypes: [POLICY_TYPE_PROGRESSION],
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        event: event,
    })) === null || _f === void 0 ? void 0 : _f.appliedPolicies) !== null && _g !== void 0 ? _g : {};
    if (typeof params.policyDefinitions === 'object') {
        Object.assign(appliedPolicies, params.policyDefinitions);
    }
    var qualifyingMatch = (inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.stage) === QUALIFYING &&
        inContextMatchUp.finishingRound === 1;
    var qualifierAdvancing = qualifyingMatch && winningSide;
    var removingQualifier = qualifyingMatch && // oop
        matchUp.winningSide &&
        !winningSide && // function calls last
        (!params.matchUpStatus ||
            (params.matchUpStatus &&
                isNonDirectingMatchUpStatus({
                    matchUpStatus: params.matchUpStatus,
                }))) &&
        (!params.outcome || !checkScoreHasValue({ outcome: params.outcome }));
    var qualifierChanging = qualifierAdvancing && // oop
        winningSide !== matchUp.winningSide &&
        matchUp.winningSide;
    Object.assign(params, {
        inContextDrawMatchUps: inContextDrawMatchUps,
        qualifierAdvancing: qualifierAdvancing,
        qualifierChanging: qualifierChanging,
        removingQualifier: removingQualifier,
        inContextMatchUp: inContextMatchUp,
        appliedPolicies: appliedPolicies,
        matchUpTieId: matchUpTieId,
        matchUpsMap: matchUpsMap,
        targetData: targetData,
        structure: structure,
        matchUp: matchUp,
    });
    if (matchUpTieId) {
        var dualMatchUp = findDrawMatchUp({
            matchUpId: matchUpTieId,
            inContext: true,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
            event: event,
        }).matchUp;
        if (dualMatchUp) {
            var tieFormat = (_h = resolveTieFormat({
                matchUp: dualMatchUp,
                drawDefinition: drawDefinition,
                structure: structure,
                event: event,
            })) === null || _h === void 0 ? void 0 : _h.tieFormat;
            var projectedWinningSide = getProjectedDualWinningSide({
                drawDefinition: drawDefinition,
                matchUpStatus: matchUpStatus,
                dualMatchUp: dualMatchUp,
                matchUpsMap: matchUpsMap,
                winningSide: winningSide,
                tieFormat: tieFormat,
                structure: structure,
                matchUp: matchUp,
                event: event,
                score: score,
            }).projectedWinningSide;
            var existingDualMatchUpWinningSide = dualMatchUp.winningSide;
            dualWinningSideChange =
                projectedWinningSide !== existingDualMatchUpWinningSide;
            Object.assign(params, {
                isCollectionMatchUp: true,
                dualWinningSideChange: dualWinningSideChange,
                projectedWinningSide: projectedWinningSide,
                matchUpTieId: matchUpTieId,
                dualMatchUp: dualMatchUp,
                tieFormat: tieFormat,
            });
        }
    }
    // with propagating winningSide changes, activeDownstream does not apply to collection matchUps
    var activeDownstream = isActiveDownstream(params);
    var directingMatchUpStatus = isDirectingMatchUpStatus({ matchUpStatus: matchUpStatus });
    if (!matchUpTieId) {
        if (activeDownstream &&
            !winningSide &&
            ((matchUpStatus && isNonDirectingMatchUpStatus({ matchUpStatus: matchUpStatus })) ||
                (matchUpStatus &&
                    [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUpStatus)))) {
            return {
                error: INCOMPATIBLE_MATCHUP_STATUS,
                activeDownstream: activeDownstream,
                winningSide: winningSide,
            };
        }
        if (winningSide &&
            winningSide === matchUp.winningSide &&
            matchUpStatus &&
            !directingMatchUpStatus) {
            return {
                context: 'winningSide must include directing matchUpStatus',
                error: INCOMPATIBLE_MATCHUP_STATUS,
                directingMatchUpStatus: directingMatchUpStatus,
                matchUpStatus: matchUpStatus,
            };
        }
    }
    // Add scheduling information to matchUp ------------------------------------
    var schedule = params.schedule;
    if (schedule) {
        var result_2 = addMatchUpScheduleItems({
            disableNotice: true,
            tournamentRecords: tournamentRecords,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
            schedule: schedule,
        });
        if (result_2.error) {
            return result_2;
        }
    }
    var validWinningSideSwap = matchUp.matchUpType !== TEAM &&
        !dualWinningSideChange &&
        winningSide &&
        matchUp.winningSide &&
        matchUp.winningSide !== winningSide;
    if (allowChangePropagation &&
        validWinningSideSwap &&
        matchUp.roundPosition // not round robin if matchUp.roundPosition
    ) {
        return swapWinnerLoser(params);
    }
    var matchUpWinner = (winningSide && !matchUpTieId) || params.projectedWinningSide;
    pushGlobalLog({
        method: stack,
        activeDownstream: activeDownstream,
        matchUpWinner: matchUpWinner,
        winningSide: winningSide,
    });
    var result = (!activeDownstream && noDownstreamDependencies(params)) ||
        (matchUpWinner && winningSideWithDownstreamDependencies(params)) ||
        (directingMatchUpStatus && applyMatchUpValues(params)) || {
        error: NO_VALID_ACTIONS,
    };
    return decorateResult({ result: result, stack: stack });
}
function winningSideWithDownstreamDependencies(params) {
    var matchUp = params.matchUp, winningSide = params.winningSide, matchUpTieId = params.matchUpTieId, dualWinningSideChange = params.dualWinningSideChange;
    if (winningSide === matchUp.winningSide ||
        (matchUpTieId && !dualWinningSideChange)) {
        return applyMatchUpValues(params);
    }
    else {
        return decorateResult({
            stack: 'winningSideWithDownstreamDependencies',
            result: { error: CANNOT_CHANGE_WINNING_SIDE },
            context: { winningSide: winningSide, matchUp: matchUp },
        });
    }
}
function applyMatchUpValues(params) {
    var tournamentRecord = params.tournamentRecord, matchUp = params.matchUp, event = params.event;
    var removeWinningSide = params.isCollectionMatchUp &&
        matchUp.winningSide &&
        !params.winningSide &&
        !checkScoreHasValue({ score: params.score });
    var newMatchUpStatus = params.isCollectionMatchUp
        ? params.matchUpStatus || (removeWinningSide && TO_BE_PLAYED) || COMPLETED$1
        : params.matchUpStatus || COMPLETED$1;
    var removeScore = params.removeScore ||
        ([CANCELLED$1, WALKOVER$2].includes(newMatchUpStatus) &&
            ![INCOMPLETE, ABANDONED$1].includes(newMatchUpStatus));
    var result = modifyMatchUpScore(__assign(__assign({}, params), { matchUpStatus: newMatchUpStatus, removeWinningSide: removeWinningSide, removeScore: removeScore }));
    if (result.error)
        return result;
    // recalculate dualMatchUp score if isCollectionMatchUp
    if (params.isCollectionMatchUp) {
        var matchUpTieId = params.matchUpTieId, drawDefinition = params.drawDefinition, matchUpsMap = params.matchUpsMap;
        var tieMatchUpResult = updateTieMatchUpScore({
            matchUpId: matchUpTieId,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
            event: event,
        });
        if (tieMatchUpResult.error)
            return tieMatchUpResult;
        Object.assign(result, { tieMatchUpResult: tieMatchUpResult });
    }
    return result;
}

function enableTieAutoCalc(_a) {
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, matchUpId = _a.matchUpId, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var matchUp = findDrawMatchUp({
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
        event: event,
    }).matchUp;
    if ((matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpType) !== TEAM_MATCHUP)
        return { error: INVALID_MATCHUP };
    return setMatchUpState({
        enableAutoCalc: true,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
        event: event,
    });
}

function renameStructures(_a) {
    var e_1, _b;
    var drawDefinition = _a.drawDefinition, structureDetails = _a.structureDetails;
    if (!Array.isArray(structureDetails))
        return { error: INVALID_VALUES };
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var detailMap = Object.assign.apply(Object, __spreadArray([{}], __read(structureDetails
        .map(function (detail) {
        var _a;
        if (!isObject(detail))
            return;
        var _b = detail || {}, structureId = _b.structureId, structureName = _b.structureName;
        if (!structureId || !structureName)
            return;
        return _a = {}, _a[structureId] = structureName, _a;
    })
        .filter(Boolean)), false));
    if (!Object.values(detailMap).length) {
        return { error: MISSING_VALUE };
    }
    try {
        for (var _c = __values(drawDefinition.structures || []), _d = _c.next(); !_d.done; _d = _c.next()) {
            var structure = _d.value;
            var structureName = detailMap[structure.structureId];
            if (structureName) {
                structure.structureName = structureName;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}

/**
 *
 * @param {object} orderedDrawIdsMap - required - mapping of ALL present drawIds => { [drawId]: drawOrder }
 */
function updateDrawIdsOrder(_a) {
    var _b, _c;
    var event = _a.event, orderedDrawIdsMap = _a.orderedDrawIdsMap;
    if (typeof event !== 'object')
        return { error: MISSING_EVENT };
    if (!orderedDrawIdsMap)
        return { error: MISSING_VALUE, info: 'Missing drawIdsOrderMap' };
    if (typeof orderedDrawIdsMap !== 'object')
        return {
            error: INVALID_VALUES,
            info: 'orderedDrawIdsMap must be an object',
        };
    var drawOrders = Object.values(orderedDrawIdsMap);
    var validDrawOrders = drawOrders.every(function (drawOrder) { return !isNaN(drawOrder); });
    if (!validDrawOrders)
        return { error: INVALID_VALUES, info: 'drawOrder must be numeric' };
    if (unique(drawOrders).length !== drawOrders.length)
        return {
            error: INVALID_VALUES,
            info: 'drawOrder values must be unique',
        };
    if ((_b = event.drawDefinitions) === null || _b === void 0 ? void 0 : _b.length) {
        var drawIds = (event.drawDefinitions || []).map(function (_a) {
            var drawId = _a.drawId;
            return drawId;
        });
        var orderedDrawIds = Object.keys(orderedDrawIdsMap);
        if ((orderedDrawIds === null || orderedDrawIds === void 0 ? void 0 : orderedDrawIds.length) &&
            intersection(drawIds, orderedDrawIds).length !== drawIds.length)
            return { error: INVALID_VALUES, info: 'Missing drawIds' };
        event.drawDefinitions.forEach(function (drawDefinition) {
            drawDefinition.drawOrder = orderedDrawIdsMap[drawDefinition.drawId];
        });
    }
    var flightProfile = getFlightProfile({ event: event }).flightProfile;
    (_c = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _c === void 0 ? void 0 : _c.forEach(function (flight) {
        flight.flightNumber = orderedDrawIdsMap[flight.drawId];
    });
    return __assign({}, SUCCESS);
}

function refreshEventDrawOrder(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    var flightProfile = getFlightProfile({ event: event }).flightProfile;
    // if there is a flightProfile, derive order from that, otherwise use drawDefinitions array
    var orderedDrawIdsMap = ((flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) && Object.assign.apply(Object, __spreadArray([{}], __read(flightProfile.flights
        .sort(function (a, b) { return a.flightNumber - b.flightNumber; })
        .map(function (flight, i) {
        var _a;
        return (_a = {}, _a[flight.drawId] = i + 1, _a);
    })), false))) ||
        (((_b = event.drawDefinitions) === null || _b === void 0 ? void 0 : _b.length) && Object.assign.apply(Object, __spreadArray([{}], __read(event.drawDefinitions
            .sort(function (a, b) { return a.drawOrder - b.drawOrder; })
            .map(function (drawDefinition, i) {
            var _a;
            return (_a = {}, _a[drawDefinition.drawId] = i + 1, _a);
        })), false))) ||
        undefined;
    return orderedDrawIdsMap
        ? updateDrawIdsOrder({ event: event, orderedDrawIdsMap: orderedDrawIdsMap })
        : __assign({}, SUCCESS);
}

function deleteFlightAndFlightDraw(_a) {
    var _b, _c;
    var _d = _a.autoPublish, autoPublish = _d === void 0 ? true : _d, tournamentRecord = _a.tournamentRecord, auditData = _a.auditData, drawId = _a.drawId, event = _a.event, force = _a.force;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!drawId)
        return { error: MISSING_DRAW_ID };
    if (!event)
        return { error: MISSING_EVENT };
    var flightProfile = getFlightProfile({ event: event }).flightProfile;
    if (flightProfile) {
        var flight = (_b = flightProfile.flights) === null || _b === void 0 ? void 0 : _b.find(function (flight) { return flight.drawId === drawId; });
        if (flight) {
            var flights = flightProfile.flights.filter(function (flight) {
                return flight.drawId !== drawId;
            });
            var extension = {
                name: FLIGHT_PROFILE,
                value: __assign(__assign({}, flightProfile), { flights: flights }),
            };
            addEventExtension({ event: event, extension: extension });
        }
    }
    var drawWasGenerated = (_c = event.drawDefinitions) === null || _c === void 0 ? void 0 : _c.find(function (drawDefinition) { return drawDefinition.drawId === drawId; });
    if (drawWasGenerated) {
        var result = deleteDrawDefinitions({
            drawIds: [drawId],
            eventId: event.eventId,
            tournamentRecord: tournamentRecord,
            autoPublish: autoPublish,
            auditData: auditData,
            event: event,
            force: force,
        });
        if (result.error)
            return result;
    }
    return refreshEventDrawOrder({ tournamentRecord: tournamentRecord, event: event });
}

function removeDelegatedOutcome(_a) {
    var drawDefinition = _a.drawDefinition, event = _a.event, matchUpId = _a.matchUpId;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    var matchUp = findDrawMatchUp({ drawDefinition: drawDefinition, event: event, matchUpId: matchUpId }).matchUp;
    if (!matchUp)
        return { error: MATCHUP_NOT_FOUND };
    return removeExtension({
        name: DELEGATED_OUTCOME,
        element: matchUp,
    });
}

function addDrawDefinitionTimeItem(_a) {
    var drawDefinition = _a.drawDefinition, timeItem = _a.timeItem;
    if (!drawDefinition)
        return { error: DRAW_DEFINITION_NOT_FOUND };
    if (!timeItem)
        return { error: MISSING_TIME_ITEM };
    var timeItemAttributes = timeItem && Object.keys(timeItem);
    var requiredAttributes = ['itemType', 'itemValue'];
    var validTimeItem = requiredAttributes.filter(function (attribute) {
        return timeItemAttributes.includes(attribute);
    }).length === requiredAttributes.length;
    if (!validTimeItem)
        return { error: INVALID_TIME_ITEM };
    if (!drawDefinition.timeItems)
        drawDefinition.timeItems = [];
    var createdAt = new Date().toISOString();
    Object.assign(timeItem, { createdAt: createdAt });
    drawDefinition.timeItems.push(timeItem);
    addDrawNotice({ drawDefinition: drawDefinition });
    return __assign({}, SUCCESS);
}

function removeStructure(_a) {
    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, structureId = _a.structureId, event = _a.event, force = _a.force;
    if (typeof structureId !== 'string')
        return { error: INVALID_VALUES };
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structureId)
        return { error: MISSING_STRUCTURE_ID };
    var structures = (_b = drawDefinition.structures) !== null && _b !== void 0 ? _b : [];
    var removedStructureIds = [];
    var structure = structures.find(function (structure) { return structure.structureId === structureId; });
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    // TODO: if structure being rmoved is qualifying structure, ensure no source structures have scored matchUps
    var structureMatchUps = getAllStructureMatchUps({ structure: structure }).matchUps;
    var scoresPresent = structureMatchUps.some(function (_a) {
        var score = _a.score;
        return checkScoreHasValue({ score: score });
    });
    if (scoresPresent) {
        var appliedPolicies = (_c = getAppliedPolicies({
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            structure: structure,
            event: event,
        })) === null || _c === void 0 ? void 0 : _c.appliedPolicies;
        var allowDeletionWithScoresPresent = force !== null && force !== void 0 ? force : (_e = (_d = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_SCORING]) === null || _d === void 0 ? void 0 : _d.allowDeletionWithScoresPresent) === null || _e === void 0 ? void 0 : _e.structures;
        if (!allowDeletionWithScoresPresent)
            return { error: SCORES_PRESENT };
    }
    var mainStageSequence1 = structures.find(function (_a) {
        var stage = _a.stage, stageSequence = _a.stageSequence;
        return stage === MAIN && stageSequence === 1;
    });
    var isMainStageSequence1 = structureId === (mainStageSequence1 === null || mainStageSequence1 === void 0 ? void 0 : mainStageSequence1.structureId);
    var qualifyingStructureIds = structures.filter(function (_a) {
        var stage = _a.stage;
        return stage === QUALIFYING;
    }).map(xa('structureId'));
    if (isMainStageSequence1 && !qualifyingStructureIds.length) {
        return { error: CANNOT_REMOVE_MAIN_STRUCTURE };
    }
    var structureIds = structures.map(xa('structureId'));
    var removedMatchUpIds = [];
    var getTargetedStructureIds = function (structureId) {
        var _a, _b;
        return (_b = (_a = drawDefinition.links) === null || _a === void 0 ? void 0 : _a.map(function (link) {
            return link.source.structureId === structureId &&
                link.target.structureId !== (mainStageSequence1 === null || mainStageSequence1 === void 0 ? void 0 : mainStageSequence1.structureId) &&
                link.target.structureId;
        }).filter(Boolean)) !== null && _b !== void 0 ? _b : [];
    };
    var getQualifyingSourceStructureIds = function (structureId) {
        var _a, _b;
        return (_b = (_a = drawDefinition.links) === null || _a === void 0 ? void 0 : _a.map(function (link) {
            return qualifyingStructureIds.includes(link.source.structureId) &&
                link.target.structureId === structureId &&
                link.source.structureId;
        }).filter(Boolean)) !== null && _b !== void 0 ? _b : [];
    };
    var isQualifyingStructure = qualifyingStructureIds.includes(structureId);
    var relatedStructureIdsMap = new Map();
    structureIds.forEach(function (id) {
        return relatedStructureIdsMap.set(id, isQualifyingStructure
            ? getQualifyingSourceStructureIds(id)
            : getTargetedStructureIds(id));
    });
    var idsToRemove = isMainStageSequence1 ? relatedStructureIdsMap.get(structureId) : [structureId];
    var _loop_1 = function () {
        var idBeingRemoved = idsToRemove.pop();
        var structure_1 = findStructure({
            structureId: idBeingRemoved,
            drawDefinition: drawDefinition,
        }).structure;
        var matchUps_1 = getAllStructureMatchUps({ structure: structure_1 }).matchUps;
        var matchUpIds = getMatchUpIds(matchUps_1);
        removedMatchUpIds.push.apply(removedMatchUpIds, __spreadArray([], __read(matchUpIds), false));
        drawDefinition.links =
            (_g = (_f = drawDefinition.links) === null || _f === void 0 ? void 0 : _f.filter(function (link) { return link.source.structureId !== idBeingRemoved && link.target.structureId !== idBeingRemoved; })) !== null && _g !== void 0 ? _g : [];
        if (!isMainStageSequence1 ||
            (isMainStageSequence1 && qualifyingStructureIds.length) ||
            idBeingRemoved !== structureId) {
            drawDefinition.structures = ((_h = drawDefinition.structures) !== null && _h !== void 0 ? _h : []).filter(function (structure) {
                if (idBeingRemoved && idBeingRemoved === structure.structureId)
                    removedStructureIds.push(idBeingRemoved);
                return structure.structureId !== idBeingRemoved;
            });
        }
        var targetedStructureIds = idBeingRemoved &&
            ((_j = relatedStructureIdsMap.get(idBeingRemoved)) === null || _j === void 0 ? void 0 : _j.filter(function (id) {
                // IMPORTANT: only delete MAIN stageSequence: 1 if specified to protect against DOUBLE_ELIMINATION scenario
                return id !== (mainStageSequence1 === null || mainStageSequence1 === void 0 ? void 0 : mainStageSequence1.structureId) || structureId === mainStageSequence1.structureId;
            }));
        if (targetedStructureIds === null || targetedStructureIds === void 0 ? void 0 : targetedStructureIds.length)
            idsToRemove.push.apply(idsToRemove, __spreadArray([], __read(targetedStructureIds), false));
    };
    while (idsToRemove === null || idsToRemove === void 0 ? void 0 : idsToRemove.length) {
        _loop_1();
    }
    // now get all remaining matchUps in the draw
    var matchUps = getAllDrawMatchUps({ drawDefinition: drawDefinition }).matchUps;
    matchUps === null || matchUps === void 0 ? void 0 : matchUps.forEach(function (matchUp) {
        if (matchUp.winnerMatchUpId && removedMatchUpIds.includes(matchUp.winnerMatchUpId)) {
            delete matchUp.winnerMatchUpId;
        }
        if (matchUp.loserMatchUpId && removedMatchUpIds.includes(matchUp.loserMatchUpId)) {
            delete matchUp.loserMatchUpId;
        }
    });
    // if this is MAIN stageSequence: 1 there must be qualifying, return to empty state
    if (isMainStageSequence1) {
        var mainStageSequence1MatchUpIds = (_l = ((_k = mainStageSequence1.matchUps) !== null && _k !== void 0 ? _k : [])) === null || _l === void 0 ? void 0 : _l.map(xa('matchUpId'));
        removedMatchUpIds.push.apply(removedMatchUpIds, __spreadArray([], __read(mainStageSequence1MatchUpIds), false));
        mainStageSequence1.positionAssignments = [];
        mainStageSequence1.seedAssignments = [];
        mainStageSequence1.matchUps = [];
        if (mainStageSequence1.extensions) {
            mainStageSequence1.extensions = [];
        }
    }
    isQualifyingStructure && resequenceStructures({ drawDefinition: drawDefinition });
    deleteMatchUpsNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        matchUpIds: removedMatchUpIds,
        action: 'removeStructure',
        eventId: event === null || event === void 0 ? void 0 : event.eventId,
        drawDefinition: drawDefinition,
    });
    modifyDrawNotice({ drawDefinition: drawDefinition, eventId: event === null || event === void 0 ? void 0 : event.eventId });
    return __assign(__assign({}, SUCCESS), { removedMatchUpIds: removedMatchUpIds, removedStructureIds: removedStructureIds });
}

function setStageDrawSize(_a) {
    var _b;
    var _c = _a.stageSequence, stageSequence = _c === void 0 ? 1 : _c, drawDefinition = _a.drawDefinition, drawSize = _a.drawSize, stage = _a.stage;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!stageExists({ drawDefinition: drawDefinition, stage: stage })) {
        return { error: INVALID_STAGE };
    }
    var directAcceptanceEntries = getStageDirectEntriesCount({
        drawDefinition: drawDefinition,
        stage: stage,
    });
    var qualifiersCount = getQualifiersCount({
        drawDefinition: drawDefinition,
        stageSequence: stageSequence,
        stage: stage,
    }).qualifiersCount;
    var totalStageDrawPositions = directAcceptanceEntries + qualifiersCount;
    if (drawSize < totalStageDrawPositions) {
        return {
            error: DRAW_SIZE_MISMATCH,
        };
    }
    var entryProfile = modifyEntryProfile({
        attributes: [(_b = {}, _b[stage] = { drawSize: drawSize }, _b)],
        drawDefinition: drawDefinition,
    }).entryProfile;
    modifyDrawNotice({ drawDefinition: drawDefinition });
    return __assign(__assign({}, SUCCESS), { entryProfile: entryProfile });
}
function setStageQualifiersCount(_a) {
    var _b;
    var _c = _a.qualifiersCount, qualifiersCount = _c === void 0 ? 0 : _c, drawDefinition = _a.drawDefinition, stage = _a.stage;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!stageExists({ drawDefinition: drawDefinition, stage: stage })) {
        return { error: INVALID_STAGE };
    }
    if (stage !== MAIN) {
        return {
            error: DRAW_SIZE_MISMATCH,
            info: 'qualifiersCount can only be set for main stage',
        };
    }
    modifyEntryProfile({
        attributes: [(_b = {}, _b[stage] = { qualifiersCount: qualifiersCount }, _b)],
        drawDefinition: drawDefinition,
    });
    modifyDrawNotice({ drawDefinition: drawDefinition });
    return __assign({}, SUCCESS);
}

function addVoluntaryConsolationStage$1(_a) {
    var drawDefinition = _a.drawDefinition, drawSize = _a.drawSize;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var result = setStageDrawSize({
        stage: VOLUNTARY_CONSOLATION,
        stageSequence: 1,
        drawDefinition: drawDefinition,
        drawSize: drawSize,
    });
    if (result.error)
        return result;
    modifyDrawNotice({ drawDefinition: drawDefinition });
    return __assign({}, SUCCESS);
}

function addVoluntaryConsolationStage(params) {
    return addVoluntaryConsolationStage$1(params);
}

function updateTargetTeamMatchUps(_a) {
    var e_1, _b;
    var updateInProgressMatchUps = _a.updateInProgressMatchUps, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, targetMatchUps = _a.targetMatchUps, tieFormat = _a.tieFormat, event = _a.event;
    try {
        for (var targetMatchUps_1 = __values(targetMatchUps), targetMatchUps_1_1 = targetMatchUps_1.next(); !targetMatchUps_1_1.done; targetMatchUps_1_1 = targetMatchUps_1.next()) {
            var targetMatchUp = targetMatchUps_1_1.value;
            var hasTieFormat = !!targetMatchUp.tieFormat;
            if (hasTieFormat) {
                targetMatchUp.tieFormat = copyTieFormat(tieFormat);
            }
            var scoreUpdated = void 0;
            if (updateInProgressMatchUps) {
                // recalculate score
                var result = updateTieMatchUpScore({
                    matchUpId: targetMatchUp.matchUpId,
                    exitWhenNoValues: true,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    event: event,
                });
                if (result.error)
                    return result;
                scoreUpdated = result.score;
            }
            if (hasTieFormat && !scoreUpdated) {
                modifyMatchUpNotice({
                    tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                    context: 'updateTargetTeamMatchUps',
                    eventId: event === null || event === void 0 ? void 0 : event.eventId,
                    matchUp: targetMatchUp,
                    drawDefinition: drawDefinition,
                });
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (targetMatchUps_1_1 && !targetMatchUps_1_1.done && (_b = targetMatchUps_1.return)) _b.call(targetMatchUps_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}

function getTargetTeamMatchUps(_a) {
    var _b, _c, _d, _e;
    var updateInProgressMatchUps = _a.updateInProgressMatchUps, drawDefinition = _a.drawDefinition, structureId = _a.structureId, structure = _a.structure, matchUpId = _a.matchUpId, matchUp = _a.matchUp;
    var matchUps = [];
    if (matchUpId && matchUp) {
        matchUps = [matchUp];
    }
    else if (structureId && structure) {
        matchUps =
            (_c = (_b = getAllStructureMatchUps({
                matchUpFilters: { matchUpTypes: [TEAM] },
                structure: structure,
            })) === null || _b === void 0 ? void 0 : _b.matchUps) !== null && _c !== void 0 ? _c : [];
    }
    else if (drawDefinition) {
        matchUps =
            (_e = (_d = allDrawMatchUps({
                matchUpFilters: { matchUpTypes: [TEAM] },
                drawDefinition: drawDefinition,
            })) === null || _d === void 0 ? void 0 : _d.matchUps) !== null && _e !== void 0 ? _e : [];
    }
    // all team matchUps in scope which are completed or which have a tieFormat should not be modified
    var targetMatchUps = matchUps.filter(function (matchUp) {
        return !matchUp.winningSide &&
            matchUp.matchUpStatus !== COMPLETED$1 &&
            (updateInProgressMatchUps ||
                (matchUp.matchUpStatus !== IN_PROGRESS$1 && !checkScoreHasValue(matchUp)));
    });
    return { targetMatchUps: targetMatchUps };
}

function collectionGroupUpdate(_a) {
    var updateInProgressMatchUps = _a.updateInProgressMatchUps, originalValueGoal = _a.originalValueGoal, tournamentRecord = _a.tournamentRecord, wasAggregateValue = _a.wasAggregateValue, tieFormatName = _a.tieFormatName, drawDefinition = _a.drawDefinition, structureId = _a.structureId, structure = _a.structure, tieFormat = _a.tieFormat, matchUpId = _a.matchUpId, matchUp = _a.matchUp, eventId = _a.eventId, event = _a.event;
    // calculate new winCriteria for tieFormat
    // if existing winCriteria is aggregateValue, retain
    var _b = calculateWinCriteria(tieFormat), aggregateValue = _b.aggregateValue, valueGoal = _b.valueGoal;
    tieFormat.winCriteria = definedAttributes({ aggregateValue: aggregateValue, valueGoal: valueGoal });
    // if valueGoal has changed, force renaming of the tieFormat
    if ((originalValueGoal && originalValueGoal !== valueGoal) ||
        (aggregateValue && !wasAggregateValue)) {
        if (tieFormatName) {
            tieFormat.tieFormatName = tieFormatName;
        }
        else {
            delete tieFormat.tieFormatName;
        }
    }
    var targetMatchUps = getTargetTeamMatchUps({
        updateInProgressMatchUps: updateInProgressMatchUps,
        drawDefinition: drawDefinition,
        structureId: structureId,
        structure: structure,
        matchUpId: matchUpId,
        matchUp: matchUp,
    }).targetMatchUps;
    updateTargetTeamMatchUps({
        updateInProgressMatchUps: updateInProgressMatchUps,
        tournamentRecord: tournamentRecord,
        targetMatchUps: targetMatchUps,
        drawDefinition: drawDefinition,
        tieFormat: tieFormat,
        event: event,
    });
    var prunedTieFormat = definedAttributes(tieFormat);
    var result = validateTieFormat({ tieFormat: prunedTieFormat });
    if (result.error)
        return result;
    // TODO: implement use of tieFormats and tieFormatId
    if (eventId && event) {
        event.tieFormat = prunedTieFormat;
        // NOTE: there is not yet a modifyEventNotice
    }
    else if (matchUpId && matchUp) {
        matchUp.tieFormat = tieFormat;
    }
    else if (structure) {
        structure.tieFormat = prunedTieFormat;
    }
    else if (drawDefinition) {
        drawDefinition.tieFormat = prunedTieFormat;
    }
    else if (!matchUp || !drawDefinition) {
        return { error: MISSING_DRAW_DEFINITION };
    }
    modifyDrawNotice({ drawDefinition: drawDefinition, eventId: event === null || event === void 0 ? void 0 : event.eventId });
    return __assign({}, SUCCESS);
}

function removeCollectionGroup(_a) {
    var _b;
    var _c = _a.updateInProgressMatchUps, updateInProgressMatchUps = _c === void 0 ? true : _c, collectionGroupNumber = _a.collectionGroupNumber, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, tieFormatName = _a.tieFormatName, structureId = _a.structureId, matchUpId = _a.matchUpId, matchUp = _a.matchUp, eventId = _a.eventId, event = _a.event;
    if (!collectionGroupNumber)
        return { error: MISSING_VALUE };
    if (isNaN(collectionGroupNumber))
        return { error: INVALID_VALUES };
    var stack = 'removeCollectionGroup';
    var result = !matchUp
        ? getTieFormat$1({
            drawDefinition: drawDefinition,
            structureId: structureId,
            matchUpId: matchUpId,
            eventId: eventId,
            event: event,
        })
        : undefined;
    if (result === null || result === void 0 ? void 0 : result.error)
        return decorateResult({ result: result, stack: stack });
    var structure = result === null || result === void 0 ? void 0 : result.structure;
    matchUp = matchUp !== null && matchUp !== void 0 ? matchUp : result === null || result === void 0 ? void 0 : result.matchUp;
    var existingTieFormat = result === null || result === void 0 ? void 0 : result.tieFormat;
    var originalValueGoal = existingTieFormat === null || existingTieFormat === void 0 ? void 0 : existingTieFormat.winCriteria.valueGoal;
    var wasAggregateValue = existingTieFormat === null || existingTieFormat === void 0 ? void 0 : existingTieFormat.winCriteria.aggregateValue;
    var tieFormat = copyTieFormat(existingTieFormat);
    result = validateTieFormat({ tieFormat: tieFormat });
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    var modifiedCollectionIds = [];
    // remove the collectionGroup and all references to it in other collectionDefinitions
    tieFormat.collectionDefinitions = tieFormat.collectionDefinitions.map(function (collectionDefinition) {
        var groupNumber = collectionDefinition.collectionGroupNumber, rest = __rest(collectionDefinition, ["collectionGroupNumber"]);
        if (groupNumber !== collectionGroupNumber) {
            return collectionDefinition;
        }
        else {
            modifiedCollectionIds.push(collectionDefinition.collectionId);
            return rest;
        }
    });
    tieFormat.collectionGroups = tieFormat.collectionGroups.filter(function (_a) {
        var groupNumber = _a.groupNumber;
        return groupNumber !== collectionGroupNumber;
    });
    result = collectionGroupUpdate({
        updateInProgressMatchUps: updateInProgressMatchUps,
        originalValueGoal: originalValueGoal,
        wasAggregateValue: wasAggregateValue,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        tieFormatName: tieFormatName,
        structureId: structureId,
        structure: structure,
        tieFormat: tieFormat,
        matchUpId: matchUpId,
        matchUp: matchUp,
        eventId: eventId,
        event: event,
    });
    if (!result.error) {
        var appliedPolicies = getAppliedPolicies({ tournamentRecord: tournamentRecord }).appliedPolicies;
        if ((_b = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.audit) === null || _b === void 0 ? void 0 : _b[TIE_FORMAT_MODIFICATIONS]) {
            var auditData = definedAttributes({
                drawId: drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.drawId,
                collectionGroupNumber: collectionGroupNumber,
                action: stack,
                structureId: structureId,
                matchUpId: matchUpId,
                eventId: eventId,
            });
            tieFormatTelemetry({ drawDefinition: drawDefinition, auditData: auditData });
        }
    }
    return decorateResult({
        result: __assign(__assign({}, result), { modifiedCollectionIds: modifiedCollectionIds }),
        stack: stack,
    });
}

function removeSeededParticipant(_a) {
    var _b, _c;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, participantId = _a.participantId, structureId = _a.structureId;
    var stack = 'removeSeededParticipant';
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var structure = ((_b = drawDefinition.structures) !== null && _b !== void 0 ? _b : []).find(function (structure) { return structure.structureId === structureId; });
    if (!structure)
        return decorateResult({ result: { error: STRUCTURE_NOT_FOUND }, stack: stack });
    if (!structure.stage ||
        ![MAIN, QUALIFYING].includes(structure.stage) ||
        (structure.stage === MAIN && structure.stageSequence !== 1)) {
        return decorateResult({ result: { error: INVALID_STRUCTURE }, stack: stack });
    }
    var seedAssignment = (_c = structure.seedAssignments) === null || _c === void 0 ? void 0 : _c.find(function (assignment) { return assignment.participantId === participantId; });
    if (!seedAssignment)
        return decorateResult({
            info: 'participant not seeded',
            result: { error: NOT_FOUND },
            context: { participantId: participantId },
        });
    // TODO: implement rotation of seeded players
    return __assign({}, SUCCESS);
}

function getOrderedTieFormat(_a) {
    var tieFormat = _a.tieFormat, orderMap = _a.orderMap;
    var orderedTieFormat = copyTieFormat(tieFormat);
    orderedTieFormat.collectionDefinitions.forEach(function (collectionDefinition) {
        var collectionOrder = orderMap[collectionDefinition.collectionId];
        if (collectionOrder)
            collectionDefinition.collectionOrder = collectionOrder;
    });
    orderedTieFormat.collectionDefinitions.sort(function (a, b) {
        return numericSortValue(a.collectionOrder) - numericSortValue(b.collectionOrder);
    });
    return orderedTieFormat;
}
function orderCollectionDefinitions(_a) {
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, structureId = _a.structureId, matchUpId = _a.matchUpId, orderMap = _a.orderMap, eventId = _a.eventId, matchUp = _a.matchUp, event = _a.event;
    if (typeof orderMap !== 'object' ||
        !Object.values(orderMap).every(function (val) { return isConvertableInteger(val); }))
        return decorateResult({
            result: { error: INVALID_VALUES },
            context: { orderMap: orderMap },
        });
    if (eventId && (event === null || event === void 0 ? void 0 : event.tieFormat)) {
        updateEventTieFormat({ tournamentRecord: tournamentRecord, event: event, orderMap: orderMap });
    }
    else if (matchUpId) {
        var result = drawDefinition &&
            findDrawMatchUp({
                drawDefinition: drawDefinition,
                matchUpId: matchUpId,
            });
        if (result === null || result === void 0 ? void 0 : result.error)
            return result;
        matchUp = result.matchUp;
        if (!matchUp)
            return { error: MISSING_MATCHUP };
        if (matchUp === null || matchUp === void 0 ? void 0 : matchUp.tieFormat) {
            matchUp.tieFormat = getOrderedTieFormat({
                tieFormat: matchUp.tieFormat,
                orderMap: orderMap,
            });
            modifyMatchUpNotice({
                tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                eventId: event === null || event === void 0 ? void 0 : event.eventId,
                drawDefinition: drawDefinition,
                matchUp: matchUp,
            });
        }
    }
    else if (structureId) {
        var result = findStructure({ drawDefinition: drawDefinition, structureId: structureId });
        if (result.error)
            return result;
        var structure = result.structure;
        if (structure === null || structure === void 0 ? void 0 : structure.tieFormat) {
            structure.tieFormat = getOrderedTieFormat({
                tieFormat: structure.tieFormat,
                orderMap: orderMap,
            });
            updateStructureMatchUps$1({
                eventId: event === null || event === void 0 ? void 0 : event.eventId,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                structure: structure,
                orderMap: orderMap,
            });
            modifyDrawNotice({
                drawDefinition: drawDefinition,
                structureIds: [structure.structureId],
            });
        }
        else if (drawDefinition.tieFormat) {
            updateDrawTieFormat({
                structureIds: [structureId],
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                orderMap: orderMap,
                event: event,
            });
        }
        else if (event === null || event === void 0 ? void 0 : event.tieFormat) {
            updateEventTieFormat({
                structureIds: [structureId],
                tournamentRecord: tournamentRecord,
                orderMap: orderMap,
                event: event,
            });
        }
        else {
            return { error: NOT_FOUND };
        }
    }
    else if (drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.tieFormat) {
        updateDrawTieFormat({ tournamentRecord: tournamentRecord, drawDefinition: drawDefinition, orderMap: orderMap, event: event });
    }
    else {
        return { error: NOT_FOUND };
    }
    return __assign({}, SUCCESS);
}
function updateEventTieFormat(_a) {
    var e_1, _b;
    var _c;
    var tournamentRecord = _a.tournamentRecord, structureIds = _a.structureIds, // allow scoping to only specific structureIds
    orderMap = _a.orderMap, event = _a.event;
    var updatedFormat = getOrderedTieFormat({
        tieFormat: event.tieFormat,
        orderMap: orderMap,
    });
    if (!(structureIds === null || structureIds === void 0 ? void 0 : structureIds.length))
        event.tieFormat = updatedFormat;
    try {
        for (var _d = __values((_c = event.drawDefinitions) !== null && _c !== void 0 ? _c : []), _e = _d.next(); !_e.done; _e = _d.next()) {
            var drawDefinition = _e.value;
            updateDrawTieFormat({
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                structureIds: structureIds,
                orderMap: orderMap,
                event: event,
            });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
function updateDrawTieFormat(_a) {
    var e_2, _b;
    var _c, _d, _e, _f;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, structureIds = _a.structureIds, orderMap = _a.orderMap, event = _a.event;
    var tieFormat = (_c = drawDefinition.tieFormat) !== null && _c !== void 0 ? _c : event === null || event === void 0 ? void 0 : event.tieFormat;
    var updatedFormat = getOrderedTieFormat({
        tieFormat: tieFormat,
        orderMap: orderMap,
    });
    if (!(structureIds === null || structureIds === void 0 ? void 0 : structureIds.length))
        drawDefinition.tieFormat = updatedFormat;
    var modifiedStructureIds = [];
    try {
        for (var _g = __values((_d = drawDefinition.structures) !== null && _d !== void 0 ? _d : []), _h = _g.next(); !_h.done; _h = _g.next()) {
            var structure = _h.value;
            // if structureIds is present, only modify referenced structures
            if ((structureIds === null || structureIds === void 0 ? void 0 : structureIds.length) && !structureIds.includes(structure.structureId))
                continue;
            if (structure.tieFormat || (structureIds === null || structureIds === void 0 ? void 0 : structureIds.includes(structure.structureId)))
                structure.tieFormat = getOrderedTieFormat({
                    tieFormat: (_f = (_e = structure.tieFormat) !== null && _e !== void 0 ? _e : drawDefinition.tieFormat) !== null && _f !== void 0 ? _f : event === null || event === void 0 ? void 0 : event.tieFormat,
                    orderMap: orderMap,
                });
            updateStructureMatchUps$1({
                eventId: event === null || event === void 0 ? void 0 : event.eventId,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                structure: structure,
                orderMap: orderMap,
            });
            modifiedStructureIds.push(structure.structureId);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
        }
        finally { if (e_2) throw e_2.error; }
    }
    modifyDrawNotice({ drawDefinition: drawDefinition, structureIds: modifiedStructureIds });
}
function updateStructureMatchUps$1(_a) {
    var e_3, _b;
    var _c;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, structure = _a.structure, orderMap = _a.orderMap, eventId = _a.eventId;
    var matchUps = (_c = getAllStructureMatchUps({
        matchUpFilters: { matchUpTypes: [TEAM] },
        structure: structure,
    })) === null || _c === void 0 ? void 0 : _c.matchUps;
    try {
        for (var matchUps_1 = __values(matchUps), matchUps_1_1 = matchUps_1.next(); !matchUps_1_1.done; matchUps_1_1 = matchUps_1.next()) {
            var matchUp = matchUps_1_1.value;
            if (matchUp.tieFormat) {
                matchUp.tieFormat = getOrderedTieFormat({
                    tieFormat: matchUp.tieFormat,
                    orderMap: orderMap,
                });
                modifyMatchUpNotice({
                    tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                    drawDefinition: drawDefinition,
                    eventId: eventId,
                    matchUp: matchUp,
                });
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (matchUps_1_1 && !matchUps_1_1.done && (_b = matchUps_1.return)) _b.call(matchUps_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
}

// all child matchUps need to be checked for collectionAssignments which need to be removed when collectionDefinition.collectionIds are removed
function removeCollectionDefinition(_a) {
    var e_1, _b, e_2, _c, e_3, _d;
    var _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    var _s = _a.updateInProgressMatchUps, updateInProgressMatchUps = _s === void 0 ? true : _s, tieFormatComparison = _a.tieFormatComparison, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, tieFormatName = _a.tieFormatName, collectionId = _a.collectionId, structureId = _a.structureId, matchUpId = _a.matchUpId, eventId = _a.eventId, matchUp = _a.matchUp, event = _a.event;
    var stack = 'removeCollectionDefinition';
    var result = !matchUp
        ? getTieFormat$1({
            drawDefinition: drawDefinition,
            structureId: structureId,
            matchUpId: matchUpId,
            eventId: eventId,
            event: event,
        })
        : undefined;
    if (result === null || result === void 0 ? void 0 : result.error)
        return decorateResult({ result: result, stack: stack });
    var structure = result === null || result === void 0 ? void 0 : result.structure;
    matchUp = matchUp !== null && matchUp !== void 0 ? matchUp : result === null || result === void 0 ? void 0 : result.matchUp;
    var existingTieFormat = result === null || result === void 0 ? void 0 : result.tieFormat;
    var tieFormat = copyTieFormat(existingTieFormat);
    result = validateTieFormat({ tieFormat: tieFormat });
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    var targetCollection = (_e = tieFormat === null || tieFormat === void 0 ? void 0 : tieFormat.collectionDefinitions) === null || _e === void 0 ? void 0 : _e.find(function (collectionDefinition) { return collectionDefinition.collectionId === collectionId; });
    if (!targetCollection)
        return decorateResult({ result: { error: NOT_FOUND, collectionId: collectionId } });
    tieFormat.collectionDefinitions = tieFormat.collectionDefinitions.filter(function (collectionDefinition) { return collectionDefinition.collectionId !== collectionId; });
    // if the collectionDefinition being removed contains a collectionGroupNumber,
    // remove the collectionGroup and all references to it in other collectionDefinitions
    if (targetCollection.collectionGroupNumber) {
        tieFormat.collectionDefinitions = tieFormat.collectionDefinitions.map(function (collectionDefinition) {
            collectionDefinition.collectionGroupNumber; var rest = __rest(collectionDefinition, ["collectionGroupNumber"]);
            return rest;
        });
        tieFormat.collectionGroups = tieFormat.collectionGroups.filter(function (_a) {
            var groupNumber = _a.groupNumber;
            return groupNumber !== targetCollection.collectionGroupNumber;
        });
    }
    // calculate new winCriteria for tieFormat
    // if existing winCriteria is aggregateValue, retain
    var _t = calculateWinCriteria(tieFormat), aggregateValue = _t.aggregateValue, valueGoal = _t.valueGoal;
    tieFormat.winCriteria = definedAttributes({ aggregateValue: aggregateValue, valueGoal: valueGoal });
    // if valueGoal has changed, force renaming of the tieFormat
    var originalValueGoal = existingTieFormat === null || existingTieFormat === void 0 ? void 0 : existingTieFormat.winCriteria.valueGoal;
    var wasAggregateValue = existingTieFormat === null || existingTieFormat === void 0 ? void 0 : existingTieFormat.winCriteria.aggregateValue;
    if ((originalValueGoal && originalValueGoal !== valueGoal) ||
        (aggregateValue && !wasAggregateValue)) {
        if (tieFormatName) {
            tieFormat.tieFormatName = tieFormatName;
        }
        else {
            delete tieFormat.tieFormatName;
        }
    }
    // check all scoped lineUps in the drawDefinition to identify collectionAssignments
    var matchUps = [];
    if (matchUpId && matchUp) {
        matchUps = [matchUp];
    }
    else if (structureId && structure) {
        matchUps =
            (_g = (_f = getAllStructureMatchUps({
                matchUpFilters: { matchUpTypes: [TEAM] },
                structure: structure,
            })) === null || _f === void 0 ? void 0 : _f.matchUps) !== null && _g !== void 0 ? _g : [];
    }
    else if (drawDefinition) {
        matchUps =
            (_j = (_h = allDrawMatchUps({
                matchUpFilters: { matchUpTypes: [TEAM] },
                drawDefinition: drawDefinition,
            })) === null || _h === void 0 ? void 0 : _h.matchUps) !== null && _j !== void 0 ? _j : [];
    }
    else if (event) {
        matchUps =
            (_l = (_k = allEventMatchUps({
                matchUpFilters: { matchUpTypes: [TEAM] },
                drawDefinition: drawDefinition,
            })) === null || _k === void 0 ? void 0 : _k.matchUps) !== null && _l !== void 0 ? _l : [];
    }
    // all team matchUps in scope which are completed or which have a score should not be modified
    // UNLESS all collectionMatchUps have no score
    var targetMatchUps = (matchUps || []).filter(function (matchUp) {
        var _a, _b;
        var collectionMatchUps = (_a = matchUp.tieMatchUps) === null || _a === void 0 ? void 0 : _a.filter(function (tieMatchUp) { return tieMatchUp.collectionId === collectionId; });
        var collectionScore = collectionMatchUps === null || collectionMatchUps === void 0 ? void 0 : collectionMatchUps.some(checkScoreHasValue);
        var tieFormatDifference = tieFormatComparison && matchUp.tieFormat
            ? (_b = compareTieFormats({
                descendant: matchUp.tieFormat,
                ancestor: tieFormat,
            })) === null || _b === void 0 ? void 0 : _b.different
            : false;
        return ((updateInProgressMatchUps && !collectionScore) ||
            (!matchUp.winningSide &&
                matchUp.matchUpStatus !== COMPLETED$1 &&
                (updateInProgressMatchUps ||
                    (matchUp.matchUpStatus !== IN_PROGRESS$1 &&
                        !checkScoreHasValue(matchUp) &&
                        !tieFormatDifference))));
    });
    if (!targetMatchUps.length) {
        return { error: NO_MODIFICATIONS_APPLIED };
    }
    if (matchUpId && matchUp && updateInProgressMatchUps) {
        var collectionMatchUps = (_m = matchUp.tieMatchUps) === null || _m === void 0 ? void 0 : _m.filter(function (tieMatchUp) { return tieMatchUp.collectionId === collectionId; });
        try {
            for (var _u = __values(collectionMatchUps !== null && collectionMatchUps !== void 0 ? collectionMatchUps : []), _v = _u.next(); !_v.done; _v = _u.next()) {
                var collectionMatchUp = _v.value;
                var result_1 = setMatchUpState({
                    matchUpId: collectionMatchUp.matchUpId,
                    tieMatchUpId: matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpId,
                    winningSide: undefined,
                    removeScore: true,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    event: event,
                });
                if (result_1.error)
                    return result_1;
                result_1 = findDrawMatchUp({
                    drawDefinition: drawDefinition,
                    matchUpId: matchUpId,
                });
                if (result_1.error)
                    return result_1;
                matchUp = result_1 === null || result_1 === void 0 ? void 0 : result_1.matchUp;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_v && !_v.done && (_b = _u.return)) _b.call(_u);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    var deletedMatchUpIds = [];
    try {
        for (var targetMatchUps_1 = __values(targetMatchUps), targetMatchUps_1_1 = targetMatchUps_1.next(); !targetMatchUps_1_1.done; targetMatchUps_1_1 = targetMatchUps_1.next()) {
            var matchUp_1 = targetMatchUps_1_1.value;
            try {
                // remove any collectionAssignments from LineUps that include collectionId
                for (var _w = (e_3 = void 0, __values((_o = matchUp_1 === null || matchUp_1 === void 0 ? void 0 : matchUp_1.sides) !== null && _o !== void 0 ? _o : [])), _x = _w.next(); !_x.done; _x = _w.next()) {
                    var side = _x.value;
                    side.lineUp = ((_p = side.lineUp) !== null && _p !== void 0 ? _p : []).map(function (assignment) {
                        var _a;
                        return ({
                            participantId: assignment.participantId,
                            collectionAssignments: ((_a = assignment === null || assignment === void 0 ? void 0 : assignment.collectionAssignments) !== null && _a !== void 0 ? _a : []).filter(function (collectionAssignment) {
                                return collectionAssignment.collectionId !== collectionId;
                            }),
                        });
                    });
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_x && !_x.done && (_d = _w.return)) _d.call(_w);
                }
                finally { if (e_3) throw e_3.error; }
            }
            // delete any tieMatchUps that contain collectionId
            matchUp_1.tieMatchUps = ((_q = matchUp_1.tieMatchUps) !== null && _q !== void 0 ? _q : []).filter(function (matchUp) {
                var deleteTarget = matchUp.collectionId === collectionId;
                if (deleteTarget)
                    deletedMatchUpIds.push(matchUp.matchUpId);
                return !deleteTarget;
            });
            if (matchUp_1.tieFormat)
                matchUp_1.tieFormat = copyTieFormat(tieFormat);
            if (updateInProgressMatchUps) {
                // recalculate score
                var result_2 = updateTieMatchUpScore({
                    matchUpId: matchUp_1.matchUpId,
                    exitWhenNoValues: true,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    event: event,
                });
                if (result_2.error)
                    return result_2;
            }
            modifyMatchUpNotice({
                tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                eventId: event === null || event === void 0 ? void 0 : event.eventId,
                drawDefinition: drawDefinition,
                context: stack,
                matchUp: matchUp_1,
            });
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (targetMatchUps_1_1 && !targetMatchUps_1_1.done && (_c = targetMatchUps_1.return)) _c.call(targetMatchUps_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    // remove any matchUps which contain collectionId
    if (deletedMatchUpIds.length) {
        // notify subscribers that matchUps have been deleted
        deleteMatchUpsNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            matchUpIds: deletedMatchUpIds,
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            drawDefinition: drawDefinition,
        });
    }
    var prunedTieFormat = definedAttributes(tieFormat);
    result = validateTieFormat({ tieFormat: prunedTieFormat });
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    // TODO: implement use of tieFormats and tieFormatId
    if (eventId && event) {
        event.tieFormat = prunedTieFormat;
        // NOTE: there is not a modifyEventNotice
    }
    else if (matchUpId && matchUp) {
        matchUp.tieFormat = prunedTieFormat;
    }
    else if (structure) {
        structure.tieFormat = prunedTieFormat;
    }
    else if (drawDefinition) {
        drawDefinition.tieFormat = prunedTieFormat;
    }
    else if (!matchUp || !drawDefinition) {
        return { error: MISSING_DRAW_DEFINITION };
    }
    modifyDrawNotice({ drawDefinition: drawDefinition, eventId: event === null || event === void 0 ? void 0 : event.eventId });
    var appliedPolicies = getAppliedPolicies({ tournamentRecord: tournamentRecord }).appliedPolicies;
    if ((_r = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.audit) === null || _r === void 0 ? void 0 : _r[TIE_FORMAT_MODIFICATIONS]) {
        var auditData = definedAttributes({
            drawId: drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.drawId,
            action: stack,
            collectionId: collectionId,
            structureId: structureId,
            matchUpId: matchUpId,
            eventId: eventId,
        });
        tieFormatTelemetry({ drawDefinition: drawDefinition, auditData: auditData });
    }
    return __assign({ tieFormat: prunedTieFormat, deletedMatchUpIds: deletedMatchUpIds, targetMatchUps: targetMatchUps }, SUCCESS);
}

function setPositionAssignments$1(_a) {
    var e_1, _b, e_2, _c;
    var _d;
    var structurePositionAssignments = _a.structurePositionAssignments, provisionalPositioning = _a.provisionalPositioning, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!Array.isArray(structurePositionAssignments))
        return { error: INVALID_VALUES };
    var stack = 'setPositionAssignments';
    try {
        for (var structurePositionAssignments_1 = __values(structurePositionAssignments), structurePositionAssignments_1_1 = structurePositionAssignments_1.next(); !structurePositionAssignments_1_1.done; structurePositionAssignments_1_1 = structurePositionAssignments_1.next()) {
            var structureAssignments = structurePositionAssignments_1_1.value;
            var structureId = structureAssignments.structureId, positionAssignments = structureAssignments.positionAssignments;
            if (!positionAssignments)
                continue;
            var result = findStructure({ drawDefinition: drawDefinition, structureId: structureId });
            if (result.error)
                return result;
            var structure = result.structure;
            if (!structure)
                return { error: STRUCTURE_NOT_FOUND };
            var structureDrawPositions = (_d = getPositionAssignments$1({
                structure: structure,
            }).positionAssignments) === null || _d === void 0 ? void 0 : _d.map(function (_a) {
                var drawPosition = _a.drawPosition;
                return drawPosition;
            });
            var submittedDrawPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.map(function (_a) {
                var drawPosition = _a.drawPosition;
                return drawPosition;
            });
            if (intersection(structureDrawPositions, submittedDrawPositions).length !==
                (structureDrawPositions === null || structureDrawPositions === void 0 ? void 0 : structureDrawPositions.length)) {
                return decorateResult({
                    result: { error: INVALID_VALUES },
                    info: 'drawPositions do not match',
                    stack: stack,
                });
            }
            var matchUpsMap = getMatchUpsMap({ drawDefinition: drawDefinition });
            var inContextDrawMatchUps = getAllDrawMatchUps({
                inContext: true,
                drawDefinition: drawDefinition,
                matchUpsMap: matchUpsMap,
            }).matchUps;
            var _loop_1 = function (assignment) {
                var drawPosition = assignment.drawPosition, participantId = assignment.participantId, bye = assignment.bye, qualifier = assignment.qualifier;
                if (bye) {
                    var result_1 = assignDrawPositionBye({
                        tournamentRecord: tournamentRecord,
                        drawDefinition: drawDefinition,
                        drawPosition: drawPosition,
                        matchUpsMap: matchUpsMap,
                        structureId: structureId,
                        structure: structure,
                        event: event,
                    });
                    if (result_1 === null || result_1 === void 0 ? void 0 : result_1.error)
                        return { value: result_1 };
                }
                else if (qualifier) {
                    positionAssignments.forEach(function (assignment) {
                        if (assignment.drawPosition === drawPosition) {
                            assignment.qualifier = true;
                            delete assignment.participantId;
                            delete assignment.bye;
                        }
                    });
                }
                else if (participantId) {
                    var result_2 = assignDrawPosition$1({
                        provisionalPositioning: provisionalPositioning,
                        inContextDrawMatchUps: inContextDrawMatchUps,
                        tournamentRecord: tournamentRecord,
                        drawDefinition: drawDefinition,
                        participantId: participantId,
                        drawPosition: drawPosition,
                        matchUpsMap: matchUpsMap,
                        structureId: structureId,
                        event: event,
                    });
                    if (result_2 === null || result_2 === void 0 ? void 0 : result_2.error)
                        return { value: result_2 };
                }
            };
            try {
                for (var _e = (e_2 = void 0, __values(positionAssignments || [])), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var assignment = _f.value;
                    var state_1 = _loop_1(assignment);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            modifyPositionAssignmentsNotice({
                tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                drawDefinition: drawDefinition,
                structure: structure,
                event: event,
            });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (structurePositionAssignments_1_1 && !structurePositionAssignments_1_1.done && (_b = structurePositionAssignments_1.return)) _b.call(structurePositionAssignments_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var structureIds = structurePositionAssignments.map(function (_a) {
        var structureId = _a.structureId;
        return structureId;
    });
    modifyDrawNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        eventId: event === null || event === void 0 ? void 0 : event.eventId,
        drawDefinition: drawDefinition,
        structureIds: structureIds,
    });
    return __assign({}, SUCCESS);
}

function setPositionAssignments(params) {
    return setPositionAssignments$1(params);
}

function generateQualifyingLink(_a) {
    var _b = _a.targetEntryRound, targetEntryRound = _b === void 0 ? 1 : _b, finishingPositions = _a.finishingPositions, sourceRoundNumber = _a.sourceRoundNumber, sourceStructureId = _a.sourceStructureId, targetStructureId = _a.targetStructureId, _c = _a.linkType, linkType = _c === void 0 ? WINNER : _c;
    if (!sourceStructureId || !targetStructureId)
        return { error: MISSING_STRUCTURE_ID };
    var link = definedAttributes({
        linkType: linkType,
        source: {
            roundNumber: sourceRoundNumber,
            structureId: sourceStructureId,
            finishingPositions: finishingPositions,
        },
        target: {
            feedProfile: DRAW, // positions are not automatically placed
            roundNumber: targetEntryRound,
            structureId: targetStructureId,
        },
    });
    return { link: link };
}

function generateMatchUpId(_a) {
    var roundPosition = _a.roundPosition, roundNumber = _a.roundNumber, idPrefix = _a.idPrefix, uuids = _a.uuids;
    return idPrefix
        ? "".concat(idPrefix, "-").concat(roundNumber, "-").concat(roundPosition)
        : (uuids === null || uuids === void 0 ? void 0 : uuids.pop()) || UUID();
}

function buildRound(_a) {
    var includeMatchUpType = _a.includeMatchUpType, matchUpType = _a.matchUpType, roundNumber = _a.roundNumber, matchUps = _a.matchUps, idPrefix = _a.idPrefix, isMock = _a.isMock, uuids = _a.uuids, nodes = _a.nodes;
    var index = 0;
    var roundNodes = [];
    var roundPosition = 1;
    var matchRoundNumber = roundNumber - 1;
    var roundMatchUpsCount = nodes === null || nodes === void 0 ? void 0 : nodes.length;
    while (index < (roundMatchUpsCount || 0)) {
        var child1 = nodes === null || nodes === void 0 ? void 0 : nodes[index];
        var child2 = nodes === null || nodes === void 0 ? void 0 : nodes[index + 1];
        if (matchRoundNumber)
            child1.roundNumber = matchRoundNumber;
        if (child2 && matchRoundNumber)
            child2.roundNumber = matchRoundNumber;
        var matchUpId = generateMatchUpId({
            roundPosition: roundPosition,
            roundNumber: roundNumber,
            idPrefix: idPrefix,
            uuids: uuids,
        });
        var node = {
            roundPosition: roundPosition,
            children: [child1, child2],
            matchUpId: matchUpId,
        };
        roundNodes.push(node);
        var matchUp = {
            drawPositions: node.children.map(function (c) { return c === null || c === void 0 ? void 0 : c.drawPosition; }).filter(Boolean),
            matchUpStatus: TO_BE_PLAYED,
            matchUpId: node.matchUpId,
            roundPosition: roundPosition,
            roundNumber: roundNumber,
        };
        // matchUpType is derived for inContext matchUps from structure or drawDefinition
        if (includeMatchUpType && matchUpType)
            matchUp.matchUpType = matchUpType;
        if (isMock)
            matchUp.isMock = true;
        matchUps.push(matchUp);
        roundPosition++;
        index += 2;
    }
    return { roundNodes: roundNodes, matchUps: matchUps };
}

function treeMatchUps(_a) {
    var _b, _c;
    var finishingPositionOffset = _a.finishingPositionOffset, finishingPositionLimit = _a.finishingPositionLimit, // optional - limit finishingPositionRanges
    qualifyingRoundNumber = _a.qualifyingRoundNumber, // round at which participants qualify
    qualifyingPositions = _a.qualifyingPositions, // number of positions which qualify
    matchUpType = _a.matchUpType, roundLimit = _a.roundLimit, idPrefix = _a.idPrefix, drawSize = _a.drawSize, isMock = _a.isMock, uuids = _a.uuids;
    if (isNaN(drawSize) || drawSize < 2 || (qualifyingPositions && drawSize <= qualifyingPositions)) {
        return { matchUps: [], roundsCount: 0 };
    }
    if (qualifyingPositions && (!isPowerOf2(drawSize) || drawSize % qualifyingPositions)) {
        // if drawSize is NOT a multiple of qualifyingPositions...
        // change drawSize to a multiple of qualifyingPositions that is larger than drawSize
        var requiredDrawSize = qualifyingPositions;
        while (requiredDrawSize < drawSize)
            requiredDrawSize = 2 * requiredDrawSize;
        drawSize = requiredDrawSize;
    }
    var isValidQualifying = qualifyingPositions &&
        !(drawSize % 2) &&
        (!isNaN(qualifyingPositions) || (qualifyingRoundNumber && !isNaN(qualifyingRoundNumber))) &&
        (drawSize / qualifyingPositions === Math.round(drawSize / qualifyingPositions) ||
            (qualifyingRoundNumber && drawSize / qualifyingRoundNumber === Math.round(drawSize / qualifyingRoundNumber)));
    if (!isPowerOf2(drawSize) && !isValidQualifying) {
        return { matchUps: [], roundsCount: 0 };
    }
    var nodes = generateRange(1, drawSize + 1).map(function (drawPosition) { return ({
        drawPosition: drawPosition,
    }); });
    var roundNodes;
    var matchUps = [];
    var roundNumber = 1;
    (_b = buildRound({
        matchUpType: matchUpType,
        roundNumber: roundNumber,
        idPrefix: idPrefix,
        matchUps: matchUps,
        isMock: isMock,
        nodes: nodes,
        uuids: uuids,
    }), roundNodes = _b.roundNodes, matchUps = _b.matchUps);
    roundNumber++;
    roundLimit = roundLimit !== null && roundLimit !== void 0 ? roundLimit : qualifyingRoundNumber;
    while (roundNodes.length > 1) {
        if (qualifyingPositions && roundNodes.length === qualifyingPositions) {
            roundLimit = roundNumber - 1;
        }
        (_c = buildRound({
            nodes: roundNodes,
            matchUpType: matchUpType,
            roundNumber: roundNumber,
            idPrefix: idPrefix,
            matchUps: matchUps,
            isMock: isMock,
            uuids: uuids,
        }), roundNodes = _c.roundNodes, matchUps = _c.matchUps);
        roundNumber++;
    }
    var roundsCount = roundNumber - 1; // because roundNumber was incremented at the end of the while loop
    matchUps = addFinishingRounds({
        finishingPositionOffset: finishingPositionOffset,
        finishingPositionLimit: finishingPositionLimit,
        roundsCount: roundsCount,
        roundLimit: roundLimit,
        matchUps: matchUps,
    });
    if (!roundLimit) {
        // this is the case { qualifyingPositions : 1 }
        // subtract one to account for the last ++
        roundLimit = roundNumber - 1;
    }
    else {
        matchUps = matchUps.filter(function (matchUp) { var _a; return roundLimit && ((_a = matchUp.roundNumber) !== null && _a !== void 0 ? _a : 0) <= roundLimit; });
    }
    return { drawSize: drawSize, matchUps: matchUps, roundsCount: roundsCount, roundLimit: roundLimit };
}

// for use when adding a qualifying structure to an existing drawDefinition
// not for use when generating structures from qualifyingProfiles
function generateQualifyingStructure(params) {
    var _a;
    var _b, _c, _d, _e, _f, _g, _h, _j;
    var stack = 'generateQualifyingStructure';
    if (!params.drawDefinition)
        return decorateResult({
            result: { error: MISSING_DRAW_DEFINITION },
            stack: stack,
        });
    if ((params.drawSize && !isConvertableInteger(params.drawSize)) ||
        (params.participantsCount &&
            !isConvertableInteger(params.participantsCount)) ||
        (params.qualifyingPositions &&
            !isConvertableInteger(params.qualifyingPositions))) {
        return decorateResult({ result: { error: INVALID_VALUES }, stack: stack });
    }
    var drawSize = (_b = params.drawSize) !== null && _b !== void 0 ? _b : coerceEven(params.participantsCount);
    var qualifyingRoundNumber = params.qualifyingRoundNumber, qualifyingPositions = params.qualifyingPositions, targetStructureId = params.targetStructureId, structureOptions = params.structureOptions, appliedPolicies = params.appliedPolicies, drawDefinition = params.drawDefinition, matchUpFormat = params.matchUpFormat, structureName = params.structureName, structureId = params.structureId, roundTarget = params.roundTarget, drawType = params.drawType, idPrefix = params.idPrefix, isMock = params.isMock, uuids = params.uuids;
    if (!params.drawSize)
        return decorateResult({
            result: { error: MISSING_DRAW_SIZE },
            context: { drawSize: drawSize },
            stack: stack,
        });
    if (qualifyingPositions && qualifyingPositions >= params.drawSize)
        return decorateResult({
            result: { error: INVALID_VALUES },
            context: { drawSize: drawSize, qualifyingPositions: qualifyingPositions },
            stack: stack,
        });
    var roundLimit, roundsCount, structure, matchUps;
    var qualifiersCount = 0;
    var finishingPositions;
    var stageSequence = 1;
    var structureProfiles = getStructureGroups({ drawDefinition: drawDefinition }).structureProfiles;
    var structureProfile = structureProfiles[targetStructureId];
    if (!structureProfile) {
        return decorateResult({
            result: { error: STRUCTURE_NOT_FOUND },
            context: { targetStructureId: targetStructureId },
            stack: stack,
        });
    }
    var matchUpType = drawDefinition.matchUpType;
    var roundTargetName = roundTarget ? "".concat(roundTarget, "-") : '';
    var isPreQualifying = structureProfile.stage === QUALIFYING;
    var preQualifyingNaming = (_e = (_d = (_c = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_ROUND_NAMING]) === null || _c === void 0 ? void 0 : _c.namingConventions) === null || _d === void 0 ? void 0 : _d.pre) !== null && _e !== void 0 ? _e : (_g = (_f = POLICY_ROUND_NAMING_DEFAULT[POLICY_TYPE_ROUND_NAMING]) === null || _f === void 0 ? void 0 : _f.namingConventions) === null || _g === void 0 ? void 0 : _g.pre;
    var pre = isPreQualifying && preQualifyingNaming ? "".concat(preQualifyingNaming, "-") : '';
    var qualifyingStructureName = structureName !== null && structureName !== void 0 ? structureName : (roundTargetName
        ? "".concat(pre).concat(constantToString(QUALIFYING), " ").concat(roundTargetName)
        : "".concat(pre).concat(constantToString(QUALIFYING)));
    if (drawType === ROUND_ROBIN) {
        var _k = generateRoundRobin({
            structureName: structureName !== null && structureName !== void 0 ? structureName : qualifyingStructureName,
            structureId: structureId !== null && structureId !== void 0 ? structureId : uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
            stage: QUALIFYING,
            structureOptions: structureOptions,
            appliedPolicies: appliedPolicies,
            stageSequence: stageSequence,
            matchUpType: matchUpType,
            roundTarget: roundTarget,
            idPrefix: idPrefix,
            drawSize: drawSize,
            isMock: isMock,
            uuids: uuids,
        }), maxRoundNumber = _k.maxRoundNumber /*, groupSize*/, structures = _k.structures, groupCount = _k.groupCount;
        qualifiersCount = groupCount;
        roundLimit = maxRoundNumber;
        structure = structures[0];
        finishingPositions = [1];
    }
    else {
        (_a = treeMatchUps({
            qualifyingRoundNumber: qualifyingRoundNumber,
            qualifyingPositions: qualifyingPositions,
            matchUpType: matchUpType,
            idPrefix: idPrefix,
            drawSize: drawSize,
            isMock: isMock,
            uuids: uuids,
        }), drawSize = _a.drawSize, matchUps = _a.matchUps, roundLimit = _a.roundLimit, roundsCount = _a.roundsCount);
        if (!roundLimit)
            roundLimit = roundsCount;
        structure = structureTemplate({
            structureName: structureName !== null && structureName !== void 0 ? structureName : qualifyingStructureName,
            structureId: structureId !== null && structureId !== void 0 ? structureId : uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
            qualifyingRoundNumber: roundLimit,
            stage: QUALIFYING,
            matchUpFormat: matchUpFormat,
            stageSequence: stageSequence,
            matchUpType: matchUpType,
            roundLimit: roundLimit, // redundant
            matchUps: matchUps,
        });
        if (roundTarget) {
            addExtension({
                extension: { name: ROUND_TARGET, value: roundTarget },
                element: structure,
            });
        }
        qualifiersCount = (_h = matchUps === null || matchUps === void 0 ? void 0 : matchUps.filter(function (matchUp) { return matchUp.roundNumber === roundLimit; })) === null || _h === void 0 ? void 0 : _h.length;
    }
    // order of operations is important here!! finalQualifier positions is not yet updated when this step occurs
    var linkType = drawType === ROUND_ROBIN ? POSITION : WINNER;
    var link = structure &&
        roundLimit &&
        ((_j = generateQualifyingLink({
            sourceStructureId: structure.structureId,
            sourceRoundNumber: roundLimit,
            targetStructureId: targetStructureId,
            finishingPositions: finishingPositions,
            linkType: linkType,
        })) === null || _j === void 0 ? void 0 : _j.link);
    return __assign(__assign({ qualifyingDrawPositionsCount: drawSize, qualifiersCount: qualifiersCount }, SUCCESS), { structure: structure, link: link });
}

function addQualifyingStructure(params) {
    var tournamentRecord = params.tournamentRecord;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var result = addQualifying(params);
    if (result.error)
        return result;
    var qualifyingRoundNumber = params.qualifyingRoundNumber, qualifyingPositions = params.qualifyingPositions, targetStructureId = params.targetStructureId, drawDefinition = params.drawDefinition, structureName = params.structureName, matchUpType = params.matchUpType, drawSize = params.drawSize, drawType = params.drawType;
    var qualifyingDetails = definedAttributes({
        drawId: drawDefinition.drawId,
        qualifyingRoundNumber: qualifyingRoundNumber,
        qualifyingPositions: qualifyingPositions,
        targetStructureId: targetStructureId,
        structureName: structureName,
        matchUpType: matchUpType,
        drawSize: drawSize,
        drawType: drawType,
    });
    var timeItem = {
        itemType: 'addQualifyingStructures',
        itemValue: qualifyingDetails,
    };
    addTournamentTimeItem({ tournamentRecord: tournamentRecord, timeItem: timeItem });
    return result;
}
function addQualifying(params) {
    if (!params.drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!params.targetStructureId)
        return { error: MISSING_STRUCTURE_ID };
    var result = generateQualifyingStructure(params);
    if (result.error)
        return result;
    var structure = result.structure, link = result.link;
    if (!structure || !link)
        return { error: INVALID_VALUES };
    return attachQualifyingStructure({
        tournamentRecord: params.tournamentRecord,
        drawDefinition: params.drawDefinition,
        structure: structure,
        link: link,
    });
}

function substituteParticipant$1(_a) {
    var _b, _c, _d;
    var substituteParticipantId = _a.substituteParticipantId, existingParticipantId = _a.existingParticipantId, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, sideNumber = _a.sideNumber, matchUpId = _a.matchUpId, event = _a.event;
    var stack = 'substituteParticipant';
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    if (!existingParticipantId || !substituteParticipantId)
        return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack: stack });
    var matchUp = findDrawMatchUp({
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
        event: event,
    }).matchUp;
    if (!matchUp)
        return { error: MATCHUP_NOT_FOUND };
    if (!matchUp.collectionId)
        return decorateResult({ result: { error: INVALID_MATCHUP }, stack: stack });
    var matchUpsMap = getMatchUpsMap({ drawDefinition: drawDefinition });
    var inContextDrawMatchUps = getAllDrawMatchUps({
        tournamentParticipants: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants,
        inContext: true,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
    }).matchUps;
    var inContextMatchUp = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.find(function (drawMatchUp) { return drawMatchUp.matchUpId === matchUpId; });
    var inContextDualMatchUp = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.find(function (drawMatchUp) { return drawMatchUp.matchUpId === (inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.matchUpTieId); });
    // ensure that existingParticipantId and substituteParticipantId are on the same team
    var relevantSide = (_b = inContextDualMatchUp === null || inContextDualMatchUp === void 0 ? void 0 : inContextDualMatchUp.sides) === null || _b === void 0 ? void 0 : _b.find(function (side) {
        return side.participant.individualParticipants.some(function (_a) {
            var participantId = _a.participantId;
            return participantId === existingParticipantId;
        });
    });
    if (!relevantSide || (sideNumber && relevantSide.sideNumber !== sideNumber))
        return { error: INVALID_PARTICIPANT_ID };
    // if no sideNumber is provided, segregate available by sideNumber and specify sideNumber
    var availableParticipantIds = (_d = (_c = relevantSide.participant) === null || _c === void 0 ? void 0 : _c.individualParticipants) === null || _d === void 0 ? void 0 : _d.map(getParticipantId).filter(function (participantId) { return participantId !== existingParticipantId; });
    if (!(availableParticipantIds === null || availableParticipantIds === void 0 ? void 0 : availableParticipantIds.includes(substituteParticipantId)))
        return decorateResult({ result: { error: INVALID_PARTICIPANT_ID }, stack: stack });
    return replaceTieMatchUpParticipantId({
        newParticipantId: substituteParticipantId,
        tieMatchUpId: matchUpId,
        existingParticipantId: existingParticipantId,
        substitution: true,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        event: event,
    });
}

function substituteParticipant(params) {
    return substituteParticipant$1(params);
}

function disableTieAutoCalc(_a) {
    var drawDefinition = _a.drawDefinition, matchUpId = _a.matchUpId, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var matchUp = findDrawMatchUp({
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
        event: event,
    }).matchUp;
    return addExtension({
        extension: { name: DISABLE_AUTO_CALC, value: true },
        element: matchUp,
    });
}

function modifyPairAssignment(_a) {
    var e_1, _b, e_2, _c;
    var _d, _e;
    var replacementIndividualParticipantId = _a.replacementIndividualParticipantId, existingIndividualParticipantId = _a.existingIndividualParticipantId, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, participantId = _a.participantId, event = _a.event, uuids = _a.uuids;
    if (!event)
        return { error: MISSING_EVENT };
    if ((event === null || event === void 0 ? void 0 : event.eventType) !== DOUBLES$1)
        return { error: INVALID_EVENT_TYPE };
    if (uuids && !Array.isArray(uuids))
        return { error: INVALID_VALUES };
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (![
        replacementIndividualParticipantId,
        existingIndividualParticipantId,
        participantId,
    ].every(function (id) { return typeof id === 'string'; })) {
        return { error: MISSING_PARTICIPANT_ID };
    }
    // ensure that replacementIndividualPartiicpant is UNPAIRED
    var availableIndividualParticipantIds = ((_d = event === null || event === void 0 ? void 0 : event.entries) === null || _d === void 0 ? void 0 : _d.filter(function (_a) {
        var entryStatus = _a.entryStatus;
        return [UNGROUPED, UNPAIRED].includes(entryStatus);
    }).map(function (_a) {
        var participantId = _a.participantId;
        return participantId;
    })) || [];
    if (!availableIndividualParticipantIds.includes(replacementIndividualParticipantId)) {
        return { error: INVALID_PARTICIPANT_ID };
    }
    var participant = (tournamentRecord.participants || []).find(function (participant) { return participant.participantId === participantId; });
    if ((participant === null || participant === void 0 ? void 0 : participant.participantType) !== PAIR)
        return { error: INVALID_PARTICIPANT, participant: participant };
    var existingIndividualParticipantIds = participant.individualParticipantIds;
    var individualParticipantIds = __spreadArray([
        replacementIndividualParticipantId
    ], __read(existingIndividualParticipantIds.filter(function (individualParticipantId) {
        return individualParticipantId !== existingIndividualParticipantId;
    })), false);
    var existingPairParticipant = getPairedParticipant({
        participantIds: individualParticipantIds,
        tournamentRecord: tournamentRecord,
    }).participant;
    // if no existing pair participant, add new pair participant
    var newPairParticipantId;
    if (!existingPairParticipant) {
        var newPairParticipant = {
            participantId: uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
            participantRole: COMPETITOR,
            individualParticipantIds: individualParticipantIds,
            participantType: PAIR,
        };
        var result = addParticipant({
            participant: newPairParticipant,
            returnParticipant: true,
            tournamentRecord: tournamentRecord,
        });
        if (result.error)
            return result;
        newPairParticipantId = result.participant.participantId;
    }
    else {
        newPairParticipantId = existingPairParticipant.participantId;
    }
    var flightProfile = getFlightProfile({ event: event }).flightProfile;
    if (drawDefinition) {
        // modify all positionAssignments in event, drawDefinition and flight
        var flight = (_e = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _e === void 0 ? void 0 : _e.find(function (_a) {
            var drawId = _a.drawId;
            return drawId === drawDefinition.drawId;
        });
        if (flight) {
            flight.drawEntries = flight.drawEntries.map(function (entry) {
                return entry.participantId === participantId
                    ? __assign(__assign({}, entry), { participantId: newPairParticipantId }) : entry;
            });
        }
        drawDefinition.entries = drawDefinition.entries.map(function (entry) {
            return entry.participantId === participantId
                ? __assign(__assign({}, entry), { participantId: newPairParticipantId }) : entry;
        });
        try {
            // update positionAssignments for all structures within the drawDefinition
            for (var _f = __values(drawDefinition.structures || []), _g = _f.next(); !_g.done; _g = _f.next()) {
                var structure = _g.value;
                if (structure.positionAssignments) {
                    structure.positionAssignments = structure.positionAssignments.map(function (assignment) {
                        return assignment.participantId === participantId
                            ? __assign(__assign({}, assignment), { participantId: newPairParticipantId }) : assignment;
                    });
                }
                else if (structure.structures) {
                    try {
                        for (var _h = (e_2 = void 0, __values(structure.structures)), _j = _h.next(); !_j.done; _j = _h.next()) {
                            var subStructure = _j.value;
                            subStructure.positionAssignments =
                                subStructure.positionAssignments.map(function (assignment) {
                                    return assignment.participantId === participantId
                                        ? __assign(__assign({}, assignment), { participantId: newPairParticipantId }) : assignment;
                                });
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    event.entries = event.entries.map(function (entry) {
        // replace previous pair participantId with newPairParticipantid
        // remove replacmentIndividualParticipantId from event.entries
        return (entry.participantId === participantId && __assign(__assign({}, entry), { participantId: newPairParticipantId })) ||
            // add existingIndividualParticipantId removed from original PAIR to event.entries as UNGROUPED
            (entry.participantId === replacementIndividualParticipantId && __assign(__assign({}, entry), { participantId: existingIndividualParticipantId })) ||
            entry;
    });
    // if participant has no other entries then the pair can be destroyed
    var participantOtherEntries = tournamentRecord.events.some(function (_a) {
        var entries = _a.entries, eventId = _a.eventId, drawDefinitions = _a.drawDefinitions;
        if (event.eventId === eventId) {
            return drawDefinitions.some(function (_a) {
                var drawId = _a.drawId, entries = _a.entries;
                return drawId === (drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.drawId)
                    ? false
                    : entries === null || entries === void 0 ? void 0 : entries.find(function (entry) { return entry.participantId === participantId; });
            });
        }
        else {
            return entries === null || entries === void 0 ? void 0 : entries.find(function (entry) { return entry.participantId === participantId; });
        }
    });
    if (!participantOtherEntries) {
        var result = deleteParticipants({
            addIndividualParticipantsToEvents: false,
            participantIds: [participantId],
            tournamentRecord: tournamentRecord,
        });
        if (result.error)
            return result;
    }
    return __assign(__assign({}, SUCCESS), { participantOtherEntries: participantOtherEntries, newPairParticipantId: newPairParticipantId });
}

// internal use only; set matchUpFormat for a matchUp or structure
function setMatchUpMatchUpFormat(params) {
    var e_1, _a;
    var structureIds = params.structureIds;
    var tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, matchUpFormat = params.matchUpFormat, structureId = params.structureId, matchUpId = params.matchUpId, event = params.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!matchUpFormat)
        return { error: MISSING_MATCHUP_FORMAT };
    if (!isValidMatchUpFormat({ matchUpFormat: matchUpFormat }))
        return { error: UNRECOGNIZED_MATCHUP_FORMAT };
    var stack = 'setMatchUpFormat';
    if (matchUpId) {
        var result = findDrawMatchUp({
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
            event: event,
        });
        if (result.error)
            return result;
        if (!result.matchUp)
            return { error: MATCHUP_NOT_FOUND };
        var matchUp = result.matchUp;
        if ((matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpType) === TEAM$2)
            return {
                error: INVALID_MATCHUP,
                info: 'Cannot set matchUpFormat when { matchUpType: TEAM }',
            };
        matchUp.matchUpFormat = matchUpFormat;
        modifyMatchUpNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            context: stack,
            drawDefinition: drawDefinition,
            matchUp: matchUp,
        });
    }
    else if (Array.isArray(structureIds)) {
        if ((event === null || event === void 0 ? void 0 : event.eventType) === TEAM$2)
            return { error: INVALID_EVENT_TYPE };
        try {
            for (var structureIds_1 = __values(structureIds), structureIds_1_1 = structureIds_1.next(); !structureIds_1_1.done; structureIds_1_1 = structureIds_1.next()) {
                var structureId_1 = structureIds_1_1.value;
                var result = findStructure({ drawDefinition: drawDefinition, structureId: structureId_1 });
                if (result.error)
                    return result;
                if (!result.structure) {
                    return { error: STRUCTURE_NOT_FOUND };
                }
                else {
                    result.structure.matchUpFormat = matchUpFormat;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (structureIds_1_1 && !structureIds_1_1.done && (_a = structureIds_1.return)) _a.call(structureIds_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else if (structureId) {
        if ((event === null || event === void 0 ? void 0 : event.eventType) === TEAM$2)
            return { error: INVALID_EVENT_TYPE };
        var result = findStructure({ drawDefinition: drawDefinition, structureId: structureId });
        if (result.error)
            return result;
        if (!result.structure) {
            return { error: STRUCTURE_NOT_FOUND };
        }
        else {
            result.structure.matchUpFormat = matchUpFormat;
        }
    }
    else if (drawDefinition) {
        drawDefinition.matchUpFormat = matchUpFormat;
    }
    structureIds = structureIds !== null && structureIds !== void 0 ? structureIds : (structureId ? [structureId] : undefined);
    modifyDrawNotice({ drawDefinition: drawDefinition, structureIds: structureIds });
    return __assign({}, SUCCESS);
}

function setMatchUpFormat(params) {
    var e_1, _a, e_2, _b;
    var stack = 'setMatchUpFormat';
    var tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, scheduledDates = params.scheduledDates, stageSequences = params.stageSequences, matchUpFormat = params.matchUpFormat, structureId = params.structureId, eventType = params.eventType, // only SINGLES or DOUBLES
    matchUpId = params.matchUpId, eventId = params.eventId, stages = params.stages, drawId = params.drawId, event = params.event, force = params.force;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!matchUpFormat)
        return { error: MISSING_MATCHUP_FORMAT };
    if (matchUpFormat && !isValidMatchUpFormat({ matchUpFormat: matchUpFormat }))
        return decorateResult({
            result: { error: UNRECOGNIZED_MATCHUP_FORMAT, matchUpFormat: matchUpFormat },
            stack: stack,
        });
    if (scheduledDates && !Array.isArray(scheduledDates))
        return decorateResult({
            result: { error: INVALID_VALUES, scheduledDates: scheduledDates },
            stack: stack,
        });
    if (eventType && ![SINGLES$1, DOUBLES$1].includes(eventType))
        return decorateResult({ result: { error: INVALID_EVENT_TYPE }, stack: stack });
    var modificationsCount = 0;
    var structureIds = params.structureIds || (structureId && [structureId].filter(Boolean)) || [];
    var eventIds = params.eventIds || (eventId && [eventId].filter(Boolean)) || [];
    var drawIds = params.drawIds || (drawId && [drawId].filter(Boolean)) || [];
    if ((structureId || (structureIds === null || structureIds === void 0 ? void 0 : structureIds.length)) && !drawDefinition) {
        return decorateResult({
            result: { error: MISSING_DRAW_DEFINITION },
            stack: stack,
        });
    }
    if (drawId && matchUpId && drawDefinition) {
        var result = setMatchUpMatchUpFormat({
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpFormat: matchUpFormat,
            structureIds: structureIds,
            structureId: structureId,
            matchUpId: matchUpId,
        });
        if (result.error)
            return result;
        modificationsCount += 1;
    }
    var processStructures = function (drawDefinition) {
        var e_3, _a, e_4, _b;
        var modifiedStructureIds = [];
        try {
            for (var _c = __values(drawDefinition.structures || []), _d = _c.next(); !_d.done; _d = _c.next()) {
                var structure = _d.value;
                if ((Array.isArray(stages) && !stages.includes(structure.stage)) ||
                    (Array.isArray(stageSequences) &&
                        !stageSequences.includes(structure.stageSequence)) ||
                    ((structureIds === null || structureIds === void 0 ? void 0 : structureIds.length) && !structureIds.includes(structure.structureId)))
                    continue;
                if ((structureIds === null || structureIds === void 0 ? void 0 : structureIds.length) && structure.matchUpFormat !== matchUpFormat) {
                    structure.matchUpFormat = matchUpFormat;
                    modifiedStructureIds.push(structure.structureId);
                    modificationsCount += 1;
                }
                var matchUps = (force || scheduledDates) &&
                    getAllStructureMatchUps({
                        matchUpFilters: { matchUpStatuses: [TO_BE_PLAYED] },
                        structure: structure,
                    }).matchUps;
                var inContextMatchUps = scheduledDates &&
                    getAllStructureMatchUps({
                        matchUpFilters: { matchUpStatuses: [TO_BE_PLAYED] },
                        contextFilters: { scheduledDates: scheduledDates },
                        afterRecoveryTimes: false,
                        inContext: true,
                        structure: structure,
                    }).matchUps;
                if (matchUps === null || matchUps === void 0 ? void 0 : matchUps.length) {
                    var matchUpIdsToModify = inContextMatchUps
                        ? inContextMatchUps.map(getMatchUpId)
                        : matchUps.map(getMatchUpId);
                    try {
                        for (var matchUps_1 = (e_4 = void 0, __values(matchUps)), matchUps_1_1 = matchUps_1.next(); !matchUps_1_1.done; matchUps_1_1 = matchUps_1.next()) {
                            var matchUp = matchUps_1_1.value;
                            if (matchUpIdsToModify.includes(matchUp.matchUpId)) {
                                matchUp.matchUpFormat = (scheduledDates === null || scheduledDates === void 0 ? void 0 : scheduledDates.length)
                                    ? matchUpFormat
                                    : undefined; // force to inherit structure matchUpFormat
                                modifyMatchUpNotice({
                                    tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                                    eventId: event === null || event === void 0 ? void 0 : event.eventId,
                                    context: stack,
                                    drawDefinition: drawDefinition,
                                    matchUp: matchUp,
                                });
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (matchUps_1_1 && !matchUps_1_1.done && (_b = matchUps_1.return)) _b.call(matchUps_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (!modifiedStructureIds.length &&
            drawDefinition.matchUpFormat !== matchUpFormat) {
            drawDefinition.matchUpFormat = matchUpFormat;
            modificationsCount += 1;
        }
        return modifiedStructureIds;
    };
    try {
        for (var _c = __values(tournamentRecord.events || []), _d = _c.next(); !_d.done; _d = _c.next()) {
            var event_1 = _d.value;
            if (((eventIds === null || eventIds === void 0 ? void 0 : eventIds.length) && !eventIds.includes(event_1.eventId)) ||
                (eventType && eventType !== event_1.eventType) ||
                eventType === TEAM$2) {
                continue;
            }
            if (Array.isArray(stageSequences) ||
                Array.isArray(stages) ||
                (structureIds === null || structureIds === void 0 ? void 0 : structureIds.length) ||
                (drawIds === null || drawIds === void 0 ? void 0 : drawIds.length)) {
                try {
                    for (var _e = (e_2 = void 0, __values(event_1.drawDefinitions || [])), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var drawDefinition_1 = _f.value;
                        if (Array.isArray(drawIds) && !drawIds.includes(drawDefinition_1.drawId))
                            continue;
                        var modifiedStructureIds = processStructures(drawDefinition_1);
                        modifyDrawNotice({
                            structureIds: modifiedStructureIds,
                            drawDefinition: drawDefinition_1,
                        });
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            else if (event_1.matchUpFormat !== matchUpFormat) {
                event_1.matchUpFormat = matchUpFormat;
                modificationsCount += 1;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (!modificationsCount)
        return __assign(__assign({}, SUCCESS), { info: NO_MODIFICATIONS_APPLIED });
    return __assign(__assign({}, SUCCESS), { modificationsCount: modificationsCount });
}

function resetMatchUpLineUps(_a) {
    var _b, _c;
    var _d = _a.inheritance, inheritance = _d === void 0 ? true : _d, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, matchUpId = _a.matchUpId, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var matchUp = (_b = findDrawMatchUp({
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
    })) === null || _b === void 0 ? void 0 : _b.matchUp;
    if (!(matchUp === null || matchUp === void 0 ? void 0 : matchUp.tieMatchUps))
        return { error: INVALID_MATCHUP };
    var inContextMatchUp = (_c = findDrawMatchUp({
        inContext: true,
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
        event: event,
    })) === null || _c === void 0 ? void 0 : _c.matchUp;
    var modificationsCount = 0;
    ((matchUp === null || matchUp === void 0 ? void 0 : matchUp.sides) || []).forEach(function (side) {
        if (side.lineUp)
            delete side.lineUp;
    });
    ((inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.sides) || []).forEach(function (side) {
        modificationsCount += 1;
        if (inheritance === false) {
            var tieFormat = inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.tieFormat;
            var participantId = side.participantId;
            if (tieFormat && participantId) {
                updateTeamLineUp({
                    drawDefinition: drawDefinition,
                    participantId: participantId,
                    lineUp: [],
                    tieFormat: tieFormat,
                });
            }
        }
        modifyMatchUpNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            context: 'resetMatchUpLineUps',
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            drawDefinition: drawDefinition,
            matchUp: matchUp,
        });
    });
    return __assign(__assign({}, SUCCESS), { modificationsCount: modificationsCount });
}

function getPositionRangeMap(_a) {
    var _b;
    var playoffGroups = _a.playoffGroups, drawDefinition = _a.drawDefinition, structureId = _a.structureId;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (typeof structureId !== 'string' || !Array.isArray(playoffGroups)) {
        return { error: INVALID_VALUES };
    }
    var playoffGroupFinishingPostions = playoffGroups
        .map(function (_a) {
        var finishingPositions = _a.finishingPositions;
        return finishingPositions;
    })
        .flat();
    var availablePlayoffProfiles = getAvailablePlayoffProfiles({
        drawDefinition: drawDefinition,
        structureId: structureId,
    });
    var playoffFinishingPositionRanges = (_b = availablePlayoffProfiles.playoffFinishingPositionRanges) === null || _b === void 0 ? void 0 : _b.filter(function (r) {
        return playoffGroupFinishingPostions.includes(r.finishingPosition);
    });
    var positionRangeMap = playoffFinishingPositionRanges === null || playoffFinishingPositionRanges === void 0 ? void 0 : playoffFinishingPositionRanges.reduce(function (positionMap, positionDetail) {
        positionMap[positionDetail.finishingPosition] = positionDetail;
        return positionMap;
    }, {});
    return { positionRangeMap: positionRangeMap };
}

function buildFeedRound(_a) {
    var includeMatchUpType = _a.includeMatchUpType, drawPosition = _a.drawPosition, roundNumber = _a.roundNumber, matchUpType = _a.matchUpType, idPrefix = _a.idPrefix, matchUps = _a.matchUps, isMock = _a.isMock, uuids = _a.uuids, nodes = _a.nodes, fed = _a.fed;
    var feedRoundMatchUpsCount = nodes.length;
    var initialGroupDrawPosition = drawPosition
        ? drawPosition - feedRoundMatchUpsCount
        : undefined;
    var drawPositionGroup = generateRange(0, feedRoundMatchUpsCount).map(function (value) {
        return initialGroupDrawPosition ? initialGroupDrawPosition + value : undefined;
    });
    var roundNodes = [];
    for (var nodeIndex = 0; nodeIndex < feedRoundMatchUpsCount; nodeIndex++) {
        var feedDrawPosition = drawPositionGroup.shift();
        var feedArm = {
            drawPosition: feedDrawPosition,
            fed: fed + 1,
            feed: true,
        };
        var position = nodes[nodeIndex];
        position.roundNumber = roundNumber - 1;
        var matchUpId = generateMatchUpId({
            roundPosition: position.roundPosition,
            roundNumber: roundNumber,
            idPrefix: idPrefix,
            uuids: uuids,
        });
        var newMatchUp = {
            roundPosition: position.roundPosition,
            drawPositions: [feedDrawPosition],
            matchUpStatus: TO_BE_PLAYED,
            roundNumber: roundNumber,
            matchUpId: matchUpId,
        };
        // matchUpType is derived for inContext matchUps from structure or drawDefinition
        if (includeMatchUpType)
            newMatchUp.matchUpType = matchUpType;
        if (isMock)
            newMatchUp.isMock = true;
        matchUps.push(newMatchUp);
        var roundNode = { children: [position, feedArm] };
        roundNodes.push(roundNode);
    }
    var nextDrawPosition = drawPosition
        ? drawPosition - feedRoundMatchUpsCount
        : undefined;
    return { roundNodes: roundNodes, matchUps: matchUps, drawPosition: nextDrawPosition };
}

function feedInMatchUps(params) {
    var e_1, _a;
    var _b;
    var drawSize = params.drawSize;
    var feedRoundsProfile = params.feedRoundsProfile, _c = params.feedRounds, feedRounds = _c === void 0 ? 0 : _c, _d = params.skipRounds, skipRounds = _d === void 0 ? 0 : _d, baseDrawSize = params.baseDrawSize;
    var linkFedFinishingRoundNumbers = params.linkFedFinishingRoundNumbers, finishingPositionOffset = params.finishingPositionOffset, linkFedRoundNumbers = params.linkFedRoundNumbers, feedsFromFinal = params.feedsFromFinal, isConsolation = params.isConsolation, matchUpType = params.matchUpType, idPrefix = params.idPrefix, isMock = params.isMock, uuids = params.uuids, fmlc = params.fmlc;
    // calculate the number of rounds and the number of matchUps in each round
    // for normal elimination structure
    baseDrawSize = baseDrawSize !== null && baseDrawSize !== void 0 ? baseDrawSize : getBaseDrawSize(drawSize);
    var baseDrawRounds = roundMatchCounts({ drawSize: baseDrawSize });
    var baseRoundsCount = baseDrawRounds.length;
    var positionsFed = 0;
    if (feedRoundsProfile === null || feedRoundsProfile === void 0 ? void 0 : feedRoundsProfile.length) {
        positionsFed = feedRoundsProfile.reduce(function (a, b) { return a + b; }, 0);
    }
    else if (drawSize) {
        // having a drawSize defined trumps other configuration options
        var positionsToFeed_1 = drawSize - baseDrawSize;
        feedRoundsProfile = baseDrawRounds.filter(function (feedSize) {
            if (feedSize <= positionsToFeed_1) {
                positionsToFeed_1 -= feedSize;
                return true;
            }
            return false;
        });
        positionsFed = feedRoundsProfile.reduce(function (a, b) { return a + b; }, 0);
        feedRounds = feedRoundsProfile.length;
    }
    else {
        // if skipRounds is set higher than baseRoundsCount then there are no feedRounds
        if (skipRounds >= baseRoundsCount) {
            feedRounds = 0;
        }
        else if (feedsFromFinal) {
            // if feedsFromFinal is defined, calculate number of feed rounds from Final Match
            // e.g. feedsFromFinal is 1 for Semifinal, 2 for QuarterFinals, 3 for Round of 16
            feedRounds = baseRoundsCount - feedsFromFinal;
            skipRounds = 0;
        }
        // Given the above, feedsFromFinal trumps skipRounds
        // and skipRounds >= baseRoundsCount negates feedRounds
        feedRoundsProfile = baseDrawRounds.filter(function (feedSize, i) {
            if (feedsFromFinal && !feedRounds)
                return 0;
            if (feedRounds && i >= skipRounds + feedRounds)
                return 0;
            if (i < skipRounds)
                return 0;
            return feedSize;
        });
        positionsFed = feedRoundsProfile.reduce(function (a, b) { return a + b; }, 0);
        feedRounds = feedRoundsProfile.length;
    }
    var allRounds = __spreadArray(__spreadArray([], __read(baseDrawRounds), false), __read(feedRoundsProfile), false).sort(function (a, b) { return b - a; });
    var roundsCount = allRounds.length;
    // rounds which have linkFed participants can be specified two ways:
    // linkFedRoundNumbers[] and linkFedFinishingRoundNumbers[]
    // the difference being which end of the draw structure === 1
    var linkFedRoundNumbersIndices = __spreadArray(__spreadArray([], __read((linkFedRoundNumbers !== null && linkFedRoundNumbers !== void 0 ? linkFedRoundNumbers : []).map(function (n) { return n - 1; })), false), __read((linkFedFinishingRoundNumbers !== null && linkFedFinishingRoundNumbers !== void 0 ? linkFedFinishingRoundNumbers : []).map(function (n) { return roundsCount - n; })), false);
    // positionsFedByLinks can be determined by summing the values in allRounds
    // which are found at linkFedRoundNumbersIndices
    var positionsFedByLinks = linkFedRoundNumbersIndices
        .map(function (i) { return allRounds[i]; })
        .reduce(function (a, b) { return a + b; }, 0);
    positionsFed = positionsFed - positionsFedByLinks;
    // initialize round creation variables
    var fed = 0; // keep track of even/odd feed rounds
    var matchUps = []; // accumulate matchUps
    var roundNodes; // an array of nodes
    var roundNumber = 1; // initial roundNumber
    // firstRoundDrawPositions are generated and assigned drawPositions
    var firstRoundDrawPositions = generateRange(0, baseDrawSize).map(function (_, i) { return ({
        drawPosition: i + 1 + positionsFed,
    }); });
    // initial nodes fed into buildRound
    var nodes = firstRoundDrawPositions;
    // drawPosition within structure; offset used for feedRounds
    var drawPosition = positionsFed + 1;
    var _loop_1 = function (baseDrawRound) {
        var _e;
        (_e = buildRound({
            matchUpType: matchUpType,
            roundNumber: roundNumber,
            idPrefix: idPrefix,
            matchUps: matchUps,
            isMock: isMock,
            nodes: nodes,
            uuids: uuids,
        }), roundNodes = _e.roundNodes, matchUps = _e.matchUps);
        roundNumber++;
        if (feedRoundsProfile.includes(baseDrawRound)) {
            var roundIterations = instanceCount(feedRoundsProfile)[baseDrawRound];
            var iterationRange = generateRange(0, roundIterations);
            var finishingRoundNumber = roundsCount + 1 - roundNumber;
            var isLinkFedRound_1 = (_b = linkFedFinishingRoundNumbers === null || linkFedFinishingRoundNumbers === void 0 ? void 0 : linkFedFinishingRoundNumbers.includes(finishingRoundNumber)) !== null && _b !== void 0 ? _b : linkFedRoundNumbers === null || linkFedRoundNumbers === void 0 ? void 0 : linkFedRoundNumbers.includes(roundNumber);
            iterationRange.forEach(function () {
                var _a;
                var iterationDrawPosition = (!isLinkFedRound_1 && drawPosition) || undefined;
                (_a = buildFeedRound({
                    drawPosition: iterationDrawPosition,
                    nodes: roundNodes,
                    matchUpType: matchUpType,
                    roundNumber: roundNumber,
                    idPrefix: idPrefix,
                    matchUps: matchUps,
                    isMock: isMock,
                    uuids: uuids,
                    fed: fed,
                }), roundNodes = _a.roundNodes, matchUps = _a.matchUps, drawPosition = _a.drawPosition);
                roundNumber++;
                fed += 1;
            });
        }
        nodes = roundNodes;
    };
    try {
        for (var baseDrawRounds_1 = __values(baseDrawRounds), baseDrawRounds_1_1 = baseDrawRounds_1.next(); !baseDrawRounds_1_1.done; baseDrawRounds_1_1 = baseDrawRounds_1.next()) {
            var baseDrawRound = baseDrawRounds_1_1.value;
            _loop_1(baseDrawRound);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (baseDrawRounds_1_1 && !baseDrawRounds_1_1.done && (_a = baseDrawRounds_1.return)) _a.call(baseDrawRounds_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // because roundNumber was incremented at the end of the while loop
    if (roundsCount !== roundNumber - 1)
        console.log('ERROR');
    // if this is a feed-in consolation then finishing drawPositions must be offset ...
    // ... by the number of drawPositions which will be fed into the consolation draw
    // final drawPositions will be played off twice up until the final feed round
    var consolationFinish = baseDrawSize - positionsFed;
    var modifiedFinishingPositionOffset = isConsolation
        ? consolationFinish
        : finishingPositionOffset;
    matchUps = addFinishingRounds({
        finishingPositionOffset: modifiedFinishingPositionOffset,
        positionsFed: positionsFed,
        roundsCount: roundsCount,
        matchUps: matchUps,
        fmlc: fmlc,
    });
    var draw = (roundNodes === null || roundNodes === void 0 ? void 0 : roundNodes.length) ? roundNodes[0] : roundNodes;
    if (draw) {
        draw.roundNumber = roundNumber - 1;
        draw.matchUps = matchUps;
    }
    return { draw: draw, matchUps: matchUps, roundsCount: roundsCount };
    function getBaseDrawSize(drawSize) {
        var nearestP2 = nearestPowerOf2(drawSize);
        return nearestP2 > drawSize ? nearestP2 / 2 : nearestP2;
    }
}
// returns an array of the number of matchUps in each round of an elimination draw
function roundMatchCounts(_a) {
    var drawSize = _a.drawSize;
    var rounds = Math.ceil(Math.log(drawSize) / Math.log(2));
    var range = generateRange(0, rounds).reverse();
    return range.map(function (r) { return Math.pow(2, r); });
}

function generatePlayoffStructures(params) {
    var _a, _b, _c, _d, _e;
    var _f = params.finishingPositionOffset, finishingPositionOffset = _f === void 0 ? 0 : _f, addNameBaseToAttributeName = params.addNameBaseToAttributeName, playoffStructureNameBase = params.playoffStructureNameBase, finishingPositionNaming = params.finishingPositionNaming, finishingPositionLimit = params.finishingPositionLimit, playoffAttributes = params.playoffAttributes, _g = params.stageSequence, stageSequence = _g === void 0 ? 1 : _g, _h = params.exitProfile, exitProfile = _h === void 0 ? '0' : _h, exitProfileLimit = params.exitProfileLimit, roundOffsetLimit = params.roundOffsetLimit, _j = params.roundOffset, roundOffset = _j === void 0 ? 0 : _j, drawDefinition = params.drawDefinition, staggeredEntry = params.staggeredEntry, // not propagated to child structurs
    sequenceLimit = params.sequenceLimit, _k = params.stage, stage = _k === void 0 ? MAIN : _k, drawSize = params.drawSize, idPrefix = params.idPrefix, isMock = params.isMock, uuids = params.uuids;
    var generateStructure = !playoffAttributes || !exitProfileLimit || (playoffAttributes === null || playoffAttributes === void 0 ? void 0 : playoffAttributes[exitProfile]);
    if (!generateStructure ||
        drawSize < 2 ||
        (sequenceLimit && stageSequence > sequenceLimit))
        return {};
    var allMatchUps = [];
    var structures = [];
    var links = [];
    var matchUpType = (_a = params.matchUpType) !== null && _a !== void 0 ? _a : drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.matchUpType;
    var finishingPositionsFrom = finishingPositionOffset + 1;
    var finishingPositionsTo = finishingPositionOffset + drawSize;
    var finishingPositionRange = "".concat(finishingPositionsFrom, "-").concat(finishingPositionsTo);
    var attributeProfile = playoffAttributes === null || playoffAttributes === void 0 ? void 0 : playoffAttributes[exitProfile];
    var base = (playoffStructureNameBase && "".concat(playoffStructureNameBase, " ")) || '';
    var customNaming = (_b = playoffAttributes === null || playoffAttributes === void 0 ? void 0 : playoffAttributes[finishingPositionRange]) !== null && _b !== void 0 ? _b : finishingPositionNaming === null || finishingPositionNaming === void 0 ? void 0 : finishingPositionNaming[finishingPositionRange];
    var structureName = params.structureName ||
        (customNaming === null || customNaming === void 0 ? void 0 : customNaming.name) ||
        ((attributeProfile === null || attributeProfile === void 0 ? void 0 : attributeProfile.name) &&
            (addNameBaseToAttributeName
                ? "".concat(base).concat(attributeProfile === null || attributeProfile === void 0 ? void 0 : attributeProfile.name)
                : attributeProfile.name)) ||
        "".concat(base).concat(finishingPositionRange);
    var structureAbbreviation = (_c = customNaming === null || customNaming === void 0 ? void 0 : customNaming.abbreviation) !== null && _c !== void 0 ? _c : attributeProfile === null || attributeProfile === void 0 ? void 0 : attributeProfile.abbreviation;
    var structureId = (_e = (_d = params.structureId) !== null && _d !== void 0 ? _d : attributeProfile === null || attributeProfile === void 0 ? void 0 : attributeProfile.structureId) !== null && _e !== void 0 ? _e : uuids === null || uuids === void 0 ? void 0 : uuids.pop();
    var mainParams = {
        idPrefix: idPrefix && "".concat(idPrefix, "-").concat(structureName, "-RP"),
        finishingPositionOffset: finishingPositionOffset,
        matchUpType: matchUpType,
        drawSize: drawSize,
        isMock: isMock,
        uuids: uuids,
    };
    var matchUps = (staggeredEntry
        ? feedInMatchUps(mainParams) // should only every apply to initial structure
        : treeMatchUps(mainParams)).matchUps;
    var structure = structureTemplate({
        structureAbbreviation: structureAbbreviation,
        stageSequence: stageSequence,
        structureName: structureName,
        matchUpType: matchUpType,
        roundOffset: roundOffset,
        structureId: structureId,
        matchUps: matchUps,
        stage: stage,
    });
    allMatchUps.push.apply(allMatchUps, __spreadArray([], __read(matchUps), false));
    structures.push(structure);
    var rounds = Math.ceil(Math.log(drawSize) / Math.log(2));
    var roundsToPlayOff = roundOffsetLimit
        ? Math.min(roundOffsetLimit - roundOffset, rounds)
        : !finishingPositionLimit || finishingPositionsFrom < finishingPositionLimit
            ? rounds
            : 0;
    if (drawSize > 2) {
        generateRange(1, roundsToPlayOff + 1).forEach(function (roundNumber) {
            return generateChildStructures(roundNumber);
        });
    }
    return __assign({ structureId: structure.structureId, matchUps: allMatchUps, structureName: structureName, structures: structures, links: links }, SUCCESS);
    function generateChildStructures(roundNumber) {
        var playoffDrawPositions = drawSize / Math.pow(2, roundNumber);
        if (playoffDrawPositions < 2)
            return;
        var childFinishingPositionOffset = drawSize / Math.pow(2, roundNumber) + finishingPositionOffset;
        if (finishingPositionLimit &&
            childFinishingPositionOffset + 1 > finishingPositionLimit)
            return;
        var _a = generatePlayoffStructures({
            finishingPositionOffset: childFinishingPositionOffset,
            exitProfile: "".concat(exitProfile, "-").concat(roundNumber),
            roundOffset: roundOffset + roundNumber,
            stageSequence: stageSequence + 1,
            drawSize: playoffDrawPositions,
            addNameBaseToAttributeName: addNameBaseToAttributeName,
            playoffStructureNameBase: playoffStructureNameBase,
            finishingPositionNaming: finishingPositionNaming,
            finishingPositionLimit: finishingPositionLimit,
            playoffAttributes: playoffAttributes,
            exitProfileLimit: exitProfileLimit,
            roundOffsetLimit: roundOffsetLimit,
            drawDefinition: drawDefinition,
            sequenceLimit: sequenceLimit,
            matchUpType: matchUpType,
            idPrefix: idPrefix,
            uuids: uuids,
            stage: stage,
        }), childStructures = _a.structures, targetStructureId = _a.structureId, childMatchUps = _a.matchUps, childLinks = _a.links;
        if (structure.structureId && targetStructureId) {
            var link = {
                linkType: LOSER,
                source: {
                    roundNumber: roundNumber,
                    structureId: structure.structureId,
                },
                target: {
                    roundNumber: 1,
                    feedProfile: TOP_DOWN,
                    structureId: targetStructureId,
                },
            };
            if (childLinks && structure)
                childLinks.push(link);
            if (childLinks === null || childLinks === void 0 ? void 0 : childLinks.length)
                links.push.apply(links, __spreadArray([], __read(childLinks), false));
        }
        if (childStructures === null || childStructures === void 0 ? void 0 : childStructures.length)
            structures.push.apply(structures, __spreadArray([], __read(childStructures), false));
        if (childMatchUps === null || childMatchUps === void 0 ? void 0 : childMatchUps.length)
            allMatchUps.push.apply(allMatchUps, __spreadArray([], __read(childMatchUps), false));
        return {
            structureId: targetStructureId,
            childLinks: childLinks,
            structures: structures,
        };
    }
}

function firstRoundLoserConsolation(params) {
    var _a, _b, _c, _d;
    var _e = params.finishingPositionOffset, finishingPositionOffset = _e === void 0 ? 0 : _e, playoffAttributes = params.playoffAttributes, _f = params.stageSequence, stageSequence = _f === void 0 ? 1 : _f, staggeredEntry = params.staggeredEntry, structureName = params.structureName, _g = params.stage, stage = _g === void 0 ? MAIN : _g, matchUpType = params.matchUpType, structureId = params.structureId, idPrefix = params.idPrefix, drawSize = params.drawSize, isMock = params.isMock, uuids = params.uuids;
    var mainParams = {
        finishingPositionOffset: finishingPositionOffset,
        matchUpType: matchUpType,
        drawSize: drawSize,
        idPrefix: idPrefix,
        isMock: isMock,
        uuids: uuids,
    };
    var matchUps = (staggeredEntry
        ? feedInMatchUps(mainParams)
        : treeMatchUps(mainParams)).matchUps;
    var mainStructure = structureTemplate({
        structureName: structureName || ((_a = playoffAttributes === null || playoffAttributes === void 0 ? void 0 : playoffAttributes['0']) === null || _a === void 0 ? void 0 : _a.name) || constantToString(MAIN),
        structureId: structureId || (uuids === null || uuids === void 0 ? void 0 : uuids.pop()),
        stageSequence: stageSequence,
        matchUpType: matchUpType,
        matchUps: matchUps,
        stage: stage,
    });
    var structures = [mainStructure];
    var links = [];
    if (drawSize > 2) {
        var consolationDrawPositions = drawSize / 2;
        var consolationMatchUps = treeMatchUps({
            finishingPositionOffset: finishingPositionOffset + consolationDrawPositions,
            idPrefix: idPrefix && "".concat(idPrefix, "-c"),
            drawSize: consolationDrawPositions,
            matchUpType: matchUpType,
            isMock: isMock,
        }).matchUps;
        var consolation = constantToString(CONSOLATION);
        var consolationStructureName = (_d = (_c = (_b = playoffAttributes === null || playoffAttributes === void 0 ? void 0 : playoffAttributes['0-1']) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : params.consolationStructureName) !== null && _d !== void 0 ? _d : (structureName ? "".concat(structureName, " ").concat(consolation) : consolation);
        var consolationStructure = structureTemplate({
            structureName: consolationStructureName,
            matchUps: consolationMatchUps,
            structureId: uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
            stage: CONSOLATION,
            stageSequence: 1,
            matchUpType: matchUpType,
        });
        structures.push(consolationStructure);
        var link = {
            linkType: LOSER,
            source: {
                roundNumber: 1,
                structureId: mainStructure.structureId,
            },
            target: {
                roundNumber: 1,
                feedProfile: TOP_DOWN,
                structureId: consolationStructure.structureId,
            },
        };
        links.push(link);
    }
    return __assign(__assign({}, SUCCESS), { structures: structures, links: links });
}

function feedInLinks(_a) {
    var consolationStructure = _a.consolationStructure, _b = _a.roundOffset, roundOffset = _b === void 0 ? 0 : _b, mainStructure = _a.mainStructure, roundsCount = _a.roundsCount, feedPolicy = _a.feedPolicy, fmlc = _a.fmlc;
    var consolationMatchUps = consolationStructure.matchUps;
    var roundsFed = consolationMatchUps.reduce(function (p, matchUp) {
        var drawPositions = (matchUp.drawPositions || []).filter(Boolean);
        return drawPositions.length && !p.includes(matchUp.roundNumber)
            ? p.concat(matchUp.roundNumber)
            : p;
    }, []);
    var roundGroupedOrder = (feedPolicy === null || feedPolicy === void 0 ? void 0 : feedPolicy.roundGroupedOrder) || [];
    var roundFeedProfiles = feedPolicy === null || feedPolicy === void 0 ? void 0 : feedPolicy.roundFeedProfiles;
    // range excludes final round which is final matchUp
    return generateRange(1 + roundOffset, roundsCount + 1 + roundOffset)
        .map(function (roundNumber) {
        var feedProfile = roundFeedProfiles && roundFeedProfiles[roundNumber - 1]
            ? roundFeedProfiles[roundNumber - 1]
            : roundNumber % 2
                ? TOP_DOWN
                : BOTTOM_UP;
        // after first two rounds of target feed, matchUps are every other round
        var targetRound = roundNumber - roundOffset <= 2
            ? roundNumber - roundOffset
            : (roundNumber - roundOffset - 2) * 2 + 2;
        var link = {
            linkType: LOSER,
            source: {
                roundNumber: roundNumber,
                structureId: mainStructure.structureId,
            },
            target: {
                feedProfile: feedProfile,
                roundNumber: targetRound,
                structureId: consolationStructure.structureId,
            },
        };
        var groupedOrder = roundGroupedOrder[roundNumber - 1];
        if (groupedOrder)
            link.target.groupedOrder = groupedOrder;
        if (getDevContext()) {
            link.source.structureName = mainStructure.structureName;
            link.target.structureName = consolationStructure.structureName;
        }
        if (roundNumber === 2 && fmlc) {
            link.linkCondition = FIRST_MATCHUP;
            link.target.feedProfile = TOP_DOWN;
        }
        return roundsFed.includes(targetRound) ? link : undefined;
    })
        .filter(Boolean);
}

function generateCurtisConsolation(params) {
    var _a, _b, _c, _d, _e;
    var playoffStructureNameBase = params.playoffStructureNameBase, finishingPositionOffset = params.finishingPositionOffset, _f = params.stageSequence, stageSequence = _f === void 0 ? 1 : _f, playoffAttributes = params.playoffAttributes, structureNameMap = params.structureNameMap, staggeredEntry = params.staggeredEntry, _g = params.stage, stage = _g === void 0 ? MAIN : _g, matchUpType = params.matchUpType, structureId = params.structureId, drawSize = params.drawSize, idPrefix = params.idPrefix, isMock = params.isMock, uuids = params.uuids;
    var mainParams = {
        finishingPositionOffset: finishingPositionOffset,
        matchUpType: matchUpType,
        drawSize: drawSize,
        idPrefix: idPrefix,
        isMock: isMock,
        uuids: uuids,
    };
    var _h = staggeredEntry
        ? feedInMatchUps(mainParams)
        : treeMatchUps(mainParams), matchUps = _h.matchUps, mainDrawRoundsCount = _h.roundsCount;
    var structureName = (_c = (_a = params.structureName) !== null && _a !== void 0 ? _a : (_b = playoffAttributes === null || playoffAttributes === void 0 ? void 0 : playoffAttributes['0']) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : constantToString(MAIN);
    var mainStructure = structureTemplate({
        structureId: structureId || (uuids === null || uuids === void 0 ? void 0 : uuids.pop()),
        structureName: structureName,
        stageSequence: stageSequence,
        matchUpType: matchUpType,
        matchUps: matchUps,
        stage: stage,
    });
    var structures = [mainStructure];
    var links = [];
    if (drawSize > 2) {
        var feedRoundOffsets = [0, 2].slice(0, drawSize / 16);
        var consolationItems = feedRoundOffsets.map(function (roundOffset, index) {
            var stageSequence = index + 1;
            var consolationStructure = consolationFeedStructure({
                idPrefix: idPrefix && "".concat(idPrefix, "-c").concat(index),
                structureId: uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
                playoffStructureNameBase: playoffStructureNameBase,
                playoffAttributes: playoffAttributes,
                structureNameMap: structureNameMap,
                stageSequence: stageSequence,
                roundOffset: roundOffset,
                matchUpType: matchUpType,
                drawSize: drawSize,
                isMock: isMock,
                index: index,
                uuids: uuids,
            }).consolationStructure;
            structures.push(consolationStructure);
            var links = feedInLinks({
                consolationStructure: consolationStructure,
                roundsCount: 2,
                mainStructure: mainStructure,
                roundOffset: roundOffset,
            });
            return { consolationStructure: consolationStructure, links: links };
        });
        var consolationLinks = consolationItems.map(function (item) { return item.links; }).flat();
        links.push.apply(links, __spreadArray([], __read(consolationLinks), false));
        // only add 3-4 playoff structure
        // 1. if there is one consolation round, drawSize === 16
        // 2. if drawSize > 32
        // when drawSize === 32 then all rounds feed into the two consolation structures
        if ((drawSize >= 4 && drawSize <= 16) || drawSize > 32) {
            var playoffMatchUps = treeMatchUps({
                idPrefix: idPrefix && "".concat(idPrefix, "-p3t4"),
                finishingPositionOffset: 2,
                drawSize: 2,
                matchUpType: matchUpType,
                isMock: isMock,
            }).matchUps;
            var defaultName = (_e = (_d = playoffAttributes === null || playoffAttributes === void 0 ? void 0 : playoffAttributes['3-4']) === null || _d === void 0 ? void 0 : _d.name) !== null && _e !== void 0 ? _e : constantToString(PLAY_OFF);
            var mappedStructureName = (structureNameMap === null || structureNameMap === void 0 ? void 0 : structureNameMap[defaultName]) || defaultName;
            var structureName_1 = playoffStructureNameBase
                ? "".concat(playoffStructureNameBase, " ").concat(mappedStructureName)
                : mappedStructureName;
            var playoffStructure = structureTemplate({
                structureId: uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
                matchUps: playoffMatchUps,
                stageSequence: 2,
                stage: PLAY_OFF,
                structureName: structureName_1,
                matchUpType: matchUpType,
            });
            var playoffLink = {
                linkType: LOSER,
                source: {
                    roundNumber: mainDrawRoundsCount - 1,
                    structureId: mainStructure.structureId,
                },
                target: {
                    structureId: playoffStructure.structureId,
                    feedProfile: TOP_DOWN,
                    roundNumber: 1,
                },
            };
            structures.push(playoffStructure);
            links.push(playoffLink);
        }
    }
    return __assign({ structures: structures, links: links }, SUCCESS);
}
function consolationFeedStructure(_a) {
    var _b, _c;
    var playoffStructureNameBase = _a.playoffStructureNameBase, _d = _a.stageSequence, stageSequence = _d === void 0 ? 1 : _d, playoffAttributes = _a.playoffAttributes, structureNameMap = _a.structureNameMap, _e = _a.roundOffset, roundOffset = _e === void 0 ? 0 : _e, matchUpType = _a.matchUpType, structureId = _a.structureId, idPrefix = _a.idPrefix, drawSize = _a.drawSize, isMock = _a.isMock, index = _a.index, uuids = _a.uuids;
    var consolationDrawPositions = drawSize / (2 * Math.pow(2, roundOffset));
    var _f = feedInMatchUps({
        finishingPositionOffset: consolationDrawPositions,
        baseDrawSize: consolationDrawPositions,
        isConsolation: true,
        feedRounds: 1,
        matchUpType: matchUpType,
        idPrefix: idPrefix,
        isMock: isMock,
        uuids: uuids,
    }), consolationMatchUps = _f.matchUps, consolationRoundsCount = _f.roundsCount;
    var indexedStructureName = (index === 0 && ((_b = playoffAttributes === null || playoffAttributes === void 0 ? void 0 : playoffAttributes['0-1']) === null || _b === void 0 ? void 0 : _b.name)) ||
        (index === 1 && ((_c = playoffAttributes === null || playoffAttributes === void 0 ? void 0 : playoffAttributes['0-3']) === null || _c === void 0 ? void 0 : _c.name));
    var defaultName = indexedStructureName || "".concat(constantToString(CONSOLATION), " ").concat(index + 1);
    var mappedStructureName = (structureNameMap === null || structureNameMap === void 0 ? void 0 : structureNameMap[defaultName]) || defaultName;
    var structureName = playoffStructureNameBase
        ? "".concat(playoffStructureNameBase, " ").concat(mappedStructureName)
        : mappedStructureName;
    var consolationStructure = structureTemplate({
        matchUps: consolationMatchUps,
        stage: CONSOLATION,
        structureName: structureName,
        stageSequence: stageSequence,
        matchUpType: matchUpType,
        structureId: structureId,
    });
    return { consolationStructure: consolationStructure, consolationRoundsCount: consolationRoundsCount };
}

function feedInChampionship(params) {
    var _a, _b, _c;
    var finishingPositionOffset = params.finishingPositionOffset, _d = params.stageSequence, stageSequence = _d === void 0 ? 1 : _d, playoffAttributes = params.playoffAttributes, policyDefinitions = params.policyDefinitions, feedsFromFinal = params.feedsFromFinal, staggeredEntry = params.staggeredEntry, structureName = params.structureName, _e = params.stage, stage = _e === void 0 ? MAIN : _e, structureId = params.structureId, matchUpType = params.matchUpType, skipRounds = params.skipRounds, feedRounds = params.feedRounds, idPrefix = params.idPrefix, drawSize = params.drawSize, isMock = params.isMock, uuids = params.uuids, fmlc = params.fmlc;
    var feedPolicy = params.feedPolicy || (policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_FEED_IN]);
    var mainParams = {
        finishingPositionOffset: finishingPositionOffset,
        matchUpType: matchUpType,
        skipRounds: skipRounds,
        drawSize: drawSize,
        idPrefix: idPrefix,
        isMock: isMock,
        uuids: uuids,
    };
    var matchUps = (staggeredEntry
        ? feedInMatchUps(mainParams)
        : treeMatchUps(mainParams)).matchUps;
    var mainStructure = structureTemplate({
        structureName: structureName || ((_a = playoffAttributes === null || playoffAttributes === void 0 ? void 0 : playoffAttributes['0']) === null || _a === void 0 ? void 0 : _a.name) || constantToString(MAIN),
        structureId: structureId || (uuids === null || uuids === void 0 ? void 0 : uuids.pop()),
        stageSequence: stageSequence,
        matchUpType: matchUpType,
        matchUps: matchUps,
        stage: stage,
    });
    var structures = [mainStructure];
    var links = [];
    var baseDrawSize = drawSize / 2;
    var _f = feedInMatchUps({
        finishingPositionOffset: baseDrawSize,
        idPrefix: idPrefix && "".concat(idPrefix, "-c"),
        isConsolation: true,
        feedsFromFinal: feedsFromFinal,
        baseDrawSize: baseDrawSize,
        matchUpType: matchUpType,
        feedRounds: feedRounds,
        skipRounds: skipRounds,
        isMock: isMock,
        uuids: uuids,
        fmlc: fmlc,
    }), consolationMatchUps = _f.matchUps, roundsCount = _f.roundsCount;
    if (drawSize > 2) {
        var name_1 = (_c = (_b = playoffAttributes === null || playoffAttributes === void 0 ? void 0 : playoffAttributes['0-1']) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : constantToString(CONSOLATION);
        var structureName_1 = params.playoffStructureNameBase
            ? "".concat(params.playoffStructureNameBase, " ").concat(name_1)
            : name_1;
        var consolationStructure = structureTemplate({
            matchUps: consolationMatchUps,
            structureId: uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
            stage: CONSOLATION,
            stageSequence: 1,
            structureName: structureName_1,
            matchUpType: matchUpType,
        });
        structures.push(consolationStructure);
        var feedLinks = feedInLinks({
            consolationStructure: consolationStructure,
            mainStructure: mainStructure,
            roundsCount: roundsCount,
            feedPolicy: feedPolicy,
            fmlc: fmlc,
        });
        links.push.apply(links, __spreadArray([], __read(feedLinks), false));
    }
    return __assign(__assign({}, SUCCESS), { structures: structures, links: links });
}

function processPlayoffGroups(_a) {
    var e_1, _b;
    var _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    var _u = _a.requireSequential, requireSequential = _u === void 0 ? true : _u, playoffMatchUpFormat = _a.playoffMatchUpFormat, playoffAttributes = _a.playoffAttributes, sourceStructureId = _a.sourceStructureId, policyDefinitions = _a.policyDefinitions, stageSequence = _a.stageSequence, drawDefinition = _a.drawDefinition, playoffGroups = _a.playoffGroups, matchUpType = _a.matchUpType, feedPolicy = _a.feedPolicy, groupCount = _a.groupCount, idPrefix = _a.idPrefix, isMock = _a.isMock, uuids = _a.uuids;
    feedPolicy = feedPolicy || (policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_FEED_IN]);
    var stack = 'processPlayoffGroups';
    var finishingPositionOffset = 0;
    var finishingPositionTargets = [];
    var structures = [];
    var links = [];
    var _v = getPositionRangeMap({
        structureId: sourceStructureId,
        drawDefinition: drawDefinition,
        playoffGroups: playoffGroups,
    }), error = _v.error, positionRangeMap = _v.positionRangeMap;
    if (error)
        return decorateResult({ result: { error: error }, stack: stack });
    var validFinishingPositions = !positionRangeMap ||
        (playoffGroups === null || playoffGroups === void 0 ? void 0 : playoffGroups.every(function (profile) {
            var _a = profile.finishingPositions, finishingPositions = _a === void 0 ? [] : _a;
            if (!finishingPositions.length)
                return false;
            var sequential = __spreadArray([], __read(finishingPositions), false).sort(numericSort)
                .map(function (pos, i) { return (finishingPositions[i + 1] || pos) - pos; })
                .every(function (val) { return val < 2; });
            return (!requireSequential || sequential) && finishingPositions.every(function (position) { return positionRangeMap[position]; });
        }));
    if (!validFinishingPositions) {
        return decorateResult({
            context: { validFinishingPositions: Object.values(positionRangeMap) },
            result: { error: INVALID_VALUES },
            stack: stack,
        });
    }
    var _loop_1 = function (playoffGroup) {
        var _w;
        var finishingPositions = playoffGroup.finishingPositions;
        var positionsPlayedOff = positionRangeMap && finishingPositions.map(function (p) { var _a; return (_a = positionRangeMap[p]) === null || _a === void 0 ? void 0 : _a.finishingPositions; }).flat();
        var participantsInDraw = groupCount * finishingPositions.length;
        var drawSize = nextPowerOf2(participantsInDraw);
        var playoffDrawType = (drawSize === 2 && SINGLE_ELIMINATION) || playoffGroup.drawType || SINGLE_ELIMINATION;
        if (positionsPlayedOff) {
            finishingPositionOffset = Math.min.apply(Math, __spreadArray([], __read(positionsPlayedOff), false)) - 1;
        }
        var finishingPositionRange = positionsPlayedOff && "".concat(Math.min.apply(Math, __spreadArray([], __read(positionsPlayedOff), false)), "-").concat(Math.max.apply(Math, __spreadArray([], __read(positionsPlayedOff), false)));
        var structureName = playoffGroup.structureName ||
            (finishingPositionRange && ((_d = (_c = playoffGroup.playoffAttributes) === null || _c === void 0 ? void 0 : _c[finishingPositionRange]) === null || _d === void 0 ? void 0 : _d.name)) ||
            ((_f = (_e = playoffGroup.playoffAttributes) === null || _e === void 0 ? void 0 : _e['0']) === null || _f === void 0 ? void 0 : _f.name);
        var playoffGroupParams = {
            addNameBaseToAttributeName: playoffGroup.addNameBaseToAttributeName,
            playoffStructureNameBase: playoffGroup.playoffStructureNameBase,
            finishingPositionNaming: playoffGroup.finishingPositionNaming,
            finishingPositionLimit: playoffGroup.finishingPositionLimit,
            structureId: (_g = playoffGroup.structureId) !== null && _g !== void 0 ? _g : uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
            playoffAttributes: playoffGroup.playoffAttributes,
            structureNameMap: playoffGroup.structureNameMap,
            sequenceLimit: playoffGroup.sequenceLimit,
            structureName: structureName,
        };
        var params = __assign(__assign({}, playoffGroupParams), { idPrefix: idPrefix && "".concat(idPrefix, "-po"), appliedPolicies: policyDefinitions, finishingPositionOffset: finishingPositionOffset, stage: PLAY_OFF, stageSequence: stageSequence, matchUpType: matchUpType, drawSize: drawSize, isMock: isMock, uuids: uuids });
        var updateStructureAndLinks = function (_a) {
            var playoffStructures = _a.playoffStructures, playoffLinks = _a.playoffLinks;
            var _b = __read(playoffStructures, 1), playoffStructure = _b[0];
            var playoffLink = generatePlayoffLink({
                playoffStructureId: playoffStructure.structureId,
                finishingPositions: finishingPositions,
                sourceStructureId: sourceStructureId,
            });
            links.push(playoffLink);
            links.push.apply(links, __spreadArray([], __read(playoffLinks), false));
            structures.push.apply(structures, __spreadArray([], __read(playoffStructures), false));
            finishingPositionTargets.push({
                structureId: playoffStructure.structureId,
                finishingPositions: finishingPositions,
            });
            // update *after* value has been passed into current playoff structure generator
            finishingPositionOffset += participantsInDraw;
        };
        if (playoffDrawType === SINGLE_ELIMINATION) {
            var matchUps = treeMatchUps({
                finishingPositionLimit: finishingPositionOffset + participantsInDraw,
                idPrefix: idPrefix && "".concat(idPrefix, "-po"),
                finishingPositionOffset: finishingPositionOffset,
                matchUpType: matchUpType,
                drawSize: drawSize,
                isMock: isMock,
                uuids: uuids,
            }).matchUps;
            var playoffStructure = structureTemplate({
                structureId: (_h = playoffGroup.structureId) !== null && _h !== void 0 ? _h : uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
                matchUpFormat: playoffMatchUpFormat,
                stage: PLAY_OFF,
                structureName: structureName,
                stageSequence: stageSequence,
                matchUps: matchUps,
            });
            structures.push(playoffStructure);
            var playoffLink = generatePlayoffLink({
                playoffStructureId: playoffStructure.structureId,
                finishingPositions: finishingPositions,
                sourceStructureId: sourceStructureId,
            });
            links.push(playoffLink);
            // update *after* value has been passed into current playoff structure generator
            finishingPositionOffset += participantsInDraw;
            finishingPositionTargets.push({
                structureId: playoffStructure.structureId,
                finishingPositions: finishingPositions,
            });
        }
        else if ([COMPASS, OLYMPIC, PLAY_OFF].includes(playoffDrawType)) {
            var params_1 = {
                playoffAttributes: (_j = playoffGroup.playoffAttributes) !== null && _j !== void 0 ? _j : playoffAttributes,
                playoffStructureNameBase: playoffGroup.playoffStructureNameBase,
                structureId: (_k = playoffGroup.structureId) !== null && _k !== void 0 ? _k : uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
                structureName: playoffGroup.structureName,
                idPrefix: idPrefix && "".concat(idPrefix, "-po"),
                addNameBaseToAttributeName: true,
                finishingPositionOffset: finishingPositionOffset,
                stage: PLAY_OFF,
                roundOffset: 0,
                stageSequence: stageSequence,
                drawSize: drawSize,
                isMock: isMock,
                uuids: uuids,
            };
            if (playoffDrawType === COMPASS) {
                Object.assign(params_1, {
                    playoffAttributes: (_m = (_l = playoffGroup === null || playoffGroup === void 0 ? void 0 : playoffGroup.playoffAttributes) !== null && _l !== void 0 ? _l : playoffAttributes) !== null && _m !== void 0 ? _m : COMPASS_ATTRIBUTES,
                    roundOffsetLimit: 3,
                });
            }
            else if (playoffDrawType === OLYMPIC) {
                Object.assign(params_1, {
                    playoffAttributes: (_p = (_o = playoffGroup === null || playoffGroup === void 0 ? void 0 : playoffGroup.playoffAttributes) !== null && _o !== void 0 ? _o : playoffAttributes) !== null && _p !== void 0 ? _p : OLYMPIC_ATTRIBUTES,
                    roundOffsetLimit: 2,
                });
            }
            var result = generatePlayoffStructures(params_1);
            if (result.error)
                return { value: result };
            if ((_q = result.links) === null || _q === void 0 ? void 0 : _q.length)
                links.push.apply(links, __spreadArray([], __read(result.links), false));
            if ((_r = result.structures) === null || _r === void 0 ? void 0 : _r.length)
                structures.push.apply(structures, __spreadArray([], __read(result.structures), false));
            structures.sort(structureSort);
            if (result.structureId) {
                var playoffLink = generatePlayoffLink({
                    playoffStructureId: result.structureId,
                    finishingPositions: finishingPositions,
                    sourceStructureId: sourceStructureId,
                });
                links.push(playoffLink);
                finishingPositionTargets.push({
                    structureId: result.structureId,
                    finishingPositions: finishingPositions,
                });
            }
            // update *after* value has been passed into current playoff structure generator
            finishingPositionOffset += participantsInDraw;
        }
        else if ([
            FIRST_MATCH_LOSER_CONSOLATION,
            FEED_IN_CHAMPIONSHIP,
            FEED_IN_CHAMPIONSHIP_TO_R16,
            FEED_IN_CHAMPIONSHIP_TO_QF,
            FEED_IN_CHAMPIONSHIP_TO_SF,
            MODIFIED_FEED_IN_CHAMPIONSHIP,
        ].includes(playoffDrawType)) {
            var uuidsFMLC = [uuids === null || uuids === void 0 ? void 0 : uuids.pop(), uuids === null || uuids === void 0 ? void 0 : uuids.pop()];
            var params_2 = {
                playoffStructureNameBase: playoffGroup.playoffStructureNameBase,
                structureId: (_s = playoffGroup.structureId) !== null && _s !== void 0 ? _s : uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
                playoffAttributes: playoffGroup.playoffAttributes,
                idPrefix: idPrefix && "".concat(idPrefix, "-po"),
                finishingPositionOffset: finishingPositionOffset,
                uuids: uuidsFMLC,
                stage: PLAY_OFF,
                structureName: structureName,
                matchUpType: matchUpType,
                feedPolicy: feedPolicy,
                drawSize: drawSize,
                isMock: isMock,
            };
            var additionalAttributes = (_w = {},
                _w[FIRST_MATCH_LOSER_CONSOLATION] = { fmlc: true, feedRounds: 1 },
                _w[MODIFIED_FEED_IN_CHAMPIONSHIP] = { feedRounds: 1 },
                _w[FEED_IN_CHAMPIONSHIP_TO_R16] = { feedsFromFinal: 3 },
                _w[FEED_IN_CHAMPIONSHIP_TO_QF] = { feedsFromFinal: 2 },
                _w[FEED_IN_CHAMPIONSHIP_TO_SF] = { feedsFromFinal: 1 },
                _w);
            Object.assign(params_2, additionalAttributes[playoffDrawType] || {});
            var _x = feedInChampionship(params_2), champitionShipStructures = _x.structures, feedInLinks = _x.links;
            var _y = __read(champitionShipStructures, 1), playoffStructure = _y[0];
            var playoffLink = generatePlayoffLink({
                playoffStructureId: playoffStructure.structureId,
                finishingPositions: finishingPositions,
                sourceStructureId: sourceStructureId,
            });
            links.push(playoffLink);
            links.push.apply(links, __spreadArray([], __read(feedInLinks), false));
            structures.push.apply(structures, __spreadArray([], __read(champitionShipStructures), false));
            finishingPositionTargets.push({
                structureId: playoffStructure.structureId,
                finishingPositions: finishingPositions,
            });
            // update *after* value has been passed into current playoff structure generator
            finishingPositionOffset += participantsInDraw;
        }
        else if ([ROUND_ROBIN].includes(playoffDrawType)) {
            var _z = generateRoundRobin(__assign(__assign({}, params), { structureOptions: playoffGroup.structureOptions || { groupSize: 4 } })), playoffStructures = _z.structures, playoffLinks = _z.links;
            updateStructureAndLinks({ playoffStructures: playoffStructures, playoffLinks: playoffLinks });
        }
        else if ([FIRST_ROUND_LOSER_CONSOLATION].includes(playoffDrawType)) {
            var _0 = firstRoundLoserConsolation(params), playoffStructures = _0.structures, playoffLinks = _0.links;
            updateStructureAndLinks({ playoffStructures: playoffStructures, playoffLinks: playoffLinks });
        }
        else if ([CURTIS_CONSOLATION].includes(playoffDrawType)) {
            var _1 = generateCurtisConsolation(params), playoffStructures = _1.structures, playoffLinks = _1.links;
            updateStructureAndLinks({ playoffStructures: playoffStructures, playoffLinks: playoffLinks });
        }
        else if ([AD_HOC].includes(playoffDrawType)) {
            var structure = structureTemplate({
                structureId: (_t = playoffGroup.structureId) !== null && _t !== void 0 ? _t : uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
                structureName: playoffGroup.structureName,
                finishingPosition: WIN_RATIO,
                stage: PLAY_OFF,
                stageSequence: stageSequence,
                matchUps: [],
            });
            updateStructureAndLinks({
                playoffStructures: [structure],
                playoffLinks: [],
            });
        }
    };
    try {
        for (var playoffGroups_1 = __values(playoffGroups), playoffGroups_1_1 = playoffGroups_1.next(); !playoffGroups_1_1.done; playoffGroups_1_1 = playoffGroups_1.next()) {
            var playoffGroup = playoffGroups_1_1.value;
            var state_1 = _loop_1(playoffGroup);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (playoffGroups_1_1 && !playoffGroups_1_1.done && (_b = playoffGroups_1.return)) _b.call(playoffGroups_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { finishingPositionTargets: finishingPositionTargets, positionRangeMap: positionRangeMap, structures: structures, links: links };
}
function generatePlayoffLink(_a) {
    var playoffStructureId = _a.playoffStructureId, finishingPositions = _a.finishingPositions, sourceStructureId = _a.sourceStructureId;
    return {
        linkType: POSITION,
        source: {
            structureId: sourceStructureId,
            finishingPositions: finishingPositions,
        },
        target: {
            structureId: playoffStructureId,
            feedProfile: DRAW,
            roundNumber: 1,
        },
    };
}

function generateAndPopulateRRplayoffStructures(params) {
    var _a, _b;
    var _c, _d, _e;
    var stack = 'generateAndPopulateRRplayoffStructures';
    if (!params.playoffGroups) {
        return decorateResult({
            result: { error: MISSING_VALUE },
            info: 'playoffGroups required',
            stack: stack,
        });
    }
    var sourceStructureId = params.sourceStructureId, requireSequential = params.requireSequential, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, playoffGroups = params.playoffGroups, groupCount = params.groupCount, groupSize = params.groupSize, event = params.event;
    var _f = processPlayoffGroups(__assign({ requireSequential: requireSequential, sourceStructureId: sourceStructureId, playoffGroups: playoffGroups, groupCount: groupCount, groupSize: groupSize }, params)), _g = _f.structures, playoffStructures = _g === void 0 ? [] : _g, _h = _f.links, playoffLinks = _h === void 0 ? [] : _h, finishingPositionTargets = _f.finishingPositionTargets, positionRangeMap = _f.positionRangeMap, error = _f.error;
    if (error)
        return { error: error };
    var positionsPlayedOff = finishingPositionTargets === null || finishingPositionTargets === void 0 ? void 0 : finishingPositionTargets.map(function (_a) {
        var finishingPositions = _a.finishingPositions;
        return finishingPositions;
    }).flat().map(function (finishingPosition) { return positionRangeMap[finishingPosition].finishingPositions; }).flat();
    (_a = drawDefinition.structures).push.apply(_a, __spreadArray([], __read(playoffStructures), false));
    (_b = drawDefinition.links).push.apply(_b, __spreadArray([], __read(playoffLinks), false));
    var _j = getAllDrawMatchUps({
        inContext: true,
        drawDefinition: drawDefinition,
    }), inContextDrawMatchUps = _j.matchUps, matchUpsMap = _j.matchUpsMap;
    var newStructureIds = playoffStructures.map(function (_a) {
        var structureId = _a.structureId;
        return structureId;
    });
    var addedMatchUpIds = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.filter(function (_a) {
        var structureId = _a.structureId;
        return newStructureIds.includes(structureId);
    }).map(getMatchUpId);
    var addedMatchUps = (_c = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.drawMatchUps) === null || _c === void 0 ? void 0 : _c.filter(function (_a) {
        var matchUpId = _a.matchUpId;
        return addedMatchUpIds === null || addedMatchUpIds === void 0 ? void 0 : addedMatchUpIds.includes(matchUpId);
    });
    if (addedMatchUps === null || addedMatchUps === void 0 ? void 0 : addedMatchUps.length) {
        var tieFormat_1 = (_d = resolveTieFormat({ drawDefinition: drawDefinition, event: event })) === null || _d === void 0 ? void 0 : _d.tieFormat;
        if (tieFormat_1) {
            addedMatchUps.forEach(function (matchUp) {
                var tieMatchUps = generateTieMatchUps({
                    isMock: params.isMock,
                    tieFormat: tieFormat_1,
                    matchUp: matchUp,
                }).tieMatchUps;
                Object.assign(matchUp, { tieMatchUps: tieMatchUps, matchUpType: TEAM_MATCHUP });
            });
        }
    }
    // TODO: determine participants that are present in each playoffGroup.finishingPositions
    // OPTIONALLY: populate positionAssignments for newly generated structures
    var positionAssignments = getPositionAssignments$1({
        structureId: sourceStructureId,
        drawDefinition: drawDefinition,
    }).positionAssignments;
    var finishingPositionParticipantIds = {};
    positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.forEach(function (assignment) {
        var _a;
        var result = findExtension({
            element: assignment,
            name: TALLY,
        });
        var participantResult = (_a = result === null || result === void 0 ? void 0 : result.extension) === null || _a === void 0 ? void 0 : _a.value;
        var groupOrder = participantResult === null || participantResult === void 0 ? void 0 : participantResult.groupOrder;
        if (groupOrder) {
            if (!finishingPositionParticipantIds[groupOrder])
                finishingPositionParticipantIds[groupOrder] = [];
            finishingPositionParticipantIds[groupOrder].push(assignment.participantId);
        }
    });
    /*
     *finishingPositionTargets.forEach((target) => {
     *  const { finishingPositions, structureId } = target;
     *  const participantIds = finishingPositions
     *    .flatMap((position) => finishingPositionParticipantIds[position] || [])
     *    .sort();
     *  console.log({ structureId, participantIds });
     *  const stageEntries = getStageEntries({
     *    drawDefinition,
     *    structureId,
     *    stage: 'PLAY_OFF',
     *  });
     *  console.log(stageEntries.map((p) => p.participantId).sort());
     *});
     */
    var result = automatedPlayoffPositioning({
        provisionalPositioning: params.provisionalPositioning,
        structureId: sourceStructureId,
        applyPositioning: true,
        event: params.event,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
    });
    // attempt automated positioning but fail silently if source structure is incomplete
    if (result.error && ((_e = result.error) === null || _e === void 0 ? void 0 : _e.code) !== INCOMPLETE_SOURCE_STRUCTURE.code) {
        return decorateResult({ result: result, stack: stack });
    }
    return __assign({ structures: playoffStructures, links: playoffLinks, positionsPlayedOff: positionsPlayedOff, drawDefinition: drawDefinition }, SUCCESS);
}

function generateAndPopulatePlayoffStructures(params) {
    var e_1, _a, _b, _c;
    var _d, _e;
    var stack = 'genPlayoffStructure';
    if (!params.drawDefinition)
        return decorateResult({
            result: { error: MISSING_DRAW_DEFINITION },
            stack: stack,
        });
    var availabilityResult = getAvailablePlayoffProfiles(params);
    if (availabilityResult.error) {
        return decorateResult({ result: availabilityResult, stack: stack });
    }
    var sourceStructureId = params.structureId, addNameBaseToAttributeName = params.addNameBaseToAttributeName, playoffStructureNameBase = params.playoffStructureNameBase, finishingPositionNaming = params.finishingPositionNaming, finishingPositionLimit = params.finishingPositionLimit, playoffAttributes = params.playoffAttributes, playoffPositions = params.playoffPositions, roundOffsetLimit = params.roundOffsetLimit, tournamentRecord = params.tournamentRecord, exitProfileLimit = params.exitProfileLimit, roundProfiles = params.roundProfiles, roundNumbers = params.roundNumbers, idPrefix = params.idPrefix, isMock = params.isMock, event = params.event, uuids = params.uuids;
    // The goal here is to return { structures, links } and not modify existing drawDefinition
    // However, a copy of the drawDefinition needs to have the structures attached in order to
    // populate the newly created structures with participants which should advance into them
    var drawDefinition = makeDeepCopy(params.drawDefinition, false, true);
    var structure = findStructure({
        structureId: sourceStructureId,
        drawDefinition: drawDefinition,
    }).structure;
    if (!structure)
        return decorateResult({ result: { error: STRUCTURE_NOT_FOUND }, stack: stack });
    if (structure.structureType === CONTAINER || structure.structures) {
        return generateAndPopulateRRplayoffStructures(__assign(__assign(__assign({ sourceStructureId: structure.structureId }, params), availabilityResult), { drawDefinition: drawDefinition }));
    }
    var availablePlayoffRoundsRanges = availabilityResult.playoffRoundsRanges, availablePlayoffRounds = availabilityResult.playoffRounds;
    var _f = getSourceRounds(params), playoffPositionsReturned = _f.playoffPositionsReturned, sourceRoundsError = _f.error, playoffSourceRounds = _f.playoffSourceRounds, playoffRoundsRanges = _f.playoffRoundsRanges;
    if (sourceRoundsError) {
        return decorateResult({ result: { error: sourceRoundsError }, stack: stack });
    }
    var roundProfile = (roundProfiles === null || roundProfiles === void 0 ? void 0 : roundProfiles.length) && Object.assign.apply(Object, __spreadArray([{}], __read(roundProfiles), false));
    var targetRoundNumbers = roundNumbers || (typeof roundProfiles === 'object' && roundProfiles.map(function (p) { return Object.keys(p); }).flat());
    var validRoundNumbers = Array.isArray(targetRoundNumbers) && targetRoundNumbers.map(function (p) { return !isNaN(p) && ensureInt(p); }).filter(Boolean);
    if (validRoundNumbers) {
        if (!Array.isArray(validRoundNumbers))
            return decorateResult({
                result: { error: INVALID_VALUES },
                context: { validRoundNumbers: validRoundNumbers },
                stack: stack,
            });
        validRoundNumbers.forEach(function (roundNumber) {
            if (!(availablePlayoffRounds === null || availablePlayoffRounds === void 0 ? void 0 : availablePlayoffRounds.includes(roundNumber))) {
                return decorateResult({
                    result: { error: INVALID_VALUES },
                    context: { roundNumber: roundNumber },
                    stack: stack,
                });
            }
            return undefined;
        });
    }
    if (playoffPositions) {
        playoffPositions.forEach(function (playoffPosition) {
            if (!(playoffPositionsReturned === null || playoffPositionsReturned === void 0 ? void 0 : playoffPositionsReturned.includes(playoffPosition))) {
                return decorateResult({
                    result: { error: INVALID_VALUES },
                    context: { playoffPosition: playoffPosition },
                    stack: stack,
                });
            }
            return undefined;
        });
    }
    var sourceRounds = validRoundNumbers || playoffSourceRounds;
    var roundsRanges = validRoundNumbers ? availablePlayoffRoundsRanges : playoffRoundsRanges;
    var newStructures = [];
    var newLinks = [];
    var _loop_1 = function (roundNumber) {
        var roundInfo = roundsRanges === null || roundsRanges === void 0 ? void 0 : roundsRanges.find(function (roundInfo) { return roundInfo.roundNumber === roundNumber; });
        if (!roundInfo)
            return { value: decorateResult({
                    result: { error: INVALID_VALUES },
                    context: { roundNumber: roundNumber },
                    stack: stack,
                }) };
        var drawSize = roundInfo.finishingPositions.length;
        var finishingPositionOffset = Math.min.apply(Math, __spreadArray([], __read(roundInfo.finishingPositions), false)) - 1;
        var stageSequence = 2;
        var sequenceLimit = roundNumber && (roundProfile === null || roundProfile === void 0 ? void 0 : roundProfile[roundNumber]) && stageSequence + roundProfile[roundNumber] - 1;
        var result = generatePlayoffStructures({
            exitProfile: "0-".concat(roundNumber),
            addNameBaseToAttributeName: addNameBaseToAttributeName,
            playoffStructureNameBase: playoffStructureNameBase,
            finishingPositionOffset: finishingPositionOffset,
            playoffAttributes: playoffAttributes,
            exitProfileLimit: exitProfileLimit,
            stage: PLAY_OFF,
            roundOffset: 0,
            drawDefinition: drawDefinition,
            sequenceLimit: sequenceLimit,
            stageSequence: stageSequence,
            drawSize: drawSize,
            idPrefix: idPrefix,
            isMock: isMock,
            uuids: uuids,
            finishingPositionNaming: finishingPositionNaming,
            finishingPositionLimit: finishingPositionLimit,
            roundOffsetLimit: roundOffsetLimit,
        });
        if (result.error)
            return { value: decorateResult({ result: result, stack: stack }) };
        var structures = result.structures, links = result.links;
        if (structures === null || structures === void 0 ? void 0 : structures.length)
            newStructures.push.apply(newStructures, __spreadArray([], __read(structures), false));
        if (links === null || links === void 0 ? void 0 : links.length)
            newLinks.push.apply(newLinks, __spreadArray([], __read(links), false));
        if (result.structureId && roundNumber) {
            var link = {
                linkType: LOSER,
                source: {
                    structureId: sourceStructureId,
                    roundNumber: roundNumber,
                },
                target: {
                    structureId: result.structureId,
                    feedProfile: TOP_DOWN,
                    roundNumber: 1,
                },
            };
            newLinks.push(link);
        }
    };
    try {
        for (var _g = __values(sourceRounds !== null && sourceRounds !== void 0 ? sourceRounds : []), _h = _g.next(); !_h.done; _h = _g.next()) {
            var roundNumber = _h.value;
            var state_1 = _loop_1(roundNumber);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (!newStructures.length)
        return decorateResult({
            result: { error: INVALID_VALUES },
            info: 'No structures generated',
            stack: stack,
        });
    (_b = drawDefinition.structures).push.apply(_b, __spreadArray([], __read(newStructures), false));
    (_c = drawDefinition.links).push.apply(_c, __spreadArray([], __read(newLinks), false));
    var _j = getAllDrawMatchUps({
        inContext: true,
        drawDefinition: drawDefinition,
    }), inContextDrawMatchUps = _j.matchUps, matchUpsMap = _j.matchUpsMap;
    var newStructureIds = newStructures.map(function (_a) {
        var structureId = _a.structureId;
        return structureId;
    });
    var addedMatchUpIds = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.filter(function (_a) {
        var structureId = _a.structureId;
        return newStructureIds.includes(structureId);
    }).map(getMatchUpId);
    var addedMatchUps = (_d = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.drawMatchUps) === null || _d === void 0 ? void 0 : _d.filter(function (_a) {
        var matchUpId = _a.matchUpId;
        return addedMatchUpIds === null || addedMatchUpIds === void 0 ? void 0 : addedMatchUpIds.includes(matchUpId);
    });
    if (addedMatchUps === null || addedMatchUps === void 0 ? void 0 : addedMatchUps.length) {
        var tieFormat_1 = (_e = resolveTieFormat({ drawDefinition: drawDefinition, event: event })) === null || _e === void 0 ? void 0 : _e.tieFormat;
        if (tieFormat_1) {
            addedMatchUps.forEach(function (matchUp) {
                var tieMatchUps = generateTieMatchUps({ matchUp: matchUp, tieFormat: tieFormat_1, isMock: isMock }).tieMatchUps;
                Object.assign(matchUp, { tieMatchUps: tieMatchUps, matchUpType: TEAM });
            });
        }
    }
    // now advance any players from completed matchUps into the newly added structures
    var completedMatchUps = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.filter(function (matchUp) { return checkMatchUpIsComplete({ matchUp: matchUp }) && matchUp.structureId === sourceStructureId; });
    completedMatchUps === null || completedMatchUps === void 0 ? void 0 : completedMatchUps.forEach(function (matchUp) {
        var matchUpId = matchUp.matchUpId, score = matchUp.score, winningSide = matchUp.winningSide;
        var targetData = positionTargets({
            inContextDrawMatchUps: inContextDrawMatchUps,
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
        });
        var result = directParticipants({
            inContextDrawMatchUps: inContextDrawMatchUps,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
            winningSide: winningSide,
            targetData: targetData,
            matchUpId: matchUpId,
            structure: structure,
            matchUp: matchUp,
            score: score,
            event: event,
        });
        if (result.error)
            console.log(result.error);
    });
    var byeMatchUps = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.filter(function (matchUp) { return matchUp.matchUpStatus === BYE && matchUp.structureId === sourceStructureId; });
    byeMatchUps === null || byeMatchUps === void 0 ? void 0 : byeMatchUps.forEach(function (matchUp) {
        var matchUpId = matchUp.matchUpId;
        var targetData = positionTargets({
            inContextDrawMatchUps: inContextDrawMatchUps,
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
        });
        var loserTargetLink = targetData.targetLinks.loserTargetLink, _a = targetData.targetMatchUps, loserMatchUpDrawPositionIndex = _a.loserMatchUpDrawPositionIndex, // only present when positionTargets found without loserMatchUpId
        loserMatchUp = _a.loserMatchUp;
        if (loserTargetLink && loserMatchUp) {
            var targetStructureId = loserTargetLink.target.structureId;
            var targetDrawPosition = loserMatchUp.drawPositions[loserMatchUpDrawPositionIndex];
            var result = assignDrawPositionBye({
                drawPosition: targetDrawPosition,
                structureId: targetStructureId,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                event: event,
            });
            if (result.error)
                console.log(result.error);
        }
    });
    // the matchUps in the source structure must have goesTo details added
    var matchUpModifications = [];
    var goesToMap = addGoesTo({
        inContextDrawMatchUps: inContextDrawMatchUps,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
    }).goesToMap;
    var sourceStructure = findStructure({
        drawDefinition: params.drawDefinition,
        structureId: sourceStructureId,
    }).structure;
    var sourceStructureMatchUps = getAllStructureMatchUps({
        structure: sourceStructure,
    }).matchUps;
    sourceStructureMatchUps.forEach(function (matchUp) {
        var _a, _b;
        var loserMatchUpId = goesToMap === null || goesToMap === void 0 ? void 0 : goesToMap.loserMatchUpIds[matchUp.matchUpId];
        if (loserMatchUpId && matchUp.loserMatchUpId !== loserMatchUpId) {
            matchUp.loserMatchUpId = loserMatchUpId;
            var modification = {
                tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                eventId: (_a = params.event) === null || _a === void 0 ? void 0 : _a.eventId,
                context: stack,
                matchUp: matchUp,
            };
            matchUpModifications.push(modification);
        }
        var winnerMatchUpId = goesToMap === null || goesToMap === void 0 ? void 0 : goesToMap.winnerMatchUpIds[matchUp.matchUpId];
        if (winnerMatchUpId && matchUp.winnerMatchUpId !== winnerMatchUpId) {
            matchUp.winnerMatchUpId = winnerMatchUpId;
            var modification = {
                tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                eventId: (_b = params.event) === null || _b === void 0 ? void 0 : _b.eventId,
                context: stack,
                matchUp: matchUp,
            };
            matchUpModifications.push(modification);
        }
    });
    return __assign({ structures: newStructures, matchUpModifications: matchUpModifications, links: newLinks, drawDefinition: drawDefinition }, SUCCESS);
}

function attachConsolationStructures(params) {
    return attachStructures(__assign(__assign({}, params), { itemType: 'attachConsolationStructures' }));
}
function attachPlayoffStructures(params) {
    return attachStructures(__assign(__assign({}, params), { itemType: 'attachPlayoffStructures' }));
}
function attachStructures(_a) {
    var _b;
    var _c, _d, _e, _f;
    var _g = _a.itemType, itemType = _g === void 0 ? 'attachStructures' : _g, matchUpModifications = _a.matchUpModifications, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, structures = _a.structures, _h = _a.links, links = _h === void 0 ? [] : _h, event = _a.event;
    var stack = 'attachStructures';
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!Array.isArray(structures) || !Array.isArray(links))
        return decorateResult({ result: { error: INVALID_VALUES }, stack: stack });
    var linkHash = function (link) {
        var _a;
        return [
            link.source.structureId,
            link.source.roundNumber || ((_a = link.source.finishingPositions) === null || _a === void 0 ? void 0 : _a.join('|')),
            link.target.roundNumber,
        ].join('|');
    };
    var existingLinkHashes = (_c = drawDefinition.links) === null || _c === void 0 ? void 0 : _c.map(linkHash);
    var duplicateLink = links.some(function (link) {
        var hash = linkHash(link);
        return existingLinkHashes === null || existingLinkHashes === void 0 ? void 0 : existingLinkHashes.includes(hash);
    });
    if (duplicateLink)
        return decorateResult({
            result: { error: EXISTING_STRUCTURE },
            info: 'playoff structure exists',
            stack: stack,
        });
    // TODO: ensure that all links are valid and reference structures that are/will be included in the drawDefinition
    if (links.length)
        (_d = drawDefinition.links) === null || _d === void 0 ? void 0 : _d.push.apply(_d, __spreadArray([], __read(links), false));
    var generatedStructureIds = structures.map(function (_a) {
        var structureId = _a.structureId;
        return structureId;
    });
    var existingStructureIds = (_e = drawDefinition.structures) === null || _e === void 0 ? void 0 : _e.map(function (_a) {
        var structureId = _a.structureId;
        return structureId;
    });
    // replace any existing structures with newly generated structures
    // this is done because it is possible that a structure exists without matchUps
    drawDefinition.structures = ((_f = drawDefinition.structures) !== null && _f !== void 0 ? _f : []).map(function (structure) {
        return generatedStructureIds.includes(structure.structureId)
            ? structures.find(function (_a) {
                var structureId = _a.structureId;
                return structureId === structure.structureId;
            })
            : structure;
    });
    var newStructures = structures === null || structures === void 0 ? void 0 : structures.filter(function (_a) {
        var structureId = _a.structureId;
        return !(existingStructureIds === null || existingStructureIds === void 0 ? void 0 : existingStructureIds.includes(structureId));
    });
    if (newStructures.length)
        (_b = drawDefinition.structures).push.apply(_b, __spreadArray([], __read(newStructures), false));
    addGoesTo({ drawDefinition: drawDefinition });
    var matchUps = structures.map(function (structure) { var _a; return ((_a = getAllStructureMatchUps({ structure: structure })) === null || _a === void 0 ? void 0 : _a.matchUps) || []; }).flat();
    addMatchUpsNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        eventId: event === null || event === void 0 ? void 0 : event.eventId,
        drawDefinition: drawDefinition,
        matchUps: matchUps,
    });
    var structureIds = structures.map(function (_a) {
        var structureId = _a.structureId;
        return structureId;
    });
    modifyDrawNotice({ drawDefinition: drawDefinition, structureIds: structureIds });
    if (matchUpModifications === null || matchUpModifications === void 0 ? void 0 : matchUpModifications.length) {
        var modifiedMatchUpMap_1 = {};
        matchUpModifications.forEach(function (modification) {
            var _a;
            var matchUpId = (_a = modification.matchUp) === null || _a === void 0 ? void 0 : _a.matchUpId;
            if (matchUpId) {
                modifiedMatchUpMap_1[matchUpId] = modification;
            }
        });
        // This is necessary to support external data stores in client/server architectures
        // where the data store, e.g. Mongo, requires additional attributes to be present
        // for each matchUp for which there are modifications, merge matchUp in state with modifications
        // also descend into tieMatchUps, when present, with the same logic
        var modifyStructureMatchUps_1 = function (structure) {
            structure.matchUps.forEach(function (matchUp) {
                if (modifiedMatchUpMap_1[matchUp.matchUpId]) {
                    var _a = modifiedMatchUpMap_1[matchUp.matchUpId].matchUp, tieMatchUps = _a.tieMatchUps, attribs = __rest(_a, ["tieMatchUps"]);
                    Object.assign(matchUp, attribs);
                    if (tieMatchUps === null || tieMatchUps === void 0 ? void 0 : tieMatchUps.length) {
                        var modifiedTieMatchUpsMap_1 = {};
                        tieMatchUps.forEach(function (modifiedTieMatchUp) { return (modifiedMatchUpMap_1[modifiedTieMatchUp.matchUpId] = modifiedTieMatchUp); });
                        matchUp.tieMatchUps.forEach(function (tm) { return Object.assign(tm, modifiedTieMatchUpsMap_1[tm.matchUpId]); });
                    }
                    modifiedMatchUpMap_1[matchUp.matchUpId].matchUp = matchUp;
                    modifyMatchUpNotice(modifiedMatchUpMap_1[matchUp.matchUpId]);
                }
            });
        };
        // pre-existing structures must be updated if any matchUpModifications were passed into this method
        drawDefinition.structures.forEach(function (structure) {
            var e_1, _a;
            if (existingStructureIds === null || existingStructureIds === void 0 ? void 0 : existingStructureIds.includes(structure.structureId)) {
                if (structure.structures) {
                    try {
                        for (var _b = __values(structure.structures), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var subStructure = _c.value;
                            modifyStructureMatchUps_1(subStructure);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                else {
                    modifyStructureMatchUps_1(structure);
                }
            }
        });
    }
    var addedStructureIds = newStructures.map(xa('structureId'));
    if (tournamentRecord) {
        var itemValue = { structureIds: structureIds, drawId: drawDefinition.drawId };
        var timeItem = {
            itemValue: itemValue,
            itemType: itemType,
        };
        addTimeItem({ element: tournamentRecord, timeItem: timeItem });
    }
    return __assign(__assign({}, SUCCESS), { addedStructureIds: addedStructureIds });
}

function addPlayoffStructures(params) {
    var _a, _b;
    var _c = generateAndPopulatePlayoffStructures(params), structures = _c.structures, links = _c.links, matchUpModifications = _c.matchUpModifications, error = _c.error;
    if (error)
        return { error: error };
    var drawDefinition = params.drawDefinition;
    return attachPlayoffStructures({
        tournamentId: (_a = params.tournamentRecord) === null || _a === void 0 ? void 0 : _a.tournamentId,
        eventId: ((_b = params.event) === null || _b === void 0 ? void 0 : _b.eventId) || params.eventId,
        matchUpModifications: matchUpModifications,
        drawDefinition: drawDefinition,
        structures: structures,
        links: links,
    });
}

function addCollectionGroup(_a) {
    var e_1, _b;
    var _c = _a.updateInProgressMatchUps, updateInProgressMatchUps = _c === void 0 ? true : _c, tournamentRecord = _a.tournamentRecord, groupDefinition = _a.groupDefinition, drawDefinition = _a.drawDefinition, collectionIds = _a.collectionIds, tieFormatName = _a.tieFormatName, structureId = _a.structureId, matchUpId = _a.matchUpId, matchUp = _a.matchUp, eventId = _a.eventId, event = _a.event;
    var stack = 'addCollectionGroup';
    if (!Array.isArray(collectionIds))
        return decorateResult({ result: { error: MISSING_VALUE }, stack: stack });
    // TODO: validate groupDefinition
    var result = !matchUp
        ? getTieFormat$1({
            drawDefinition: drawDefinition,
            structureId: structureId,
            matchUpId: matchUpId,
            eventId: eventId,
            event: event,
        })
        : undefined;
    if (result === null || result === void 0 ? void 0 : result.error)
        return decorateResult({ result: result, stack: stack });
    var structure = result === null || result === void 0 ? void 0 : result.structure;
    matchUp = matchUp || (result === null || result === void 0 ? void 0 : result.matchUp);
    var existingTieFormat = result === null || result === void 0 ? void 0 : result.tieFormat;
    var originalValueGoal = existingTieFormat === null || existingTieFormat === void 0 ? void 0 : existingTieFormat.winCriteria.valueGoal;
    var tieFormat = copyTieFormat(existingTieFormat);
    result = validateTieFormat({ tieFormat: tieFormat });
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    try {
        // if any of the collectionIds are already part of a different collectionGroup, throw an error
        for (var _d = __values(tieFormat.collectionDefinitions), _e = _d.next(); !_e.done; _e = _d.next()) {
            var collectionDefinition = _e.value;
            var collectionId = collectionDefinition.collectionId, collectionGroupNumber_1 = collectionDefinition.collectionGroupNumber;
            if (collectionGroupNumber_1 && collectionIds.includes(collectionId))
                return decorateResult({
                    info: 'collectionIds cannot be part of other collectionGroups',
                    result: { error: INVALID_VALUES },
                    stack: stack,
                });
            // TODO: calculate the total value of the collectionDefinition
            // either matchUpCount * matchUpValue or collectionValue or collectionValueProfiles total
            // if not gropuDEfinition.winCriteria.aggregateValue then caluculate valueGoal automatically
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var maxGroupNumber = (tieFormat.collectionGroups || []).reduce(function (max, group) { return (group.groupNumber > max ? group.groupNumber : max); }, 0);
    var collectionGroupNumber = maxGroupNumber + 1;
    groupDefinition.groupNumber = collectionGroupNumber;
    // add collectionGroupNumber to all targeted collectionDefinitions
    tieFormat.collectionDefinitions = tieFormat.collectionDefinitions.map(function (collectionDefinition) {
        if (collectionIds.includes(collectionDefinition.collectionId)) {
            return __assign(__assign({}, collectionDefinition), { collectionGroupNumber: collectionGroupNumber });
        }
        else {
            return collectionDefinition;
        }
    });
    tieFormat.collectionGroups = __spreadArray(__spreadArray([], __read((tieFormat.collecitonGroups || [])), false), [
        groupDefinition,
    ], false);
    return collectionGroupUpdate({
        updateInProgressMatchUps: updateInProgressMatchUps,
        originalValueGoal: originalValueGoal,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        tieFormatName: tieFormatName,
        structureId: structureId,
        structure: structure,
        tieFormat: tieFormat,
        matchUpId: matchUpId,
        matchUp: matchUp,
        eventId: eventId,
        event: event,
    });
}

function generateScoreString(params) {
    var _a = params.winnerFirst, winnerFirst = _a === void 0 ? true : _a, addOutcomeString = params.addOutcomeString, _b = params.reversed, reversed = _b === void 0 ? false : _b, matchUpStatus = params.matchUpStatus, matchUpFormat = params.matchUpFormat, autoComplete = params.autoComplete, winningSide = params.winningSide, sets = params.sets;
    if (!sets)
        return { error: MISSING_VALUE, info: 'missing sets' };
    var parsedFormat = matchUpFormat && parse(matchUpFormat);
    var _c = parsedFormat !== null && parsedFormat !== void 0 ? parsedFormat : {}, bestOf = _c.bestOf, finalSetFormat = _c.finalSetFormat, setFormat = _c.setFormat;
    var scoresInSideOrder = !winnerFirst || !winningSide || winningSide === 1;
    var reverseScores = reversed || !scoresInSideOrder;
    var outcomeString = addOutcomeString
        ? getOutcomeString({ matchUpStatus: matchUpStatus })
        : '';
    var setScores = (sets === null || sets === void 0 ? void 0 : sets.sort(setSort).map(setString).filter(Boolean).join(' ')) || '';
    if (!outcomeString)
        return setScores;
    if (winningSide === 2)
        return "".concat(outcomeString, " ").concat(setScores);
    return "".concat(setScores, " ").concat(outcomeString);
    function setString(currentSet) {
        var isFinalSet = bestOf && currentSet.setNumber === bestOf;
        var format = isFinalSet && finalSetFormat ? finalSetFormat : setFormat;
        var hasGameScores = function (set) {
            return isNumeric(set === null || set === void 0 ? void 0 : set.side1Score) || isNumeric(set === null || set === void 0 ? void 0 : set.side2Score);
        };
        var hasTiebreakScores = function (set) {
            return isNumeric(set === null || set === void 0 ? void 0 : set.side1TiebreakScore) || isNumeric(set === null || set === void 0 ? void 0 : set.side2TiebreakScore);
        };
        var isTiebreakSet = (format === null || format === void 0 ? void 0 : format.tiebreakSet) ||
            (!hasGameScores(currentSet) && hasTiebreakScores(currentSet));
        var side1Score = currentSet.side1Score, side2Score = currentSet.side2Score, side1TiebreakScore = currentSet.side1TiebreakScore, side2TiebreakScore = currentSet.side2TiebreakScore;
        var t1 = side1TiebreakScore ||
            (isNumeric(side1TiebreakScore) || autoComplete ? 0 : '');
        var t2 = side2TiebreakScore ||
            (isNumeric(side2TiebreakScore) || autoComplete ? 0 : '');
        if (isTiebreakSet) {
            var tiebreakScore = reverseScores ? [t2, t1] : [t1, t2];
            return "[".concat(tiebreakScore.join('-'), "]");
        }
        var lowTiebreakScore = Math.min(t1, t2);
        var tiebreak = lowTiebreakScore ? "(".concat(lowTiebreakScore, ")") : '';
        var s1 = side1Score || (isNumeric(side1Score) || autoComplete ? 0 : '');
        var s2 = side2Score || (isNumeric(side2Score) || autoComplete ? 0 : '');
        var scoreString = reverseScores
            ? "".concat([s2, s1].join('-')).concat(tiebreak)
            : "".concat([s1, s2].join('-')).concat(tiebreak);
        if (['-', ' '].includes(scoreString))
            scoreString = '';
        return scoreString;
    }
}
function getOutcomeString(_a) {
    var _b;
    var matchUpStatus = _a.matchUpStatus;
    var outcomeStrings = (_b = {},
        _b[RETIRED$1] = 'RET',
        _b[WALKOVER$2] = 'WO',
        _b[DOUBLE_DEFAULT] = 'DF/DF',
        _b[DOUBLE_WALKOVER] = 'WO/WO',
        _b[SUSPENDED] = 'SUS',
        _b[ABANDONED$1] = 'ABN',
        _b[DEFAULTED] = 'DEF',
        _b[DEAD_RUBBER] = 'DR',
        _b);
    return (matchUpStatus && outcomeStrings[matchUpStatus]) || '';
}
function setSort(a, b) {
    return a.setNumber - b.setNumber;
}

function matchUpScore(params) {
    var matchUpFormat = params.matchUpFormat, matchUpStatus = params.matchUpStatus, winningSide = params.winningSide, score = params.score;
    if (!score)
        return { sets: [] };
    var sets = score.sets || [];
    var scoreStringSide1 = generateScoreString({
        winnerFirst: false,
        matchUpFormat: matchUpFormat,
        matchUpStatus: matchUpStatus,
        sets: sets,
    });
    var scoreStringSide2 = generateScoreString({
        winnerFirst: false,
        reversed: true,
        matchUpFormat: matchUpFormat,
        matchUpStatus: matchUpStatus,
        sets: sets,
    });
    var winnerPerspective = generateScoreString({
        matchUpFormat: matchUpFormat,
        matchUpStatus: matchUpStatus,
        winningSide: winningSide,
        sets: sets,
    });
    var loserPerspective = scoreStringSide1 === winnerPerspective
        ? scoreStringSide2
        : scoreStringSide1;
    if (winningSide) {
        scoreStringSide1 = winningSide === 1 ? winnerPerspective : loserPerspective;
        scoreStringSide2 = winningSide === 2 ? winnerPerspective : loserPerspective;
    }
    return {
        score: {
            sets: sets,
            scoreStringSide1: scoreStringSide1,
            scoreStringSide2: scoreStringSide2,
        },
    };
}

function setMatchUpStatus(params) {
    var _a, _b;
    var tournamentRecords = resolveTournamentRecords(params);
    if (!params.drawDefinition) {
        var tournamentRecord_1 = (_a = params.tournamentRecord) !== null && _a !== void 0 ? _a : (params.tournamentId && tournamentRecords[params.tournamentId]);
        if (!params.tournamentRecord)
            params.tournamentRecord = tournamentRecord_1;
        var result = findEvent({
            eventId: params.eventId,
            drawId: params.drawId,
            tournamentRecord: tournamentRecord_1,
        });
        if (result.error)
            return result;
        if (result.drawDefinition)
            params.drawDefinition = result.drawDefinition;
        params.event = result.event;
    }
    var policyDefinitions = params.policyDefinitions, tournamentRecord = params.tournamentRecord, disableAutoCalc = params.disableAutoCalc, enableAutoCalc = params.enableAutoCalc, drawDefinition = params.drawDefinition, matchUpFormat = params.matchUpFormat, matchUpId = params.matchUpId, schedule = params.schedule, event = params.event, notes = params.notes;
    if (!drawDefinition)
        return { error: MISSING_DRAW_ID };
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    var policy = findPolicy({
        policyType: POLICY_TYPE_SCORING,
        tournamentRecord: tournamentRecord,
        event: event,
    }).policy;
    // whether or not to allow winningSide change propagation
    var allowChangePropagation = (params.allowChangePropagation !== undefined &&
        params.allowChangePropagation) ||
        ((policy === null || policy === void 0 ? void 0 : policy.allowChangePropagation) !== undefined &&
            policy.allowChangePropagation) ||
        undefined;
    var outcome = params.outcome;
    if (matchUpFormat) {
        var result = setMatchUpMatchUpFormat({
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpFormat: matchUpFormat,
            matchUpId: matchUpId,
            event: event,
        });
        if (result.error)
            return result;
    }
    if (((_b = outcome === null || outcome === void 0 ? void 0 : outcome.score) === null || _b === void 0 ? void 0 : _b.sets) && !outcome.score.scoreStringSide1) {
        var scoreObject = matchUpScore(outcome).score;
        outcome.score = scoreObject;
        outcome.score.sets = outcome.score.sets.filter(function (set) {
            return set.side1Score ||
                set.side2Score ||
                set.side1TiebreakScore ||
                set.side2TiebreakScore;
        });
    }
    return setMatchUpState({
        matchUpStatusCodes: outcome === null || outcome === void 0 ? void 0 : outcome.matchUpStatusCodes,
        matchUpStatus: outcome === null || outcome === void 0 ? void 0 : outcome.matchUpStatus,
        winningSide: outcome === null || outcome === void 0 ? void 0 : outcome.winningSide,
        allowChangePropagation: allowChangePropagation,
        score: outcome === null || outcome === void 0 ? void 0 : outcome.score,
        tournamentRecords: tournamentRecords,
        policyDefinitions: policyDefinitions,
        tournamentRecord: tournamentRecord,
        disableAutoCalc: disableAutoCalc,
        enableAutoCalc: enableAutoCalc,
        drawDefinition: drawDefinition,
        matchUpFormat: matchUpFormat,
        matchUpId: matchUpId,
        schedule: schedule,
        event: event,
        notes: notes,
    });
}

function addCollectionDefinition(_a) {
    var e_1, _b, e_2, _c, _d, e_3, _e;
    var _f, _g, _h, _j, _k, _l, _m, _o, _p;
    var _q = _a.updateInProgressMatchUps, updateInProgressMatchUps = _q === void 0 ? true : _q, collectionDefinition = _a.collectionDefinition, referenceCategory = _a.referenceCategory, tournamentRecord = _a.tournamentRecord, policyDefinitions = _a.policyDefinitions, enforceCategory = _a.enforceCategory, referenceGender = _a.referenceGender, drawDefinition = _a.drawDefinition, tieFormatName = _a.tieFormatName, enforceGender = _a.enforceGender, structureId = _a.structureId, matchUpId = _a.matchUpId, matchUp = _a.matchUp, eventId = _a.eventId, uuids = _a.uuids, event = _a.event;
    var stack = 'addCollectionDefinition';
    var appliedPolicies = (_f = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        event: event,
    }).appliedPolicies) !== null && _f !== void 0 ? _f : {};
    var matchUpActionsPolicy = (_g = policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_MATCHUP_ACTIONS]) !== null && _g !== void 0 ? _g : appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_MATCHUP_ACTIONS];
    enforceCategory = enforceCategory !== null && enforceCategory !== void 0 ? enforceCategory : (_h = matchUpActionsPolicy === null || matchUpActionsPolicy === void 0 ? void 0 : matchUpActionsPolicy.participants) === null || _h === void 0 ? void 0 : _h.enforceCategory;
    var genderEnforced = (enforceGender !== null && enforceGender !== void 0 ? enforceGender : (_j = matchUpActionsPolicy === null || matchUpActionsPolicy === void 0 ? void 0 : matchUpActionsPolicy.participants) === null || _j === void 0 ? void 0 : _j.enforceGender) !== false;
    var checkCategory = !!((referenceCategory !== null && referenceCategory !== void 0 ? referenceCategory : event === null || event === void 0 ? void 0 : event.category) && enforceCategory !== false);
    var checkGender = !!((referenceGender !== null && referenceGender !== void 0 ? referenceGender : event === null || event === void 0 ? void 0 : event.gender) && genderEnforced);
    var validationResult = validateCollectionDefinition({
        referenceCategory: referenceCategory !== null && referenceCategory !== void 0 ? referenceCategory : event === null || event === void 0 ? void 0 : event.category,
        collectionDefinition: collectionDefinition,
        referenceGender: referenceGender,
        checkCategory: checkCategory,
        checkGender: checkGender,
        event: event,
    });
    if (validationResult.error) {
        return decorateResult({ result: validationResult, stack: stack });
    }
    var result = !(matchUp === null || matchUp === void 0 ? void 0 : matchUp.tieFormat)
        ? getTieFormat$1({
            drawDefinition: drawDefinition,
            structureId: structureId,
            matchUpId: matchUpId,
            eventId: eventId,
            event: event,
        })
        : undefined;
    if (result === null || result === void 0 ? void 0 : result.error)
        return decorateResult({ result: { error: result.error }, stack: stack });
    var structure = result === null || result === void 0 ? void 0 : result.structure;
    matchUp = matchUp !== null && matchUp !== void 0 ? matchUp : result === null || result === void 0 ? void 0 : result.matchUp;
    var existingTieFormat = (_k = matchUp === null || matchUp === void 0 ? void 0 : matchUp.tieFormat) !== null && _k !== void 0 ? _k : result === null || result === void 0 ? void 0 : result.tieFormat;
    var tieFormat = copyTieFormat(existingTieFormat);
    result = validateTieFormat({ tieFormat: tieFormat });
    if (result === null || result === void 0 ? void 0 : result.error) {
        return decorateResult({ result: { error: result.error }, stack: stack });
    }
    if (!collectionDefinition.collectionId) {
        collectionDefinition.collectionId = UUID();
    }
    else {
        var collectionIds = tieFormat.collectionDefinitions.map(function (_a) {
            var collectionId = _a.collectionId;
            return collectionId;
        });
        if (collectionIds.includes(collectionDefinition.collectionId))
            return decorateResult({
                context: { collectionId: collectionDefinition.collectionId },
                result: { error: DUPLICATE_VALUE },
            });
    }
    tieFormat.collectionDefinitions.push(collectionDefinition);
    tieFormat.collectionDefinitions
        .sort(function (a, b) { return (a.collectionOrder || 0) - (b.collectionOrder || 0); })
        .forEach(function (collectionDefinition, i) { return (collectionDefinition.collectionOrder = i + 1); });
    // calculate new winCriteria for tieFormat
    // if existing winCriteria is aggregateValue, retain
    var _r = calculateWinCriteria(tieFormat), aggregateValue = _r.aggregateValue, valueGoal = _r.valueGoal;
    tieFormat.winCriteria = definedAttributes({ aggregateValue: aggregateValue, valueGoal: valueGoal });
    // if valueGoal has changed, force renaming of the tieFormat
    var originalValueGoal = existingTieFormat === null || existingTieFormat === void 0 ? void 0 : existingTieFormat.winCriteria.valueGoal;
    var wasAggregateValue = existingTieFormat === null || existingTieFormat === void 0 ? void 0 : existingTieFormat.winCriteria.aggregateValue;
    if ((originalValueGoal && originalValueGoal !== valueGoal) || (aggregateValue && !wasAggregateValue)) {
        if (tieFormatName) {
            tieFormat.tieFormatName = tieFormatName;
        }
        else {
            delete tieFormat.tieFormatName;
        }
    }
    var modifiedStructureIds = [];
    var addedMatchUps = [];
    var targetMatchUps = [];
    var prunedTieFormat = definedAttributes(tieFormat);
    result = validateTieFormat({ tieFormat: prunedTieFormat });
    if (result === null || result === void 0 ? void 0 : result.error) {
        return decorateResult({ result: { error: result.error }, stack: stack });
    }
    if (eventId && event) {
        event.tieFormat = prunedTieFormat;
        try {
            // all team matchUps in the event which do not have tieFormats and where draws/strucures do not have tieFormats should have matchUps added
            for (var _s = __values((_l = event.drawDefinitions) !== null && _l !== void 0 ? _l : []), _t = _s.next(); !_t.done; _t = _s.next()) {
                var drawDefinition_1 = _t.value;
                if (drawDefinition_1.tieFormat)
                    continue;
                try {
                    for (var _u = (e_2 = void 0, __values((_m = drawDefinition_1.structures) !== null && _m !== void 0 ? _m : [])), _v = _u.next(); !_v.done; _v = _u.next()) {
                        var structure_1 = _v.value;
                        if (structure_1.tieFormat)
                            continue;
                        var result_1 = updateStructureMatchUps({
                            updateInProgressMatchUps: updateInProgressMatchUps,
                            collectionDefinition: collectionDefinition,
                            structure: structure_1,
                            uuids: uuids,
                        });
                        addedMatchUps.push.apply(addedMatchUps, __spreadArray([], __read(result_1.newMatchUps), false));
                        targetMatchUps.push.apply(targetMatchUps, __spreadArray([], __read(result_1.targetMatchUps), false));
                        modifiedStructureIds.push(structure_1.structureId);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_v && !_v.done && (_c = _u.return)) _c.call(_u);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_t && !_t.done && (_b = _s.return)) _b.call(_s);
            }
            finally { if (e_1) throw e_1.error; }
        }
        queueNoficiations({
            modifiedMatchUps: targetMatchUps,
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            modifiedStructureIds: modifiedStructureIds,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            addedMatchUps: addedMatchUps,
            stack: stack,
        });
    }
    else if (structureId && structure) {
        structure.tieFormat = prunedTieFormat;
        var result_2 = updateStructureMatchUps({
            updateInProgressMatchUps: updateInProgressMatchUps,
            collectionDefinition: collectionDefinition,
            structure: structure,
            uuids: uuids,
        });
        addedMatchUps.push.apply(addedMatchUps, __spreadArray([], __read(result_2.newMatchUps), false));
        targetMatchUps = result_2.targetMatchUps;
        queueNoficiations({
            modifiedMatchUps: targetMatchUps,
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            modifiedStructureIds: modifiedStructureIds,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            addedMatchUps: addedMatchUps,
            stack: stack,
        });
    }
    else if (matchUpId && matchUp) {
        if (!validUpdate({ matchUp: matchUp, updateInProgressMatchUps: updateInProgressMatchUps }))
            return decorateResult({
                result: { error: CANNOT_MODIFY_TIEFORMAT },
                stack: stack,
            });
        matchUp.tieFormat = prunedTieFormat;
        var newMatchUps = generateCollectionMatchUps({
            collectionDefinition: collectionDefinition,
            matchUp: matchUp,
            uuids: uuids,
        });
        if (!Array.isArray(matchUp.tieMatchUps))
            matchUp.tieMatchUps = [];
        (_d = matchUp.tieMatchUps).push.apply(_d, __spreadArray([], __read(newMatchUps), false));
        addedMatchUps.push.apply(addedMatchUps, __spreadArray([], __read(newMatchUps), false));
        queueNoficiations({
            modifiedMatchUps: [matchUp],
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            modifiedStructureIds: modifiedStructureIds,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            addedMatchUps: addedMatchUps,
            stack: stack,
        });
    }
    else if (drawDefinition) {
        // all team matchUps in the drawDefinition which do not have tieFormats and where strucures do not have tieFormats should have matchUps added
        drawDefinition.tieFormat = prunedTieFormat;
        try {
            for (var _w = __values((_o = drawDefinition.structures) !== null && _o !== void 0 ? _o : []), _x = _w.next(); !_x.done; _x = _w.next()) {
                var structure_2 = _x.value;
                var result_3 = updateStructureMatchUps({
                    updateInProgressMatchUps: updateInProgressMatchUps,
                    collectionDefinition: collectionDefinition,
                    structure: structure_2,
                    uuids: uuids,
                });
                modifiedStructureIds.push(structure_2.structureId);
                addedMatchUps.push.apply(addedMatchUps, __spreadArray([], __read(result_3.newMatchUps), false));
                targetMatchUps.push.apply(targetMatchUps, __spreadArray([], __read(result_3.targetMatchUps), false));
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_x && !_x.done && (_e = _w.return)) _e.call(_w);
            }
            finally { if (e_3) throw e_3.error; }
        }
        queueNoficiations({
            modifiedMatchUps: targetMatchUps,
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            addedMatchUps: addedMatchUps,
            stack: stack,
        });
    }
    else {
        return { error: MISSING_DRAW_DEFINITION };
    }
    if ((_p = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.audit) === null || _p === void 0 ? void 0 : _p[TIE_FORMAT_MODIFICATIONS]) {
        var auditData = definedAttributes({
            drawId: drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.drawId,
            collectionDefinition: collectionDefinition,
            action: stack,
            structureId: structureId,
            matchUpId: matchUpId,
            eventId: eventId,
        });
        tieFormatTelemetry({ drawDefinition: drawDefinition, auditData: auditData });
    }
    return __assign({ tieFormat: prunedTieFormat, targetMatchUps: targetMatchUps, addedMatchUps: addedMatchUps }, SUCCESS);
}
function updateStructureMatchUps(_a) {
    var e_4, _b, _c;
    var _d;
    var updateInProgressMatchUps = _a.updateInProgressMatchUps, collectionDefinition = _a.collectionDefinition, structure = _a.structure, uuids = _a.uuids;
    var newMatchUps = [];
    var matchUps = (_d = getAllStructureMatchUps({
        matchUpFilters: { matchUpTypes: [TEAM] },
        structure: structure,
    })) === null || _d === void 0 ? void 0 : _d.matchUps;
    // all team matchUps in the structure which are not completed and which have no score value should have matchUps added
    var targetMatchUps = matchUps.filter(function (matchUp) { return validUpdate({ matchUp: matchUp, updateInProgressMatchUps: updateInProgressMatchUps }) && !matchUp.tieFormat; });
    try {
        for (var targetMatchUps_1 = __values(targetMatchUps), targetMatchUps_1_1 = targetMatchUps_1.next(); !targetMatchUps_1_1.done; targetMatchUps_1_1 = targetMatchUps_1.next()) {
            var matchUp = targetMatchUps_1_1.value;
            var tieMatchUps = generateCollectionMatchUps({
                collectionDefinition: collectionDefinition,
                matchUp: matchUp,
                uuids: uuids,
            });
            if (!Array.isArray(matchUp.tieMatchUps))
                matchUp.tieMatchUps = [];
            (_c = matchUp.tieMatchUps).push.apply(_c, __spreadArray([], __read(tieMatchUps), false));
            newMatchUps.push.apply(newMatchUps, __spreadArray([], __read(tieMatchUps), false));
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (targetMatchUps_1_1 && !targetMatchUps_1_1.done && (_b = targetMatchUps_1.return)) _b.call(targetMatchUps_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return { newMatchUps: newMatchUps, targetMatchUps: targetMatchUps };
}
function queueNoficiations(_a) {
    var modifiedStructureIds = _a.modifiedStructureIds, tournamentRecord = _a.tournamentRecord, modifiedMatchUps = _a.modifiedMatchUps, drawDefinition = _a.drawDefinition, addedMatchUps = _a.addedMatchUps, eventId = _a.eventId, stack = _a.stack;
    addMatchUpsNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        matchUps: addedMatchUps,
        drawDefinition: drawDefinition,
        eventId: eventId,
    });
    modifiedMatchUps === null || modifiedMatchUps === void 0 ? void 0 : modifiedMatchUps.forEach(function (matchUp) {
        modifyMatchUpNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            drawDefinition: drawDefinition,
            context: stack,
            matchUp: matchUp,
            eventId: eventId,
        });
    });
    modifyDrawNotice({
        structureIds: modifiedStructureIds,
        drawDefinition: drawDefinition,
        eventId: eventId,
    });
}

function attachPolicies(params) {
    var _a, _b, e_1, _c;
    var _d, _e, _f, _g;
    var checkParams = checkRequiredParameters(params, [
        (_a = {
                _anyOf: (_b = {},
                    _b[TOURNAMENT_RECORDS] = false,
                    _b[TOURNAMENT_RECORD] = false,
                    _b[DRAW_DEFINITION] = false,
                    _b[EVENT] = false,
                    _b)
            },
            _a[POLICY_DEFINITIONS] = true,
            _a),
    ]);
    if (checkParams.error)
        return checkParams;
    var applied = [];
    var element = (_e = (_d = params.drawDefinition) !== null && _d !== void 0 ? _d : params.event) !== null && _e !== void 0 ? _e : ((params.tournamentId || !params.tournamentRecords) && params.tournamentRecord);
    if (element) {
        var result = policyAttachement(params, element);
        if (result.error)
            return result;
        applied.push.apply(applied, __spreadArray([], __read(((_f = result === null || result === void 0 ? void 0 : result.applied) !== null && _f !== void 0 ? _f : [])), false));
        if (params.drawDefinition) {
            modifyDrawNotice({
                drawDefinition: params.drawDefinition,
                tournamentId: params.tournamentId,
            });
        }
    }
    else if (params.tournamentRecords) {
        var tournamentIds = Object.keys(params.tournamentRecords);
        if (!tournamentIds.length)
            return { error: MISSING_TOURNAMENT_RECORD };
        try {
            for (var tournamentIds_1 = __values(tournamentIds), tournamentIds_1_1 = tournamentIds_1.next(); !tournamentIds_1_1.done; tournamentIds_1_1 = tournamentIds_1.next()) {
                var tournamentId = tournamentIds_1_1.value;
                var tournamentRecord = params.tournamentRecords[tournamentId];
                var result = policyAttachement(params, tournamentRecord);
                if (result.error)
                    return result;
                applied.push.apply(applied, __spreadArray([], __read(((_g = result === null || result === void 0 ? void 0 : result.applied) !== null && _g !== void 0 ? _g : [])), false));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (tournamentIds_1_1 && !tournamentIds_1_1.done && (_c = tournamentIds_1.return)) _c.call(tournamentIds_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else {
        return { error: MISSING_TOURNAMENT_RECORD };
    }
    return !applied.length ? { error: EXISTING_POLICY_TYPE } : __assign(__assign({}, SUCCESS), { applied: applied });
}
function policyAttachement(params, element) {
    var e_2, _a;
    var _b;
    var appliedPolicies = (_b = getAppliedPolicies(params).appliedPolicies) !== null && _b !== void 0 ? _b : {};
    if (!element.extensions)
        element.extensions = [];
    var applied = [];
    var policyTypes = Object.keys(params.policyDefinitions);
    if (!policyTypes.length)
        return { error: MISSING_POLICY_DEFINITION };
    try {
        for (var policyTypes_1 = __values(policyTypes), policyTypes_1_1 = policyTypes_1.next(); !policyTypes_1_1.done; policyTypes_1_1 = policyTypes_1.next()) {
            var policyType = policyTypes_1_1.value;
            if (!appliedPolicies[policyType] || params.allowReplacement) {
                var policy = params.policyDefinitions[policyType];
                if (!policy)
                    continue;
                if (!isObject(policy))
                    return { error: INVALID_VALUES };
                var policyName = policy.policyName, values = __rest(policy, ["policyName"]);
                if (!values || !Object.keys(values).length || (policyName && !isString(policyName)))
                    return { error: INVALID_VALUES };
                appliedPolicies[policyType] = params.policyDefinitions[policyType];
                applied.push(policyType);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (policyTypes_1_1 && !policyTypes_1_1.done && (_a = policyTypes_1.return)) _a.call(policyTypes_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    if (applied === null || applied === void 0 ? void 0 : applied.length) {
        var extension = { name: APPLIED_POLICIES, value: appliedPolicies };
        return __assign(__assign({}, addExtension({ element: element, extension: extension })), { applied: applied });
    }
    return { applied: applied, error: EXISTING_POLICY_TYPE };
}

function modifyDrawName(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, flightProfile = _a.flightProfile, drawName = _a.drawName, drawId = _a.drawId, event = _a.event;
    if (!drawName || typeof drawName !== 'string')
        return decorateResult({
            result: { error: INVALID_VALUES },
            context: { drawName: drawName },
        });
    if (!flightProfile) {
        flightProfile = getFlightProfile({ event: event }).flightProfile;
    }
    var flight = (_b = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _b === void 0 ? void 0 : _b.find(function (flight) { return flight.drawId === drawId; });
    if (flight) {
        flight.drawName = drawName;
        var extension = {
            name: FLIGHT_PROFILE,
            value: __assign(__assign({}, flightProfile), { flights: flightProfile.flights }),
        };
        addEventExtension({ event: event, extension: extension });
    }
    if (drawDefinition) {
        drawDefinition.drawName = drawName;
        modifyDrawNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            drawDefinition: drawDefinition,
        });
    }
    if (!flight && !drawDefinition) {
        return { error: MISSING_DRAW_DEFINITION };
    }
    return __assign(__assign({}, SUCCESS), { flight: flight });
}

function modifyDrawDefinition(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawUpdates = _a.drawUpdates, drawId = _a.drawId, event = _a.event;
    if (!isObject(drawUpdates))
        return { error: INVALID_VALUES };
    var flightProfile = getFlightProfile({ event: event }).flightProfile;
    var nameResult = drawUpdates.drawName &&
        modifyDrawName({
            drawName: drawUpdates.drawName,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            flightProfile: flightProfile,
            drawId: drawId,
            event: event,
        });
    if (nameResult === null || nameResult === void 0 ? void 0 : nameResult.error)
        return nameResult === null || nameResult === void 0 ? void 0 : nameResult.error;
    var flight = (nameResult === null || nameResult === void 0 ? void 0 : nameResult.flight) ||
        ((_b = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _b === void 0 ? void 0 : _b.find(function (flight) { return flight.drawId === drawId; }));
    if (!flight && !drawDefinition) {
        return { error: MISSING_DRAW_DEFINITION };
    }
    if (flight) {
        // TODO: any relevant changes to flightProfile
        var extension = {
            name: FLIGHT_PROFILE,
            value: __assign(__assign({}, flightProfile), { flights: flightProfile.flights }),
        };
        addEventExtension({ event: event, extension: extension });
    }
    if (drawDefinition) {
        if (drawUpdates.policyDefinitions) {
            attachPolicies({
                policyDefinitions: drawUpdates.policyDefinitions,
                drawDefinition: drawDefinition,
            });
        }
        // TODO: any relevant changes to drawDefinition
        modifyDrawNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            drawDefinition: drawDefinition,
        });
    }
    return __assign({}, SUCCESS);
}

function setDelegatedOutcome$1(_a) {
    var _b, _c;
    var drawDefinition = _a.drawDefinition, matchUpId = _a.matchUpId, outcome = _a.outcome, matchUp = _a.matchUp;
    if (!matchUp && !drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!outcome)
        return { error: MISSING_VALUE, info: 'missing outcome' };
    if (!matchUp && !matchUpId)
        return { error: MISSING_MATCHUP };
    if (!matchUp) {
        var result = findDrawMatchUp({
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
        });
        if (result.error)
            return result;
        matchUp = result.matchUp;
    }
    if (typeof outcome !== 'object' ||
        !((_b = outcome.score) === null || _b === void 0 ? void 0 : _b.scoreStringSide1) ||
        !((_c = outcome.score) === null || _c === void 0 ? void 0 : _c.scoreStringSide2)) {
        return { error: INVALID_VALUES };
    }
    // TODO: check validity of outcome
    var extension = {
        name: DELEGATED_OUTCOME,
        value: outcome,
    };
    return addExtension({ element: matchUp, extension: extension });
}

function setDelegatedOutcome(params) {
    return setDelegatedOutcome$1(params);
}

function bulkMatchUpStatusUpdate(params) {
    var _a, e_1, _b;
    var _c;
    if (!(params === null || params === void 0 ? void 0 : params.outcomes))
        return { error: MISSING_VALUE };
    if (!Array.isArray(params.outcomes))
        return { error: MISSING_VALUE, info: { outcomes: params.outcomes } };
    var tournamentRecords = params.tournamentRecords ||
        (params.tournamentRecord && (_a = {},
            _a[params.tournamentRecord.tournamentId] = params.tournamentRecord,
            _a)) ||
        {};
    var outcomes = (_c = params.outcomes) !== null && _c !== void 0 ? _c : [];
    var tournamentIds = outcomes.reduce(function (tournamentIds, outcome) {
        return !tournamentIds.includes(outcome.tournamentId)
            ? tournamentIds.concat(outcome.tournamentId)
            : tournamentIds;
    }, []);
    var _loop_1 = function (tournamentId) {
        var tournamentRecord = tournamentRecords[tournamentId];
        if (!tournamentRecord)
            return { value: { error: MISSING_TOURNAMENT_RECORD } };
        var tournamentOutcomes = outcomes.filter(function (outcome) { return outcome.tournamentId === tournamentId; });
        if (tournamentOutcomes.length) {
            var result = bulkUpdate({
                outcomes: tournamentOutcomes,
                tournamentRecord: tournamentRecord,
            });
            if (result.error)
                return { value: result };
        }
    };
    try {
        for (var tournamentIds_1 = __values(tournamentIds), tournamentIds_1_1 = tournamentIds_1.next(); !tournamentIds_1_1.done; tournamentIds_1_1 = tournamentIds_1.next()) {
            var tournamentId = tournamentIds_1_1.value;
            var state_1 = _loop_1(tournamentId);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (tournamentIds_1_1 && !tournamentIds_1_1.done && (_b = tournamentIds_1.return)) _b.call(tournamentIds_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}
function bulkUpdate(params) {
    var e_2, _a, e_3, _b;
    var _c;
    var tournamentRecords = params.tournamentRecords, tournamentRecord = params.tournamentRecord, outcomes = params.outcomes, policyDefinitions = params.policyDefinitions;
    var events = {};
    // group outcomes by events to optimize
    outcomes.forEach(function (outcome) {
        var eventId = outcome.eventId;
        if (!events[eventId])
            events[eventId] = [];
        events[eventId].push(outcome);
    });
    try {
        for (var _d = __values(Object.keys(events)), _e = _d.next(); !_e.done; _e = _d.next()) {
            var eventId = _e.value;
            var event_1 = findEvent({ tournamentRecord: tournamentRecord, eventId: eventId }).event;
            var _loop_2 = function (outcome) {
                var drawId = outcome.drawId;
                var drawDefinition = (_c = event_1 === null || event_1 === void 0 ? void 0 : event_1.drawDefinitions) === null || _c === void 0 ? void 0 : _c.find(function (drawDefinition) { return drawDefinition.drawId === drawId; });
                if (drawDefinition && drawId) {
                    var matchUpFormat = outcome.matchUpFormat, matchUpId = outcome.matchUpId;
                    var result = setMatchUpStatus({
                        schedule: outcome === null || outcome === void 0 ? void 0 : outcome.schedule,
                        tournamentRecords: tournamentRecords,
                        policyDefinitions: policyDefinitions,
                        tournamentRecord: tournamentRecord,
                        drawDefinition: drawDefinition,
                        matchUpFormat: matchUpFormat,
                        matchUpId: matchUpId,
                        outcome: outcome,
                        drawId: drawId,
                        event: event_1,
                    });
                    if (result.error) {
                        return { value: result };
                    }
                }
            };
            try {
                for (var _f = (e_3 = void 0, __values(events[eventId])), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var outcome = _g.value;
                    var state_2 = _loop_2(outcome);
                    if (typeof state_2 === "object")
                        return state_2.value;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return __assign({}, SUCCESS);
}

function resetDrawDefinition(_a) {
    var e_1, _b, e_2, _c;
    var _d;
    var tournamentRecord = _a.tournamentRecord, removeScheduling = _a.removeScheduling, drawDefinition = _a.drawDefinition;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    // for matchups in all structures:
    // remove all drawPositions which are not first round or fed
    // remove all extensions
    // if removeScheudling, remove all scheduling timeItems
    // for all structures which are NOT QUALIFYING or MAIN { stageSequence: 1 }
    // remove all positionAssignments that are not BYE
    var matchUpsMap = getMatchUpsMap({ drawDefinition: drawDefinition });
    var getRawMatchUp = function (matchUpId) {
        var _a;
        return (_a = matchUpsMap === null || matchUpsMap === void 0 ? void 0 : matchUpsMap.drawMatchUps) === null || _a === void 0 ? void 0 : _a.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
    };
    try {
        for (var _e = __values(drawDefinition.structures || []), _f = _e.next(); !_f.done; _f = _e.next()) {
            var structure = _f.value;
            var positionAssignments = structure.positionAssignments, stage = structure.stage, stageSequence = structure.stageSequence;
            // reset positionAssignments and seedAssignments where appropriate
            if (positionAssignments &&
                (stageSequence !== 1 || ![QUALIFYING, MAIN].includes(stage))) {
                structure.positionAssignments = positionAssignments.map(function (assignment) {
                    delete assignment.participantId;
                    return assignment;
                });
                structure.seedAssignments = [];
            }
            var inContextMatchUps = getAllStructureMatchUps({
                afterRecoveryTimes: false,
                inContext: true,
                matchUpsMap: matchUpsMap,
                structure: structure,
            }).matchUps;
            var _loop_1 = function (inContextMatchUp) {
                var matchUpId = inContextMatchUp.matchUpId, roundNumber = inContextMatchUp.roundNumber, sides = inContextMatchUp.sides;
                var matchUp = getRawMatchUp(matchUpId);
                if (matchUp) {
                    delete matchUp.extensions;
                    delete matchUp.notes;
                    if (matchUp.matchUpStatus !== BYE) {
                        Object.assign(matchUp, toBePlayed);
                    }
                    if (roundNumber && roundNumber > 1 && matchUp.drawPositions) {
                        var fedDrawPositions_1 = sides === null || sides === void 0 ? void 0 : sides.map(function (_a) {
                            var drawPosition = _a.drawPosition, participantFed = _a.participantFed;
                            return !participantFed && drawPosition;
                        }).filter(Boolean);
                        var drawPositions = matchUp.drawPositions.map(function (drawPosition) {
                            return !fedDrawPositions_1.includes(drawPosition) ? drawPosition : undefined;
                        });
                        matchUp.drawPositions = drawPositions;
                    }
                    if (removeScheduling) {
                        delete matchUp.timeItems;
                    }
                    else if ((_d = matchUp.timeItems) === null || _d === void 0 ? void 0 : _d.length) {
                        matchUp.timeItems = matchUp.timeItems.filter(function (timeItem) {
                            return timeItem.itemType &&
                                ![
                                    ALLOCATE_COURTS,
                                    ASSIGN_COURT,
                                    ASSIGN_VENUE,
                                    ASSIGN_OFFICIAL,
                                    SCHEDULED_DATE,
                                    SCHEDULED_TIME,
                                ].includes(timeItem.itemType);
                        });
                    }
                    modifyMatchUpNotice({
                        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                        context: 'resetDrawDefiniton',
                        drawDefinition: drawDefinition,
                        matchUp: matchUp,
                    });
                }
            };
            try {
                // reset all matchUps to initial state
                for (var inContextMatchUps_1 = (e_2 = void 0, __values(inContextMatchUps)), inContextMatchUps_1_1 = inContextMatchUps_1.next(); !inContextMatchUps_1_1.done; inContextMatchUps_1_1 = inContextMatchUps_1.next()) {
                    var inContextMatchUp = inContextMatchUps_1_1.value;
                    _loop_1(inContextMatchUp);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (inContextMatchUps_1_1 && !inContextMatchUps_1_1.done && (_c = inContextMatchUps_1.return)) _c.call(inContextMatchUps_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var structureIds = (drawDefinition.structures || []).map(function (_a) {
        var structureId = _a.structureId;
        return structureId;
    });
    modifyDrawNotice({ drawDefinition: drawDefinition, structureIds: structureIds });
    return __assign({}, SUCCESS);
}

function analyzeDraws(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var drawsAnalysis = {
        positionsNoOutcomes: [], // all positions assigned and no outcomes
        canBePruned: [], // partially assigned positions with outcomes => drawSizes can be reduced
        matchPlay: [], // only first round has active matchUps; some unassigned positions
        inactive: [],
        drawAnalysis: {},
    };
    var eventsMap = {};
    var eventDraws = (_b = tournamentRecord.events) === null || _b === void 0 ? void 0 : _b.map(function (event) {
        var eventId = event.eventId;
        eventsMap[eventId] = event;
        return ((event === null || event === void 0 ? void 0 : event.drawDefinitions) || []).map(function (drawDefinition) { return ({
            drawDefinition: drawDefinition,
            eventId: eventId,
        }); });
    }).flat().filter(Boolean);
    eventDraws.forEach(function (_a) {
        var drawDefinition = _a.drawDefinition, eventId = _a.eventId;
        var positionsAssignedCount = 0;
        var matchUpsWithWinningSideCount = 0;
        var matchUpsNoOutcomeCount = 0;
        var allStructuresLinked = getStructureGroups({ drawDefinition: drawDefinition }).allStructuresLinked;
        var event = eventsMap[eventId];
        var structures = (drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) || [];
        var structuresData = structures.map(function (structure) {
            var _a, _b, _c, _d;
            var stage = structure.stage, stageSequence = structure.stageSequence, structureId = structure.structureId;
            var orderNumber = stageOrder$1[stage];
            var inContextStructureMatchUps = getStructureDrawPositionProfiles({
                drawDefinition: drawDefinition,
                structure: structure,
                event: event,
            }).inContextStructureMatchUps;
            var matchUpsWithWinningSide = inContextStructureMatchUps === null || inContextStructureMatchUps === void 0 ? void 0 : inContextStructureMatchUps.filter(function (_a) {
                var winningSide = _a.winningSide;
                return winningSide;
            });
            var winningSideCount = matchUpsWithWinningSide.filter(Boolean).length || 0;
            matchUpsWithWinningSideCount += winningSideCount;
            matchUpsNoOutcomeCount +=
                inContextStructureMatchUps.length - matchUpsWithWinningSideCount;
            var maxWinningSideFirstRoundPosition = Math.max(matchUpsWithWinningSide
                .filter(function (_a) {
                var roundNumber = _a.roundNumber;
                return roundNumber === 1;
            })
                .map(function (_a) {
                var roundPosition = _a.roundPosition;
                return roundPosition;
            }));
            var positionAssignments = getPositionAssignments$1({ structure: structure }).positionAssignments;
            var positionsAssigned = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (_a) {
                var participantId = _a.participantId;
                return participantId;
            });
            positionsAssignedCount += (_a = positionsAssigned === null || positionsAssigned === void 0 ? void 0 : positionsAssigned.length) !== null && _a !== void 0 ? _a : 0;
            var unassignedPositionsCount = ((_b = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.length) !== null && _b !== void 0 ? _b : 0) - ((_c = positionsAssigned === null || positionsAssigned === void 0 ? void 0 : positionsAssigned.length) !== null && _c !== void 0 ? _c : 0);
            var _e = getRoundMatchUps({ matchUps: inContextStructureMatchUps }), roundMatchUps = _e.roundMatchUps, roundProfile = _e.roundProfile, roundNumbers = _e.roundNumbers, maxMatchUpsCount = _e.maxMatchUpsCount;
            var activeRounds = roundProfile &&
                Object.keys(roundProfile)
                    .filter(function (roundNumber) { return !roundProfile[roundNumber].inactiveRound; })
                    .map(function (roundNumber) { return parseInt(roundNumber); });
            var inactiveRounds = roundProfile &&
                Object.keys(roundProfile)
                    .filter(function (roundNumber) { return roundProfile[roundNumber].inactiveRound; })
                    .map(function (roundNumber) { return parseInt(roundNumber); });
            var inactiveStructure = roundProfile &&
                Object.values(roundProfile).every(function (profile) { return profile.inactiveRound; });
            return {
                positionsAssignedCount: (_d = positionsAssigned === null || positionsAssigned === void 0 ? void 0 : positionsAssigned.length) !== null && _d !== void 0 ? _d : 0,
                maxWinningSideFirstRoundPosition: maxWinningSideFirstRoundPosition,
                unassignedPositionsCount: unassignedPositionsCount,
                inactiveStructure: inactiveStructure,
                maxMatchUpsCount: maxMatchUpsCount,
                inactiveRounds: inactiveRounds,
                roundMatchUps: roundMatchUps,
                activeRounds: activeRounds,
                roundNumbers: roundNumbers,
                roundProfile: roundProfile,
                structureId: structureId,
                stageSequence: stageSequence,
                orderNumber: orderNumber,
                stage: stage,
            };
        });
        var mainStructure = structuresData.find(function (data) { return data.orderNumber === 2 && data.stageSequence === 1; });
        var activeStructuresCount = structuresData.filter(function (_a) {
            var inactiveStructure = _a.inactiveStructure;
            return !inactiveStructure;
        }).length;
        var links = getStructureLinks({
            structureId: mainStructure.structureId,
            drawDefinition: drawDefinition,
        }).links;
        var isMatchPlay = ensureInt(mainStructure.activeRounds[0]) === 1 &&
            mainStructure.activeRounds.length === 1 &&
            activeStructuresCount === 1;
        var inactiveDraw = structuresData === null || structuresData === void 0 ? void 0 : structuresData.every(function (_a) {
            var inactiveStructure = _a.inactiveStructure;
            return inactiveStructure;
        });
        var canBePruned = !links.length &&
            mainStructure.activeRounds.length &&
            (mainStructure.roundProfile[1].inactiveCount ||
                mainStructure.inactiveRounds.length);
        var drawId = drawDefinition.drawId;
        if (positionsAssignedCount && !matchUpsWithWinningSideCount)
            drawsAnalysis.positionsNoOutcomes.push(drawId);
        if (inactiveDraw)
            drawsAnalysis.inactive.push(drawId);
        if (isMatchPlay)
            drawsAnalysis.matchPlay.push(drawId);
        if (canBePruned)
            drawsAnalysis.canBePruned.push(drawId);
        var drawAnalysis = {
            matchUpsWithWinningSideCount: matchUpsWithWinningSideCount,
            matchUpsNoOutcomeCount: matchUpsNoOutcomeCount,
            positionsAssignedCount: positionsAssignedCount,
            allStructuresLinked: allStructuresLinked,
            structuresData: structuresData,
            inactiveDraw: inactiveDraw,
            isMatchPlay: isMatchPlay,
            drawId: drawId,
        };
        drawsAnalysis.drawAnalysis[drawId] = drawAnalysis;
    });
    return __assign(__assign({}, SUCCESS), { drawsAnalysis: drawsAnalysis });
}

function pruneDrawDefinition(_a) {
    var _b, _c;
    var _d = _a.matchPlayDrawPositions, matchPlayDrawPositions = _d === void 0 ? true : _d, // when simply extracting matchUps for aggregation, drawPositions are unnecessary
    tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawId = _a.drawId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var relevantMatchUps = [];
    var drawsAnalysis = analyzeDraws({ tournamentRecord: tournamentRecord }).drawsAnalysis;
    if (drawsAnalysis.canBePruned.includes(drawId)) {
        var isMatchPlay = drawsAnalysis.matchPlay.includes(drawId);
        var drawAnalysis = drawsAnalysis.drawAnalysis[drawId];
        var _e = __read(getDrawStructures({
            stageSequence: 1,
            drawDefinition: drawDefinition,
            stage: MAIN,
        }).structures, 1), mainStructure_1 = _e[0];
        var structureData_1 = drawAnalysis.structuresData.find(function (_a) {
            var structureId = _a.structureId;
            return mainStructure_1.structureId === structureId;
        });
        var matchUps = (_b = mainStructure_1.matchUps) !== null && _b !== void 0 ? _b : [];
        relevantMatchUps = matchUps
            .sort(function (a, b) { return a.roundPosition - b.roundPosition; })
            .filter(function (_a) {
            var roundNumber = _a.roundNumber;
            return !structureData_1.inactiveRounds.includes(roundNumber);
        });
        var relevantMatchUpIds_1 = relevantMatchUps.map(getMatchUpId);
        var deletedMatchUpIds = matchUps
            .map(getMatchUpId)
            .filter(function (matchUpId) { return !relevantMatchUpIds_1.includes(matchUpId); });
        // only ifMatchPlay can the positionAssignments be reallocated
        if (isMatchPlay) {
            var matchPlayMatchUps = relevantMatchUps
                .sort(function (a, b) { return a.roundPosition - b.roundPosition; })
                .filter(function (_a) {
                var roundNumber = _a.roundNumber;
                return !structureData_1.inactiveRounds.includes(roundNumber);
            })
                .filter(function (_a) {
                var winningSide = _a.winningSide;
                return winningSide;
            });
            var matchPlayMatchUpIds_1 = matchPlayMatchUps.map(getMatchUpId);
            var matchUpIdsToDelete = relevantMatchUpIds_1.filter(function (matchUpId) { return !matchPlayMatchUpIds_1.includes(matchUpId); });
            deletedMatchUpIds.push.apply(deletedMatchUpIds, __spreadArray([], __read(matchUpIdsToDelete), false));
            var existingDrawPositionPairings = matchPlayMatchUps
                .flatMap(function (matchUp) { var _a; return (_a = matchUp.drawPositions) !== null && _a !== void 0 ? _a : []; })
                .filter(Boolean);
            var existingDrawPositions_1 = existingDrawPositionPairings.flat();
            var drawPositionsMap_1 = Object.assign.apply(Object, __spreadArray([{}], __read(existingDrawPositions_1.map(function (drawPosition, i) {
                var _a;
                return (_a = {},
                    _a[drawPosition] = i + 1,
                    _a);
            })), false));
            matchPlayMatchUps.forEach(function (matchUp) {
                if (matchPlayDrawPositions) {
                    matchUp.drawPositions = matchUp.drawPositions.map(function (drawPosition) { return drawPositionsMap_1[drawPosition]; });
                }
                else {
                    delete matchUp.drawPositions;
                }
            });
            if (matchPlayDrawPositions) {
                var updatedPositionAssignments = (_c = mainStructure_1 === null || mainStructure_1 === void 0 ? void 0 : mainStructure_1.positionAssignments) === null || _c === void 0 ? void 0 : _c.filter(function (assignment) {
                    return existingDrawPositions_1.includes(assignment.drawPosition);
                }).map(function (assignment) {
                    assignment.drawPosition = drawPositionsMap_1[assignment.drawPosition];
                    return assignment;
                });
                mainStructure_1.positionAssignments = updatedPositionAssignments;
            }
            else {
                mainStructure_1.positionAssignments = [];
            }
            mainStructure_1.matchUps = matchPlayMatchUps;
            relevantMatchUps = matchPlayMatchUps;
        }
        deleteMatchUpsNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            matchUpIds: deletedMatchUpIds,
            drawDefinition: drawDefinition,
        });
        modifyDrawNotice({ drawDefinition: drawDefinition });
    }
    return __assign(__assign({}, SUCCESS), { matchUps: relevantMatchUps });
}

function assignDrawPosition(_a) {
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, participantId = _a.participantId, drawPosition = _a.drawPosition, structureId = _a.structureId, qualifier = _a.qualifier, event = _a.event, bye = _a.bye;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!drawPosition)
        return { error: MISSING_DRAW_POSITION };
    if (!structureId)
        return { error: MISSING_STRUCTURE_ID };
    if (bye) {
        var result = assignDrawPositionBye({
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            drawPosition: drawPosition,
            structureId: structureId,
            event: event,
        });
        if (result.error)
            return result;
    }
    else if (qualifier) {
        return { error: NOT_IMPLEMENTED };
    }
    else {
        var result = assignDrawPosition$1({
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            participantId: participantId,
            drawPosition: drawPosition,
            structureId: structureId,
            event: event,
        });
        if (result.error)
            return result;
    }
    return __assign({}, SUCCESS);
}

function deleteAdHocMatchUps(_a) {
    var e_1, _b;
    var _c, _d, _e, _f, _g;
    var tournamentRecord = _a.tournamentRecord, _h = _a.matchUpIds, matchUpIds = _h === void 0 ? [] : _h, drawDefinition = _a.drawDefinition, structureId = _a.structureId, event = _a.event;
    if (typeof drawDefinition !== 'object')
        return { error: MISSING_DRAW_DEFINITION };
    if (typeof structureId !== 'string')
        return { error: MISSING_STRUCTURE_ID };
    if (!Array.isArray(matchUpIds))
        return { error: INVALID_VALUES };
    var structure = (_c = drawDefinition.structures) === null || _c === void 0 ? void 0 : _c.find(function (structure) { return structure.structureId === structureId; });
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    var existingMatchUps = structure === null || structure === void 0 ? void 0 : structure.matchUps;
    var structureHasRoundPositions = existingMatchUps === null || existingMatchUps === void 0 ? void 0 : existingMatchUps.find(function (matchUp) { return !!matchUp.roundPosition; });
    if (structure.structures || structureHasRoundPositions || structure.finishingPosition === ROUND_OUTCOME) {
        return { error: INVALID_STRUCTURE };
    }
    var matchUpIdsWithScoreValue = [];
    var matchUpsToDelete = (_d = existingMatchUps === null || existingMatchUps === void 0 ? void 0 : existingMatchUps.filter(function (_a) {
        var matchUpId = _a.matchUpId, score = _a.score;
        if (checkScoreHasValue({ score: score }))
            matchUpIdsWithScoreValue.push(matchUpId);
        return matchUpIds.includes(matchUpId);
    })) !== null && _d !== void 0 ? _d : [];
    var matchUpIdsToDelete = matchUpsToDelete.map(xa('matchUpId'));
    if (matchUpIdsToDelete.length) {
        structure.matchUps = ((_e = structure.matchUps) !== null && _e !== void 0 ? _e : []).filter(function (_a) {
            var matchUpId = _a.matchUpId;
            return !matchUpIdsToDelete.includes(matchUpId);
        });
        deleteMatchUpsNotice({
            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
            matchUpIds: matchUpIdsToDelete,
            action: 'deleteAdHocMatchUps',
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            drawDefinition: drawDefinition,
        });
        var roundNumbers = unique(structure.matchUps.map(xa('roundNumber')));
        var missingRoundNumbers = getMissingSequenceNumbers(roundNumbers);
        if (missingRoundNumbers.length) {
            missingRoundNumbers.reverse();
            var _loop_1 = function (roundNumber) {
                structure.matchUps.forEach(function (matchUp) {
                    if (matchUp.roundNumber && matchUp.roundNumber > roundNumber) {
                        matchUp.roundNumber -= 1;
                        modifyMatchUpNotice({
                            tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                            context: ['adHoc round deletion'],
                            eventId: event === null || event === void 0 ? void 0 : event.eventId,
                            drawDefinition: drawDefinition,
                            matchUp: matchUp,
                        });
                    }
                });
            };
            try {
                for (var missingRoundNumbers_1 = __values(missingRoundNumbers), missingRoundNumbers_1_1 = missingRoundNumbers_1.next(); !missingRoundNumbers_1_1.done; missingRoundNumbers_1_1 = missingRoundNumbers_1.next()) {
                    var roundNumber = missingRoundNumbers_1_1.value;
                    _loop_1(roundNumber);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (missingRoundNumbers_1_1 && !missingRoundNumbers_1_1.done && (_b = missingRoundNumbers_1.return)) _b.call(missingRoundNumbers_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        if (matchUpIdsWithScoreValue.length) {
            structure.positionAssignments = unique(structure.matchUps
                .flatMap(function (matchUp) { var _a; return ((_a = matchUp.sides) !== null && _a !== void 0 ? _a : []).map(function (side) { return side.participantId; }); })
                .filter(Boolean)).map(function (participantId) { return ({ participantId: participantId }); });
            var matchUpFormat = (_g = (_f = structure === null || structure === void 0 ? void 0 : structure.matchUpFormat) !== null && _f !== void 0 ? _f : drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.matchUpFormat) !== null && _g !== void 0 ? _g : event === null || event === void 0 ? void 0 : event.matchUpFormat;
            var result = updateAssignmentParticipantResults({
                positionAssignments: structure.positionAssignments,
                matchUps: structure.matchUps,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                matchUpFormat: matchUpFormat,
                event: event,
            });
            if (result.error)
                console.log(result);
        }
        modifyDrawNotice({
            structureIds: [structureId],
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            drawDefinition: drawDefinition,
        });
    }
    return __assign({}, SUCCESS);
}

function removeDrawEntries(_a) {
    var _b, _c;
    var _d = _a.autoEntryPositions, autoEntryPositions = _d === void 0 ? true : _d, participantIds = _a.participantIds, drawDefinition = _a.drawDefinition, drawId = _a.drawId, stages = _a.stages, event = _a.event;
    if (!event)
        return { error: MISSING_EVENT };
    if (!drawId)
        return { error: MISSING_DRAW_ID };
    if (!(participantIds === null || participantIds === void 0 ? void 0 : participantIds.length))
        return { error: MISSING_PARTICIPANT_IDS };
    var assignedParticipantIds = (_b = getAssignedParticipantIds({
        drawDefinition: drawDefinition,
        stages: stages,
    }).assignedParticipantIds) !== null && _b !== void 0 ? _b : [];
    var someAssignedParticipantIds = overlap(assignedParticipantIds, participantIds);
    if (someAssignedParticipantIds)
        return { error: EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT };
    var filterEntry = function (entry) {
        var entryId = entry.participantId;
        return !participantIds.includes(entryId);
    };
    var flightProfile = getFlightProfile({ event: event }).flightProfile;
    var flight = (_c = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _c === void 0 ? void 0 : _c.find(function (flight) { return flight.drawId === drawId; });
    if (flight === null || flight === void 0 ? void 0 : flight.drawEntries) {
        flight.drawEntries = flight.drawEntries.filter(filterEntry);
        if (autoEntryPositions) {
            flight.drawEntries = refreshEntryPositions({
                entries: flight.drawEntries,
            });
        }
    }
    if (drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) {
        drawDefinition.entries = drawDefinition.entries.filter(filterEntry);
        if (autoEntryPositions) {
            drawDefinition.entries = refreshEntryPositions({
                entries: drawDefinition.entries,
            });
        }
    }
    return __assign({}, SUCCESS);
}

function modifyTieFormat(_a) {
    var e_1, _b, e_2, _c, e_3, _d;
    var _e = _a.updateInProgressMatchUps, updateInProgressMatchUps = _e === void 0 ? false : _e, tieFormatComparison = _a.tieFormatComparison, modifiedTieFormat = _a.modifiedTieFormat, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, structureId = _a.structureId, matchUpId = _a.matchUpId, eventId = _a.eventId, uuids = _a.uuids, event = _a.event;
    var stack = 'modifyTieFormat';
    if (!validateTieFormat({ tieFormat: modifiedTieFormat }).valid) {
        return decorateResult({
            result: { error: INVALID_TIE_FORMAT },
            info: 'falied validation',
            stack: stack,
        });
    }
    var result = getTieFormat$1({
        drawDefinition: drawDefinition,
        structureId: structureId,
        matchUpId: matchUpId,
        eventId: eventId,
        event: event,
    });
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    var matchUp = result.matchUp, existingTieFormat = result.tieFormat;
    var tieFormat = copyTieFormat(existingTieFormat);
    var comparison = compareTieFormats({
        descendant: modifiedTieFormat,
        ancestor: tieFormat,
    });
    if (comparison.invalid) {
        return decorateResult({
            context: { invalid: comparison.invalid },
            result: { error: INVALID_TIE_FORMAT },
            stack: stack,
        });
    }
    if (!(comparison === null || comparison === void 0 ? void 0 : comparison.different)) {
        return decorateResult({
            result: __assign({}, SUCCESS),
            info: 'Nothing to do',
            stack: stack,
        });
    }
    var existingCollectionIds = tieFormat.collectionDefinitions.map(function (_a) {
        var collectionId = _a.collectionId;
        return collectionId;
    });
    var updatedCollectionIds = modifiedTieFormat.collectionDefinitions.map(function (_a) {
        var collectionId = _a.collectionId;
        return collectionId;
    });
    var removedCollectionIds = existingCollectionIds.filter(function (collectionId) { return !updatedCollectionIds.includes(collectionId); });
    var addedCollectionDefinitions = modifiedTieFormat.collectionDefinitions.filter(function (_a) {
        var collectionId = _a.collectionId;
        return !existingCollectionIds.includes(collectionId);
    });
    var addedCollectionIds = addedCollectionDefinitions.map(xa('collectionId'));
    var modifications = [];
    var processedTieFormat;
    var tieFormatName = modifiedTieFormat.tieFormatName;
    try {
        // TODO: if gender is changing pre-check for misgendered collectionAssignments
        for (var _f = __values(modifiedTieFormat.collectionDefinitions), _g = _f.next(); !_g.done; _g = _f.next()) {
            var collectionDefinition = _g.value;
            if (addedCollectionIds.includes(collectionDefinition.collectionId))
                continue;
            var result_1 = modifyCollectionDefinition(__assign(__assign({ updateInProgressMatchUps: updateInProgressMatchUps }, collectionDefinition), { tournamentRecord: tournamentRecord, tieFormatName: tieFormatName, drawDefinition: drawDefinition, structureId: structureId, matchUpId: matchUpId, eventId: eventId, event: event }));
            if (result_1.modifications)
                modifications.push.apply(modifications, __spreadArray([], __read(result_1.modifications), false));
            if (result_1.error)
                return decorateResult({ result: result_1, stack: stack });
            if (result_1.tieFormat)
                processedTieFormat = result_1.tieFormat;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var addedCollectionDefinitions_1 = __values(addedCollectionDefinitions), addedCollectionDefinitions_1_1 = addedCollectionDefinitions_1.next(); !addedCollectionDefinitions_1_1.done; addedCollectionDefinitions_1_1 = addedCollectionDefinitions_1.next()) {
            var collectionDefinition = addedCollectionDefinitions_1_1.value;
            var result_2 = addCollectionDefinition({
                updateInProgressMatchUps: updateInProgressMatchUps,
                collectionDefinition: collectionDefinition,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                tieFormatName: tieFormatName,
                structureId: structureId,
                matchUpId: matchUpId,
                matchUp: matchUp,
                eventId: eventId,
                uuids: uuids,
                event: event,
            });
            if (result_2.error)
                return decorateResult({ result: result_2, stack: stack });
            if (result_2.tieFormat)
                processedTieFormat = result_2.tieFormat;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (addedCollectionDefinitions_1_1 && !addedCollectionDefinitions_1_1.done && (_c = addedCollectionDefinitions_1.return)) _c.call(addedCollectionDefinitions_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    try {
        for (var removedCollectionIds_1 = __values(removedCollectionIds), removedCollectionIds_1_1 = removedCollectionIds_1.next(); !removedCollectionIds_1_1.done; removedCollectionIds_1_1 = removedCollectionIds_1.next()) {
            var collectionId = removedCollectionIds_1_1.value;
            var result_3 = removeCollectionDefinition({
                updateInProgressMatchUps: updateInProgressMatchUps,
                tieFormatComparison: tieFormatComparison,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                tieFormatName: tieFormatName,
                collectionId: collectionId,
                structureId: structureId,
                matchUpId: matchUpId,
                eventId: eventId,
                matchUp: matchUp,
                event: event,
            });
            if (result_3.error)
                return decorateResult({ result: result_3, stack: stack });
            if (result_3.tieFormat)
                processedTieFormat = result_3.tieFormat;
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (removedCollectionIds_1_1 && !removedCollectionIds_1_1.done && (_d = removedCollectionIds_1.return)) _d.call(removedCollectionIds_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    var changedTieFormatName = (existingTieFormat === null || existingTieFormat === void 0 ? void 0 : existingTieFormat.tieFormatName) !== tieFormatName;
    // if tieFormat has changed, force renaming of the tieFormat
    if (changedTieFormatName) {
        processedTieFormat.tieFormatName = tieFormatName;
        modifications.push({ tieFormatName: tieFormatName });
    }
    else if (modifications.length || addedCollectionIds.length || removedCollectionIds.length) {
        delete processedTieFormat.tieFormatName;
        modifications.push('tieFormatName removed: modifications without new tieFormatName');
    }
    processedTieFormat.collectionDefinitions = processedTieFormat.collectionDefinitions
        .sort(function (a, b) { return numericSortValue(a.collectionOrder) - numericSortValue(b.collectionOrder); })
        .map(function (def, i) { return (__assign(__assign({}, def), { collectionOrder: i + 1 })); });
    return __assign({ processedTieFormat: copyTieFormat(processedTieFormat), modifications: modifications }, SUCCESS);
}

function removeRoundMatchUps(_a) {
    var removeCompletedMatchUps = _a.removeCompletedMatchUps, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, structureId = _a.structureId, roundNumber = _a.roundNumber, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!roundNumber)
        return decorateResult({
            result: { error: MISSING_VALUE },
            info: 'roundNumber required',
        });
    var structureResult = findStructure({ drawDefinition: drawDefinition, structureId: structureId });
    if (structureResult.error)
        return structureResult;
    var structure = structureResult.structure;
    // cannot be a round robin structure
    if (structure === null || structure === void 0 ? void 0 : structure.structures)
        return { error: INVALID_STRUCTURE };
    var isAdHocStructure = isAdHoc({ drawDefinition: drawDefinition, structure: structure });
    if (isAdHocStructure) {
        return removeAdHocRound({
            tournamentId: tournamentRecord.tournamentId,
            removeCompletedMatchUps: removeCompletedMatchUps,
            eventId: event.eventId,
            drawDefinition: drawDefinition,
            roundNumber: roundNumber,
            structure: structure,
        });
    }
    else {
        console.log('not implemented');
    }
    return __assign({}, SUCCESS);
}
// TODO: move to drawEngine and passthrough
function removeAdHocRound(_a) {
    var _b;
    var removeCompletedMatchUps = _a.removeCompletedMatchUps, drawDefinition = _a.drawDefinition, tournamentId = _a.tournamentId, roundNumber = _a.roundNumber, structure = _a.structure, eventId = _a.eventId;
    var matchUps = (_b = structure === null || structure === void 0 ? void 0 : structure.matchUps) !== null && _b !== void 0 ? _b : [];
    var deletedMatchUpIds = [];
    var roundRemoved = false;
    var roundNumbers = matchUps
        .reduce(function (nums, matchUp) {
        var roundNumber = matchUp === null || matchUp === void 0 ? void 0 : matchUp.roundNumber;
        if (!roundNumber)
            return nums;
        return nums.includes(roundNumber) ? nums : nums.concat(roundNumber);
    }, [])
        .sort(numericSort);
    if (roundNumbers.includes(roundNumber)) {
        var updatedMatchUps = matchUps.filter(function (matchUp) {
            var target = matchUp.roundNumber === roundNumber &&
                (!completedMatchUpStatuses.includes(matchUp.matchUpStatus) ||
                    removeCompletedMatchUps);
            if (target)
                deletedMatchUpIds.push(matchUp.matchUpId);
            return !target;
        });
        if (deletedMatchUpIds.length) {
            deleteMatchUpsNotice({
                matchUpIds: deletedMatchUpIds,
                drawDefinition: drawDefinition,
                tournamentId: tournamentId,
                eventId: eventId,
            });
            var stillContainsRoundNumber = updatedMatchUps.some(function (matchUp) { return matchUp.roundNumber === roundNumber; });
            if (!stillContainsRoundNumber) {
                updatedMatchUps.forEach(function (matchUp) {
                    if (matchUp.roundNumber > roundNumber) {
                        matchUp.roundNumber -= 1;
                        modifyMatchUpNotice({
                            drawDefinition: drawDefinition,
                            tournamentId: tournamentId,
                            eventId: eventId,
                            matchUp: matchUp,
                        });
                    }
                });
                roundRemoved = true;
            }
            structure.matchUps = updatedMatchUps;
        }
    }
    return __assign({ deletedMatchUpsCount: deletedMatchUpIds.length, roundRemoved: roundRemoved }, SUCCESS);
}

function aggregateTieFormats(_a) {
    var e_1, _b;
    var _c, _d, _e, _f, _g;
    var tournamentRecord = _a.tournamentRecord;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var addedCount = 0;
    var _loop_1 = function (event_1) {
        var e_2, _k, e_3, _l, e_4, _m, e_5, _o;
        var tieFormats = (_d = event_1.tieFormats) !== null && _d !== void 0 ? _d : [];
        var checkTieFormat = function (obj) {
            var e_6, _a;
            if (!obj.tieFormat)
                return;
            var identifiedTieFormatId;
            try {
                for (var tieFormats_2 = (e_6 = void 0, __values(tieFormats)), tieFormats_2_1 = tieFormats_2.next(); !tieFormats_2_1.done; tieFormats_2_1 = tieFormats_2.next()) {
                    var tieFormat = tieFormats_2_1.value;
                    var different = compareTieFormats({
                        descendant: obj.tieFormat,
                        ancestor: tieFormat,
                    }).different;
                    if (!different)
                        identifiedTieFormatId = tieFormat.tieFormatId;
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (tieFormats_2_1 && !tieFormats_2_1.done && (_a = tieFormats_2.return)) _a.call(tieFormats_2);
                }
                finally { if (e_6) throw e_6.error; }
            }
            if (identifiedTieFormatId) {
                obj.tieFormatId = identifiedTieFormatId;
                delete obj.tieFormat;
            }
            else {
                var newTieFormat = makeDeepCopy(obj.tieFormat, undefined, true);
                if (!newTieFormat.tieFormatId)
                    newTieFormat.tieFormatId = UUID();
                obj.tieFormatId = newTieFormat.tieFormatId;
                delete obj.tieFormat;
                tieFormats.push(newTieFormat);
                addedCount += 1;
            }
        };
        var eventType = event_1.eventType;
        checkTieFormat({ tieFormat: event_1.tieFormat, eventType: eventType });
        try {
            for (var _p = (e_2 = void 0, __values((_e = event_1.drawDefinitions) !== null && _e !== void 0 ? _e : [])), _q = _p.next(); !_q.done; _q = _p.next()) {
                var drawDefinition = _q.value;
                checkTieFormat({ tieFormat: drawDefinition.tieFormat, eventType: eventType });
                try {
                    for (var _r = (e_3 = void 0, __values((_f = drawDefinition.structures) !== null && _f !== void 0 ? _f : [])), _s = _r.next(); !_s.done; _s = _r.next()) {
                        var structure = _s.value;
                        checkTieFormat({ tieFormat: structure.tieFormat, eventType: eventType });
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_s && !_s.done && (_l = _r.return)) _l.call(_r);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_q && !_q.done && (_k = _p.return)) _k.call(_p);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var setTieFormatId = function (matchUpId, tieFormatId) {
            var _a;
            var matchUp = (_a = eventMatchUpResult.matchUps) === null || _a === void 0 ? void 0 : _a.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
            if (matchUp) {
                matchUp.tieFormatId = tieFormatId;
                delete matchUp.tieFormat;
                modifyMatchUpNotice({
                    tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                    eventId: event_1.eventId,
                    matchUp: matchUp,
                });
            }
        };
        var addNewTieFormat = function (inContextMatchUp) {
            var newTieFormat = makeDeepCopy(inContextMatchUp.tieFormat, undefined, true);
            if (!newTieFormat.tieFormatId)
                newTieFormat.tieFormatId = UUID();
            tieFormats.push(newTieFormat);
            addedCount += 1;
            setTieFormatId(inContextMatchUp.matchUpId, newTieFormat.tieFormatId);
        };
        var eventMatchUpResult = allEventMatchUps({
            matchUpFilters: { matchUpTypes: [TEAM_MATCHUP] },
            event: event_1,
        });
        var inContextMatchUps = (_g = eventMatchUpResult.matchUps) !== null && _g !== void 0 ? _g : [];
        try {
            for (var inContextMatchUps_1 = (e_4 = void 0, __values(inContextMatchUps)), inContextMatchUps_1_1 = inContextMatchUps_1.next(); !inContextMatchUps_1_1.done; inContextMatchUps_1_1 = inContextMatchUps_1.next()) {
                var inContextMatchUp = inContextMatchUps_1_1.value;
                var identifiedTieFormatId = void 0;
                try {
                    for (var tieFormats_1 = (e_5 = void 0, __values(tieFormats)), tieFormats_1_1 = tieFormats_1.next(); !tieFormats_1_1.done; tieFormats_1_1 = tieFormats_1.next()) {
                        var tieFormat = tieFormats_1_1.value;
                        var different = inContextMatchUp.tieFormat &&
                            compareTieFormats({
                                descendant: inContextMatchUp.tieFormat,
                                ancestor: tieFormat,
                            }).different;
                        if (!different)
                            identifiedTieFormatId = tieFormat.tieFormatId;
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (tieFormats_1_1 && !tieFormats_1_1.done && (_o = tieFormats_1.return)) _o.call(tieFormats_1);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                if (identifiedTieFormatId) {
                    setTieFormatId(inContextMatchUp.matchUpId, identifiedTieFormatId);
                }
                else {
                    addNewTieFormat(inContextMatchUp);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (inContextMatchUps_1_1 && !inContextMatchUps_1_1.done && (_m = inContextMatchUps_1.return)) _m.call(inContextMatchUps_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        if (tieFormats.length)
            event_1.tieFormats = tieFormats;
    };
    try {
        for (var _h = __values((_c = tournamentRecord.events) !== null && _c !== void 0 ? _c : []), _j = _h.next(); !_j.done; _j = _h.next()) {
            var event_1 = _j.value;
            _loop_1(event_1);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign(__assign({}, SUCCESS), { addedCount: addedCount });
}

function setOrderOfFinish$1(_a) {
    var e_1, _b;
    var _c, _d;
    var drawDefinition = _a.drawDefinition, finishingOrder = _a.finishingOrder;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var stack = 'setOrderOfFinish';
    if (!Array.isArray(finishingOrder))
        return decorateResult({
            info: mustBeAnArray('finishingOrder'),
            result: { error: INVALID_VALUES },
            stack: stack,
        });
    var _e = getDrawMatchUps({
        inContext: true,
        drawDefinition: drawDefinition,
    }), completedMatchUps = _e.completedMatchUps, matchUpsMap = _e.matchUpsMap;
    var matchUpIds = (_c = completedMatchUps === null || completedMatchUps === void 0 ? void 0 : completedMatchUps.map(getMatchUpId)) !== null && _c !== void 0 ? _c : [];
    var targetMatchUpIds = finishingOrder.map(getMatchUpId);
    var _f = (completedMatchUps !== null && completedMatchUps !== void 0 ? completedMatchUps : [])
        .filter(function (_a) {
        var matchUpId = _a.matchUpId;
        return targetMatchUpIds.includes(matchUpId);
    })
        .reduce(function (aggregator, matchUp) {
        var matchUpTieId = matchUp.matchUpTieId, matchUpType = matchUp.matchUpType, roundNumber = matchUp.roundNumber, structureId = matchUp.structureId;
        if (!aggregator.matchUpTypes.includes(matchUpType))
            aggregator.matchUpTypes.push(matchUpType);
        if (!aggregator.roundNumbers.includes(roundNumber))
            aggregator.roundNumbers.push(roundNumber);
        if (!aggregator.structureIds.includes(structureId))
            aggregator.structureIds.push(structureId);
        if (!aggregator.matchUpTieIds.includes(matchUpTieId))
            aggregator.matchUpTieIds.push(matchUpTieId);
        return aggregator;
    }, {
        matchUpTypes: [],
        roundNumbers: [],
        structureIds: [],
        matchUpTieIds: [],
    }), matchUpTypes = _f.matchUpTypes, roundNumbers = _f.roundNumbers, structureIds = _f.structureIds, matchUpTieIds = _f.matchUpTieIds;
    // targeted matchUps must all be of the same matchUpType and have the same roundNumber and structureId
    if (matchUpTypes.length > 1 ||
        matchUpTieIds.length > 1 ||
        roundNumbers.length > 1 ||
        structureIds.length > 1) {
        return decorateResult({
            info: 'matchUpType, structureId and roundNumber must be equivalent',
            result: { error: INVALID_VALUES },
            stack: stack,
        });
    }
    // targetedMatchUps must all be in draws completedMatchUps and orderOfFinish values must be integers
    var validMatchUpId, validOrderOfFinish;
    var valuesMap = {};
    var targetedMatchUpIds = [];
    var orderOfFinishValues = [];
    var validValues = finishingOrder.every(function (_a) {
        var orderOfFinish = _a.orderOfFinish, matchUpId = _a.matchUpId;
        targetedMatchUpIds.push(matchUpId);
        if (orderOfFinish)
            orderOfFinishValues.push(orderOfFinish);
        valuesMap[matchUpId] = orderOfFinish;
        validMatchUpId = matchUpIds.includes(matchUpId);
        validOrderOfFinish =
            orderOfFinish === undefined ||
                (isConvertableInteger(orderOfFinish) && Math.floor(orderOfFinish) > 0);
        return validMatchUpId && validOrderOfFinish;
    });
    if (!validValues) {
        return decorateResult({
            result: {
                error: !validMatchUpId ? INVALID_MATCHUP_STATUS : INVALID_VALUES,
            },
            info: (!validMatchUpId && 'matchUps must be completed') ||
                (!validOrderOfFinish &&
                    'orderOfFinish must be integer > 0 or undefined') ||
                undefined,
            stack: stack,
        });
    }
    // get other matchUps in the same logical grouping
    var otherCohortMatchUps = completedMatchUps === null || completedMatchUps === void 0 ? void 0 : completedMatchUps.filter(function (matchUp) {
        return matchUp.structureId === structureIds[0] &&
            matchUp.roundNumber === roundNumbers[0] &&
            matchUp.matchUpType === matchUpTypes[0] &&
            matchUp.matchUpTieId === matchUpTieIds[0] &&
            !targetedMatchUpIds.includes(matchUp.matchUpId);
    });
    try {
        // throw an error if an existing matchUp has an invalid orderOfFinish value
        for (var _g = __values(otherCohortMatchUps !== null && otherCohortMatchUps !== void 0 ? otherCohortMatchUps : []), _h = _g.next(); !_h.done; _h = _g.next()) {
            var matchUp = _h.value;
            var orderOfFinish = (matchUp || {}).orderOfFinish;
            if (orderOfFinish) {
                if (!isConvertableInteger(orderOfFinish))
                    return decorateResult({
                        context: { orderOfFinish: orderOfFinish, matchUp: matchUp },
                        result: { error: INVALID_VALUES },
                        stack: stack,
                    });
                orderOfFinishValues.push(orderOfFinish);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // order of finish values must be unique and no value greater than the number of values
    if (uniqueValues(orderOfFinishValues).length !== orderOfFinishValues.length ||
        Math.max.apply(Math, __spreadArray([], __read(orderOfFinishValues), false)) > orderOfFinishValues.length) {
        return decorateResult({
            info: 'Values not unique or greater than expected number of values',
            result: { error: INVALID_VALUES },
            stack: stack,
        });
    }
    if (structureIds.length) {
        // get the matchUp objects to modify (not inContext)
        var result = getStructureMatchUps({
            matchUpFilters: { matchUpIds: targetMatchUpIds },
            structureId: structureIds[0],
            drawDefinition: drawDefinition,
            matchUpsMap: matchUpsMap,
        });
        if (result.error)
            return decorateResult({ result: result, stack: stack });
        // apply the new values to targeted matchUps
        (_d = result.completedMatchUps) === null || _d === void 0 ? void 0 : _d.forEach(function (matchUp) { return (matchUp.orderOfFinish = valuesMap[matchUp.matchUpId]); });
    }
    return __assign({}, SUCCESS);
}

function setOrderOfFinish(params) {
    return setOrderOfFinish$1(params);
}

function modifySeedAssignment$1(_a) {
    var _b = _a.validation, validation = _b === void 0 ? true : _b, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, participantId = _a.participantId, structureId = _a.structureId, seedValue = _a.seedValue, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structureId)
        return { error: MISSING_STRUCTURE_ID };
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    var validValue = !validation ||
        isNumeric(seedValue) ||
        seedValue === undefined ||
        seedValue === '' ||
        (typeof seedValue === 'string' &&
            seedValue.split('-').every(function (v) { return isNumeric(v) && ensureInt(v) > 0; }));
    if (!validValue)
        return { error: INVALID_VALUES };
    var seedAssignments = getStructureSeedAssignments({
        drawDefinition: drawDefinition,
        structure: structure,
    }).seedAssignments;
    var seedNumbers = seedAssignments === null || seedAssignments === void 0 ? void 0 : seedAssignments.map(function (assignment) { return assignment.seedNumber; });
    var existingAssginment = seedAssignments === null || seedAssignments === void 0 ? void 0 : seedAssignments.find(function (assignment) { return assignment.participantId === participantId; });
    if (existingAssginment) {
        var newValue = typeof seedValue === 'string'
            ? (seedValue.includes('-') &&
                seedValue
                    .split('-')
                    .map(function (v) { return parseInt(v); })
                    .join('-')) ||
                (parseInt(seedValue) > 0 && parseInt(seedValue)) ||
                ''
            : (seedValue && seedValue > 0 && seedValue) || '';
        existingAssginment.seedValue = newValue;
    }
    else {
        var seedNumber = Math.max.apply(Math, __spreadArray([0], __read((seedNumbers || [])), false)) + 1;
        var seedAssignment = { seedNumber: seedNumber, participantId: participantId };
        if (seedValue)
            seedAssignment.seedValue = seedValue;
        if (!structure.seedAssignments)
            structure.seedAssignments = [];
        structure.seedAssignments.push(seedAssignment);
    }
    modifySeedAssignmentsNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        eventId: event === null || event === void 0 ? void 0 : event.eventId,
        drawDefinition: drawDefinition,
        structure: structure,
    });
    return __assign({}, SUCCESS);
}

/**
 *
 * @param {string} drawId - id of drawDefinition within which structure occurs
 * @param {object} drawDefinition - added automatically by tournamentEngine
 * @param {string} participantId - id of participant which will receive the seedValue
 * @param {string} structureId - id of structure within drawDefinition
 * @param {string} seedValue - supports value of e.g. '5-8'
 *
 */
function modifySeedAssignment(_a) {
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, participantId = _a.participantId, structureId = _a.structureId, seedValue = _a.seedValue, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var participant = (tournamentRecord.participants || []).find(function (participant) { return participant.participantId === participantId; });
    if (!participant)
        return { error: INVALID_PARTICIPANT_ID };
    return modifySeedAssignment$1({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        participantId: participantId,
        structureId: structureId,
        seedValue: seedValue,
        event: event,
    });
}

function addDrawDefinition(params) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    var flightDefinition = params.flight, suppressNotifications = params.suppressNotifications, modifyEventEntries = params.modifyEventEntries, // event.entries[{entryStatus}] are modified to match draw.entries[{entryStatus}]
    existingDrawCount = params.existingDrawCount, allowReplacement = params.allowReplacement, checkEntryStatus = params.checkEntryStatus, // optional boolean to enable checking that flight.drawEntries match event.entries
    tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, event = params.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!event)
        return { error: MISSING_EVENT };
    if (!event.drawDefinitions)
        event.drawDefinitions = [];
    var drawId = drawDefinition.drawId, drawName = drawDefinition.drawName, drawEntries = drawDefinition.entries;
    var eventEntries = event.entries;
    var modifiedEventEntryStatusCount = 0;
    if (existingDrawCount !== undefined &&
        existingDrawCount !== event.drawDefinitions.length)
        return { error: INVALID_VALUES, info: 'drawDefintions count mismatch' };
    var flightProfile = getFlightProfile({ event: event }).flightProfile;
    var relevantFlight = flightDefinition &&
        ((_a = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _a === void 0 ? void 0 : _a.find(function (flight) { return flight.flightNumber === flightDefinition.flightNumber; }));
    // if there is a source drawId specified, the source draw must exist
    var sourceDrawId = (_d = (_c = (_b = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.links) === null || _b === void 0 ? void 0 : _b.find(function (link) { var _a; return ((_a = link === null || link === void 0 ? void 0 : link.target) === null || _a === void 0 ? void 0 : _a.drawId) === drawId; })) === null || _c === void 0 ? void 0 : _c.source) === null || _d === void 0 ? void 0 : _d.drawId;
    var sourceDrawIdError = sourceDrawId &&
        !event.drawDefinitions.find(function (drawDefinition) { return drawDefinition.drawId === sourceDrawId; });
    if (sourceDrawIdError)
        return decorateResult({
            result: { error: MISSING_DRAW_DEFINITION },
            info: { sourceDrawId: sourceDrawId },
        });
    var flightConflict = relevantFlight && relevantFlight.drawId !== drawDefinition.drawId;
    if (flightConflict) {
        return decorateResult({
            result: { error: INVALID_DRAW_DEFINITION },
            info: { relevantFlight: relevantFlight },
        });
    }
    var drawEntriesPresentInFlight = drawEntries === null || drawEntries === void 0 ? void 0 : drawEntries.every(function (_a) {
        var participantId = _a.participantId, entryStatus = _a.entryStatus;
        var flightEntry = relevantFlight === null || relevantFlight === void 0 ? void 0 : relevantFlight.drawEntries.find(function (entry) { return entry.participantId === participantId; });
        return !entryStatus || (flightEntry === null || flightEntry === void 0 ? void 0 : flightEntry.entryStatus) === entryStatus;
    });
    // check that all drawEntries have equivalent entryStatus to event.entries
    var matchingEventEntries = !checkEntryStatus ||
        (eventEntries &&
            (drawEntries === null || drawEntries === void 0 ? void 0 : drawEntries.every(function (_a) {
                var participantId = _a.participantId, entryStatus = _a.entryStatus, entryStage = _a.entryStage;
                var eventEntry = eventEntries.find(function (eventEntry) {
                    return eventEntry.participantId === participantId &&
                        (!eventEntry.entryStage || eventEntry.entryStage === entryStage);
                });
                return (eventEntry === null || eventEntry === void 0 ? void 0 : eventEntry.entryStatus) === entryStatus;
            })));
    if (relevantFlight && !drawEntriesPresentInFlight) {
        return decorateResult({
            result: { error: INVALID_DRAW_DEFINITION },
            context: {
                drawEntriesPresentInFlight: drawEntriesPresentInFlight,
                matchingEventEntries: matchingEventEntries,
                relevantFlight: relevantFlight,
            },
            info: 'Draw entries are not present in flight or do not match entryStatuses',
        });
    }
    if (modifyEventEntries) {
        drawEntries === null || drawEntries === void 0 ? void 0 : drawEntries.filter(Boolean).forEach(function (drawEntry) {
            if ((drawEntry === null || drawEntry === void 0 ? void 0 : drawEntry.entryStatus) &&
                STRUCTURE_SELECTED_STATUSES.includes(drawEntry === null || drawEntry === void 0 ? void 0 : drawEntry.entryStatus)) {
                var eventEntry = eventEntries === null || eventEntries === void 0 ? void 0 : eventEntries.filter(Boolean).find(function (eventEntry) { return eventEntry.participantId === drawEntry.participantId; });
                if (eventEntry &&
                    drawEntry.entryStatus &&
                    (eventEntry === null || eventEntry === void 0 ? void 0 : eventEntry.entryStatus) !== drawEntry.entryStatus) {
                    eventEntry.entryStatus = drawEntry.entryStatus;
                    modifiedEventEntryStatusCount += 1;
                }
            }
        });
    }
    if (eventEntries && !matchingEventEntries)
        return decorateResult({
            result: {
                info: 'Draw entries do not match event entryStatuses',
                context: { matchingEventEntries: matchingEventEntries, eventEntries: eventEntries },
                error: INVALID_DRAW_DEFINITION,
            },
        });
    var flightNumbers = ((_f = (_e = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _e === void 0 ? void 0 : _e.map(function (_a) {
        var flightNumber = _a.flightNumber;
        return !isNaN(flightNumber) && ensureInt(flightNumber);
    })) === null || _f === void 0 ? void 0 : _f.filter(Boolean)) || [];
    var drawOrders = ((_g = event.drawDefinitions
        .map(function (_a) {
        var drawOrder = _a.drawOrder;
        return drawOrder && ensureInt(drawOrder);
    })) === null || _g === void 0 ? void 0 : _g.filter(Boolean)) || [];
    var drawOrder = Math.max.apply(Math, __spreadArray(__spreadArray([0], __read(drawOrders), false), __read(flightNumbers), false)) + 1;
    var flight = (_h = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _h === void 0 ? void 0 : _h.find(function (flight) { return flight.drawId === drawId; });
    var extension;
    if (flight) {
        // if this drawId was defined in a flightProfile...
        // ...update the flight.drawName with the drawName in the drawDefinition
        flight.drawName = drawDefinition.drawName;
        extension = {
            name: FLIGHT_PROFILE,
            value: __assign(__assign({}, flightProfile), { flights: flightProfile.flights }),
        };
        var flightNumber = flight.flightNumber;
        if (flightNumber && !drawOrders.includes(flightNumber)) {
            drawOrder = flightNumber;
        }
        else {
            flight.flightNumber = drawOrder;
        }
    }
    else {
        var flights = (flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) || [];
        flights.push({
            manuallyAdded: true, // this drawDefinition was not part of automated split
            flightNumber: drawOrder,
            drawEntries: drawEntries,
            drawName: drawName,
            drawId: drawId,
        });
        extension = {
            name: FLIGHT_PROFILE,
            value: __assign(__assign({}, (flightProfile || {})), { flights: flights }),
        };
    }
    addEventExtension({ event: event, extension: extension });
    Object.assign(drawDefinition, { drawOrder: drawOrder });
    var existingDrawDefinition = event.drawDefinitions.find(function (drawDefinition) { return drawDefinition.drawId === drawId; });
    var tournamentId = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId;
    var eventId = event.eventId;
    if (existingDrawDefinition) {
        if (!allowReplacement) {
            return { error: DRAW_ID_EXISTS };
        }
        // find matchUps added/removed
        var existingMatchUps = (_j = allDrawMatchUps({
            drawDefinition: existingDrawDefinition,
        })) === null || _j === void 0 ? void 0 : _j.matchUps;
        var existingMatchUpIds = (_k = existingMatchUps === null || existingMatchUps === void 0 ? void 0 : existingMatchUps.map(getMatchUpId)) !== null && _k !== void 0 ? _k : [];
        var incomingMatchUps = (_l = allDrawMatchUps({
            drawDefinition: drawDefinition,
        })) === null || _l === void 0 ? void 0 : _l.matchUps;
        if (!suppressNotifications) {
            // all existing are deleted and then re-added to handle back-end created Id issues
            if (existingMatchUpIds === null || existingMatchUpIds === void 0 ? void 0 : existingMatchUpIds.length) {
                deleteMatchUpsNotice({
                    matchUpIds: existingMatchUpIds,
                    action: 'modifyDrawDefinition',
                    tournamentId: tournamentId,
                    eventId: eventId,
                });
            }
            if (incomingMatchUps === null || incomingMatchUps === void 0 ? void 0 : incomingMatchUps.length) {
                addMatchUpsNotice({
                    matchUps: incomingMatchUps,
                    tournamentId: tournamentId,
                    eventId: eventId,
                });
            }
            // replace the existing drawDefinition with the updated version
            event.drawDefinitions = event.drawDefinitions.map(function (d) {
                return d.drawId === drawId ? drawDefinition : d;
            });
            var structureIds = (_m = drawDefinition.structures) === null || _m === void 0 ? void 0 : _m.map(function (_a) {
                var structureId = _a.structureId;
                return structureId;
            });
            modifyDrawNotice({ drawDefinition: drawDefinition, tournamentId: tournamentId, structureIds: structureIds, eventId: eventId });
        }
    }
    else {
        event.drawDefinitions.push(drawDefinition);
        if (!suppressNotifications) {
            var matchUps = allDrawMatchUps({ drawDefinition: drawDefinition, event: event }).matchUps;
            matchUps &&
                addMatchUpsNotice({
                    tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                    matchUps: matchUps,
                });
            addDrawNotice({ drawDefinition: drawDefinition, tournamentId: tournamentId, eventId: eventId });
        }
    }
    return __assign(__assign({}, SUCCESS), { modifiedEventEntryStatusCount: modifiedEventEntryStatusCount });
}

function assignSeedPositions(params) {
    var e_1, _a;
    var provisionalPositioning = params.provisionalPositioning, useExistingSeedLimit = params.useExistingSeedLimit, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, seedingProfile = params.seedingProfile, structureId = params.structureId, assignments = params.assignments, drawId = params.drawId, event = params.event;
    var modifications = 0;
    if (!(assignments === null || assignments === void 0 ? void 0 : assignments.length))
        return { error: MISSING_ASSIGNMENTS };
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!drawId)
        return { error: MISSING_DRAW_ID };
    var result = getStructureSeedAssignments({
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        structureId: structureId,
    });
    if (result.error)
        return result;
    var seedAssignments = result.seedAssignments, seedLimit = result.seedLimit;
    /**
     * mergeObject and seedLimit ensure that new assignments do not go beyond already established number of seeds
     */
    var mergeObject = Object.assign.apply(Object, __spreadArray([{}], __read((seedAssignments !== null && seedAssignments !== void 0 ? seedAssignments : [])
        .filter(function (assignment) { return assignment.seedNumber; })
        .map(function (assignment) {
        var _a;
        return (_a = {}, _a[assignment.seedNumber] = assignment, _a);
    })), false));
    assignments.forEach(function (newAssignment) {
        var seedNumber = newAssignment.seedNumber;
        if (seedLimit &&
            seedNumber <= seedLimit &&
            (!useExistingSeedLimit || mergeObject[seedNumber])) {
            mergeObject[seedNumber] = newAssignment;
        }
    });
    /**
     * ensure that no participantId is assigned to multiple seedNumbers
     */
    var updatedAssignments = Object.values(mergeObject);
    var participantIds = updatedAssignments
        .map(function (assignment) { return assignment === null || assignment === void 0 ? void 0 : assignment.participantId; })
        .filter(Boolean);
    if (participantIds.length !== uniqueValues(participantIds).length) {
        return {
            error: INVALID_PARTICIPANT_SEEDING,
        };
    }
    try {
        for (var updatedAssignments_1 = __values(updatedAssignments), updatedAssignments_1_1 = updatedAssignments_1.next(); !updatedAssignments_1_1.done; updatedAssignments_1_1 = updatedAssignments_1.next()) {
            var assignment = updatedAssignments_1_1.value;
            var result_1 = assignSeed(__assign(__assign({}, assignment), { provisionalPositioning: provisionalPositioning, tournamentRecord: tournamentRecord, drawDefinition: drawDefinition, seedingProfile: seedingProfile, structureId: structureId, event: event }));
            if (result_1 === null || result_1 === void 0 ? void 0 : result_1.error) {
                return result_1;
            }
            else if (result_1 === null || result_1 === void 0 ? void 0 : result_1.success) {
                modifications++;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (updatedAssignments_1_1 && !updatedAssignments_1_1.done && (_a = updatedAssignments_1.return)) _a.call(updatedAssignments_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return modifications
        ? __assign(__assign({}, SUCCESS), { modifications: modifications }) : { error: NO_MODIFICATIONS_APPLIED };
}

function addParticipants(_a) {
    var e_1, _b;
    var allowDuplicateParticipantIdPairs = _a.allowDuplicateParticipantIdPairs, returnParticipants = _a.returnParticipants, tournamentRecord = _a.tournamentRecord, _c = _a.participants, participants = _c === void 0 ? [] : _c;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!tournamentRecord.participants)
        tournamentRecord.participants = [];
    var tournamentParticipants = tournamentRecord.participants;
    var existingParticipantIds = tournamentParticipants.map(function (p) { return p.participantId; }) || [];
    participants.forEach(function (participant) {
        if (!participant.participantId)
            participant.participantId = UUID();
    });
    var newParticipants = participants.filter(function (participant) { return !existingParticipantIds.includes(participant.participantId); });
    var notAdded = participants.filter(function (participant) { return existingParticipantIds.includes(participant.participantId); });
    var individualParticipants = newParticipants.filter(function (participant) { return participant.participantType === INDIVIDUAL; });
    var groupedParticipants = newParticipants.filter(function (participant) { return participant.participantType !== INDIVIDUAL; });
    // add individual participants first so that grouped participants which include them are valid
    var participantsToAdd = individualParticipants.concat.apply(individualParticipants, __spreadArray([], __read(groupedParticipants), false));
    var addedParticipants = [];
    if (participantsToAdd.length) {
        try {
            for (var participantsToAdd_1 = __values(participantsToAdd), participantsToAdd_1_1 = participantsToAdd_1.next(); !participantsToAdd_1_1.done; participantsToAdd_1_1 = participantsToAdd_1.next()) {
                var participant = participantsToAdd_1_1.value;
                var result_1 = addParticipant({
                    allowDuplicateParticipantIdPairs: allowDuplicateParticipantIdPairs,
                    returnParticipant: true,
                    disableNotice: true,
                    tournamentRecord: tournamentRecord,
                    participant: participant,
                });
                if (result_1.error)
                    return result_1;
                if (result_1.success && !result_1.existingParticipant)
                    addedParticipants.push(result_1.participant);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (participantsToAdd_1_1 && !participantsToAdd_1_1.done && (_b = participantsToAdd_1.return)) _b.call(participantsToAdd_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (addedParticipants.length) {
            addNotice({
                topic: ADD_PARTICIPANTS,
                payload: {
                    tournamentId: tournamentRecord.tournamentId,
                    participants: addedParticipants,
                },
            });
        }
        var result = __assign({ participants: returnParticipants && makeDeepCopy(addedParticipants), addedCount: addedParticipants.length }, SUCCESS);
        if (notAdded.length) {
            Object.assign(result, { notAdded: notAdded, info: EXISTING_PARTICIPANT });
        }
        return definedAttributes(result);
    }
    else {
        return __assign({ info: 'No new participants to add', addedCount: 0 }, SUCCESS);
    }
}

function addEventEntryPairs(_a) {
    var e_1, _b;
    var _c;
    var allowDuplicateParticipantIdPairs = _a.allowDuplicateParticipantIdPairs, _d = _a.entryStage, entryStage = _d === void 0 ? MAIN : _d, _e = _a.entryStatus, entryStatus = _e === void 0 ? ALTERNATE : _e, _f = _a.participantIdPairs, participantIdPairs = _f === void 0 ? [] : _f, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, event = _a.event, uuids = _a.uuids;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    if (event.eventType !== DOUBLES)
        return { error: INVALID_EVENT_TYPE };
    var existingParticipantIdPairs = [];
    var genderMap = new Map();
    try {
        for (var _g = __values((_c = tournamentRecord.participants) !== null && _c !== void 0 ? _c : []), _h = _g.next(); !_h.done; _h = _g.next()) {
            var participant = _h.value;
            var participantType = participant.participantType, participantId = participant.participantId, person = participant.person, individualParticipantIds = participant.individualParticipantIds;
            if (participantType === INDIVIDUAL && (person === null || person === void 0 ? void 0 : person.sex)) {
                genderMap.set(participantId, person.sex);
            }
            else if (participantType === PAIR && individualParticipantIds) {
                existingParticipantIdPairs.push(individualParticipantIds);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // ensure all participantIdPairs have two individual participantIds
    var invalidParticipantIdPairs = participantIdPairs.filter(function (pair) {
        // invalid if not two participantIds
        if (pair.length !== 2)
            return true;
        // invalid if either participantId does not exist
        if (!genderMap.has(pair[0]) || !genderMap.has(pair[1]))
            return true;
        // NOT invalid if event.gender is ANY or no gender is specified
        if (!event.gender || event.gender === ANY)
            return false;
        var participantGenders = pair.map(function (id) { return genderMap.get(id); });
        // invalid if event.gender is MALE/FEMALE and both participants do not match
        var invalidParticiapntGenders = (event.gender === MALE &&
            (participantGenders[0] !== MALE || participantGenders[1] !== MALE)) ||
            (event.gender === FEMALE &&
                (participantGenders[0] !== FEMALE || participantGenders[1] !== FEMALE));
        // invalid if event.gender is MIXED and participant genders are not different
        if (event.gender === MIXED) {
            participantGenders.sort(stringSort);
            if (participantGenders[0] !== FEMALE || participantGenders[1] !== MALE)
                invalidParticiapntGenders = true;
        }
        return invalidParticiapntGenders;
    });
    if (invalidParticipantIdPairs.length)
        return { error: INVALID_PARTICIPANT_IDS, invalidParticipantIdPairs: invalidParticipantIdPairs };
    // create provisional participant objects
    var provisionalParticipants = participantIdPairs.map(function (individualParticipantIds) {
        var _a;
        return ({
            participantId: (_a = uuids === null || uuids === void 0 ? void 0 : uuids.pop()) !== null && _a !== void 0 ? _a : UUID(),
            participantRole: COMPETITOR,
            individualParticipantIds: individualParticipantIds,
            participantType: PAIR,
        });
    });
    // filter out existing participants unless allowDuplicateParticipantIdPairs is true
    var newParticipants = allowDuplicateParticipantIdPairs
        ? provisionalParticipants
        : provisionalParticipants.filter(function (participant) {
            return !existingParticipantIdPairs.find(function (existing) {
                return intersection(existing, participant.individualParticipantIds)
                    .length === 2;
            });
        });
    var info;
    var addedParticipants = [];
    if (newParticipants) {
        var result_1 = addParticipants({
            allowDuplicateParticipantIdPairs: allowDuplicateParticipantIdPairs,
            participants: newParticipants,
            returnParticipants: true,
            tournamentRecord: tournamentRecord,
        });
        if (result_1.error)
            return result_1;
        addedParticipants = result_1.participants || [];
        info = result_1.info;
    }
    var pairParticipantIds = participantIdPairs
        .map(function (participantIds) {
        var addedParticipant = addedParticipants.find(function (addedPair) {
            return intersection(addedPair.individualParticipantIds, participantIds)
                .length === 2;
        });
        if (addedParticipant)
            return addedParticipant;
        var participant = getPairedParticipant({
            tournamentRecord: tournamentRecord,
            participantIds: participantIds,
        }).participant;
        return participant;
    })
        .map(function (participant) { return participant.participantId; });
    var result = addEventEntries({
        participantIds: pairParticipantIds,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        entryStatus: entryStatus,
        entryStage: entryStage,
        event: event,
    });
    if (newParticipants.length) {
        addNotice({
            payload: { participants: newParticipants },
            topic: ADD_PARTICIPANTS,
        });
    }
    var newParticipantIds = newParticipants.map(getParticipantId);
    return __assign(__assign({}, result), { info: info, newParticipantIds: newParticipantIds });
}

function modifyEventEntries(_a) {
    var _b;
    var _c, _d;
    var _e = _a.entryStatus, entryStatus = _e === void 0 ? DIRECT_ACCEPTANCE : _e, _f = _a.unpairedParticipantIds, unpairedParticipantIds = _f === void 0 ? [] : _f, _g = _a.participantIdPairs, participantIdPairs = _g === void 0 ? [] : _g, _h = _a.entryStage, entryStage = _h === void 0 ? MAIN : _h, tournamentRecord = _a.tournamentRecord, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    var tournamentParticipants = (_c = tournamentRecord.participants) !== null && _c !== void 0 ? _c : [];
    var individualParticipantIds = tournamentParticipants
        .filter(function (participant) { return participant.participantType === INDIVIDUAL; })
        .map(function (participant) { return participant.participantId; });
    // concat all incoming INDIVIDUAL participantIds
    var incomingIndividualParticipantIds = unpairedParticipantIds
        .concat.apply(unpairedParticipantIds, __spreadArray([], __read(participantIdPairs), false)).flat(Infinity);
    // ensure all participants are present in the tournament record
    var invalidParticipantIds = incomingIndividualParticipantIds.filter(function (participantId) { return !individualParticipantIds.includes(participantId); });
    if (invalidParticipantIds.length)
        return { error: INVALID_PARTICIPANT_IDS, invalidParticipantIds: invalidParticipantIds };
    // ensure all participantIdPairs have two individual participantIds
    var invalidParticipantIdPairs = participantIdPairs.filter(function (pair) { return pair.length !== 2; });
    if (invalidParticipantIdPairs.length)
        return { error: INVALID_PARTICIPANT_IDS, invalidParticipantIdPairs: invalidParticipantIdPairs };
    // make an array of all existing PAIR participantIds
    var existingParticipantIdPairs = tournamentParticipants
        .filter(function (participant) { return participant.participantType === PAIR; })
        .map(function (participant) { return participant.individualParticipantIds; });
    // determine participantIdPairs which do not already exist
    var newParticipantIdPairs = participantIdPairs.filter(function (incoming) {
        return !existingParticipantIdPairs.find(function (existing) { return intersection(existing, incoming).length === 2; });
    });
    // create new participant objects
    var newParticipants = newParticipantIdPairs.map(function (individualParticipantIds) { return ({
        participantType: PAIR,
        participantRole: COMPETITOR,
        individualParticipantIds: individualParticipantIds,
    }); });
    var result = addParticipants({
        participants: newParticipants,
        tournamentRecord: tournamentRecord,
    });
    if (result.error)
        return result;
    // get all participantIds for PAIR participants
    var pairParticipantEntries = participantIdPairs
        .map(function (participantIds) {
        var participant = getPairedParticipant({
            tournamentRecord: tournamentRecord,
            participantIds: participantIds,
        }).participant;
        return participant;
    })
        .map(function (participantId) { return ({
        participantId: participantId,
        entryStatus: entryStatus,
        entryStage: entryStage,
    }); });
    var unpairedParticipantEntries = unpairedParticipantIds.map(function (participantId) { return ({
        entryStatus: UNGROUPED,
        participantId: participantId,
        entryStage: entryStage,
    }); });
    // remove all entries matching the stage which has been modified
    event.entries = ((_d = event.entries) !== null && _d !== void 0 ? _d : []).filter(function (entry) { return entry.entryStage === entryStage; });
    event.entries = (_b = event.entries).concat.apply(_b, __spreadArray(__spreadArray([], __read(pairParticipantEntries), false), __read(unpairedParticipantEntries), false));
    return __assign({}, SUCCESS);
}

function generateAdHocMatchUps(params) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    var _q = params.matchUpIds, matchUpIds = _q === void 0 ? [] : _q, drawDefinition = params.drawDefinition, roundNumber = params.roundNumber, newRound = params.newRound, isMock = params.isMock, event = params.event;
    if (typeof drawDefinition !== 'object')
        return { error: MISSING_DRAW_DEFINITION };
    var participantIdPairings = params.participantIdPairings, matchUpsCount = params.matchUpsCount;
    var structureId = (_a = params.structureId) !== null && _a !== void 0 ? _a : (((_b = drawDefinition.structures) === null || _b === void 0 ? void 0 : _b.length) === 1 && ((_d = (_c = drawDefinition.structures) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.structureId));
    if (typeof structureId !== 'string')
        return { error: MISSING_STRUCTURE_ID };
    // if drawDefinition and structureId are provided it is possible to infer roundNumber
    var structure = (_e = drawDefinition.structures) === null || _e === void 0 ? void 0 : _e.find(function (structure) { return structure.structureId === structureId; });
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    var structureHasRoundPositions;
    var existingMatchUps = (_f = structure.matchUps) !== null && _f !== void 0 ? _f : [];
    var lastRoundNumber = existingMatchUps === null || existingMatchUps === void 0 ? void 0 : existingMatchUps.reduce(function (roundNumber, matchUp) {
        if (matchUp.roundPosition)
            structureHasRoundPositions = true;
        return ((matchUp === null || matchUp === void 0 ? void 0 : matchUp.roundNumber) || 0) > roundNumber ? matchUp.roundNumber : roundNumber;
    }, 0);
    if (!matchUpsCount) {
        var selectedEntries = (_h = (_g = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) === null || _g === void 0 ? void 0 : _g.filter(function (entry) {
            var entryStatus = entry.entryStatus;
            return STRUCTURE_SELECTED_STATUSES.includes(entryStatus);
        })) !== null && _h !== void 0 ? _h : [];
        var roundMatchUpsCount = Math.floor((selectedEntries === null || selectedEntries === void 0 ? void 0 : selectedEntries.length) / 2) || 1;
        if (newRound) {
            matchUpsCount = roundMatchUpsCount;
        }
        else {
            var targetRoundNumber_1 = (_j = roundNumber !== null && roundNumber !== void 0 ? roundNumber : lastRoundNumber) !== null && _j !== void 0 ? _j : 1;
            var existingRoundMatchUps = (_m = (_l = (_k = structure.matchUps) === null || _k === void 0 ? void 0 : _k.filter(function (matchUp) { return matchUp.roundNumber === targetRoundNumber_1; })) === null || _l === void 0 ? void 0 : _l.length) !== null && _m !== void 0 ? _m : 0;
            var maxRemaining = roundMatchUpsCount - existingRoundMatchUps;
            if (maxRemaining > 0)
                matchUpsCount = maxRemaining;
        }
    }
    if ((participantIdPairings && !Array.isArray(participantIdPairings)) ||
        (matchUpsCount && !isConvertableInteger(matchUpsCount)) ||
        (matchUpIds && !Array.isArray(matchUpIds)) ||
        (!participantIdPairings && !matchUpsCount)) {
        return { error: INVALID_VALUES, info: 'matchUpsCount or pairings error' };
    }
    // structure must not be a container of other structures
    // structure must not contain matchUps with roundPosition
    // structure must not determine finishingPosition by ROUND_OUTCOME
    if (structure.structures || structureHasRoundPositions || structure.finishingPosition === ROUND_OUTCOME) {
        return { error: INVALID_STRUCTURE };
    }
    if (roundNumber && roundNumber - 1 > (lastRoundNumber || 0))
        return { error: INVALID_VALUES, info: 'roundNumber error' };
    var nextRoundNumber = roundNumber !== null && roundNumber !== void 0 ? roundNumber : ((newRound && (lastRoundNumber !== null && lastRoundNumber !== void 0 ? lastRoundNumber : 0) + 1) || lastRoundNumber || 1);
    participantIdPairings =
        participantIdPairings !== null && participantIdPairings !== void 0 ? participantIdPairings : generateRange(0, matchUpsCount).map(function () { return ({
            participantIds: [undefined, undefined],
        }); });
    var getPrefixedId = function (index) {
        var _a;
        if (!params.idPrefix && !isMock)
            return undefined;
        var drawId = drawDefinition.drawId;
        var idPrefix = (_a = params.idPrefix) !== null && _a !== void 0 ? _a : 'ah';
        return "".concat(drawId, "-").concat(idPrefix, "-").concat(nextRoundNumber, "-").concat(index);
    };
    var matchUps = participantIdPairings === null || participantIdPairings === void 0 ? void 0 : participantIdPairings.map(function (pairing, i) {
        var _a, _b, _c;
        var idStack = (_a = pairing === null || pairing === void 0 ? void 0 : pairing.participantIds) !== null && _a !== void 0 ? _a : [undefined, undefined];
        // ensure there are always 2 sides in generated matchUps
        idStack.push.apply(idStack, [undefined, undefined]);
        var participantIds = idStack.slice(0, 2);
        var sides = participantIds.map(function (participantId, i) {
            return definedAttributes({
                sideNumber: i + 1,
                participantId: participantId,
            });
        });
        var matchUpId = (_c = (_b = matchUpIds[i]) !== null && _b !== void 0 ? _b : getPrefixedId(i)) !== null && _c !== void 0 ? _c : UUID();
        return {
            roundNumber: nextRoundNumber,
            matchUpStatus: TO_BE_PLAYED,
            matchUpId: matchUpId,
            sides: sides,
        };
    });
    if (matchUps === null || matchUps === void 0 ? void 0 : matchUps.length) {
        var tieFormat_1 = (_o = resolveTieFormat({ drawDefinition: drawDefinition, event: event })) === null || _o === void 0 ? void 0 : _o.tieFormat;
        if (tieFormat_1) {
            matchUps.forEach(function (matchUp) {
                var tieMatchUps = generateTieMatchUps({
                    tieFormat: tieFormat_1,
                    matchUp: matchUp,
                    isMock: isMock,
                }).tieMatchUps;
                Object.assign(matchUp, { tieMatchUps: tieMatchUps, matchUpType: TEAM });
            });
        }
    }
    return __assign({ matchUpsCount: (_p = matchUps === null || matchUps === void 0 ? void 0 : matchUps.length) !== null && _p !== void 0 ? _p : 0, matchUps: matchUps }, SUCCESS);
}

function generateCandidate(_a) {
    var _b = _a.maxIterations, maxIterations = _b === void 0 ? 4000 : _b, // cap the processing intensity of the candidate generator
    valueSortedPairings = _a.valueSortedPairings, // pairings sorted by value from low to high
    pairingValues = _a.pairingValues, valueObjects = _a.valueObjects, deltaObjects = _a.deltaObjects;
    var pairingValueMap = Object.assign.apply(Object, __spreadArray([{}], __read(valueSortedPairings.map(function (rm) {
        var _a;
        return (_a = {}, _a[rm.pairing] = rm.value, _a);
    })), false));
    var actors = Object.keys(pairingValues);
    var proposedCandidates = [];
    // generate an initial candidate value with no stipulated pairings
    var initialProposal = roundCandidate({
        actorsCount: actors.length,
        valueSortedPairings: valueSortedPairings,
        pairingValueMap: pairingValueMap,
        deltaObjects: deltaObjects,
        valueObjects: valueObjects,
    });
    var candidateHashes = [candidateHash(initialProposal)];
    proposedCandidates.push(initialProposal);
    var lowCandidateValue = initialProposal.value;
    var deltaCandidate = initialProposal;
    // iterations is the number of loops over valueSortedPairings
    var candidatesCount = 0;
    var iterations = 0;
    var opponentCount = actors.length;
    var calculatedIterations;
    // calculate the number of opponents to consider for each participantId
    do {
        opponentCount -= 1;
        calculatedIterations = actors.length * pairingValues[actors[0]].length;
    } while (calculatedIterations > maxIterations && opponentCount > 5);
    // keep track of proposed pairings
    var stipulatedPairs = [];
    // for each actor generate a roundCandidate using opponentCount of pairing values
    actors.forEach(function (actor) {
        var participantIdPairings = pairingValues[actor];
        // opponentCount limits the number of opponents to consider
        participantIdPairings.slice(0, opponentCount).forEach(function (pairing) {
            iterations += 1;
            var stipulatedPair = pairingHash(actor, pairing.opponent);
            if (!stipulatedPairs.includes(stipulatedPair)) {
                var proposed = roundCandidate({
                    // each roundCandidate starts with stipulated pairings
                    stipulated: [[actor, pairing.opponent]],
                    actorsCount: actors.length,
                    valueSortedPairings: valueSortedPairings,
                    pairingValueMap: pairingValueMap,
                    deltaObjects: deltaObjects,
                    valueObjects: valueObjects,
                });
                // ensure no duplicate candidates are considered
                if (!candidateHashes.includes(candidateHash(proposed))) {
                    candidateHashes.push(candidateHash(proposed));
                    proposedCandidates.push(proposed);
                    var maxDelta = proposed.maxDelta, value = proposed.value;
                    if (maxDelta < deltaCandidate.maxDelta)
                        deltaCandidate = proposed;
                    if (value < lowCandidateValue ||
                        (value === lowCandidateValue && Math.round(Math.random())) // randomize if equivalent values
                    ) {
                        lowCandidateValue = value;
                    }
                    stipulatedPairs.push(stipulatedPair);
                    candidatesCount += 1;
                }
            }
        });
        proposedCandidates = proposedCandidates.filter(function (proposed) { return Math.abs(proposed.value - lowCandidateValue) < 5; });
    });
    proposedCandidates.sort(function (a, b) { return a.maxDiff - b.maxDiff; });
    var candidate = randomPop(proposedCandidates);
    return {
        candidatesCount: candidatesCount,
        deltaCandidate: deltaCandidate,
        maxIterations: maxIterations,
        iterations: iterations,
        candidate: candidate,
    };
}
function candidateHash(candidate) {
    return candidate.participantIdPairings
        .map(function (_a) {
        var participantIds = _a.participantIds;
        return participantIds.sort().join('|');
    })
        .sort()
        .join('/');
}
function roundCandidate(_a) {
    var valueSortedPairings = _a.valueSortedPairings, _b = _a.stipulated, stipulated = _b === void 0 ? [] : _b, pairingValueMap = _a.pairingValueMap, deltaObjects = _a.deltaObjects, valueObjects = _a.valueObjects, actorsCount = _a.actorsCount;
    // roundPlayers starts with the stipulated pairing
    var roundPlayers = [].concat.apply([], __spreadArray([], __read(stipulated), false));
    // aggregates the pairings generated for a roundCandidate
    var participantIdPairings = [];
    // candidateValue is the sum of all participantIdPairings in a roundCandidate
    // the winning candidate has the LOWEST total value
    var candidateValue = 0;
    // candidateValue is initialized with any stipulated pairings
    stipulated.filter(Boolean).forEach(function (participantIds) {
        var _a = __read(participantIds, 2), p1 = _a[0], p2 = _a[1];
        var pairing = pairingHash(p1, p2);
        var value = pairingValueMap[pairing];
        participantIdPairings.push({ participantIds: participantIds, value: value });
        candidateValue += pairingValueMap[pairing];
    });
    // valueSortedPairings is an array sorted from lowest value to highest value
    // introduce random shuffling of chunks of valueSortedPairings
    var consideredPairings = chunkArray(valueSortedPairings, actorsCount)
        .map(function (pairings) {
        return shuffleArray(pairings).map(function (pairing) { return (__assign(__assign({}, pairing), { value: pairing.value + Math.random() * Math.round(Math.random()) })); });
    })
        .flat();
    // go through the valueSortedPairings (of all possible unique pairings)
    consideredPairings.forEach(function (rankedPairing) {
        var participantIds = rankedPairing.pairing.split('|');
        var opponentExists = participantIds.reduce(function (p, c) { return roundPlayers.includes(c) || p; }, false);
        if (!opponentExists) {
            roundPlayers.push.apply(roundPlayers, __spreadArray([], __read(participantIds), false));
            var value = rankedPairing.value;
            candidateValue += value;
            participantIdPairings.push({ participantIds: participantIds, value: value });
        }
    });
    // sort the candidate's proposed pairings by value
    participantIdPairings.sort(function (a, b) { return a.value - b.value; });
    // determine the greatest delta in the candidate's pairings
    var maxDelta = participantIdPairings.reduce(function (p, c) {
        var _a = __read(c.participantIds, 2), p1 = _a[0], p2 = _a[1];
        var hash = pairingHash(p1, p2);
        var delta = deltaObjects[hash];
        return delta > p ? delta : p;
    }, 0);
    // determine the greatest delta in the candidate's pairings
    var maxDiff = participantIdPairings.reduce(function (p, c) {
        var _a = __read(c.participantIds, 2), p1 = _a[0], p2 = _a[1];
        var hash = pairingHash(p1, p2);
        var diff = valueObjects[hash];
        return diff > p ? diff : p;
    }, 0);
    return { value: candidateValue, participantIdPairings: participantIdPairings, maxDelta: maxDelta, maxDiff: maxDiff };
}
function pairingHash(id1, id2) {
    return [id1, id2].sort(stringSort).join('|');
}

function getPairingsData(_a) {
    var participantIds = _a.participantIds;
    var possiblePairings = {};
    var uniquePairings = [];
    participantIds.forEach(function (participantId) {
        possiblePairings[participantId] = participantIds.filter(function (id) { return id !== participantId; });
        possiblePairings[participantId].forEach(function (id) {
            var pairing = pairingHash(id, participantId);
            if (!uniquePairings.includes(pairing))
                uniquePairings.push(pairing);
        });
    });
    var deltaObjects = Object.assign.apply(Object, __spreadArray([{}], __read(uniquePairings.map(function (pairing) {
        var _a;
        return (_a = {}, _a[pairing] = 0, _a);
    })), false));
    return { uniquePairings: uniquePairings, possiblePairings: possiblePairings, deltaObjects: deltaObjects };
}

function getEncounters(_a) {
    var e_1, _b;
    var matchUps = _a.matchUps;
    var encounters = [];
    try {
        for (var matchUps_1 = __values(matchUps), matchUps_1_1 = matchUps_1.next(); !matchUps_1_1.done; matchUps_1_1 = matchUps_1.next()) {
            var matchUp = matchUps_1_1.value;
            var participantIds = matchUp.sides.map(xa('participantId'));
            if (participantIds.length === 2) {
                var _c = __read(participantIds, 2), p1 = _c[0], p2 = _c[1];
                var pairing = pairingHash(p1, p2);
                if (!encounters.includes(pairing))
                    encounters.push(pairing);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (matchUps_1_1 && !matchUps_1_1.done && (_b = matchUps_1.return)) _b.call(matchUps_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { encounters: encounters };
}

function getParticipantPairingValues(_a) {
    var e_1, _b;
    var possiblePairings = _a.possiblePairings, valueObjects = _a.valueObjects;
    var pairingValues = {};
    var _loop_1 = function (participantId) {
        var participantValues = possiblePairings[participantId].map(function (opponent) {
            return pairingValue(participantId, opponent);
        });
        pairingValues[participantId] = participantValues.sort(function (a, b) { return a.value - b.value; });
    };
    try {
        for (var _c = __values(Object.keys(possiblePairings)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var participantId = _d.value;
            _loop_1(participantId);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    function pairingValue(participantId, opponent) {
        var key = pairingHash(participantId, opponent);
        return { opponent: opponent, value: valueObjects[key] };
    }
    return { pairingValues: pairingValues };
}

var ELO = 'ELO';
var NTRP = 'NTRP';
var TRN = 'TRN';
var UTR = 'UTR';
var WTN = 'WTN';
var ratingConstants = {
    ELO: ELO,
    NTRP: NTRP,
    TRN: TRN,
    UTR: UTR,
    WTN: WTN,
};

var _a$e;
var ratingsParameters = (_a$e = {},
    _a$e[ELO] = {
        defaultInitialization: 1500,
        decimalsCount: 0,
        range: [0, 3000],
        ascending: true,
    },
    _a$e[NTRP] = {
        accessors: ['ntrpRating', 'dntrpRatingHundredths'],
        attributes: { ustaRatingType: '' },
        accessor: 'dntrpRatingHundredths',
        defaultInitialization: 3,
        decimalsCount: 1,
        ascending: true,
        range: [1, 7],
    },
    _a$e[UTR] = {
        defaultInitialization: 6,
        accessors: ['utrRating'],
        accessor: 'utrRating',
        decimalsCount: 2,
        ascending: true,
        range: [1, 16],
    },
    _a$e[WTN] = {
        attributes: { confidence: { generator: true, range: [60, 100] } },
        accessors: ['wtnRating', 'confidence'],
        defaultInitialization: 23,
        accessor: 'wtnRating',
        ascending: false,
        decimalsCount: 2,
        range: [40, 1],
    },
    _a$e);

var DEFAULT_RATING = 0;
function getSideRatings(_a) {
    var _b, _c;
    var tournamentParticipants = _a.tournamentParticipants, adHocRatings = _a.adHocRatings, eventType = _a.eventType, scaleName = _a.scaleName, pairing = _a.pairing;
    var defaultRating = (_c = (_b = ratingsParameters[scaleName]) === null || _b === void 0 ? void 0 : _b.defaultInitialization) !== null && _c !== void 0 ? _c : DEFAULT_RATING;
    return pairing.split('|').map(function (participantId) {
        var _a;
        if (eventType === DOUBLES$1) {
            var individualParticipantIds = (_a = tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.find(function (participant) { return participant.participantId === participantId; })) === null || _a === void 0 ? void 0 : _a.individualParticipantIds;
            return !individualParticipantIds
                ? defaultRating * 2
                : individualParticipantIds === null || individualParticipantIds === void 0 ? void 0 : individualParticipantIds.map(function (participantId) { return adHocRatings[participantId] || defaultRating; });
        }
        else {
            return adHocRatings[participantId] || defaultRating;
        }
    });
}

function getPairings(_a) {
    var tournamentParticipants = _a.tournamentParticipants, _b = _a.adHocRatings, adHocRatings = _b === void 0 ? {} : _b, possiblePairings = _a.possiblePairings, // participant keyed; provides array of possible opponents
    uniquePairings = _a.uniquePairings, // hashes of all possible participantId pairings
    maxIterations = _a.maxIterations, deltaObjects = _a.deltaObjects, // difference in rating between paired participants
    valueObjects = _a.valueObjects, // calculated value of a pairing of participants, used for sorting pairings
    eventType = _a.eventType, scaleName = _a.scaleName, salted = _a.salted;
    // modify valueObjects by ratings ratingsDifference squared
    // update deltaObjects to reflect the current difference between participant's ratings
    uniquePairings.forEach(function (pairing) {
        var ratings = getSideRatings({
            tournamentParticipants: tournamentParticipants,
            adHocRatings: adHocRatings,
            scaleName: scaleName,
            eventType: eventType,
            pairing: pairing,
        });
        var salting = (typeof salted === 'number' && salted) || 0.5;
        var salt = (salted && (Math.round(Math.random()) ? salting : salting * -1)) || 0;
        var ratingsDifference = Math.abs(ratings[0] - ratings[1]) + salt;
        var pairingDelta = Math.abs(ratings[0] - ratings[1]);
        deltaObjects[pairing] = pairingDelta;
        if (!valueObjects[pairing])
            valueObjects[pairing] = 0;
        valueObjects[pairing] += ratingsDifference
            ? Math.pow(ratingsDifference, 2)
            : 0;
    });
    /**
     * valueSortedPairings are uniquePairings sorted by the ratings difference of the pairings, lowest to highest
     */
    var valueSortedPairings = uniquePairings
        .map(function (pairing) { return ({ pairing: pairing, value: valueObjects[pairing] }); })
        .sort(function (a, b) { return a.value - b.value; });
    /**
     * pairingValues is keyed by participantId and provides a value-sorted array of pairings for each participantId
     * 'actorId': [
          { opponent: 'potentialId1', value: 1 },
          { opponent: 'potentialId2', value: 1 },
     */
    var pairingValues = getParticipantPairingValues({
        possiblePairings: possiblePairings,
        valueObjects: valueObjects,
    }).pairingValues;
    var _c = generateCandidate({
        valueSortedPairings: valueSortedPairings,
        maxIterations: maxIterations,
        pairingValues: pairingValues,
        deltaObjects: deltaObjects,
        valueObjects: valueObjects,
    }), candidate = _c.candidate, candidatesCount = _c.candidatesCount, deltaCandidate = _c.deltaCandidate, iterations = _c.iterations;
    var participantIdPairings = candidate.participantIdPairings;
    return {
        participantIdPairings: participantIdPairings,
        candidatesCount: candidatesCount,
        deltaCandidate: deltaCandidate,
        iterations: iterations,
        candidate: candidate,
    };
}

// this should be in policyDefinitions
var ENCOUNTER_VALUE = 100;
var SAME_TEAM_VALUE = 100;
var MAX_ITERATIONS = 4000;
function generateDrawMaticRound(_a) {
    var e_1, _b, e_2, _c, e_3, _d;
    var _e, _f;
    var _g = _a.encounterValue, encounterValue = _g === void 0 ? ENCOUNTER_VALUE : _g, _h = _a.sameTeamValue, sameTeamValue = _h === void 0 ? SAME_TEAM_VALUE : _h, _j = _a.maxIterations, maxIterations = _j === void 0 ? MAX_ITERATIONS : _j, _k = _a.generateMatchUps, generateMatchUps = _k === void 0 ? true : _k, tournamentParticipants = _a.tournamentParticipants, participantIds = _a.participantIds, drawDefinition = _a.drawDefinition, adHocRatings = _a.adHocRatings, structureId = _a.structureId, _l = _a.salted, salted = _l === void 0 ? 0.5 : _l, matchUpIds = _a.matchUpIds, eventType = _a.eventType, structure = _a.structure, scaleName = _a.scaleName, idPrefix = _a.idPrefix, isMock = _a.isMock, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structure && !structureId)
        return { error: STRUCTURE_NOT_FOUND };
    if (!structure) {
        structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    }
    if (!isObject(structure))
        return { error: MISSING_STRUCTURE };
    if (!(participantIds === null || participantIds === void 0 ? void 0 : participantIds.length)) {
        return { error: MISSING_PARTICIPANT_IDS };
    }
    // create valueObject for each previous encounter within the structure
    var encounters = getEncounters({ matchUps: (_e = structure === null || structure === void 0 ? void 0 : structure.matchUps) !== null && _e !== void 0 ? _e : [] }).encounters;
    // valueObjects provide "weighting" to each possible pairing of participants
    // {
    //  'P-I-0|P-I-1': 1,
    //  'P-I-0|P-I-2': 1,
    //  'P-I-0|P-I-3': 1
    // }
    var valueObjects = {};
    try {
        for (var encounters_1 = __values(encounters), encounters_1_1 = encounters_1.next(); !encounters_1_1.done; encounters_1_1 = encounters_1.next()) {
            var pairing = encounters_1_1.value;
            if (!valueObjects[pairing])
                valueObjects[pairing] = 0;
            valueObjects[pairing] += encounterValue;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (encounters_1_1 && !encounters_1_1.done && (_b = encounters_1.return)) _b.call(encounters_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var teamParticipants = tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.filter(function (_a) {
        var participantType = _a.participantType;
        return participantType === TEAM$1;
    });
    if (teamParticipants) {
        try {
            // add SAME_TEAM_VALUE for participants who appear on the same team
            for (var teamParticipants_1 = __values(teamParticipants), teamParticipants_1_1 = teamParticipants_1.next(); !teamParticipants_1_1.done; teamParticipants_1_1 = teamParticipants_1.next()) {
                var teamParticipant = teamParticipants_1_1.value;
                var participantIds_1 = (_f = teamParticipant.individualParticipantIds) !== null && _f !== void 0 ? _f : [];
                var uniquePairings_2 = getPairingsData({ participantIds: participantIds_1 }).uniquePairings;
                try {
                    for (var uniquePairings_1 = (e_3 = void 0, __values(uniquePairings_2)), uniquePairings_1_1 = uniquePairings_1.next(); !uniquePairings_1_1.done; uniquePairings_1_1 = uniquePairings_1.next()) {
                        var pairing = uniquePairings_1_1.value;
                        if (!valueObjects[pairing])
                            valueObjects[pairing] = 0;
                        valueObjects[pairing] += sameTeamValue;
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (uniquePairings_1_1 && !uniquePairings_1_1.done && (_d = uniquePairings_1.return)) _d.call(uniquePairings_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (teamParticipants_1_1 && !teamParticipants_1_1.done && (_c = teamParticipants_1.return)) _c.call(teamParticipants_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    // deltaObjects contain the difference in ratings between two participants
    // {
    //  'P-I-0|P-I-1': 0,
    //  'P-I-0|P-I-2': 0,
    //  'P-I-0|P-I-3': 0
    // }
    var _m = getPairingsData({
        participantIds: participantIds,
    }), uniquePairings = _m.uniquePairings, possiblePairings = _m.possiblePairings, deltaObjects = _m.deltaObjects;
    var params = {
        tournamentParticipants: tournamentParticipants,
        possiblePairings: possiblePairings,
        drawDefinition: drawDefinition,
        participantIds: participantIds,
        uniquePairings: uniquePairings,
        maxIterations: maxIterations,
        adHocRatings: adHocRatings,
        deltaObjects: deltaObjects,
        valueObjects: valueObjects,
        eventType: eventType,
        scaleName: scaleName,
        structure: structure,
        salted: salted,
    };
    var _o = getPairings(params), candidatesCount = _o.candidatesCount, participantIdPairings = _o.participantIdPairings, iterations = _o.iterations, candidate = _o.candidate;
    if (!candidatesCount)
        return { error: NO_CANDIDATES };
    var matchUps;
    if (generateMatchUps) {
        var result = generateAdHocMatchUps({
            structureId: structure === null || structure === void 0 ? void 0 : structure.structureId,
            participantIdPairings: participantIdPairings,
            newRound: true,
            drawDefinition: drawDefinition,
            matchUpIds: matchUpIds,
            idPrefix: idPrefix,
            isMock: isMock,
            event: event,
        });
        if (result.error)
            return result;
        matchUps = result.matchUps;
    }
    var maxDelta = candidate.maxDelta, maxDiff = candidate.maxDiff;
    return __assign(__assign({}, SUCCESS), { participantIdPairings: participantIdPairings, candidatesCount: candidatesCount, iterations: iterations, matchUps: matchUps, maxDelta: maxDelta, maxDiff: maxDiff });
}

function drawMatic(params) {
    var e_1, _a;
    var _b, _c, _d, _e, _f, _g, _h;
    var restrictEntryStatus = params.restrictEntryStatus, _j = params.adHocRatings, adHocRatings = _j === void 0 ? {} : _j, generateMatchUps = params.generateMatchUps, tournamentRecord = params.tournamentRecord, encounterValue = params.encounterValue, sameTeamValue = params.sameTeamValue, drawDefinition = params.drawDefinition, scaleAccessor = params.scaleAccessor, maxIterations = params.maxIterations, matchUpIds = params.matchUpIds, scaleName = params.scaleName, // custom rating name to seed dynamic ratings
    idPrefix = params.idPrefix, salted = params.salted, event = params.event;
    if (typeof drawDefinition !== 'object' || (drawDefinition.drawType && drawDefinition.drawType !== AD_HOC)) {
        return { error: INVALID_DRAW_DEFINITION };
    }
    var participantIds = params.participantIds, structureId = params.structureId;
    var isMock = (_b = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.isMock) !== null && _b !== void 0 ? _b : params.isMock;
    if (!Array.isArray(drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) && participantIds && !Array.isArray(participantIds)) {
        return { error: INVALID_VALUES, info: 'Missing Entries' };
    }
    var eventType = (_c = params.eventType) !== null && _c !== void 0 ? _c : event === null || event === void 0 ? void 0 : event.eventType;
    var enteredParticipantIds = (_d = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) === null || _d === void 0 ? void 0 : _d.filter(function (entry) {
        var entryStatus = entry.entryStatus;
        return !restrictEntryStatus || STRUCTURE_SELECTED_STATUSES.includes(entryStatus);
    }).map(getParticipantId);
    if (participantIds) {
        // ensure all participantIds are in drawDefinition.entries
        var invalidParticipantIds = participantIds.filter(function (participantId) { return !(enteredParticipantIds === null || enteredParticipantIds === void 0 ? void 0 : enteredParticipantIds.includes(participantId)); });
        if (invalidParticipantIds === null || invalidParticipantIds === void 0 ? void 0 : invalidParticipantIds.length)
            return decorateResult({
                result: { error: INVALID_PARTICIPANT_ID },
                info: { invalidParticipantIds: invalidParticipantIds },
            });
    }
    else {
        participantIds = enteredParticipantIds;
    }
    // if no structureId is specified find the latest AD_HOC stage which has matchUps
    if (!structureId) {
        var targetStructure = (_f = (_e = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) === null || _e === void 0 ? void 0 : _e.filter(function (structure) { return structure.stageSequence === 1; })) === null || _f === void 0 ? void 0 : _f.reduce(function (targetStructure, structure) {
            var orderNumber = structure.stage && stageOrder$1[structure.stage];
            var structureIsAdHoc = isAdHoc({ drawDefinition: drawDefinition, structure: structure });
            return structureIsAdHoc && orderNumber > (stageOrder$1[targetStructure === null || targetStructure === void 0 ? void 0 : targetStructure.stage] || 1)
                ? structure
                : targetStructure;
        }, undefined);
        structureId = targetStructure === null || targetStructure === void 0 ? void 0 : targetStructure.structureId;
    }
    var structure = (_g = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) === null || _g === void 0 ? void 0 : _g.find(function (structure) { return structure.structureId === structureId; });
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    // an AD_HOC structure is one that has no child structures and in which no matchUps have roundPosition
    var structureIsAdHoc = isAdHoc({ drawDefinition: drawDefinition, structure: structure });
    if (!structureIsAdHoc)
        return { error: INVALID_DRAW_DEFINITION };
    var tournamentParticipants = (_h = tournamentRecord.participants) !== null && _h !== void 0 ? _h : [];
    var _loop_1 = function (participantId) {
        var participant = tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.find(function (participant) { return participant.participantId === participantId; });
        // first see if there is already a dynamic value
        var scaleValue = getScaleValue({
            scaleName: "".concat(scaleName, ".").concat(DYNAMIC),
            scaleAccessor: scaleAccessor,
            participant: participant,
            eventType: eventType,
        });
        // if no dynamic value found and a seeding scaleValue is provided...
        if (!scaleValue && scaleName) {
            scaleValue = getScaleValue({
                scaleAccessor: scaleAccessor,
                participant: participant,
                scaleName: scaleName,
                eventType: eventType,
            });
        }
        if (scaleValue && !adHocRatings[participantId])
            adHocRatings[participantId] = scaleValue;
    };
    try {
        for (var _k = __values(participantIds !== null && participantIds !== void 0 ? participantIds : []), _l = _k.next(); !_l.done; _l = _k.next()) {
            var participantId = _l.value;
            _loop_1(participantId);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_l && !_l.done && (_a = _k.return)) _a.call(_k);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // TODO: update dynamic ratings based on matchUps present from last played round
    // use scaleEngine.generateDynamicRatings(); see dynamicCalculations.test.ts
    return generateDrawMaticRound({
        tournamentParticipants: tournamentParticipants,
        generateMatchUps: generateMatchUps,
        participantIds: participantIds,
        encounterValue: encounterValue,
        sameTeamValue: sameTeamValue,
        drawDefinition: drawDefinition,
        maxIterations: maxIterations,
        adHocRatings: adHocRatings,
        matchUpIds: matchUpIds,
        structure: structure,
        eventType: eventType,
        idPrefix: idPrefix,
        salted: salted,
        isMock: isMock,
        event: event,
    });
}
function getScaleValue(_a) {
    var _b;
    var _c = _a.scaleType, scaleType = _c === void 0 ? RATING$1 : _c, scaleAccessor = _a.scaleAccessor, participant = _a.participant, scaleName = _a.scaleName, eventType = _a.eventType;
    var scaleAttributes = {
        eventType: eventType !== null && eventType !== void 0 ? eventType : SINGLES_EVENT,
        scaleType: scaleType,
        scaleName: scaleName,
    };
    var result = participant &&
        participantScaleItem({
            scaleAttributes: scaleAttributes,
            participant: participant,
        });
    var scaleValue = (_b = result === null || result === void 0 ? void 0 : result.scaleItem) === null || _b === void 0 ? void 0 : _b.scaleValue;
    return scaleAccessor && isObject(scaleValue) ? scaleValue[scaleAccessor] : scaleValue;
}

function addAdHocMatchUps(_a) {
    var _b;
    var _c, _d, _e, _f, _g, _h, _j;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, structureId = _a.structureId, matchUps = _a.matchUps;
    if (typeof drawDefinition !== 'object')
        return { error: MISSING_DRAW_DEFINITION };
    if (!structureId && ((_c = drawDefinition.structures) === null || _c === void 0 ? void 0 : _c.length) === 1)
        structureId = (_e = (_d = drawDefinition.structures) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.structureId;
    if (typeof structureId !== 'string')
        return { error: MISSING_STRUCTURE_ID };
    if (!validMatchUps(matchUps))
        return { error: INVALID_VALUES, info: mustBeAnArray('matchUps') };
    var structure = (_f = drawDefinition.structures) === null || _f === void 0 ? void 0 : _f.find(function (structure) { return structure.structureId === structureId; });
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    var existingMatchUps = structure === null || structure === void 0 ? void 0 : structure.matchUps;
    var structureHasRoundPositions = existingMatchUps.find(function (matchUp) { return !!matchUp.roundPosition; });
    if (structure.structures ||
        structureHasRoundPositions ||
        structure.finishingPosition === ROUND_OUTCOME) {
        return { error: INVALID_STRUCTURE };
    }
    var existingMatchUpIds = (_j = (_h = (_g = allTournamentMatchUps({
        tournamentRecord: tournamentRecord,
        inContext: false,
    })) === null || _g === void 0 ? void 0 : _g.matchUps) === null || _h === void 0 ? void 0 : _h.map(getMatchUpId)) !== null && _j !== void 0 ? _j : [];
    var newMatchUpIds = matchUps.map(getMatchUpId);
    if (overlap(existingMatchUpIds, newMatchUpIds)) {
        return {
            error: EXISTING_MATCHUP_ID,
            info: 'One or more matchUpIds already present in tournamentRecord',
        };
    }
    (_b = structure.matchUps).push.apply(_b, __spreadArray([], __read(matchUps), false));
    addMatchUpsNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        drawDefinition: drawDefinition,
        matchUps: matchUps,
    });
    modifyDrawNotice({ drawDefinition: drawDefinition, structureIds: [structureId] });
    return __assign({}, SUCCESS);
}

function attachFlightProfile(_a) {
    var _b;
    var deleteExisting = _a.deleteExisting, event = _a.event, flightProfile = _a.flightProfile;
    var stack = 'attachFlightProfile';
    if (!flightProfile)
        return decorateResult({ result: { error: MISSING_VALUE }, stack: stack });
    if (!event)
        return decorateResult({ result: { error: MISSING_EVENT }, stack: stack });
    var existingFlightProfile = getFlightProfile({ event: event }).flightProfile;
    if (existingFlightProfile && !deleteExisting)
        return decorateResult({ result: { error: EXISTING_PROFILE }, stack: stack });
    if ((_b = event.drawDefinitions) === null || _b === void 0 ? void 0 : _b.length)
        return decorateResult({
            result: { error: EXISTING_DRAW_DEFINITIONS },
            stack: stack,
        });
    var extension = {
        name: FLIGHT_PROFILE,
        value: flightProfile,
    };
    addEventExtension({ event: event, extension: extension });
    return __assign({ flightProfile: makeDeepCopy(flightProfile, false, true) }, SUCCESS);
}

/**
 *
 * @param {object} tournamentRecord - passed automatically if tournamentEngine.setState()
 * @param {string[]} participantIds
 * @param {string} scaleAttributes - { scaleType, scaleName, eventType }
 * @returns {boolean} { success: true } or { error }
 */
function removeParticipantsScaleItems(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, scaleAttributes = _a.scaleAttributes, participantIds = _a.participantIds;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!participantIds)
        return { error: MISSING_PARTICIPANT_IDS };
    if (!scaleAttributes)
        return { error: MISSING_VALUE, info: 'scaleAttributes required' };
    var scaleType = scaleAttributes.scaleType, eventType = scaleAttributes.eventType, scaleName = scaleAttributes.scaleName;
    var itemType = [SCALE, scaleType, eventType, scaleName].join('.');
    (_b = tournamentRecord.participants) === null || _b === void 0 ? void 0 : _b.forEach(function (participant) {
        if (participantIds.includes(participant.participantId) &&
            participant.timeItems) {
            participant.timeItems = participant.timeItems.filter(function (timeItem) {
                return timeItem && (timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType) !== itemType;
            });
        }
    });
    return __assign({}, SUCCESS);
}

/**
 *
 * @param {object} tournamentRecord - passed automatically if tournamentEngine.setState()
 * @param {string} eventId - resolves to event
 * @param {string} drawId - OPTIONAL - resolves drawDefinition - scopes participants to clear to drawDefinition.entries or flightProfile.flight.drawEntries
 * @param {string} scaleAttributes - { scaleType, scaleName, eventType }
 * @param {string} stage - OPTIONAL - filter event or draw entries by stage
 * @returns {boolean} { success: true } or { error }
 */
function removeScaleValues(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, scaleAttributes = _a.scaleAttributes, drawDefinition = _a.drawDefinition, entryStatuses = _a.entryStatuses, drawId = _a.drawId, event = _a.event, stage = _a.stage;
    if (!event)
        return { error: MISSING_EVENT };
    if (entryStatuses && !Array.isArray(entryStatuses))
        return decorateResult({
            result: { error: INVALID_VALUES },
            info: mustBeAnArray('entryStatus'),
            stack: 'removeScaleValues',
        });
    var entries = event.entries;
    if (drawId) {
        var flightProfile = getFlightProfile({ event: event }).flightProfile;
        var flight = (_b = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _b === void 0 ? void 0 : _b.find(function (flight) { return flight.drawId === drawId; });
        if (flight) {
            entries = flight.drawEntries;
        }
        else {
            entries = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries;
        }
    }
    var stageEntries = (entries || []).filter(function (entry) {
        return (!stage || !entry.entryStage || entry.entryStage === stage) &&
            (!entryStatuses || entryStatuses.includes(entry.entryStatus));
    });
    var participantIds = stageEntries.map(getParticipantId);
    return removeParticipantsScaleItems({
        tournamentRecord: tournamentRecord,
        scaleAttributes: scaleAttributes,
        participantIds: participantIds,
    });
}

function applyLineUps(_a) {
    var e_1, _b, e_2, _c, e_3, _d, e_4, _e;
    var _f, _g, _h, _j;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, matchUpId = _a.matchUpId, lineUps = _a.lineUps, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!drawDefinition)
        return { error: DRAW_DEFINITION_NOT_FOUND };
    if (typeof matchUpId !== 'string')
        return { error: INVALID_MATCHUP };
    if (!Array.isArray(lineUps))
        return { error: INVALID_VALUES, lineUps: lineUps };
    var stack = 'applyLineUps';
    var tournamentParticipants = tournamentRecord.participants || [];
    var result = findDrawMatchUp({
        tournamentParticipants: tournamentParticipants,
        inContext: true,
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
    });
    if (result.error)
        return result;
    if (!result.matchUp)
        return { error: MATCHUP_NOT_FOUND };
    var inContextMatchUp = result.matchUp, structure = result.structure;
    var drawPositions = inContextMatchUp.drawPositions, matchUpType = inContextMatchUp.matchUpType;
    if (matchUpType !== TEAM)
        return { error: INVALID_MATCHUP };
    if (!(drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.length))
        return { error: MISSING_DRAW_POSITIONS };
    var tieFormat = (_f = resolveTieFormat({
        matchUp: inContextMatchUp,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    })) === null || _f === void 0 ? void 0 : _f.tieFormat;
    // verify integrity of lineUps...
    // 1. all participantIds must be valid individualParticipantIds
    // 2. there should be at most one participantId for a given collectionPosition in singles
    // 3. there should be at most two participantIds for a given collectionPosition in doubles
    var sideAssignments = {};
    try {
        for (var lineUps_1 = __values(lineUps), lineUps_1_1 = lineUps_1.next(); !lineUps_1_1.done; lineUps_1_1 = lineUps_1.next()) {
            var lineUp = lineUps_1_1.value;
            if (!Array.isArray(lineUp))
                return { error: INVALID_VALUES, lineUp: lineUp };
            // maintain mapping of collectionId|collectionPosition to the participantIds assigned
            var collectionParticipantIds = {};
            var sideNumbers = [];
            var _loop_1 = function (lineUpAssignment) {
                var e_5, _m;
                if (typeof lineUpAssignment !== 'object')
                    return { value: { error: INVALID_VALUES, lineUpAssignment: lineUpAssignment } };
                var participantId = lineUpAssignment.participantId, _o = lineUpAssignment.collectionAssignments, collectionAssignments = _o === void 0 ? [] : _o;
                if (!Array.isArray(collectionAssignments))
                    return { value: { error: INVALID_VALUES, collectionAssignments: collectionAssignments } };
                var participant = tournamentParticipants.find(function (participant) { return participant.participantId === participantId; });
                if (!participant)
                    return { value: { error: PARTICIPANT_NOT_FOUND } };
                if (participant.participantType !== INDIVIDUAL)
                    return { value: { error: INVALID_PARTICIPANT_TYPE } };
                var sideNumber_1 = (_h = (_g = inContextMatchUp.sides) === null || _g === void 0 ? void 0 : _g.find(function (side) { var _a, _b; return (_b = (_a = side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipantIds) === null || _b === void 0 ? void 0 : _b.includes(participantId); })) === null || _h === void 0 ? void 0 : _h.sideNumber;
                if (sideNumber_1)
                    sideNumbers.push(sideNumber_1);
                var _loop_3 = function (collectionAssignment) {
                    if (typeof collectionAssignment !== 'object')
                        return { value: { error: INVALID_VALUES, collectionAssignment: collectionAssignment } };
                    var collectionId = collectionAssignment.collectionId, collectionPosition = collectionAssignment.collectionPosition;
                    var collectionDefinition = (_j = tieFormat === null || tieFormat === void 0 ? void 0 : tieFormat.collectionDefinitions) === null || _j === void 0 ? void 0 : _j.find(function (collectionDefinition) {
                        return collectionDefinition.collectionId === collectionId;
                    });
                    // all collectionIds in the lineUp must be present in the tieFormat collectionDefinitions
                    if (!collectionDefinition)
                        return { value: { error: INVALID_VALUES, collectionId: collectionId } };
                    var aggregator = "".concat(collectionId, "-").concat(collectionPosition);
                    if (!collectionParticipantIds[aggregator]) {
                        collectionParticipantIds[aggregator] = [];
                    }
                    var participantsCount = collectionParticipantIds[aggregator].length;
                    if ((collectionDefinition.matchUpType === SINGLES && participantsCount) ||
                        (collectionDefinition.matchUpType === DOUBLES &&
                            participantsCount > 1)) {
                        return { value: {
                                info: 'Excessive collectionPosition assignments',
                                error: INVALID_VALUES,
                            } };
                    }
                    collectionParticipantIds[aggregator].push(participantId);
                };
                try {
                    for (var collectionAssignments_1 = (e_5 = void 0, __values(collectionAssignments)), collectionAssignments_1_1 = collectionAssignments_1.next(); !collectionAssignments_1_1.done; collectionAssignments_1_1 = collectionAssignments_1.next()) {
                        var collectionAssignment = collectionAssignments_1_1.value;
                        var state_2 = _loop_3(collectionAssignment);
                        if (typeof state_2 === "object")
                            return state_2;
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (collectionAssignments_1_1 && !collectionAssignments_1_1.done && (_m = collectionAssignments_1.return)) _m.call(collectionAssignments_1);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
            };
            try {
                for (var lineUp_1 = (e_2 = void 0, __values(lineUp)), lineUp_1_1 = lineUp_1.next(); !lineUp_1_1.done; lineUp_1_1 = lineUp_1.next()) {
                    var lineUpAssignment = lineUp_1_1.value;
                    var state_1 = _loop_1(lineUpAssignment);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (lineUp_1_1 && !lineUp_1_1.done && (_c = lineUp_1.return)) _c.call(lineUp_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            // ensure that doubles pair participants exist, otherwise create
            var collectionParticipantIdPairs = Object.values(collectionParticipantIds);
            try {
                for (var collectionParticipantIdPairs_1 = (e_3 = void 0, __values(collectionParticipantIdPairs)), collectionParticipantIdPairs_1_1 = collectionParticipantIdPairs_1.next(); !collectionParticipantIdPairs_1_1.done; collectionParticipantIdPairs_1_1 = collectionParticipantIdPairs_1.next()) {
                    var participantIds = collectionParticipantIdPairs_1_1.value;
                    if (participantIds.length === 2) {
                        var pairedParticipant = getPairedParticipant({
                            tournamentParticipants: tournamentParticipants,
                            participantIds: participantIds,
                        }).participant;
                        if (!pairedParticipant) {
                            // create pair participant
                            var newPairParticipant = {
                                participantType: PAIR,
                                participantRole: COMPETITOR,
                                individualParticipantIds: participantIds,
                            };
                            var result_1 = addParticipant({
                                participant: newPairParticipant,
                                pairOverride: true,
                                tournamentRecord: tournamentRecord,
                            });
                            if (result_1.error)
                                return result_1;
                        }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (collectionParticipantIdPairs_1_1 && !collectionParticipantIdPairs_1_1.done && (_d = collectionParticipantIdPairs_1.return)) _d.call(collectionParticipantIdPairs_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            // determine sideNumber based on instances of participants appearing in team participants assigned to sides
            // allows for some team members to be "borrowed"
            var instances = instanceCount(sideNumbers);
            var sideNumber = ((instances[1] || 0) > (instances[2] || 0) && 1) ||
                ((instances[2] || 0) > (instances[1] || 0) && 2) ||
                undefined;
            // if side not previously assigned, map sideNumber to lineUp
            var sideAssignmentKeys = Object.keys(sideAssignments).map(function (key) {
                return parseInt(key);
            });
            if (sideNumber && !sideAssignmentKeys.includes(sideNumber)) {
                sideAssignments[sideNumber] = lineUp;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (lineUps_1_1 && !lineUps_1_1.done && (_b = lineUps_1.return)) _b.call(lineUps_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (!Object.keys(sideAssignments).length)
        return { error: VALUE_UNCHANGED };
    result = findDrawMatchUp({ drawDefinition: drawDefinition, matchUpId: matchUpId });
    if (result.error)
        return result;
    if (!result.matchUp)
        return { error: MATCHUP_NOT_FOUND };
    var matchUp = result.matchUp;
    if (!matchUp.sides)
        matchUp.sides = [];
    var _loop_2 = function (sideNumber) {
        var side = matchUp.sides.find(function (side) { return side.sideNumber === sideNumber; });
        var assignment = sideAssignments[sideNumber];
        if (!assignment) {
            return "continue";
        }
        else if (!side) {
            matchUp.sides.push({ lineUp: assignment, sideNumber: sideNumber });
        }
        else {
            side.lineUp = assignment;
        }
    };
    try {
        for (var _k = __values([1, 2]), _l = _k.next(); !_l.done; _l = _k.next()) {
            var sideNumber = _l.value;
            _loop_2(sideNumber);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_l && !_l.done && (_e = _k.return)) _e.call(_k);
        }
        finally { if (e_4) throw e_4.error; }
    }
    modifyMatchUpNotice({
        tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        context: stack,
        drawDefinition: drawDefinition,
        matchUp: matchUp,
    });
    return __assign({}, SUCCESS);
}

function resetTieFormat(params) {
    var _a, _b, e_1, _c, e_2, _d;
    var _e, _f, _g;
    var stack = 'resetTieFormat';
    var drawDefinition = params.drawDefinition, event = params.event, uuids = params.uuids;
    var paramCheck = checkRequiredParameters(params, [(_a = {}, _a[TOURNAMENT_RECORD] = true, _a[MATCHUP_ID] = true, _a)], stack);
    if (paramCheck.error)
        return paramCheck;
    var resolutions = resolveFromParameters(params, [(_b = {}, _b[PARAM] = MATCHUP, _b)]);
    if (resolutions[ERROR])
        return resolutions;
    var tournamentId = (_e = params.tournamentRecord) === null || _e === void 0 ? void 0 : _e.tournamentId;
    var _h = (_f = resolutions === null || resolutions === void 0 ? void 0 : resolutions.matchUp) !== null && _f !== void 0 ? _f : {}, matchUp = _h.matchUp, structure = _h.structure;
    if (!(matchUp === null || matchUp === void 0 ? void 0 : matchUp.tieMatchUps))
        return decorateResult({
            result: { error: INVALID_MATCHUP },
            info: 'Must be a TEAM matchUp',
            stack: stack,
        });
    // if there is no tieFormat there is nothing to do
    if (!matchUp.tieFormat)
        return __assign({}, SUCCESS);
    var tieFormat = (_g = resolveTieFormat({
        structure: structure,
        drawDefinition: drawDefinition,
        event: event,
    })) === null || _g === void 0 ? void 0 : _g.tieFormat;
    if (!tieFormat)
        return decorateResult({
            result: { error: NOT_FOUND },
            info: 'No inherited tieFormat',
            stack: stack,
        });
    var deletedMatchUpIds = [];
    var collectionIds = [];
    var tieMatchUps = [];
    var newMatchUps = [];
    var _loop_1 = function (collectionDefinition) {
        // delete any matchUp.tieMatchUps that are not found in the ancestor tieFormat collectionDefinitions
        var matchUpCount = collectionDefinition.matchUpCount, collectionId = collectionDefinition.collectionId;
        collectionIds.push(collectionId);
        var existingCollectionMatchUps = (matchUp.tieMatchUps || []).filter(function (matchUp) { return matchUp.collectionId === collectionId; });
        if (existingCollectionMatchUps.length > matchUpCount) {
            // sort by matchUpStatus to prioritize active or completed matchUpsA
            existingCollectionMatchUps.sort(function (a, b) { return (a.matchUpStatus === TO_BE_PLAYED ? 1 : 0) - (b.matchUpStatus === TO_BE_PLAYED ? 1 : 0); });
            tieMatchUps.push.apply(tieMatchUps, __spreadArray([], __read(existingCollectionMatchUps.slice(0, matchUpCount)), false));
            deletedMatchUpIds.push.apply(deletedMatchUpIds, __spreadArray([], __read(existingCollectionMatchUps.slice(3).map(getMatchUpId)), false));
        }
        else {
            tieMatchUps.push.apply(tieMatchUps, __spreadArray([], __read(existingCollectionMatchUps), false));
            if (existingCollectionMatchUps.length < matchUpCount) {
                var matchUpsLimit = matchUpCount - existingCollectionMatchUps.length;
                var matchUps = generateCollectionMatchUps({
                    collectionDefinition: collectionDefinition,
                    matchUpsLimit: matchUpsLimit,
                    matchUp: matchUp,
                    uuids: uuids,
                });
                newMatchUps.push.apply(newMatchUps, __spreadArray([], __read(matchUps), false));
            }
        }
    };
    try {
        for (var _j = __values(tieFormat.collectionDefinitions), _k = _j.next(); !_k.done; _k = _j.next()) {
            var collectionDefinition = _k.value;
            _loop_1(collectionDefinition);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var _l = __values((matchUp === null || matchUp === void 0 ? void 0 : matchUp.tieMatchUps) || []), _m = _l.next(); !_m.done; _m = _l.next()) {
            var tieMatchUp = _m.value;
            if (tieMatchUp.collectionId && !collectionIds.includes(tieMatchUp.collectionId))
                deletedMatchUpIds.push(tieMatchUp.matchUpId);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
        }
        finally { if (e_2) throw e_2.error; }
    }
    if (newMatchUps.length) {
        tieMatchUps.push.apply(tieMatchUps, __spreadArray([], __read(newMatchUps), false));
        addMatchUpsNotice({
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            matchUps: newMatchUps,
            drawDefinition: drawDefinition,
            tournamentId: tournamentId,
        });
    }
    if (deletedMatchUpIds.length) {
        deleteMatchUpsNotice({
            matchUpIds: deletedMatchUpIds,
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            drawDefinition: drawDefinition,
            tournamentId: tournamentId,
        });
    }
    if (matchUp) {
        matchUp.tieMatchUps = tieMatchUps;
        matchUp.tieFormatId = undefined;
        matchUp.tieFormat = undefined;
        modifyMatchUpNotice({
            structureId: structure === null || structure === void 0 ? void 0 : structure.structureId,
            eventId: event === null || event === void 0 ? void 0 : event.eventId,
            context: stack,
            drawDefinition: drawDefinition,
            tournamentId: tournamentId,
            matchUp: matchUp,
        });
    }
    return __assign(__assign({}, SUCCESS), { newMatchUps: newMatchUps, deletedMatchUpIds: deletedMatchUpIds });
}

function resetScorecard(params) {
    var e_1, _a;
    var _b, _c;
    var tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, matchUpId = params.matchUpId, event = params.event;
    var stack = 'resetScorecard';
    // Check for missing parameters ---------------------------------------------
    if (!drawDefinition)
        return decorateResult({
            result: { error: MISSING_DRAW_DEFINITION },
            stack: stack,
        });
    if (!matchUpId)
        return decorateResult({ result: { error: MISSING_MATCHUP_ID }, stack: stack });
    if (!isString(matchUpId))
        return decorateResult({
            result: { error: INVALID_VALUES, matchUpId: matchUpId },
            stack: stack,
        });
    // Get map of all drawMatchUps and inContextDrawMatchUPs ---------------------
    var matchUpsMap = getMatchUpsMap({ drawDefinition: drawDefinition });
    var inContextDrawMatchUps = getAllDrawMatchUps({
        nextMatchUps: true,
        inContext: true,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
    }).matchUps;
    // Find target matchUp ------------------------------------------------------
    var matchUp = matchUpsMap.drawMatchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
    var inContextMatchUp = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
    if (!matchUp || !inContextDrawMatchUps)
        return { error: MATCHUP_NOT_FOUND };
    // only accept matchUpType: TEAM
    if (matchUp.matchUpType !== TEAM_EVENT)
        return { error: INVALID_MATCHUP };
    // Get winner/loser position targets ----------------------------------------
    var targetData = positionTargets({
        inContextDrawMatchUps: inContextDrawMatchUps,
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
    });
    var structureId = inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.structureId;
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    Object.assign(params, {
        inContextDrawMatchUps: inContextDrawMatchUps,
        inContextMatchUp: inContextMatchUp,
        matchUpsMap: matchUpsMap,
        targetData: targetData,
        structure: structure,
        matchUp: matchUp,
    });
    // with propagating winningSide changes, activeDownstream only applies to eventType: TEAM
    var activeDownstream = isActiveDownstream(params);
    if (activeDownstream)
        return { error: CANNOT_CHANGE_WINNING_SIDE };
    if ((_b = matchUp.tieMatchUps) === null || _b === void 0 ? void 0 : _b.length) {
        try {
            for (var _d = __values(matchUp.tieMatchUps), _e = _d.next(); !_e.done; _e = _d.next()) {
                var tieMatchUp = _e.value;
                var result_1 = setMatchUpState({
                    matchUpId: tieMatchUp.matchUpId,
                    matchUpTieId: matchUpId,
                    winningSide: undefined,
                    removeScore: true,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    event: event,
                });
                if (result_1.error)
                    return decorateResult({ result: result_1, stack: stack });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    var result = updateTieMatchUpScore({
        event: params.event,
        removeScore: true,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        matchUpId: matchUpId,
    });
    if (result.error)
        return decorateResult({ result: result, stack: stack });
    if (params.tiebreakReset && !result.tieFormatRemoved) {
        // check for scenarios where an added "Tiebreaker" collectionDefinition/matchUp has been added
        var inheritedTieFormat = (_c = resolveTieFormat({
            drawDefinition: drawDefinition,
            structure: structure,
            event: event,
        })) === null || _c === void 0 ? void 0 : _c.tieFormat;
        if (matchUp.tieFormat && inheritedTieFormat) {
            var _f = compareTieFormats({
                descendant: matchUp.tieFormat,
                ancestor: inheritedTieFormat,
            }), matchUpCountDifference = _f.matchUpCountDifference, descendantDifferences = _f.descendantDifferences, ancestorDifferences = _f.ancestorDifferences, valueDifference = _f.valueDifference;
            if (descendantDifferences.collectionIds.length === 1 &&
                !ancestorDifferences.collectionIds.length &&
                !ancestorDifferences.groupsCount &&
                matchUpCountDifference === 1 &&
                valueDifference === 1) {
                var result_2 = resetTieFormat({
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    matchUpId: matchUpId,
                    event: event,
                });
                if (result_2.error)
                    return result_2;
            }
        }
    }
    return __assign({}, SUCCESS);
}

function removeSeeding(_a) {
    var _b, _c;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, entryStatuses = _a.entryStatuses, scaleName = _a.scaleName, drawId = _a.drawId, event = _a.event, stage = _a.stage;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    scaleName =
        scaleName ||
            ((_b = event.category) === null || _b === void 0 ? void 0 : _b.categoryName) ||
            ((_c = event.category) === null || _c === void 0 ? void 0 : _c.ageCategoryCode);
    var scaleAttributes = {
        eventType: event.eventType,
        scaleType: SEEDING$1,
        scaleName: scaleName,
    };
    return removeScaleValues({
        tournamentRecord: tournamentRecord,
        scaleAttributes: scaleAttributes,
        drawDefinition: drawDefinition,
        entryStatuses: entryStatuses,
        drawId: drawId,
        event: event,
        stage: stage,
    });
}

function setSubOrder(_a) {
    var _b, _c, _d, _e;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, drawPosition = _a.drawPosition, structureId = _a.structureId, subOrder = _a.subOrder, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!structureId)
        return { error: MISSING_STRUCTURE_ID };
    if (!drawPosition)
        return { error: MISSING_DRAW_POSITION };
    var structure = findStructure({ drawDefinition: drawDefinition, structureId: structureId }).structure;
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    var targetStructure = structure;
    if (structure.structures && structure.structureType === CONTAINER) {
        targetStructure = (_b = structure.structures) === null || _b === void 0 ? void 0 : _b.find(function (currentStructure) {
            var _a;
            return (_a = currentStructure.positionAssignments) === null || _a === void 0 ? void 0 : _a.find(function (assignment) { return assignment.drawPosition === drawPosition; });
        });
    }
    var positionAssignments = targetStructure === null || targetStructure === void 0 ? void 0 : targetStructure.positionAssignments;
    var assignment = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.find(function (assignment) { return assignment.drawPosition === drawPosition; });
    var extension = {
        name: SUB_ORDER,
        value: subOrder,
    };
    assignment && addExtension({ element: assignment, extension: extension });
    var isDualMatchUp = (event === null || event === void 0 ? void 0 : event.eventType) === TEAM ||
        drawDefinition.matchUpType === TEAM ||
        ((_d = (_c = event === null || event === void 0 ? void 0 : event.tieFormat) !== null && _c !== void 0 ? _c : drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.tieFormat) !== null && _d !== void 0 ? _d : structure === null || structure === void 0 ? void 0 : structure.tieFormat);
    var matchUpFilters = isDualMatchUp && { matchUpTypes: [TEAM] };
    var matchUps = getAllStructureMatchUps({
        structure: targetStructure,
        afterRecoveryTimes: false,
        inContext: true,
        matchUpFilters: matchUpFilters,
        event: event,
    }).matchUps;
    var matchUpFormat = (_e = structure === null || structure === void 0 ? void 0 : structure.matchUpFormat) !== null && _e !== void 0 ? _e : drawDefinition.matchUpFormat;
    updateAssignmentParticipantResults({
        positionAssignments: positionAssignments,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        matchUpFormat: matchUpFormat,
        matchUps: matchUps,
        event: event,
    });
    modifyDrawNotice({ drawDefinition: drawDefinition, structureIds: [structureId] });
    return __assign({}, SUCCESS);
}

function deleteEvents(_a) {
    var removePairParticipants = _a.removePairParticipants, tournamentRecord = _a.tournamentRecord, eventIds = _a.eventIds;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!tournamentRecord.events)
        return { error: EVENT_NOT_FOUND };
    if (!Array.isArray(eventIds))
        return { error: MISSING_VALUE, info: mustBeAnArray('drawIds') };
    var auditTrail = [];
    var deletedEventDetails = [];
    var activePairParticipantIds = [];
    var pairParticipantIds = [];
    tournamentRecord.events = (tournamentRecord.events || []).filter(function (event) {
        if (eventIds.includes(event.eventId)) {
            var auditData = {
                action: DELETE_EVENTS,
                payload: { events: [event] },
            };
            auditTrail.push(auditData);
            deletedEventDetails.push({
                tournamentId: tournamentRecord.tournamentId,
                eventName: event.eventName,
                eventType: event.eventType,
                category: event.category,
                eventId: event.eventId,
                gender: event.gender,
            });
        }
        var enteredPairParticipantIds = event.eventType === DOUBLES$1
            ? (event.entries || [])
                .map(function (_a) {
                var entryStatus = _a.entryStatus, participantId = _a.participantId;
                return entryStatus !== UNGROUPED && participantId;
            })
                .filter(Boolean)
            : [];
        var deleteEvent = eventIds.includes(event.eventId);
        if (deleteEvent) {
            pairParticipantIds.push.apply(pairParticipantIds, __spreadArray([], __read(enteredPairParticipantIds), false));
        }
        else {
            activePairParticipantIds.push.apply(activePairParticipantIds, __spreadArray([], __read(enteredPairParticipantIds), false));
        }
        return !deleteEvent;
    });
    if (removePairParticipants) {
        var particiapntIdsToRemove_1 = pairParticipantIds.filter(function (participantId) { return !activePairParticipantIds.includes(participantId); });
        tournamentRecord.participants = tournamentRecord.participants.filter(function (_a) {
            var participantId = _a.participantId;
            return !particiapntIdsToRemove_1.includes(participantId);
        });
    }
    // cleanup references to eventId in schedulingProfile extension
    checkAndUpdateSchedulingProfile({ tournamentRecord: tournamentRecord });
    if (auditTrail.length) {
        addNotice({ topic: AUDIT, payload: auditTrail });
        var timeItem = {
            itemType: DELETE_EVENTS,
            itemValue: deletedEventDetails,
        };
        addTournamentTimeItem({ tournamentRecord: tournamentRecord, timeItem: timeItem });
    }
    return __assign({}, SUCCESS);
}

function getEliminationDrawSize(_a) {
    var participantsCount = _a.participantsCount, participantCount = _a.participantCount;
    participantsCount = participantsCount !== null && participantsCount !== void 0 ? participantsCount : participantCount;
    if (!participantsCount)
        return { error: INVALID_VALUES };
    var drawSize = nextPowerOf2(participantsCount);
    if (!drawSize)
        return decorateResult({
            result: { error: INVALID_VALUES },
            stack: 'getEliminationDrawSize',
            context: { participantsCount: participantsCount },
        });
    return { drawSize: drawSize };
}

function getSeedsCount(params) {
    var _a;
    var _b = params || {}, _c = _b.drawSizeProgression, drawSizeProgression = _c === void 0 ? false : _c, policyDefinitions = _b.policyDefinitions, drawSize = _b.drawSize;
    var _d = params || {}, _e = _d.requireParticipantCount, requireParticipantCount = _e === void 0 ? true : _e, tournamentRecord = _d.tournamentRecord, drawDefinition = _d.drawDefinition, event = _d.event;
    var stack = 'getSeedsCount';
    var participantsCount = (_a = params === null || params === void 0 ? void 0 : params.participantsCount) !== null && _a !== void 0 ? _a : params === null || params === void 0 ? void 0 : params.participantCount;
    if (!policyDefinitions) {
        var result = getPolicyDefinitions({
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            event: event,
        });
        if (result.error)
            return decorateResult({ result: result, stack: stack });
        policyDefinitions = result.policyDefinitions;
    }
    var validParticpantCount = isConvertableInteger(participantsCount);
    if (participantsCount && !validParticpantCount)
        return decorateResult({
            result: { error: INVALID_VALUES },
            context: { participantsCount: participantsCount },
            stack: stack,
        });
    if (requireParticipantCount && !validParticpantCount)
        return decorateResult({
            result: { error: MISSING_PARTICIPANT_COUNT },
            stack: stack,
        });
    if (isNaN(drawSize)) {
        if (participantsCount) {
            (drawSize = getEliminationDrawSize({
                participantsCount: participantsCount,
            }).drawSize);
        }
        else {
            return decorateResult({ result: { error: MISSING_DRAW_SIZE }, stack: stack });
        }
    }
    var consideredParticipantCount = (requireParticipantCount && participantsCount) || drawSize;
    if (consideredParticipantCount && consideredParticipantCount > drawSize)
        return { error: PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE };
    var policy = policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_SEEDING];
    if (!policy)
        return { error: INVALID_POLICY_DEFINITION };
    var seedsCountThresholds = policy.seedsCountThresholds;
    if (!seedsCountThresholds)
        return { error: MISSING_SEEDCOUNT_THRESHOLDS };
    if (policy.drawSizeProgression !== undefined)
        drawSizeProgression = policy.drawSizeProgression;
    var relevantThresholds = seedsCountThresholds.filter(function (threshold) {
        return drawSizeProgression
            ? threshold.drawSize <= drawSize
            : drawSize === threshold.drawSize;
    });
    var seedsCount = relevantThresholds.reduce(function (seedsCount, threshold) {
        return participantsCount &&
            participantsCount >= threshold.minimumParticipantCount
            ? threshold.seedsCount
            : seedsCount;
    }, 0);
    return { seedsCount: seedsCount };
}

function getEntriesAndSeedsCount(_a) {
    var policyDefinitions = _a.policyDefinitions, drawDefinition = _a.drawDefinition, drawSize = _a.drawSize, drawId = _a.drawId, event = _a.event, stage = _a.stage;
    if (!event)
        return { error: MISSING_EVENT };
    var _b = getStageEntries({
        drawDefinition: drawDefinition,
        drawId: drawId,
        stage: stage,
        event: event,
    }), entries = _b.entries, stageEntries = _b.stageEntries;
    var participantsCount = stageEntries.length;
    var eliminationDrawSize = getEliminationDrawSize({
        participantsCount: participantsCount,
    }).drawSize;
    var result = getSeedsCount({
        drawSize: drawSize !== null && drawSize !== void 0 ? drawSize : eliminationDrawSize,
        participantsCount: participantsCount,
        policyDefinitions: policyDefinitions,
    });
    if (result.error)
        return decorateResult({ result: result, stack: 'getEntriesAndSeedsCount' });
    var seedsCount = result.seedsCount;
    return { entries: entries, seedsCount: seedsCount, stageEntries: stageEntries };
}

function generateSeedingScaleItems(_a) {
    var scaleAttributes = _a.scaleAttributes, scaledEntries = _a.scaledEntries, stageEntries = _a.stageEntries, seedsCount = _a.seedsCount, scaleName = _a.scaleName;
    if (!scaleAttributes)
        return { error: MISSING_VALUE, info: 'missing scaleAttributes' };
    var seededEntries = Object.assign.apply(Object, __spreadArray([{}], __read((scaledEntries || [])
        .slice(0, seedsCount)
        .map(function (_a, index) {
        var _b;
        var participantId = _a.participantId;
        return (_b = {}, _b[participantId] = index + 1, _b);
    })), false));
    scaleName = scaleName || scaleAttributes.scaleName;
    var scaleDate = new Date().toISOString();
    var scaleItemsWithParticipantIds = stageEntries.map(function (_a) {
        var participantId = _a.participantId;
        var scaleItem = {
            scaleValue: seededEntries[participantId],
            eventType: scaleAttributes.eventType,
            scaleType: SEEDING$1,
            scaleName: scaleName,
            scaleDate: scaleDate,
        };
        return {
            scaleItems: [scaleItem],
            participantId: participantId,
        };
    });
    return { scaleItemsWithParticipantIds: scaleItemsWithParticipantIds };
}

function getParticipantScaleItem(params) {
    var _a;
    var tournamentRecord = params.tournamentRecord, scaleAttributes = params.scaleAttributes, participantId = params.participantId;
    var tournamentRecords = params.tournamentRecords ||
        (tournamentRecord && (_a = {},
            _a[tournamentRecord.tournamentId] = tournamentRecord,
            _a)) ||
        {};
    if (!participantId)
        return { error: MISSING_PARTICIPANT_ID };
    var _b = findTournamentParticipant({
        tournamentRecords: tournamentRecords,
        tournamentRecord: tournamentRecord,
        participantId: participantId,
    }), participant = _b.participant, tournamentId = _b.tournamentId;
    if (!participant)
        return { error: PARTICIPANT_NOT_FOUND };
    return __assign(__assign({}, participantScaleItem({ participant: participant, scaleAttributes: scaleAttributes })), { tournamentId: tournamentId });
}

function getScaledEntries(_a) {
    var _b;
    var _c = _a.sortDescending, sortDescending = _c === void 0 ? false : _c, tournamentRecord = _a.tournamentRecord, scaleAttributes = _a.scaleAttributes, scaleSortMethod = _a.scaleSortMethod, stageSequence = _a.stageSequence, entries = _a.entries, event = _a.event, stage = _a.stage;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    entries = (_b = entries !== null && entries !== void 0 ? entries : event === null || event === void 0 ? void 0 : event.entries) !== null && _b !== void 0 ? _b : [];
    var stageEntries = entries.filter(function (entry) {
        return (!stage || !entry.entryStage || entry.entryStage === stage) &&
            (!stageSequence ||
                !entry.entryStageSequence ||
                entry.entryStageSequence === stageSequence) &&
            STRUCTURE_SELECTED_STATUSES.includes(entry.entryStatus);
    });
    var scaledEntries = stageEntries
        .map(function (entry) {
        var participantId = entry.participantId;
        var scaleItem = getParticipantScaleItem({
            tournamentRecord: tournamentRecord,
            scaleAttributes: scaleAttributes,
            participantId: participantId,
        }).scaleItem;
        // return a new object so original entry is untouched
        return __assign(__assign({}, entry), scaleItem);
    })
        .filter(function (scaledEntry) {
        var scaleValue = scaledEntry.scaleValue;
        // if a custom sort method is not provided, filter out entries with non-float values
        if (!scaleSortMethod && (isNaN(scaleValue) || !parseFloat(scaleValue)))
            return false;
        return scaleValue;
    })
        .sort(scaleSortMethod || defaultScaleValueSort);
    return { scaledEntries: scaledEntries };
    function defaultScaleValueSort(a, b) {
        return sortDescending
            ? scaleItemValue(b) - scaleItemValue(a)
            : scaleItemValue(a) - scaleItemValue(b);
    }
    function scaleItemValue(scaleItem) {
        return parseFloat(scaleItem.scaleValue || (sortDescending ? -1 : 1e5));
    }
}

/**
 *
 * @param {object} tournamentRecord - passed automatically if tournamentEngine.setState() has been called
 * @param {string} eventId - resolved by tournamentEngine to the event object
 *
 * @param {object} policyDefinitions - seeding policyDefinitions determines the # of seeds for given participantsCount/drawSize
 * @param {object} scaleAttributes -
 * @param {string} scaleName - OPTIONAL - defaults to scaleAttributes.scaleName
 * @param {number} drawSize - OPTIONAL - defaults to calculation based on # of entries
 * @param {string} drawId - OPTIONAL - will use flight.drawEntries or drawDefinition.entries rather than event.entries
 * @param {string} stage - OPTIONAL - filters entries by specified stage
 *
 * @param {boolean} sortDescending - OPTIONAL - defaults to false
 * @param {function} scaleSortMethod - OPTIONAL - user defined sorting method
 *
 * @returns {object} - { success: true } or { error }
 */
function autoSeeding(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, policyDefinitions = _a.policyDefinitions, scaleAttributes = _a.scaleAttributes, scaleName = _a.scaleName, drawSize = _a.drawSize, drawId = _a.drawId, event = _a.event, stage = _a.stage, sortDescending = _a.sortDescending, scaleSortMethod = _a.scaleSortMethod;
    var result = getEntriesAndSeedsCount({
        policyDefinitions: policyDefinitions,
        drawDefinition: drawDefinition,
        drawSize: drawSize,
        drawId: drawId,
        event: event,
        stage: stage,
    });
    if (result.error)
        return result;
    var entries = result.entries, seedsCount = result.seedsCount, stageEntries = result.stageEntries;
    if (!stageEntries || !seedsCount)
        return { error: INVALID_VALUES };
    var scaledEntries = (_b = getScaledEntries({
        tournamentRecord: tournamentRecord,
        scaleAttributes: scaleAttributes,
        scaleSortMethod: scaleSortMethod,
        sortDescending: sortDescending,
        entries: entries,
        stage: stage,
    }).scaledEntries) !== null && _b !== void 0 ? _b : [];
    var scaleItemsWithParticipantIds = generateSeedingScaleItems({
        scaleAttributes: scaleAttributes,
        scaledEntries: scaledEntries,
        stageEntries: stageEntries,
        seedsCount: seedsCount,
        scaleName: scaleName,
    }).scaleItemsWithParticipantIds;
    return { scaleItemsWithParticipantIds: scaleItemsWithParticipantIds };
}

function modifyEvent(_a) {
    var _b, _c, _d, _e, _f;
    var tournamentRecord = _a.tournamentRecord, eventUpdates = _a.eventUpdates, eventId = _a.eventId, event = _a.event;
    var stack = 'modifyEvent';
    if (!tournamentRecord)
        return decorateResult({
            result: { error: MISSING_TOURNAMENT_RECORD },
            stack: stack,
        });
    if (!isString(eventId))
        return decorateResult({
            result: { error: MISSING_EVENT },
            context: { eventId: eventId },
            stack: stack,
        });
    if (!isObject(eventUpdates))
        return decorateResult({
            result: { error: INVALID_VALUES },
            context: { eventUpdates: eventUpdates },
            stack: stack,
        });
    var enteredParticipantIds = (_c = (_b = event === null || event === void 0 ? void 0 : event.entries) === null || _b === void 0 ? void 0 : _b.filter(function (_a) {
        var entryStatus = _a.entryStatus;
        var status = entryStatus;
        return __spreadArray(__spreadArray([], __read(STRUCTURE_SELECTED_STATUSES), false), [ALTERNATE], false).includes(status);
    }).map(function (_a) {
        var participantId = _a.participantId;
        return participantId;
    })) !== null && _c !== void 0 ? _c : [];
    var enteredParticipants = enteredParticipantIds
        ? (_d = getParticipants({
            participantFilters: { participantIds: enteredParticipantIds },
            withIndividualParticipants: true,
            tournamentRecord: tournamentRecord,
        }).participants) !== null && _d !== void 0 ? _d : []
        : [];
    var genderAccumulator = [];
    var enteredParticipantTypes = enteredParticipants.reduce(function (types, participant) {
        var _a, _b;
        var genders = ((_a = participant.person) === null || _a === void 0 ? void 0 : _a.sex)
            ? [participant.person.sex]
            : ((_b = participant.individualParticpants) === null || _b === void 0 ? void 0 : _b.map(function (p) { var _a; return (_a = p.person) === null || _a === void 0 ? void 0 : _a.sex; })) || [];
        genderAccumulator.push.apply(genderAccumulator, __spreadArray([], __read(genders), false));
        return !types.includes(participant.participantType)
            ? types.concat(participant.participantType)
            : types;
    }, []);
    var enteredParticipantGenders = unique(genderAccumulator);
    var validGender = !enteredParticipantGenders.length ||
        [MIXED, ANY].includes((_e = eventUpdates.gender) !== null && _e !== void 0 ? _e : '') ||
        (enteredParticipantGenders.length === 1 &&
            enteredParticipantGenders[0] === eventUpdates.gender);
    if (eventUpdates.gender && !validGender)
        return decorateResult({
            context: { gender: eventUpdates.gender, validGender: validGender },
            result: { error: INVALID_VALUES },
            stack: stack,
        });
    var validEventTypes = (enteredParticipantTypes.includes(TEAM$2) && [TEAM$2]) ||
        (enteredParticipantTypes.includes(INDIVIDUAL) && [SINGLES$1]) ||
        (enteredParticipantTypes.includes(PAIR) && [DOUBLES$1]) || [
        DOUBLES$1,
        SINGLES$1,
        TEAM$2,
    ];
    var validEventType = validEventTypes.includes((_f = eventUpdates.eventType) !== null && _f !== void 0 ? _f : '');
    if (eventUpdates.eventType && !validEventType)
        return decorateResult({
            context: { participantType: eventUpdates.eventType, validEventType: validEventType },
            result: { error: INVALID_VALUES },
            stack: stack,
        });
    if (eventUpdates.eventType)
        event.eventType = eventUpdates.eventType;
    if (eventUpdates.eventName)
        event.eventName = eventUpdates.eventName;
    if (eventUpdates.gender)
        event.gender = eventUpdates.gender;
    return __assign({}, SUCCESS);
}

function addFlight(_a) {
    var _b, _c, _d, _e;
    var qualifyingPositions = _a.qualifyingPositions, _f = _a.drawEntries, drawEntries = _f === void 0 ? [] : _f, // [{ entryPosition, entryStatus, participantId }]
    drawName = _a.drawName, drawId = _a.drawId, event = _a.event, stage = _a.stage;
    var stack = 'addFlight';
    if (!event)
        return decorateResult({ result: { error: MISSING_EVENT }, stack: stack });
    if (!drawName)
        return decorateResult({ result: { error: MISSING_VALUE }, stack: stack });
    if (drawEntries === null || drawEntries === void 0 ? void 0 : drawEntries.length) {
        // check that all drawEntries are in event.entries
        var enteredParticipantIds = ((_b = event.entries) !== null && _b !== void 0 ? _b : []).map(xa('participantId'));
        var flightParticipantIds = drawEntries.map(xa('participantId'));
        if (intersection(flightParticipantIds, enteredParticipantIds).length !== flightParticipantIds.length) {
            return decorateResult({ result: { error: INVALID_VALUES }, stack: stack });
        }
    }
    var flightProfile = (_c = getFlightProfile({ event: event })) === null || _c === void 0 ? void 0 : _c.flightProfile;
    var flightNumbers = ((_e = (_d = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _d === void 0 ? void 0 : _d.map(function (_a) {
        var flightNumber = _a.flightNumber;
        return !isNaN(flightNumber) && ensureInt(flightNumber);
    })) === null || _e === void 0 ? void 0 : _e.filter(Boolean)) || [];
    var flightNumber = Math.max.apply(Math, __spreadArray([0], __read(flightNumbers), false)) + 1;
    var flightDrawId = drawId || UUID();
    var flight = {
        drawId: flightDrawId,
        flightNumber: flightNumber,
        drawEntries: drawEntries,
        drawName: drawName,
    };
    if (stage)
        flight.stage = stage;
    if (qualifyingPositions)
        flight.qualifyingPositions = qualifyingPositions;
    var flightExists = ((flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) || []).find(function (_a) {
        var drawId = _a.drawId;
        return drawId === flight.drawId;
    });
    if (flightExists)
        return decorateResult({ result: { error: EXISTING_FLIGHT }, stack: stack });
    var flights = ((flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) || []).concat(flight);
    var extension = {
        name: FLIGHT_PROFILE,
        value: __assign(__assign({}, (flightProfile || {})), { flights: flights }),
    };
    return addEventExtension({ event: event, extension: extension });
}

var collectionDefinitions$j = [
	{
		collectionName: "Male Singles",
		matchUpFormat: "SET3-S:6/TB7",
		matchUpType: "SINGLES",
		matchUpCount: 4,
		matchUpValue: 1,
		gender: "MALE"
	},
	{
		collectionName: "Female Singles",
		matchUpFormat: "SET3-S:6/TB7",
		matchUpType: "SINGLES",
		gender: "FEMALE",
		matchUpCount: 4,
		matchUpValue: 1
	},
	{
		collectionName: "Male Doubles",
		matchUpFormat: "SET1-S:8/TB7@7",
		matchUpType: "DOUBLES",
		matchUpCount: 2,
		matchUpValue: 1,
		gender: "MALE"
	},
	{
		collectionName: "Female Doubles",
		matchUpFormat: "SET1-S:8/TB7@7",
		matchUpType: "DOUBLES",
		gender: "FEMALE",
		matchUpCount: 2,
		matchUpValue: 1
	},
	{
		collectionName: "Mixed Doubles",
		matchUpFormat: "SET1-S:8/TB7@7",
		matchUpType: "DOUBLES",
		matchUpCount: 4,
		matchUpValue: 1,
		gender: "MIXED"
	}
];
var tieFormatName$j = "USTA_GOLD_TEAM_CHALLENGE";
var winCriteria$j = {
	valueGoal: 9
};
var USTA_GOLD_TEAM_CHALLENGE$1 = {
	collectionDefinitions: collectionDefinitions$j,
	tieFormatName: tieFormatName$j,
	winCriteria: winCriteria$j
};

var collectionDefinitions$i = [
	{
		collectionName: "Round 1",
		matchUpCount: 3,
		matchUpFormat: "SET1-S:T20",
		matchUpType: "DOUBLES",
		scoreValue: 1
	},
	{
		collectionName: "Round 2",
		matchUpCount: 3,
		matchUpFormat: "SET1-S:T20",
		matchUpType: "DOUBLES",
		scoreValue: 1
	},
	{
		collectionName: "Round 3",
		matchUpCount: 3,
		matchUpFormat: "SET1-S:T20",
		matchUpType: "DOUBLES",
		scoreValue: 1
	}
];
var tieFormatName$i = "Doubles Shuffle";
var unrestrictedSelections = true;
var winCriteria$i = {
	aggregateValue: true
};
var TEAM_DOUBLES_3_AGGREGATION$1 = {
	collectionDefinitions: collectionDefinitions$i,
	tieFormatName: tieFormatName$i,
	unrestrictedSelections: unrestrictedSelections,
	winCriteria: winCriteria$i
};

var collectionDefinitions$h = [
	{
		collectionName: "Male Singles",
		gender: "MALE",
		matchUpCount: 6,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		collectionName: "Female Singles",
		gender: "FEMALE",
		matchUpCount: 6,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		collectionName: "Mixed Doubles",
		gender: "MIXED",
		matchUpCount: 3,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	}
];
var tieFormatName$h = "USTA_SOUTHERN_LEVEL_5";
var winCriteria$h = {
	valueGoal: 8
};
var USTA_SOUTHERN_LEVEL_5$1 = {
	collectionDefinitions: collectionDefinitions$h,
	tieFormatName: tieFormatName$h,
	winCriteria: winCriteria$h
};

var collectionDefinitions$g = [
	{
		category: {
			ageCategoryCode: "16U"
		},
		collectionName: "16U Singles",
		matchUpCount: 4,
		matchUpFormat: "SET3-S:6/TB7",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "18U"
		},
		collectionName: "18U Singles",
		matchUpCount: 4,
		matchUpFormat: "SET3-S:6/TB7",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "16U"
		},
		collectionName: "16U Doubles",
		matchUpCount: 2,
		matchUpFormat: "SET1-S:6/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "18U"
		},
		collectionName: "18U Doubles",
		matchUpCount: 2,
		matchUpFormat: "SET1-S:6/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	},
	{
		collectionName: "Tiebreak Doubles",
		matchUpCount: 1,
		matchUpFormat: "SET1-S:TB10",
		matchUpType: "DOUBLES",
		matchUpValue: 1,
		processCodes: [
			"RANKING.IGNORE"
		]
	}
];
var tieFormatName$g = "USTA_SECTION_BATTLE";
var winCriteria$g = {
	valueGoal: 9
};
var USTA_SECTION_BATTLE$1 = {
	collectionDefinitions: collectionDefinitions$g,
	tieFormatName: tieFormatName$g,
	winCriteria: winCriteria$g
};

var collectionDefinitions$f = [
	{
		collectionName: "Male Singles",
		gender: "MALE",
		matchUpCount: 6,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		collectionName: "Female Singles",
		gender: "FEMALE",
		matchUpCount: 6,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		collectionName: "Male Doubles",
		gender: "MALE",
		matchUpCount: 1,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	},
	{
		collectionName: "Female Doubles",
		gender: "FEMALE",
		matchUpCount: 1,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	},
	{
		collectionName: "Mixed Doubles",
		gender: "MIXED",
		matchUpCount: 1,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	}
];
var tieFormatName$f = "USTA_INTERSECTIONAL";
var winCriteria$f = {
	valueGoal: 8
};
var USTA_INTERSECTIONAL$1 = {
	collectionDefinitions: collectionDefinitions$f,
	tieFormatName: tieFormatName$f,
	winCriteria: winCriteria$f
};

var collectionDefinitions$e = [
	{
		scoreValue: 1,
		matchUpType: "SINGLES",
		collectionName: "Men's Singles",
		matchUpFormat: "SET1-S:T60",
		gender: "MALE",
		matchUpCount: 1
	},
	{
		scoreValue: 1,
		matchUpType: "SINGLES",
		collectionName: "Women's Singles",
		matchUpFormat: "SET1-S:T60",
		gender: "FEMALE",
		matchUpCount: 1
	},
	{
		matchUpValue: 1,
		matchUpType: "DOUBLES",
		collectionName: "Mixed Doubles",
		matchUpFormat: "SET1-S:T60",
		gender: "MIXED",
		matchUpCount: 1
	}
];
var tieFormatName$e = "Time Tennis Pro Circuit";
var winCriteria$e = {
	aggregateValue: true
};
var TIME_TENNIS_PRO_CIRCUIT$1 = {
	collectionDefinitions: collectionDefinitions$e,
	tieFormatName: tieFormatName$e,
	winCriteria: winCriteria$e
};

var collectionDefinitions$d = [
	{
		collectionName: "Mixed Doubles",
		gender: "MIXED",
		matchUpCount: 1,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	},
	{
		collectionName: "Male Singles",
		matchUpCount: 1,
		gender: "MALE",
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		collectionName: "Female Singles",
		gender: "FEMALE",
		matchUpCount: 1,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpType: "SINGLES",
		matchUpValue: 1
	}
];
var tieFormatName$d = "DOMINANT_DUO_MIXED";
var winCriteria$d = {
	valueGoal: 2
};
var DOMINANT_DUO_MIXED$1 = {
	collectionDefinitions: collectionDefinitions$d,
	tieFormatName: tieFormatName$d,
	winCriteria: winCriteria$d
};

var collectionDefinitions$c = [
	{
		scoreValue: 1,
		matchUpType: "SINGLES",
		collectionName: "Men's Singles",
		matchUpFormat: "SET1-S:T60",
		gender: "MALE",
		matchUpCount: 3
	},
	{
		scoreValue: 1,
		matchUpType: "SINGLES",
		collectionName: "Women's Singles",
		matchUpFormat: "SET1-S:T60",
		gender: "FEMALE",
		matchUpCount: 3
	},
	{
		scoreValue: 1,
		matchUpType: "DOUBLES",
		collectionName: "Men's Doubles",
		matchUpFormat: "SET1-S:T60",
		gender: "MALE",
		matchUpCount: 1
	},
	{
		matchUpValue: 1,
		matchUpType: "DOUBLES",
		collectionName: "Women's Doubles",
		matchUpFormat: "SET1-S:T60",
		gender: "FEMALE",
		matchUpCount: 1
	},
	{
		matchUpValue: 1,
		matchUpType: "DOUBLES",
		collectionName: "Mixed Doubles",
		matchUpFormat: "SET1-S:T60",
		gender: "MIXED",
		matchUpCount: 1
	}
];
var tieFormatName$c = "Time Tennis Dual";
var winCriteria$c = {
	aggregateValue: true
};
var TIME_TENNIS_DUAL$1 = {
	collectionDefinitions: collectionDefinitions$c,
	tieFormatName: tieFormatName$c,
	winCriteria: winCriteria$c
};

var collectionDefinitions$b = [
	{
		category: {
			ageCategoryCode: "14U"
		},
		collectionName: "14U Singles",
		matchUpCount: 2,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "16U"
		},
		collectionName: "16U Singles",
		matchUpCount: 2,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "18U"
		},
		collectionName: "18U Singles",
		matchUpCount: 2,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "14U"
		},
		collectionName: "14U Doubles",
		collectionGroupNumber: 1,
		matchUpCount: 1,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "16U"
		},
		collectionName: "16U Doubles",
		collectionGroupNumber: 1,
		matchUpCount: 1,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "18U"
		},
		collectionName: "18U Doubles",
		collectionGroupNumber: 1,
		matchUpCount: 1,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	}
];
var collectionGroups$1 = [
	{
		groupNumber: 1,
		groupName: "Doubles",
		groupValue: 1,
		winCriteria: {
			valueGoal: 2
		}
	}
];
var tieFormatName$b = "USTA_BREWER_CUP";
var winCriteria$b = {
	valueGoal: 4
};
var USTA_BREWER_CUP$1 = {
	collectionDefinitions: collectionDefinitions$b,
	collectionGroups: collectionGroups$1,
	tieFormatName: tieFormatName$b,
	winCriteria: winCriteria$b
};

var winCriteria$a = {
	valueGoal: 23
};
var tieFormatName$a = "USTA_OZAKI_CUP";
var collectionDefinitions$a = [
	{
		category: {
			ageCategoryCode: "18U"
		},
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		collectionName: "18U Boys Singles",
		matchUpType: "SINGLES",
		matchUpCount: 3,
		matchUpValue: 1,
		gender: "MALE"
	},
	{
		category: {
			ageCategoryCode: "18U"
		},
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		collectionName: "18U Girls Singles",
		matchUpType: "SINGLES",
		gender: "FEMALE",
		matchUpCount: 3,
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "18U"
		},
		collectionName: "18U Boys Doubles",
		matchUpFormat: "SET1-S:8/TB8",
		matchUpType: "DOUBLES",
		matchUpCount: 1,
		matchUpValue: 1,
		gender: "MALE"
	},
	{
		category: {
			ageCategoryCode: "18U"
		},
		collectionName: "18U Girls Doubles",
		matchUpFormat: "SET1-S:8/TB8",
		matchUpType: "DOUBLES",
		gender: "FEMALE",
		matchUpCount: 1,
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "18U"
		},
		collectionName: "18U Mixed Doubles",
		matchUpFormat: "SET1-S:8/TB8",
		matchUpType: "DOUBLES",
		gender: "MIXED",
		matchUpCount: 1,
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "16U"
		},
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		collectionName: "16U Boys Singles",
		matchUpType: "SINGLES",
		matchUpCount: 3,
		matchUpValue: 1,
		gender: "MALE"
	},
	{
		category: {
			ageCategoryCode: "16U"
		},
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		collectionName: "16U Girls Singles",
		matchUpType: "SINGLES",
		gender: "FEMALE",
		matchUpCount: 3,
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "16U"
		},
		collectionName: "16U Boys Doubles",
		matchUpFormat: "SET1-S:8/TB8",
		matchUpType: "DOUBLES",
		matchUpCount: 1,
		matchUpValue: 1,
		gender: "MALE"
	},
	{
		category: {
			ageCategoryCode: "16U"
		},
		collectionName: "16U Girls Doubles",
		matchUpFormat: "SET1-S:8/TB8",
		matchUpType: "DOUBLES",
		gender: "FEMALE",
		matchUpCount: 1,
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "16U"
		},
		collectionName: "16U Mixed Doubles",
		matchUpFormat: "SET1-S:8/TB8",
		matchUpType: "DOUBLES",
		gender: "MIXED",
		matchUpCount: 1,
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "14U"
		},
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		collectionName: "14U Boys Singles",
		matchUpType: "SINGLES",
		matchUpCount: 3,
		matchUpValue: 1,
		gender: "MALE"
	},
	{
		category: {
			ageCategoryCode: "14U"
		},
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		collectionName: "14U Girls Singles",
		matchUpType: "SINGLES",
		gender: "FEMALE",
		matchUpCount: 3,
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "14U"
		},
		collectionName: "14U Boys Doubles",
		matchUpFormat: "SET1-S:8/TB8",
		matchUpType: "DOUBLES",
		matchUpCount: 1,
		matchUpValue: 1,
		gender: "MALE"
	},
	{
		category: {
			ageCategoryCode: "14U"
		},
		collectionName: "14U Girls Doubles",
		matchUpFormat: "SET1-S:8/TB8",
		matchUpType: "DOUBLES",
		gender: "FEMALE",
		matchUpCount: 1,
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "14U"
		},
		collectionName: "14U Mixed Doubles",
		matchUpFormat: "SET1-S:8/TB8",
		matchUpType: "DOUBLES",
		gender: "MIXED",
		matchUpCount: 1,
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "12U"
		},
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		collectionName: "12U Boys Singles",
		matchUpType: "SINGLES",
		matchUpCount: 3,
		matchUpValue: 1,
		gender: "MALE"
	},
	{
		category: {
			ageCategoryCode: "12U"
		},
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		collectionName: "12U Girls Singles",
		matchUpType: "SINGLES",
		gender: "FEMALE",
		matchUpCount: 3,
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "12U"
		},
		collectionName: "12U Boys Doubles",
		matchUpFormat: "SET1-S:8/TB8",
		matchUpType: "DOUBLES",
		matchUpCount: 1,
		matchUpValue: 1,
		gender: "MALE"
	},
	{
		category: {
			ageCategoryCode: "12U"
		},
		collectionName: "12U Girls Doubles",
		matchUpFormat: "SET1-S:8/TB8",
		matchUpType: "DOUBLES",
		gender: "FEMALE",
		matchUpCount: 1,
		matchUpValue: 1
	},
	{
		category: {
			ageCategoryCode: "12U"
		},
		collectionName: "12U Mixed Doubles",
		matchUpFormat: "SET1-S:8/TB8",
		matchUpType: "DOUBLES",
		gender: "MIXED",
		matchUpCount: 1,
		matchUpValue: 1
	}
];
var USTA_OZAKI_CUP$1 = {
	winCriteria: winCriteria$a,
	tieFormatName: tieFormatName$a,
	collectionDefinitions: collectionDefinitions$a
};

var collectionDefinitions$9 = [
	{
		collectionName: "Doubles",
		matchUpCount: 1,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	},
	{
		collectionName: "Singles",
		matchUpCount: 2,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpType: "SINGLES",
		matchUpValue: 1
	}
];
var tieFormatName$9 = "DOMINANT_DUO";
var winCriteria$9 = {
	valueGoal: 2
};
var DOMINANT_DUO$1 = {
	collectionDefinitions: collectionDefinitions$9,
	tieFormatName: tieFormatName$9,
	winCriteria: winCriteria$9
};

var collectionDefinitions$8 = [
	{
		collectionName: "Doubles",
		matchUpCount: 3,
		matchUpFormat: "SET1-S:8/TB7@7",
		matchUpType: "DOUBLES",
		collectionValue: 1
	},
	{
		collectionName: "Singles",
		matchUpCount: 6,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpType: "SINGLES",
		matchUpValue: 1
	}
];
var tieFormatName$8 = "USTA_COLLEGE";
var winCriteria$8 = {
	valueGoal: 4
};
var USTA_COLLEGE$1 = {
	collectionDefinitions: collectionDefinitions$8,
	tieFormatName: tieFormatName$8,
	winCriteria: winCriteria$8
};

var collectionDefinitions$7 = [
	{
		collectionName: "Male Singles",
		matchUpCount: 6,
		matchUpFormat: "SET3-S:6/TB7",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		collectionName: "Female Singles",
		matchUpCount: 6,
		matchUpFormat: "SET3-S:6/TB7",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		collectionName: "Male Doubles",
		matchUpCount: 3,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	},
	{
		collectionName: "Female Doubles",
		matchUpCount: 3,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	}
];
var tieFormatName$7 = "USTA_LEVEL_1";
var winCriteria$7 = {
	valueGoal: 10
};
var USTA_LEVEL_1$1 = {
	collectionDefinitions: collectionDefinitions$7,
	tieFormatName: tieFormatName$7,
	winCriteria: winCriteria$7
};

var collectionDefinitions$6 = [
	{
		collectionName: "Female Doubles",
		gender: "FEMALE",
		matchUpCount: 1,
		matchUpFormat: "SET1-S:6/TB5NOAD@5",
		matchUpType: "DOUBLES",
		scoreValue: 1
	},
	{
		collectionName: "Male Doubles",
		gender: "MALE",
		matchUpCount: 1,
		matchUpFormat: "SET1-S:6/TB5NOAD@5",
		matchUpType: "DOUBLES",
		scoreValue: 1
	},
	{
		collectionName: "Female Singles",
		gender: "FEMALE",
		matchUpCount: 1,
		matchUpFormat: "SET1-S:6/TB5NOAD@5",
		matchUpType: "SINGLES",
		scoreValue: 1
	},
	{
		collectionName: "Male Singles",
		matchUpCount: 1,
		gender: "MALE",
		matchUpFormat: "SET1-S:6/TB5NOAD@5",
		matchUpType: "SINGLES",
		scoreValue: 1
	},
	{
		collectionName: "Mixed Doubles",
		matchUpCount: 1,
		gender: "MIXED",
		matchUpFormat: "SET1-S:6/TB5NOAD@5",
		matchUpType: "DOUBLES",
		scoreValue: 1
	},
	{
		collectionName: "Mixed Doubles",
		matchUpCount: 1,
		gender: "MIXED",
		matchUpFormat: "SET1-S:6/TB5NOAD@5",
		matchUpType: "DOUBLES",
		scoreValue: 1
	},
	{
		collectionName: "Overtime",
		matchUpCount: 1,
		gender: "MIXED",
		matchUpFormat: "SET1-S:T20",
		matchUpType: "DOUBLES",
		scoreValue: 1
	}
];
var tieFormatName$6 = "USTA_WTT_ITT";
var winCriteria$6 = {
	aggregateValue: true
};
var USTA_WTT_ITT$1 = {
	collectionDefinitions: collectionDefinitions$6,
	tieFormatName: tieFormatName$6,
	winCriteria: winCriteria$6
};

var collectionDefinitions$5 = [
	{
		collectionName: "Male Singles",
		gender: "MALE",
		matchUpCount: 6,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		collectionName: "Female Singles",
		gender: "FEMALE",
		matchUpCount: 6,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpType: "SINGLES",
		matchUpValue: 1
	},
	{
		collectionName: "Male Doubles",
		gender: "MALE",
		matchUpCount: 3,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	},
	{
		collectionName: "Female Doubles",
		gender: "FEMALE",
		matchUpCount: 3,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	},
	{
		collectionName: "Mixed Doubles",
		gender: "MIXED",
		matchUpCount: 1,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	}
];
var tieFormatName$5 = "USTA_ZONAL";
var winCriteria$5 = {
	valueGoal: 10
};
var USTA_ZONAL$1 = {
	collectionDefinitions: collectionDefinitions$5,
	tieFormatName: tieFormatName$5,
	winCriteria: winCriteria$5
};

var collectionDefinitions$4 = [
	{
		collectionGroupNumber: 1,
		matchUpType: "DOUBLES",
		matchUpCount: 1,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpValue: 1
	},
	{
		collectionGroupNumber: 1,
		matchUpType: "SINGLES",
		matchUpCount: 3,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpValue: 1
	},
	{
		collectionGroupNumber: 2,
		matchUpType: "DOUBLES",
		matchUpCount: 1,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpValue: 2
	},
	{
		collectionGroupNumber: 2,
		matchUpType: "SINGLES",
		matchUpCount: 3,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpValue: 2
	},
	{
		collectionGroupNumber: 3,
		matchUpType: "DOUBLES",
		matchUpCount: 1,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpValue: 3
	},
	{
		collectionGroupNumber: 3,
		matchUpType: "SINGLES",
		matchUpCount: 3,
		matchUpFormat: "SET3-S:6/TB7-F:TB10",
		matchUpValue: 3
	}
];
var collectionGroups = [
	{
		groupNumber: 1,
		groupName: "Day 1"
	},
	{
		groupNumber: 2,
		groupName: "Day 2"
	},
	{
		groupNumber: 3,
		groupName: "Day 3"
	}
];
var tieFormatName$4 = "LAVER_CUP";
var winCriteria$4 = {
	valueGoal: 13
};
var LAVER_CUP$1 = {
	collectionDefinitions: collectionDefinitions$4,
	collectionGroups: collectionGroups,
	tieFormatName: tieFormatName$4,
	winCriteria: winCriteria$4
};

var collectionDefinitions$3 = [
	{
		collectionName: "Female Doubles",
		gender: "FEMALE",
		matchUpCount: 1,
		matchUpFormat: "SET1-S:6/TB5NOAD@5",
		matchUpType: "DOUBLES",
		scoreValue: 1
	},
	{
		collectionName: "Male Doubles",
		gender: "MALE",
		matchUpCount: 1,
		matchUpFormat: "SET1-S:6/TB5NOAD@5",
		matchUpType: "DOUBLES",
		scoreValue: 1
	},
	{
		collectionName: "Female Singles",
		gender: "FEMALE",
		matchUpCount: 1,
		matchUpFormat: "SET1-S:6/TB5NOAD@5",
		matchUpType: "SINGLES",
		scoreValue: 1
	},
	{
		collectionName: "Male Singles",
		matchUpCount: 1,
		gender: "MALE",
		matchUpFormat: "SET1-S:6/TB5NOAD@5",
		matchUpType: "SINGLES",
		scoreValue: 1
	},
	{
		collectionName: "Mixed Doubles",
		matchUpCount: 1,
		gender: "MIXED",
		matchUpFormat: "SET1-S:6/TB5NOAD@5",
		matchUpType: "DOUBLES",
		scoreValue: 1
	},
	{
		collectionName: "Overtime",
		matchUpCount: 1,
		gender: "MIXED",
		matchUpFormat: "SET1-S:T20",
		matchUpType: "DOUBLES",
		scoreValue: 1
	}
];
var tieFormatName$3 = "USTA_TOC";
var winCriteria$3 = {
	aggregateValue: true
};
var USTA_TOC$1 = {
	collectionDefinitions: collectionDefinitions$3,
	tieFormatName: tieFormatName$3,
	winCriteria: winCriteria$3
};

var COLLEGE_DEFAULT$1 = 'COLLEGE_DEFAULT';
var COLLEGE_JUCO$1 = 'COLLEGE_JUCO';
var COLLEGE_D3$1 = 'COLLEGE_D3';
var DOMINANT_DUO = 'DOMINANT_DUO';
var DOMINANT_DUO_MIXED = 'DOMINANT_DUO_MIXED';
var LAVER_CUP = 'LAVER_CUP';
var TEAM_DOUBLES_3_AGGREGATION = 'TEAM_DOUBLES_3_AGGREGATION';
var TIME_TENNIS_DUAL = 'TIME_TENNIS_DUAL';
var TIME_TENNIS_PRO_CIRCUIT = 'TIME_TENNIS_PRO_CIRCUIT';
var USTA_BREWER_CUP = 'USTA_BREWER_CUP';
var USTA_OZAKI_CUP = 'USTA_OZAKI_CUP';
var USTA_COLLEGE = 'USTA_COLLEGE';
var USTA_GOLD_TEAM_CHALLENGE = 'USTA_GOLD_TEAM_CHALLENGE';
var USTA_LEVEL_1 = 'USTA_LEVEL_1';
var USTA_INTERSECTIONAL = 'USTA_INTERSECTIONAL';
var USTA_SECTION_BATTLE = 'USTA_SECTION_BATTLE';
var USTA_SOUTHERN_LEVEL_5 = 'USTA_SOUTHERN_LEVEL_5';
var USTA_TOC = 'USTA_TOC';
var USTA_WTT_ITT = 'USTA_WTT_ITT';
var USTA_ZONAL = 'USTA_ZONAL';
var tieFormatConstants = {
    COLLEGE_D3: COLLEGE_D3$1,
    COLLEGE_DEFAULT: COLLEGE_DEFAULT$1,
    COLLEGE_JUCO: COLLEGE_JUCO$1,
    DOMINANT_DUO: DOMINANT_DUO,
    DOMINANT_DUO_MIXED: DOMINANT_DUO_MIXED,
    LAVER_CUP: LAVER_CUP,
    TEAM_DOUBLES_3_AGGREGATION: TEAM_DOUBLES_3_AGGREGATION,
    TIME_TENNIS_DUAL: TIME_TENNIS_DUAL,
    TIME_TENNIS_PRO_CIRCUIT: TIME_TENNIS_PRO_CIRCUIT,
    USTA_BREWER_CUP: USTA_BREWER_CUP,
    USTA_OZAKI_CUP: USTA_OZAKI_CUP,
    USTA_COLLEGE: USTA_COLLEGE,
    USTA_GOLD_TEAM_CHALLENGE: USTA_GOLD_TEAM_CHALLENGE,
    USTA_INTERSECTIONAL: USTA_INTERSECTIONAL,
    USTA_LEVEL_1: USTA_LEVEL_1,
    USTA_SECTION_BATTLE: USTA_SECTION_BATTLE,
    USTA_SOUTHERN_LEVEL_5: USTA_SOUTHERN_LEVEL_5,
    USTA_TOC: USTA_TOC,
    USTA_WTT_ITT: USTA_WTT_ITT,
    USTA_ZONAL: USTA_ZONAL,
};

var _a$d;
var STANDARD = 'STANDARD';
var namedFormats = (_a$d = {},
    _a$d[STANDARD] = {
        hydrate: true,
        doubles: { matchUpCount: 3, matchUpValue: 1 },
        singles: { matchUpCount: 6, matchUpValue: 1 },
        valueGoal: 5,
    },
    _a$d[COLLEGE_D3$1] = {
        hydrate: true,
        doubles: {
            matchUpCount: 3,
            matchUpValue: 1,
            matchUpFormat: 'SET1-S:8/TB7@7',
        },
        singles: {
            matchUpFormat: FORMAT_STANDARD,
            matchUpCount: 6,
            matchUpValue: 1,
        },
        tieFormatName: COLLEGE_D3$1,
        valueGoal: 5,
    },
    _a$d[COLLEGE_DEFAULT$1] = {
        hydrate: true,
        doubles: {
            matchUpCount: 3,
            collectionValue: 1,
            matchUpFormat: FORMAT_STANDARD,
        },
        singles: {
            matchUpCount: 6,
            matchUpValue: 1,
            matchUpFormat: FORMAT_STANDARD,
        },
        tieFormatName: COLLEGE_DEFAULT$1,
        valueGoal: 4,
    },
    _a$d[COLLEGE_JUCO$1] = {
        hydrate: true,
        doubles: {
            matchUpCount: 3,
            matchUpValue: 1,
            matchUpFormat: 'SET1-S:8/TB7',
        },
        singles: {
            matchUpCount: 6,
            matchUpValue: 1,
            matchUpFormat: FORMAT_STANDARD,
        },
        tieFormatName: COLLEGE_JUCO$1,
        valueGoal: 5,
    },
    _a$d[LAVER_CUP] = LAVER_CUP$1,
    _a$d[DOMINANT_DUO] = DOMINANT_DUO$1,
    _a$d[DOMINANT_DUO_MIXED] = DOMINANT_DUO_MIXED$1,
    _a$d[TEAM_DOUBLES_3_AGGREGATION] = TEAM_DOUBLES_3_AGGREGATION$1,
    _a$d[TIME_TENNIS_DUAL] = TIME_TENNIS_DUAL$1,
    _a$d[TIME_TENNIS_PRO_CIRCUIT] = TIME_TENNIS_PRO_CIRCUIT$1,
    _a$d[USTA_BREWER_CUP] = USTA_BREWER_CUP$1,
    _a$d[USTA_OZAKI_CUP] = USTA_OZAKI_CUP$1,
    _a$d[USTA_COLLEGE] = USTA_COLLEGE$1,
    _a$d[USTA_GOLD_TEAM_CHALLENGE] = USTA_GOLD_TEAM_CHALLENGE$1,
    _a$d[USTA_INTERSECTIONAL] = USTA_INTERSECTIONAL$1,
    _a$d[USTA_LEVEL_1] = USTA_LEVEL_1$1,
    _a$d[USTA_SECTION_BATTLE] = USTA_SECTION_BATTLE$1,
    _a$d[USTA_SOUTHERN_LEVEL_5] = USTA_SOUTHERN_LEVEL_5$1,
    _a$d[USTA_WTT_ITT] = USTA_WTT_ITT$1,
    _a$d[USTA_TOC] = USTA_TOC$1,
    _a$d[USTA_ZONAL] = USTA_ZONAL$1,
    _a$d);
var tieFormatDefaults = function (params) {
    var _a;
    var namedFormat = (params === null || params === void 0 ? void 0 : params.namedFormat) && Object.keys(namedFormats).includes(params.namedFormat) ? params.namedFormat : STANDARD;
    var uuids = Array.isArray(params === null || params === void 0 ? void 0 : params.uuids) ? params === null || params === void 0 ? void 0 : params.uuids : [];
    var tieFormat;
    var _b = (_a = params === null || params === void 0 ? void 0 : params.event) !== null && _a !== void 0 ? _a : {}, category = _b.category, gender = _b.gender;
    var template = makeDeepCopy(namedFormats[namedFormat], false, true);
    var getCollectionId = function (index) {
        var _a, _b, _c, _d;
        if ((!(params === null || params === void 0 ? void 0 : params.isMock) && !((_a = params === null || params === void 0 ? void 0 : params.event) === null || _a === void 0 ? void 0 : _a.isMock)) || !params.event)
            return (_b = uuids === null || uuids === void 0 ? void 0 : uuids.pop()) !== null && _b !== void 0 ? _b : UUID();
        var eventId = (_c = params === null || params === void 0 ? void 0 : params.event) === null || _c === void 0 ? void 0 : _c.eventId;
        return (_d = uuids.pop()) !== null && _d !== void 0 ? _d : "".concat(eventId, "-COL-").concat(index + 1);
    };
    if (!template.hydrate) {
        template.collectionDefinitions.forEach(function (collectionDefinition, i) { return (collectionDefinition.collectionId = getCollectionId(i)); });
        tieFormat = template;
    }
    else {
        tieFormat = {
            winCriteria: {
                valueGoal: template.valueGoal,
            },
            collectionDefinitions: [
                __assign({ collectionId: getCollectionId(0), matchUpFormat: FORMAT_ATP_DOUBLES, collectionName: 'Doubles', matchUpType: DOUBLES }, template.doubles),
                __assign({ collectionId: getCollectionId(1), matchUpFormat: FORMAT_STANDARD, collectionName: 'Singles', matchUpType: SINGLES }, template.singles),
            ],
        };
        if (template.tieFormatName)
            tieFormat.tieFormatName = template.tieFormatName;
    }
    if (params === null || params === void 0 ? void 0 : params.hydrateCollections) {
        tieFormat.collectionDefinitions.forEach(function (collectionDefinition) {
            if (category && !collectionDefinition.category)
                collectionDefinition.category = category;
            if (gender && !collectionDefinition.gender)
                collectionDefinition.gender = gender;
        });
    }
    return tieFormat;
};

var collectionDefinitions$2 = [
	{
		collectionName: "Doubles",
		matchUpCount: 3,
		matchUpFormat: "SET1-S:8/TB7@7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	},
	{
		collectionName: "Singles",
		matchUpCount: 6,
		matchUpFormat: "SET3-S:6/TB7",
		matchUpType: "SINGLES",
		matchUpValue: 1
	}
];
var tieFormatName$2 = "COLLEGE_D3";
var winCriteria$2 = {
	valueGoal: 5
};
var COLLEGE_D3 = {
	collectionDefinitions: collectionDefinitions$2,
	tieFormatName: tieFormatName$2,
	winCriteria: winCriteria$2
};

var collectionDefinitions$1 = [
	{
		collectionName: "Doubles",
		collectionValue: 1,
		matchUpCount: 3,
		matchUpFormat: "SET1-S:6/TB7",
		matchUpType: "DOUBLES"
	},
	{
		collectionName: "Singles",
		matchUpCount: 6,
		matchUpFormat: "SET3-S:6/TB7",
		matchUpType: "SINGLES",
		matchUpValue: 1
	}
];
var tieFormatName$1 = "COLLEGE_DEFAULT";
var winCriteria$1 = {
	valueGoal: 5
};
var COLLEGE_DEFAULT = {
	collectionDefinitions: collectionDefinitions$1,
	tieFormatName: tieFormatName$1,
	winCriteria: winCriteria$1
};

var collectionDefinitions = [
	{
		collectionName: "Doubles",
		matchUpCount: 3,
		matchUpFormat: "SET1-S:8/TB7",
		matchUpType: "DOUBLES",
		matchUpValue: 1
	},
	{
		collectionName: "Singles",
		matchUpCount: 6,
		matchUpFormat: "SET3-S:6/TB7",
		matchUpType: "SINGLES",
		matchUpValue: 1
	}
];
var tieFormatName = "COLLEGE_JUCO";
var winCriteria = {
	valueGoal: 5
};
var COLLEGE_JUCO = {
	collectionDefinitions: collectionDefinitions,
	tieFormatName: tieFormatName,
	winCriteria: winCriteria
};

var tieFormats = {
    COLLEGE_D3: COLLEGE_D3,
    COLLEGE_DEFAULT: COLLEGE_DEFAULT,
    COLLEGE_JUCO: COLLEGE_JUCO,
    DOMINANT_DUO: DOMINANT_DUO$1,
    DOMINANT_DUO_MIXED: DOMINANT_DUO_MIXED$1,
    LAVER_CUP: LAVER_CUP$1,
    TEAM_DOUBLES_3_AGGREGATION: TEAM_DOUBLES_3_AGGREGATION$1,
    TIME_TENNIS_DUAL: TIME_TENNIS_DUAL$1,
    TIME_TENNIS_PRO_CIRCUIT: TIME_TENNIS_PRO_CIRCUIT$1,
    USTA_BREWER_CUP: USTA_BREWER_CUP$1,
    USTA_OZAKI_CUP: USTA_OZAKI_CUP$1,
    USTA_COLLEGE: USTA_COLLEGE$1,
    USTA_GOLD_TEAM_CHALLENGE: USTA_GOLD_TEAM_CHALLENGE$1,
    USTA_INTERSECTIONAL: USTA_INTERSECTIONAL$1,
    USTA_LEVEL_1: USTA_LEVEL_1$1,
    USTA_SECTION_BATTLE: USTA_SECTION_BATTLE$1,
    USTA_SOUTHERN_LEVEL_5: USTA_SOUTHERN_LEVEL_5$1,
    USTA_TOC: USTA_TOC$1,
    USTA_WTT_ITT: USTA_WTT_ITT$1,
    USTA_ZONAL: USTA_ZONAL$1,
};

function addEvent(_a) {
    var e_1, _b;
    var _c, _d, _e, _f, _g;
    var suppressNotifications = _a.suppressNotifications, tournamentRecord = _a.tournamentRecord, internalUse = _a.internalUse, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!tournamentRecord.events)
        tournamentRecord.events = [];
    if (!event)
        return { error: MISSING_EVENT };
    // set default startDate, endDate based on tournamentRecord
    var startDate = tournamentRecord.startDate, endDate = tournamentRecord.endDate;
    // if not internal use disallow passing entries and drawDefinitions
    if (!internalUse && (((_c = event.entries) === null || _c === void 0 ? void 0 : _c.length) || ((_d = event.drawDefinitions) === null || _d === void 0 ? void 0 : _d.length))) {
        var context = definedAttributes({
            drawDefinitions: !!((_e = event.drawDefinitions) === null || _e === void 0 ? void 0 : _e.length),
            entries: !!((_f = event.entries) === null || _f === void 0 ? void 0 : _f.length),
        });
        return {
            info: 'entries/drawDefinitions cannot exist',
            error: INVALID_VALUES,
            context: context,
        };
    }
    var eventRecord = __assign({ eventType: SINGLES_EVENT, drawDefinitions: [], entries: [], startDate: startDate, endDate: endDate }, event);
    if (event.eventType === TEAM_EVENT) {
        if (event.tieFormat) {
            var result = validateTieFormat({ tieFormat: event.tieFormat });
            if (result.error)
                return result;
        }
        else if (event.tieFormatName) {
            if (!tieFormats[event.tieFormatName]) {
                return {
                    context: { tieFormatName: event.tieFormatName },
                    error: INVALID_VALUES,
                };
            }
            var tieFormat = tieFormatDefaults({
                isMock: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.isMock,
                namedFormat: event.tieFormatName,
                event: event,
            });
            eventRecord.tieFormat = tieFormat;
        }
    }
    if (!eventRecord.eventId)
        eventRecord.eventId = UUID();
    var eventExists = tournamentRecord.events.reduce(function (exists, event) {
        return exists || event.eventId === eventRecord.eventId;
    }, undefined);
    if (!eventExists) {
        var newEvent = eventRecord;
        tournamentRecord.events.push(newEvent);
        if (!suppressNotifications) {
            var topics = getTopics().topics;
            if (topics.includes(ADD_MATCHUPS)) {
                var matchUps = (_g = allEventMatchUps({ event: event }).matchUps) !== null && _g !== void 0 ? _g : [];
                addMatchUpsNotice({
                    tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                    eventId: event.eventId,
                    matchUps: matchUps,
                });
            }
            try {
                for (var _h = __values(event.drawDefinitions || []), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var drawDefinition = _j.value;
                    addDrawNotice({ drawDefinition: drawDefinition });
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return __assign(__assign({}, SUCCESS), { event: eventRecord });
    }
    else {
        return { error: EVENT_EXISTS };
    }
}

function promoteAlternate(params) {
    var participantId = params.participantId;
    if (participantId && typeof participantId !== 'string')
        return { error: INVALID_VALUES, participantId: participantId };
    return promoteAlternates(__assign(__assign({}, params), { participantIds: [participantId].filter(Boolean) }));
}
function promoteAlternates(_a) {
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, participantIds = _a.participantIds, stageSequence = _a.stageSequence, _b = _a.stage, stage = _b === void 0 ? MAIN : _b, eventId = _a.eventId, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!Array.isArray(participantIds))
        return { error: INVALID_VALUES, participantIds: participantIds };
    if (!event)
        return { error: MISSING_EVENT };
    var stack = 'promoteAlternates';
    if (event) {
        var result = promoteWithinElement({
            element: event,
            participantIds: participantIds,
            stageSequence: stageSequence,
            stage: stage,
        });
        if (result.error)
            return result;
    }
    if (drawDefinition) {
        var result = promoteWithinElement({
            element: drawDefinition,
            participantIds: participantIds,
            stageSequence: stageSequence,
            stage: stage,
        });
        if (result.error) {
            if (eventId) {
                // if successful promoting within the event do not fail if not found in drawDefinition.entries
                // the reasoning here is that with split draws alternates may or may not appear in drawDefinition.entries
                return decorateResult({
                    context: {
                        drawPromotionError: result.error,
                        drawId: drawDefinition.drawId,
                    },
                    result: __assign({}, SUCCESS),
                    stack: stack,
                });
            }
            else {
                return result;
            }
        }
    }
    return __assign({}, SUCCESS);
}
function promoteWithinElement(_a) {
    var e_1, _b;
    var participantIds = _a.participantIds, stageSequence = _a.stageSequence, element = _a.element, stage = _a.stage;
    var alternates = (element.entries || []).filter(function (entry) { return entry.entryStatus === ALTERNATE; });
    var targetedEntries = (element.entries || []).filter(function (entry) {
        return participantIds.includes(entry.participantId);
    });
    // if no participantId is provided, take the alternate with the lowest entryPosition
    var alternateEntry = alternates.reduce(function (participantEntry, entry) {
        var entryPosition = entry.entryPosition;
        return ((isNaN(entryPosition) && participantEntry) ||
            ((!participantEntry || entryPosition < participantEntry.entryPosition) &&
                entry) ||
            participantEntry);
    }, undefined);
    var participantEntries = targetedEntries.length
        ? targetedEntries
        : [alternateEntry].filter(Boolean);
    if (!(participantEntries === null || participantEntries === void 0 ? void 0 : participantEntries.length))
        return { error: PARTICIPANT_ENTRY_NOT_FOUND };
    var invalidEntryStatus = participantEntries.filter(function (_a) {
        var entryStatus = _a.entryStatus;
        return entryStatus !== ALTERNATE;
    });
    if (invalidEntryStatus.length)
        return { error: INVALID_ENTRY_STATUS, invalidEntryStatus: invalidEntryStatus };
    var invalidStage = participantEntries.filter(function (_a) {
        var entryStage = _a.entryStage;
        return entryStage && entryStage !== stage;
    });
    if (invalidStage.length)
        return { error: PARTICIPANT_NOT_ENTERED_IN_STAGE, invalidStage: invalidStage };
    var invalidStageSequence = stageSequence &&
        participantEntries.filter(function (entry) { return entry.stageSequence !== stageSequence; });
    if (invalidStageSequence === null || invalidStageSequence === void 0 ? void 0 : invalidStageSequence.length)
        return { error: PARTICIPANT_NOT_FOUND_IN_STAGE, invalidStageSequence: invalidStageSequence };
    var _loop_1 = function (participantEntry) {
        participantEntry.entryStatus = DIRECT_ACCEPTANCE;
        // cleanUp
        var entryPosition = participantEntry === null || participantEntry === void 0 ? void 0 : participantEntry.entryPosition;
        if (!isNaN(entryPosition)) {
            // if promoted participant has an entryPosition, adjust all other alternates with an entryPosition higher than promoted participant
            element.entries.forEach(function (entry) {
                if (entry.entryStatus === ALTERNATE &&
                    entry.entryPosition > entryPosition) {
                    entry.entryPosition = entry.entryPosition - 1;
                }
            });
        }
        var maxEntryPosition = Math.max.apply(Math, __spreadArray(__spreadArray([], __read(element.entries
            .filter(function (entry) {
            return entry.entryStatus === DIRECT_ACCEPTANCE &&
                !isNaN(entry.entryPosition);
        })
            .map(function (_a) {
            var entryPosition = _a.entryPosition;
            return ensureInt(entryPosition || 0);
        })), false), [0], false));
        participantEntry.entryPosition = maxEntryPosition || 0;
    };
    try {
        for (var participantEntries_1 = __values(participantEntries), participantEntries_1_1 = participantEntries_1.next(); !participantEntries_1_1.done; participantEntries_1_1 = participantEntries_1.next()) {
            var participantEntry = participantEntries_1_1.value;
            _loop_1(participantEntry);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (participantEntries_1_1 && !participantEntries_1_1.done && (_b = participantEntries_1.return)) _b.call(participantEntries_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}

function setEntryPosition(_a) {
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, participantId = _a.participantId, entryPosition = _a.entryPosition, skipRefresh = _a.skipRefresh, event = _a.event;
    var stack = 'setEntryPositions';
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!participantId)
        return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack: stack });
    if (entryPosition !== undefined && !Number.isSafeInteger(entryPosition))
        return { error: INVALID_VALUES, entryPosition: entryPosition };
    ((event === null || event === void 0 ? void 0 : event.entries) || []).forEach(function (entry) {
        if (entry.participantId === participantId) {
            entry.entryPosition = entryPosition;
        }
    });
    ((drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) || []).forEach(function (entry) {
        if (entry.participantId === participantId) {
            entry.entryPosition = entryPosition;
        }
    });
    // if there are other entries with equivalent entryPosition, incremnt to differentiate
    // decimal values will be replaced with whole numbers by refreshEntryPositions()
    var differentiateDuplicates = function (obj) {
        obj.entries.forEach(function (entry) {
            if (entry.entryPosition === entryPosition &&
                entry.participantId !== participantId) {
                entry.entryPosition += 0.1;
            }
        });
    };
    if (!skipRefresh) {
        if (event === null || event === void 0 ? void 0 : event.entries) {
            differentiateDuplicates(event);
            event.entries = refreshEntryPositions({ entries: event.entries });
        }
        if (drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) {
            differentiateDuplicates(drawDefinition);
            drawDefinition.entries = refreshEntryPositions({
                entries: drawDefinition.entries,
            });
        }
    }
    return __assign({}, SUCCESS);
}
function setEntryPositions(_a) {
    var e_1, _b;
    var tournamentRecord = _a.tournamentRecord, entryPositions = _a.entryPositions, drawDefinition = _a.drawDefinition, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!Array.isArray(entryPositions))
        return { error: INVALID_VALUES };
    try {
        for (var entryPositions_1 = __values(entryPositions), entryPositions_1_1 = entryPositions_1.next(); !entryPositions_1_1.done; entryPositions_1_1 = entryPositions_1.next()) {
            var positioning = entryPositions_1_1.value;
            var participantId = positioning.participantId, entryPosition = positioning.entryPosition;
            var result = setEntryPosition({
                skipRefresh: true, // avoid redundant processing
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                participantId: participantId,
                entryPosition: entryPosition,
                event: event,
            });
            if (result.error)
                return result;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (entryPositions_1_1 && !entryPositions_1_1.done && (_b = entryPositions_1.return)) _b.call(entryPositions_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (event === null || event === void 0 ? void 0 : event.entries) {
        event.entries = refreshEntryPositions({ entries: event.entries });
    }
    if (drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) {
        drawDefinition.entries = refreshEntryPositions({
            entries: drawDefinition.entries,
        });
    }
    return __assign({}, SUCCESS);
}

function setEventStartDate(_a) {
    var tournamentRecord = _a.tournamentRecord, event = _a.event, startDate = _a.startDate;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    if (!dateValidation.test(startDate))
        return { error: INVALID_DATE };
    var result = getTournamentDates(tournamentRecord);
    if (result.error)
        return result;
    var tournamentStartDate = result.tournamentStartDate, tournamentEndDate = result.tournamentEndDate;
    // use extractDate() to ensure that only the YYYY-MM-DD part of date is used for comparison
    var newEventStartDate = new Date(extractDate(startDate)).getTime();
    if (!tournamentStartDate ||
        !tournamentEndDate ||
        newEventStartDate < tournamentStartDate ||
        newEventStartDate > tournamentEndDate)
        return { error: INVALID_DATE };
    // use extractDate() to ensure that only the YYYY-MM-DD part of date is used for comparison
    var eventEndDate = event.endDate && new Date(extractDate(event.endDate)).getTime();
    if (eventEndDate && newEventStartDate > eventEndDate) {
        // if the new startDate is after an existing endDate set the endDate to the startDate
        event.endDate = startDate;
    }
    event.startDate = startDate;
    return __assign({}, SUCCESS);
}
function setEventEndDate(_a) {
    var tournamentRecord = _a.tournamentRecord, event = _a.event, endDate = _a.endDate;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    if (!dateValidation.test(endDate))
        return { error: INVALID_DATE };
    var result = getTournamentDates(tournamentRecord);
    if (result.error)
        return result;
    var tournamentStartDate = result.tournamentStartDate, tournamentEndDate = result.tournamentEndDate;
    // use extractDate() to ensure that only the YYYY-MM-DD part of date is used for comparison
    var newEventEndDate = new Date(extractDate(endDate)).getTime();
    if (!tournamentStartDate ||
        !tournamentEndDate ||
        newEventEndDate < tournamentStartDate ||
        newEventEndDate > tournamentEndDate)
        return { error: INVALID_DATE };
    // use extractDate() to ensure that only the YYYY-MM-DD part of date is used for comparison
    var eventStartDate = event.startDate && new Date(extractDate(event.startDate)).getTime();
    if (eventStartDate && newEventEndDate < eventStartDate) {
        // if the new endDate is before an existing startDate set the startDate to the endDate
        event.startDate = endDate;
    }
    event.endDate = endDate;
    return __assign({}, SUCCESS);
}
function setEventDates(_a) {
    var tournamentRecord = _a.tournamentRecord, event = _a.event, startDate = _a.startDate, endDate = _a.endDate;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    if (!startDate && !endDate)
        return { error: MISSING_VALUE, info: 'missing date' };
    if (startDate && !dateValidation.test(startDate))
        return { error: INVALID_DATE };
    if (endDate && !dateValidation.test(endDate))
        return { error: INVALID_DATE };
    if (startDate && endDate) {
        var newStartDate = new Date(extractDate(startDate)).getTime();
        var newEndDate = new Date(extractDate(endDate)).getTime();
        if (newStartDate > newEndDate)
            return { error: INVALID_VALUES };
    }
    if (startDate) {
        var result = setEventStartDate({ tournamentRecord: tournamentRecord, event: event, startDate: startDate });
        if (result.error)
            return result;
    }
    if (endDate) {
        var result = setEventEndDate({ tournamentRecord: tournamentRecord, event: event, endDate: endDate });
        if (result.error)
            return result;
    }
    return __assign({}, SUCCESS);
}
function getTournamentDates(tournamentRecord) {
    var startDate = tournamentRecord.startDate, endDate = tournamentRecord.endDate;
    if (!dateValidation.test(startDate) || !dateValidation.test(endDate)) {
        return decorateResult({
            result: { error: INVALID_TOURNAMENT_DATES },
            context: { startDate: startDate, endDate: endDate },
        });
    }
    // use extractDate() to ensure that only the YYYY-MM-DD part of date is used for comparison
    return {
        tournamentStartDate: new Date(extractDate(startDate)).getTime(),
        tournamentEndDate: new Date(extractDate(endDate)).getTime(),
    };
}

var eventGovernor = {
    addAdHocMatchUps: addAdHocMatchUps,
    addCollectionDefinition: addCollectionDefinition,
    addCollectionGroup: addCollectionGroup,
    addDrawDefinition: addDrawDefinition,
    addDrawDefinitionTimeItem: addDrawDefinitionTimeItem,
    addDrawEntries: addDrawEntries,
    addEvent: addEvent,
    addEventEntries: addEventEntries,
    addEventEntryPairs: addEventEntryPairs,
    addFlight: addFlight,
    addPlayoffStructures: addPlayoffStructures,
    addQualifyingStructure: addQualifyingStructure,
    addVoluntaryConsolationStage: addVoluntaryConsolationStage,
    addVoluntaryConsolationStructure: addVoluntaryConsolationStructure,
    aggregateTieFormats: aggregateTieFormats,
    alternateDrawPositionAssignment: alternateDrawPositionAssignment,
    applyLineUps: applyLineUps,
    assignDrawPosition: assignDrawPosition,
    assignDrawPositionBye: assignDrawPositionBye,
    assignMatchUpSideParticipant: assignMatchUpSideParticipant,
    assignSeedPositions: assignSeedPositions,
    assignTieMatchUpParticipantId: assignTieMatchUpParticipantId,
    attachConsolationStructures: attachConsolationStructures,
    attachFlightProfile: attachFlightProfile,
    attachPlayoffStructures: attachPlayoffStructures,
    attachQualifyingStructure: attachQualifyingStructure,
    attachStructures: attachStructures,
    automatedPlayoffPositioning: automatedPlayoffPositioning,
    automatedPositioning: automatedPositioning,
    autoSeeding: autoSeeding,
    bulkMatchUpStatusUpdate: bulkMatchUpStatusUpdate,
    checkInParticipant: checkInParticipant,
    checkOutParticipant: checkOutParticipant,
    deleteAdHocMatchUps: deleteAdHocMatchUps,
    deleteDrawDefinitions: deleteDrawDefinitions,
    deleteEvents: deleteEvents,
    deleteFlightAndFlightDraw: deleteFlightAndFlightDraw,
    deleteFlightProfileAndFlightDraws: deleteFlightProfileAndFlightDraws,
    destroyPairEntries: destroyPairEntries,
    destroyPairEntry: destroyPairEntry,
    disableTieAutoCalc: disableTieAutoCalc,
    drawMatic: drawMatic,
    enableTieAutoCalc: enableTieAutoCalc,
    getAvailablePlayoffProfiles: getAvailablePlayoffProfiles,
    getAvailablePlayoffRounds: getAvailablePlayoffProfiles, // to be deprecated
    luckyLoserDrawPositionAssignment: luckyLoserDrawPositionAssignment,
    modifyCollectionDefinition: modifyCollectionDefinition,
    modifyDrawDefinition: modifyDrawDefinition,
    modifyDrawName: modifyDrawName,
    modifyEntriesStatus: modifyEntriesStatus,
    modifyEvent: modifyEvent,
    modifyEventEntries: modifyEventEntries,
    modifyPairAssignment: modifyPairAssignment,
    modifySeedAssignment: modifySeedAssignment,
    modifyTieFormat: modifyTieFormat,
    orderCollectionDefinitions: orderCollectionDefinitions,
    promoteAlternate: promoteAlternate,
    promoteAlternates: promoteAlternates,
    pruneDrawDefinition: pruneDrawDefinition,
    qualifierDrawPositionAssignment: qualifierDrawPositionAssignment,
    refreshEventDrawOrder: refreshEventDrawOrder,
    removeCollectionDefinition: removeCollectionDefinition,
    removeCollectionGroup: removeCollectionGroup,
    removeDelegatedOutcome: removeDelegatedOutcome,
    removeDrawEntries: removeDrawEntries,
    removeDrawPositionAssignment: removeDrawPositionAssignment,
    removeEventEntries: removeEventEntries,
    removeMatchUpSideParticipant: removeMatchUpSideParticipant,
    removeRoundMatchUps: removeRoundMatchUps,
    removeScaleValues: removeScaleValues,
    removeSeededParticipant: removeSeededParticipant,
    removeSeeding: removeSeeding,
    removeStructure: removeStructure,
    removeTieMatchUpParticipantId: removeTieMatchUpParticipantId,
    renameStructures: renameStructures,
    replaceTieMatchUpParticipantId: replaceTieMatchUpParticipantId,
    resetDrawDefinition: resetDrawDefinition,
    resetMatchUpLineUps: resetMatchUpLineUps,
    resetScorecard: resetScorecard,
    resetTieFormat: resetTieFormat,
    resetVoluntaryConsolationStructure: resetVoluntaryConsolationStructure,
    setDelegatedOutcome: setDelegatedOutcome,
    setDrawParticipantRepresentativeIds: setDrawParticipantRepresentativeIds,
    setEntryPosition: setEntryPosition,
    setEntryPositions: setEntryPositions,
    setEventDates: setEventDates,
    setEventEndDate: setEventEndDate,
    setEventStartDate: setEventStartDate,
    setMatchUpFormat: setMatchUpFormat,
    setMatchUpStatus: setMatchUpStatus,
    setOrderOfFinish: setOrderOfFinish,
    setPositionAssignments: setPositionAssignments,
    setStructureOrder: setStructureOrder,
    setSubOrder: setSubOrder,
    substituteParticipant: substituteParticipant,
    swapDrawPositionAssignments: swapDrawPositionAssignments,
    toggleParticipantCheckInState: toggleParticipantCheckInState,
    updateDrawIdsOrder: updateDrawIdsOrder,
    updateTeamLineUp: updateTeamLineUp,
    updateTieMatchUpScore: updateTieMatchUpScore,
    withdrawParticipantAtDrawPosition: withdrawParticipantAtDrawPosition,
};

function generateQualifyingStructures(_a) {
    var e_1, _b, e_2, _c;
    var _d;
    var qualifyingProfiles = _a.qualifyingProfiles, appliedPolicies = _a.appliedPolicies, idPrefix = _a.idPrefix, isMock = _a.isMock, uuids = _a.uuids;
    var stack = 'generateQualifyingSTructures';
    var qualifyingDetails = [];
    var structures = [];
    var links = [];
    var sequenceSort = function (a, b) { return a.stageSequence - b.stageSequence; };
    var roundTargetSort = function (a, b) { return a.roundTarget - b.roundTarget; };
    var qualifyingDrawPositionsCount = 0, totalQualifiersCount = 0, finishingPositions, roundTarget = 1;
    try {
        for (var _e = __values(qualifyingProfiles.sort(roundTargetSort)), _f = _e.next(); !_f.done; _f = _e.next()) {
            var roundTargetProfile = _f.value;
            var structureProfiles = roundTargetProfile.structureProfiles || [];
            roundTarget = roundTargetProfile.roundTarget || roundTarget;
            var stageSequence = 1, targetRoundQualifiersCount = 0, finalQualifyingRoundNumber = void 0, finalQualifyingStructureId = void 0, linkType = void 0;
            var _loop_1 = function (structureProfile) {
                var _j;
                var drawSize = coerceEven(structureProfile.drawSize || structureProfile.participantsCount);
                var qualifyingRoundNumber = structureProfile.qualifyingRoundNumber, structureOptions = structureProfile.structureOptions, matchUpFormat = structureProfile.matchUpFormat, structureName = structureProfile.structureName, structureId = structureProfile.structureId, drawType = structureProfile.drawType;
                var matchUpType = structureProfile.matchUpType;
                var qualifyingPositions = structureProfile.qualifyingPositions ||
                    deriveQualifyingPositions({ drawSize: drawSize, qualifyingRoundNumber: qualifyingRoundNumber });
                var roundLimit, structure = void 0, matchUps = void 0;
                if (!isConvertableInteger(drawSize)) {
                    return { value: decorateResult({
                            result: { error: MISSING_DRAW_SIZE },
                            stack: stack,
                        }) };
                }
                var roundTargetName = qualifyingProfiles.length > 1 ? "".concat(roundTarget, "-") : '';
                var stageSequenceName = structureProfiles.length > 1 || roundTargetName ? stageSequence : '';
                var qualifyingStructureName = structureName ||
                    (roundTargetName || stageSequenceName
                        ? "".concat(constantToString(QUALIFYING), " ").concat(roundTargetName).concat(stageSequenceName)
                        : constantToString(QUALIFYING));
                if (drawType === ROUND_ROBIN) {
                    var _k = generateRoundRobin({
                        structureName: structureProfile.structureName || qualifyingStructureName,
                        structureId: structureId || (uuids === null || uuids === void 0 ? void 0 : uuids.pop()),
                        // qualifyingPositions,
                        stage: QUALIFYING,
                        structureOptions: structureOptions,
                        appliedPolicies: appliedPolicies,
                        stageSequence: stageSequence,
                        matchUpType: matchUpType,
                        roundTarget: roundTarget,
                        drawSize: drawSize,
                        idPrefix: idPrefix,
                        isMock: isMock,
                        uuids: uuids,
                    }), structures_1 = _k.structures, groupCount = _k.groupCount, maxRoundNumber = _k.maxRoundNumber /*, groupSize*/;
                    targetRoundQualifiersCount = groupCount;
                    roundLimit = maxRoundNumber;
                    structure = structures_1[0];
                    finishingPositions = [1];
                }
                else {
                    (_j = treeMatchUps({
                        qualifyingRoundNumber: qualifyingRoundNumber,
                        qualifyingPositions: qualifyingPositions,
                        matchUpType: matchUpType,
                        drawSize: drawSize,
                        idPrefix: idPrefix,
                        isMock: isMock,
                        uuids: uuids,
                    }), drawSize = _j.drawSize, matchUps = _j.matchUps, roundLimit = _j.roundLimit);
                    structure = structureTemplate({
                        structureName: structureProfile.structureName || qualifyingStructureName,
                        structureId: structureId || (uuids === null || uuids === void 0 ? void 0 : uuids.pop()),
                        qualifyingRoundNumber: roundLimit,
                        stage: QUALIFYING,
                        matchUpFormat: matchUpFormat,
                        stageSequence: stageSequence,
                        matchUpType: matchUpType,
                        roundLimit: roundLimit, // redundant
                        matchUps: matchUps,
                    });
                    if (roundTarget) {
                        addExtension({
                            extension: { name: ROUND_TARGET, value: roundTarget },
                            element: structure,
                        });
                    }
                    // always set to the final round of the last generated qualifying structure
                    targetRoundQualifiersCount =
                        ((_d = matchUps === null || matchUps === void 0 ? void 0 : matchUps.filter(function (matchUp) { return matchUp.roundNumber === roundLimit; })) === null || _d === void 0 ? void 0 : _d.length) || 0;
                }
                if (stageSequence > 1) {
                    var link = generateQualifyingLink({
                        sourceStructureId: finalQualifyingStructureId,
                        sourceRoundNumber: finalQualifyingRoundNumber,
                        targetStructureId: structure.structureId,
                        finishingPositions: linkType === POSITION ? [1] : undefined,
                        linkType: linkType,
                    }).link;
                    links.push(link);
                    // if more than one qualifying stageSequence, remove last stageSequence qualifier positions from count
                    qualifyingDrawPositionsCount +=
                        (drawSize || 0) - targetRoundQualifiersCount;
                }
                else {
                    qualifyingDrawPositionsCount += drawSize || 0;
                }
                // IMPORTANT: order of operations is important here!!
                linkType = drawType === ROUND_ROBIN ? POSITION : WINNER;
                // always set to the final round of the last generated qualifying structure
                finalQualifyingStructureId = structure.structureId;
                finalQualifyingRoundNumber = roundLimit;
                structures.push(structure);
                stageSequence += 1;
            };
            try {
                for (var _g = (e_2 = void 0, __values((structureProfiles || []).sort(sequenceSort))), _h = _g.next(); !_h.done; _h = _g.next()) {
                    var structureProfile = _h.value;
                    var state_1 = _loop_1(structureProfile);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_h && !_h.done && (_c = _g.return)) _c.call(_g);
                }
                finally { if (e_2) throw e_2.error; }
            }
            totalQualifiersCount += targetRoundQualifiersCount;
            qualifyingDetails.push({
                qualifiersCount: targetRoundQualifiersCount,
                finalQualifyingRoundNumber: finalQualifyingRoundNumber,
                finalQualifyingStructureId: finalQualifyingStructureId,
                finishingPositions: finishingPositions,
                roundTarget: roundTarget,
                linkType: linkType,
            });
            roundTarget += 1;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign(__assign({ qualifiersCount: totalQualifiersCount, qualifyingDrawPositionsCount: qualifyingDrawPositionsCount, qualifyingDetails: qualifyingDetails, structures: structures }, SUCCESS), { links: links });
}
function deriveQualifyingPositions(_a) {
    var drawSize = _a.drawSize, qualifyingRoundNumber = _a.qualifyingRoundNumber;
    var qualifyingPositions = drawSize;
    var divisionsCount = 0;
    while (divisionsCount < qualifyingRoundNumber) {
        qualifyingPositions = Math.floor(qualifyingPositions / 2);
        divisionsCount += 1;
    }
    return qualifyingPositions;
}

function getDrawTypeCoercion(_a) {
    var _b, _c, _d, _e, _f, _g;
    var policyDefinitions = _a.policyDefinitions, appliedPolicies = _a.appliedPolicies, drawType = _a.drawType;
    var policyDefined = (_b = policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_DRAWS]) === null || _b === void 0 ? void 0 : _b.drawTypeCoercion;
    var policyApplied = (_c = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_DRAWS]) === null || _c === void 0 ? void 0 : _c.drawTypeCoercion;
    return ((_g = (_f = (_e = (_d = (typeof policyDefined === 'boolean' ? policyDefined : undefined)) !== null && _d !== void 0 ? _d : (drawType && (policyDefined === null || policyDefined === void 0 ? void 0 : policyDefined[drawType]))) !== null && _e !== void 0 ? _e : (typeof policyApplied === 'boolean' ? policyApplied : undefined)) !== null && _f !== void 0 ? _f : (drawType && (policyApplied === null || policyApplied === void 0 ? void 0 : policyApplied[drawType]))) !== null && _g !== void 0 ? _g : true);
}

// first iteration only links to a single playoff structure
// future iteration should allow structureOptions to specify
// groups of finishing drawPositions which playoff
function generateRoundRobinWithPlayOff(params) {
    var drawDefinition = params.drawDefinition, structureOptions = params.structureOptions, requireSequential = params.requireSequential;
    var mainDrawProperties = __assign(__assign({ structureName: constantToString(MAIN) }, params), { stage: MAIN }); // default structureName
    var _a = generateRoundRobin(mainDrawProperties), structures = _a.structures, groupCount = _a.groupCount, groupSize = _a.groupSize;
    if (groupCount < 1) {
        return { error: INVALID_CONFIGURATION };
    }
    // define a default playoff group if none specified
    var playoffGroups = (structureOptions === null || structureOptions === void 0 ? void 0 : structureOptions.playoffGroups) || [
        { finishingPositions: [1], structureName: constantToString(PLAY_OFF) },
    ];
    var _b = __read(structures, 1), mainStructure = _b[0];
    var _c = processPlayoffGroups(__assign({ sourceStructureId: mainStructure.structureId, requireSequential: requireSequential, drawDefinition: drawDefinition, playoffGroups: playoffGroups, groupCount: groupCount, groupSize: groupSize }, params)), playoffStructures = _c.structures, links = _c.links;
    if (playoffStructures)
        structures.push.apply(structures, __spreadArray([], __read(playoffStructures), false));
    return __assign(__assign({}, SUCCESS), { structures: structures, links: links });
}

function doubleEliminationLinks(_a) {
    var mainStructure = _a.mainStructure, consolationStructure = _a.consolationStructure, deciderStructure = _a.deciderStructure;
    var consolationMatchUps = consolationStructure.matchUps;
    // roundsFed are those rounds which are generated with drawPositions (not undefined or undefined)
    var roundsFed = consolationMatchUps.reduce(function (rf, matchUp) {
        var drawPositions = (matchUp.drawPositions || []).filter(Boolean);
        return drawPositions.length && !rf.includes(matchUp.roundNumber)
            ? rf.concat(matchUp.roundNumber)
            : rf;
    }, []);
    var mainFinalRound = mainStructure.matchUps.reduce(function (finalRound, matchUp) {
        return !finalRound || matchUp.roundNumber > finalRound
            ? matchUp.roundNumber
            : finalRound;
    }, undefined);
    var consolationFinalRound = consolationStructure.matchUps.reduce(function (finalRound, matchUp) {
        return !finalRound || matchUp.roundNumber > finalRound
            ? matchUp.roundNumber
            : finalRound;
    }, undefined);
    /*
    const initialRounds = [1, 2].map((roundNumber) => {
      const feedProfile = roundNumber % 2 ? TOP_DOWN : BOTTOM_UP;
      return {
        linkType: LOSER,
        source: {
          roundNumber,
          structureId: mainStructure.structureId,
        },
        target: {
          feedProfile,
          roundNumber: 1,
          positionInterleave: { offset: roundNumber - 1, interleave: 1 },
          structureId: consolationStructure.structureId,
        },
      };
    });
    */
    var fedRounds = roundsFed.map(function (roundNumber, i) {
        var roundsFedIndex = roundsFed.indexOf(roundNumber);
        var feedProfile = roundsFedIndex % 2 ? TOP_DOWN : BOTTOM_UP;
        var sourceRoundNumber = 1 + i;
        return {
            linkType: LOSER,
            source: {
                roundNumber: sourceRoundNumber,
                structureId: mainStructure.structureId,
            },
            target: {
                feedProfile: feedProfile,
                roundNumber: roundNumber,
                structureId: consolationStructure.structureId,
            },
        };
    });
    var finalistsLink = {
        linkType: WINNER,
        source: {
            roundNumber: consolationFinalRound,
            structureId: consolationStructure.structureId,
        },
        target: {
            feedProfile: TOP_DOWN,
            roundNumber: mainFinalRound,
            structureId: mainStructure.structureId,
        },
    };
    var deciderLinks = [
        {
            linkType: WINNER,
            source: {
                roundNumber: mainFinalRound,
                structureId: mainStructure.structureId,
            },
            target: {
                feedProfile: TOP_DOWN,
                roundNumber: 1,
                structureId: deciderStructure.structureId,
            },
        },
        {
            linkType: LOSER,
            source: {
                roundNumber: mainFinalRound,
                structureId: mainStructure.structureId,
            },
            target: {
                feedProfile: TOP_DOWN,
                roundNumber: 1,
                structureId: deciderStructure.structureId,
            },
        },
    ];
    // return [...initialRounds, ...fedRounds, finalistsLink, ...deciderLinks];
    return __spreadArray(__spreadArray(__spreadArray([], __read(fedRounds), false), [finalistsLink], false), __read(deciderLinks), false);
}

function generateDoubleElimination(_a) {
    var structureName = _a.structureName, matchUpType = _a.matchUpType, idPrefix = _a.idPrefix, drawSize = _a.drawSize, isMock = _a.isMock, uuids = _a.uuids;
    var structures = [];
    // feedIn MAIN structure needs 1st round feed and final round feed
    var matchUps = feedInMatchUps({
        linkFedFinishingRoundNumbers: [1],
        drawSize: drawSize + 1,
        matchUpType: matchUpType,
        idPrefix: idPrefix,
        isMock: isMock,
    }).matchUps;
    var mainStructure = structureTemplate({
        structureName: structureName || constantToString(MAIN),
        structureId: uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
        stageSequence: 1,
        stage: MAIN,
        matchUpType: matchUpType,
        matchUps: matchUps,
    });
    structures.push(mainStructure);
    var consolationDrawPositions = drawSize / 2;
    var consolationMatchUps = feedInMatchUps({
        finishingPositionOffset: consolationDrawPositions,
        idPrefix: idPrefix && "".concat(idPrefix, "-c"),
        drawSize: drawSize - 1,
        isConsolation: true,
        matchUpType: matchUpType,
        isMock: isMock,
        uuids: uuids,
    }).matchUps;
    var consolationStructure = structureTemplate({
        structureName: constantToString(BACKDRAW),
        matchUps: consolationMatchUps,
        structureId: uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
        stage: CONSOLATION,
        stageSequence: 2,
        matchUpType: matchUpType,
    });
    structures.push(consolationStructure);
    var deciderMatchUps = treeMatchUps({
        idPrefix: idPrefix && "".concat(idPrefix, "-p1t2"),
        drawSize: 2,
        matchUpType: matchUpType,
        isMock: isMock,
    }).matchUps;
    var deciderStructure = structureTemplate({
        structureName: constantToString(DECIDER),
        matchUps: deciderMatchUps,
        structureId: uuids === null || uuids === void 0 ? void 0 : uuids.pop(),
        stageSequence: 3,
        stage: PLAY_OFF,
        matchUpType: matchUpType,
    });
    structures.push(deciderStructure);
    var links = doubleEliminationLinks({
        mainStructure: mainStructure,
        consolationStructure: consolationStructure,
        deciderStructure: deciderStructure,
    });
    return __assign({ structures: structures, links: links }, SUCCESS);
}

function luckyDraw(params) {
    var e_1, _a;
    var qualifyingRoundNumber = params.qualifyingRoundNumber, // round at which participants qualify
    finishingPositionOffset = params.finishingPositionOffset, qualifyingPositions = params.qualifyingPositions, // number of positions which qualify
    matchUpType = params.matchUpType, idPrefix = params.idPrefix, drawSize = params.drawSize, isMock = params.isMock, uuids = params.uuids;
    if (!isConvertableInteger(drawSize) || drawSize < 2) {
        return { matchUps: [], roundsCount: 0 };
    }
    if (isPowerOf2(drawSize))
        return treeMatchUps(params);
    var roundProfiles = luckyRoundProfiles(drawSize);
    var firstRound = roundProfiles.shift();
    var nodes = generateRange(1, ((firstRound === null || firstRound === void 0 ? void 0 : firstRound.participantsCount) || 0) + 1).map(function (drawPosition) { return ({
        drawPosition: drawPosition,
    }); });
    var matchUps = [];
    var roundNumber = 1;
    (matchUps = buildRound({
        roundNumber: roundNumber,
        matchUpType: matchUpType,
        idPrefix: idPrefix,
        matchUps: matchUps,
        isMock: isMock,
        nodes: nodes,
        uuids: uuids,
    }).matchUps);
    roundNumber++;
    var roundLimit = params.roundLimit || qualifyingRoundNumber;
    try {
        for (var roundProfiles_1 = __values(roundProfiles), roundProfiles_1_1 = roundProfiles_1.next(); !roundProfiles_1_1.done; roundProfiles_1_1 = roundProfiles_1.next()) {
            var roundProfile = roundProfiles_1_1.value;
            var roundMatchUpsCount = roundProfile.participantsCount / 2;
            var roundPositionRange = generateRange(1, roundMatchUpsCount + 1);
            if (qualifyingPositions && roundMatchUpsCount === qualifyingPositions) {
                roundLimit = roundNumber - 1;
            }
            var roundMatchUps = roundPositionRange.map(function (roundPosition) {
                var matchUpId = generateMatchUpId({
                    roundPosition: roundPosition,
                    roundNumber: roundNumber,
                    idPrefix: idPrefix,
                    uuids: uuids,
                });
                return {
                    roundPosition: roundPosition,
                    roundNumber: roundNumber,
                    matchUpId: matchUpId,
                };
            });
            matchUps.push.apply(matchUps, __spreadArray([], __read(roundMatchUps), false));
            roundNumber++;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (roundProfiles_1_1 && !roundProfiles_1_1.done && (_a = roundProfiles_1.return)) _a.call(roundProfiles_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var roundsCount = roundNumber - 1; // because roundNumber was incremented at the end of the while loop
    matchUps = addFinishingRounds({
        finishingPositionOffset: finishingPositionOffset,
        lucky: true,
        roundsCount: roundsCount,
        roundLimit: roundLimit,
        matchUps: matchUps,
    });
    if (roundLimit) {
        matchUps = matchUps.filter(function (matchUp) { return matchUp.roundNumber <= roundLimit; });
    }
    return { matchUps: matchUps, roundsCount: roundsCount, roundLimit: roundLimit };
}
function luckyRoundProfiles(drawSize) {
    var intDrawSize = ensureInt(drawSize);
    var participantsCount = intDrawSize % 2 ? intDrawSize + 1 : intDrawSize;
    var preFeedRound = !!(Math.ceil(participantsCount / 2) % 2);
    var rounds = [{ participantsCount: participantsCount, preFeedRound: preFeedRound }];
    while (participantsCount > 2) {
        var nextRound = Math.ceil(participantsCount / 2);
        var nextIsFinal = nextRound === 1;
        var feedRound = !!(!nextIsFinal && nextRound % 2);
        participantsCount = !nextIsFinal && feedRound ? nextRound + 1 : nextRound;
        var preFeedRound_1 = !!(participantsCount !== 2 && Math.ceil(participantsCount / 2) % 2);
        rounds.push({ participantsCount: participantsCount, preFeedRound: preFeedRound_1, feedRound: feedRound });
    }
    return rounds;
}

function getGenerators(params) {
    var _a;
    var _b, _c, _d, _e;
    var playoffAttributes = params.playoffAttributes, _f = params.stageSequence, stageSequence = _f === void 0 ? 1 : _f, _g = params.stage, stage = _g === void 0 ? MAIN : _g, matchUpType = params.matchUpType, drawSize = params.drawSize, uuids = params.uuids;
    var getPrefixedStructureId = function () {
        if (!params.isMock && !params.idPrefix)
            return undefined;
        var drawId = params.drawDefinition.drawId;
        return "".concat(drawId, "-s-0");
    };
    var structureId = params.structureId || getPrefixedStructureId() || (uuids === null || uuids === void 0 ? void 0 : uuids.pop());
    var appliedPolicies = getAppliedPolicies(params).appliedPolicies;
    var feedPolicy = ((_b = params.policyDefinitions) === null || _b === void 0 ? void 0 : _b[POLICY_TYPE_FEED_IN]) || (appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_FEED_IN]);
    // disable feeding from MAIN final unless policy specifies
    params.skipRounds = params.skipRounds || (drawSize <= 4 && ((feedPolicy === null || feedPolicy === void 0 ? void 0 : feedPolicy.feedMainFinal) ? 0 : 1)) || 0;
    var structureName = (_e = (_c = params.structureName) !== null && _c !== void 0 ? _c : (_d = playoffAttributes === null || playoffAttributes === void 0 ? void 0 : playoffAttributes['0']) === null || _d === void 0 ? void 0 : _d.name) !== null && _e !== void 0 ? _e : constantToString(MAIN);
    var singleElimination = function () {
        var matchUps = treeMatchUps(params).matchUps;
        var structure = structureTemplate({
            stageSequence: stageSequence,
            structureName: structureName,
            matchUpType: matchUpType,
            structureId: structureId,
            matchUps: matchUps,
            stage: stage,
        });
        return __assign({ structures: [structure], links: [] }, SUCCESS);
    };
    var generators = (_a = {},
        _a[AD_HOC] = function () {
            var structure = structureTemplate({
                finishingPosition: WIN_RATIO$1,
                stageSequence: stageSequence,
                structureName: structureName,
                matchUps: [],
                matchUpType: matchUpType,
                structureId: structureId,
                stage: stage,
            });
            return __assign({ structures: [structure], links: [] }, SUCCESS);
        },
        _a[LUCKY_DRAW] = function () {
            var matchUps = luckyDraw(params).matchUps;
            var structure = structureTemplate({
                stageSequence: stageSequence,
                structureName: structureName,
                matchUpType: matchUpType,
                structureId: structureId,
                matchUps: matchUps,
                stage: stage,
            });
            return __assign({ structures: [structure], links: [] }, SUCCESS);
        },
        _a[SINGLE_ELIMINATION] = function () { return singleElimination(); },
        _a[DOUBLE_ELIMINATION] = function () { return generateDoubleElimination(params); },
        _a[COMPASS] = function () {
            return generatePlayoffStructures(__assign(__assign({}, params), { roundOffsetLimit: 3, playoffAttributes: playoffAttributes !== null && playoffAttributes !== void 0 ? playoffAttributes : COMPASS_ATTRIBUTES }));
        },
        _a[OLYMPIC] = function () {
            return generatePlayoffStructures(__assign(__assign({}, params), { roundOffsetLimit: 2, playoffAttributes: playoffAttributes !== null && playoffAttributes !== void 0 ? playoffAttributes : OLYMPIC_ATTRIBUTES }));
        },
        _a[PLAY_OFF] = function () {
            return generatePlayoffStructures(params);
        },
        _a[FEED_IN$1] = function () {
            var matchUps = feedInMatchUps({ drawSize: drawSize, uuids: uuids, matchUpType: matchUpType }).matchUps;
            var structure = structureTemplate({
                stageSequence: stageSequence,
                structureName: structureName,
                matchUpType: matchUpType,
                structureId: structureId,
                stage: MAIN,
                matchUps: matchUps,
            });
            return __assign({ structures: [structure], links: [] }, SUCCESS);
        },
        _a[FIRST_ROUND_LOSER_CONSOLATION] = function () { return firstRoundLoserConsolation(params); },
        _a[FIRST_MATCH_LOSER_CONSOLATION] = function () { return feedInChampionship(__assign(__assign({}, params), { feedRounds: 1, fmlc: true })); },
        _a[MFIC] = function () { return feedInChampionship(__assign(__assign({}, params), { feedRounds: 1 })); },
        _a[FICSF] = function () { return feedInChampionship(__assign(__assign({}, params), { feedsFromFinal: 1 })); },
        _a[FICQF] = function () { return feedInChampionship(__assign(__assign({}, params), { feedsFromFinal: 2 })); },
        _a[FICR16] = function () { return feedInChampionship(__assign(__assign({}, params), { feedsFromFinal: 3 })); },
        _a[FEED_IN_CHAMPIONSHIP] = function () { return feedInChampionship(params); },
        _a[CURTIS] = function () { return generateCurtisConsolation(params); },
        _a[ROUND_ROBIN] = function () { return generateRoundRobin(params); },
        _a[ROUND_ROBIN_WITH_PLAYOFF] = function () { return generateRoundRobinWithPlayOff(params); },
        _a);
    return { generators: generators };
}

function generateDrawStructuresAndLinks(params) {
    var e_1, _a, e_2, _b;
    var _c, _d, _e, _f, _g, _h, _j;
    var _k = params || {}, _l = _k.enforceMinimumDrawSize, enforceMinimumDrawSize = _l === void 0 ? true : _l, overwriteExisting = _k.overwriteExisting, appliedPolicies = _k.appliedPolicies, staggeredEntry = _k.staggeredEntry, // optional - specifies main structure FEED_IN for drawTypes CURTIS_CONSOLATION, FEED_IN_CHAMPIONSHIPS, FMLC
    drawDefinition = _k.drawDefinition, tieFormat = _k.tieFormat, drawSize = _k.drawSize, isMock = _k.isMock, uuids = _k.uuids;
    var drawTypeCoercion = (_c = params.drawTypeCoercion) !== null && _c !== void 0 ? _c : getDrawTypeCoercion({ appliedPolicies: appliedPolicies, drawType: params.drawType });
    var stack = 'generateDrawStructuresAndLinks';
    var drawType = (drawTypeCoercion && params.drawSize === 2 && SINGLE_ELIMINATION) ||
        params.drawType ||
        SINGLE_ELIMINATION;
    var structures = [], links = [];
    var matchUpType = (_d = params === null || params === void 0 ? void 0 : params.matchUpType) !== null && _d !== void 0 ? _d : SINGLES;
    var existingQualifyingStructures = (_e = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) === null || _e === void 0 ? void 0 : _e.filter(function (_a) {
        var stage = _a.stage;
        return stage === QUALIFYING;
    });
    if (existingQualifyingStructures) {
        structures.push.apply(structures, __spreadArray([], __read(existingQualifyingStructures), false));
    }
    var existingQualifyingStructureIds = existingQualifyingStructures === null || existingQualifyingStructures === void 0 ? void 0 : existingQualifyingStructures.map(function (_a) {
        var structureId = _a.structureId;
        return structureId;
    });
    var existingMainStructure = (_f = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) === null || _f === void 0 ? void 0 : _f.find(function (_a) {
        var stage = _a.stage, stageSequence = _a.stageSequence;
        return stage === MAIN && stageSequence === 1;
    });
    var existingQualifyingLinks = (_g = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.links) === null || _g === void 0 ? void 0 : _g.filter(function (link) {
        return link.target.structureId === (existingMainStructure === null || existingMainStructure === void 0 ? void 0 : existingMainStructure.structureId) &&
            (existingQualifyingStructureIds === null || existingQualifyingStructureIds === void 0 ? void 0 : existingQualifyingStructureIds.includes(link.source.structureId));
    });
    var getQualifiersCount = function (link, structure) {
        var _a;
        if (link.linkType === POSITION && (structure === null || structure === void 0 ? void 0 : structure.structures)) {
            var finishingPositions = link.source.finishingPositions || [];
            return structure.structures.length * finishingPositions.length;
        }
        else if (link.linkType === WINNER && ((_a = structure === null || structure === void 0 ? void 0 : structure.matchUps) === null || _a === void 0 ? void 0 : _a.length)) {
            var qualifyingRoundNumber_1 = link.source.roundNumber;
            var matchUps = structure.matchUps.filter(function (_a) {
                var roundNumber = _a.roundNumber;
                return roundNumber === qualifyingRoundNumber_1;
            });
            return matchUps.length;
        }
    };
    var existingQualifyingDrawPositionsCount = existingQualifyingStructures === null || existingQualifyingStructures === void 0 ? void 0 : existingQualifyingStructures.map(function (structure) {
        var _a, _b, _c, _d;
        var relevantLink = existingQualifyingLinks === null || existingQualifyingLinks === void 0 ? void 0 : existingQualifyingLinks.find(function (link) { return link.target.structureId === structure.structureId; });
        var drawPositionsCount = (_c = (_b = (_a = getPositionAssignments$1({ structure: structure })) === null || _a === void 0 ? void 0 : _a.positionAssignments) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
        if (!relevantLink)
            return drawPositionsCount;
        var sourceStructureId = relevantLink === null || relevantLink === void 0 ? void 0 : relevantLink.source.structureId;
        var sourceStructure = (_d = drawDefinition.structures) === null || _d === void 0 ? void 0 : _d.find(function (structure) { return structure.structureId === sourceStructureId; });
        var sourceQualifiersCount = getQualifiersCount(relevantLink, sourceStructure) || 0;
        return drawPositionsCount - sourceQualifiersCount;
    }).filter(Boolean).reduce(function (a, b) { return a + b; }, 0);
    var existingQualifiersCount = existingQualifyingLinks === null || existingQualifyingLinks === void 0 ? void 0 : existingQualifyingLinks.map(function (link) {
        var qualifyingStructureId = link.source.structureId;
        var structure = existingQualifyingStructures === null || existingQualifyingStructures === void 0 ? void 0 : existingQualifyingStructures.find(function (structure) { return structure.structureId === qualifyingStructureId; });
        return getQualifiersCount(link, structure);
    }).filter(Boolean).reduce(function (a, b) { return a + b; }, 0);
    var mainStructureIsPlaceholder = !!(existingMainStructure && !((_h = existingMainStructure === null || existingMainStructure === void 0 ? void 0 : existingMainStructure.matchUps) === null || _h === void 0 ? void 0 : _h.length));
    if ((existingQualifyingStructures === null || existingQualifyingStructures === void 0 ? void 0 : existingQualifyingStructures.length) && !mainStructureIsPlaceholder) {
        return { error: EXISTING_STAGE };
    }
    var qualifyingProfiles = !(existingQualifyingStructures === null || existingQualifyingStructures === void 0 ? void 0 : existingQualifyingStructures.length) && params.qualifyingProfiles;
    // first generate any qualifying structures and links
    var qualifyingResult = (qualifyingProfiles === null || qualifyingProfiles === void 0 ? void 0 : qualifyingProfiles.length) &&
        generateQualifyingStructures({
            idPrefix: params.idPrefix,
            qualifyingProfiles: qualifyingProfiles,
            appliedPolicies: appliedPolicies,
            isMock: isMock,
            uuids: uuids,
        });
    if (qualifyingResult === null || qualifyingResult === void 0 ? void 0 : qualifyingResult.error) {
        return qualifyingResult;
    }
    var _m = qualifyingResult || {
        qualifyingDrawPositionsCount: existingQualifyingDrawPositionsCount,
        qualifiersCount: existingQualifiersCount,
    }, qualifyingDrawPositionsCount = _m.qualifyingDrawPositionsCount, qualifyingDetails = _m.qualifyingDetails, qualifiersCount = _m.qualifiersCount;
    if (qualifyingDrawPositionsCount) {
        if (qualifyingResult === null || qualifyingResult === void 0 ? void 0 : qualifyingResult.structures) {
            structures.push.apply(structures, __spreadArray([], __read(qualifyingResult.structures), false));
        }
        if (qualifyingResult === null || qualifyingResult === void 0 ? void 0 : qualifyingResult.links) {
            links.push.apply(links, __spreadArray([], __read(qualifyingResult.links), false));
        }
    }
    Object.assign(params, definedAttributes({ drawSize: drawSize, matchUpType: matchUpType, tieFormat: tieFormat }));
    // check that drawSize is a valid value
    var invalidDrawSize = drawType !== AD_HOC &&
        (!drawSize ||
            isNaN(drawSize) ||
            drawSize < 2 ||
            (!staggeredEntry &&
                ![FEED_IN$1, LUCKY_DRAW].includes(drawType) &&
                (([ROUND_ROBIN_WITH_PLAYOFF, ROUND_ROBIN].includes(drawType) &&
                    drawSize < 3) ||
                    (![ROUND_ROBIN, ROUND_ROBIN_WITH_PLAYOFF].includes(drawType) &&
                        !isPowerOf2(drawSize)))));
    if (invalidDrawSize && !qualifyingDrawPositionsCount) {
        return decorateResult({
            context: { drawSize: drawSize, invalidDrawSize: invalidDrawSize },
            result: { error: INVALID_DRAW_SIZE },
            stack: stack,
        });
    }
    var multiStructure = MULTI_STRUCTURE_DRAWS.includes(drawType);
    if (drawSize && ensureInt(drawSize) < 4 && multiStructure) {
        if (drawTypeCoercion) {
            drawType = SINGLE_ELIMINATION;
        }
        else if (enforceMinimumDrawSize) {
            return decorateResult({
                context: {
                    enforceMinimumDrawSize: enforceMinimumDrawSize,
                    invalidDrawSize: invalidDrawSize,
                    drawSize: drawSize,
                    drawType: drawType,
                },
                result: { error: INVALID_DRAW_SIZE },
                stack: stack,
            });
        }
    }
    var _o = getGenerators(params), generators = _o.generators, error = _o.error;
    if (error) {
        return { error: error };
    }
    var generator = generators[drawType];
    if (!generator)
        return { error: UNRECOGNIZED_DRAW_TYPE };
    var generatorResult = generator === null || generator === void 0 ? void 0 : generator();
    if (generatorResult.error)
        return generatorResult;
    var generatedStructures = generatorResult.structures, generatedLinks = generatorResult.links;
    if (generatedStructures === null || generatedStructures === void 0 ? void 0 : generatedStructures.length) {
        var generatedMainStructure = generatedStructures.find(function (_a) {
            var stage = _a.stage, stageSequence = _a.stageSequence;
            return stage === MAIN && stageSequence === 1;
        });
        if (existingMainStructure && generatedMainStructure) {
            if (mainStructureIsPlaceholder) {
                var generatedMainStructureId = generatedMainStructure.structureId;
                generatedMainStructure.structureId = existingMainStructure.structureId;
                if (generatedLinks === null || generatedLinks === void 0 ? void 0 : generatedLinks.length) {
                    try {
                        for (var generatedLinks_1 = __values(generatedLinks), generatedLinks_1_1 = generatedLinks_1.next(); !generatedLinks_1_1.done; generatedLinks_1_1 = generatedLinks_1.next()) {
                            var link = generatedLinks_1_1.value;
                            if (link.source.structureId === generatedMainStructureId) {
                                link.source.structureId = existingMainStructure.structureId;
                            }
                            if (link.target.structureId === generatedMainStructureId) {
                                link.target.structureId = existingMainStructure.structureId;
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (generatedLinks_1_1 && !generatedLinks_1_1.done && (_a = generatedLinks_1.return)) _a.call(generatedLinks_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            }
            else if (!overwriteExisting) {
                return { error: EXISTING_STAGE };
            }
        }
        structures.push.apply(structures, __spreadArray([], __read(generatedStructures), false));
    }
    structures.sort(structureSort);
    if (generatedLinks === null || generatedLinks === void 0 ? void 0 : generatedLinks.length) {
        links.push.apply(links, __spreadArray([], __read(generatedLinks), false));
    }
    var mainStructure = generatorResult.structures.find(function (_a) {
        var stage = _a.stage, stageSequence = _a.stageSequence;
        return stage === MAIN && stageSequence === 1;
    });
    try {
        for (var _p = __values(qualifyingDetails || []), _q = _p.next(); !_q.done; _q = _p.next()) {
            var qualifyingDetail = _q.value;
            var qualifyingRoundNumber = qualifyingDetail.finalQualifyingRoundNumber, qualifyingStructureId = qualifyingDetail.finalQualifyingStructureId, targetEntryRound = qualifyingDetail.roundTarget, finishingPositions = qualifyingDetail.finishingPositions, linkType = qualifyingDetail.linkType;
            var link = mainStructure &&
                ((_j = generateQualifyingLink({
                    targetStructureId: mainStructure.structureId,
                    sourceStructureId: qualifyingStructureId,
                    sourceRoundNumber: qualifyingRoundNumber,
                    finishingPositions: finishingPositions,
                    targetEntryRound: targetEntryRound,
                    linkType: linkType,
                })) === null || _j === void 0 ? void 0 : _j.link);
            if (link === null || link === void 0 ? void 0 : link.error)
                return link;
            if (link) {
                links.push(link);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_q && !_q.done && (_b = _p.return)) _b.call(_p);
        }
        finally { if (e_2) throw e_2.error; }
    }
    if (existingQualifyingLinks)
        links.push.apply(links, __spreadArray([], __read(existingQualifyingLinks), false));
    return __assign(__assign({}, SUCCESS), { qualifyingResult: {
            qualifyingDrawPositionsCount: qualifyingDrawPositionsCount,
            qualifiersCount: qualifiersCount,
        }, structures: structures, links: links });
}

function generateDrawTypeAndModifyDrawDefinition(params) {
    var _a, _b, _c, _d, _e;
    var _f = params || {}, _g = _f.modifyOriginal, modifyOriginal = _g === void 0 ? true : _g, _h = _f.stageSequence, stageSequence = _h === void 0 ? 1 : _h, isMock = _f.isMock;
    var stack = 'generateDrawTypeAndModifyDrawDefinition';
    if (!params.drawDefinition)
        return decorateResult({
            result: { error: MISSING_DRAW_DEFINITION },
            stack: stack,
        });
    var drawDefinition = modifyOriginal ? params.drawDefinition : makeDeepCopy(params.drawDefinition, false, true);
    var tieFormat = params.tieFormat, matchUpType = params.matchUpType;
    if (tieFormat) {
        var result_1 = validateTieFormat({ tieFormat: tieFormat });
        if (result_1.error)
            return result_1;
    }
    tieFormat = copyTieFormat(tieFormat !== null && tieFormat !== void 0 ? tieFormat : (_a = resolveTieFormat({ drawDefinition: drawDefinition })) === null || _a === void 0 ? void 0 : _a.tieFormat);
    matchUpType = matchUpType !== null && matchUpType !== void 0 ? matchUpType : (drawDefinition.matchUpType || SINGLES);
    params.tieFormat = tieFormat;
    params.matchUpType = matchUpType;
    var mainStageDrawPositionsCount = getStageDrawPositionsCount({
        drawDefinition: drawDefinition,
        stage: MAIN,
    });
    params.drawSize = (_b = params.drawSize) !== null && _b !== void 0 ? _b : mainStageDrawPositionsCount;
    if (!mainStageDrawPositionsCount && params.drawSize) {
        setStageDrawSize({
            drawSize: params.drawSize,
            drawDefinition: drawDefinition,
            stageSequence: stageSequence,
            stage: MAIN,
        });
    }
    var existingMatchUpIds = getMatchUpsMap({
        drawDefinition: drawDefinition,
    }).drawMatchUps.map(getMatchUpId);
    var result = generateDrawStructuresAndLinks(params);
    if (result.error) {
        return decorateResult({ result: result, stack: stack });
    }
    var structures = result.structures, links = result.links, qualifyingResult = result.qualifyingResult;
    drawDefinition.structures = structures;
    drawDefinition.links = links;
    var qualifiersCount = Math.max((_c = params.qualifiersCount) !== null && _c !== void 0 ? _c : 0, (qualifyingResult === null || qualifyingResult === void 0 ? void 0 : qualifyingResult.qualifiersCount) || 0);
    if (qualifyingResult === null || qualifyingResult === void 0 ? void 0 : qualifyingResult.qualifyingDrawPositionsCount) {
        var qualifyingStageDrawPositionsCount = getStageDrawPositionsCount({
            stage: QUALIFYING,
            drawDefinition: drawDefinition,
        });
        if (!qualifyingStageDrawPositionsCount) {
            var result_2 = setStageDrawSize({
                drawSize: qualifyingResult.qualifyingDrawPositionsCount,
                stage: QUALIFYING,
                drawDefinition: drawDefinition,
            });
            if (result_2.error)
                return result_2;
        }
    }
    if (qualifiersCount) {
        var result_3 = setStageQualifiersCount({
            qualifiersCount: qualifiersCount,
            drawDefinition: drawDefinition,
            stage: MAIN,
        });
        if (result_3.error)
            return result_3;
    }
    var drawSize = (_d = params.drawSize) !== null && _d !== void 0 ? _d : mainStageDrawPositionsCount;
    Object.assign(params, definedAttributes({ drawSize: drawSize, matchUpType: matchUpType, tieFormat: tieFormat }));
    var _j = getAllDrawMatchUps({ drawDefinition: drawDefinition }), matchUps = _j.matchUps, matchUpsMap = _j.matchUpsMap;
    if (tieFormat) {
        // if there were exiting matchUps, exclude them from this step
        matchUps === null || matchUps === void 0 ? void 0 : matchUps.forEach(function (matchUp) {
            if (!existingMatchUpIds.includes(matchUp.matchUpId)) {
                var tieMatchUps = generateTieMatchUps({
                    tieFormat: tieFormat,
                    matchUp: matchUp,
                    isMock: isMock,
                }).tieMatchUps;
                Object.assign(matchUp, { tieMatchUps: tieMatchUps, matchUpType: matchUpType });
            }
        });
    }
    var inContextDrawMatchUps = addGoesTo({ drawDefinition: drawDefinition, matchUpsMap: matchUpsMap }).inContextDrawMatchUps;
    modifyDrawNotice({
        tournamentId: (_e = params.tournamentRecord) === null || _e === void 0 ? void 0 : _e.tournamentId,
        drawDefinition: drawDefinition,
    });
    return __assign(__assign({ inContextDrawMatchUps: inContextDrawMatchUps, drawDefinition: drawDefinition, matchUpsMap: matchUpsMap }, SUCCESS), { structures: structures, matchUps: matchUps, links: links });
}

function generateVoluntaryConsolation(params) {
    var _a, _b;
    var _c, _d, _e, _f, _g, _h;
    var _j = params.drawType, drawType = _j === void 0 ? SINGLE_ELIMINATION : _j, _k = params.attachConsolation, attachConsolation = _k === void 0 ? true : _k, _l = params.applyPositioning, applyPositioning = _l === void 0 ? true : _l, tournamentRecord = params.tournamentRecord, staggeredEntry = params.staggeredEntry, // optional - specifies main structure FEED_IN for drawTypes CURTIS_CONSOLATION, FEED_IN_CHAMPIONSHIPS, FMLC
    automated = params.automated, placeByes = params.placeByes, isMock = params.isMock, event = params.event;
    var drawDefinition = params === null || params === void 0 ? void 0 : params.drawDefinition;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var stage = VOLUNTARY_CONSOLATION;
    var entries = getStageEntries$1({
        stageSequence: 1,
        drawDefinition: drawDefinition,
        stage: stage,
    });
    var drawSize = ![ROUND_ROBIN, DOUBLE_ELIMINATION, ROUND_ROBIN_WITH_PLAYOFF].includes(drawType)
        ? nextPowerOf2(entries.length)
        : entries.length;
    if ((!staggeredEntry && drawType === FEED_IN$1 && entries.length < 2) ||
        (drawType === ROUND_ROBIN && entries.length < 3))
        return { error: INVALID_DRAW_SIZE };
    var tieFormat = params.tieFormat, matchUpType = params.matchUpType;
    if (tieFormat) {
        var result_1 = validateTieFormat({ tieFormat: tieFormat });
        if (result_1.error)
            return result_1;
    }
    tieFormat = copyTieFormat(tieFormat !== null && tieFormat !== void 0 ? tieFormat : (_c = resolveTieFormat({ drawDefinition: drawDefinition })) === null || _c === void 0 ? void 0 : _c.tieFormat);
    matchUpType = (_d = matchUpType !== null && matchUpType !== void 0 ? matchUpType : drawDefinition.matchUpType) !== null && _d !== void 0 ? _d : SINGLES;
    var stageStructures = getDrawStructures({
        stageSequence: 1,
        drawDefinition: drawDefinition,
        stage: stage,
    }).structures;
    // invalid to have more than one existing VOLUNTARY_CONSOLATION structure
    var structureCount = stageStructures.length;
    if (structureCount > 1)
        return { error: STAGE_SEQUENCE_LIMIT };
    // invalid to already have matchUps generated for any existing structure
    if ((_f = (_e = stageStructures === null || stageStructures === void 0 ? void 0 : stageStructures[0]) === null || _e === void 0 ? void 0 : _e.matchUps) === null || _f === void 0 ? void 0 : _f.length)
        return { error: EXISTING_STRUCTURE };
    var structureId = (_g = stageStructures === null || stageStructures === void 0 ? void 0 : stageStructures[0]) === null || _g === void 0 ? void 0 : _g.structureId;
    Object.assign(params, definedAttributes({
        structureName: (_h = params.structureName) !== null && _h !== void 0 ? _h : constantToString(VOLUNTARY_CONSOLATION),
        structureId: structureId,
        matchUpType: matchUpType,
        tieFormat: tieFormat,
        drawSize: drawSize,
        stage: stage,
    }));
    var result = getGenerators(params);
    if (result.error)
        return result;
    var generator = result.generators[drawType];
    if (!generator)
        return { error: UNRECOGNIZED_DRAW_TYPE };
    var generatorResult = generator === null || generator === void 0 ? void 0 : generator();
    if (generatorResult.error)
        return generatorResult;
    var structures = generatorResult.structures, links = generatorResult.links;
    var matchUps = structures.map(function (structure) { return getAllStructureMatchUps({ structure: structure }).matchUps; }).flat();
    if (tieFormat) {
        matchUps.forEach(function (matchUp) {
            var tieMatchUps = generateTieMatchUps({ matchUp: matchUp, tieFormat: tieFormat, isMock: isMock }).tieMatchUps;
            Object.assign(matchUp, { tieMatchUps: tieMatchUps, matchUpType: matchUpType });
        });
    }
    if (!applyPositioning || !attachConsolation) {
        drawDefinition = makeDeepCopy(drawDefinition, false, true);
    }
    if (!drawDefinition.links)
        drawDefinition.links = [];
    if (links.length)
        (_a = drawDefinition.links).push.apply(_a, __spreadArray([], __read(links), false));
    var generatedStructureIds = structures.map(function (_a) {
        var structureId = _a.structureId;
        return structureId;
    });
    if (!drawDefinition.structures)
        drawDefinition.structures = [];
    var existingStructureIds = drawDefinition.structures.map(function (_a) {
        var structureId = _a.structureId;
        return structureId;
    });
    // replace any existing structures with newly generated structures
    // this is done because it is possible that a consolation structure exists without matchUps
    drawDefinition.structures = drawDefinition.structures.map(function (structure) {
        return generatedStructureIds.includes(structure.structureId)
            ? structures.find(function (_a) {
                var structureId = _a.structureId;
                return structureId === structure.structureId;
            })
            : structure;
    });
    var newStructures = structures.filter(function (_a) {
        var structureId = _a.structureId;
        return !existingStructureIds.includes(structureId);
    });
    if (newStructures.length)
        (_b = drawDefinition.structures).push.apply(_b, __spreadArray([], __read(newStructures), false));
    if (automated) {
        automatedPositioning({
            seedingProfile: params.seedingProfile,
            applyPositioning: applyPositioning,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            structureId: structureId,
            placeByes: placeByes,
            drawSize: drawSize,
            event: event,
        });
    }
    if (attachConsolation)
        modifyDrawNotice({ drawDefinition: drawDefinition });
    return __assign({ links: links, structures: structures }, SUCCESS);
}

function getAllowedMatchUpFormats(_a) {
    var tournamentRecord = _a.tournamentRecord, categoryName = _a.categoryName, categoryType = _a.categoryType;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var appliedPolicies = getAppliedPolicies({ tournamentRecord: tournamentRecord }).appliedPolicies;
    var scoringPolicy = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_SCORING];
    var matchUpFormats = (scoringPolicy === null || scoringPolicy === void 0 ? void 0 : scoringPolicy.matchUpFormats) || [];
    return matchUpFormats.filter(function (_a) {
        var categoryNames = _a.categoryNames, categoryTypes = _a.categoryTypes;
        return (!categoryName && !categoryTypes) ||
            (categoryName && (categoryNames === null || categoryNames === void 0 ? void 0 : categoryNames.includes(categoryName))) ||
            (categoryType && (categoryTypes === null || categoryTypes === void 0 ? void 0 : categoryTypes.includes(categoryType)));
    });
}
function getAllowedDrawTypes(_a) {
    var tournamentRecord = _a.tournamentRecord, categoryName = _a.categoryName, categoryType = _a.categoryType;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var appliedPolicies = getAppliedPolicies({ tournamentRecord: tournamentRecord }).appliedPolicies;
    var drawTypesPolicy = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_DRAWS];
    var drawTypes = (drawTypesPolicy === null || drawTypesPolicy === void 0 ? void 0 : drawTypesPolicy.allowedDrawTypes) || [];
    return drawTypes.filter(function (_a) {
        var categoryNames = _a.categoryNames, categoryTypes = _a.categoryTypes;
        return (!categoryName && !categoryTypes) ||
            (categoryName && (categoryNames === null || categoryNames === void 0 ? void 0 : categoryNames.includes(categoryName))) ||
            (categoryType && (categoryTypes === null || categoryTypes === void 0 ? void 0 : categoryTypes.includes(categoryType)));
    });
}

// add collectionIds if missing
function checkTieFormat(_a) {
    var e_1, _b;
    var tieFormat = _a.tieFormat;
    var result = validateTieFormat({
        checkCollectionIds: false,
        tieFormat: tieFormat,
    });
    if (result.error)
        return result;
    try {
        for (var _c = __values(tieFormat.collectionDefinitions), _d = _c.next(); !_d.done; _d = _c.next()) {
            var collectionDefinition = _d.value;
            if (!collectionDefinition.collectionId)
                collectionDefinition.collectionId = UUID();
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { tieFormat: tieFormat };
}

function checkValidEntries(_a) {
    var _b;
    var _c, _d, _e, _f;
    var consideredEntries = _a.consideredEntries, policyDefinitions = _a.policyDefinitions, tournamentRecord = _a.tournamentRecord, appliedPolicies = _a.appliedPolicies, participantMap = _a.participantMap, enforceGender = _a.enforceGender, participants = _a.participants, event = _a.event;
    if ((!participants || !participantMap) && tournamentRecord) {
        (_b = getParticipants({
            tournamentRecord: tournamentRecord,
        }), participants = _b.participants, participantMap = _b.participantMap);
    }
    if (!participants)
        return { error: MISSING_PARTICIPANTS };
    if (!Array.isArray(participants))
        return { error: INVALID_VALUES };
    if (!event)
        return { error: MISSING_EVENT };
    var matchUpActionsPolicy = (_d = (_c = policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_MATCHUP_ACTIONS]) !== null && _c !== void 0 ? _c : appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_MATCHUP_ACTIONS]) !== null && _d !== void 0 ? _d : POLICY_MATCHUP_ACTIONS_DEFAULT[POLICY_TYPE_MATCHUP_ACTIONS];
    var genderEnforced = (enforceGender !== null && enforceGender !== void 0 ? enforceGender : (_e = matchUpActionsPolicy === null || matchUpActionsPolicy === void 0 ? void 0 : matchUpActionsPolicy.participants) === null || _e === void 0 ? void 0 : _e.enforceGender) !==
        false;
    var eventType = event.eventType, eventGender = event.gender;
    var isDoubles = eventType === DOUBLES_EVENT;
    var participantType = (eventType === TEAM_EVENT && TEAM$1) || (isDoubles && PAIR) || INDIVIDUAL;
    var entryStatusMap = Object.assign.apply(Object, __spreadArray([{}], __read(((_f = consideredEntries !== null && consideredEntries !== void 0 ? consideredEntries : event.entries) !== null && _f !== void 0 ? _f : []).map(function (entry) {
        var _a;
        return (_a = {},
            _a[entry.participantId] = entry.entryStatus,
            _a);
    })), false));
    var enteredParticipantIds = Object.keys(entryStatusMap);
    var enteredParticipants = participants.filter(function (participant) {
        return enteredParticipantIds.includes(participant.participantId);
    });
    var invalidEntries = enteredParticipants.filter(function (participant) {
        var _a, _b, _c, _d;
        var entryStatus = entryStatusMap[participant.participantId];
        var ungroupedParticipant = eventType &&
            [DOUBLES_EVENT, TEAM_EVENT].includes(eventType) &&
            participant.participantType === INDIVIDUAL &&
            (isUngrouped(entryStatus) || entryStatus === WITHDRAWN);
        var mismatch = participant.participantType !== participantType && !ungroupedParticipant;
        var pairGender = !mismatch &&
            isDoubles &&
            unique((_b = (_a = participant === null || participant === void 0 ? void 0 : participant.individualParticipantIds) === null || _a === void 0 ? void 0 : _a.map(function (id) { var _a, _b, _c; return (_c = (_b = (_a = participantMap === null || participantMap === void 0 ? void 0 : participantMap[id]) === null || _a === void 0 ? void 0 : _a.participant) === null || _b === void 0 ? void 0 : _b.person) === null || _c === void 0 ? void 0 : _c.sex; }).filter(Boolean)) !== null && _b !== void 0 ? _b : []);
        var validPairGender = !eventGender ||
            !(pairGender === null || pairGender === void 0 ? void 0 : pairGender.length) ||
            ANY === eventGender ||
            ([MALE, FEMALE].includes(eventGender) && pairGender[0] === eventGender) ||
            (MIXED === eventGender &&
                ((pairGender.length == 1 &&
                    ((_c = participant.individualParticipantIds) === null || _c === void 0 ? void 0 : _c.length) === 1) ||
                    pairGender.length === 2));
        var personGender = (_d = participant === null || participant === void 0 ? void 0 : participant.person) === null || _d === void 0 ? void 0 : _d.sex;
        var validPersonGender = !(participant === null || participant === void 0 ? void 0 : participant.person) ||
            !eventGender ||
            [ANY, MIXED].includes(eventGender) ||
            ([MALE, FEMALE].includes(eventGender) && personGender === eventGender);
        var validGender = !genderEnforced || (validPairGender && validPersonGender);
        return mismatch || !validGender;
    });
    if (invalidEntries.length) {
        var invalidParticipantIds = invalidEntries.map(function (participant) { return participant.participantId; });
        return { error: INVALID_ENTRIES, invalidParticipantIds: invalidParticipantIds };
    }
    return __assign(__assign({}, SUCCESS), { valid: true });
}

var definitionTemplate = function () { return ({
    matchUpType: undefined,
    drawName: undefined,
    drawId: undefined,
    structures: [],
    entries: [],
    links: [],
}); };

function newDrawDefinition(params) {
    var _a = params !== null && params !== void 0 ? params : {}, _b = _a.drawId, drawId = _b === void 0 ? UUID() : _b, processCodes = _a.processCodes, matchUpType = _a.matchUpType, drawType = _a.drawType;
    var drawDefinition = definitionTemplate();
    return Object.assign(drawDefinition, {
        processCodes: processCodes,
        matchUpType: matchUpType,
        drawType: drawType,
        drawId: drawId,
    });
}

function initializeStructureSeedAssignments(_a) {
    var _b, _c;
    var _d = _a.requireParticipantCount, requireParticipantCount = _d === void 0 ? true : _d, _e = _a.enforcePolicyLimits, enforcePolicyLimits = _e === void 0 ? true : _e, drawSizeProgression = _a.drawSizeProgression, participantsCount = _a.participantsCount, participantCount = _a.participantCount, appliedPolicies = _a.appliedPolicies, drawDefinition = _a.drawDefinition, seedingProfile = _a.seedingProfile, structureId = _a.structureId, seedsCount = _a.seedsCount;
    participantsCount = participantsCount !== null && participantsCount !== void 0 ? participantsCount : participantCount;
    var result = findStructure({ drawDefinition: drawDefinition, structureId: structureId });
    if (result.error)
        return result;
    var structure = result.structure;
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    var positionAssignments = structureAssignedDrawPositions({ structure: structure }).positionAssignments;
    var drawSize = (positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.length) || 0;
    if (seedsCount > drawSize)
        return { error: SEEDSCOUNT_GREATER_THAN_DRAW_SIZE };
    var roundRobinGroupsCount = (_b = structure.structures) === null || _b === void 0 ? void 0 : _b.length;
    var groupSeedingThreshold = isConvertableInteger(seedingProfile === null || seedingProfile === void 0 ? void 0 : seedingProfile.groupSeedingThreshold) &&
        (seedingProfile === null || seedingProfile === void 0 ? void 0 : seedingProfile.groupSeedingThreshold);
    var seedGroups = (_c = getSeedGroups({
        roundRobinGroupsCount: roundRobinGroupsCount,
        drawSize: drawSize,
    })) === null || _c === void 0 ? void 0 : _c.seedGroups;
    var maxSeedsCount = getSeedsCount({
        policyDefinitions: appliedPolicies,
        requireParticipantCount: requireParticipantCount,
        drawSizeProgression: drawSizeProgression,
        participantsCount: participantsCount,
        drawSize: drawSize,
    }).seedsCount;
    if (maxSeedsCount &&
        (appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_SEEDING]) &&
        seedsCount > maxSeedsCount &&
        enforcePolicyLimits) {
        seedsCount = maxSeedsCount;
    }
    structure.seedLimit = seedsCount;
    structure.seedAssignments = generateRange(1, seedsCount + 1).map(function (seedNumber) {
        var seedGroup = seedGroups === null || seedGroups === void 0 ? void 0 : seedGroups.find(function (seedGroup) {
            return seedGroup.includes(seedNumber);
        });
        var groupSeedValue = seedGroup && Math.min.apply(Math, __spreadArray([], __read(seedGroup), false));
        var seedValue = groupSeedingThreshold && seedNumber >= groupSeedingThreshold
            ? groupSeedValue
            : seedNumber;
        return {
            participantId: undefined,
            seedNumber: seedNumber,
            seedValue: seedValue,
        };
    });
    modifyDrawNotice({ drawDefinition: drawDefinition, structureIds: [structureId] });
    return __assign(__assign({}, SUCCESS), { seedLimit: seedsCount });
}

function prepareStage(params) {
    var _a;
    var stack = 'prepareStage';
    var seedsCount = params.seedsCount;
    var preparedStructureIds = params.preparedStructureIds || [];
    var provisionalPositioning = params.provisionalPositioning, inContextDrawMatchUps = params.inContextDrawMatchUps, tournamentRecord = params.tournamentRecord, appliedPolicies = params.appliedPolicies, qualifyingOnly = params.qualifyingOnly, drawDefinition = params.drawDefinition, seedingProfile = params.seedingProfile, matchUpsMap = params.matchUpsMap, automated = params.automated, placeByes = params.placeByes, drawType = params.drawType, drawSize = params.drawSize, entries = params.entries, event = params.event, _b = params.enforcePolicyLimits, enforcePolicyLimits = _b === void 0 ? true : _b, seedAssignmentProfile = params.seedAssignmentProfile, // mainly used by mocksEngine for scenario testing
    _c = params.seedByRanking, // mainly used by mocksEngine for scenario testing
    seedByRanking = _c === void 0 ? true : _c, seededParticipants = params.seededParticipants, assignSeedsCount = params.assignSeedsCount, // used for testing bye placement next to seeds
    seedingScaleName = params.seedingScaleName, _d = params.stageSequence, stageSequence = _d === void 0 ? 1 : _d, roundTarget = params.roundTarget, stage = params.stage;
    var eventType = event === null || event === void 0 ? void 0 : event.eventType;
    var stageEntries = entries.filter(function (entry) {
        var _a, _b;
        var entryRoundTarget = (_b = (_a = findExtension({
            name: ROUND_TARGET,
            element: entry,
        })) === null || _a === void 0 ? void 0 : _a.extension) === null || _b === void 0 ? void 0 : _b.value;
        return ((!entry.entryStage || entry.entryStage === stage) &&
            (!stageSequence ||
                !entry.entryStageSequence ||
                entry.entryStageSequence === stageSequence) &&
            (!roundTarget || !entryRoundTarget || entryRoundTarget === roundTarget) &&
            DIRECT_ENTRY_STATUSES.includes(entry.entryStatus));
    });
    if (seededParticipants)
        seedsCount = seededParticipants.length;
    if (seedsCount > drawSize)
        seedsCount = drawSize;
    if (seedsCount > stageEntries.length)
        seedsCount = stageEntries.length;
    var structures = getDrawStructures({
        drawDefinition: drawDefinition,
        stageSequence: stageSequence,
        roundTarget: roundTarget,
        stage: stage,
    }).structures;
    var multipleStructures = ((structures === null || structures === void 0 ? void 0 : structures.length) || 0) > 1;
    var structure = structures === null || structures === void 0 ? void 0 : structures.find(function (_a) {
        var structureId = _a.structureId;
        return !preparedStructureIds.includes(structureId);
    });
    if (!structure)
        return decorateResult({ result: { error: STRUCTURE_NOT_FOUND }, stack: stack });
    var structureId = structure === null || structure === void 0 ? void 0 : structure.structureId;
    var seedBlockInfo = structure
        ? getValidSeedBlocks({
            provisionalPositioning: provisionalPositioning,
            appliedPolicies: appliedPolicies,
            drawDefinition: drawDefinition,
            seedingProfile: seedingProfile,
            structure: structure,
        })
        : undefined;
    var seedLimit = initializeStructureSeedAssignments({
        participantsCount: stageEntries.length,
        enforcePolicyLimits: enforcePolicyLimits,
        appliedPolicies: appliedPolicies,
        drawDefinition: drawDefinition,
        seedingProfile: seedingProfile,
        structureId: structureId,
        seedsCount: seedsCount,
    }).seedLimit;
    if (seedLimit && seedLimit < seedsCount)
        seedsCount = seedLimit;
    var enteredParticipantIds = entries.map(getParticipantId);
    if (seededParticipants) {
        seededParticipants
            .filter(function (_a) {
            var participantId = _a.participantId;
            return enteredParticipantIds.includes(participantId);
        })
            .filter(function (seededParticipant) {
            return !seededParticipant.seedNumber ||
                seededParticipant.seedNumber <= seededParticipants.length;
        })
            .sort(function (a, b) {
            if (a.seedNumber < b.seedNumber)
                return -1;
            if (a.seedNumber < b.seedNumber)
                return 1;
            return 0;
        })
            .forEach(function (seededParticipant) {
            var participantId = seededParticipant.participantId, seedNumber = seededParticipant.seedNumber, seedValue = seededParticipant.seedValue;
            assignSeed({
                provisionalPositioning: provisionalPositioning,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                seedingProfile: seedingProfile,
                participantId: participantId,
                seedBlockInfo: seedBlockInfo,
                structureId: structureId,
                seedNumber: seedNumber,
                seedValue: seedValue,
                event: event,
            });
        });
    }
    else if (event || seedingScaleName) {
        // if no seededParticipants have been defined, seed by seeding scale or ranking scale, if present
        var _e = (event === null || event === void 0 ? void 0 : event.category) || {}, categoryName = _e.categoryName, ageCategoryCode = _e.ageCategoryCode;
        var seedingScaleAttributes = {
            scaleType: SEEDING$1,
            scaleName: seedingScaleName || categoryName || ageCategoryCode || event.eventId,
            eventType: eventType,
        };
        var scaledEntries = getScaledEntries({
            scaleAttributes: seedingScaleAttributes,
            tournamentRecord: tournamentRecord,
            stageSequence: stageSequence,
            entries: entries,
            stage: stage,
        }).scaledEntries;
        if (!(scaledEntries === null || scaledEntries === void 0 ? void 0 : scaledEntries.length) && seedByRanking) {
            var rankingScaleAttributes = {
                scaleName: categoryName || ageCategoryCode,
                scaleType: RANKING$1,
                eventType: eventType,
            };
            (scaledEntries = getScaledEntries({
                scaleAttributes: rankingScaleAttributes,
                tournamentRecord: tournamentRecord,
                stageSequence: stageSequence,
                entries: entries,
                stage: stage,
            }).scaledEntries);
        }
        var scaledEntriesCount = (_a = scaledEntries === null || scaledEntries === void 0 ? void 0 : scaledEntries.length) !== null && _a !== void 0 ? _a : 0;
        if (scaledEntriesCount < seedsCount)
            seedsCount = scaledEntriesCount;
        scaledEntries === null || scaledEntries === void 0 ? void 0 : scaledEntries.filter(function (_a) {
            var participantId = _a.participantId;
            return enteredParticipantIds.includes(participantId);
        }).slice(0, assignSeedsCount || seedsCount).forEach(function (scaledEntry, index) {
            var seedNumber = index + 1;
            var participantId = scaledEntry.participantId, scaleValue = scaledEntry.scaleValue;
            var seedValue = (seedAssignmentProfile === null || seedAssignmentProfile === void 0 ? void 0 : seedAssignmentProfile[seedNumber]) || scaleValue || seedNumber;
            assignSeed({
                provisionalPositioning: provisionalPositioning,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                seedingProfile: seedingProfile,
                participantId: participantId,
                structureId: structureId,
                seedNumber: seedNumber,
                seedValue: seedValue,
                event: event,
            });
        });
    }
    var conflicts = [];
    var positionAssignments;
    var positioningReport;
    if (automated !== false &&
        drawType !== AD_HOC &&
        !(qualifyingOnly && stage !== QUALIFYING)) {
        var seedsOnly = typeof automated === 'object' && automated.seedsOnly;
        // if { seedsOnly: true } then only seeds and an Byes releated to seeded positions are placed
        var result = automatedPositioning({
            inContextDrawMatchUps: inContextDrawMatchUps,
            multipleStructures: multipleStructures,
            tournamentRecord: tournamentRecord,
            appliedPolicies: appliedPolicies,
            drawDefinition: drawDefinition,
            seedingProfile: seedingProfile,
            structureId: structureId,
            matchUpsMap: matchUpsMap,
            placeByes: placeByes,
            seedLimit: seedLimit,
            seedsOnly: seedsOnly,
            drawSize: drawSize,
            drawType: drawType,
            event: event,
        });
        if (result.conflicts)
            conflicts = result === null || result === void 0 ? void 0 : result.conflicts;
        positionAssignments = result === null || result === void 0 ? void 0 : result.positionAssignments;
        positioningReport = result === null || result === void 0 ? void 0 : result.positioningReport;
        if (result.error) {
            return decorateResult({ result: result, stack: stack });
        }
    }
    return {
        positionAssignments: positionAssignments,
        positioningReport: positioningReport,
        stageEntries: stageEntries,
        structureId: structureId,
        seedsCount: seedsCount,
        conflicts: conflicts,
    };
}

var _a$c, _b$3;
var POLICY_SEEDING_DEFAULT = (_a$c = {},
    _a$c[POLICY_TYPE_SEEDING] = {
        validSeedPositions: { ignore: true },
        duplicateSeedNumbers: true,
        drawSizeProgression: true,
        seedingProfile: {
            drawTypes: (_b$3 = {},
                _b$3[ROUND_ROBIN_WITH_PLAYOFF] = { positioning: WATERFALL },
                _b$3[ROUND_ROBIN] = { positioning: WATERFALL },
                _b$3),
            positioning: SEPARATE,
        },
        policyName: 'USTA SEEDING',
        seedsCountThresholds: [
            { drawSize: 4, minimumParticipantCount: 3, seedsCount: 2 },
            { drawSize: 16, minimumParticipantCount: 12, seedsCount: 4 },
            { drawSize: 32, minimumParticipantCount: 24, seedsCount: 8 },
            { drawSize: 64, minimumParticipantCount: 48, seedsCount: 16 },
            { drawSize: 128, minimumParticipantCount: 96, seedsCount: 32 },
            { drawSize: 256, minimumParticipantCount: 192, seedsCount: 64 },
        ],
    },
    _a$c);

function generateDrawDefinition(params) {
    var _a, e_1, _b, e_2, _c, e_3, _d, e_4, _e, _f, e_5, _g, e_6, _h, _j;
    var _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31;
    var stack = 'generateDrawDefinition';
    var _32 = params.considerEventEntries, considerEventEntries = _32 === void 0 ? true : _32, // in the absence of drawSize and drawEntries, look to event.entries
    ignoreAllowedDrawTypes = params.ignoreAllowedDrawTypes, voluntaryConsolation = params.voluntaryConsolation, hydrateCollections = params.hydrateCollections, ignoreStageSpace = params.ignoreStageSpace, tournamentRecord = params.tournamentRecord, qualifyingOnly = params.qualifyingOnly, tieFormatName = params.tieFormatName, drawEntries = params.drawEntries, placeByes = params.placeByes, event = params.event;
    var isMock = (_k = params.isMock) !== null && _k !== void 0 ? _k : true;
    var idPrefix = params.idPrefix;
    var appliedPolicies = (_l = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
        event: event,
    }).appliedPolicies) !== null && _l !== void 0 ? _l : {};
    var policyDefinitions = makeDeepCopy((_m = params.policyDefinitions) !== null && _m !== void 0 ? _m : {}, false, true);
    var drawTypeCoercion = (_o = params.drawTypeCoercion) !== null && _o !== void 0 ? _o : getDrawTypeCoercion({
        drawType: params.drawType,
        policyDefinitions: policyDefinitions,
        appliedPolicies: appliedPolicies,
    });
    var drawType = (drawTypeCoercion && params.drawSize === 2 && SINGLE_ELIMINATION) || params.drawType || SINGLE_ELIMINATION;
    var seedingPolicy = (_p = policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_SEEDING]) !== null && _p !== void 0 ? _p : appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_SEEDING];
    var seedingProfile = (_t = (_q = params.seedingProfile) !== null && _q !== void 0 ? _q : (_s = (_r = seedingPolicy === null || seedingPolicy === void 0 ? void 0 : seedingPolicy.seedingProfile) === null || _r === void 0 ? void 0 : _r.drawTypes) === null || _s === void 0 ? void 0 : _s[drawType]) !== null && _t !== void 0 ? _t : seedingPolicy === null || seedingPolicy === void 0 ? void 0 : seedingPolicy.seedingProfile;
    // extend policyDefinitions only if a seedingProfile was specified in params
    if (params.seedingProfile) {
        if (!policyDefinitions[POLICY_TYPE_SEEDING]) {
            policyDefinitions[POLICY_TYPE_SEEDING] = __assign({}, POLICY_SEEDING_DEFAULT[POLICY_TYPE_SEEDING]);
        }
        policyDefinitions[POLICY_TYPE_SEEDING].seedingProfile = seedingProfile;
    }
    // get participants both for entry validation and for automated placement
    // automated placement requires them to be "inContext" for avoidance policies to work
    var _33 = getParticipants({
        withIndividualParticipants: true,
        convertExtensions: true,
        internalUse: true,
        tournamentRecord: tournamentRecord,
    }), participants = _33.participants, participantMap = _33.participantMap;
    var enforceGender = (_x = (_u = params.enforceGender) !== null && _u !== void 0 ? _u : (_w = (_v = policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_MATCHUP_ACTIONS]) === null || _v === void 0 ? void 0 : _v.participants) === null || _w === void 0 ? void 0 : _w.enforceGender) !== null && _x !== void 0 ? _x : (_z = (_y = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_MATCHUP_ACTIONS]) === null || _y === void 0 ? void 0 : _y.participants) === null || _z === void 0 ? void 0 : _z.enforceGender;
    // if tournamentRecord is provided, and unless instructed to ignore valid types,
    // check for restrictions on allowed drawTypes
    var allowedDrawTypes = !ignoreAllowedDrawTypes &&
        tournamentRecord &&
        getAllowedDrawTypes({
            tournamentRecord: tournamentRecord,
            categoryType: (_0 = event === null || event === void 0 ? void 0 : event.category) === null || _0 === void 0 ? void 0 : _0.categoryType,
            categoryName: (_1 = event === null || event === void 0 ? void 0 : event.category) === null || _1 === void 0 ? void 0 : _1.categoryName,
        });
    if ((allowedDrawTypes === null || allowedDrawTypes === void 0 ? void 0 : allowedDrawTypes.length) && !allowedDrawTypes.includes(drawType)) {
        return decorateResult({ result: { error: INVALID_DRAW_TYPE }, stack: stack });
    }
    var eventEntries = (_3 = (_2 = event === null || event === void 0 ? void 0 : event.entries) === null || _2 === void 0 ? void 0 : _2.filter(function (entry) { return entry.entryStatus && __spreadArray(__spreadArray([], __read(STRUCTURE_SELECTED_STATUSES), false), [QUALIFIER], false).includes(entry.entryStatus); })) !== null && _3 !== void 0 ? _3 : [];
    var consideredEntries = ((qualifyingOnly && []) ||
        drawEntries ||
        (considerEventEntries ? eventEntries : [])).filter(function (_a) {
        var entryStage = _a.entryStage;
        return !entryStage || entryStage === MAIN;
    });
    // entries participantTypes must correspond with eventType
    // this is only possible if the event is provided
    var validEntriesResult = event &&
        participants &&
        checkValidEntries({
            consideredEntries: consideredEntries,
            appliedPolicies: appliedPolicies,
            participantMap: participantMap,
            enforceGender: enforceGender,
            participants: participants,
            event: event,
        });
    if (validEntriesResult === null || validEntriesResult === void 0 ? void 0 : validEntriesResult.error)
        return decorateResult({ result: validEntriesResult, stack: stack });
    var derivedDrawSize = !params.drawSize &&
        consideredEntries.length &&
        ![AD_HOC, DOUBLE_ELIMINATION, FEED_IN$1, ROUND_ROBIN, ROUND_ROBIN_WITH_PLAYOFF].includes(drawType) &&
        nextPowerOf2(consideredEntries.length);
    // coersion of drawSize and seedsCount to integers
    var drawSize = derivedDrawSize ||
        (params.drawSize && isConvertableInteger(params.drawSize) && ensureInt(params.drawSize)) ||
        false; // required for isNaN check
    if (isNaN(drawSize) && drawType !== AD_HOC) {
        return decorateResult({
            result: { error: MISSING_DRAW_SIZE },
            stack: stack,
        });
    }
    var seedsCount = typeof params.seedsCount !== 'number' ? ensureInt((_4 = params.seedsCount) !== null && _4 !== void 0 ? _4 : 0) : (_5 = params.seedsCount) !== null && _5 !== void 0 ? _5 : 0;
    var eventType = event === null || event === void 0 ? void 0 : event.eventType;
    var matchUpType = (_6 = params.matchUpType) !== null && _6 !== void 0 ? _6 : eventType;
    var existingDrawDefinition = params.drawId
        ? (_7 = event === null || event === void 0 ? void 0 : event.drawDefinitions) === null || _7 === void 0 ? void 0 : _7.find(function (d) { return d.drawId === params.drawId; })
        : undefined;
    // drawDefinition cannot have both tieFormat and matchUpFormat
    var tieFormat = params.tieFormat, matchUpFormat = params.matchUpFormat;
    // TODO: implement use of tieFormatId and tieFormats array
    if (matchUpType === TEAM && eventType === TEAM) {
        // if there is an existingDrawDefinition which has a tieFormat on MAIN structure
        // use this tieFormat ONLY when no tieFormat is specified in params
        var existingMainTieFormat = (_9 = (_8 = existingDrawDefinition === null || existingDrawDefinition === void 0 ? void 0 : existingDrawDefinition.structures) === null || _8 === void 0 ? void 0 : _8.find(function (_a) {
            var stage = _a.stage;
            return stage === MAIN;
        })) === null || _9 === void 0 ? void 0 : _9.tieFormat;
        tieFormat =
            tieFormat ||
                existingMainTieFormat ||
                // if tieFormatName is provided and it matches the name of the tieFormat attached to parent event...
                (tieFormatName && ((_10 = event === null || event === void 0 ? void 0 : event.tieFormat) === null || _10 === void 0 ? void 0 : _10.tieFormatName) === tieFormatName && event.tieFormat) ||
                // if the tieFormatName is not found in the factory then will use default
                (tieFormatName &&
                    tieFormatDefaults({
                        namedFormat: tieFormatName,
                        hydrateCollections: hydrateCollections,
                        isMock: isMock,
                        event: event,
                    })) ||
                (
                // if no tieFormat is found on event then will use default
                event === null || event === void 0 ? void 0 : event.tieFormat) ||
                tieFormatDefaults({ event: event, isMock: isMock, hydrateCollections: hydrateCollections });
        matchUpFormat = undefined;
    }
    else if (!matchUpFormat) {
        tieFormat = undefined;
        if (!(event === null || event === void 0 ? void 0 : event.matchUpFormat)) {
            matchUpFormat = FORMAT_STANDARD;
        }
    }
    if (tieFormat) {
        var result = validateTieFormat({
            gender: event === null || event === void 0 ? void 0 : event.gender,
            enforceGender: enforceGender,
            tieFormat: tieFormat,
        });
        if (result.error)
            return decorateResult({ result: result, stack: stack });
    }
    var invalidDrawId = params.drawId && typeof params.drawId !== 'string';
    if (invalidDrawId)
        return decorateResult({ result: { error: INVALID_VALUES }, stack: stack });
    // ---------------------------------------------------------------------------
    // Begin construction of drawDefinition
    if (existingDrawDefinition && drawType !== existingDrawDefinition.drawType)
        existingDrawDefinition.drawType = drawType;
    var drawDefinition = existingDrawDefinition !== null && existingDrawDefinition !== void 0 ? existingDrawDefinition : newDrawDefinition({
        drawType: drawType,
        drawId: params.drawId,
        processCodes: params.processCodes,
    });
    // if there is a defined matchUpFormat/tieFormat only attach to drawDefinition...
    // ...when there is not an equivalent definition on the parent event
    if (matchUpFormat || tieFormat) {
        var equivalentInScope = (matchUpFormat && (event === null || event === void 0 ? void 0 : event.matchUpFormat) === matchUpFormat) ||
            ((event === null || event === void 0 ? void 0 : event.tieFormat) && tieFormat && JSON.stringify(event.tieFormat) === JSON.stringify(tieFormat));
        // if an equivalent matchUpFormat or tieFormat is attached to the event
        // there is no need to attach to the drawDefinition
        if (!equivalentInScope) {
            if (tieFormat) {
                var result = checkTieFormat({ tieFormat: tieFormat });
                if (result.error)
                    return decorateResult({ result: result, stack: stack });
                drawDefinition.tieFormat = (_11 = result.tieFormat) !== null && _11 !== void 0 ? _11 : tieFormat;
            }
            else if (matchUpFormat) {
                var result = setMatchUpMatchUpFormat({
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    matchUpFormat: matchUpFormat,
                    event: event,
                });
                if (result.error) {
                    return {
                        error: result.error,
                        info: 'matchUpFormat or tieFormat error',
                    };
                }
            }
            if (matchUpType)
                drawDefinition.matchUpType = matchUpType;
        }
    }
    // ---------------------------------------------------------------------------
    // Attach policies to the drawDefinition
    // if there is an avoidance policy on the event, it must be preserved in the drawDefinition
    // if there is an avoidance policy in policyDefinitions, it will override
    // avoidance policies on the event can be changed (if location used for UI)
    var policiesToAttach = (_a = {},
        _a[POLICY_TYPE_AVOIDANCE] = appliedPolicies[POLICY_TYPE_AVOIDANCE],
        _a);
    if (policyDefinitions) {
        if (typeof policyDefinitions !== 'object') {
            return decorateResult({
                info: 'policyDefinitions must be an object',
                result: { error: INVALID_VALUES },
                stack: stack,
            });
        }
        else {
            try {
                for (var _34 = __values(Object.keys(policyDefinitions)), _35 = _34.next(); !_35.done; _35 = _34.next()) {
                    var key = _35.value;
                    if (JSON.stringify(appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[key]) !== JSON.stringify(policyDefinitions[key])) {
                        policiesToAttach[key] = policyDefinitions[key];
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_35 && !_35.done && (_b = _34.return)) _b.call(_34);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (Object.keys(policiesToAttach).length) {
                // attach any policyDefinitions which have been provided and are not already present
                attachPolicies({
                    policyDefinitions: policiesToAttach,
                    drawDefinition: drawDefinition,
                });
                Object.assign(appliedPolicies, policiesToAttach);
            }
        }
    }
    else if (policiesToAttach.avoidance) {
        attachPolicies({ drawDefinition: drawDefinition, policyDefinitions: policiesToAttach });
    }
    if (!appliedPolicies[POLICY_TYPE_SEEDING] && !policyDefinitions[POLICY_TYPE_SEEDING]) {
        attachPolicies({
            policyDefinitions: POLICY_SEEDING_DEFAULT,
            drawDefinition: drawDefinition,
        });
        Object.assign(appliedPolicies, POLICY_SEEDING_DEFAULT);
    }
    // ---------------------------------------------------------------------------
    // find existing MAIN structureId if existingDrawDefinition
    var structureId = (_13 = (_12 = existingDrawDefinition === null || existingDrawDefinition === void 0 ? void 0 : existingDrawDefinition.structures) === null || _12 === void 0 ? void 0 : _12.find(function (structure) { return structure.stage === MAIN && structure.stageSequence === 1; })) === null || _13 === void 0 ? void 0 : _13.structureId;
    var entries = drawEntries !== null && drawEntries !== void 0 ? drawEntries : eventEntries;
    var positioningReports = [];
    var drawTypeResult;
    var conflicts = [];
    var generateQualifyingPlaceholder = params.qualifyingPlaceholder && !((_14 = params.qualifyingProfiles) === null || _14 === void 0 ? void 0 : _14.length) && !existingDrawDefinition;
    var existingQualifyingStructures = existingDrawDefinition
        ? (_15 = existingDrawDefinition.structures) === null || _15 === void 0 ? void 0 : _15.filter(function (structure) { return structure.stage === QUALIFYING; })
        : [];
    var existingQualifyingPlaceholderStructureId = (existingQualifyingStructures === null || existingQualifyingStructures === void 0 ? void 0 : existingQualifyingStructures.length) === 1 &&
        !((_16 = existingQualifyingStructures[0].matchUps) === null || _16 === void 0 ? void 0 : _16.length) &&
        existingQualifyingStructures[0].structureId;
    if (existingQualifyingPlaceholderStructureId) {
        var qualifyingProfiles = params.qualifyingProfiles;
        var qualifyingResult = (qualifyingProfiles === null || qualifyingProfiles === void 0 ? void 0 : qualifyingProfiles.length)
            ? generateQualifyingStructures({
                uuids: params.uuids,
                qualifyingProfiles: qualifyingProfiles,
                appliedPolicies: appliedPolicies,
                idPrefix: idPrefix,
                isMock: isMock,
            })
            : undefined;
        if (qualifyingResult === null || qualifyingResult === void 0 ? void 0 : qualifyingResult.error) {
            return qualifyingResult;
        }
        drawDefinition.structures = (_17 = drawDefinition.structures) === null || _17 === void 0 ? void 0 : _17.filter(function (_a) {
            var structureId = _a.structureId;
            return structureId !== existingQualifyingPlaceholderStructureId;
        });
        drawDefinition.links = (_18 = drawDefinition.links) === null || _18 === void 0 ? void 0 : _18.filter(function (_a) {
            var source = _a.source;
            return source.structureId !== existingQualifyingPlaceholderStructureId;
        });
        var _36 = qualifyingResult !== null && qualifyingResult !== void 0 ? qualifyingResult : {}, qualifiersCount = _36.qualifiersCount, qualifyingDrawPositionsCount = _36.qualifyingDrawPositionsCount, qualifyingDetails = _36.qualifyingDetails;
        if (qualifyingDrawPositionsCount) {
            if (qualifyingResult === null || qualifyingResult === void 0 ? void 0 : qualifyingResult.structures) {
                (_19 = drawDefinition.structures) === null || _19 === void 0 ? void 0 : _19.push.apply(_19, __spreadArray([], __read(qualifyingResult.structures), false));
            }
            if (qualifyingResult === null || qualifyingResult === void 0 ? void 0 : qualifyingResult.links) {
                (_20 = drawDefinition.links) === null || _20 === void 0 ? void 0 : _20.push.apply(_20, __spreadArray([], __read(qualifyingResult.links), false));
            }
        }
        var mainStructure = (_21 = drawDefinition.structures) === null || _21 === void 0 ? void 0 : _21.find(function (_a) {
            var stage = _a.stage, stageSequence = _a.stageSequence;
            return stage === MAIN && stageSequence === 1;
        });
        var existingQualifiersCount = getQualifiersCount({
            stageSequence: 1,
            drawDefinition: drawDefinition,
            structureId: structureId,
            stage: MAIN,
        }).qualifiersCount;
        var derivedQualifiersCount = Math.max(qualifiersCount !== null && qualifiersCount !== void 0 ? qualifiersCount : 0, existingQualifiersCount !== null && existingQualifiersCount !== void 0 ? existingQualifiersCount : 0);
        var result = setStageQualifiersCount({
            qualifiersCount: derivedQualifiersCount,
            drawDefinition: drawDefinition,
            stage: MAIN,
        });
        if (result.error)
            return result;
        result = setStageDrawSize({
            drawSize: qualifyingDrawPositionsCount,
            stage: QUALIFYING,
            drawDefinition: drawDefinition,
        });
        if (result.error)
            return result;
        try {
            for (var _37 = __values((drawEntries !== null && drawEntries !== void 0 ? drawEntries : []).filter(function (_a) {
                var entryStage = _a.entryStage;
                return entryStage === QUALIFYING;
            })), _38 = _37.next(); !_38.done; _38 = _37.next()) {
                var entry = _38.value;
                var entryData = __assign(__assign({}, entry), { entryStage: (_22 = entry.entryStage) !== null && _22 !== void 0 ? _22 : MAIN, drawDefinition: drawDefinition });
                // ignore errors (EXITING_PARTICIPANT)
                addDrawEntry(entryData);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_38 && !_38.done && (_c = _37.return)) _c.call(_37);
            }
            finally { if (e_2) throw e_2.error; }
        }
        try {
            for (var _39 = __values(qualifyingDetails || []), _40 = _39.next(); !_40.done; _40 = _39.next()) {
                var qualifyingDetail = _40.value;
                var qualifyingRoundNumber = qualifyingDetail.finalQualifyingRoundNumber, qualifyingStructureId = qualifyingDetail.finalQualifyingStructureId, targetEntryRound = qualifyingDetail.roundTarget, finishingPositions = qualifyingDetail.finishingPositions, linkType = qualifyingDetail.linkType;
                var link = mainStructure &&
                    ((_23 = generateQualifyingLink({
                        targetStructureId: mainStructure.structureId,
                        sourceStructureId: qualifyingStructureId,
                        sourceRoundNumber: qualifyingRoundNumber,
                        finishingPositions: finishingPositions,
                        targetEntryRound: targetEntryRound,
                        linkType: linkType,
                    })) === null || _23 === void 0 ? void 0 : _23.link);
                if (link === null || link === void 0 ? void 0 : link.error)
                    return link;
                if (link) {
                    if (!drawDefinition.links)
                        drawDefinition.links = [];
                    drawDefinition.links.push(link);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_40 && !_40.done && (_d = _39.return)) _d.call(_39);
            }
            finally { if (e_3) throw e_3.error; }
        }
        drawTypeResult = { drawDefinition: drawDefinition };
    }
    else {
        drawTypeResult = generateDrawTypeAndModifyDrawDefinition(__assign(__assign({}, params), { modifyOriginal: false, tournamentRecord: tournamentRecord, appliedPolicies: appliedPolicies, drawDefinition: drawDefinition, matchUpFormat: matchUpFormat, matchUpType: matchUpType, tieFormat: tieFormat, drawSize: drawSize, isMock: isMock }));
        if (drawTypeResult.error) {
            return decorateResult({ result: drawTypeResult, stack: stack });
        }
        drawDefinition = drawTypeResult.drawDefinition;
        try {
            // add all entries to the draw
            for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                var entry = entries_1_1.value;
                // if drawEntries and entryStage !== stage ignore
                if (drawEntries && entry.entryStage && entry.entryStage !== MAIN)
                    continue;
                var entryData = __assign(__assign({}, entry), { ignoreStageSpace: ignoreStageSpace !== null && ignoreStageSpace !== void 0 ? ignoreStageSpace : drawType === AD_HOC, entryStage: (_24 = entry.entryStage) !== null && _24 !== void 0 ? _24 : MAIN, drawDefinition: drawDefinition, drawType: drawType });
                var result = addDrawEntry(entryData);
                if (drawEntries && result.error) {
                    // only report errors with drawEntries
                    // if entries are taken from event.entries assume stageSpace is not available
                    return decorateResult({ result: result, stack: stack });
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (entries_1_1 && !entries_1_1.done && (_e = entries_1.return)) _e.call(entries_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        // temporary until seeding is supported in LUCKY_DRAW
        if (drawType === LUCKY_DRAW)
            seedsCount = 0;
        var structureResult = prepareStage(__assign(__assign(__assign({}, drawTypeResult), params), { qualifyingOnly: !drawSize || qualifyingOnly, // ooo!! If there is no drawSize then MAIN is not being generated
            appliedPolicies: appliedPolicies, drawDefinition: drawDefinition, seedingProfile: seedingProfile, participants: participants, stage: MAIN, seedsCount: seedsCount, placeByes: placeByes, drawSize: drawSize, entries: entries }));
        if (structureResult.error && !structureResult.conflicts) {
            return structureResult;
        }
        if ((_25 = structureResult.positioningReport) === null || _25 === void 0 ? void 0 : _25.length)
            positioningReports.push((_f = {}, _f[MAIN] = structureResult.positioningReport, _f));
        structureId = structureResult.structureId;
        if (structureResult.conflicts)
            conflicts = structureResult.conflicts;
        if (drawType === AD_HOC && params.roundsCount) {
            var entries_2 = (_26 = event === null || event === void 0 ? void 0 : event.entries) === null || _26 === void 0 ? void 0 : _26.filter(function (_a) {
                var entryStage = _a.entryStage, entryStatus = _a.entryStatus;
                return (!entryStage || entryStage === MAIN) && entryStatus && STRUCTURE_SELECTED_STATUSES.includes(entryStatus);
            });
            var participantIds_1 = entries_2 === null || entries_2 === void 0 ? void 0 : entries_2.map(xa('participantId'));
            var matchUpsCount_1 = entries_2 ? Math.floor(entries_2.length / 2) : 0;
            generateRange(1, params.roundsCount + 1).forEach(function () {
                var _a, _b, _c;
                if (params.automated) {
                    var _d = (_a = params.drawMatic) !== null && _a !== void 0 ? _a : {}, restrictEntryStatus = _d.restrictEntryStatus, generateMatchUps = _d.generateMatchUps, structureId_1 = _d.structureId, matchUpIds = _d.matchUpIds, scaleName = _d.scaleName;
                    var matchUps = drawMatic({
                        eventType: (_c = (_b = params.drawMatic) === null || _b === void 0 ? void 0 : _b.eventType) !== null && _c !== void 0 ? _c : matchUpType,
                        generateMatchUps: generateMatchUps !== null && generateMatchUps !== void 0 ? generateMatchUps : true,
                        restrictEntryStatus: restrictEntryStatus,
                        tournamentRecord: tournamentRecord,
                        participantIds: participantIds_1,
                        drawDefinition: drawDefinition,
                        structureId: structureId_1,
                        matchUpIds: matchUpIds,
                        scaleName: scaleName, // custom rating name to seed dynamic ratings
                        idPrefix: idPrefix,
                        isMock: isMock,
                        event: event,
                    }).matchUps;
                    addAdHocMatchUps({
                        tournamentRecord: tournamentRecord,
                        drawDefinition: drawDefinition,
                        structureId: structureId_1,
                        matchUps: matchUps,
                    });
                }
                else {
                    var matchUps = generateAdHocMatchUps({
                        newRound: true,
                        drawDefinition: drawDefinition,
                        matchUpsCount: matchUpsCount_1,
                        idPrefix: idPrefix,
                        isMock: isMock,
                        event: event,
                    }).matchUps;
                    addAdHocMatchUps({
                        tournamentRecord: tournamentRecord,
                        drawDefinition: drawDefinition,
                        structureId: structureId,
                        matchUps: matchUps,
                    });
                }
            });
        }
    }
    var qualifyingConflicts = [];
    if (params.qualifyingProfiles) {
        var sequenceSort = function (a, b) { return a.stageSequence - b.stageSequence; };
        var roundTargetSort = function (a, b) { return a.roundTarget - b.roundTarget; };
        // keep track of structures already prepared in case of multiple matching structures
        var preparedStructureIds = [];
        var roundTarget = 1;
        params.qualifyingProfiles.sort(roundTargetSort);
        try {
            for (var _41 = __values(params.qualifyingProfiles), _42 = _41.next(); !_42.done; _42 = _41.next()) {
                var roundTargetProfile = _42.value;
                if (!Array.isArray(roundTargetProfile.structureProfiles))
                    return decorateResult({
                        info: mustBeAnArray('structureProfiles'),
                        result: { error: MISSING_VALUE },
                        stack: stack,
                    });
                roundTarget = roundTargetProfile.roundTarget || roundTarget;
                var sortedStructureProfiles = ((_27 = roundTargetProfile.structureProfiles) === null || _27 === void 0 ? void 0 : _27.sort(sequenceSort)) || [];
                var sequence = 1;
                try {
                    for (var sortedStructureProfiles_1 = (e_6 = void 0, __values(sortedStructureProfiles)), sortedStructureProfiles_1_1 = sortedStructureProfiles_1.next(); !sortedStructureProfiles_1_1.done; sortedStructureProfiles_1_1 = sortedStructureProfiles_1.next()) {
                        var structureProfile = sortedStructureProfiles_1_1.value;
                        var qualifyingRoundNumber = structureProfile.qualifyingRoundNumber, qualifyingPositions = structureProfile.qualifyingPositions, seededParticipants = structureProfile.seededParticipants, seedingScaleName = structureProfile.seedingScaleName, _43 = structureProfile.seedsCount, seedsCount_1 = _43 === void 0 ? 0 : _43, seedByRanking = structureProfile.seedByRanking, placeByes_1 = structureProfile.placeByes, drawSize_1 = structureProfile.drawSize;
                        var qualifyingStageResult = prepareStage(__assign(__assign(__assign({}, drawTypeResult), params), { seedingProfile: (_28 = structureProfile.seedingProfile) !== null && _28 !== void 0 ? _28 : seedingProfile, stageSequence: sequence, qualifyingRoundNumber: qualifyingRoundNumber, preparedStructureIds: preparedStructureIds, qualifyingPositions: qualifyingPositions, seededParticipants: seededParticipants, stage: QUALIFYING, seedingScaleName: seedingScaleName, appliedPolicies: appliedPolicies, drawDefinition: drawDefinition, qualifyingOnly: qualifyingOnly, seedByRanking: seedByRanking, participants: participants, roundTarget: roundTarget, seedsCount: seedsCount_1, placeByes: placeByes_1, drawSize: drawSize_1, entries: entries }));
                        if (qualifyingStageResult.error) {
                            return qualifyingStageResult;
                        }
                        if (qualifyingStageResult.structureId) {
                            preparedStructureIds.push(qualifyingStageResult.structureId);
                        }
                        sequence += 1;
                        if ((_29 = qualifyingStageResult.conflicts) === null || _29 === void 0 ? void 0 : _29.length)
                            qualifyingConflicts.push.apply(qualifyingConflicts, __spreadArray([], __read(qualifyingStageResult.conflicts), false));
                        if ((_30 = qualifyingStageResult.positioningReport) === null || _30 === void 0 ? void 0 : _30.length)
                            positioningReports.push((_j = {},
                                _j[QUALIFYING] = qualifyingStageResult.positioningReport,
                                _j));
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (sortedStructureProfiles_1_1 && !sortedStructureProfiles_1_1.done && (_h = sortedStructureProfiles_1.return)) _h.call(sortedStructureProfiles_1);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
                roundTarget += 1;
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_42 && !_42.done && (_g = _41.return)) _g.call(_41);
            }
            finally { if (e_5) throw e_5.error; }
        }
    }
    else if (structureId && generateQualifyingPlaceholder) {
        var qualifyingStructure = structureTemplate({
            structureName: constantToString(QUALIFYING),
            stage: QUALIFYING,
        });
        var link = generateQualifyingLink({
            sourceStructureId: qualifyingStructure.structureId,
            targetStructureId: structureId,
            sourceRoundNumber: 0,
            linkType: POSITION,
        }).link;
        if (!drawDefinition.structures)
            drawDefinition.structures = [];
        drawDefinition.structures.push(qualifyingStructure);
        if (!drawDefinition.links)
            drawDefinition.links = [];
        drawDefinition.links.push(link);
    }
    drawDefinition.drawName = (_31 = params.drawName) !== null && _31 !== void 0 ? _31 : (drawType && constantToString(drawType));
    if (typeof voluntaryConsolation === 'object' && drawSize >= 4) {
        addVoluntaryConsolationStructure(__assign(__assign({}, voluntaryConsolation), { drawDefinition: drawDefinition, matchUpType: matchUpType }));
    }
    return __assign(__assign({ existingDrawDefinition: !!existingDrawDefinition, qualifyingConflicts: qualifyingConflicts, positioningReports: positioningReports, drawDefinition: drawDefinition, structureId: structureId }, SUCCESS), { conflicts: conflicts });
}

/*
 * Flights are created by splitting event entries into groups.
 * The following split methods are supported.
 * In all cases event.entries are first sorted by some scaleValue.
 * scaleValue is derived from rankings or ratings or seedings.
 */
var SPLIT_LEVEL_BASED = 'splitLevelBased'; // Evenly chunk sorted entries
var SPLIT_WATERFALL = 'splitWaterfall'; // 1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4
var SPLIT_SHUTTLE = 'splitShuttle'; // 1,2,3,4,4,3,2,1,1,2,3,4,4,3,2,1
var flightConstants = {
    SPLIT_LEVEL_BASED: SPLIT_LEVEL_BASED,
    SPLIT_WATERFALL: SPLIT_WATERFALL,
    SPLIT_SHUTTLE: SPLIT_SHUTTLE,
};

function generateFlightProfile(params) {
    var _a, _b;
    var _c = params.drawNameRoot, drawNameRoot = _c === void 0 ? 'Flight' : _c, attachFlightProfile$1 = params.attachFlightProfile, tournamentRecord = params.tournamentRecord, scaleAttributes = params.scaleAttributes, scaleSortMethod = params.scaleSortMethod, deleteExisting = params.deleteExisting, sortDescending = params.sortDescending, _d = params.drawNames, drawNames = _d === void 0 ? [] : _d, flightsCount = params.flightsCount, splitMethod = params.splitMethod, _e = params.uuids, uuids = _e === void 0 ? [] : _e, event = params.event, stage = params.stage;
    if (!event)
        return { error: MISSING_EVENT };
    var eventEntries = (_a = event.entries) !== null && _a !== void 0 ? _a : [];
    var flightProfile = getFlightProfile({ event: event }).flightProfile;
    if (flightProfile && attachFlightProfile$1 && !deleteExisting) {
        return { error: EXISTING_PROFILE };
    }
    var scaledEntries = (_b = params.scaledEntries) !== null && _b !== void 0 ? _b : getScaledEntries({
        tournamentRecord: tournamentRecord,
        scaleAttributes: scaleAttributes,
        scaleSortMethod: scaleSortMethod,
        sortDescending: sortDescending,
        event: event,
        stage: stage,
    }).scaledEntries;
    var scaledEntryParticipantIds = scaledEntries.map(getParticipantId);
    var unscaledEntries = shuffleArray(eventEntries
        .filter(function (_a) {
        var participantId = _a.participantId;
        return !scaledEntryParticipantIds.includes(participantId);
    })
        .filter(function (entry) {
        return (!stage || !entry.entryStage || entry.entryStage === stage) &&
            (!entry.entryStatus || // absence of entryStatus is equivalent to DIRECT_ACCEPTANCE
                DIRECT_ENTRY_STATUSES.includes(entry.entryStatus));
    }));
    var flightEntries = scaledEntries.concat.apply(scaledEntries, __spreadArray([], __read(unscaledEntries), false));
    var entriesCount = flightEntries.length;
    // default is SPLIT_LEVEL_BASED - Evenly chunk sorted entries
    var chunkSize = Math.ceil(entriesCount / flightsCount);
    var splitEntries = chunkArray(flightEntries, chunkSize);
    if (splitMethod === SPLIT_WATERFALL) {
        // e.g. 1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4
        splitEntries = chunkByNth(flightEntries, flightsCount);
    }
    else if (splitMethod === SPLIT_SHUTTLE) {
        // e.g. 1,2,3,4,4,3,2,1,1,2,3,4,4,3,2,1
        splitEntries = chunkByNth(flightEntries, flightsCount, true);
    }
    function getDrawEntries(entriesChunk) {
        return (entriesChunk || [])
            .map(function (_a) {
            var participantId = _a.participantId, scaleValue = _a.scaleValue;
            var entry = eventEntries.find(function (entry) { return entry.participantId === participantId; });
            if ((entry === null || entry === void 0 ? void 0 : entry.scaleValue) && scaleValue)
                entry.scaleValue = scaleValue;
            return entry;
        })
            .sort(function (a, b) { return a.scaleValue - b.scaleValue; })
            .map(function (entry, i) {
            if (entry.scaleValue)
                entry.seedNumber = i + 1;
            return entry;
        });
    }
    var flights = generateRange(0, flightsCount).map(function (index) {
        var _a;
        var flightNumber = index + 1;
        return {
            flightNumber: flightNumber,
            drawId: (_a = uuids === null || uuids === void 0 ? void 0 : uuids.pop()) !== null && _a !== void 0 ? _a : UUID(),
            drawEntries: getDrawEntries(splitEntries[index]),
            drawName: ((drawNames === null || drawNames === void 0 ? void 0 : drawNames.length) && drawNames[index]) ||
                "".concat(drawNameRoot, " ").concat(flightNumber),
        };
    });
    var updatedFlightProfile = {
        scaleAttributes: scaleAttributes,
        splitMethod: splitMethod,
        flights: flights,
    };
    if (attachFlightProfile$1) {
        var result = attachFlightProfile({
            flightProfile: updatedFlightProfile,
            deleteExisting: deleteExisting,
            event: event,
        });
        return __assign({ splitEntries: (getDevContext() && splitEntries) || undefined }, result);
    }
    else {
        return __assign({ flightProfile: updatedFlightProfile }, SUCCESS);
    }
}

var ASC = 'ASC';
var ASCENDING = 'ASC';
var DESC = 'DESC';
var DESCENDING = 'DESC';
var sortingConstants = { ASC: ASC, ASCENDING: ASCENDING, DESC: DESC, DESCENDING: DESCENDING };

// by default if there are no scaleValues matching the scaleAccessor then participants will be assigned in the array order of [team].individidualParticipantIds
function generateLineUps(params) {
    var e_1, _a, e_2, _b;
    var _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    var tieFormat = params.tieFormat;
    var useDefaultEventRanking = params.useDefaultEventRanking, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, scaleAccessor = params.scaleAccessor, // e.g. { scaleType: 'RANKINGS', scaleName: 'U18', accessor: 'wtnRating', sortOrder: 'ASC' }
    singlesOnly = params.singlesOnly, // use singles scale for doubles events
    attach = params.attach, // boolean - when true attach LINEUPS extension to drawDefinition and add new PAIR participants (where necessary)
    event = params.event;
    if ((event === null || event === void 0 ? void 0 : event.eventType) !== TEAM_EVENT)
        return { error: INVALID_EVENT_TYPE };
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!tieFormat && !drawDefinition)
        return { error: DRAW_DEFINITION_NOT_FOUND };
    tieFormat = tieFormat !== null && tieFormat !== void 0 ? tieFormat : (_c = resolveTieFormat({ drawDefinition: drawDefinition, event: event })) === null || _c === void 0 ? void 0 : _c.tieFormat;
    if (validateTieFormat({ tieFormat: tieFormat }).error)
        return { error: INVALID_TIE_FORMAT };
    if (typeof scaleAccessor !== 'object' && !useDefaultEventRanking)
        return { error: INVALID_VALUES, context: { scaleAccessor: scaleAccessor } };
    var lineUps = {};
    var targetEntries = ((_e = (_d = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) !== null && _d !== void 0 ? _d : event === null || event === void 0 ? void 0 : event.entries) !== null && _e !== void 0 ? _e : []).filter(function (entry) { return (entry === null || entry === void 0 ? void 0 : entry.entryStatus) === DIRECT_ACCEPTANCE; });
    var participantIds = targetEntries.map(getParticipantId);
    var _p = getParticipants({
        withIndividualParticipants: true,
        withScaleValues: true,
        tournamentRecord: tournamentRecord,
    }).participants, participants = _p === void 0 ? [] : _p;
    var teamParticipants = participants.filter(function (_a) {
        var participantId = _a.participantId;
        return participantIds.includes(participantId);
    });
    var formatScaleType = function (type) { return (type === RANKING$1 ? 'rankings' : 'ratings'); };
    var defaultScaleName = (_g = (_f = event === null || event === void 0 ? void 0 : event.category) === null || _f === void 0 ? void 0 : _f.categoryName) !== null && _g !== void 0 ? _g : (_h = event === null || event === void 0 ? void 0 : event.category) === null || _h === void 0 ? void 0 : _h.ageCategoryCode;
    var _q = scaleAccessor || {}, _r = _q.scaleName, scaleName = _r === void 0 ? defaultScaleName : _r, _s = _q.scaleType, scaleType = _s === void 0 ? RANKING$1 : _s, sortOrder = _q.sortOrder, accessor = _q.accessor;
    var formattedScaleType = formatScaleType(scaleType);
    var getScaleValue = function (individualParticipant, matchUpType) {
        var _a, _b, _c;
        var matchUpTypeScales = (_a = individualParticipant[formattedScaleType]) === null || _a === void 0 ? void 0 : _a[matchUpType];
        // if { userDefaultEventRanking: true } fallback to SINGLES if no values for DOUBLES
        if (!matchUpTypeScales && useDefaultEventRanking) {
            matchUpTypeScales = (_b = individualParticipant[formattedScaleType]) === null || _b === void 0 ? void 0 : _b[SINGLES_MATCHUP];
        }
        if (Array.isArray(matchUpTypeScales)) {
            var scaleValue = (_c = matchUpTypeScales.find(function (scale) { return scale.scaleName === scaleName; })) === null || _c === void 0 ? void 0 : _c.scaleValue;
            if (isNumeric(scaleValue)) {
                return scaleValue;
            }
            else if (accessor && typeof scaleValue === 'object')
                return scaleValue[accessor];
        }
        return 0;
    };
    var sortMethod = function (a, b, matchUpType) {
        var x = sortOrder === DESCENDING ? b : a;
        var y = sortOrder === DESCENDING ? a : b;
        return getScaleValue(x, matchUpType) - getScaleValue(y, matchUpType);
    };
    var singlesScaleSort = function (a, b) { return sortMethod(a, b, SINGLES_MATCHUP); };
    var doublesScaleSort = function (a, b) { return sortMethod(a, b, DOUBLES_MATCHUP); };
    var participantIdPairs = [];
    var collectionDefinitions = (_j = tieFormat === null || tieFormat === void 0 ? void 0 : tieFormat.collectionDefinitions) !== null && _j !== void 0 ? _j : [];
    var _loop_1 = function (teamParticipant) {
        var e_3, _t;
        var singlesSort = (_l = (_k = teamParticipant.individualParticipants) === null || _k === void 0 ? void 0 : _k.sort(singlesScaleSort)) !== null && _l !== void 0 ? _l : [];
        var doublesSort = singlesOnly
            ? singlesSort
            : (_o = (_m = teamParticipant.individualParticipants) === null || _m === void 0 ? void 0 : _m.sort(doublesScaleSort)) !== null && _o !== void 0 ? _o : [];
        var participantAssignments = {};
        var _loop_2 = function (collectionDefinition) {
            var collectionParticipantIds = [];
            var collectionId = collectionDefinition.collectionId, matchUpCount = collectionDefinition.matchUpCount, matchUpType = collectionDefinition.matchUpType, gender = collectionDefinition.gender;
            var singlesMatchUp = matchUpType === SINGLES_MATCHUP;
            generateRange(0, matchUpCount).forEach(function (i) {
                var typeSort = singlesMatchUp ? singlesSort : doublesSort !== null && doublesSort !== void 0 ? doublesSort : [];
                var collectionPosition = i + 1;
                var participantIds = [];
                generateRange(0, singlesMatchUp ? 1 : 2).forEach(function (i) {
                    var _a;
                    var nextParticipantId = (_a = typeSort === null || typeSort === void 0 ? void 0 : typeSort.find(function (participant) {
                        var _a;
                        var targetGender = gender && (([MALE, FEMALE].includes(gender) && gender) || (gender === MIXED && [MALE, FEMALE][i]));
                        return ((!targetGender || targetGender === ((_a = participant.person) === null || _a === void 0 ? void 0 : _a.sex)) &&
                            !collectionParticipantIds.includes(participant.participantId));
                    })) === null || _a === void 0 ? void 0 : _a.participantId;
                    // keep track of participantIds which have already been assigned
                    if (nextParticipantId) {
                        participantIds.push(nextParticipantId);
                        collectionParticipantIds.push(nextParticipantId);
                        if (!participantAssignments[nextParticipantId])
                            participantAssignments[nextParticipantId] = [];
                        participantAssignments[nextParticipantId].push({
                            collectionPosition: collectionPosition,
                            collectionId: collectionId,
                        });
                    }
                });
                if (!singlesMatchUp)
                    participantIdPairs.push(participantIds);
            });
        };
        try {
            for (var collectionDefinitions_1 = (e_3 = void 0, __values(collectionDefinitions)), collectionDefinitions_1_1 = collectionDefinitions_1.next(); !collectionDefinitions_1_1.done; collectionDefinitions_1_1 = collectionDefinitions_1.next()) {
                var collectionDefinition = collectionDefinitions_1_1.value;
                _loop_2(collectionDefinition);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (collectionDefinitions_1_1 && !collectionDefinitions_1_1.done && (_t = collectionDefinitions_1.return)) _t.call(collectionDefinitions_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        var lineUp = Object.keys(participantAssignments).map(function (participantId) { return ({
            collectionAssignments: participantAssignments[participantId],
            participantId: participantId,
        }); });
        lineUps[teamParticipant.participantId] = lineUp;
    };
    try {
        for (var teamParticipants_1 = __values(teamParticipants), teamParticipants_1_1 = teamParticipants_1.next(); !teamParticipants_1_1.done; teamParticipants_1_1 = teamParticipants_1.next()) {
            var teamParticipant = teamParticipants_1_1.value;
            _loop_1(teamParticipant);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (teamParticipants_1_1 && !teamParticipants_1_1.done && (_a = teamParticipants_1.return)) _a.call(teamParticipants_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var participantsToAdd = [];
    try {
        for (var participantIdPairs_1 = __values(participantIdPairs), participantIdPairs_1_1 = participantIdPairs_1.next(); !participantIdPairs_1_1.done; participantIdPairs_1_1 = participantIdPairs_1.next()) {
            var pairParticipantIds = participantIdPairs_1_1.value;
            var existingPairParticipant = getPairedParticipant({
                tournamentParticipants: participants,
                participantIds: pairParticipantIds,
            }).participant;
            if (!existingPairParticipant) {
                var newPairParticipant = {
                    individualParticipantIds: pairParticipantIds,
                    participantRole: COMPETITOR,
                    participantType: PAIR,
                };
                participantsToAdd.push(newPairParticipant);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (participantIdPairs_1_1 && !participantIdPairs_1_1.done && (_b = participantIdPairs_1.return)) _b.call(participantIdPairs_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    if (attach) {
        while (participantsToAdd.length) {
            addParticipant({
                participant: participantsToAdd.pop(),
                tournamentRecord: tournamentRecord,
            });
        }
        var extension = { name: LINEUPS, value: lineUps };
        addExtension({ element: drawDefinition, extension: extension });
    }
    return __assign(__assign({}, SUCCESS), { lineUps: lineUps, participantsToAdd: participantsToAdd });
}

function generateCourts(params) {
    var _a, _b, _c, _d, _e;
    var _f;
    if (!params)
        return { error: MISSING_VALUE };
    var paramCheck = checkRequiredParameters(params, [
        (_a = { dates: false }, _a[VALIDATE] = function (value) { return Array.isArray(value) && value.every(isValidDateString); }, _a),
        (_b = { uuids: false }, _b[VALIDATE] = function (value) { return Array.isArray(value) && value.every(isString); }, _b),
        (_c = { startTime: false, endTime: false }, _c[VALIDATE] = isTimeString, _c),
        (_d = { idPrefix: false, namePrefix: false }, _d[VALIDATE] = isString, _d),
        (_e = { count: true }, _e[VALIDATE] = isNumeric, _e),
    ]);
    if (paramCheck.error)
        return paramCheck;
    var _g = (_f = params.tournamentRecord) !== null && _f !== void 0 ? _f : {}, startDate = _g.startDate, endDate = _g.endDate;
    var dates = params.dates || (startDate && endDate && generateDateRange(startDate, endDate)) || [];
    var courts = generateRange(1, params.count + 1).map(function (courtNumber) {
        var _a, _b, _c, _d, _e;
        return definedAttributes({
            courtId: (_c = (_b = (_a = params.uuids) === null || _a === void 0 ? void 0 : _a.pop()) !== null && _b !== void 0 ? _b : (params.idPrefix && "".concat(params.idPrefix, "-").concat(courtNumber))) !== null && _c !== void 0 ? _c : UUID(),
            courtName: (_e = (_d = params.courtNames) === null || _d === void 0 ? void 0 : _d.pop()) !== null && _e !== void 0 ? _e : (params.namePrefix && "".concat(params.namePrefix, " ").concat(courtNumber)),
            dateAvailability: dates.map(function (date) {
                var _a, _b;
                return ({
                    startTime: (_a = params.startTime) !== null && _a !== void 0 ? _a : '08:00',
                    endTime: (_b = params.endTime) !== null && _b !== void 0 ? _b : '20:00',
                    date: date,
                });
            }),
        });
    });
    return __assign(__assign({}, SUCCESS), { courts: courts });
}

function getCourtDateAvailability(_a) {
    var court = _a.court, date = _a.date;
    var targetDateAvailability = date &&
        court.dateAvailability.find(function (availability) {
            return sameDay(availability.date, date);
        });
    var defaultAvailability = court.dateAvailability.find(function (availability) { return !availability.date; });
    return targetDateAvailability || defaultAvailability;
}

function generateTimeSlots(_a) {
    var _b = _a.includeBookingTypes, includeBookingTypes = _b === void 0 ? [] : _b, courtDate = _a.courtDate;
    var timeSlots = [];
    var startTime = timeToDate(courtDate.startTime);
    (courtDate.bookings || [])
        .filter(function (booking) {
        return !booking.bookingType ||
            !includeBookingTypes.includes(booking.bookingType);
    })
        .sort(function (a, b) { return tidyTime(a.startTime).localeCompare(tidyTime(b.startTime)); })
        .forEach(function (booking) {
        var timeSlot = {
            startTime: extractTime(startTime.toISOString()),
            endTime: booking.startTime,
        };
        if (timeToDate(booking.startTime) > startTime) {
            timeSlots.push(timeSlot);
        }
        if (timeToDate(booking.endTime) > startTime) {
            startTime = timeToDate(booking.endTime);
        }
    });
    var timeSlot = {
        startTime: extractTime(startTime.toISOString()),
        endTime: courtDate.endTime,
    };
    if (timeToDate(courtDate.endTime) > startTime) {
        timeSlots.push(timeSlot);
    }
    return timeSlots;
}

function getEnoughTime(_a) {
    var averageMatchUpMinutes = _a.averageMatchUpMinutes, includeBookingTypes = _a.includeBookingTypes, periodStartTime = _a.periodStartTime, periodEndTime = _a.periodEndTime;
    var enoughTime = function (courtDate) {
        var timeSlots = generateTimeSlots({
            includeBookingTypes: includeBookingTypes,
            courtDate: courtDate,
        });
        var availableTimeSlots = timeSlots.filter(validTimeSlot);
        return !!availableTimeSlots.length;
    };
    function validTimeSlot(timeSlot) {
        var slotStartTime = timeToDate(timeSlot.startTime);
        var slotEndTime = timeToDate(timeSlot.endTime);
        if (slotStartTime > periodStartTime)
            return false;
        if (slotEndTime < periodEndTime)
            return false;
        var timeSlotMinutes = minutesDifference(periodStartTime, slotEndTime);
        return timeSlotMinutes >= averageMatchUpMinutes;
    }
    return { enoughTime: enoughTime };
}

function getCourtsAvailableAtPeriodStart(params) {
    var averageMatchUpMinutes = params.averageMatchUpMinutes, includeBookingTypes = params.includeBookingTypes, periodStart = params.periodStart, date = params.date;
    var courts = params.courts;
    var periodStartTime = timeToDate(periodStart);
    var periodEndTime = addMinutes(periodStartTime, averageMatchUpMinutes);
    var enoughTime = getEnoughTime({
        averageMatchUpMinutes: averageMatchUpMinutes,
        includeBookingTypes: includeBookingTypes,
        periodStartTime: periodStartTime,
        periodEndTime: periodEndTime,
    }).enoughTime;
    var availableCourts = (courts === null || courts === void 0 ? void 0 : courts.filter(function (court) {
        if (!Array.isArray(court.dateAvailability))
            return false;
        var courtDate = getCourtDateAvailability({ date: date, court: court });
        return !!(courtDate && enoughTime(courtDate));
    })) || [];
    return {
        availableToScheduleCount: availableCourts.length,
    };
}

function courtGenerator(params) {
    var _a = params !== null && params !== void 0 ? params : {}, _b = _a.startTime, startTime = _b === void 0 ? '8:00' : _b, _c = _a.endTime, endTime = _c === void 0 ? '20:30' : _c, _d = _a.count, count = _d === void 0 ? 10 : _d, date = _a.date;
    return generateRange(0, count).map(function () { return ({
        dateAvailability: [{ date: date, startTime: startTime, endTime: endTime }],
    }); });
}

function generateVirtualCourts(params) {
    var e_1, _a;
    var _b = params.remainingScheduleTimes, remainingScheduleTimes = _b === void 0 ? [] : _b, clearScheduleDates = params.clearScheduleDates, _c = params.periodLength, periodLength = _c === void 0 ? 30 : _c, scheduleDate = params.scheduleDate, _d = params.courts, courts = _d === void 0 ? [] : _d;
    var _e = params.bookings, bookings = _e === void 0 ? [] : _e;
    if (!Array.isArray(courts) || !courts.length)
        return { error: INVALID_VALUES, courts: courts };
    if (!Array.isArray(bookings))
        return { error: INVALID_BOOKINGS };
    if (!isValidDateString(scheduleDate))
        return { error: INVALID_DATE };
    if (clearScheduleDates) {
        if (Array.isArray(clearScheduleDates)) {
            if (clearScheduleDates.includes(scheduleDate))
                bookings = [];
        }
        else {
            bookings = [];
        }
    }
    var _f = bookings.reduce(function (accumulator, booking) {
        var courtId = booking.courtId;
        if (courtId) {
            if (!accumulator.courtBookings[courtId]) {
                accumulator.courtBookings[courtId] = [booking];
            }
            else {
                accumulator.courtBookings[courtId].push(booking);
            }
        }
        else {
            accumulator.unassignedBookings.push(booking);
        }
        return accumulator;
    }, { courtBookings: {}, unassignedBookings: [] }), courtBookings = _f.courtBookings, unassignedBookings = _f.unassignedBookings;
    var inProcessCourts = courts.map(function (court, index) {
        var courtId = court.courtId, courtName = court.courtName;
        var bookingsThisCourt = courtBookings[courtId] || [];
        var availability = getCourtDateAvailability({ date: scheduleDate, court: court }) || {};
        var _a = availability.bookings, existingBookings = _a === void 0 ? [] : _a, startTime = availability.startTime, endTime = availability.endTime, date = availability.date;
        var allocatedTimeBooking = remainingScheduleTimes[index] && {
            startTime: startTime,
            endTime: remainingScheduleTimes[index],
        };
        var amendedBookings = __spreadArray(__spreadArray([
            allocatedTimeBooking
        ], __read(makeDeepCopy(existingBookings, false, true)), false), __read(bookingsThisCourt), false).filter(Boolean);
        return {
            courtId: courtId,
            courtName: courtName,
            dateAvailability: {
                bookings: amendedBookings,
                startTime: startTime,
                endTime: endTime,
                date: date,
            },
        };
    });
    unassignedBookings.sort(function (a, b) { return timeStringMinutes(a.startTime) - timeStringMinutes(b.startTime); });
    var getCourtTimeSlots = function () {
        return inProcessCourts
            .map(function (court) {
            var courtDate = court.dateAvailability;
            var timeSlots = generateTimeSlots({ courtDate: courtDate });
            return {
                courtName: court.courtName,
                courtId: court.courtId,
                timeSlots: timeSlots,
            };
        })
            .flat();
    };
    var assignedBookings = [];
    var _loop_1 = function (unassignedBooking) {
        var startTime = unassignedBooking.startTime, endTime = unassignedBooking.endTime, averageMinutes = unassignedBooking.averageMinutes, recoveryMinutes = unassignedBooking.recoveryMinutes, matchUpId = unassignedBooking.matchUpId;
        var startMinutes = timeStringMinutes(startTime);
        var endMinutes = timeStringMinutes(endTime);
        var courtTimeSlots = getCourtTimeSlots();
        var bestCourt = courtTimeSlots.reduce(function (best, _a) {
            var courtId = _a.courtId, courtName = _a.courtName, timeSlots = _a.timeSlots;
            var startDifference;
            var timeSlot = timeSlots.find(function (_a) {
                var startTime = _a.startTime, endTime = _a.endTime;
                startDifference = timeStringMinutes(startTime) - startMinutes;
                var startFits = startMinutes >= timeStringMinutes(startTime);
                var endFits = endMinutes <= timeStringMinutes(endTime);
                return (endFits &&
                    best.startDifference !== 0 &&
                    (((startDifference === 0 || startDifference + periodLength >= 0) &&
                        (best.startDifference === undefined ||
                            startDifference < best.startDifference)) ||
                        startFits));
            });
            return timeSlot ? { courtName: courtName, courtId: courtId, startDifference: startDifference } : best;
        }, {});
        if (bestCourt.courtId) {
            var booking = {
                averageMinutes: averageMinutes,
                recoveryMinutes: recoveryMinutes,
                matchUpId: matchUpId,
                startTime: startTime,
                endTime: endTime,
            };
            assignedBookings.push(booking);
            var virtualCourt = inProcessCourts.find(function (_a) {
                var courtId = _a.courtId;
                return courtId === bestCourt.courtId;
            });
            virtualCourt === null || virtualCourt === void 0 ? void 0 : virtualCourt.dateAvailability.bookings.push(booking);
        }
        else {
            console.log({ unassignedBooking: unassignedBooking });
        }
    };
    try {
        for (var unassignedBookings_1 = __values(unassignedBookings), unassignedBookings_1_1 = unassignedBookings_1.next(); !unassignedBookings_1_1.done; unassignedBookings_1_1 = unassignedBookings_1.next()) {
            var unassignedBooking = unassignedBookings_1_1.value;
            _loop_1(unassignedBooking);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (unassignedBookings_1_1 && !unassignedBookings_1_1.done && (_a = unassignedBookings_1.return)) _a.call(unassignedBookings_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var virtualCourts = inProcessCourts.map(function (_a) {
        var courtId = _a.courtId, courtName = _a.courtName, dateAvailability = _a.dateAvailability;
        return ({
            dateAvailability: [dateAvailability],
            courtName: courtName,
            courtId: courtId,
        });
    });
    return { virtualCourts: virtualCourts, assignedBookings: assignedBookings };
}

function calculatePeriodLength(_a) {
    var averageMatchUpMinutes = _a.averageMatchUpMinutes, _b = _a.periodLength, periodLength = _b === void 0 ? 30 : _b, recoveryMinutes = _a.recoveryMinutes;
    var combinedMinutes = (averageMatchUpMinutes || 90) + (recoveryMinutes || 0);
    return periodLength > combinedMinutes ? combinedMinutes : periodLength || 30;
}

function getDateTimeBoundary(_a) {
    var scheduleDate = _a.scheduleDate, startTime = _a.startTime, endTime = _a.endTime, courts = _a.courts;
    var accessor = (startTime && 'startTime') || (endTime && 'endTime') || undefined;
    return courts.reduce(function (boundaryTime, court) {
        var dateAvailability = getCourtDateAvailability({
            date: scheduleDate,
            court: court,
        });
        var comparisonTime = accessor && ((dateAvailability === null || dateAvailability === void 0 ? void 0 : dateAvailability[accessor]) || court[accessor]);
        return comparisonTime &&
            (!boundaryTime ||
                (startTime &&
                    timeStringMinutes(comparisonTime) <
                        timeStringMinutes(boundaryTime)) ||
                (endTime &&
                    timeStringMinutes(comparisonTime) > timeStringMinutes(boundaryTime)))
            ? comparisonTime
            : boundaryTime;
    }, undefined);
}

function getFirstTimeSlotStartTime(_a) {
    var e_1, _b;
    var averageMinutes = _a.averageMinutes, startTime = _a.startTime, endTime = _a.endTime, courts = _a.courts, date = _a.date;
    // find the first timeSlot across all courts between startTime and endTime that can accommodate averageMatchUpMinutes
    startTime =
        startTime ||
            getDateTimeBoundary({ courts: courts, scheduleDate: date, startTime: true });
    endTime =
        endTime ||
            getDateTimeBoundary({ courts: courts, scheduleDate: date, endTime: true });
    var firstTimeSlotStartTime;
    if (startTime && endTime) {
        var dateStartTime_1 = timeToDate(startTime);
        var dateEndTime_1 = timeToDate(endTime);
        try {
            for (var _c = __values(courts || []), _d = _c.next(); !_d.done; _d = _c.next()) {
                var court = _d.value;
                if (!Array.isArray(court.dateAvailability))
                    continue;
                var courtDate = getCourtDateAvailability({ court: court, date: date });
                var timeSlots = generateTimeSlots({ courtDate: courtDate });
                timeSlots.forEach(function (timeSlot) {
                    var timeSlotStartTime = timeToDate(timeSlot.startTime);
                    var timeSlotEndTime = timeToDate(timeSlot.endTime);
                    if (timeSlotStartTime > dateEndTime_1 ||
                        timeSlotStartTime < dateStartTime_1)
                        return false;
                    if (timeSlotEndTime < dateStartTime_1)
                        return false;
                    var timeSlotMinutes = minutesDifference(timeSlotStartTime, timeSlotEndTime);
                    var available = timeSlotMinutes >= averageMinutes;
                    if (available) {
                        var timeString = extractTime(timeSlotStartTime.toISOString());
                        if (!firstTimeSlotStartTime || timeString < firstTimeSlotStartTime) {
                            firstTimeSlotStartTime = timeString;
                        }
                    }
                    return undefined;
                });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return { firstTimeSlotStartTime: firstTimeSlotStartTime };
}

function getScheduleTimes(params) {
    var _a = params.date, date = _a === void 0 ? getUTCdateString() : _a, _b = params.startTime, startTime = _b === void 0 ? '08:00' : _b, _c = params.endTime, endTime = _c === void 0 ? '19:00' : _c, periodLength = params.periodLength, courts = params.courts;
    var _d = params.calculateStartTimeFromCourts, calculateStartTimeFromCourts = _d === void 0 ? true : _d, remainingScheduleTimes = params.remainingScheduleTimes, // times remaining from previous scheduling iteration
    averageMatchUpMinutes = params.averageMatchUpMinutes, clearScheduleDates = params.clearScheduleDates, courtsCount = params.courtsCount, bookings = params.bookings;
    periodLength =
        periodLength || calculatePeriodLength({ averageMatchUpMinutes: averageMatchUpMinutes });
    // standardize date as YYYY-MM-DD
    date = extractDate(date);
    // standardize time as 00:00
    startTime = extractTime(startTime);
    endTime = extractTime(endTime);
    // keeps track of value of calculation after previous iteration
    var previousCalculation = 0;
    // keeps track of # of courts available during previous iteration
    var previousAvailableCourts = 0;
    // cumulativeMatches (float) number of matchUps possible for averageCourts
    // over # of periods of length periodLength
    var cumulativeMatches = 0;
    // accumulated matchUps which have been scheduled
    var totalMatchUps = 0;
    // accumulated time periods when a court was available for scheduling
    var cumulativePeriods = 0;
    if (!courts && courtsCount) {
        courts = courtGenerator({ startTime: startTime, endTime: endTime, count: courtsCount, date: date });
    }
    var virtualCourts = generateVirtualCourts({
        remainingScheduleTimes: remainingScheduleTimes,
        clearScheduleDates: clearScheduleDates,
        scheduleDate: date,
        periodLength: periodLength,
        bookings: bookings,
        courts: courts,
    }).virtualCourts;
    var firstTimeSlotStartTime = getFirstTimeSlotStartTime({
        averageMinutes: averageMatchUpMinutes,
        courts: virtualCourts,
        startTime: startTime,
        endTime: endTime,
        date: date,
    }).firstTimeSlotStartTime;
    if (calculateStartTimeFromCourts && firstTimeSlotStartTime) {
        startTime = firstTimeSlotStartTime ? firstTimeSlotStartTime : startTime;
    }
    // startTime, endTime and periodLength are used to calculate periodCount
    var dayStartMinutes = timeStringMinutes(startTime);
    var dayEndMinutes = timeStringMinutes(endTime);
    var dayMinutes = dayEndMinutes - dayStartMinutes;
    var periodCount = Math.floor(dayMinutes / periodLength);
    var periods = generateRange(0, periodCount + 1);
    var timingProfile = periods.map(function (period) {
        var periodStartMinutes = dayStartMinutes + period * periodLength;
        var periodStart = dayMinutesToTimeString(periodStartMinutes);
        // availableToScheduleCount calculated from periodStartTime and averageMatchUpMinutes
        // a court is only available if it can accommodate matchUps of duration averageMatchUpMinutes
        var availableToScheduleCount = getCourtsAvailableAtPeriodStart({
            courts: virtualCourts || [],
            averageMatchUpMinutes: averageMatchUpMinutes,
            periodStart: periodStart,
            date: date,
        }).availableToScheduleCount;
        // newCourts are courts which have become available for the start of current time period
        var newCourts = availableToScheduleCount > previousAvailableCourts
            ? availableToScheduleCount - previousAvailableCourts
            : 0;
        cumulativePeriods += period ? availableToScheduleCount : 0;
        var averageCourts = period
            ? cumulativePeriods / period
            : availableToScheduleCount;
        // calculatedTotal uses Revised Garman Formula to calculate total number of matchUps
        // which should be possible given a number of periods and an average number of courts
        // available over the accumulated time
        var accumulatedTime = periodLength * averageCourts;
        var matchesCalculation = accumulatedTime / averageMatchUpMinutes;
        var calculatedTotal = period
            ? matchesCalculation * (period - 1) + averageCourts
            : averageCourts;
        // used to increment cumulativeMatches
        // difference between current calculation and previous calculation
        // if no available courts then Zero so that cumulativeMatches does not increase
        // if available courts but no previously available courts then newCourts;
        var calculationDifference = !availableToScheduleCount
            ? 0
            : (previousAvailableCourts && calculatedTotal - previousCalculation) ||
                newCourts;
        previousCalculation = calculatedTotal;
        previousAvailableCourts = availableToScheduleCount;
        cumulativeMatches += calculationDifference;
        var addToSchedule = ensureInt(cumulativeMatches) - totalMatchUps;
        totalMatchUps += addToSchedule;
        return {
            periodStart: periodStart,
            add: addToSchedule,
            availableToScheduleCount: availableToScheduleCount,
            newCourts: newCourts,
            totalMatchUps: totalMatchUps,
        };
    });
    var scheduleTimes = timingProfile
        .reduce(function (scheduleTimes, profile) {
        var stRange = generateRange(0, profile.add);
        var newTimes = stRange.map(function () {
            var scheduleTime = profile.periodStart;
            return { scheduleTime: scheduleTime };
        });
        return scheduleTimes.concat.apply(scheduleTimes, __spreadArray([], __read(newTimes), false));
    }, [])
        .flat();
    return { scheduleTimes: scheduleTimes, timingProfile: timingProfile, totalMatchUps: totalMatchUps };
}

var garman = {
    getCourtsAvailableAtPeriodStart: getCourtsAvailableAtPeriodStart,
    generateTimeSlots: generateTimeSlots,
    getScheduleTimes: getScheduleTimes,
    courtGenerator: courtGenerator,
};

var generationGovernor = {
    garman: garman,
    generateAdHocMatchUps: generateAdHocMatchUps,
    generateAndPopulatePlayoffStructures: generateAndPopulatePlayoffStructures,
    generateCourts: generateCourts,
    generateDrawDefinition: generateDrawDefinition,
    generateDrawMaticRound: generateDrawMaticRound,
    generateDrawStructuresAndLinks: generateDrawStructuresAndLinks,
    generateDrawTypeAndModifyDrawDefinition: generateDrawTypeAndModifyDrawDefinition,
    generateFlightProfile: generateFlightProfile,
    generateLineUps: generateLineUps,
    generateQualifyingStructure: generateQualifyingStructure,
    generateSeedingScaleItems: generateSeedingScaleItems,
    generateVoluntaryConsolation: generateVoluntaryConsolation,
};

var statesData = [
	{
		AA: "Annexia"
	},
	{
		BA: "Bacteria"
	},
	{
		BO: "Borduria"
	},
	{
		BM: "Bensalem"
	},
	{
		BS: "Basenji"
	},
	{
		BI: "Balnibarbi"
	},
	{
		BV: "Bartovia"
	},
	{
		BZ: "Berzerkistan"
	},
	{
		CA: "Caldonia"
	},
	{
		CC: "Concordia"
	},
	{
		CH: "Chula"
	},
	{
		DA: "Deltora"
	},
	{
		DW: "Discworld"
	},
	{
		EA: "Eastasia"
	},
	{
		EP: "Ecotopia"
	},
	{
		ER: "Erewhon"
	},
	{
		FA: "Freedonia"
	},
	{
		FN: "Florin"
	},
	{
		FG: "Fogg"
	},
	{
		FK: "Fourecks"
	},
	{
		GA: "Genovia"
	},
	{
		GL: "Gilead"
	},
	{
		GD: "Gilead"
	},
	{
		GL: "Gondal"
	},
	{
		GO: "Gondor"
	},
	{
		GR: "Gruzinia"
	},
	{
		GT: "Goritania"
	},
	{
		GU: "Guilder"
	},
	{
		HA: "Heldscalla"
	},
	{
		HO: "Hidalgo"
	},
	{
		IL: "Illyria"
	},
	{
		KA: "Kinakuta"
	},
	{
		KG: "Kangan"
	},
	{
		KN: "Kreplachistan"
	},
	{
		KS: "Kallipolis"
	},
	{
		LH: "Lugash"
	},
	{
		LI: "Listenbourg"
	},
	{
		LT: "Lilliput"
	},
	{
		LU: "Luggnagg"
	},
	{
		LV: "Lichtenslava"
	},
	{
		MR: "Moher"
	},
	{
		NA: "Narnia"
	},
	{
		NV: "Novaria"
	},
	{
		OA: "Oceania"
	},
	{
		OS: "Orsinia"
	},
	{
		OV: "Octavia"
	},
	{
		PA: "Palombia"
	},
	{
		PG: "Penguina"
	},
	{
		QA: "Qasha"
	},
	{
		PM: "Panem"
	},
	{
		SA: "Solymbria"
	},
	{
		SD: "Syldavia"
	},
	{
		SG: "San Glucose"
	},
	{
		SL: "San Lorenzo"
	},
	{
		SR: "Sontar"
	},
	{
		SY: "Sylvania"
	},
	{
		TF: "Tralfamadore"
	},
	{
		TH: "Themyscira"
	},
	{
		UA: "Utopia"
	},
	{
		VA: "Vespugia"
	},
	{
		WA: "Wakanda"
	},
	{
		WX: "Wessex"
	},
	{
		ZA: "Zamunda"
	},
	{
		ZK: "Zubrowka"
	}
];

var citiesData = [
	"Amber",
	"Ansul",
	"Atlantis",
	"Braavos",
	"Busytown",
	"Castle Rock",
	"Centralia",
	"Coober Pedy",
	"Chefchaouen",
	"Chronopolis",
	"Damanhur",
	"Diaspar",
	"Dictionopolis",
	"Diomira",
	"El Dorado",
	"Elista",
	"Ephesus",
	"Gotham",
	"Hadleyburg",
	"Hallstatt",
	"Hierusalem",
	"Ilium",
	"Inverness",
	"Kowloon",
	"Laputa",
	"Longyearbyen",
	"Lys",
	"Matmata",
	"Maycomb",
	"Metropolis",
	"Miyake-jima",
	"Monowi",
	"Nagoro",
	"Navarre",
	"New New York",
	"Nimbin",
	"Pemberley",
	"Pseudopolis",
	"Rivendell",
	"Roswell",
	"Shangri-La",
	"Springfield",
	"Supilinn",
	"Thneedville",
	"Trantor",
	"Wobegon",
	"Yonwood",
	"Xanadu",
	"Xylar",
	"Zion"
];

function cityMocks(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.count, count = _c === void 0 ? 1 : _c, _d = _b.participantsCount, participantsCount = _d === void 0 ? 32 : _d;
    var shuffledCities = shuffleArray(citiesData);
    var candidateCities = shuffledCities.slice(0, count);
    // the following ensures that all of the generated items are used at least once
    var cities = generateRange(0, participantsCount).map(function (i) {
        return i < Math.min(count, shuffledCities.length)
            ? candidateCities[i]
            : randomMember(candidateCities);
    });
    return { cities: cities };
}
function stateMocks(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.count, count = _c === void 0 ? 1 : _c, _d = _b.participantsCount, participantsCount = _d === void 0 ? 32 : _d;
    var shuffledStates = shuffleArray(statesData);
    var candidateStates = shuffledStates
        .slice(0, count)
        .map(function (state) { return Object.keys(state); })
        .flat();
    // the following ensures that all of the generated items are used at least once
    var states = generateRange(0, participantsCount).map(function (i) {
        return i < Math.min(count, shuffledStates.length)
            ? candidateStates[i]
            : randomMember(candidateStates);
    });
    return { states: states };
}
function postalCodeMocks(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.count, count = _c === void 0 ? 1 : _c, _d = _b.participantsCount, participantsCount = _d === void 0 ? 32 : _d;
    var candidatePostalCodes = generateRange(0, count).map(function () {
        return generateRange(0, 5)
            .map(function () { return randomInt(0, 9); })
            .join('');
    });
    // the following ensures that all of the generated items are used at least once
    var postalCodes = generateRange(0, participantsCount).map(function (i) {
        return i < count ? candidatePostalCodes[i] : randomMember(candidatePostalCodes);
    });
    return { postalCodes: postalCodes };
}

var lastNames = [
	"Abbey",
	"Assange",
	"Ahern",
	"Ampleforth",
	"Atreides",
	"Austen",
	"Bach",
	"Banks",
	"Barrington",
	"Batty",
	"Bauers",
	"Beals",
	"Beer",
	"Bennett",
	"Berry",
	"Bonaparte",
	"Brockovich",
	"Bukowski",
	"Cassidy",
	"Catton",
	"Calvino",
	"Carson",
	"Chip",
	"Constant",
	"Crane",
	"Crowne",
	"Cummings",
	"Curie",
	"Dallas",
	"Diamond",
	"Deckard",
	"Drazic",
	"Dunbar",
	"Earhart",
	"Eisenstein",
	"Eldritch",
	"Elliot",
	"Escher",
	"Eyre",
	"Faulkner",
	"Fukuoka",
	"Godel",
	"Goldstein",
	"Greer",
	"Hedges",
	"Herbert",
	"Holmgren",
	"Humperdinck",
	"Huxley",
	"Illich",
	"Jeffers",
	"Jensen",
	"Jevons",
	"Johnson",
	"Johnstone",
	"Jovovich",
	"Kingsnorth",
	"Langer",
	"Fernwright",
	"Fuller",
	"Le Guin",
	"Lem",
	"Lovelace",
	"Midgely",
	"Mond",
	"Montoya",
	"Moore",
	"Murry",
	"Nagle",
	"Nearing",
	"Ogden",
	"Ophuls",
	"Parks",
	"Paz",
	"Peet",
	"Perfect",
	"Pendejo",
	"Pevensie",
	"Postman",
	"Ripley",
	"Rodda",
	"Rumfoord",
	"Runciter",
	"Rugen",
	"Sale",
	"Schumacher",
	"Shaftoe",
	"Shelley",
	"Shepard",
	"Smith",
	"Stratton",
	"Stewart",
	"Swift",
	"Tillich",
	"Turing",
	"Tyrell",
	"Twain",
	"Yeats",
	"Veblen",
	"Yates",
	"Vonnegut",
	"Waterhouse",
	"Watson",
	"Wolin",
	"Wirt",
	"Wormwood"
];
var firstFemale = [
	"Ada",
	"Amelia",
	"Amelie",
	"America",
	"Anne",
	"Antonia",
	"Aravis",
	"Astrid",
	"Beatrice",
	"Brienne",
	"Buttercup",
	"Caitlin",
	"Cimorene",
	"Cordelia",
	"Desdemona",
	"Ellen",
	"Elizabeth",
	"Emily",
	"Emmie",
	"Erin",
	"Eva",
	"Evelyn",
	"Heather",
	"Helen",
	"Hermia",
	"Hypatia",
	"Imogen",
	"Jane",
	"Jasmine",
	"Juliana",
	"Juliet",
	"Katniss",
	"Leeloo",
	"Lenina",
	"Lilith",
	"Linda",
	"Lizzie",
	"Louise",
	"Lucy",
	"Marie",
	"Mary",
	"Martha",
	"Matilda",
	"Milla",
	"Miranda",
	"Meg",
	"Melba",
	"Nicole",
	"Ola",
	"Portia",
	"Pris",
	"Rachael",
	"Rachel",
	"Rebecca",
	"River",
	"Rosa",
	"Rosalind",
	"Scout",
	"Sharn",
	"Susanne",
	"Titania",
	"Uhura",
	"Ursula",
	"Valentina",
	"Viola",
	"Virginia",
	"Xena",
	"Zoe"
];
var firstMale = [
	"Alan",
	"Aldous",
	"August",
	"Axel",
	"Barda",
	"Bill",
	"Bruce",
	"Charles",
	"Chris",
	"Darwin",
	"David",
	"Derrick",
	"Edward",
	"Emmanuel",
	"Ernst",
	"Estlin",
	"Fezzik",
	"Filby",
	"Frank",
	"Frito",
	"George",
	"Glen",
	"Helmholtz",
	"Inigo",
	"Italo",
	"Ivan",
	"James",
	"Jared",
	"Joe",
	"Johann",
	"Julian",
	"John Michael",
	"Jonathan",
	"Korben",
	"Kirkpatrick",
	"Kurt",
	"Lief",
	"Malachi",
	"Mark",
	"Masanobu",
	"Maurits",
	"Michael",
	"Mustapha",
	"Neil",
	"Nikola",
	"Octavio",
	"Palmer",
	"Paul",
	"Pierre",
	"Robinson",
	"Rick",
	"Rincewind",
	"Roy",
	"Shannon",
	"Sheldon",
	"Stafford",
	"Stanislaw",
	"Stanley",
	"Syme",
	"Thorstein",
	"Thomas",
	"Tyrone",
	"Vizzini",
	"Walton",
	"Walker",
	"Warren",
	"Wendell",
	"Westley",
	"William",
	"Winston",
	"Zoran"
];
var namesData$1 = {
	lastNames: lastNames,
	firstFemale: firstFemale,
	firstMale: firstMale
};

function generatePersonData(params) {
    var _a = params || {}, _b = _a.count, count = _b === void 0 ? 100 : _b, sex = _a.sex;
    if (!count || (sex && ![MALE, FEMALE].includes(sex)))
        return { personData: [], error: INVALID_VALUES };
    // generate 30% more than count to account for duplicated firstName/lastName
    var buffer = Math.ceil(count * 1.3);
    var lastNames = namesData$1.lastNames, firstFemale = namesData$1.firstFemale, firstMale = namesData$1.firstMale;
    var ISOs = countries.map(function (_a) {
        var iso = _a.iso;
        return iso;
    }).filter(Boolean);
    var lastNameDupeCount = Math.ceil(buffer / lastNames.length);
    var femaleDupeCount = Math.ceil(buffer / firstFemale.length);
    var maleDupeCount = Math.ceil(buffer / firstMale.length);
    var lastNameDupes = generateRange(0, lastNameDupeCount).flatMap(function () {
        var n = makeDeepCopy(lastNames, false, true); // internal use
        return generateRange(0, lastNames.length).map(function () { return randomPop(n); });
    });
    var femaleDupes = generateRange(0, femaleDupeCount).flatMap(function () {
        var n = makeDeepCopy(firstFemale, false, true); // internal use
        return generateRange(0, firstFemale.length).map(function () { return randomPop(n); });
    });
    var maleDupes = generateRange(0, maleDupeCount).flatMap(function () {
        var n = makeDeepCopy(firstMale, false, true); // internal use
        return generateRange(0, firstMale.length).map(function () { return randomPop(n); });
    });
    var candidates = {};
    for (var i = 0; i < buffer; i++) {
        var lastName = lastNameDupes.pop();
        var personSex = sex || randomMember([MALE, FEMALE]);
        var firstName = personSex === MALE ? maleDupes.pop() : femaleDupes.pop();
        var nationalityCode = randomMember(ISOs);
        candidates["".concat(firstName).concat(lastName)] = {
            nationalityCode: nationalityCode,
            sex: personSex,
            firstName: firstName,
            lastName: lastName,
        };
    }
    var personData = Object.values(candidates).slice(0, count);
    return { personData: personData };
}

/**
 * @param {integer} count - number of persons to generate
 * @param {string} sex - optional - MALE or FEMALE
 * @param {object[]} personData - optional array of persons to seed generator [{ firstName, lastName, sex, nationalityCode }]
 * @param {object} personExtensions - optional array of extentsions to apply to all persons
 */
function generatePersons(params) {
    var count = (params === null || params === void 0 ? void 0 : params.count) || 1;
    var _a = params || {}, personExtensions = _a.personExtensions, consideredDate = _a.consideredDate, _b = _a.isMock, isMock = _b === void 0 ? true : _b, gendersCount = _a.gendersCount, personData = _a.personData, category = _a.category, sex = _a.sex;
    if (isNaN(count))
        return { error: INVALID_VALUES };
    var maleCount = (gendersCount === null || gendersCount === void 0 ? void 0 : gendersCount[MALE]) || (sex === MALE && count) || 0;
    var femaleCount = (gendersCount === null || gendersCount === void 0 ? void 0 : gendersCount[FEMALE]) || (sex === FEMALE && count) || 0;
    count = Math.max(count, maleCount + femaleCount);
    var defaultCount = count - (maleCount + femaleCount);
    var defaultMalePersonData = (maleCount &&
        generatePersonData({
            count: maleCount,
            sex: MALE,
        }).personData) ||
        [];
    var defaultFemalePersonData = (femaleCount &&
        generatePersonData({
            count: femaleCount,
            sex: FEMALE,
        }).personData) ||
        [];
    var defaultPersonData = __spreadArray(__spreadArray(__spreadArray([], __read(defaultMalePersonData), false), __read(defaultFemalePersonData), false), __read(((defaultCount &&
        generatePersonData({
            count: defaultCount,
        }).personData) ||
        [])), false);
    var validPersonData = defaultPersonData.filter(function (person) { return !sex || (maleCount && femaleCount) || person.sex === sex; });
    var nationalityCodes = [];
    if (Array.isArray(personData)) {
        var validatedPersonData = personData.filter(function (person) {
            if (typeof person.firstName !== 'string')
                return false;
            if (typeof person.lastName !== 'string')
                return false;
            if (person.sex && ![MALE, FEMALE].includes(person.sex))
                return false;
            if (person.nationalityCode &&
                (typeof person.nationalityCode !== 'string' ||
                    person.nationalityCode.length > 3 ||
                    !countries.find(function (_a) {
                        var iso = _a.iso, ioc = _a.ioc;
                        return [iso, ioc].includes(person.nationalityCode);
                    })))
                return false;
            if (person.nationalityCode)
                nationalityCodes.push(person.nationalityCode);
            return true;
        });
        if (validatedPersonData.length) {
            validPersonData = validatedPersonData;
        }
        else {
            return { error: INVALID_VALUES };
        }
    }
    var shuffledPersons = personData
        ? validPersonData
        : shuffleArray(validPersonData);
    if (shuffledPersons.length < count) {
        var _c = defaultPersonData.reduce(function (a, person) {
            var firstName = person.firstName, lastName = person.lastName, nationalityCode = person.nationalityCode;
            if (person.sex === MALE) {
                if (!a.maleFirstNames.includes(firstName))
                    a.maleFirstNames.push(firstName);
                if (!a.maleLastNames.includes(lastName))
                    a.maleLastNames.push(lastName);
            }
            else {
                if (!a.femaleFirstNames.includes(firstName))
                    a.femaleFirstNames.push(firstName);
                if (!a.femaleLastNames.includes(lastName))
                    a.femaleLastNames.push(lastName);
            }
            if (!a.nationalityCodes.includes(nationalityCode))
                a.nationalityCodes.push(nationalityCode);
            return a;
        }, {
            maleFirstNames: [],
            maleLastNames: [],
            femaleFirstNames: [],
            femaleLastNames: [],
            nationalityCodes: [],
        }), maleFirstNames_1 = _c.maleFirstNames, maleLastNames_1 = _c.maleLastNames, femaleFirstNames_1 = _c.femaleFirstNames, femaleLastNames_1 = _c.femaleLastNames, nationalityCodes_1 = _c.nationalityCodes;
        generateRange(0, count - shuffledPersons.length).forEach(function () {
            var personSex = sex || randomMember([MALE, FEMALE]);
            var nationalityCode = randomMember(nationalityCodes_1);
            var firstName = personSex === MALE
                ? randomMember(maleFirstNames_1)
                : randomMember(femaleFirstNames_1);
            var lastName = personSex === MALE
                ? randomMember(maleLastNames_1)
                : randomMember(femaleLastNames_1);
            var person = {
                firstName: firstName,
                lastName: lastName,
                sex: personSex,
                nationalityCode: nationalityCode,
            };
            shuffledPersons.push(person);
        });
    }
    var _d = getCategoryAgeDetails({
        consideredDate: consideredDate,
        category: category,
    }), ageMinDate = _d.ageMinDate, ageMaxDate = _d.ageMaxDate;
    var rangeStart = ensureInt((ageMinDate === null || ageMinDate === void 0 ? void 0 : ageMinDate.slice(0, 4)) || 0) ||
        ensureInt((ageMaxDate === null || ageMaxDate === void 0 ? void 0 : ageMaxDate.slice(0, 4)) || 0) - 3;
    var rangeEnd = ensureInt((ageMaxDate === null || ageMaxDate === void 0 ? void 0 : ageMaxDate.slice(0, 4)) || 0) ||
        ensureInt((ageMinDate === null || ageMinDate === void 0 ? void 0 : ageMinDate.slice(0, 4)) || 0) + 3;
    var yearRange = (ageMinDate || ageMaxDate) && [rangeStart, rangeEnd];
    var persons = shuffledPersons.slice(0, count).map(function (person, i) {
        var _a = __read(yearRange || [], 2), start = _a[0], end = _a[1];
        var birthYear = yearRange && randomPop(generateRange(start, end));
        var birthDay = randomPop(generateRange(0, 365));
        var birthDate = birthYear && dateFromDay(birthYear, birthDay);
        return Object.assign(definedAttributes({
            extensions: personExtensions || [{ name: 'regionCode', value: i + 1 }],
            birthDate: birthDate,
            isMock: isMock,
        }), person);
    });
    return {
        persons: (persons.length && persons) || shuffledPersons[0],
        nationalityCodes: nationalityCodes,
    };
}

function generateAddress(addressAttributes) {
    var cities = addressAttributes.cities, states = addressAttributes.states, postalCodes = addressAttributes.postalCodes, nationalityCode = addressAttributes.nationalityCode, participantIndex = addressAttributes.participantIndex;
    return {
        postalCode: postalCodes === null || postalCodes === void 0 ? void 0 : postalCodes[participantIndex],
        state: states === null || states === void 0 ? void 0 : states[participantIndex],
        city: cities === null || cities === void 0 ? void 0 : cities[participantIndex],
        countryCode: nationalityCode,
    };
}

var namesData = [
	"Ace Academy",
	"Avengers",
	"Ball Bouncers",
	"Baseliners",
	"Captivators",
	"Civil Disobedients",
	"Continentals",
	"Court Royal",
	"Court Sharks",
	"Diamond Dogs",
	"Danger Zone",
	"Doubles Dominators",
	"Double Faults",
	"Tricksters",
	"Eliminators",
	"Court Crusaders",
	"Fuzz Busters",
	"Game Changers",
	"Goal Gurus",
	"Good Volley",
	"Green Machine",
	"Hawk Eyes",
	"Inside Outers",
	"Killer Instinct",
	"Line Toers",
	"Masters of Mayhem",
	"Matter Catchers",
	"Cheap Shot",
	"Mean Machines",
	"Mindspace Invaders",
	"Net Centric",
	"Net Positive",
	"Smash Mullet",
	"Over Your Head",
	"Spin Meisters",
	"Aggressors",
	"Racket Machine",
	"Slice Happy",
	"Refs Nightmare",
	"Sandeaters",
	"Sun Seekers",
	"Slicer Dicers",
	"Sparkle Soul Tribe",
	"Stacked Deck",
	"Cross Stringers",
	"The Emergence",
	"Total Demolition",
	"Touch and Go",
	"Upside Downers",
	"Vertically Challenged",
	"Visual Spectacle"
];

function nameMocks(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.nameRoot, nameRoot = _c === void 0 ? 'TEAM' : _c, _d = _b.count, count = _d === void 0 ? 1 : _d;
    var shuffledTeamNames = shuffleArray(namesData);
    var names = shuffledTeamNames.slice(0, count);
    if (names.length < count) {
        generateRange(0, count - names.length).forEach(function (i) {
            return names.push("".concat(nameRoot, " ").concat(i + 1));
        });
    }
    return { names: names };
}

function anonymizeTournamentRecord(_a) {
    var e_1, _b, e_2, _c, e_3, _d, e_4, _e, e_5, _f, e_6, _g, e_7, _h, e_8, _j, e_9, _k, e_10, _l, _m, _o;
    var _p, _q, _r, _s, _t;
    var _u = _a.keepExtensions, keepExtensions = _u === void 0 ? [] : _u, // e.g. ['level']
    _v = _a.anonymizeParticipantNames, // e.g. ['level']
    anonymizeParticipantNames = _v === void 0 ? true : _v, tournamentRecord = _a.tournamentRecord, tournamentName = _a.tournamentName, _w = _a.personIds, personIds = _w === void 0 ? [] : _w, tournamentId = _a.tournamentId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    // if keepExtensions is boolean true then keep all extensions
    // otherwise, keep any specified extensions along with internal extensions
    var extensionsToKeep = Array.isArray(keepExtensions)
        ? internalExtensions.concat.apply(internalExtensions, __spreadArray([], __read(keepExtensions), false)) : internalExtensions;
    var filterExtensions = function (element) {
        var _a;
        if (Array.isArray(keepExtensions)) {
            return (_a = element === null || element === void 0 ? void 0 : element.extensions) === null || _a === void 0 ? void 0 : _a.filter(function (extension) {
                return extensionsToKeep.includes(extension.name);
            });
        }
        else {
            return element === null || element === void 0 ? void 0 : element.extensions;
        }
    };
    // create mapping from original element IDs to newly generated UUIDs
    var idMap = {};
    // change the tournamentId and name
    tournamentRecord.extensions = filterExtensions(tournamentRecord);
    var newTournamentId = tournamentId || UUID();
    idMap[tournamentRecord.tournamentId] = newTournamentId;
    tournamentRecord.tournamentId = newTournamentId;
    tournamentRecord.createdAt = new Date().toISOString();
    tournamentRecord.tournamentName =
        tournamentName || "Anonymized: ".concat(formatDate(new Date()));
    delete tournamentRecord.parentOrganisation;
    try {
        for (var _x = __values(tournamentRecord.participants || []), _y = _x.next(); !_y.done; _y = _x.next()) {
            var participant = _y.value;
            var newParticipantId = UUID();
            idMap[participant.participantId] = newParticipantId;
            participant.participantId = newParticipantId;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_y && !_y.done && (_b = _x.return)) _b.call(_x);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        // update all PAIR, GROUP and TEAM participant individualParticipantIds
        for (var _z = __values(tournamentRecord.participants || []), _0 = _z.next(); !_0.done; _0 = _z.next()) {
            var participant = _0.value;
            if (Array.isArray(participant.individualParticipantIds)) {
                participant.individualParticipantIds =
                    participant.individualParticipantIds.map(function (individualParticipantId) { return idMap[individualParticipantId]; });
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_0 && !_0.done && (_c = _z.return)) _c.call(_z);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var venueIndex = 0;
    try {
        for (var _1 = __values(tournamentRecord.venues || []), _2 = _1.next(); !_2.done; _2 = _1.next()) {
            var venue = _2.value;
            venue.extensions = filterExtensions(venue);
            venue.venueName = "Venue #".concat(venueIndex);
            venue.venueAbbreviation = "V".concat(venueIndex);
            var newVenueId = UUID();
            idMap[venue.venueId] = newVenueId;
            venueIndex += 1;
            // venue.eventId = UUID(); eventIds can't be anonymized without updating schedulingProfiles
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_2 && !_2.done && (_d = _1.return)) _d.call(_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    var eventCount = 1;
    try {
        for (var _3 = __values(tournamentRecord.events || []), _4 = _3.next(); !_4.done; _4 = _3.next()) {
            var event_1 = _4.value;
            event_1.extensions = filterExtensions(event_1);
            var newEventId = UUID();
            idMap[event_1.eventId] = newEventId;
            event_1.eventId = newEventId;
            var categoryName = ((_p = event_1.category) === null || _p === void 0 ? void 0 : _p.categoryName) ||
                ((_q = event_1.category) === null || _q === void 0 ? void 0 : _q.ageCategoryCode) ||
                ((_r = event_1.category) === null || _r === void 0 ? void 0 : _r.ratingType) ||
                event_1.gender;
            event_1.eventName = "Event ".concat(eventCount, " ").concat(categoryName);
            // update all event entries
            if (Array.isArray(event_1.entries)) {
                try {
                    for (var _5 = (e_5 = void 0, __values(event_1.entries)), _6 = _5.next(); !_6.done; _6 = _5.next()) {
                        var entry = _6.value;
                        entry.participantId = idMap[entry.participantId];
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_6 && !_6.done && (_f = _5.return)) _f.call(_5);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
            }
            try {
                for (var _7 = (e_6 = void 0, __values(event_1.drawDefinitions || [])), _8 = _7.next(); !_8.done; _8 = _7.next()) {
                    var drawDefinition = _8.value;
                    drawDefinition.extensions = filterExtensions(drawDefinition);
                    var newDrawId = UUID();
                    idMap[drawDefinition.drawId] = newDrawId;
                    drawDefinition.drawId = newDrawId;
                    // update all drawDefinition entries
                    if (Array.isArray(drawDefinition.entries)) {
                        try {
                            for (var _9 = (e_7 = void 0, __values(drawDefinition.entries)), _10 = _9.next(); !_10.done; _10 = _9.next()) {
                                var entry = _10.value;
                                entry.participantId = idMap[entry.participantId];
                            }
                        }
                        catch (e_7_1) { e_7 = { error: e_7_1 }; }
                        finally {
                            try {
                                if (_10 && !_10.done && (_h = _9.return)) _h.call(_9);
                            }
                            finally { if (e_7) throw e_7.error; }
                        }
                    }
                    var updateStructure = function (structure) {
                        var e_11, _a, e_12, _b, e_13, _c, e_14, _d;
                        structure.extensions = filterExtensions(structure);
                        var newStructureId = UUID();
                        idMap[structure.structureId] = newStructureId;
                        structure.structureId = newStructureId;
                        try {
                            // update positionAssignments for all structures
                            for (var _e = (e_11 = void 0, __values(structure.positionAssignments || [])), _f = _e.next(); !_f.done; _f = _e.next()) {
                                var assignment = _f.value;
                                if (assignment.participantId)
                                    assignment.participantId = idMap[assignment.participantId];
                            }
                        }
                        catch (e_11_1) { e_11 = { error: e_11_1 }; }
                        finally {
                            try {
                                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                            }
                            finally { if (e_11) throw e_11.error; }
                        }
                        try {
                            // update seedAssignments for all structures
                            for (var _g = (e_12 = void 0, __values(structure.seedAssignments || [])), _h = _g.next(); !_h.done; _h = _g.next()) {
                                var assignment = _h.value;
                                if (assignment.participantId)
                                    assignment.participantId = idMap[assignment.participantId];
                            }
                        }
                        catch (e_12_1) { e_12 = { error: e_12_1 }; }
                        finally {
                            try {
                                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                            }
                            finally { if (e_12) throw e_12.error; }
                        }
                        try {
                            // update lineUps in each matchUp
                            for (var _j = (e_13 = void 0, __values(structure.matchUps || [])), _k = _j.next(); !_k.done; _k = _j.next()) {
                                var matchUp = _k.value;
                                try {
                                    for (var _l = (e_14 = void 0, __values(matchUp.sides || [])), _m = _l.next(); !_m.done; _m = _l.next()) {
                                        var side = _m.value;
                                        if (!side.lineUp)
                                            continue;
                                        side.lineUp = side.lineUp.map(function (_a) {
                                            var participantId = _a.participantId, collectionAssignments = _a.collectionAssignments;
                                            return ({
                                                participantId: idMap[participantId],
                                                collectionAssignments: collectionAssignments,
                                            });
                                        });
                                    }
                                }
                                catch (e_14_1) { e_14 = { error: e_14_1 }; }
                                finally {
                                    try {
                                        if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                                    }
                                    finally { if (e_14) throw e_14.error; }
                                }
                            }
                        }
                        catch (e_13_1) { e_13 = { error: e_13_1 }; }
                        finally {
                            try {
                                if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                            }
                            finally { if (e_13) throw e_13.error; }
                        }
                    };
                    try {
                        for (var _11 = (e_8 = void 0, __values(drawDefinition.structures || [])), _12 = _11.next(); !_12.done; _12 = _11.next()) {
                            var structure = _12.value;
                            updateStructure(structure);
                            // account for structureType CONTAINER
                            if (Array.isArray(structure.structures)) {
                                try {
                                    for (var _13 = (e_9 = void 0, __values(structure.structures)), _14 = _13.next(); !_14.done; _14 = _13.next()) {
                                        var childStructure = _14.value;
                                        updateStructure(childStructure);
                                    }
                                }
                                catch (e_9_1) { e_9 = { error: e_9_1 }; }
                                finally {
                                    try {
                                        if (_14 && !_14.done && (_k = _13.return)) _k.call(_13);
                                    }
                                    finally { if (e_9) throw e_9.error; }
                                }
                            }
                        }
                    }
                    catch (e_8_1) { e_8 = { error: e_8_1 }; }
                    finally {
                        try {
                            if (_12 && !_12.done && (_j = _11.return)) _j.call(_11);
                        }
                        finally { if (e_8) throw e_8.error; }
                    }
                    try {
                        // use idMap to update all link IDs
                        for (var _15 = (e_10 = void 0, __values(drawDefinition.links || [])), _16 = _15.next(); !_16.done; _16 = _15.next()) {
                            var link = _16.value;
                            link.source.structureId = idMap[link.source.structureId];
                            link.target.structureId = idMap[link.target.structureId];
                        }
                    }
                    catch (e_10_1) { e_10 = { error: e_10_1 }; }
                    finally {
                        try {
                            if (_16 && !_16.done && (_l = _15.return)) _l.call(_15);
                        }
                        finally { if (e_10) throw e_10.error; }
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_8 && !_8.done && (_g = _7.return)) _g.call(_7);
                }
                finally { if (e_6) throw e_6.error; }
            }
            var flightProfile = findExtension({
                name: FLIGHT_PROFILE,
                element: event_1,
            }).extension;
            // use idMap to update all IDs in flightProfiles
            if (Array.isArray((_s = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.value) === null || _s === void 0 ? void 0 : _s.flights)) {
                (_t = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.value.flights) === null || _t === void 0 ? void 0 : _t.forEach(function (flight) {
                    var e_15, _a;
                    flight.drawId = idMap[flight.drawId];
                    if (Array.isArray(flight.drawEntries)) {
                        try {
                            for (var _b = (e_15 = void 0, __values(flight.drawEntries)), _c = _b.next(); !_c.done; _c = _b.next()) {
                                var entry = _c.value;
                                entry.participantId = idMap[entry.participantId];
                            }
                        }
                        catch (e_15_1) { e_15 = { error: e_15_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                            }
                            finally { if (e_15) throw e_15.error; }
                        }
                    }
                });
            }
            eventCount += 1;
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_4 && !_4.done && (_e = _3.return)) _e.call(_3);
        }
        finally { if (e_4) throw e_4.error; }
    }
    var consideredDate = tournamentRecord.startDate || formatDate(new Date());
    var individualParticipants = (tournamentRecord.participants || []).filter(function (_a) {
        var participantType = _a.participantType;
        return participantType === INDIVIDUAL;
    });
    var gendersCount = individualParticipants.reduce(function (counts, participant) {
        var _a;
        var gender = (_a = participant.person) === null || _a === void 0 ? void 0 : _a.sex;
        if ([MALE, FEMALE].includes(gender)) {
            counts[gender] += 1;
        }
        else {
            counts[OTHER$2] += 1;
        }
        return counts;
    }, (_m = {}, _m[MALE] = 0, _m[FEMALE] = 0, _m[OTHER$2] = 0, _m));
    var genderedPersons = Object.assign.apply(Object, __spreadArray([{}], __read(Object.keys(gendersCount).map(function (gender) {
        var _a;
        var _b;
        return (_a = {},
            _a[gender] = ((_b = generatePersons({
                category: { ageCategoryCode: 'O18' }, // ageCategoryCode is unimportant since birthYear will be replaced
                count: gendersCount[gender],
                addressProps: { citiesCount: 10 },
                personExtensions: [],
                consideredDate: consideredDate,
                sex: gender,
            })) === null || _b === void 0 ? void 0 : _b.persons) || [],
            _a);
    })), false));
    var genderedIndices = (_o = {}, _o[MALE] = 0, _o[FEMALE] = 0, _o[OTHER$2] = 0, _o);
    var individualParticipantsCount = individualParticipants.length;
    var addressComponents = individualParticipants.reduce(function (components, participant) {
        var _a, _b;
        var address = ((_b = (_a = participant.person) === null || _a === void 0 ? void 0 : _a.addresses) === null || _b === void 0 ? void 0 : _b[0]) || {};
        var city = address.city, state = address.state, postalCode = address.postalCode;
        if (!components.cities.includes(city))
            components.cities.push(city);
        if (!components.states.includes(state))
            components.states.push(state);
        if (!components.postalCodes.includes(postalCode))
            components.postalCodes.push(postalCode);
        return components;
    }, { cities: [], postalCodes: [], states: [] });
    var postalCodesCount = addressComponents.postalCodes.length;
    var citiesCount = addressComponents.cities.length;
    var statesCount = addressComponents.states.length;
    var cities = cityMocks({
        count: citiesCount || individualParticipantsCount,
        participantsCount: individualParticipantsCount,
    }).cities;
    var states = stateMocks({
        count: statesCount || individualParticipantsCount,
        participantsCount: individualParticipantsCount,
    }).states;
    var postalCodes = postalCodeMocks({
        count: postalCodesCount || individualParticipantsCount,
        participantsCount: individualParticipantsCount,
    }).postalCodes;
    var addressValues = { cities: cities, states: states, postalCodes: postalCodes };
    individualParticipants.forEach(function (individualParticipant, participantIndex) {
        var _a, _b;
        var person = individualParticipant === null || individualParticipant === void 0 ? void 0 : individualParticipant.person;
        var gender = (person === null || person === void 0 ? void 0 : person.sex) || OTHER$2;
        var birthYear = (_a = extractDate(person === null || person === void 0 ? void 0 : person.birthDate)) === null || _a === void 0 ? void 0 : _a.split('-')[0];
        var genderedIndex = genderedIndices[gender];
        var generatedPerson = genderedPersons[gender][genderedIndex];
        genderedIndices[gender] += 1;
        if (birthYear) {
            var _c = __read(((_b = generatedPerson === null || generatedPerson === void 0 ? void 0 : generatedPerson.birthDate) === null || _b === void 0 ? void 0 : _b.split('-')) || [], 3), month = _c[1], day = _c[2];
            var birthDate = [birthYear, month, day].join('-');
            generatedPerson.birthDate = birthDate;
        }
        if (person === null || person === void 0 ? void 0 : person.addresses) {
            var address = generateAddress(__assign(__assign({}, addressValues), { participantIndex: participantIndex, nationalityCode: generatedPerson.nationalityCode }));
            generatedPerson.addresses = [address];
        }
        generatedPerson.personId = (personIds === null || personIds === void 0 ? void 0 : personIds[participantIndex]) || UUID();
        if (anonymizeParticipantNames) {
            generatedPerson.standardFamilyName = generatedPerson.lastName;
            generatedPerson.standardGivenName = generatedPerson.firstName;
            individualParticipant.participantName = "".concat(generatedPerson.standardGivenName, " ").concat(generatedPerson.standardFamilyName);
        }
        else {
            generatedPerson.standardFamilyName = person === null || person === void 0 ? void 0 : person.standardFamilyName;
            generatedPerson.standardGivenName = person === null || person === void 0 ? void 0 : person.standardGivenName;
        }
        delete generatedPerson.firstName;
        delete generatedPerson.lastName;
        generatedPerson.extensions = filterExtensions(person);
        individualParticipant.person = generatedPerson;
        idMap[person === null || person === void 0 ? void 0 : person.personId] = generatedPerson.personId;
    });
    var pairParticipants = (tournamentRecord.participants || []).filter(function (_a) {
        var participantType = _a.participantType;
        return participantType === PAIR;
    });
    pairParticipants.forEach(function (pairParticipant) {
        var individualParticipantIds = pairParticipant.individualParticipantIds;
        pairParticipant.participantName = generatePairParticipantName({
            individualParticipantIds: individualParticipantIds,
            individualParticipants: individualParticipants,
        });
    });
    var teamParticipants = (tournamentRecord.participants || []).filter(function (_a) {
        var participantType = _a.participantType;
        return participantType === TEAM$1;
    });
    var teamParticipantsCount = teamParticipants.length;
    var teamNames = nameMocks({ count: teamParticipantsCount }).names;
    teamParticipants.forEach(function (teamParticipant, i) {
        teamParticipant.participantName = teamNames[i];
    });
    var groupParticipants = (tournamentRecord.participants || []).filter(function (_a) {
        var participantType = _a.participantType;
        return participantType === GROUP;
    });
    var groupParticipantsCount = groupParticipants.length;
    var groupNames = nameMocks({
        count: groupParticipantsCount,
        nameRoot: 'Group',
    }).names;
    groupParticipants.forEach(function (teamParticipant, i) {
        teamParticipant.participantName = groupNames[i];
    });
    var schedulingProfile = findExtension({
        element: tournamentRecord,
        name: SCHEDULING_PROFILE,
    }).extension;
    // use idMap to update all IDs in schedulingProfile
    if (Array.isArray(schedulingProfile === null || schedulingProfile === void 0 ? void 0 : schedulingProfile.value)) {
        schedulingProfile === null || schedulingProfile === void 0 ? void 0 : schedulingProfile.value.forEach(function (round) {
            round.tournamentId = idMap[round.tournamentId];
            round.structureId = idMap[round.structureId];
            round.eventId = idMap[round.eventId];
            round.drawId = idMap[round.drawId];
        });
    }
    var personRequests = findExtension({
        element: tournamentRecord,
        name: PERSON_REQUESTS,
    }).extension;
    // use idMap to update all IDs in personRequests
    if (Array.isArray(personRequests === null || personRequests === void 0 ? void 0 : personRequests.value)) {
        personRequests === null || personRequests === void 0 ? void 0 : personRequests.value.forEach(function (request) {
            request.personId = idMap[request.personId];
        });
    }
    return __assign({}, SUCCESS);
}
function generatePairParticipantName(_a) {
    var individualParticipantIds = _a.individualParticipantIds, individualParticipants = _a.individualParticipants;
    var participantName = individualParticipants
        .filter(function (_a) {
        var participantId = _a.participantId;
        return individualParticipantIds.includes(participantId);
    })
        .map(function (_a) {
        var person = _a.person;
        return person === null || person === void 0 ? void 0 : person.standardFamilyName;
    })
        .filter(Boolean)
        .sort()
        .join('/');
    if (individualParticipantIds.length === 1)
        participantName += '/Unknown';
    return participantName;
}

var getSetComplement = function (params) {
    var isSide1 = params.isSide1, lowValue = params.lowValue, setTo = params.setTo, tiebreakAt = params.tiebreakAt, NoAD = params.NoAD;
    if (lowValue === undefined)
        return false;
    var valueAsNumber = ensureInt(lowValue);
    // Not necessary?
    if ((valueAsNumber === null || valueAsNumber === void 0 ? void 0 : valueAsNumber.toString().length) > 2) {
        valueAsNumber = parseInt(valueAsNumber.toString().slice(0, 2));
    }
    if (tiebreakAt && tiebreakAt < setTo && valueAsNumber > tiebreakAt) {
        valueAsNumber = tiebreakAt;
    }
    var calculatedValue;
    if (NoAD && !tiebreakAt) {
        calculatedValue = valueAsNumber < setTo ? setTo : setTo - 1;
    }
    else {
        calculatedValue =
            (valueAsNumber + 1 < setTo && setTo) ||
                (tiebreakAt &&
                    tiebreakAt < setTo &&
                    valueAsNumber === tiebreakAt &&
                    setTo) ||
                (!tiebreakAt && valueAsNumber + 2) ||
                setTo + 1;
    }
    var side1Result = isSide1 ? valueAsNumber : calculatedValue;
    var side2Result = !isSide1 ? valueAsNumber : calculatedValue;
    return [side1Result, side2Result];
};
var getTiebreakComplement = function (params) {
    var isSide1 = params.isSide1, lowValue = params.lowValue, tiebreakTo = params.tiebreakTo, tiebreakNoAd = params.tiebreakNoAd;
    if (lowValue === undefined)
        return false;
    var valueAsNumber = typeof lowValue === 'string' ? parseInt(lowValue) : lowValue;
    // Not necessary?
    // do not accept low values greater than two digits;
    if ((valueAsNumber === null || valueAsNumber === void 0 ? void 0 : valueAsNumber.toString().length) > 2) {
        valueAsNumber = parseInt(valueAsNumber.toString().slice(0, 2));
    }
    // If NOAD low lowValue cannot be greater than tiebreakTo - 1
    if (tiebreakNoAd && valueAsNumber > tiebreakTo - 1) {
        valueAsNumber = tiebreakTo - 1;
    }
    var highValue = getHighTiebreakValue$1({
        lowValue: valueAsNumber,
        NoAD: tiebreakNoAd,
        tiebreakTo: tiebreakTo,
    });
    var side1Result = isSide1 ? valueAsNumber : highValue;
    var side2Result = !isSide1 ? valueAsNumber : highValue;
    return [side1Result, side2Result];
};
function getHighTiebreakValue$1(params) {
    var lowValue = params.lowValue, NoAD = params.NoAD, tiebreakTo = params.tiebreakTo;
    var winBy = NoAD ? 1 : 2;
    if (lowValue + 1 >= tiebreakTo) {
        return lowValue + winBy;
    }
    return tiebreakTo;
}

// utility function just to allow testing with string score entry
function parseScoreString(_a) {
    var _b = _a.tiebreakTo, tiebreakTo = _b === void 0 ? 7 : _b, scoreString = _a.scoreString;
    return scoreString
        .split(' ')
        .filter(Boolean)
        .map(function (set, index) { return parseSet({ set: set, setNumber: index + 1 }); });
    function parseSet(_a) {
        var set = _a.set, setNumber = _a.setNumber;
        var matchTiebreak = (set === null || set === void 0 ? void 0 : set.startsWith('[')) &&
            set
                .split('[')[1]
                .split(']')[0]
                .split('-')
                .map(function (sideScore) { return parseInt(sideScore); });
        var setString = (set.includes('(') && set.split('(')[0]) ||
            (set.includes('[') && set.split('[')[0]) ||
            set;
        var setScores = !matchTiebreak &&
            setString.split('-').map(function (sideScore) { return parseInt(sideScore); });
        var winningSide = matchTiebreak
            ? (matchTiebreak[0] > matchTiebreak[1] && 1) ||
                (matchTiebreak[0] < matchTiebreak[1] && 2) ||
                undefined
            : (setScores[0] > setScores[1] && 1) ||
                (setScores[0] < setScores[1] && 2) ||
                undefined;
        var setTiebreakLowScore = set.includes('(')
            ? set.split('(')[1].split(')')[0]
            : undefined;
        var side1TiebreakPerspective = setTiebreakLowScore &&
            getTiebreakComplement({
                lowValue: setTiebreakLowScore,
                isSide1: winningSide === 2,
                tiebreakTo: tiebreakTo,
            });
        var setTiebreak = side1TiebreakPerspective !== null && side1TiebreakPerspective !== void 0 ? side1TiebreakPerspective : [];
        var _b = __read(setScores || [], 2), side1Score = _b[0], side2Score = _b[1];
        var _c = __read(matchTiebreak || setTiebreak || [], 2), side1TiebreakScore = _c[0], side2TiebreakScore = _c[1];
        return {
            side1Score: side1Score,
            side2Score: side2Score,
            side1TiebreakScore: side1TiebreakScore,
            side2TiebreakScore: side2TiebreakScore,
            winningSide: winningSide,
            setNumber: setNumber,
        };
    }
}

/**
 *
 * Generates TODS score object from parseable score string
 *
 * @param {string} scoreString - parseable score string, e.g. '6-0 6-0'
 * @param {number} winningSide - optional - valid values are [1, 2, undefined]
 * @param {string=} matchUpFormat
 * @param {string=} matchUpStatus
 *
 */
function generateOutcomeFromScoreString(params) {
    var matchUpFormat = params.matchUpFormat, matchUpStatus = params.matchUpStatus, winningSide = params.winningSide, scoreString = params.scoreString;
    if (!scoreString)
        return {
            outcome: __assign(__assign({}, toBePlayed), { winningSide: winningSide, matchUpStatus: matchUpStatus }),
        };
    if (winningSide && ![1, 2, undefined].includes(winningSide))
        return { error: INVALID_VALUES, winningSide: winningSide };
    var neutralParsedSets = scoreString && parseScoreString({ scoreString: scoreString });
    var score = {};
    var winningScoreString = generateScoreString({
        sets: neutralParsedSets,
        matchUpFormat: matchUpFormat,
    });
    var losingScoreString = generateScoreString({
        sets: neutralParsedSets,
        reversed: true,
        matchUpFormat: matchUpFormat,
    });
    if (winningSide === 2) {
        score.scoreStringSide1 = losingScoreString;
        score.scoreStringSide2 = winningScoreString;
    }
    else {
        score.scoreStringSide1 = winningScoreString;
        score.scoreStringSide2 = losingScoreString;
    }
    score.sets = parseScoreString({ scoreString: score.scoreStringSide1 });
    return definedAttributes({
        outcome: {
            matchUpStatus: matchUpStatus,
            winningSide: winningSide,
            score: score,
        },
    });
}

function getMatchUpDailyLimits(_a) {
    var tournamentRecords = _a.tournamentRecords, tournamentId = _a.tournamentId;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var tournamentIds = Object.keys(tournamentRecords).filter(function (currentTournamentId) {
        return !tournamentId || currentTournamentId === tournamentId;
    });
    var dailyLimits;
    tournamentIds.forEach(function (tournamentId) {
        var tournamentRecord = tournamentRecords[tournamentId];
        var matchUpDailyLimits = getDailyLimit({
            tournamentRecord: tournamentRecord,
        }).matchUpDailyLimits;
        dailyLimits = matchUpDailyLimits;
    });
    return { matchUpDailyLimits: dailyLimits };
}
function getDailyLimit(params) {
    var _a;
    var _b;
    var paramCheck = checkRequiredParameters(params, [
        (_a = {}, _a[TOURNAMENT_RECORD] = true, _a),
    ]);
    if (paramCheck.error)
        return paramCheck;
    var tournamentRecord = params.tournamentRecord;
    var policy = findPolicy({
        policyType: POLICY_TYPE_SCHEDULING,
        tournamentRecord: tournamentRecord,
    }).policy;
    var extension = findExtension({
        element: tournamentRecord,
        name: SCHEDULE_LIMITS,
    }).extension;
    var tournamentDailyLimits = (_b = extension === null || extension === void 0 ? void 0 : extension.value) === null || _b === void 0 ? void 0 : _b.dailyLimits;
    var policyDailyLimits = policy === null || policy === void 0 ? void 0 : policy.defaultDailyLimits;
    return { matchUpDailyLimits: tournamentDailyLimits || policyDailyLimits };
}

function checkDependenciesScheduled(_a) {
    var _b;
    var matchUpScheduleTimes = _a.matchUpScheduleTimes, matchUpDependencies = _a.matchUpDependencies, allDateMatchUpIds = _a.allDateMatchUpIds, matchUp = _a.matchUp;
    // only those dependencies that are part of the date scheduling profile are important to consider
    var matchUpIdDependencies = (((_b = matchUpDependencies === null || matchUpDependencies === void 0 ? void 0 : matchUpDependencies[matchUp.matchUpId]) === null || _b === void 0 ? void 0 : _b.matchUpIds) || []).filter(function (matchUpId) { return allDateMatchUpIds.includes(matchUpId); });
    var remainingDependencies = matchUpIdDependencies.filter(function (matchUpId) { return !matchUpScheduleTimes[matchUpId]; });
    // when true all the matchUps on which this matchUp is dependent have already been scheduled
    var dependenciesScheduled = !(remainingDependencies === null || remainingDependencies === void 0 ? void 0 : remainingDependencies.length);
    return { dependenciesScheduled: dependenciesScheduled, remainingDependencies: remainingDependencies };
}

function findDrawDefinition$1(_a) {
    var tournamentRecords = _a.tournamentRecords, tournamentRecord = _a.tournamentRecord, tournamentId = _a.tournamentId, drawId = _a.drawId;
    if (!tournamentRecord && !tournamentRecords)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!drawId)
        return { error: MISSING_DRAW_ID };
    if (!tournamentRecord && tournamentRecords) {
        if (typeof tournamentId !== 'string') {
            // find tournamentId by brute force if not provided
            tournamentId = findTournamentId({ tournamentRecords: tournamentRecords, drawId: drawId });
            if (!tournamentId)
                return { error: MISSING_TOURNAMENT_ID };
        }
        tournamentRecord = tournamentRecords[tournamentId];
        if (!tournamentRecord)
            return { error: MISSING_TOURNAMENT_RECORD };
    }
    var result = tournamentRecord && findEvent({ tournamentRecord: tournamentRecord, drawId: drawId });
    if (!(result === null || result === void 0 ? void 0 : result.drawDefinition)) {
        return decorateResult({
            result: { error: DRAW_DEFINITION_NOT_FOUND },
            stack: 'findDrawDefinition',
        });
    }
    return __assign({ drawDefinition: result.drawDefinition, event: result.event, tournamentRecord: tournamentRecord }, SUCCESS);
}

function processNextMatchUps(_a) {
    var _b, _c, _d, _e;
    var matchUpPotentialParticipantIds = _a.matchUpPotentialParticipantIds, matchUpNotBeforeTimes = _a.matchUpNotBeforeTimes, timeAfterRecovery = _a.timeAfterRecovery, matchUp = _a.matchUp;
    var individualParticipantIds = getIndividualParticipantIds(matchUp).individualParticipantIds;
    timeAfterRecovery = timeAfterRecovery !== null && timeAfterRecovery !== void 0 ? timeAfterRecovery : (_b = matchUp.schedule) === null || _b === void 0 ? void 0 : _b.timeAfterRecovery;
    var addPotentialParticipantIds = function (targetMatchUpId) {
        var _a;
        if (!matchUpPotentialParticipantIds[targetMatchUpId])
            matchUpPotentialParticipantIds[targetMatchUpId] = [];
        // push potentials as an array so that if any have progressed to target matchUp
        // others in the array can be identfied as no longer potentials
        matchUpPotentialParticipantIds[targetMatchUpId] = unique((_a = matchUpPotentialParticipantIds[targetMatchUpId]).concat.apply(_a, __spreadArray([], __read(individualParticipantIds), false)));
    };
    // It is necessary to only update timeAfterRecovery if value is greater...
    // ...to account for source matchUps having earlier timeAfterRecovery
    // e.g. roundPosition 1 matchUp timeAfterRecovery is 11:00 but
    // roundPosition 2 matchUp timeAfterRecovery is 9:30
    // and the last one to be processed shouldn't overwrite later value
    var updateNotBeforeTime = function (matchUpId) {
        if (timeAfterRecovery &&
            (!matchUpNotBeforeTimes[matchUpId] ||
                timeAfterRecovery > matchUpNotBeforeTimes[matchUpId])) {
            matchUpNotBeforeTimes[matchUpId] = timeAfterRecovery;
        }
    };
    var winnerMatchUpId = ((_c = matchUp.winnerTo) === null || _c === void 0 ? void 0 : _c.matchUpId) || matchUp.winnerMatchUpId;
    if (winnerMatchUpId) {
        timeAfterRecovery && updateNotBeforeTime(winnerMatchUpId);
        addPotentialParticipantIds(winnerMatchUpId);
    }
    var loserMatchUpId = ((_d = matchUp.loserTo) === null || _d === void 0 ? void 0 : _d.matchUpId) || matchUp.loserMatchUpId;
    if (loserMatchUpId) {
        timeAfterRecovery && updateNotBeforeTime(loserMatchUpId);
        addPotentialParticipantIds(loserMatchUpId);
    }
    if ((_e = matchUp.sidesTo) === null || _e === void 0 ? void 0 : _e.length) {
        matchUp.sidesTo.forEach(function (_a) {
            var matchUpId = _a.matchUpId;
            if (matchUpId) {
                timeAfterRecovery && updateNotBeforeTime(matchUpId);
                addPotentialParticipantIds(matchUpId);
            }
        });
    }
}

function checkParticipantProfileInitialization(_a) {
    var individualParticipantProfiles = _a.individualParticipantProfiles, participantId = _a.participantId;
    if (!individualParticipantProfiles[participantId]) {
        individualParticipantProfiles[participantId] = {
            typeChangeTimeAfterRecovery: undefined,
            timeAfterRecovery: undefined,
            priorMatchUpType: undefined,
            potentialRecovery: {}, // { [drawId]: [timeString] } - timeAfterRecovery for potential matchUps by drawId
            potentialCounted: {}, // whether a potential matchUp has been counted for daily limits for a specific drawId
            potentialBookings: {},
            bookings: [],
            counters: {},
        };
    }
}
function addParticipantPotentialRecovery(_a) {
    var individualParticipantProfiles = _a.individualParticipantProfiles, recoveryValue = _a.recoveryValue, participantId = _a.participantId, scheduleTime = _a.scheduleTime, drawId = _a.drawId;
    if (!individualParticipantProfiles[participantId].potentialRecovery[drawId]) {
        individualParticipantProfiles[participantId].potentialRecovery[drawId] = [];
    }
    individualParticipantProfiles[participantId].potentialRecovery[drawId].push(recoveryValue);
    if (!individualParticipantProfiles[participantId].potentialBookings[drawId]) {
        individualParticipantProfiles[participantId].potentialBookings[drawId] = [];
    }
    individualParticipantProfiles[participantId].potentialBookings[drawId].push({
        timeAfterRecovery: recoveryValue,
        scheduleTime: scheduleTime,
    });
}

function updateTimeAfterRecovery(_a) {
    var _b, _c;
    var matchUpPotentialParticipantIds = _a.matchUpPotentialParticipantIds, individualParticipantProfiles = _a.individualParticipantProfiles, typeChangeRecoveryMinutes = _a.typeChangeRecoveryMinutes, _d = _a.averageMatchUpMinutes, averageMatchUpMinutes = _d === void 0 ? 0 : _d, matchUpNotBeforeTimes = _a.matchUpNotBeforeTimes, matchUpDependencies = _a.matchUpDependencies, _e = _a.recoveryMinutes, recoveryMinutes = _e === void 0 ? 0 : _e, scheduleTime = _a.scheduleTime, matchUp = _a.matchUp;
    var endTime = extractTime((_b = matchUp === null || matchUp === void 0 ? void 0 : matchUp.schedule) === null || _b === void 0 ? void 0 : _b.endTime);
    var timeAfterRecovery = endTime
        ? addMinutesToTimeString(endTime, ensureInt(recoveryMinutes))
        : addMinutesToTimeString(scheduleTime, ensureInt(averageMatchUpMinutes) + ensureInt(recoveryMinutes));
    var typeChangeTimeAfterRecovery = typeChangeRecoveryMinutes &&
        (endTime
            ? addMinutesToTimeString(extractTime(endTime), typeChangeRecoveryMinutes)
            : addMinutesToTimeString(scheduleTime, ensureInt(averageMatchUpMinutes) +
                ensureInt(typeChangeRecoveryMinutes)));
    var participantIdDependencies = ((_c = matchUpDependencies === null || matchUpDependencies === void 0 ? void 0 : matchUpDependencies[matchUp.matchUpId]) === null || _c === void 0 ? void 0 : _c.participantIds) || [];
    var potentialIndividualParticipantIds = ((matchUp.roundPosition &&
        matchUpPotentialParticipantIds[matchUp.matchUpId]) ||
        []).flat();
    participantIdDependencies.forEach(function (participantId) {
        checkParticipantProfileInitialization({
            individualParticipantProfiles: individualParticipantProfiles,
            participantId: participantId,
        });
        var matchUpTypeChange = individualParticipantProfiles[participantId].priorMatchUpType !==
            matchUp.matchUpType;
        // if matchUpType of previous matchUp is different, use typeChangeTimeAfterRecovery (if available)
        var recoveryValue = matchUpTypeChange
            ? typeChangeTimeAfterRecovery || timeAfterRecovery
            : timeAfterRecovery;
        // check whether this participantId is potential or actual for this matchUp
        if (potentialIndividualParticipantIds.includes(participantId)) {
            addParticipantPotentialRecovery({
                individualParticipantProfiles: individualParticipantProfiles,
                drawId: matchUp.drawId,
                recoveryValue: recoveryValue,
                participantId: participantId,
                scheduleTime: scheduleTime,
            });
        }
        else {
            individualParticipantProfiles[participantId].timeAfterRecovery =
                recoveryValue;
            individualParticipantProfiles[participantId].bookings.push({
                scheduleTime: scheduleTime,
                timeAfterRecovery: recoveryValue,
            });
        }
    });
    processNextMatchUps({
        matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
        matchUpNotBeforeTimes: matchUpNotBeforeTimes,
        timeAfterRecovery: timeAfterRecovery,
        matchUp: matchUp,
    });
}

function checkDependendantTiming(_a) {
    var _b, _c, _d, _e, _f;
    var matchUpScheduleTimes = _a.matchUpScheduleTimes, matchUpDependencies = _a.matchUpDependencies, scheduleTime = _a.scheduleTime, matchUpId = _a.matchUpId, details = _a.details;
    var scheduledDependent;
    var recoveryMinutes = (_c = (_b = details.minutesMap) === null || _b === void 0 ? void 0 : _b[matchUpId]) === null || _c === void 0 ? void 0 : _c.recoveryMinutes;
    var averageMatchUpMinutes = (_e = (_d = details.minutesMap) === null || _d === void 0 ? void 0 : _d[matchUpId]) === null || _e === void 0 ? void 0 : _e.averageMinutes;
    var totalMinutes = (averageMatchUpMinutes || 0) + (recoveryMinutes || 0);
    var dependentNotBeforeTime = addMinutesToTimeString(scheduleTime, totalMinutes);
    var matchUpIdDependents = ((_f = matchUpDependencies === null || matchUpDependencies === void 0 ? void 0 : matchUpDependencies[matchUpId]) === null || _f === void 0 ? void 0 : _f.dependentMatchUpIds) || [];
    if (matchUpIdDependents.length) {
        var earliestDependent = matchUpIdDependents.reduce(function (dependent, candidateId) {
            var candidateScheduleTime = matchUpScheduleTimes[candidateId];
            if (!candidateScheduleTime)
                return dependent;
            var candidateDependent = {
                scheduleTime: candidateScheduleTime,
                matchUpId: candidateId,
            };
            if (candidateScheduleTime && !dependent.matchUpId)
                return candidateDependent;
            return timeStringMinutes(candidateScheduleTime) <
                timeStringMinutes(dependent.scheduleTime)
                ? candidateDependent
                : dependent;
        }, {});
        if (earliestDependent.scheduleTime &&
            timeStringMinutes(dependentNotBeforeTime) >
                timeStringMinutes(earliestDependent.scheduleTime)) {
            scheduledDependent = earliestDependent;
        }
    }
    return { scheduledDependent: scheduledDependent };
}

function getIndividualParticipants(matchUp) {
    var _a = matchUp || {}, sides = _a.sides, matchUpType = _a.matchUpType;
    return (sides || [])
        .map(function (side) {
        var _a;
        return ((matchUpType === DOUBLES &&
            (((_a = side === null || side === void 0 ? void 0 : side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipants) || [])) ||
            ((side === null || side === void 0 ? void 0 : side.participant) && [side.participant]) ||
            []);
    })
        .flat();
}

var DO_NOT_SCHEDULE = 'DO_NOT_SCHEDULE';
var requestConstants = {
    DO_NOT_SCHEDULE: DO_NOT_SCHEDULE,
};

/**
 *
 * @param {string} scheduleDate - 'YYYY-MM-DD' date string
 * @param {object} matchUp - matchUp being checked
 * @param {string} scheduleTime - time being checked
 * @param {number} averageMatchUpMinutes - number of minutes matchUp is expected to last
 *
 * @param {object} requestConflicts - tracks per-matchUp conflicts { [requestId]: { scheduleTimes, matchUpIds }}
 * @param {boolean} potentials - whether to consdier potential participants when determining conflicts
 * @param {object} personRequests - contains personRequests { [personId]: [request] }
 *
 * @returns
 */
function checkRequestConflicts(_a) {
    var e_1, _b;
    var _c = _a.averageMatchUpMinutes, averageMatchUpMinutes = _c === void 0 ? 90 : _c, _d = _a.requestConflicts, requestConflicts = _d === void 0 ? {} : _d, _e = _a.potentials, potentials = _e === void 0 ? true : _e, personRequests = _a.personRequests, scheduleTime = _a.scheduleTime, scheduleDate = _a.scheduleDate, matchUp = _a.matchUp;
    var personIds = getIndividualParticipants(matchUp).map(function (_a) {
        var person = _a.person;
        return person === null || person === void 0 ? void 0 : person.personId;
    });
    if (potentials) {
        var potentialPersonIds = ((matchUp === null || matchUp === void 0 ? void 0 : matchUp.potentialParticipants) || [])
            .flat()
            .map(function (_a) {
            var person = _a.person;
            return person === null || person === void 0 ? void 0 : person.personId;
        });
        personIds.push.apply(personIds, __spreadArray([], __read(potentialPersonIds), false));
    }
    var relevantPersonRequests = personIds
        .map(function (personId) { var _a; return (_a = personRequests[personId]) === null || _a === void 0 ? void 0 : _a.map(function (request) { return (__assign(__assign({}, request), { personId: personId })); }); })
        .filter(Boolean)
        .flat()
        .filter(function (request) {
        return request.requestType === DO_NOT_SCHEDULE &&
            sameDay(scheduleDate, request.date);
    });
    var conflicts = [];
    var matchUpId = matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpId;
    var scheduleStart = timeToDate(extractTime(scheduleTime), extractDate(scheduleDate));
    var averageEnd = extractTime(addMinutes(scheduleStart, averageMatchUpMinutes).toISOString());
    try {
        // scheduleTime, averageEnd, startTime and endTime are all string format '00:00'
        // string comparison < > is used to determine...
        // ...if either schedultTime or averageEnd falls between request startTime and endTime
        for (var relevantPersonRequests_1 = __values(relevantPersonRequests), relevantPersonRequests_1_1 = relevantPersonRequests_1.next(); !relevantPersonRequests_1_1.done; relevantPersonRequests_1_1 = relevantPersonRequests_1.next()) {
            var request = relevantPersonRequests_1_1.value;
            var requestId = request.requestId, startTime = request.startTime, endTime = request.endTime;
            var conflict = (scheduleTime > startTime && scheduleTime < endTime) ||
                (averageEnd > startTime && averageEnd < endTime);
            if (conflict) {
                conflicts.push({ matchUpId: matchUpId, request: request, scheduleTime: scheduleTime });
                if (!requestConflicts[requestId]) {
                    requestConflicts[requestId] = {
                        request: request,
                        scheduleTimes: [scheduleTime],
                        matchUpIds: [matchUpId],
                    };
                }
                else {
                    if (!requestConflicts[requestId].scheduleTimes.includes(scheduleTime))
                        requestConflicts[requestId].scheduleTimes.push(scheduleTime);
                    if (!requestConflicts[requestId].matchUpIds.includes(matchUpId))
                        requestConflicts[requestId].matchUpIds.push(matchUpId);
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (relevantPersonRequests_1_1 && !relevantPersonRequests_1_1.done && (_b = relevantPersonRequests_1.return)) _b.call(relevantPersonRequests_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { conflicts: conflicts };
}

function findMatchUpFormatTiming(_a) {
    var _b = _a.defaultRecoveryMinutes, defaultRecoveryMinutes = _b === void 0 ? 0 : _b, defaultAverageMinutes = _a.defaultAverageMinutes, tournamentRecords = _a.tournamentRecords, matchUpFormat = _a.matchUpFormat, categoryName = _a.categoryName, categoryType = _a.categoryType, tournamentId = _a.tournamentId, eventType = _a.eventType, eventId = _a.eventId;
    if (!isValidMatchUpFormat({ matchUpFormat: matchUpFormat }))
        return { error: UNRECOGNIZED_MATCHUP_FORMAT };
    var tournamentIds = Object.keys(tournamentRecords).filter(function (currentTournamentId) {
        return !tournamentId || currentTournamentId === tournamentId;
    });
    var timing;
    tournamentIds.forEach(function (currentTournamentId) {
        var _a;
        if (timing)
            return;
        var tournamentRecord = tournamentRecords[currentTournamentId];
        var event = eventId
            ? (_a = findEvent({ tournamentRecord: tournamentRecord, eventId: eventId })) === null || _a === void 0 ? void 0 : _a.event
            : undefined;
        timing = getMatchUpFormatTiming({
            tournamentRecord: tournamentRecord,
            matchUpFormat: matchUpFormat,
            categoryName: categoryName,
            categoryType: categoryType,
            eventType: eventType,
            event: event,
        });
        return (timing === null || timing === void 0 ? void 0 : timing.averageMinutes) || (timing === null || timing === void 0 ? void 0 : timing.recoveryMinutes);
    });
    return {
        recoveryMinutes: (timing === null || timing === void 0 ? void 0 : timing.recoveryMinutes) || defaultRecoveryMinutes,
        averageMinutes: (timing === null || timing === void 0 ? void 0 : timing.averageMinutes) || defaultAverageMinutes,
        typeChangeRecoveryMinutes: (timing === null || timing === void 0 ? void 0 : timing.typeChangeRecoveryMinutes) ||
            (timing === null || timing === void 0 ? void 0 : timing.recoveryMinutes) ||
            defaultRecoveryMinutes,
    };
}

function getScheduledRoundsDetails(_a) {
    var scheduleCompletedMatchUps = _a.scheduleCompletedMatchUps, containedStructureIds = _a.containedStructureIds, // optional to support calling method outside of scheduleProfileRounds
    tournamentRecords = _a.tournamentRecords, _b = _a.periodLength, periodLength = _b === void 0 ? 30 : _b, matchUps = _a.matchUps, // optional to support calling method outside of scheduleProfileRounds
    rounds = _a.rounds;
    if (typeof tournamentRecords !== 'object')
        return { error: MISSING_TOURNAMENT_RECORDS };
    if (!Array.isArray(rounds))
        return { error: MISSING_VALUE, info: mustBeAnArray('rounds') };
    var matchUpFormatCohorts = {};
    var orderedMatchUpIds = [];
    rounds.sort(function (a, b) { var _a, _b; return ((_a = a.sortOrder) !== null && _a !== void 0 ? _a : 0) - ((_b = b.sortOrder) !== null && _b !== void 0 ? _b : 0); });
    // ---------------------------------------------------------
    // populate required variables if not provided by parameters
    containedStructureIds =
        containedStructureIds !== null && containedStructureIds !== void 0 ? containedStructureIds : Object.assign.apply(Object, __spreadArray([{}], __read(Object.values(tournamentRecords).map(function (tournamentRecord) {
            return getContainedStructures({ tournamentRecord: tournamentRecord }).containedStructures;
        })), false));
    if (!matchUps) {
        (matchUps = allCompetitionMatchUps({
            nextMatchUps: true,
            tournamentRecords: tournamentRecords,
        }).matchUps);
    }
    // ---------------------------------------------------------
    var greatestAverageMinutes = 0;
    var recoveryMinutesMap = {};
    var averageMinutesMap = {};
    var minutesMap = {};
    var scheduledRoundsDetails = rounds.flatMap(function (round) {
        var e_1, _a, e_2, _b;
        var _c;
        var roundPeriodLength = round.periodLength || periodLength;
        var structureIds = [];
        if (containedStructureIds === null || containedStructureIds === void 0 ? void 0 : containedStructureIds[round.structureId]) {
            structureIds.push.apply(structureIds, __spreadArray([], __read(containedStructureIds[round.structureId]), false));
        }
        else {
            structureIds.push(round.structureId);
        }
        var roundMatchUps = matchUps
            ? filterMatchUps({
                tournamentIds: [round.tournamentId],
                roundNumbers: [round.roundNumber],
                matchUpIds: round.matchUpIds,
                eventIds: [round.eventId],
                drawIds: [round.drawId],
                processContext: true,
                structureIds: structureIds,
                matchUps: matchUps,
            }).sort(matchUpSort)
            : [];
        // filter by roundSegment
        var _d = round.roundSegment || {}, segmentNumber = _d.segmentNumber, segmentsCount = _d.segmentsCount;
        if (isConvertableInteger(segmentNumber) &&
            isPowerOf2(roundMatchUps === null || roundMatchUps === void 0 ? void 0 : roundMatchUps.length) &&
            isPowerOf2(segmentsCount) &&
            segmentNumber > 0 &&
            segmentNumber <= segmentsCount &&
            segmentsCount < (roundMatchUps === null || roundMatchUps === void 0 ? void 0 : roundMatchUps.length) &&
            !((_c = round.matchUpIds) === null || _c === void 0 ? void 0 : _c.length)) {
            var segmentSize = roundMatchUps.length / segmentsCount;
            var firstSegmentIndex = segmentSize * (segmentNumber - 1);
            roundMatchUps = roundMatchUps.slice(firstSegmentIndex, firstSegmentIndex + segmentSize);
        }
        var tournamentRecord = tournamentRecords[round.tournamentId];
        var event = findEvent({
            drawId: round.drawId,
            tournamentRecord: tournamentRecord,
        }).event;
        var matchUpFormatOrder = [];
        try {
            for (var roundMatchUps_1 = __values(roundMatchUps), roundMatchUps_1_1 = roundMatchUps_1.next(); !roundMatchUps_1_1.done; roundMatchUps_1_1 = roundMatchUps_1.next()) {
                var matchUp = roundMatchUps_1_1.value;
                var matchUpFormat = matchUp.matchUpFormat;
                if (matchUpFormat) {
                    if (!matchUpFormatCohorts[matchUpFormat]) {
                        matchUpFormatCohorts[matchUpFormat] = [];
                        matchUpFormatCohorts[matchUpFormat].push(matchUp);
                    }
                    matchUpFormatOrder.push(matchUpFormat);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (roundMatchUps_1_1 && !roundMatchUps_1_1.done && (_a = roundMatchUps_1.return)) _a.call(roundMatchUps_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var _loop_1 = function (matchUpFormat) {
            var _e = event !== null && event !== void 0 ? event : {}, eventType = _e.eventType, category = _e.category;
            var _f = category !== null && category !== void 0 ? category : {}, categoryName = _f.categoryName, ageCategoryCode = _f.ageCategoryCode;
            var _g = findMatchUpFormatTiming({
                categoryName: categoryName !== null && categoryName !== void 0 ? categoryName : ageCategoryCode,
                categoryType: category === null || category === void 0 ? void 0 : category.categoryType,
                tournamentId: round.tournamentId,
                eventId: round.eventId,
                tournamentRecords: tournamentRecords,
                matchUpFormat: matchUpFormat,
                eventType: eventType,
            }), typeChangeRecoveryMinutes = _g.typeChangeRecoveryMinutes, recoveryMinutes = _g.recoveryMinutes, averageMinutes = _g.averageMinutes, error = _g.error;
            if (error)
                return { value: { error: error, round: round } };
            var matchUpIds = roundMatchUps
                .filter(function (rm) {
                // don't attempt to scheduled completed matchUpstatuses unless explicit override
                return (scheduleCompletedMatchUps ||
                    !completedMatchUpStatuses.includes(rm.matchUpStatus)) &&
                    rm.matchUpStatus !== BYE;
            })
                .map(getMatchUpId);
            matchUpIds.forEach(function (matchUpId) {
                minutesMap[matchUpId] = {
                    typeChangeRecoveryMinutes: typeChangeRecoveryMinutes,
                    recoveryMinutes: recoveryMinutes,
                    averageMinutes: averageMinutes,
                };
                recoveryMinutesMap[matchUpId] = recoveryMinutes;
                averageMinutesMap[matchUpId] = averageMinutes;
            });
            orderedMatchUpIds.push.apply(orderedMatchUpIds, __spreadArray([], __read(matchUpIds), false));
            greatestAverageMinutes = Math.max(averageMinutes || 0, greatestAverageMinutes);
            var hash = "".concat(averageMinutes, "|").concat(roundPeriodLength);
            return { value: {
                    roundPeriodLength: roundPeriodLength,
                    recoveryMinutes: recoveryMinutes,
                    averageMinutes: averageMinutes,
                    matchUpIds: matchUpIds,
                    hash: hash,
                } };
        };
        try {
            for (var matchUpFormatOrder_1 = __values(matchUpFormatOrder), matchUpFormatOrder_1_1 = matchUpFormatOrder_1.next(); !matchUpFormatOrder_1_1.done; matchUpFormatOrder_1_1 = matchUpFormatOrder_1.next()) {
                var matchUpFormat = matchUpFormatOrder_1_1.value;
                var state_1 = _loop_1(matchUpFormat);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (matchUpFormatOrder_1_1 && !matchUpFormatOrder_1_1.done && (_b = matchUpFormatOrder_1.return)) _b.call(matchUpFormatOrder_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return undefined;
    });
    return __assign({ scheduledRoundsDetails: scheduledRoundsDetails, greatestAverageMinutes: greatestAverageMinutes, matchUpFormatCohorts: matchUpFormatCohorts, recoveryMinutesMap: recoveryMinutesMap, averageMinutesMap: averageMinutesMap, orderedMatchUpIds: orderedMatchUpIds, minutesMap: minutesMap }, SUCCESS);
}

// groups schedule profile rounds where adjacent hashes are equivalent
// if { garmanSinglePass: true } then group all rounds into a single group
// if { garmanSinglePass: true } then the one group has greatestAverageMinutes
function getGroupedRounds(_a) {
    var e_1, _b;
    var scheduledRoundsDetails = _a.scheduledRoundsDetails, greatestAverageMinutes = _a.greatestAverageMinutes, garmanSinglePass = _a.garmanSinglePass;
    var groupedRounds = [];
    var groupedMatchUpIds = [];
    var roundPeriodLength;
    var recoveryMinutes;
    var averageMinutes;
    var lastHash;
    try {
        for (var _c = __values(scheduledRoundsDetails.filter(Boolean)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var roundDetails = _d.value;
            if (!lastHash)
                lastHash = roundDetails.hash;
            if (roundDetails.hash === lastHash || garmanSinglePass) {
                groupedMatchUpIds = groupedMatchUpIds.concat(roundDetails.matchUpIds);
            }
            if (roundDetails.hash !== lastHash && !garmanSinglePass) {
                lastHash = roundDetails.hash;
                groupedRounds.push({
                    averageMinutes: averageMinutes,
                    recoveryMinutes: recoveryMinutes,
                    roundPeriodLength: roundPeriodLength,
                    matchUpIds: groupedMatchUpIds,
                });
                groupedMatchUpIds = roundDetails.matchUpIds;
            }
            averageMinutes = garmanSinglePass
                ? greatestAverageMinutes
                : roundDetails.averageMinutes;
            recoveryMinutes = roundDetails.recoveryMinutes;
            roundPeriodLength = roundDetails.roundPeriodLength;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (groupedMatchUpIds.length) {
        groupedRounds.push({
            matchUpIds: groupedMatchUpIds,
            roundPeriodLength: roundPeriodLength,
            recoveryMinutes: recoveryMinutes,
            averageMinutes: averageMinutes,
        });
    }
    return { groupedRounds: groupedRounds };
}

function modifyParticipantMatchUpsCount(_a) {
    var matchUpPotentialParticipantIds = _a.matchUpPotentialParticipantIds, individualParticipantProfiles = _a.individualParticipantProfiles, matchUp = _a.matchUp, value = _a.value;
    var matchUpType = matchUp.matchUpType;
    // individualParticipantIds represent those participants already present
    var individualParticipantIds = getIndividualParticipantIds(matchUp).individualParticipantIds;
    // potentialParticipantIds are those who could progress to this matchUp
    var potentialParticipantIds = matchUpPotentialParticipantIds[matchUp.matchUpId] || [];
    // filteredPotentials exclude potentials if any of the participantIds
    // are present in individualParticipantIds which ensures that source match losers
    // do not get considered when incrementing or decrementing matchUp counters
    var filteredPotentials = potentialParticipantIds
        .filter(function (potentials) { return !overlap(potentials, individualParticipantIds); })
        .flat();
    var consideredParticipantIds = __spreadArray(__spreadArray([], __read(individualParticipantIds), false), __read(filteredPotentials), false);
    consideredParticipantIds.forEach(function (participantId) {
        checkParticipantProfileInitialization({
            individualParticipantProfiles: individualParticipantProfiles,
            participantId: participantId,
        });
        if (!individualParticipantProfiles[participantId].potentialCounted[matchUp.drawId]) {
            var counters = individualParticipantProfiles[participantId].counters;
            if (counters[matchUpType])
                counters[matchUpType] += value;
            else if (value > 0)
                counters[matchUpType] = value;
            if (counters[TOTAL])
                counters[TOTAL] += value;
            else if (value > 0)
                counters[TOTAL] = value;
            if (filteredPotentials.includes(participantId)) {
                individualParticipantProfiles[participantId].potentialCounted[matchUp.drawId] = true;
            }
        }
    });
}

var hasSchedule = function (_a) {
    var _b = _a.scheduleAttributes, scheduleAttributes = _b === void 0 ? ['scheduledDate', 'scheduledTime'] : _b, _c = _a.schedule, schedule = _c === void 0 ? {} : _c;
    var matchUpScheduleKeys = Object.keys(schedule)
        .filter(function (key) { return scheduleAttributes.includes(key); })
        .filter(function (key) { return schedule[key]; });
    return !!matchUpScheduleKeys.length;
};

function processAlreadyScheduledMatchUps(_a) {
    var e_1, _b;
    var _c, _d;
    var matchUpPotentialParticipantIds = _a.matchUpPotentialParticipantIds, individualParticipantProfiles = _a.individualParticipantProfiles, dateScheduledMatchUpIds = _a.dateScheduledMatchUpIds, greatestAverageMinutes = _a.greatestAverageMinutes, dateScheduledMatchUps = _a.dateScheduledMatchUps, matchUpNotBeforeTimes = _a.matchUpNotBeforeTimes, matchUpScheduleTimes = _a.matchUpScheduleTimes, matchUpDependencies = _a.matchUpDependencies, clearScheduleDates = _a.clearScheduleDates, scheduleDate = _a.scheduleDate, minutesMap = _a.minutesMap, matchUps = _a.matchUps;
    var byeScheduledMatchUpDetails = [];
    if (!dateScheduledMatchUpIds) {
        dateScheduledMatchUps = matchUps === null || matchUps === void 0 ? void 0 : matchUps.filter(function (matchUp) {
            var schedule = matchUp.schedule || {};
            var isByeMatchUp = matchUp.matchUpStatus === BYE;
            if (isByeMatchUp)
                byeScheduledMatchUpDetails.push({
                    tournamentId: matchUp.tournamentId,
                    matchUpId: matchUp.matchUpId,
                });
            return (!isByeMatchUp &&
                hasSchedule({ schedule: schedule }) &&
                (!scheduleDate || matchUp.schedule.scheduledDate === scheduleDate));
        });
        dateScheduledMatchUpIds = dateScheduledMatchUps.map(getMatchUpId);
    }
    // first build up a map of matchUpNotBeforeTimes and matchUpPotentialParticipantIds
    // based on already scheduled matchUps
    var clearDate = Array.isArray(clearScheduleDates)
        ? clearScheduleDates.includes(scheduleDate)
        : clearScheduleDates;
    var alreadyScheduled = clearDate
        ? []
        : matchUps.filter(function (_a) {
            var matchUpId = _a.matchUpId;
            return dateScheduledMatchUpIds.includes(matchUpId);
        });
    try {
        for (var alreadyScheduled_1 = __values(alreadyScheduled), alreadyScheduled_1_1 = alreadyScheduled_1.next(); !alreadyScheduled_1_1.done; alreadyScheduled_1_1 = alreadyScheduled_1.next()) {
            var matchUp = alreadyScheduled_1_1.value;
            modifyParticipantMatchUpsCount({
                matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
                individualParticipantProfiles: individualParticipantProfiles,
                value: 1,
                matchUp: matchUp,
            });
            var scheduleTime = (_c = matchUp.schedule) === null || _c === void 0 ? void 0 : _c.scheduledTime;
            if (scheduleTime) {
                matchUpScheduleTimes[matchUp.matchUpId] = scheduleTime;
                var recoveryMinutes = (_d = minutesMap === null || minutesMap === void 0 ? void 0 : minutesMap[matchUp.matchUpId]) === null || _d === void 0 ? void 0 : _d.recoveryMinutes;
                var averageMatchUpMinutes = greatestAverageMinutes;
                // minutesMap?.[matchUp.matchUpId]?.averageMinutes; // for the future when variable averageMinutes supported
                updateTimeAfterRecovery({
                    individualParticipantProfiles: individualParticipantProfiles,
                    matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
                    matchUpNotBeforeTimes: matchUpNotBeforeTimes,
                    matchUpDependencies: matchUpDependencies,
                    averageMatchUpMinutes: averageMatchUpMinutes,
                    recoveryMinutes: recoveryMinutes,
                    scheduleTime: scheduleTime,
                    matchUp: matchUp,
                });
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (alreadyScheduled_1_1 && !alreadyScheduled_1_1.done && (_b = alreadyScheduled_1.return)) _b.call(alreadyScheduled_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return {
        dateScheduledMatchUpIds: dateScheduledMatchUpIds,
        byeScheduledMatchUpDetails: byeScheduledMatchUpDetails,
        dateScheduledMatchUps: dateScheduledMatchUps,
        clearDate: clearDate,
    };
}

function getMatchUpsToSchedule(_a) {
    var matchUpPotentialParticipantIds = _a.matchUpPotentialParticipantIds, scheduleCompletedMatchUps = _a.scheduleCompletedMatchUps, dateScheduledMatchUpIds = _a.dateScheduledMatchUpIds, matchUpNotBeforeTimes = _a.matchUpNotBeforeTimes, matchUpScheduleTimes = _a.matchUpScheduleTimes, orderedMatchUpIds = _a.orderedMatchUpIds, clearDate = _a.clearDate, matchUps = _a.matchUps;
    var alreadyScheduledMatchUpIds = Object.keys(matchUpScheduleTimes);
    // this must be done to preserve the order of matchUpIds
    var matchUpsToSchedule = orderedMatchUpIds
        .map(function (matchUpId) {
        return matchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
    })
        .filter(Boolean)
        .filter(function (matchUp) {
        var alreadyScheduled = !clearDate &&
            (dateScheduledMatchUpIds.includes(matchUp.matchUpId) ||
                alreadyScheduledMatchUpIds.includes(matchUp.matchUpId));
        var doNotSchedule = [
            BYE,
            DEFAULTED,
            COMPLETED$1,
            ABANDONED$1,
            RETIRED$1,
            WALKOVER$2,
            DOUBLE_WALKOVER,
            DOUBLE_DEFAULT,
        ].includes(matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpStatus);
        return (scheduleCompletedMatchUps || // override for mocksEngine
            (!alreadyScheduled && !matchUp.winningSide && !doNotSchedule));
    });
    // for optimization, build up an object for each tournament and an array for each draw with target matchUps
    // keep track of matchUps counts per participant and don't add matchUps for participants beyond those limits
    var matchUpMap = matchUpsToSchedule.reduce(function (aggregator, matchUp) {
        var drawId = matchUp.drawId, tournamentId = matchUp.tournamentId;
        if (!aggregator.matchUpMap[tournamentId])
            aggregator.matchUpMap[tournamentId] = {};
        if (!aggregator.matchUpMap[tournamentId][drawId]) {
            aggregator.matchUpMap[tournamentId][drawId] = [matchUp];
        }
        else {
            aggregator.matchUpMap[tournamentId][drawId].push(matchUp);
        }
        // since this matchUp is to be scheduled, update the matchUpPotentialParticipantIds
        processNextMatchUps({
            matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
            matchUpNotBeforeTimes: matchUpNotBeforeTimes,
            matchUp: matchUp,
        });
        return aggregator;
    }, { matchUpMap: {} }).matchUpMap;
    return { matchUpsToSchedule: matchUpsToSchedule, matchUpMap: matchUpMap };
}

function generateBookings(_a) {
    var _b = _a.defaultRecoveryMinutes, defaultRecoveryMinutes = _b === void 0 ? 0 : _b, _c = _a.averageMatchUpMinutes, averageMatchUpMinutes = _c === void 0 ? 90 : _c, dateScheduledMatchUps = _a.dateScheduledMatchUps, tournamentRecords = _a.tournamentRecords, _d = _a.venueIds, venueIds = _d === void 0 ? [] : _d, periodLength = _a.periodLength, scheduleDate = _a.scheduleDate, matchUps = _a.matchUps;
    if (typeof tournamentRecords !== 'object')
        return { error: MISSING_TOURNAMENT_RECORDS };
    if (!validMatchUps(matchUps) && !Array.isArray(dateScheduledMatchUps))
        return { error: MISSING_MATCHUPS };
    periodLength =
        periodLength !== null && periodLength !== void 0 ? periodLength : calculatePeriodLength({
            recoveryMinutes: defaultRecoveryMinutes,
            averageMatchUpMinutes: averageMatchUpMinutes,
        });
    // get a mapping of eventIds to category details
    var eventDetails = Object.assign.apply(Object, __spreadArray([{}], __read(Object.values(tournamentRecords)
        .map(function (tournamentRecord) {
        var _a;
        return ((_a = tournamentRecord.events) !== null && _a !== void 0 ? _a : []).map(function (event) {
            var _a;
            var scheduleTiming = getScheduleTiming({
                tournamentRecord: tournamentRecord,
                event: event,
            }).scheduleTiming;
            return _a = {},
                _a[event.eventId] = { event: event, scheduleTiming: scheduleTiming },
                _a;
        });
    })
        .flat()), false));
    var defaultTiming = {
        averageTimes: [{ minutes: { default: averageMatchUpMinutes } }],
        recoveryTimes: [{ minutes: { default: defaultRecoveryMinutes } }],
    };
    if (!dateScheduledMatchUps) {
        dateScheduledMatchUps = matchUps === null || matchUps === void 0 ? void 0 : matchUps.filter(function (matchUp) {
            var schedule = matchUp.schedule;
            return (hasSchedule({ schedule: schedule }) &&
                (!scheduleDate || matchUp.schedule.scheduledDate === scheduleDate));
        });
    }
    var relevantMatchUps = dateScheduledMatchUps === null || dateScheduledMatchUps === void 0 ? void 0 : dateScheduledMatchUps.filter(function (matchUp) {
        return (!venueIds.length || venueIds.includes(matchUp.schedule.venueId)) &&
            matchUp.matchUpStatus !== BYE;
    });
    var bookings = relevantMatchUps === null || relevantMatchUps === void 0 ? void 0 : relevantMatchUps.map(function (_a) {
        var eventId = _a.eventId, schedule = _a.schedule, matchUpFormat = _a.matchUpFormat;
        var _b = eventDetails[eventId], event = _b.event, scheduleTiming = _b.scheduleTiming;
        var eventType = event === null || event === void 0 ? void 0 : event.eventType;
        var timingDetails = __assign(__assign({}, scheduleTiming), { defaultTiming: defaultTiming, matchUpFormat: matchUpFormat });
        var _c = matchUpFormatTimes({
            timingDetails: timingDetails,
            eventType: eventType,
        }), averageMinutes = _c.averageMinutes, recoveryMinutes = _c.recoveryMinutes;
        var courtId = schedule.courtId, venueId = schedule.venueId;
        var startTime = extractTime(schedule.scheduledTime);
        var endTime = addMinutesToTimeString(startTime, averageMinutes);
        return {
            recoveryMinutes: recoveryMinutes,
            averageMinutes: averageMinutes,
            periodLength: periodLength,
            startTime: startTime,
            courtId: courtId,
            endTime: endTime,
            venueId: venueId,
        };
    }).filter(Boolean);
    return { bookings: bookings, relevantMatchUps: relevantMatchUps, dateScheduledMatchUps: dateScheduledMatchUps };
}

function generateScheduleTimes(_a) {
    var _b;
    var _c;
    var _d = _a.calculateStartTimeFromCourts, calculateStartTimeFromCourts = _d === void 0 ? true : _d, remainingScheduleTimes = _a.remainingScheduleTimes, defaultRecoveryMinutes = _a.defaultRecoveryMinutes, averageMatchUpMinutes = _a.averageMatchUpMinutes, clearScheduleDates = _a.clearScheduleDates, tournamentRecords = _a.tournamentRecords, tournamentRecord = _a.tournamentRecord, periodLength = _a.periodLength, scheduleDate = _a.scheduleDate, startTime = _a.startTime, venueIds = _a.venueIds, matchUps = _a.matchUps, endTime = _a.endTime;
    if (tournamentRecord && !tournamentRecords) {
        tournamentRecords = (_b = {}, _b[tournamentRecord.tournamentId] = tournamentRecord, _b);
    }
    if (typeof tournamentRecords !== 'object' || !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    periodLength =
        periodLength !== null && periodLength !== void 0 ? periodLength : calculatePeriodLength({
            recoveryMinutes: defaultRecoveryMinutes,
            averageMatchUpMinutes: averageMatchUpMinutes,
        });
    var _e = getVenuesAndCourts({
        dates: [scheduleDate],
        ignoreDisabled: true,
        tournamentRecords: tournamentRecords,
    }), allCourts = _e.courts, venues = _e.venues;
    var courts = (_c = allCourts === null || allCourts === void 0 ? void 0 : allCourts.filter(function (court) { return !venueIds || venueIds.includes(court.venueId); })) !== null && _c !== void 0 ? _c : [];
    startTime = startTime !== null && startTime !== void 0 ? startTime : getDateTimeBoundary({ courts: courts, scheduleDate: scheduleDate, startTime: true });
    endTime = endTime !== null && endTime !== void 0 ? endTime : getDateTimeBoundary({ courts: courts, scheduleDate: scheduleDate, endTime: true });
    var _f = generateBookings({
        defaultRecoveryMinutes: defaultRecoveryMinutes,
        averageMatchUpMinutes: averageMatchUpMinutes,
        tournamentRecords: tournamentRecords,
        scheduleDate: scheduleDate,
        periodLength: periodLength,
        venueIds: venueIds,
        matchUps: matchUps,
    }), bookings = _f.bookings, dateScheduledMatchUps = _f.dateScheduledMatchUps;
    var timingParameters = {
        calculateStartTimeFromCourts: calculateStartTimeFromCourts,
        remainingScheduleTimes: remainingScheduleTimes,
        averageMatchUpMinutes: averageMatchUpMinutes,
        clearScheduleDates: clearScheduleDates,
        date: scheduleDate,
        periodLength: periodLength,
        startTime: startTime,
        bookings: bookings,
        endTime: endTime,
        courts: courts,
    };
    var scheduleTimes = getScheduleTimes(timingParameters).scheduleTimes;
    // if a single venue specified, or only one venue available, return venueId
    var venueId = ((venueIds === null || venueIds === void 0 ? void 0 : venueIds.length) === 1 && venueIds[0]) || ((venues === null || venues === void 0 ? void 0 : venues.length) === 1 && venues[0].venueId) || undefined;
    var dateScheduledMatchUpIds = dateScheduledMatchUps === null || dateScheduledMatchUps === void 0 ? void 0 : dateScheduledMatchUps.map(xa('matchUpId'));
    return {
        dateScheduledMatchUpIds: dateScheduledMatchUpIds,
        dateScheduledMatchUps: dateScheduledMatchUps,
        scheduleTimes: scheduleTimes,
        venueId: venueId,
    };
}

function getVenueSchedulingDetails(_a) {
    var e_1, _b;
    var _c;
    var matchUpPotentialParticipantIds = _a.matchUpPotentialParticipantIds, individualParticipantProfiles = _a.individualParticipantProfiles, scheduleCompletedMatchUps = _a.scheduleCompletedMatchUps, containedStructureIds = _a.containedStructureIds, matchUpNotBeforeTimes = _a.matchUpNotBeforeTimes, matchUpScheduleTimes = _a.matchUpScheduleTimes, matchUpDependencies = _a.matchUpDependencies, clearScheduleDates = _a.clearScheduleDates, tournamentRecords = _a.tournamentRecords, periodLength = _a.periodLength, scheduleDate = _a.scheduleDate, useGarman = _a.useGarman, matchUps = _a.matchUps, courts = _a.courts, venues = _a.venues;
    var venueScheduledRoundDetails = {};
    // checking that matchUpDependencies is scoped to only those matchUps that are already or are to be scheduled on the same date
    var allDateScheduledMatchUpIds = [];
    var allDateScheduledByeMatchUpDetails = [];
    var allDateMatchUpIds = [];
    var _loop_1 = function (venue) {
        var _d;
        var _e = venue.rounds, rounds = _e === void 0 ? [] : _e, venueId = venue.venueId; // rounds derives from dateSchedulingProfile
        var _f = getScheduledRoundsDetails({
            scheduleCompletedMatchUps: scheduleCompletedMatchUps,
            containedStructureIds: containedStructureIds,
            tournamentRecords: tournamentRecords,
            periodLength: periodLength,
            matchUps: matchUps,
            rounds: rounds,
        }), scheduledRoundsDetails = _f.scheduledRoundsDetails, greatestAverageMinutes = _f.greatestAverageMinutes, orderedMatchUpIds = _f.orderedMatchUpIds, minutesMap = _f.minutesMap;
        allDateMatchUpIds.push.apply(allDateMatchUpIds, __spreadArray([], __read((orderedMatchUpIds !== null && orderedMatchUpIds !== void 0 ? orderedMatchUpIds : [])), false));
        var groupedRounds = getGroupedRounds({
            scheduledRoundsDetails: scheduledRoundsDetails,
            greatestAverageMinutes: greatestAverageMinutes,
            garmanSinglePass: true,
        }).groupedRounds;
        var dateScheduledMatchUpIds = void 0;
        var dateScheduledMatchUps = void 0;
        var scheduleTimes = [];
        if (useGarman) {
            // determines court availability taking into account already scheduled matchUps on the scheduleDate
            // optimization to pass already retrieved competitionMatchUps to avoid refetch (requires refactor)
            // on first call pass in the averageMatchUpMiutes of first round to be scheduled
            (_d = generateScheduleTimes({
                averageMatchUpMinutes: (_c = groupedRounds[0]) === null || _c === void 0 ? void 0 : _c.averageMinutes,
                scheduleDate: extractDate(scheduleDate),
                venueIds: [venue.venueId],
                clearScheduleDates: clearScheduleDates,
                tournamentRecords: tournamentRecords,
                periodLength: periodLength,
                matchUps: matchUps,
            }), scheduleTimes = _d.scheduleTimes, dateScheduledMatchUpIds = _d.dateScheduledMatchUpIds, dateScheduledMatchUps = _d.dateScheduledMatchUps);
        }
        var processResult = processAlreadyScheduledMatchUps({
            matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
            individualParticipantProfiles: individualParticipantProfiles,
            dateScheduledMatchUpIds: dateScheduledMatchUpIds,
            greatestAverageMinutes: greatestAverageMinutes,
            matchUpNotBeforeTimes: matchUpNotBeforeTimes,
            matchUpScheduleTimes: matchUpScheduleTimes,
            matchUpDependencies: matchUpDependencies,
            clearScheduleDates: clearScheduleDates,
            scheduleDate: scheduleDate,
            minutesMap: minutesMap,
            matchUps: matchUps,
        });
        (dateScheduledMatchUpIds = processResult.dateScheduledMatchUpIds, dateScheduledMatchUps = processResult.dateScheduledMatchUps);
        var byeScheduledMatchUpDetails = processResult.byeScheduledMatchUpDetails, clearDate = processResult.clearDate;
        if (byeScheduledMatchUpDetails === null || byeScheduledMatchUpDetails === void 0 ? void 0 : byeScheduledMatchUpDetails.length)
            allDateScheduledByeMatchUpDetails.push.apply(allDateScheduledByeMatchUpDetails, __spreadArray([], __read(byeScheduledMatchUpDetails), false));
        var _g = getMatchUpsToSchedule({
            matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
            scheduleCompletedMatchUps: scheduleCompletedMatchUps,
            dateScheduledMatchUpIds: dateScheduledMatchUpIds,
            matchUpNotBeforeTimes: matchUpNotBeforeTimes,
            matchUpScheduleTimes: matchUpScheduleTimes,
            orderedMatchUpIds: orderedMatchUpIds,
            clearDate: clearDate,
            matchUps: matchUps,
        }), matchUpsToSchedule = _g.matchUpsToSchedule, matchUpMap = _g.matchUpMap;
        var venueCourts = courts.filter(function (court) { return court.venueId === venueId; });
        venueScheduledRoundDetails[venueId] = {
            previousRemainingScheduleTimes: [], // keep track of sheduleTimes not used on previous iteration
            courtsCount: venueCourts.length,
            greatestAverageMinutes: greatestAverageMinutes,
            scheduledRoundsDetails: scheduledRoundsDetails,
            dateScheduledMatchUps: dateScheduledMatchUps,
            matchUpsToSchedule: matchUpsToSchedule,
            scheduleTimes: scheduleTimes,
            groupedRounds: groupedRounds,
            venueCourts: venueCourts,
            minutesMap: minutesMap,
            matchUpMap: matchUpMap,
        };
        if (!clearScheduleDates) {
            allDateScheduledMatchUpIds.push.apply(allDateScheduledMatchUpIds, __spreadArray([], __read(dateScheduledMatchUpIds), false));
        }
    };
    try {
        // first pass through all venues is to build up an array of all matchUpIds in the schedulingProfile for current scheduleDate
        for (var venues_1 = __values(venues), venues_1_1 = venues_1.next(); !venues_1_1.done; venues_1_1 = venues_1.next()) {
            var venue = venues_1_1.value;
            _loop_1(venue);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (venues_1_1 && !venues_1_1.done && (_b = venues_1.return)) _b.call(venues_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return {
        allDateScheduledByeMatchUpDetails: allDateScheduledByeMatchUpDetails,
        allDateScheduledMatchUpIds: allDateScheduledMatchUpIds,
        venueScheduledRoundDetails: venueScheduledRoundDetails,
        allDateMatchUpIds: allDateMatchUpIds,
    };
}

function analyzeScheduleOverlap(a, b) {
    var startA = timeStringMinutes(a.scheduleTime);
    var endA = timeStringMinutes(a.timeAfterRecovery);
    var startB = timeStringMinutes(b.scheduleTime);
    var endB = timeStringMinutes(b.timeAfterRecovery);
    var startOrEndEquivalence = startA === startB || endA === endB;
    var startAisContained = startA > startB && startA < endB;
    var startBisContained = startB > startA && startB < endA;
    var endAisContained = endA > startB && endA < endB;
    var endBisContained = endB > startA && endB < endA;
    var hasOverlap = startOrEndEquivalence ||
        startAisContained ||
        endAisContained ||
        startBisContained ||
        endBisContained;
    return definedAttributes({
        hasOverlap: hasOverlap,
        startAisContained: startAisContained,
        endAisContained: endAisContained,
        startBisContained: startBisContained,
        endBisContained: endBisContained,
    }, true);
}

function checkRecoveryTime(_a) {
    var _b, _c, _d, _e, _f;
    var individualParticipantProfiles = _a.individualParticipantProfiles, matchUpNotBeforeTimes = _a.matchUpNotBeforeTimes, matchUpDependencies = _a.matchUpDependencies, scheduleTime = _a.scheduleTime, matchUp = _a.matchUp, details = _a.details;
    var participantIdDependencies = (((_b = matchUpDependencies === null || matchUpDependencies === void 0 ? void 0 : matchUpDependencies[matchUp.matchUpId]) === null || _b === void 0 ? void 0 : _b.participantIds) || []).flat();
    var averageMatchUpMinutes = ((_d = (_c = details === null || details === void 0 ? void 0 : details.minutesMap) === null || _c === void 0 ? void 0 : _c[matchUp.matchUpId]) === null || _d === void 0 ? void 0 : _d.averageMinutes) || 0;
    var recoveryMinutes = ((_f = (_e = details === null || details === void 0 ? void 0 : details.minutesMap) === null || _e === void 0 ? void 0 : _e[matchUp.matchUpId]) === null || _f === void 0 ? void 0 : _f.recoveryMinutes) || 0;
    var sufficientTimeForIndiiduals = participantIdDependencies.every(function (participantId) {
        var _a;
        checkParticipantProfileInitialization({
            individualParticipantProfiles: individualParticipantProfiles,
            participantId: participantId,
        });
        var profile = individualParticipantProfiles[participantId];
        if (!profile.timeAfterRecovery)
            return true;
        // details are provided by jinnScheduler and this enables treating a participant's scheduled matchUps as "bookings"
        // if (details && timeBetween < 0) {
        var endTime = extractTime((_a = matchUp === null || matchUp === void 0 ? void 0 : matchUp.schedule) === null || _a === void 0 ? void 0 : _a.endTime);
        var timeAfterRecovery = endTime
            ? addMinutesToTimeString(endTime, ensureInt(recoveryMinutes))
            : addMinutesToTimeString(scheduleTime, ensureInt(averageMatchUpMinutes) + ensureInt(recoveryMinutes));
        var potentialParticipantBookings = Object.keys(profile.potentialBookings)
            .filter(function (drawId) { return drawId !== matchUp.drawId; })
            .map(function (drawId) { return profile.potentialBookings[drawId]; })
            .flat();
        var participantBookings = __spreadArray(__spreadArray([], __read(potentialParticipantBookings), false), __read(profile.bookings), false);
        var timeOverlap = !!participantBookings.find(function (booking) {
            return analyzeScheduleOverlap({ scheduleTime: scheduleTime, timeAfterRecovery: timeAfterRecovery }, booking)
                .hasOverlap;
        });
        return !timeOverlap;
    });
    var notBeforeTime = matchUpNotBeforeTimes[matchUp.matchUpId];
    var timeBetweenMatchUps = notBeforeTime
        ? minutesDifference(timeToDate(notBeforeTime), timeToDate(scheduleTime), false)
        : 0;
    var sufficientTimeBetweenMatchUps = timeBetweenMatchUps >= 0;
    var enoughTime = sufficientTimeForIndiiduals && sufficientTimeBetweenMatchUps;
    return { enoughTime: enoughTime };
}

/**
 * @param {object} matchUp
 * @param {object} matchUpDailyLimits - { SINGLES, DOUBLES, TOTAL } - counters
 * @param {string[]} matchUpPotentialParticipantIds - participantIds are attributes { [participantId]: { counters: { SINGLES, DOUBLES, TOTAL }}}
 * @param {object} individualParticipantProfiles - participantIds are attributes { [participantId]: { counters: { SINGLES, DOUBLES, TOTAL }}}
 * @returns {string[]} participantIdsAtLimit - array of participantIds who are at or beyond daily matchUp limit
 * @returns {string[]} relevantParticipantIds - array of participantIds relevant to current matchUp
 * @modifies individualParticipantProfiles - increments counters
 */
function checkDailyLimits(_a) {
    var individualParticipantProfiles = _a.individualParticipantProfiles, matchUpPotentialParticipantIds = _a.matchUpPotentialParticipantIds, _b = _a.matchUpDailyLimits, matchUpDailyLimits = _b === void 0 ? {} : _b, matchUp = _a.matchUp;
    var matchUpId = matchUp.matchUpId, matchUpType = matchUp.matchUpType;
    var enteredIndividualParticipantIds = getIndividualParticipantIds(matchUp).enteredIndividualParticipantIds;
    // don't include potentials if matchUp is in round robin
    // this is because potentials uses { sidesTo } attribute which must be present for other calculations
    var potentialParticipantIds = ((matchUp.roundPosition && matchUpPotentialParticipantIds[matchUpId]) ||
        []).flat();
    var relevantParticipantIds = unique(enteredIndividualParticipantIds.concat.apply(enteredIndividualParticipantIds, __spreadArray([], __read(potentialParticipantIds), false)));
    relevantParticipantIds.forEach(function (participantId) {
        checkParticipantProfileInitialization({
            individualParticipantProfiles: individualParticipantProfiles,
            participantId: participantId,
        });
    });
    var participantIdsAtLimit = relevantParticipantIds.filter(function (participantId) {
        var profile = individualParticipantProfiles[participantId];
        if (profile) {
            return [matchUpType, TOTAL].find(function (counterName) {
                var _a;
                var participantsCount = ((_a = profile.counters) === null || _a === void 0 ? void 0 : _a[counterName]) || 0;
                var dailyLimit = matchUpDailyLimits[counterName] || 0;
                return (participantsCount && dailyLimit && participantsCount >= dailyLimit);
            });
        }
    });
    return { participantIdsAtLimit: participantIdsAtLimit, relevantParticipantIds: relevantParticipantIds };
}

function bulkScheduleTournamentMatchUps(_a) {
    var e_1, _b, e_2, _c;
    var _d, _e, _f, _g;
    var _h = _a.scheduleCompletedMatchUps, scheduleCompletedMatchUps = _h === void 0 ? false : _h, _j = _a.scheduleByeMatchUps, scheduleByeMatchUps = _j === void 0 ? false : _j, _k = _a.errorOnAnachronism, errorOnAnachronism = _k === void 0 ? false : _k, _l = _a.checkChronology, checkChronology = _l === void 0 ? true : _l, matchUpDependencies = _a.matchUpDependencies, removePriorValues = _a.removePriorValues, tournamentRecords = _a.tournamentRecords, tournamentRecord = _a.tournamentRecord, matchUpDetails = _a.matchUpDetails, matchUpIds = _a.matchUpIds, schedule = _a.schedule;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!matchUpDetails && (!matchUpIds || !Array.isArray(matchUpIds)))
        return { error: MISSING_MATCHUP_IDS };
    if (!matchUpDetails && (!schedule || typeof schedule !== 'object'))
        return { error: MISSING_SCHEDULE };
    var inContextMatchUps;
    var warnings = [];
    var scheduled = 0;
    // Optimize getting matchUps for all tournamentRecords
    // if matchUpDependencies are provided, skip this step
    if (checkChronology && !matchUpDependencies) {
        var result = getMatchUpDependencies({
            tournamentRecords: tournamentRecords,
            tournamentRecord: tournamentRecord,
        });
        matchUpDependencies = result.matchUpDependencies;
        inContextMatchUps = result.matchUps;
    }
    // Optimize getting matchUps for all tournamentRecords
    // if inContextMatchUps retrieved in previous step, skip this step
    if (!inContextMatchUps) {
        inContextMatchUps =
            (_e = (_d = allTournamentMatchUps({
                tournamentRecord: tournamentRecord,
            })) === null || _d === void 0 ? void 0 : _d.matchUps) !== null && _e !== void 0 ? _e : [];
    }
    // first organize matchUpIds by drawId
    var drawIdMap = inContextMatchUps.reduce(function (drawIdMap, matchUp) {
        var matchUpId = matchUp.matchUpId, drawId = matchUp.drawId, matchUpStatus = matchUp.matchUpStatus;
        if ((scheduleByeMatchUps || matchUpStatus !== BYE) &&
            (scheduleCompletedMatchUps ||
                !completedMatchUpStatuses.includes(matchUpStatus))) {
            if (drawIdMap[drawId]) {
                drawIdMap[drawId].push(matchUpId);
            }
            else {
                drawIdMap[drawId] = [matchUpId];
            }
        }
        return drawIdMap;
    }, {});
    var detailMatchUpIds = matchUpDetails === null || matchUpDetails === void 0 ? void 0 : matchUpDetails.map(function (detail) { return detail.matchUpId; });
    try {
        for (var _m = __values(Object.keys(drawIdMap)), _o = _m.next(); !_o.done; _o = _m.next()) {
            var drawId = _o.value;
            var drawDefinition = findDrawDefinition$1({
                tournamentRecord: tournamentRecord,
                drawId: drawId,
            }).drawDefinition;
            if (!drawDefinition)
                continue;
            var drawMatchUpIds = drawIdMap[drawId].filter(function (matchUpId) { var _a; return (_a = matchUpIds === null || matchUpIds === void 0 ? void 0 : matchUpIds.includes(matchUpId)) !== null && _a !== void 0 ? _a : detailMatchUpIds === null || detailMatchUpIds === void 0 ? void 0 : detailMatchUpIds.includes(matchUpId); });
            // optimize matchUp retrieval
            var drawMatchUps = allDrawMatchUps({
                inContext: false,
                drawDefinition: drawDefinition,
            }).matchUps;
            var _loop_1 = function (matchUpId) {
                var matchUpSchedule = ((_f = matchUpDetails === null || matchUpDetails === void 0 ? void 0 : matchUpDetails.find(function (details) { return details.matchUpId === matchUpId; })) === null || _f === void 0 ? void 0 : _f.schedule) || schedule;
                var result = addMatchUpScheduleItems({
                    schedule: matchUpSchedule,
                    matchUpDependencies: matchUpDependencies,
                    errorOnAnachronism: errorOnAnachronism,
                    removePriorValues: removePriorValues,
                    inContextMatchUps: inContextMatchUps,
                    tournamentRecords: tournamentRecords,
                    tournamentRecord: tournamentRecord,
                    checkChronology: checkChronology,
                    drawDefinition: drawDefinition,
                    drawMatchUps: drawMatchUps,
                    matchUpId: matchUpId,
                });
                if ((_g = result === null || result === void 0 ? void 0 : result.warnings) === null || _g === void 0 ? void 0 : _g.length)
                    warnings.push.apply(warnings, __spreadArray([], __read(result.warnings), false));
                if (result === null || result === void 0 ? void 0 : result.success)
                    scheduled += 1;
                if (result.error)
                    return { value: result };
            };
            try {
                for (var drawMatchUpIds_1 = (e_2 = void 0, __values(drawMatchUpIds)), drawMatchUpIds_1_1 = drawMatchUpIds_1.next(); !drawMatchUpIds_1_1.done; drawMatchUpIds_1_1 = drawMatchUpIds_1.next()) {
                    var matchUpId = drawMatchUpIds_1_1.value;
                    var state_1 = _loop_1(matchUpId);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (drawMatchUpIds_1_1 && !drawMatchUpIds_1_1.done && (_c = drawMatchUpIds_1.return)) _c.call(drawMatchUpIds_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_o && !_o.done && (_b = _m.return)) _b.call(_m);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return warnings.length
        ? __assign(__assign({}, SUCCESS), { scheduled: scheduled, warnings: warnings }) : __assign(__assign({}, SUCCESS), { scheduled: scheduled });
}

function bulkScheduleMatchUps(params) {
    var _a, _b, e_1, _c;
    var _d;
    var _e = params.scheduleCompletedMatchUps, scheduleCompletedMatchUps = _e === void 0 ? false : _e, _f = params.scheduleByeMatchUps, scheduleByeMatchUps = _f === void 0 ? false : _f, errorOnAnachronism = params.errorOnAnachronism, matchUpContextIds = params.matchUpContextIds, removePriorValues = params.removePriorValues, tournamentRecords = params.tournamentRecords, checkChronology = params.checkChronology, matchUpDetails = params.matchUpDetails, schedule = params.schedule;
    if (params.matchUpIds && !matchUpContextIds)
        return bulkScheduleTournamentMatchUps(params);
    var paramsCheck = checkRequiredParameters(params, [
        (_a = {}, _a[TOURNAMENT_RECORDS] = true, _a),
        (_b = {},
            _b[ONE_OF] = { matchUpContextIds: false, matchUpDetails: false },
            _b[INVALID] = INVALID_VALUES,
            _b[OF_TYPE] = ARRAY,
            _b),
    ]);
    if (paramsCheck.error)
        return paramsCheck;
    if ((!matchUpDetails || matchUpContextIds) && !schedule)
        return { error: MISSING_VALUE, info: 'schedule is required' };
    var warnings = [];
    var scheduled = 0;
    var matchUpDependencies = getMatchUpDependencies({
        tournamentRecords: tournamentRecords,
    }).matchUpDependencies;
    var _loop_1 = function (tournamentRecord) {
        var tournamentId = tournamentRecord.tournamentId;
        var matchUpIds = matchUpContextIds === null || matchUpContextIds === void 0 ? void 0 : matchUpContextIds.filter(function (contextIds) { return contextIds.tournamentId === tournamentId; }).map(getMatchUpId);
        var tournamentMatchUpDetails = matchUpDetails === null || matchUpDetails === void 0 ? void 0 : matchUpDetails.filter(function (details) { return (details === null || details === void 0 ? void 0 : details.tournamentId) === tournamentId; });
        if ((matchUpIds === null || matchUpIds === void 0 ? void 0 : matchUpIds.length) || (tournamentMatchUpDetails === null || tournamentMatchUpDetails === void 0 ? void 0 : tournamentMatchUpDetails.length)) {
            var result = bulkScheduleTournamentMatchUps({
                matchUpDetails: tournamentMatchUpDetails,
                scheduleCompletedMatchUps: scheduleCompletedMatchUps,
                scheduleByeMatchUps: scheduleByeMatchUps,
                matchUpDependencies: matchUpDependencies,
                errorOnAnachronism: errorOnAnachronism,
                removePriorValues: removePriorValues,
                tournamentRecords: tournamentRecords,
                tournamentRecord: tournamentRecord,
                checkChronology: checkChronology,
                matchUpIds: matchUpIds,
                schedule: schedule,
            });
            if ((_d = result.warnings) === null || _d === void 0 ? void 0 : _d.length)
                warnings.push.apply(warnings, __spreadArray([], __read(result.warnings), false));
            if (result.scheduled)
                scheduled += result.scheduled;
            if (result.error)
                return { value: result };
        }
    };
    try {
        for (var _g = __values(Object.values(tournamentRecords)), _h = _g.next(); !_h.done; _h = _g.next()) {
            var tournamentRecord = _h.value;
            var state_1 = _loop_1(tournamentRecord);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_c = _g.return)) _c.call(_g);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return warnings.length ? __assign(__assign({}, SUCCESS), { scheduled: scheduled, warnings: warnings }) : __assign(__assign({}, SUCCESS), { scheduled: scheduled });
}

function auditAutoScheduling(_a) {
    var e_1, _b;
    var _c;
    var autoSchedulingAudit = _a.autoSchedulingAudit, tournamentRecords = _a.tournamentRecords;
    addNotice({ topic: AUDIT, payload: autoSchedulingAudit });
    var getCount = function (obj) {
        if (!obj)
            return 0;
        var values = Object.values(obj);
        return values.reduce(function (count, value) { return count + value.length || 0; }, 0);
    };
    var profileRoundsCount = ((autoSchedulingAudit === null || autoSchedulingAudit === void 0 ? void 0 : autoSchedulingAudit.schedulingProfile) || []).reduce(function (count, dateProfile) {
        return count +
            dateProfile.venues.reduce(function (vc, venue) { return vc + venue.rounds.length; }, 0);
    }, 0);
    var itemValue = {
        scheduledDatesCount: (_c = autoSchedulingAudit.scheduledDates) === null || _c === void 0 ? void 0 : _c.length,
        noTimeMatchUpIdsCount: getCount(autoSchedulingAudit === null || autoSchedulingAudit === void 0 ? void 0 : autoSchedulingAudit.noTimeMatchUpIds),
        scheduledMatchUpIdsCount: getCount(autoSchedulingAudit === null || autoSchedulingAudit === void 0 ? void 0 : autoSchedulingAudit.scheduledMatchUpIds),
        overLimitMatchUpIdsCount: getCount(autoSchedulingAudit === null || autoSchedulingAudit === void 0 ? void 0 : autoSchedulingAudit.overLimitMatchUpIds),
        requestConflictsCount: getCount(autoSchedulingAudit === null || autoSchedulingAudit === void 0 ? void 0 : autoSchedulingAudit.requestConflicts),
        profileRoundsCount: profileRoundsCount,
    };
    var timeItem = {
        itemType: AUTO_SCHEDULING_AUDIT,
        itemValue: itemValue,
    };
    try {
        for (var _d = __values(Object.values(tournamentRecords)), _e = _d.next(); !_e.done; _e = _d.next()) {
            var tournamentRecord = _e.value;
            addTournamentTimeItem({ tournamentRecord: tournamentRecord, timeItem: timeItem });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
}

function jinnScheduler(_a) {
    var e_1, _b;
    var _c, _d, _e, _f, _g, _h, _j;
    var schedulingProfileModifications = _a.schedulingProfileModifications, checkPotentialRequestConflicts = _a.checkPotentialRequestConflicts, scheduleCompletedMatchUps = _a.scheduleCompletedMatchUps, // override which can be used by mocksEngine
    schedulingProfileIssues = _a.schedulingProfileIssues, dateSchedulingProfiles = _a.dateSchedulingProfiles, containedStructureIds = _a.containedStructureIds, matchUpDependencies = _a.matchUpDependencies, matchUpDailyLimits = _a.matchUpDailyLimits, clearScheduleDates = _a.clearScheduleDates, tournamentRecords = _a.tournamentRecords, schedulingProfile = _a.schedulingProfile, personRequests = _a.personRequests, periodLength = _a.periodLength, matchUps = _a.matchUps, courts = _a.courts, dryRun = _a.dryRun;
    var scheduleTimesRemaining = {};
    var skippedScheduleTimes = {};
    var recoveryTimeDeferredMatchUpIds = {};
    var dependencyDeferredMatchUpIds = {};
    var scheduleDateRequestConflicts = {};
    var matchUpScheduleTimes = {};
    var scheduledMatchUpIds = {};
    var overLimitMatchUpIds = {};
    var noTimeMatchUpIds = {};
    var requestConflicts = {};
    var _loop_1 = function (dateSchedulingProfile) {
        var e_2, _k, e_3, _l, e_4, _m, e_5, _o;
        var scheduleDate = extractDate(dateSchedulingProfile === null || dateSchedulingProfile === void 0 ? void 0 : dateSchedulingProfile.scheduleDate);
        var venues = (dateSchedulingProfile === null || dateSchedulingProfile === void 0 ? void 0 : dateSchedulingProfile.venues) || [];
        var matchUpPotentialParticipantIds = {};
        var individualParticipantProfiles = {};
        var bumpLimits = function (relevantParticipantIds, matchUpType) {
            relevantParticipantIds.forEach(function (participantId) {
                var counters = individualParticipantProfiles[participantId].counters;
                if (counters[matchUpType])
                    counters[matchUpType] += 1;
                else
                    counters[matchUpType] = 1;
                if (counters[TOTAL])
                    counters[TOTAL] += 1;
                else
                    counters[TOTAL] = 1;
            });
        };
        recoveryTimeDeferredMatchUpIds[scheduleDate] = {};
        dependencyDeferredMatchUpIds[scheduleDate] = {};
        scheduleTimesRemaining[scheduleDate] = {};
        skippedScheduleTimes[scheduleDate] = {};
        scheduledMatchUpIds[scheduleDate] = []; // will not be in scheduled order
        overLimitMatchUpIds[scheduleDate] = [];
        noTimeMatchUpIds[scheduleDate] = [];
        requestConflicts[scheduleDate] = [];
        // Build up matchUpNotBeforeTimes for all matchUps already scheduled on scheduleDate
        var matchUpNotBeforeTimes = {};
        matchUps.forEach(function (matchUp) {
            var _a;
            if (((_a = matchUp.schedule) === null || _a === void 0 ? void 0 : _a.scheduledDate) &&
                sameDay(scheduleDate, extractDate(matchUp.schedule.scheduledDate))) {
                processNextMatchUps({
                    matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
                    matchUpNotBeforeTimes: matchUpNotBeforeTimes,
                    matchUp: matchUp,
                });
            }
        });
        var _p = getVenueSchedulingDetails({
            matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
            individualParticipantProfiles: individualParticipantProfiles,
            scheduleCompletedMatchUps: scheduleCompletedMatchUps,
            containedStructureIds: containedStructureIds,
            matchUpNotBeforeTimes: matchUpNotBeforeTimes,
            matchUpScheduleTimes: matchUpScheduleTimes,
            matchUpDependencies: matchUpDependencies,
            clearScheduleDates: clearScheduleDates,
            tournamentRecords: tournamentRecords,
            useGarman: true,
            periodLength: periodLength,
            scheduleDate: scheduleDate,
            matchUps: matchUps,
            courts: courts,
            venues: venues,
        }), allDateScheduledByeMatchUpDetails = _p.allDateScheduledByeMatchUpDetails, venueScheduledRoundDetails = _p.venueScheduledRoundDetails, allDateMatchUpIds = _p.allDateMatchUpIds;
        var maxScheduleTimeAttempts = 10; // TODO: calculate this based on max court start/end range and averageMinutes
        var schedulingIterations = 0;
        var schedulingComplete = void 0;
        var failSafe = 10;
        while (!schedulingComplete) {
            var _loop_2 = function (venueId) {
                var scheduledThisPass = 0;
                var details = venueScheduledRoundDetails[venueId];
                var _loop_4 = function () {
                    // attempt to schedule a round or at least venue.courts.length matchUps
                    var _u = details.scheduleTimes.shift(), scheduleTime = _u.scheduleTime, _v = _u.attempts, attempts = _v === void 0 ? 0 : _v;
                    var scheduledMatchUp = details.matchUpsToSchedule.find(function (matchUp) {
                        var _a;
                        var _b, _c;
                        var matchUpId = matchUp.matchUpId, matchUpType = matchUp.matchUpType;
                        var _d = checkDailyLimits({
                            matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
                            individualParticipantProfiles: individualParticipantProfiles,
                            matchUpDailyLimits: matchUpDailyLimits,
                            matchUp: matchUp,
                        }), participantIdsAtLimit = _d.participantIdsAtLimit, relevantParticipantIds = _d.relevantParticipantIds;
                        if (participantIdsAtLimit.length) {
                            if (!overLimitMatchUpIds[scheduleDate].includes(matchUpId))
                                overLimitMatchUpIds[scheduleDate].push(matchUpId);
                            return false;
                        }
                        var scheduledDependent = checkDependendantTiming({
                            matchUpScheduleTimes: matchUpScheduleTimes,
                            matchUpDependencies: matchUpDependencies,
                            scheduleTime: scheduleTime,
                            matchUpId: matchUpId,
                            details: details,
                        }).scheduledDependent;
                        if (scheduledDependent)
                            return false;
                        var _e = checkDependenciesScheduled({
                            matchUpScheduleTimes: matchUpScheduleTimes,
                            matchUpDependencies: matchUpDependencies,
                            allDateMatchUpIds: allDateMatchUpIds,
                            matchUp: matchUp,
                        }), dependenciesScheduled = _e.dependenciesScheduled, remainingDependencies = _e.remainingDependencies;
                        if (!dependenciesScheduled) {
                            if (!dependencyDeferredMatchUpIds[scheduleDate][matchUpId])
                                dependencyDeferredMatchUpIds[scheduleDate][matchUpId] = [];
                            dependencyDeferredMatchUpIds[scheduleDate][matchUpId].push({
                                scheduleTime: scheduleTime,
                                remainingDependencies: remainingDependencies,
                            });
                            return false;
                        }
                        var enoughTime = checkRecoveryTime({
                            individualParticipantProfiles: individualParticipantProfiles,
                            matchUpNotBeforeTimes: matchUpNotBeforeTimes,
                            matchUpDependencies: matchUpDependencies,
                            scheduleTime: scheduleTime,
                            details: details,
                            matchUp: matchUp,
                        }).enoughTime;
                        if (!enoughTime) {
                            if (!recoveryTimeDeferredMatchUpIds[scheduleDate][matchUpId])
                                recoveryTimeDeferredMatchUpIds[scheduleDate][matchUpId] = [];
                            recoveryTimeDeferredMatchUpIds[scheduleDate][matchUpId].push({
                                scheduleTime: scheduleTime,
                            });
                            return false;
                        }
                        var averageMatchUpMinutes = details.greatestAverageMinutes;
                        // details.minutesMap?.[matchUpId]?.averageMinutes;
                        // TODO: check the previous scheduled matchUp for each participantId/potentialParticipantId
                        // CHECK: if the matchUpType has changed for ALL PARTICIPANTS from SINGLE/DOUBLES use typeChangeRecoveryMinutes
                        var conflicts = checkRequestConflicts({
                            potentials: checkPotentialRequestConflicts,
                            averageMatchUpMinutes: averageMatchUpMinutes,
                            requestConflicts: requestConflicts,
                            personRequests: personRequests,
                            scheduleTime: scheduleTime,
                            scheduleDate: scheduleDate,
                            matchUp: matchUp,
                        }).conflicts;
                        if (conflicts === null || conflicts === void 0 ? void 0 : conflicts.length) {
                            if (!scheduleDateRequestConflicts[scheduleDate])
                                scheduleDateRequestConflicts[scheduleDate] = [];
                            (_a = scheduleDateRequestConflicts[scheduleDate]).push.apply(_a, __spreadArray([], __read(conflicts), false));
                            return false;
                        }
                        bumpLimits(relevantParticipantIds, matchUpType);
                        var recoveryMinutes = (_c = (_b = details.minutesMap) === null || _b === void 0 ? void 0 : _b[matchUpId]) === null || _c === void 0 ? void 0 : _c.recoveryMinutes;
                        updateTimeAfterRecovery({
                            matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
                            individualParticipantProfiles: individualParticipantProfiles,
                            matchUpNotBeforeTimes: matchUpNotBeforeTimes,
                            averageMatchUpMinutes: averageMatchUpMinutes,
                            matchUpDependencies: matchUpDependencies,
                            recoveryMinutes: recoveryMinutes,
                            scheduleTime: scheduleTime,
                            matchUp: matchUp,
                        });
                        matchUpScheduleTimes[matchUpId] = scheduleTime;
                        return true;
                    });
                    details.matchUpsToSchedule = details.matchUpsToSchedule.filter(function (_a) {
                        var matchUpId = _a.matchUpId;
                        return matchUpId !== (scheduledMatchUp === null || scheduledMatchUp === void 0 ? void 0 : scheduledMatchUp.matchUpId);
                    });
                    if (!scheduledMatchUp) {
                        if (!skippedScheduleTimes[scheduleDate][venueId])
                            skippedScheduleTimes[scheduleDate][venueId] = [];
                        skippedScheduleTimes[scheduleDate][venueId].push({
                            scheduleTime: scheduleTime,
                            attempts: attempts + 1,
                        });
                    }
                    else {
                        scheduledThisPass += 1;
                    }
                };
                while (details.courtsCount &&
                    ((_c = details.scheduleTimes) === null || _c === void 0 ? void 0 : _c.length) &&
                    ((_d = details.matchUpsToSchedule) === null || _d === void 0 ? void 0 : _d.length) &&
                    scheduledThisPass <= details.courtsCount) {
                    _loop_4();
                }
                if ((_e = details.matchUpsToSchedule) === null || _e === void 0 ? void 0 : _e.length) {
                    skippedScheduleTimes[scheduleDate][venueId] = (_f = skippedScheduleTimes[scheduleDate][venueId]) === null || _f === void 0 ? void 0 : _f.filter(function (unused) {
                        var tryAgain = unused.attempts < maxScheduleTimeAttempts;
                        if (tryAgain)
                            details.scheduleTimes.push(unused);
                        return !tryAgain;
                    });
                }
                if (!((_g = details.scheduleTimes) === null || _g === void 0 ? void 0 : _g.length) ||
                    !((_h = details.matchUpsToSchedule) === null || _h === void 0 ? void 0 : _h.length))
                    details.complete = true;
            };
            try {
                // for each venue schedule a round
                for (var venues_1 = (e_2 = void 0, __values(venues)), venues_1_1 = venues_1.next(); !venues_1_1.done; venues_1_1 = venues_1.next()) {
                    var venueId = venues_1_1.value.venueId;
                    _loop_2(venueId);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (venues_1_1 && !venues_1_1.done && (_k = venues_1.return)) _k.call(venues_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            schedulingIterations += 1;
            schedulingComplete =
                venues.every(function (_a) {
                    var venueId = _a.venueId;
                    return venueScheduledRoundDetails[venueId].complete;
                }) || schedulingIterations === failSafe;
        }
        var _loop_3 = function (venueId) {
            var matchUpMap = venueScheduledRoundDetails[venueId].matchUpMap;
            Object.keys(matchUpMap).forEach(function (tournamentId) {
                var tournamentRecord = tournamentRecords[tournamentId];
                if (tournamentRecord) {
                    Object.keys(matchUpMap[tournamentId]).forEach(function (drawId) {
                        var drawDefinition = findDrawDefinition$1({
                            tournamentRecord: tournamentRecord,
                            drawId: drawId,
                        }).drawDefinition;
                        if (drawDefinition) {
                            var drawMatchUps = matchUpMap[tournamentId][drawId];
                            drawMatchUps.forEach(function (_a) {
                                var matchUpId = _a.matchUpId;
                                var scheduleTime = matchUpScheduleTimes[matchUpId];
                                if (scheduleTime) {
                                    // must include scheduleDate being scheduled to generate proper ISO string
                                    var formatTime = scheduleTime
                                        .split(':')
                                        .map(zeroPad)
                                        .join(':');
                                    var scheduledTime = "".concat(extractDate(scheduleDate), "T").concat(formatTime);
                                    if (dryRun) {
                                        scheduledMatchUpIds[scheduleDate].push(matchUpId);
                                    }
                                    else {
                                        var result = addMatchUpScheduledTime({
                                            drawDefinition: drawDefinition,
                                            scheduledTime: scheduledTime,
                                            matchUpId: matchUpId,
                                        });
                                        if (result.success)
                                            scheduledMatchUpIds[scheduleDate].push(matchUpId);
                                        if (venueId) {
                                            assignMatchUpVenue({
                                                tournamentRecord: tournamentRecord,
                                                drawDefinition: drawDefinition,
                                                matchUpId: matchUpId,
                                                venueId: venueId,
                                            });
                                        }
                                    }
                                }
                            });
                        }
                    });
                }
            });
            noTimeMatchUpIds[scheduleDate] =
                venueScheduledRoundDetails[venueId].matchUpsToSchedule.map(getMatchUpId);
            scheduleTimesRemaining[scheduleDate][venueId] =
                venueScheduledRoundDetails[venueId].scheduleTimes.sort(function (a, b) {
                    return timeStringMinutes(a.scheduleTime) -
                        timeStringMinutes(b.scheduleTime);
                });
        };
        try {
            // assign scheduledTime and venue to each matchUp
            // because this is done in an optimized fashion from hash of assignments
            // scheduledMatchUpIds[scheduleDate] will not be in the order that scheduleTimes were assigned
            for (var venues_2 = (e_3 = void 0, __values(venues)), venues_2_1 = venues_2.next(); !venues_2_1.done; venues_2_1 = venues_2.next()) {
                var venueId = venues_2_1.value.venueId;
                _loop_3(venueId);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (venues_2_1 && !venues_2_1.done && (_l = venues_2.return)) _l.call(venues_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (!dryRun && (allDateScheduledByeMatchUpDetails === null || allDateScheduledByeMatchUpDetails === void 0 ? void 0 : allDateScheduledByeMatchUpDetails.length)) {
            // remove scheduling information for BYE matchUps from any rounds that were scheduled
            // remove scheduling information for BYE matchUps from any rounds that were scheduled
            bulkScheduleMatchUps({
                matchUpDetails: allDateScheduledByeMatchUpDetails,
                scheduleByeMatchUps: true,
                removePriorValues: true,
                tournamentRecords: tournamentRecords,
                schedule: {
                    scheduledDate: '',
                    scheduledTime: '',
                    courtOrder: '',
                    courtId: '',
                    venueId: '',
                },
            });
        }
        try {
            for (var _q = (e_4 = void 0, __values(dateSchedulingProfile.venues)), _r = _q.next(); !_r.done; _r = _q.next()) {
                var venue = _r.value;
                try {
                    for (var _s = (e_5 = void 0, __values(venue.rounds)), _t = _s.next(); !_t.done; _t = _s.next()) {
                        var round = _t.value;
                        var matchUpIds = ((_j = round.matchUps) === null || _j === void 0 ? void 0 : _j.map(function (_a) {
                            var matchUpId = _a.matchUpId;
                            return matchUpId;
                        })) || [];
                        var canScheduleMatchUpIds = matchUpIds.filter(function (matchUpId) {
                            return scheduledMatchUpIds[scheduleDate].includes(matchUpId);
                        });
                        round.canScheduledMatchUpIds = canScheduleMatchUpIds;
                        var possibleToSchedulePct = Math.round((canScheduleMatchUpIds.length / round.matchUpsCount) * 10000) / 100;
                        if (possibleToSchedulePct === Infinity || isNaN(possibleToSchedulePct))
                            possibleToSchedulePct = 0;
                        round.possibleToSchedulePct = possibleToSchedulePct;
                        if (round.matchUpsCount === canScheduleMatchUpIds.length) {
                            round.possibleToSchedule = true;
                        }
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_t && !_t.done && (_o = _s.return)) _o.call(_s);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_r && !_r.done && (_m = _q.return)) _m.call(_q);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    try {
        for (var dateSchedulingProfiles_1 = __values(dateSchedulingProfiles), dateSchedulingProfiles_1_1 = dateSchedulingProfiles_1.next(); !dateSchedulingProfiles_1_1.done; dateSchedulingProfiles_1_1 = dateSchedulingProfiles_1.next()) {
            var dateSchedulingProfile = dateSchedulingProfiles_1_1.value;
            _loop_1(dateSchedulingProfile);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (dateSchedulingProfiles_1_1 && !dateSchedulingProfiles_1_1.done && (_b = dateSchedulingProfiles_1.return)) _b.call(dateSchedulingProfiles_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // returns the original form of the dateStrings, before extractDate()
    var scheduledDates = dateSchedulingProfiles.map(function (_a) {
        var scheduleDate = _a.scheduleDate;
        return scheduleDate;
    });
    var autoSchedulingAudit = {
        timeStamp: Date.now(),
        overLimitMatchUpIds: overLimitMatchUpIds,
        scheduledMatchUpIds: scheduledMatchUpIds,
        schedulingProfile: schedulingProfile,
        noTimeMatchUpIds: noTimeMatchUpIds,
        requestConflicts: requestConflicts,
        scheduledDates: scheduledDates,
    };
    auditAutoScheduling({ tournamentRecords: tournamentRecords, autoSchedulingAudit: autoSchedulingAudit });
    return __assign(__assign({}, SUCCESS), { schedulingProfileModifications: schedulingProfileModifications, schedulingProfileIssues: schedulingProfileIssues, scheduleTimesRemaining: scheduleTimesRemaining, dateSchedulingProfiles: dateSchedulingProfiles, skippedScheduleTimes: skippedScheduleTimes, recoveryTimeDeferredMatchUpIds: recoveryTimeDeferredMatchUpIds, dependencyDeferredMatchUpIds: dependencyDeferredMatchUpIds, matchUpScheduleTimes: matchUpScheduleTimes, overLimitMatchUpIds: overLimitMatchUpIds, scheduledMatchUpIds: scheduledMatchUpIds, noTimeMatchUpIds: noTimeMatchUpIds, requestConflicts: requestConflicts, scheduledDates: scheduledDates });
}

function getPersonRequests(params) {
    var _a, e_1, _b, e_2, _c, e_3, _d;
    var tournamentRecords = params.tournamentRecords, requestType = params.requestType;
    var paramsCheck = checkRequiredParameters(params, [(_a = {}, _a[TOURNAMENT_RECORDS] = true, _a)]);
    if (paramsCheck.error)
        return paramsCheck;
    var personRequests = {};
    try {
        // create merged view of person requests across tournamentRecords
        // ... possible for a person to be in multiple linked tournamentRecords
        for (var _e = __values(Object.values(tournamentRecords)), _f = _e.next(); !_f.done; _f = _e.next()) {
            var tournamentRecord = _f.value;
            var extension = findExtension({
                element: tournamentRecord,
                name: PERSON_REQUESTS,
            }).extension;
            var requestObjects = (extension === null || extension === void 0 ? void 0 : extension.value) || [];
            try {
                for (var requestObjects_1 = (e_2 = void 0, __values(requestObjects)), requestObjects_1_1 = requestObjects_1.next(); !requestObjects_1_1.done; requestObjects_1_1 = requestObjects_1.next()) {
                    var requestObject = requestObjects_1_1.value;
                    var _g = requestObject || {}, personId = _g.personId, requests = _g.requests;
                    if (!personRequests[personId])
                        personRequests[personId] = [];
                    try {
                        for (var requests_1 = (e_3 = void 0, __values(requests)), requests_1_1 = requests_1.next(); !requests_1_1.done; requests_1_1 = requests_1.next()) {
                            var request = requests_1_1.value;
                            if (requestType && request.requestType !== requestType)
                                continue;
                            personRequests[personId].push(request);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (requests_1_1 && !requests_1_1.done && (_d = requests_1.return)) _d.call(requests_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (requestObjects_1_1 && !requestObjects_1_1.done && (_c = requestObjects_1.return)) _c.call(requestObjects_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // audit requests and filter out any that are no longer relevant
    // (tournament dates changed & etc)
    return __assign({ personRequests: personRequests }, SUCCESS);
}

function getEarliestCourtTime(_a) {
    var averageMinutes = _a.averageMinutes, startTime = _a.startTime, endTime = _a.endTime, court = _a.court, date = _a.date;
    if (!Array.isArray(court.dateAvailability))
        return { error: MISSING_VALUE, stack: 'getEarliestCourtTime' };
    var courtStartTime = getDateTimeBoundary({
        scheduleDate: date,
        courts: [court],
        startTime: true,
    });
    var courtEndTime = getDateTimeBoundary({
        scheduleDate: date,
        courts: [court],
        endTime: true,
    });
    startTime = startTime || courtStartTime;
    endTime = endTime || courtEndTime;
    var courtDate = getCourtDateAvailability({ court: court, date: date });
    var timeSlots = generateTimeSlots({ courtDate: courtDate });
    var dateStartTime = timeToDate(startTime);
    var dateEndTime = timeToDate(endTime);
    var earliestCourtTime = timeSlots.reduce(function (first, timeSlot) {
        var timeSlotStartTime = timeToDate(timeSlot.startTime);
        var timeSlotEndTime = timeToDate(timeSlot.endTime);
        if (timeSlotStartTime > dateEndTime || timeSlotEndTime < dateStartTime) {
            return first;
        }
        var consideredStartTime = dateStartTime > timeSlotStartTime ? dateStartTime : timeSlotStartTime;
        var timeSlotMinutes = minutesDifference(consideredStartTime, timeSlotEndTime);
        var available = timeSlotMinutes >= averageMinutes;
        if (available) {
            var timeString = extractTime(consideredStartTime.toISOString());
            if (!first || timeString < first)
                first = timeString;
        }
        return first;
    }, undefined);
    return { earliestCourtTime: earliestCourtTime, courtStartTime: courtStartTime, courtEndTime: courtEndTime };
}

function v2Scheduler(_a) {
    var e_1, _b;
    var _c, _d;
    var schedulingProfileModifications = _a.schedulingProfileModifications, checkPotentialRequestConflicts = _a.checkPotentialRequestConflicts, scheduleCompletedMatchUps = _a.scheduleCompletedMatchUps, // override which can be used by mocksEngine
    schedulingProfileIssues = _a.schedulingProfileIssues, dateSchedulingProfiles = _a.dateSchedulingProfiles, containedStructureIds = _a.containedStructureIds, matchUpDependencies = _a.matchUpDependencies, matchUpDailyLimits = _a.matchUpDailyLimits, clearScheduleDates = _a.clearScheduleDates, tournamentRecords = _a.tournamentRecords, _e = _a.periodLength, periodLength = _e === void 0 ? 30 : _e, schedulingProfile = _a.schedulingProfile, personRequests = _a.personRequests, _f = _a.matchUps, matchUps = _f === void 0 ? [] : _f, courts = _a.courts, dryRun = _a.dryRun;
    var recoveryTimeDeferredMatchUpIds = {};
    var dependencyDeferredMatchUpIds = {};
    var scheduleDateRequestConflicts = {};
    var matchUpScheduleCourtIds = {};
    var matchUpScheduleTimes = {};
    var scheduledMatchUpIds = {};
    var overLimitMatchUpIds = {};
    var noTimeMatchUpIds = {};
    var requestConflicts = {};
    var _loop_1 = function (dateSchedulingProfile) {
        var e_2, _j, e_3, _k, e_4, _l, e_5, _m;
        var scheduleDate = extractDate(dateSchedulingProfile === null || dateSchedulingProfile === void 0 ? void 0 : dateSchedulingProfile.scheduleDate);
        var venues = (dateSchedulingProfile === null || dateSchedulingProfile === void 0 ? void 0 : dateSchedulingProfile.venues) || [];
        var matchUpPotentialParticipantIds = {};
        var individualParticipantProfiles = {};
        var bumpLimits = function (relevantParticipantIds, matchUpType) {
            relevantParticipantIds.forEach(function (participantId) {
                var counters = individualParticipantProfiles[participantId].counters;
                if (counters[matchUpType])
                    counters[matchUpType] += 1;
                else
                    counters[matchUpType] = 1;
                if (counters[TOTAL])
                    counters[TOTAL] += 1;
                else
                    counters[TOTAL] = 1;
            });
        };
        recoveryTimeDeferredMatchUpIds[scheduleDate] = {};
        dependencyDeferredMatchUpIds[scheduleDate] = {};
        scheduledMatchUpIds[scheduleDate] = []; // will not be in scheduled order
        overLimitMatchUpIds[scheduleDate] = [];
        noTimeMatchUpIds[scheduleDate] = [];
        requestConflicts[scheduleDate] = [];
        // Build up matchUpNotBeforeTimes for all matchUps already scheduled on scheduleDate
        var matchUpNotBeforeTimes = {};
        matchUps === null || matchUps === void 0 ? void 0 : matchUps.forEach(function (matchUp) {
            var _a;
            if (((_a = matchUp.schedule) === null || _a === void 0 ? void 0 : _a.scheduledDate) &&
                sameDay(scheduleDate, extractDate(matchUp.schedule.scheduledDate))) {
                processNextMatchUps({
                    matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
                    matchUpNotBeforeTimes: matchUpNotBeforeTimes,
                    matchUp: matchUp,
                });
            }
        });
        var _o = getVenueSchedulingDetails({
            matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
            individualParticipantProfiles: individualParticipantProfiles,
            scheduleCompletedMatchUps: scheduleCompletedMatchUps,
            containedStructureIds: containedStructureIds,
            matchUpNotBeforeTimes: matchUpNotBeforeTimes,
            matchUpScheduleTimes: matchUpScheduleTimes,
            matchUpDependencies: matchUpDependencies,
            clearScheduleDates: clearScheduleDates,
            tournamentRecords: tournamentRecords,
            periodLength: periodLength,
            scheduleDate: scheduleDate,
            matchUps: matchUps,
            courts: courts,
            venues: venues,
        }), allDateScheduledByeMatchUpDetails = _o.allDateScheduledByeMatchUpDetails, allDateScheduledMatchUpIds = _o.allDateScheduledMatchUpIds, venueScheduledRoundDetails = _o.venueScheduledRoundDetails, allDateMatchUpIds = _o.allDateMatchUpIds;
        var dateScheduledMatchUps = matchUps === null || matchUps === void 0 ? void 0 : matchUps.filter(function (_a) {
            var matchUpId = _a.matchUpId;
            return allDateScheduledMatchUpIds.includes(matchUpId);
        });
        var bookings = generateBookings({
            dateScheduledMatchUps: dateScheduledMatchUps,
            tournamentRecords: tournamentRecords,
            scheduleDate: scheduleDate,
            periodLength: periodLength,
        }).bookings;
        var dateCourts = generateVirtualCourts({
            scheduleDate: scheduleDate,
            periodLength: periodLength,
            bookings: bookings,
            courts: courts,
        }).virtualCourts;
        var venueTimeBoundaries = dateCourts === null || dateCourts === void 0 ? void 0 : dateCourts.reduce(function (timeBoundaries, court) {
            var _a = getEarliestCourtTime({
                date: scheduleDate,
                averageMinutes: 0,
                court: court,
            }), earliestCourtTime = _a.earliestCourtTime, courtEndTime = _a.courtEndTime;
            if (!timeBoundaries.startTime ||
                timeToDate(earliestCourtTime) < timeToDate(timeBoundaries.startTime)) {
                timeBoundaries.startTime = earliestCourtTime;
            }
            if (!timeBoundaries.endTime ||
                timeToDate(courtEndTime) > timeToDate(timeBoundaries.endTime)) {
                timeBoundaries.endTime = courtEndTime;
            }
            return timeBoundaries;
        }, {});
        var venueEarliestCourtTime = venueTimeBoundaries.startTime;
        var addDateCourtBooking = function (_a) {
            var _b;
            var courtId = _a.courtId, booking = _a.booking;
            return (_b = dateCourts === null || dateCourts === void 0 ? void 0 : dateCourts.find(function (court) { return court.courtId === courtId; })) === null || _b === void 0 ? void 0 : _b.dateAvailability[0].bookings.push(booking);
        };
        var failSafe = 10;
        var schedulingIterations = 0;
        var schedulingComplete = void 0;
        while (!schedulingComplete) {
            var _loop_2 = function (venueId) {
                var e_6, _t;
                var details = venueScheduledRoundDetails[venueId];
                // on each pass attempt to schedule one matchUp per court
                // when a matchUp is scheduled, add it to details.dateScheduledMatchUps
                var venuePassFailSafe = details.matchUpsToSchedule.length;
                var matchUpIdsScheduled = [];
                var courtIdsScheduled = [];
                var venuePassComplete = void 0;
                var passIterations = 0;
                while (!venuePassComplete) {
                    var _loop_4 = function (matchUp) {
                        var _w;
                        if (courtIdsScheduled.length === details.courtsCount ||
                            matchUpIdsScheduled.length === details.courtsCount) {
                            venuePassComplete = true;
                            return "break";
                        }
                        var matchUpId = matchUp.matchUpId, matchUpType = matchUp.matchUpType;
                        var _x = checkDailyLimits({
                            matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
                            individualParticipantProfiles: individualParticipantProfiles,
                            matchUpDailyLimits: matchUpDailyLimits,
                            matchUp: matchUp,
                        }), participantIdsAtLimit = _x.participantIdsAtLimit, relevantParticipantIds = _x.relevantParticipantIds;
                        if (participantIdsAtLimit.length) {
                            if (!overLimitMatchUpIds[scheduleDate].includes(matchUpId))
                                overLimitMatchUpIds[scheduleDate].push(matchUpId);
                            return "continue";
                        }
                        var _y = checkDependenciesScheduled({
                            matchUpScheduleTimes: matchUpScheduleTimes,
                            matchUpDependencies: matchUpDependencies,
                            allDateMatchUpIds: allDateMatchUpIds,
                            matchUp: matchUp,
                        }), dependenciesScheduled = _y.dependenciesScheduled, remainingDependencies = _y.remainingDependencies;
                        if (!dependenciesScheduled) {
                            if (!dependencyDeferredMatchUpIds[scheduleDate][matchUpId])
                                dependencyDeferredMatchUpIds[scheduleDate][matchUpId] = [];
                            dependencyDeferredMatchUpIds[scheduleDate][matchUpId].push({
                                remainingDependencies: remainingDependencies,
                            });
                            return "continue";
                        }
                        var schedulingConflicts = [];
                        var courtTime = dateCourts === null || dateCourts === void 0 ? void 0 : dateCourts.reduce(function (courtTime, court) {
                            var _a, _b, _c, _d;
                            if (courtIdsScheduled.includes(court.courtId))
                                return courtTime;
                            var scheduleTime = getEarliestCourtTime({
                                averageMinutes: details.greatestAverageMinutes,
                                startTime: venueEarliestCourtTime,
                                date: scheduleDate,
                                court: court,
                            }).earliestCourtTime;
                            if (courtTime.scheduleTime &&
                                timeStringMinutes(scheduleTime) >=
                                    timeStringMinutes(courtTime.scheduleTime)) {
                                return courtTime;
                            }
                            var scheduledDependent = checkDependendantTiming({
                                matchUpScheduleTimes: matchUpScheduleTimes,
                                matchUpDependencies: matchUpDependencies,
                                scheduleTime: scheduleTime,
                                matchUpId: matchUpId,
                                details: details,
                            }).scheduledDependent;
                            if (scheduledDependent)
                                return courtTime;
                            var enoughTime = checkRecoveryTime({
                                individualParticipantProfiles: individualParticipantProfiles,
                                matchUpNotBeforeTimes: matchUpNotBeforeTimes,
                                matchUpDependencies: matchUpDependencies,
                                scheduleTime: scheduleTime,
                                details: details,
                                matchUp: matchUp,
                            }).enoughTime;
                            if (!enoughTime) {
                                if (!recoveryTimeDeferredMatchUpIds[scheduleDate][matchUpId])
                                    recoveryTimeDeferredMatchUpIds[scheduleDate][matchUpId] = [];
                                if (!recoveryTimeDeferredMatchUpIds[scheduleDate][matchUpId].includes(scheduleTime)) {
                                    recoveryTimeDeferredMatchUpIds[scheduleDate][matchUpId].push(scheduleTime);
                                }
                                return courtTime;
                            }
                            var averageMatchUpMinutes = ((_b = (_a = details.minutesMap) === null || _a === void 0 ? void 0 : _a[matchUpId]) === null || _b === void 0 ? void 0 : _b.averageMinutes) ||
                                details.greatestAverageMinutes;
                            var conflicts = checkRequestConflicts({
                                potentials: checkPotentialRequestConflicts,
                                averageMatchUpMinutes: averageMatchUpMinutes,
                                requestConflicts: requestConflicts,
                                personRequests: personRequests,
                                scheduleTime: scheduleTime,
                                scheduleDate: scheduleDate,
                                matchUp: matchUp,
                            }).conflicts;
                            if (conflicts === null || conflicts === void 0 ? void 0 : conflicts.length) {
                                schedulingConflicts.push.apply(schedulingConflicts, __spreadArray([], __read(conflicts), false));
                                return false;
                            }
                            bumpLimits(relevantParticipantIds, matchUpType);
                            var recoveryMinutes = (_d = (_c = details.minutesMap) === null || _c === void 0 ? void 0 : _c[matchUpId]) === null || _d === void 0 ? void 0 : _d.recoveryMinutes;
                            updateTimeAfterRecovery({
                                matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
                                individualParticipantProfiles: individualParticipantProfiles,
                                matchUpNotBeforeTimes: matchUpNotBeforeTimes,
                                averageMatchUpMinutes: averageMatchUpMinutes,
                                matchUpDependencies: matchUpDependencies,
                                recoveryMinutes: recoveryMinutes,
                                scheduleTime: scheduleTime,
                                matchUp: matchUp,
                            });
                            if (!courtTime.scheduleTime ||
                                timeStringMinutes(scheduleTime) <
                                    timeStringMinutes(courtTime.scheduleTime)) {
                                courtTime.averageMatchUpMinutes = averageMatchUpMinutes;
                                courtTime.recoveryMinutes = recoveryMinutes;
                                courtTime.scheduleTime = scheduleTime;
                                courtTime.courtName = court.courtName;
                                courtTime.courtId = court.courtId;
                            }
                            return courtTime;
                        }, {});
                        if (courtTime.scheduleTime) {
                            var averageMatchUpMinutes = courtTime.averageMatchUpMinutes, recoveryMinutes = courtTime.recoveryMinutes, scheduleTime = courtTime.scheduleTime, courtId = courtTime.courtId;
                            matchUpScheduleTimes[matchUpId] = scheduleTime;
                            matchUpScheduleCourtIds[matchUpId] = courtId;
                            matchUpIdsScheduled.push(matchUpId);
                            courtIdsScheduled.push(courtId);
                            var startTime = scheduleTime;
                            var endTime = addMinutesToTimeString(startTime, averageMatchUpMinutes);
                            var booking = {
                                averageMatchUpMinutes: averageMatchUpMinutes,
                                recoveryMinutes: recoveryMinutes,
                                periodLength: periodLength,
                                matchUpId: matchUpId,
                                startTime: startTime,
                                courtId: courtId,
                                endTime: endTime,
                                venueId: venueId,
                            };
                            addDateCourtBooking({ courtId: courtId, booking: booking });
                            details.matchUpsToSchedule = details.matchUpsToSchedule.filter(function (matchUp) { return matchUp.matchUpId !== matchUpId; });
                        }
                        else if (schedulingConflicts === null || schedulingConflicts === void 0 ? void 0 : schedulingConflicts.length) {
                            if (!scheduleDateRequestConflicts[scheduleDate])
                                scheduleDateRequestConflicts[scheduleDate] = [];
                            (_w = scheduleDateRequestConflicts[scheduleDate]).push.apply(_w, __spreadArray([], __read(schedulingConflicts), false));
                        }
                    };
                    try {
                        for (var _u = (e_6 = void 0, __values(details.matchUpsToSchedule)), _v = _u.next(); !_v.done; _v = _u.next()) {
                            var matchUp = _v.value;
                            var state_1 = _loop_4(matchUp);
                            if (state_1 === "break")
                                break;
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (_v && !_v.done && (_t = _u.return)) _t.call(_u);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                    if (courtIdsScheduled.length === details.courtsCount ||
                        matchUpIdsScheduled.length === details.courtsCount ||
                        !details.matchUpsToSchedule.length) {
                        venuePassComplete = true;
                    }
                    if (details.matchUpsToSchedule.length &&
                        matchUpIdsScheduled < details.courtsCount) {
                        if (timeToDate(venueEarliestCourtTime) <
                            timeToDate(venueTimeBoundaries.endTime)) {
                            venueEarliestCourtTime = addMinutesToTimeString(venueEarliestCourtTime, periodLength);
                        }
                        else {
                            venuePassComplete = true;
                            details.complete = true;
                        }
                    }
                    // this is necessary for scenarios where there are more courts than matches which can be scheduled at the same time
                    passIterations += 1;
                    if (!venuePassComplete && passIterations >= venuePassFailSafe) {
                        venuePassComplete = true;
                    }
                }
                if (!((_c = details.matchUpsToSchedule) === null || _c === void 0 ? void 0 : _c.length))
                    details.complete = true;
            };
            try {
                // for each venue schedule a round
                for (var venues_1 = (e_2 = void 0, __values(venues)), venues_1_1 = venues_1.next(); !venues_1_1.done; venues_1_1 = venues_1.next()) {
                    var venueId = venues_1_1.value.venueId;
                    _loop_2(venueId);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (venues_1_1 && !venues_1_1.done && (_j = venues_1.return)) _j.call(venues_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            schedulingIterations += 1;
            schedulingComplete =
                venues.every(function (_a) {
                    var venueId = _a.venueId;
                    return venueScheduledRoundDetails[venueId].complete;
                }) || schedulingIterations === failSafe;
        }
        var _loop_3 = function (venueId) {
            var matchUpMap = venueScheduledRoundDetails[venueId].matchUpMap;
            Object.keys(matchUpMap).forEach(function (tournamentId) {
                var tournamentRecord = tournamentRecords[tournamentId];
                if (tournamentRecord) {
                    Object.keys(matchUpMap[tournamentId]).forEach(function (drawId) {
                        var drawDefinition = findDrawDefinition$1({
                            tournamentRecord: tournamentRecord,
                            drawId: drawId,
                        }).drawDefinition;
                        if (drawDefinition) {
                            var drawMatchUps = matchUpMap[tournamentId][drawId];
                            drawMatchUps.forEach(function (_a) {
                                var matchUpId = _a.matchUpId;
                                var scheduleTime = matchUpScheduleTimes[matchUpId];
                                var courtId = matchUpScheduleCourtIds[matchUpId];
                                if (scheduleTime) {
                                    // must include scheduleDate being scheduled to generate proper ISO string
                                    var formatTime = scheduleTime
                                        .split(':')
                                        .map(zeroPad)
                                        .join(':');
                                    var scheduledTime = "".concat(extractDate(scheduleDate), "T").concat(formatTime);
                                    if (dryRun) {
                                        scheduledMatchUpIds[scheduleDate].push(matchUpId);
                                    }
                                    else {
                                        addMatchUpScheduledTime({
                                            drawDefinition: drawDefinition,
                                            scheduledTime: scheduledTime,
                                            matchUpId: matchUpId,
                                        });
                                        assignMatchUpCourt({
                                            courtDayDate: scheduleDate,
                                            tournamentRecords: tournamentRecords,
                                            tournamentRecord: tournamentRecord,
                                            drawDefinition: drawDefinition,
                                            matchUpId: matchUpId,
                                            courtId: courtId,
                                        });
                                        scheduledMatchUpIds[scheduleDate].push(matchUpId);
                                    }
                                }
                            });
                        }
                    });
                }
            });
            noTimeMatchUpIds[scheduleDate] =
                venueScheduledRoundDetails[venueId].matchUpsToSchedule.map(getMatchUpId);
        };
        try {
            // assign scheduledTime, venueId and courtId to each matchUp
            // because this is done in an optimized fashion from hash of assignments
            // scheduledMatchUpIds[scheduleDate] will not be in the order that scheduleTimes were assigned
            for (var venues_2 = (e_3 = void 0, __values(venues)), venues_2_1 = venues_2.next(); !venues_2_1.done; venues_2_1 = venues_2.next()) {
                var venueId = venues_2_1.value.venueId;
                _loop_3(venueId);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (venues_2_1 && !venues_2_1.done && (_k = venues_2.return)) _k.call(venues_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (!dryRun && (allDateScheduledByeMatchUpDetails === null || allDateScheduledByeMatchUpDetails === void 0 ? void 0 : allDateScheduledByeMatchUpDetails.length)) {
            // remove scheduling information for BYE matchUps from any rounds that were scheduled
            bulkScheduleMatchUps({
                matchUpDetails: allDateScheduledByeMatchUpDetails,
                scheduleByeMatchUps: true,
                removePriorValues: true,
                tournamentRecords: tournamentRecords,
                schedule: {
                    scheduledDate: '',
                    scheduledTime: '',
                    courtOrder: '',
                    courtId: '',
                    venueId: '',
                },
            });
        }
        try {
            for (var _p = (e_4 = void 0, __values(dateSchedulingProfile.venues)), _q = _p.next(); !_q.done; _q = _p.next()) {
                var venue = _q.value;
                try {
                    for (var _r = (e_5 = void 0, __values(venue.rounds)), _s = _r.next(); !_s.done; _s = _r.next()) {
                        var round = _s.value;
                        var matchUpIds = ((_d = round.matchUps) !== null && _d !== void 0 ? _d : []).map(function (_a) {
                            var matchUpId = _a.matchUpId;
                            return matchUpId;
                        });
                        var canScheduleMatchUpIds = matchUpIds === null || matchUpIds === void 0 ? void 0 : matchUpIds.filter(function (matchUpId) {
                            return scheduledMatchUpIds[scheduleDate].includes(matchUpId);
                        });
                        round.canScheduledMatchUpIds = canScheduleMatchUpIds;
                        var possibleToSchedulePct = Math.round((((canScheduleMatchUpIds === null || canScheduleMatchUpIds === void 0 ? void 0 : canScheduleMatchUpIds.length) || 0) / round.matchUpsCount) * 10000) / 100;
                        if (possibleToSchedulePct === Infinity || isNaN(possibleToSchedulePct))
                            possibleToSchedulePct = undefined;
                        round.possibleToSchedulePct = possibleToSchedulePct;
                        if (round.matchUpsCount === (canScheduleMatchUpIds === null || canScheduleMatchUpIds === void 0 ? void 0 : canScheduleMatchUpIds.length)) {
                            round.possibleToSchedule = true;
                        }
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_s && !_s.done && (_m = _r.return)) _m.call(_r);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_q && !_q.done && (_l = _p.return)) _l.call(_p);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    try {
        // Start SCHEDULING
        for (var _g = __values(dateSchedulingProfiles !== null && dateSchedulingProfiles !== void 0 ? dateSchedulingProfiles : []), _h = _g.next(); !_h.done; _h = _g.next()) {
            var dateSchedulingProfile = _h.value;
            _loop_1(dateSchedulingProfile);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // returns the original form of the dateStrings, before extractDate()
    var scheduledDates = (dateSchedulingProfiles !== null && dateSchedulingProfiles !== void 0 ? dateSchedulingProfiles : []).map(function (_a) {
        var scheduleDate = _a.scheduleDate;
        return scheduleDate;
    });
    var autoSchedulingAudit = {
        timeStamp: Date.now(),
        overLimitMatchUpIds: overLimitMatchUpIds,
        scheduledMatchUpIds: scheduledMatchUpIds,
        schedulingProfile: schedulingProfile,
        noTimeMatchUpIds: noTimeMatchUpIds,
        requestConflicts: requestConflicts,
        scheduledDates: scheduledDates,
    };
    auditAutoScheduling({ tournamentRecords: tournamentRecords, autoSchedulingAudit: autoSchedulingAudit });
    return __assign(__assign({}, SUCCESS), { schedulingProfileModifications: schedulingProfileModifications, schedulingProfileIssues: schedulingProfileIssues, dateSchedulingProfiles: dateSchedulingProfiles, recoveryTimeDeferredMatchUpIds: recoveryTimeDeferredMatchUpIds, dependencyDeferredMatchUpIds: dependencyDeferredMatchUpIds, matchUpScheduleTimes: matchUpScheduleTimes, overLimitMatchUpIds: overLimitMatchUpIds, scheduledMatchUpIds: scheduledMatchUpIds, noTimeMatchUpIds: noTimeMatchUpIds, requestConflicts: requestConflicts, scheduledDates: scheduledDates });
}

function clearScheduledMatchUps(params) {
    var e_1, _a;
    var _b = params.scheduleAttributes, scheduleAttributes = _b === void 0 ? ['scheduledDate', 'scheduledTime'] : _b, _c = params.ignoreMatchUpStatuses, ignoreMatchUpStatuses = _c === void 0 ? completedMatchUpStatuses : _c, scheduledDates = params.scheduledDates, venueIds = params.venueIds;
    var tournamentRecords = resolveTournamentRecords(params);
    var tournamentIds = isObject(tournamentRecords)
        ? Object.values(tournamentRecords)
            .map(function (_a) {
            var tournamentId = _a.tournamentId;
            return tournamentId;
        })
            .filter(Boolean)
        : [];
    if (!(tournamentIds === null || tournamentIds === void 0 ? void 0 : tournamentIds.length))
        return { error: MISSING_TOURNAMENT_RECORDS };
    var clearedScheduleCount = 0;
    try {
        for (var tournamentIds_1 = __values(tournamentIds), tournamentIds_1_1 = tournamentIds_1.next(); !tournamentIds_1_1.done; tournamentIds_1_1 = tournamentIds_1.next()) {
            var tournamentId = tournamentIds_1_1.value;
            var tournamentRecord = tournamentRecords[tournamentId];
            var result = clearSchedules({
                ignoreMatchUpStatuses: ignoreMatchUpStatuses,
                scheduleAttributes: scheduleAttributes,
                tournamentRecord: tournamentRecord,
                scheduledDates: scheduledDates,
                venueIds: venueIds,
            });
            if (result.error)
                return result;
            clearedScheduleCount += result.clearedScheduleCount || 0;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (tournamentIds_1_1 && !tournamentIds_1_1.done && (_a = tournamentIds_1.return)) _a.call(tournamentIds_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign(__assign({}, SUCCESS), { clearedScheduleCount: clearedScheduleCount });
}
function clearSchedules(_a) {
    var e_2, _b;
    var _c, _d, _e;
    var _f = _a.scheduleAttributes, scheduleAttributes = _f === void 0 ? ['scheduledDate', 'scheduledTime'] : _f, _g = _a.ignoreMatchUpStatuses, ignoreMatchUpStatuses = _g === void 0 ? completedMatchUpStatuses : _g, tournamentRecord = _a.tournamentRecord, scheduledDates = _a.scheduledDates, _h = _a.venueIds, venueIds = _h === void 0 ? [] : _h;
    if (typeof tournamentRecord !== 'object')
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!Array.isArray(ignoreMatchUpStatuses) || !Array.isArray(venueIds)) {
        return { error: INVALID_VALUES };
    }
    if (venueIds.length)
        scheduleAttributes.push('venueId');
    var inContextMatchUps = (_c = allTournamentMatchUps({
        matchUpFilters: { scheduledDates: scheduledDates },
        tournamentRecord: tournamentRecord,
    }).matchUps) !== null && _c !== void 0 ? _c : [];
    var relevantMatchUpIds = inContextMatchUps
        .filter(function (matchUp) {
        return matchUp.matchUpStatus &&
            !ignoreMatchUpStatuses.includes(matchUp.matchUpStatus) &&
            hasSchedule({ schedule: matchUp.schedule, scheduleAttributes: scheduleAttributes }) &&
            (!(venueIds === null || venueIds === void 0 ? void 0 : venueIds.length) || venueIds.includes(matchUp.schedule.venueId));
    })
        .map(getMatchUpId);
    var matchUps = (_d = allTournamentMatchUps({
        tournamentRecord: tournamentRecord,
        inContext: false,
    }).matchUps) !== null && _d !== void 0 ? _d : [];
    var clearedScheduleCount = 0;
    try {
        for (var matchUps_1 = __values(matchUps), matchUps_1_1 = matchUps_1.next(); !matchUps_1_1.done; matchUps_1_1 = matchUps_1.next()) {
            var matchUp = matchUps_1_1.value;
            if (relevantMatchUpIds.includes(matchUp.matchUpId)) {
                matchUp.timeItems = ((_e = matchUp.timeItems) !== null && _e !== void 0 ? _e : []).filter(function (timeItem) {
                    return (timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType) &&
                        ![
                            ALLOCATE_COURTS,
                            ASSIGN_COURT,
                            ASSIGN_VENUE,
                            SCHEDULED_DATE,
                            SCHEDULED_TIME,
                        ].includes(timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType);
                });
                clearedScheduleCount += 1;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (matchUps_1_1 && !matchUps_1_1.done && (_b = matchUps_1.return)) _b.call(matchUps_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return __assign(__assign({}, SUCCESS), { clearedScheduleCount: clearedScheduleCount });
}

// abstraction layer to allow other schedulers to be defined at a later time
function scheduleProfileRounds(params) {
    var _a, _b;
    var _c = params.checkPotentialRequestConflicts, checkPotentialRequestConflicts = _c === void 0 ? true : _c, scheduleCompletedMatchUps = params.scheduleCompletedMatchUps, clearScheduleDates = params.clearScheduleDates, _d = params.scheduleDates, scheduleDates = _d === void 0 ? [] : _d, tournamentRecords = params.tournamentRecords, periodLength = params.periodLength, useGarman = params.useGarman, dryRun = params.dryRun, pro = params.pro;
    var paramsCheck = checkRequiredParameters(params, [
        (_a = {}, _a[TOURNAMENT_RECORDS] = true, _a),
        (_b = {},
            _b[VALIDATE] = function (value) { return !value || (Array.isArray(value) && value.every(isValidDateString)); },
            _b[SCHEDULE_DATES] = false,
            _b[OF_TYPE] = ARRAY,
            _b),
    ]);
    if (paramsCheck.error)
        return paramsCheck;
    var result = getSchedulingProfile({ tournamentRecords: tournamentRecords });
    if (result.error)
        return result;
    if (!result.schedulingProfile.length)
        return __assign({}, SUCCESS);
    var schedulingProfileModifications = result.modifications, _e = result.issues, schedulingProfileIssues = _e === void 0 ? [] : _e, _f = result.schedulingProfile, schedulingProfile = _f === void 0 ? [] : _f;
    // round robin structures contain other structures and the scheduler
    // needs to reference the containing structure by contained structureIds
    var containedStructureIds = Object.assign.apply(Object, __spreadArray([{}], __read(Object.values(tournamentRecords).map(function (tournamentRecord) { return getContainedStructures({ tournamentRecord: tournamentRecord }).containedStructures; })), false));
    // ensure all scheduleDates are valid date strings
    var validScheduleDates = scheduleDates
        .map(function (scheduleDate) {
        if (!isValidDateString(scheduleDate))
            return;
        return extractDate(scheduleDate);
    })
        .filter(Boolean);
    // filter out any invalid scheduleDates in schedulingProfile
    var profileDates = schedulingProfile
        .map(function (dateSchedulingProfile) { return dateSchedulingProfile.scheduleDate; })
        .map(function (scheduleDate) { return isValidDateString(scheduleDate) && extractDate(scheduleDate); })
        .filter(function (scheduleDate) { return scheduleDate && (!scheduleDates.length || validScheduleDates.includes(scheduleDate)); });
    // if no valid profileDates remain throw an error
    if (!profileDates.length) {
        return { error: NO_VALID_DATES };
    }
    // if array of clearScheduleDates, clear all matchUps on scheduledDates
    if (clearScheduleDates && !dryRun) {
        var scheduledDates = Array.isArray(clearScheduleDates) ? clearScheduleDates : [];
        clearScheduledMatchUps({ tournamentRecords: tournamentRecords, scheduledDates: scheduledDates });
    }
    var courts = getVenuesAndCourts({
        ignoreDisabled: false,
        tournamentRecords: tournamentRecords,
    }).courts;
    var matchUps = allCompetitionMatchUps({
        matchUpFilters: { matchUpTypes: [SINGLES, DOUBLES] },
        afterRecoveryTimes: true,
        nextMatchUps: true,
        tournamentRecords: tournamentRecords,
    }).matchUps;
    // build up a map of all matchUp dependencies
    var matchUpDependencies = getMatchUpDependencies({
        includeParticipantDependencies: true,
        tournamentRecords: tournamentRecords,
        matchUps: matchUps,
    }).matchUpDependencies;
    var matchUpDailyLimits = getMatchUpDailyLimits({ tournamentRecords: tournamentRecords }).matchUpDailyLimits;
    var personRequests = getPersonRequests({
        requestType: DO_NOT_SCHEDULE,
        tournamentRecords: tournamentRecords,
    }).personRequests;
    // filter out any dates in schedulingProfile which have been excluded and sort
    var dateSchedulingProfiles = schedulingProfile
        .filter(function (dateschedulingProfile) {
        var scheduleDate = extractDate(dateschedulingProfile === null || dateschedulingProfile === void 0 ? void 0 : dateschedulingProfile.scheduleDate);
        return profileDates.includes(scheduleDate);
    })
        .sort(function (a, b) {
        return new Date(a.scheduleDate).getTime() - new Date(b.scheduleDate).getTime();
    });
    var schedulingParams = {
        schedulingProfileModifications: schedulingProfileModifications,
        checkPotentialRequestConflicts: checkPotentialRequestConflicts,
        scheduleCompletedMatchUps: scheduleCompletedMatchUps,
        schedulingProfileIssues: schedulingProfileIssues,
        dateSchedulingProfiles: dateSchedulingProfiles,
        containedStructureIds: containedStructureIds,
        matchUpDependencies: matchUpDependencies,
        matchUpDailyLimits: matchUpDailyLimits,
        clearScheduleDates: clearScheduleDates,
        tournamentRecords: tournamentRecords,
        schedulingProfile: schedulingProfile,
        personRequests: personRequests,
        periodLength: periodLength,
        useGarman: useGarman,
        matchUps: matchUps,
        dryRun: dryRun,
        courts: courts,
    };
    if (pro) {
        return v2Scheduler(schedulingParams);
    }
    else {
        return jinnScheduler(schedulingParams);
    }
}

function newTournamentRecord(params) {
    var attributes = params || {};
    if (!attributes.tournamentId)
        attributes.tournamentId = UUID();
    if (attributes.startDate &&
        !isISODateString(attributes.startDate) &&
        !validDateString.test(attributes.startDate)) {
        return { error: INVALID_DATE };
    }
    if (attributes.endDate &&
        !isISODateString(attributes.endDate) &&
        !validDateString.test(attributes.endDate)) {
        return { error: INVALID_DATE };
    }
    if (attributes.extensions) {
        attributes.extensions = attributes.extensions.filter(isValidExtension);
    }
    return __assign({}, attributes);
}

function createTeamsFromParticipantAttributes(_a) {
    var e_1, _b;
    var _c, _d, _e, _f, _g, _h;
    var _j = _a.addParticipants, addParticipants = _j === void 0 ? true : _j, // optional boolean to disable add
    participantAttribute = _a.participantAttribute, tournamentRecord = _a.tournamentRecord, personAttribute = _a.personAttribute, teamNames = _a.teamNames, accessor = _a.accessor, uuids = _a.uuids;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var teams = {};
    var individualParticipants = ((_c = tournamentRecord.participants) !== null && _c !== void 0 ? _c : []).filter(function (_a) {
        var participantType = _a.participantType, participantRole = _a.participantRole;
        return participantType === INDIVIDUAL && participantRole === COMPETITOR;
    });
    var teamIndex = 0;
    try {
        for (var individualParticipants_1 = __values(individualParticipants), individualParticipants_1_1 = individualParticipants_1.next(); !individualParticipants_1_1.done; individualParticipants_1_1 = individualParticipants_1.next()) {
            var individualParticipant = individualParticipants_1_1.value;
            var accessorValue = accessor &&
                ((_d = getAccessorValue({
                    element: individualParticipant,
                    accessor: accessor,
                })) === null || _d === void 0 ? void 0 : _d.value);
            var attributeValue = accessorValue ||
                (personAttribute && ((_e = individualParticipant.person) === null || _e === void 0 ? void 0 : _e[personAttribute])) ||
                (participantAttribute && individualParticipant[participantAttribute]);
            if (attributeValue) {
                if (!Object.keys(teams).includes(attributeValue)) {
                    teams[attributeValue] = {
                        participantName: (_f = teamNames === null || teamNames === void 0 ? void 0 : teamNames[teamIndex]) !== null && _f !== void 0 ? _f : attributeValue,
                        participantId: (_g = uuids === null || uuids === void 0 ? void 0 : uuids.pop()) !== null && _g !== void 0 ? _g : UUID(),
                        individualParticipantIds: [],
                        participantRole: COMPETITOR,
                        participantType: TEAM$1,
                    };
                    var extension = {
                        value: personAttribute !== null && personAttribute !== void 0 ? personAttribute : participantAttribute,
                        name: GROUPING_ATTRIBUTE,
                    };
                    addExtension({ element: teams[attributeValue], extension: extension });
                    teamIndex += 1;
                }
                teams[attributeValue].individualParticipantIds.push(individualParticipant.participantId);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (individualParticipants_1_1 && !individualParticipants_1_1.done && (_b = individualParticipants_1.return)) _b.call(individualParticipants_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var groupingAttributes = Object.keys(teams);
    var overlappingTeamParticipantIds = ((_h = tournamentRecord.participants) !== null && _h !== void 0 ? _h : [])
        .map(function (participant) {
        if (participant.participantType !== TEAM$1)
            return undefined;
        if (participant.participantRole !== COMPETITOR)
            return undefined;
        var extension = findExtension({
            name: GROUPING_ATTRIBUTE,
            element: participant,
        }).extension;
        var groupingAttribute = extension === null || extension === void 0 ? void 0 : extension.value;
        if (groupingAttributes.includes(groupingAttribute)) {
            return participant.participantId;
        }
        return undefined;
    })
        .filter(Boolean);
    var participantsAdded = 0;
    var newParticipants = [];
    Object.keys(teams).forEach(function (attributeValue) {
        var participant = teams[attributeValue];
        var participantId = participant.participantId;
        if (!overlappingTeamParticipantIds.includes(participantId)) {
            if (!tournamentRecord.participants)
                tournamentRecord.participants = [];
            if (addParticipants)
                tournamentRecord.participants.push(participant);
            newParticipants.push(participant);
            participantsAdded++;
        }
    });
    if (addParticipants && participantsAdded) {
        addNotice({
            payload: {
                tournamentId: tournamentRecord.tournamentId,
                participants: newParticipants,
            },
            topic: ADD_PARTICIPANTS,
        });
        return __assign(__assign({}, SUCCESS), { participantsAdded: participantsAdded });
    }
    else if (newParticipants.length) {
        return __assign(__assign({}, SUCCESS), { newParticipants: newParticipants });
    }
    else {
        return { error: NO_PARTICIPANTS_GENERATED };
    }
}

function genParticipantId(_a) {
    var idPrefix = _a.idPrefix, participantType = _a.participantType, index = _a.index, uuids = _a.uuids;
    var type = participantType === INDIVIDUAL ? 'I' : 'P' ;
    return idPrefix ? "".concat(idPrefix, "-").concat(type, "-").concat(index) : (uuids === null || uuids === void 0 ? void 0 : uuids.pop()) || UUID();
}

function generateParticipants(params) {
    var rankingRange = params.rankingRange, // range of ranking positions to generate
    scaledParticipantsCount = params.scaledParticipantsCount;
    var _a = params.ratingsParameters, ratingsParameters$1 = _a === void 0 ? ratingsParameters : _a, valuesInstanceLimit = params.valuesInstanceLimit, consideredDate = params.consideredDate, category = params.category, nationalityCodesCount = params.nationalityCodesCount, nationalityCodeType = params.nationalityCodeType, nationalityCodes = params.nationalityCodes, _b = params.participantsCount, participantsCount = _b === void 0 ? 32 : _b, participantType = params.participantType, personIds = params.personIds, idPrefix = params.idPrefix, uuids = params.uuids, personExtensions = params.personExtensions, addressProps = params.addressProps, gendersCount = params.gendersCount, // used by mocksEngine; internally calculated
    matchUpType = params.matchUpType, personData = params.personData, sex = params.sex, inContext = params.inContext, withISO2 = params.withISO2, withIOC = params.withIOC, scaleAllParticipants = params.scaleAllParticipants;
    var doubles = participantType === PAIR || matchUpType === DOUBLES_MATCHUP;
    var team = participantType === TEAM$1 || matchUpType === TEAM$1;
    if (rankingRange &&
        (!Array.isArray(rankingRange) || !rankingRange.every(function (r) { return isNumeric(r); }) || rankingRange.length !== 2)) {
        rankingRange = undefined;
    }
    scaledParticipantsCount = scaleAllParticipants ? participantsCount : scaledParticipantsCount;
    var defaultRankingRange = 1000;
    var rankingUpperBound = scaledParticipantsCount && scaledParticipantsCount > defaultRankingRange
        ? scaledParticipantsCount
        : defaultRankingRange;
    rankingRange = rankingRange || [1, rankingUpperBound];
    rankingRange[1] += 1; // so that behavior is as expected
    var individualParticipantsCount = participantsCount * (doubles ? 2 : team ? 8 : 1);
    var result = generatePersons({
        count: individualParticipantsCount,
        personExtensions: personExtensions,
        consideredDate: consideredDate,
        gendersCount: gendersCount,
        personData: personData,
        category: category,
        sex: sex,
    });
    if (result.error)
        return result;
    var personNationalityCodes = result.nationalityCodes, mockedPersons = result.persons;
    // generated arrays of rankings and ratings to be attached as scaleItems
    var doublesRankings = [], singlesRankings = [], singlesRatings = [], doublesRatings = [];
    if (typeof category === 'object') {
        var categoryName = category.categoryName, ageCategoryCode = category.ageCategoryCode, ratingType = category.ratingType;
        if ((categoryName || ageCategoryCode) && !ratingType) {
            var _c = __read(rankingRange || [], 2), start = _c[0], end = _c[1];
            singlesRankings = shuffleArray(generateRange(start, end)).slice(0, scaledParticipantsCount || randomInt(20, 30));
            if ([PAIR, TEAM$1].includes(participantType)) {
                var _d = __read(rankingRange || [], 2), start_1 = _d[0], end_1 = _d[1];
                doublesRankings = shuffleArray(generateRange(start_1, end_1)).slice(0, scaledParticipantsCount || randomInt(20, 30));
            }
        }
        if (ratingType && ratingsParameters$1[ratingType]) {
            // ratingAttributes allows selected attributes of ratingParameters to be overridden
            var ratingMax_1 = category.ratingMax, ratingMin_1 = category.ratingMin, ratingAttributes = category.ratingAttributes;
            var ratingParameters = __assign(__assign({}, ratingsParameters$1[ratingType]), (ratingAttributes || {}));
            var _e = ratingParameters.attributes, attributes_1 = _e === void 0 ? {} : _e, decimalsCount_1 = ratingParameters.decimalsCount, accessors_1 = ratingParameters.accessors, range = ratingParameters.range, step_1 = ratingParameters.step;
            var getAttributes_1 = function (attributes) {
                var e_1, _a;
                var generatedAttributes = {};
                var attributeKeys = Object.keys(attributes || {});
                try {
                    for (var attributeKeys_1 = __values(attributeKeys), attributeKeys_1_1 = attributeKeys_1.next(); !attributeKeys_1_1.done; attributeKeys_1_1 = attributeKeys_1.next()) {
                        var attribute = attributeKeys_1_1.value;
                        var attributeValue = attributes[attribute];
                        if (typeof attributeValue === 'object' && attributeValue.generator) {
                            var range_1 = attributeValue.range;
                            var _b = __read(range_1.slice().sort(), 2), min_1 = _b[0], max_1 = _b[1];
                            generatedAttributes[attribute] = randomInt(min_1, max_1);
                        }
                        else {
                            generatedAttributes[attribute] = attributeValue;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (attributeKeys_1_1 && !attributeKeys_1_1.done && (_a = attributeKeys_1.return)) _a.call(attributeKeys_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return generatedAttributes;
            };
            var inverted = range[0] > range[1];
            var skew_1 = inverted ? 2 : 0.5;
            var _f = __read(range.slice().sort(), 2), min_2 = _f[0], max_2 = _f[1];
            var generateRatings = function () {
                return generateRange(0, 2000) // overgenerate because filter and restricted range will impact final count
                    .map(function () { return skewedDistribution(min_2, max_2, skew_1, step_1, decimalsCount_1); })
                    .filter(function (rating) { return (!ratingMax_1 || rating <= ratingMax_1) && (!ratingMin_1 || rating >= ratingMin_1); })
                    .slice(0, scaledParticipantsCount || randomInt(20, 30))
                    .map(function (scaleValue) {
                    return !accessors_1
                        ? scaleValue
                        : Object.assign.apply(Object, __spreadArray(__spreadArray([{}], __read(accessors_1.map(function (accessor) {
                            var _a;
                            return (_a = {}, _a[accessor] = scaleValue, _a);
                        })), false), [getAttributes_1(attributes_1)], false));
                });
            };
            singlesRatings = generateRatings();
            if ([PAIR, TEAM$1].includes(participantType)) {
                doublesRatings = generateRatings();
            }
        }
    }
    var countryCodes = countries.filter(function (country) {
        return nationalityCodeType === 'IOC' ? country.ioc || country.iso : country.iso;
    });
    function getMin(count) {
        var instances = Math.ceil(individualParticipantsCount / count);
        if (valuesInstanceLimit && instances > valuesInstanceLimit)
            return Math.ceil(individualParticipantsCount / valuesInstanceLimit);
        return count;
    }
    var _g = addressProps || {}, postalCodesProfile = _g.postalCodesProfile, postalCodesCount = _g.postalCodesCount, statesProfile = _g.statesProfile, citiesProfile = _g.citiesProfile, citiesCount = _g.citiesCount, statesCount = _g.statesCount;
    var valuesFromProfile = function (profile) {
        return Object.keys(profile)
            .map(function (key) { return generateRange(0, statesProfile[key]).map(function () { return key; }); })
            .flat();
    };
    var cities = (citiesProfile && valuesFromProfile(citiesProfile)) ||
        (addressProps === null || addressProps === void 0 ? void 0 : addressProps.cities) ||
        cityMocks({
            count: citiesCount || individualParticipantsCount,
            participantsCount: individualParticipantsCount,
        }).cities;
    var states = (statesProfile && valuesFromProfile(statesProfile)) ||
        (addressProps === null || addressProps === void 0 ? void 0 : addressProps.states) ||
        stateMocks({
            count: statesCount || individualParticipantsCount,
            participantsCount: individualParticipantsCount,
        }).states;
    var postalCodes = (postalCodesProfile && valuesFromProfile(postalCodesProfile)) ||
        (addressProps === null || addressProps === void 0 ? void 0 : addressProps.postalCodes) ||
        postalCodeMocks({
            count: postalCodesCount || individualParticipantsCount,
            participantsCount: individualParticipantsCount,
        }).postalCodes;
    var addressValues = { cities: cities, states: states, postalCodes: postalCodes };
    var isoMin = getMin(nationalityCodesCount);
    var isoList = isoMin
        ? shuffleArray(countryCodes).slice(0, nationalityCodesCount)
        : nationalityCodes
            ? countryCodes.filter(function (isoCountry) { return nationalityCodes.includes(isoCountry.iso); })
            : countryCodes;
    var countriesList = shuffleArray(generateRange(0, Math.ceil(individualParticipantsCount / (isoMin || 1)))
        .map(function () { return isoList; })
        .flat(Infinity));
    var teamNames = nameMocks({ count: participantsCount }).names;
    var participants = generateRange(0, participantsCount)
        .map(function (i) {
        var sideParticipantsCount = doubles ? 2 : team ? 8 : 1;
        var individualParticipants = generateRange(0, sideParticipantsCount).map(function (j) {
            var participantIndex = i * sideParticipantsCount + j;
            return generateIndividualParticipant(participantIndex);
        });
        var individualParticipantIds = individualParticipants.map(function (participant) { return participant.participantId; });
        var pairName = individualParticipants.map(function (i) { return i.person.standardFamilyName; }).join('/');
        var participantType = doubles ? PAIR : TEAM$1;
        var groupParticipant = {
            participantId: genParticipantId({
                participantType: participantType,
                idPrefix: idPrefix,
                index: i,
                uuids: uuids,
            }),
            participantRole: COMPETITOR,
            participantName: doubles ? pairName : teamNames[i],
            individualParticipantIds: individualParticipantIds,
            participantType: participantType,
        };
        if (inContext)
            groupParticipant.individualParticipants = individualParticipants;
        return doubles || team ? __spreadArray([groupParticipant], __read(individualParticipants), false) : individualParticipants;
    })
        .flat();
    return { participants: participants };
    function generateIndividualParticipant(participantIndex) {
        var person = mockedPersons[participantIndex];
        var _a = person || {}, personNationalityCode = _a.nationalityCode, participantExtensions = _a.participantExtensions, participantTimeItems = _a.participantTimeItems, extensions = _a.extensions, firstName = _a.firstName, birthDate = _a.birthDate, lastName = _a.lastName, personId = _a.personId, sex = _a.sex;
        var standardGivenName = firstName || 'GivenName';
        var standardFamilyName = lastName || 'FamilyName';
        var participantName = "".concat(standardGivenName, " ").concat(standardFamilyName);
        var country = countriesList[participantIndex];
        var nationalityCode = ((personNationalityCodes === null || personNationalityCodes === void 0 ? void 0 : personNationalityCodes.length) && personNationalityCode) ||
            (country && (nationalityCodeType === 'IOC' ? country.ioc || country.iso : country.iso || country.ioc)) ||
            personNationalityCode;
        if ((countriesList === null || countriesList === void 0 ? void 0 : countriesList.length) && !nationalityCode && !personNationalityCode) {
            console.log('%c Invalid Nationality Code', { participantIndex: participantIndex, country: country });
        }
        var address = generateAddress(__assign(__assign({}, addressValues), { participantIndex: participantIndex, nationalityCode: nationalityCode }));
        var participant = definedAttributes({
            participantId: genParticipantId({
                participantType: INDIVIDUAL,
                index: participantIndex,
                idPrefix: idPrefix,
                uuids: uuids,
            }),
            extensions: participantExtensions,
            timeItems: participantTimeItems,
            participantRole: COMPETITOR,
            participantType: INDIVIDUAL,
            participantName: participantName,
            person: {
                addresses: [address],
                personId: personId || ((personIds === null || personIds === void 0 ? void 0 : personIds.length) && personIds[participantIndex]) || UUID(),
                standardFamilyName: standardFamilyName,
                standardGivenName: standardGivenName,
                nationalityCode: nationalityCode,
                extensions: extensions,
                birthDate: isValidDateString(birthDate) ? birthDate : undefined,
                sex: sex,
            },
        });
        if (withIOC && nationalityCode) {
            var country_1 = countries.find(function (_a) {
                var iso = _a.iso;
                return iso === nationalityCode;
            });
            if (country_1 === null || country_1 === void 0 ? void 0 : country_1.ioc)
                participant.person.iocNationalityCode = country_1.ioc;
            if (country_1 === null || country_1 === void 0 ? void 0 : country_1.label)
                participant.person.countryName = country_1.label;
        }
        if (withISO2 && nationalityCode) {
            var country_2 = countries.find(function (_a) {
                var iso = _a.iso;
                return iso === nationalityCode;
            });
            if (country_2 === null || country_2 === void 0 ? void 0 : country_2.iso2)
                participant.person.iso2NationalityCode = country_2.iso2;
            if (country_2 === null || country_2 === void 0 ? void 0 : country_2.label)
                participant.person.countryName = country_2.label;
        }
        if (category) {
            var singlesRanking = singlesRankings[participantIndex];
            var doublesRanking = doublesRankings[participantIndex];
            addScaleItem({
                scaleValue: singlesRanking,
                eventType: SINGLES_EVENT,
                scaleType: RANKING$1,
                participant: participant,
                category: category,
            });
            addScaleItem({
                scaleValue: doublesRanking,
                eventType: DOUBLES_EVENT,
                scaleType: RANKING$1,
                participant: participant,
                category: category,
            });
            var singlesRating = singlesRatings[participantIndex];
            var doublesRating = doublesRatings[participantIndex];
            addScaleItem({
                scaleValue: singlesRating,
                eventType: SINGLES_EVENT,
                scaleType: RATING$1,
                participant: participant,
                category: category,
            });
            addScaleItem({
                scaleValue: doublesRating,
                eventType: DOUBLES_EVENT,
                scaleType: RATING$1,
                participant: participant,
                category: category,
            });
        }
        return participant;
    }
}
function addScaleItem(_a) {
    var itemValue = _a.scaleValue, participant = _a.participant, eventType = _a.eventType, scaleType = _a.scaleType, category = _a.category;
    var scaleName = category.categoryName || category.ratingType || category.ageCategoryCode;
    var itemType = [SCALE$1, scaleType, eventType, scaleName].join('.');
    var timeItem = { itemValue: itemValue, itemType: itemType };
    if (scaleName && itemValue) {
        if (!participant.timeItems)
            participant.timeItems = [];
        participant.timeItems.push(timeItem);
    }
}

function processTieFormat(_a) {
    var _b;
    var _c;
    var _d = _a.alternatesCount, alternatesCount = _d === void 0 ? 0 : _d, tieFormatName = _a.tieFormatName, tieFormat = _a.tieFormat, drawSize = _a.drawSize;
    var maxDoublesCount = 0, maxSinglesCount = 0;
    var singlesMatchUpTotal = 0, doublesMatchUpTotal = 0;
    var categories = {};
    var genders = (_b = {}, _b[MALE] = 0, _b[FEMALE] = 0, _b[MIXED] = 0, _b[OTHER$2] = 0, _b[ANY] = 0, _b);
    tieFormat =
        typeof tieFormat === 'object'
            ? tieFormat
            : tieFormatDefaults({ namedFormat: tieFormatName });
    (_c = tieFormat === null || tieFormat === void 0 ? void 0 : tieFormat.collectionDefinitions) === null || _c === void 0 ? void 0 : _c.filter(Boolean).forEach(function (collectionDefinition) {
        var category = collectionDefinition.category, collectionId = collectionDefinition.collectionId, matchUpType = collectionDefinition.matchUpType, matchUpCount = collectionDefinition.matchUpCount, gender = collectionDefinition.gender;
        if ([MALE, FEMALE].includes(gender)) {
            var required = matchUpCount * (matchUpType === DOUBLES ? 2 : 1);
            if (genders[gender] < required)
                genders[gender] = required;
        }
        else if (gender === MIXED) {
            if (genders[MALE] < matchUpCount)
                genders[MALE] = matchUpCount;
            if (genders[FEMALE] < matchUpCount)
                genders[FEMALE] = matchUpCount;
        }
        if (category) {
            var categoryString = JSON.stringify(category);
            categories[categoryString] = category;
        }
        // ensure every collectionDefinition has a collectionId
        if (!collectionId)
            collectionDefinition.collectionId = UUID();
        if (matchUpType === DOUBLES) {
            var doublesCount = matchUpCount;
            doublesMatchUpTotal += matchUpCount;
            maxDoublesCount = Math.max(maxDoublesCount, doublesCount);
        }
        if (matchUpType === SINGLES) {
            var singlescount = matchUpCount;
            singlesMatchUpTotal += matchUpCount;
            maxSinglesCount = Math.max(maxSinglesCount, singlescount);
        }
    });
    var teamSize = Object.keys(categories).length
        ? Math.max(singlesMatchUpTotal, doublesMatchUpTotal * 2)
        : Math.max(maxSinglesCount, maxDoublesCount * 2);
    var maxDoublesDraw = maxDoublesCount * (drawSize + alternatesCount);
    var maxSinglesDraw = maxSinglesCount * (drawSize + alternatesCount);
    return {
        maxDoublesDraw: maxDoublesDraw,
        maxSinglesDraw: maxSinglesDraw,
        teamSize: teamSize,
        genders: genders,
    };
}

function getParticipantsCount(_a) {
    var _b, e_1, _c;
    var participantsProfile = _a.participantsProfile, eventProfiles = _a.eventProfiles, drawProfiles = _a.drawProfiles;
    var _d = participantsProfile || {}, participantsCount = _d.participantsCount, _e = _d.participantType, participantType = _e === void 0 ? INDIVIDUAL : _e;
    var specifiedParicipantsCount = participantsCount || 0; // capture this to ensure calculated participantsCount is not below
    var gendersCount = (_b = {},
        _b[FEMALE] = 0,
        _b[MIXED] = 0,
        _b[OTHER$2] = 0,
        _b[MALE] = 0,
        _b[ANY] = 0,
        _b);
    var largestDoublesDraw = 0, largestSinglesDraw = 0, largestTeamSize = 0, largestTeamDraw = 0, uniqueParticipantsCount = 0;
    var processDrawProfile = function (_a) {
        var _b = _a.alternatesCount, alternatesCount = _b === void 0 ? 0 : _b, uniqueParticipants = _a.uniqueParticipants, tieFormatName = _a.tieFormatName, _c = _a.drawSize, drawSize = _c === void 0 ? 0 : _c, eventType = _a.eventType, tieFormat = _a.tieFormat, category = _a.category, gender = _a.gender, stage = _a.stage;
        var isDoubles = eventType === DOUBLES$1;
        var isTeam = eventType === TEAM$2;
        var requiresUniqueParticipants = Boolean(uniqueParticipants || stage === QUALIFYING || category || gender);
        if (isTeam) {
            largestTeamDraw = Math.max(largestTeamDraw, drawSize + alternatesCount);
            tieFormat =
                typeof tieFormat === 'object'
                    ? tieFormat
                    : tieFormatDefaults({ namedFormat: tieFormatName });
            var _d = processTieFormat({
                alternatesCount: alternatesCount,
                tieFormatName: tieFormatName,
                tieFormat: tieFormat,
                drawSize: drawSize,
            }), teamSize = _d.teamSize, maxDoublesDraw = _d.maxDoublesDraw, maxSinglesDraw = _d.maxSinglesDraw, genders_1 = _d.genders;
            largestTeamSize = Math.max(largestTeamSize, teamSize);
            largestSinglesDraw = Math.max(largestSinglesDraw, maxSinglesDraw);
            if (!requiresUniqueParticipants) {
                largestDoublesDraw = Math.max(largestDoublesDraw, maxDoublesDraw);
            }
            Object.keys(genders_1).forEach(function (key) { return (gendersCount[key] += genders_1[key]); });
        }
        else if (isDoubles) {
            if (requiresUniqueParticipants) {
                var additionalParticipantsCount = (drawSize + alternatesCount) * 2;
                uniqueParticipantsCount += additionalParticipantsCount;
                if (gender)
                    gendersCount[gender] += additionalParticipantsCount;
            }
            else if (drawSize + alternatesCount &&
                drawSize + alternatesCount > largestDoublesDraw) {
                largestDoublesDraw = drawSize + alternatesCount;
            }
        }
        else if (requiresUniqueParticipants) {
            var additionalParticipantsCount = drawSize + alternatesCount;
            if (gender)
                gendersCount[gender] += additionalParticipantsCount;
            uniqueParticipantsCount += additionalParticipantsCount;
        }
        else if (drawSize && drawSize > largestSinglesDraw) {
            largestSinglesDraw = drawSize + alternatesCount;
        }
    };
    /*
     * TODO: let categories = []; // use when generating participants
     */
    eventProfiles === null || eventProfiles === void 0 ? void 0 : eventProfiles.forEach(function (eventProfile) {
        var e_2, _a;
        var eventTieFormatName = eventProfile.tieFormatName, eventTieFormat = eventProfile.tieFormat, drawProfiles = eventProfile.drawProfiles, eventType = eventProfile.eventType, category = eventProfile.category, gender = eventProfile.gender;
        if (drawProfiles) {
            try {
                for (var drawProfiles_2 = __values(drawProfiles), drawProfiles_2_1 = drawProfiles_2.next(); !drawProfiles_2_1.done; drawProfiles_2_1 = drawProfiles_2.next()) {
                    var drawProfile = drawProfiles_2_1.value;
                    var tieFormatName = drawProfile.tieFormatName, tieFormat = drawProfile.tieFormat;
                    processDrawProfile(__assign(__assign({}, drawProfile), { tieFormatName: tieFormatName || eventTieFormatName, tieFormat: tieFormat || eventTieFormat, eventType: eventType, category: category, gender: gender }));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (drawProfiles_2_1 && !drawProfiles_2_1.done && (_a = drawProfiles_2.return)) _a.call(drawProfiles_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    });
    if (Array.isArray(drawProfiles)) {
        try {
            for (var drawProfiles_1 = __values(drawProfiles), drawProfiles_1_1 = drawProfiles_1.next(); !drawProfiles_1_1.done; drawProfiles_1_1 = drawProfiles_1.next()) {
                var drawProfile = drawProfiles_1_1.value;
                processDrawProfile(drawProfile);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (drawProfiles_1_1 && !drawProfiles_1_1.done && (_c = drawProfiles_1.return)) _c.call(drawProfiles_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    var individualCompetitorsCount = Math.max(largestTeamDraw * largestTeamSize, largestDoublesDraw * 2, largestSinglesDraw);
    if (largestDoublesDraw)
        participantType = PAIR;
    if ((participantsCount || specifiedParicipantsCount) <
        individualCompetitorsCount)
        participantsCount = individualCompetitorsCount;
    if (participantsCount &&
        largestDoublesDraw &&
        [PAIR, TEAM$2].includes(participantType)) {
        // if we are generating PAIRs or TEAMs...
        if (largestSinglesDraw &&
            Math.floor(largestSinglesDraw / 2) > largestDoublesDraw) {
            // if the half the singles draw is still larger than doubles draw
            participantsCount = Math.floor(largestSinglesDraw / 2);
        }
        else if (!largestSinglesDraw ||
            largestDoublesDraw * 2 >= largestSinglesDraw) {
            // otherwise participantsCount can be cut in half
            participantsCount = Math.ceil(participantsCount / 2);
        }
    }
    // if (participantsCount === undefined) participantsCount = 32;
    if (participantsCount === undefined) {
        participantsCount =
            !(eventProfiles === null || eventProfiles === void 0 ? void 0 : eventProfiles.length) && !(drawProfiles === null || drawProfiles === void 0 ? void 0 : drawProfiles.length) ? 32 : 0;
    }
    if (participantsCount < specifiedParicipantsCount)
        participantsCount = specifiedParicipantsCount;
    return {
        uniqueParticipantsCount: uniqueParticipantsCount,
        participantsCount: participantsCount,
        largestTeamDraw: largestTeamDraw,
        largestTeamSize: largestTeamSize,
        participantType: participantType,
        gendersCount: gendersCount,
    };
}

function addTournamentParticipants(_a) {
    var participantsProfile = _a.participantsProfile, tournamentRecord = _a.tournamentRecord, eventProfiles = _a.eventProfiles, drawProfiles = _a.drawProfiles, startDate = _a.startDate, uuids = _a.uuids;
    var _b = getParticipantsCount({
        participantsProfile: participantsProfile,
        eventProfiles: eventProfiles,
        drawProfiles: drawProfiles,
    }), participantsCount = _b.participantsCount, participantType = _b.participantType, largestTeamDraw = _b.largestTeamDraw, largestTeamSize = _b.largestTeamSize, gendersCount = _b.gendersCount;
    var teamKey = participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.teamKey;
    var participants = generateParticipants(__assign(__assign({ uuids: uuids }, participantsProfile), { consideredDate: startDate, participantsCount: participantsCount, participantType: participantType, gendersCount: gendersCount })).participants;
    var addedCount = 0;
    var result = addParticipants({ tournamentRecord: tournamentRecord, participants: participants });
    if (result.error)
        return result;
    addedCount += result.addedCount;
    if (teamKey) {
        var result_1 = createTeamsFromParticipantAttributes(__assign({ tournamentRecord: tournamentRecord }, teamKey));
        if (result_1.error)
            return result_1;
    }
    // generate Team participants
    var allIndividualParticipantIds = participants
        .filter(function (_a) {
        var participantType = _a.participantType;
        return participantType === INDIVIDUAL;
    })
        .map(getParticipantId);
    var idPrefix = (participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.idPrefix) ? "".concat(TEAM$1, "-").concat(participantsProfile.idPrefix) : undefined;
    var teamParticipants = generateRange(0, largestTeamDraw).map(function (teamIndex) {
        var individualParticipantIds = allIndividualParticipantIds.slice(teamIndex * largestTeamSize, (teamIndex + 1) * largestTeamSize);
        var participantId = genParticipantId({
            index: teamIndex,
            participantType: participantType,
            idPrefix: idPrefix,
            uuids: uuids,
        });
        return {
            participantName: "Team ".concat(teamIndex + 1),
            participantRole: COMPETITOR,
            individualParticipantIds: individualParticipantIds,
            participantType: TEAM$1,
            participantId: participantId,
        };
    });
    result = addParticipants({
        participants: teamParticipants,
        tournamentRecord: tournamentRecord,
    });
    if (result.error)
        return result;
    addedCount += result.addedCount;
    return __assign({ addedCount: addedCount }, SUCCESS);
}

var courtTemplate = function () { return ({
    altitude: undefined,
    courtId: undefined,
    courtName: '',
    courtDimensions: undefined,
    latitude: undefined,
    longitude: undefined,
    surfaceCategory: undefined,
    surfaceType: undefined,
    surfacedDate: undefined,
    dateAvailability: [],
    onlineResources: [],
    pace: undefined,
    notes: undefined,
}); };

function getInt(value) {
    return parseInt(value);
}
function validTimePeriod(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.startTime, startTime = _c === void 0 ? '' : _c, _d = _b.endTime, endTime = _d === void 0 ? '' : _d;
    if (!startTime ||
        !endTime ||
        !timeValidation.test(startTime) ||
        !timeValidation.test(endTime))
        return false;
    var _e = __read(startTime.split(':').map(getInt), 2), startHour = _e[0], startMinute = _e[1];
    var _f = __read(endTime.split(':').map(getInt), 2), endHour = _f[0], endMinute = _f[1];
    if (endHour < startHour)
        return false;
    return startHour === endHour && endMinute < startMinute ? false : true;
}
function startTimeSort(a, b) {
    var _a = __read(a.startTime.split(':').map(getInt), 2), startHourA = _a[0], startMinuteA = _a[1];
    var _b = __read(b.startTime.split(':').map(getInt), 2), startHourB = _b[0], startMinuteB = _b[1];
    if (startHourA < startHourB)
        return -1;
    if (startHourA > startHourB)
        return 1;
    if (startMinuteA < startMinuteB)
        return -1;
    if (startMinuteA > startMinuteB)
        return 1;
    return 0;
}

function validDateAvailability(_a) {
    var e_1, _b, e_2, _c;
    var dateAvailability = _a.dateAvailability;
    if (!dateAvailability)
        return { error: MISSING_DATE_AVAILABILITY };
    if (!Array.isArray(dateAvailability))
        return { error: INVALID_DATE_AVAILABILITY };
    var dateNote = 'Dates must be formated => YYYY-MM-DD';
    var timeNote = 'Times must be 24 hour => 00:00';
    try {
        for (var dateAvailability_1 = __values(dateAvailability), dateAvailability_1_1 = dateAvailability_1.next(); !dateAvailability_1_1.done; dateAvailability_1_1 = dateAvailability_1.next()) {
            var availability = dateAvailability_1_1.value;
            if (typeof availability !== 'object') {
                return { error: INVALID_DATE_AVAILABILITY };
            }
            var date = availability.date, startTime = availability.startTime, endTime = availability.endTime, _d = availability.bookings, bookings = _d === void 0 ? [] : _d;
            if (!startTime || !endTime) {
                return { error: INVALID_DATE_AVAILABILITY };
            }
            if (date && !dateValidation.test(date)) {
                return {
                    error: INVALID_DATE,
                    dateAvailability: { date: date },
                    info: dateNote,
                };
            }
            if (!timeValidation.test(startTime)) {
                return {
                    error: INVALID_TIME,
                    dateAvailability: { startTime: startTime },
                    info: timeNote,
                };
            }
            if (!timeValidation.test(endTime)) {
                return {
                    error: INVALID_TIME,
                    dateAvailability: { endTime: endTime },
                    info: timeNote,
                };
            }
            if (startTime === endTime) {
                return {
                    error: INVALID_TIME,
                    dateAvailability: { startTime: startTime, endTime: endTime },
                    info: 'startTime and endTime are equivalent',
                };
            }
            if (!validTimePeriod({ startTime: startTime, endTime: endTime })) {
                return {
                    error: INVALID_TIME,
                    dateAvailability: { startTime: startTime, endTime: endTime },
                    info: 'endTime must be after startTime',
                };
            }
            if (bookings) {
                if (!Array.isArray(bookings)) {
                    return { error: INVALID_BOOKINGS };
                }
                try {
                    for (var bookings_1 = (e_2 = void 0, __values(bookings)), bookings_1_1 = bookings_1.next(); !bookings_1_1.done; bookings_1_1 = bookings_1.next()) {
                        var booking = bookings_1_1.value;
                        if (typeof booking !== 'object') {
                            return { error: INVALID_BOOKINGS };
                        }
                        var startTime_1 = booking.startTime, endTime_1 = booking.endTime;
                        if (!timeValidation.test(startTime_1)) {
                            return {
                                error: INVALID_TIME,
                                booking: { startTime: startTime_1 },
                                info: timeNote,
                            };
                        }
                        if (!timeValidation.test(endTime_1)) {
                            return {
                                error: INVALID_TIME,
                                booking: { endTime: endTime_1 },
                                info: timeNote,
                            };
                        }
                        if (startTime_1 === endTime_1) {
                            return {
                                error: INVALID_TIME,
                                dateAvailability: { startTime: startTime_1, endTime: endTime_1 },
                                info: 'startTime and endTime are equivalent',
                            };
                        }
                        if (!validTimePeriod({ startTime: startTime_1, endTime: endTime_1 })) {
                            return {
                                error: INVALID_TIME,
                                dateAvailability: { startTime: startTime_1, endTime: endTime_1 },
                                info: 'endTime must be after startTime',
                            };
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (bookings_1_1 && !bookings_1_1.done && (_c = bookings_1.return)) _c.call(bookings_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (dateAvailability_1_1 && !dateAvailability_1_1.done && (_b = dateAvailability_1.return)) _b.call(dateAvailability_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { valid: true };
}

function addCourt(_a) {
    var e_1, _b;
    var tournamentRecord = _a.tournamentRecord, disableNotice = _a.disableNotice, venueId = _a.venueId, courtId = _a.courtId, court = _a.court;
    var venue = findVenue({ tournamentRecord: tournamentRecord, venueId: venueId }).venue;
    if (!venue)
        return { error: VENUE_NOT_FOUND };
    if (!venue.courts)
        venue.courts = [];
    var courtRecord = __assign(__assign({}, courtTemplate()), { venueId: venueId, courtId: courtId });
    if (!courtRecord.courtId) {
        courtRecord.courtId = UUID();
    }
    var courtExists = venue.courts.some(function (candidate) { return candidate.courtId === courtRecord.courtId; });
    if (courtExists) {
        return { error: COURT_EXISTS };
    }
    else {
        // build new dateAvailability object with date/time extraction
        var dateAvailability = ((court === null || court === void 0 ? void 0 : court.dateAvailability) || []).map(function (availabilty) {
            var _a;
            return (__assign(__assign({}, availabilty), { date: extractDate(availabilty.date), startTime: extractTime(availabilty.startTime), endTime: extractTime(availabilty.endTime), bookings: (_a = availabilty.bookings) === null || _a === void 0 ? void 0 : _a.map(function (_a) {
                    var startTime = _a.startTime, endTime = _a.endTime, bookingType = _a.bookingType;
                    return ({
                        startTime: extractTime(startTime),
                        endTime: extractTime(endTime),
                        bookingType: bookingType,
                    });
                }) }));
        });
        var attributes = Object.keys(courtRecord);
        try {
            for (var attributes_1 = __values(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {
                var attribute = attributes_1_1.value;
                if (court === null || court === void 0 ? void 0 : court[attribute]) {
                    if (attribute === 'dateAvailability') {
                        var result = validDateAvailability({ dateAvailability: dateAvailability });
                        if (!result.valid && result.error)
                            return result;
                        courtRecord.dateAvailability = dateAvailability;
                    }
                    else {
                        courtRecord[attribute] = court[attribute];
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (attributes_1_1 && !attributes_1_1.done && (_b = attributes_1.return)) _b.call(attributes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var newCourt = courtRecord;
        venue.courts.push(newCourt);
        if (!disableNotice) {
            addNotice({
                payload: { venue: venue, tournamentId: tournamentRecord.tournamentId },
                topic: MODIFY_VENUE,
                key: venue.venueId,
            });
        }
        return __assign(__assign({}, SUCCESS), { court: makeDeepCopy(courtRecord), venueId: venueId });
    }
}
function addCourts(params) {
    var _a, e_2, _b, e_3, _c;
    var _d, _e, _f;
    // if tournamentRecord is not linked to other tournamentRecods, only add to tournamentRecord
    var tournamentRecord = params.tournamentRecord, venueId = params.venueId;
    if (typeof venueId !== 'string' || !venueId)
        return { error: MISSING_VENUE_ID };
    var tournamentRecords = (_e = (_d = params.tournamentRecords) !== null && _d !== void 0 ? _d : (tournamentRecord && (_a = {},
        _a[tournamentRecord.tournamentId] = tournamentRecord,
        _a))) !== null && _e !== void 0 ? _e : {};
    var courtIds = [];
    var success;
    try {
        for (var _g = __values(Object.values(tournamentRecords)), _h = _g.next(); !_h.done; _h = _g.next()) {
            var tournamentRecord_1 = _h.value;
            var venue = findVenue({ tournamentRecord: tournamentRecord_1, venueId: venueId }).venue;
            if (venue) {
                // TODO: create courts before adding to each tournamentRecord
                var result = courtsAdd(__assign(__assign({}, params), { tournamentRecord: tournamentRecord_1 }));
                try {
                    for (var _j = (e_3 = void 0, __values((_f = result === null || result === void 0 ? void 0 : result.courts) !== null && _f !== void 0 ? _f : [])), _k = _j.next(); !_k.done; _k = _j.next()) {
                        var court = _k.value;
                        courtIds.push(court === null || court === void 0 ? void 0 : court.courtId);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                if (result.error)
                    return result;
                success = true;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return success ? __assign(__assign({}, SUCCESS), { courtIds: courtIds }) : { error: VENUE_NOT_FOUND };
}
function courtsAdd(_a) {
    var _b = _a.courtNameRoot, courtNameRoot = _b === void 0 ? 'Court' : _b, _c = _a.dateAvailability, dateAvailability = _c === void 0 ? [] : _c, venueAbbreviationRoot = _a.venueAbbreviationRoot, tournamentRecord = _a.tournamentRecord, _d = _a.courtNames, courtNames = _d === void 0 ? [] : _d, courtTimings = _a.courtTimings, courtsCount = _a.courtsCount, startTime = _a.startTime, courtIds = _a.courtIds, endTime = _a.endTime, idPrefix = _a.idPrefix, venueId = _a.venueId, dates = _a.dates;
    if (!venueId)
        return { error: MISSING_VENUE_ID };
    var result = findVenue({ tournamentRecord: tournamentRecord, venueId: venueId });
    if (result.error)
        return result;
    var venue = result.venue;
    if (!isNumeric(courtsCount) || !courtNames)
        return { error: MISSING_COURTS_INFO };
    courtsCount = courtsCount !== null && courtsCount !== void 0 ? courtsCount : courtNames.length;
    var courts = generateRange(0, courtsCount).map(function (i) {
        var courtTiming = courtTimings === null || courtTimings === void 0 ? void 0 : courtTimings[i];
        var courtAvailability = courtTiming
            ? dates.map(function (date) { return (__assign({ date: formatDate(date), startTime: startTime, endTime: endTime }, courtTiming)); })
            : dateAvailability;
        // when courtTiming is provided, also add default availability
        if (courtTiming && startTime && endTime)
            courtAvailability.push({ startTime: startTime, endTime: endTime });
        return {
            courtName: courtNames[i] ||
                (venueAbbreviationRoot &&
                    (venue === null || venue === void 0 ? void 0 : venue.venueAbbreviation) &&
                    "".concat(venue === null || venue === void 0 ? void 0 : venue.venueAbbreviation, " ").concat(i + 1)) ||
                "".concat(courtNameRoot, " ").concat(i + 1),
            dateAvailability: courtAvailability,
        };
    });
    var mapResult = courts.map(function (court, i) {
        var courtId = (courtIds === null || courtIds === void 0 ? void 0 : courtIds.pop()) || (idPrefix && "".concat(idPrefix, "-").concat(i + 1));
        return addCourt({
            disableNotice: true,
            tournamentRecord: tournamentRecord,
            courtId: courtId,
            venueId: venueId,
            court: court,
        });
    });
    var courtRecords = mapResult
        .map(function (outcome) { return outcome.court; })
        .filter(Boolean);
    if (courtRecords.length !== courtsCount) {
        return decorateResult({
            info: 'not all courts could be generated',
            result: { error: INVALID_VALUES },
        });
    }
    if (venue)
        addNotice({
            payload: { venue: venue, tournamentId: tournamentRecord.tournamentId },
            topic: MODIFY_VENUE,
            key: venue.venueId,
        });
    return __assign(__assign({}, SUCCESS), { courts: makeDeepCopy(courtRecords) });
}

function generateVenues(_a) {
    var e_1, _b;
    var _c;
    var tournamentRecord = _a.tournamentRecord, venueProfiles = _a.venueProfiles, uuids = _a.uuids;
    var startDate = tournamentRecord.startDate, endDate = tournamentRecord.endDate;
    var venueIds = [];
    var _loop_1 = function (index, venueProfile) {
        var venueAbbreviation = venueProfile.venueAbbreviation, _g = venueProfile.venueId, venueId = _g === void 0 ? (_c = uuids === null || uuids === void 0 ? void 0 : uuids.pop()) !== null && _c !== void 0 ? _c : UUID() : _g, dateAvailability = venueProfile.dateAvailability, _h = venueProfile.startTime, startTime = _h === void 0 ? '07:00' : _h, _j = venueProfile.endTime, endTime = _j === void 0 ? '19:00' : _j, courtTimings = venueProfile.courtTimings, courtsCount = venueProfile.courtsCount, courtNames = venueProfile.courtNames, venueName = venueProfile.venueName, idPrefix = venueProfile.idPrefix, courtIds = venueProfile.courtIds;
        var newVenue = {
            venueName: venueName || "Venue ".concat(index + 1),
            venueAbbreviation: venueAbbreviation,
            venueId: venueId,
        };
        var result = addVenue({ tournamentRecord: tournamentRecord, venue: newVenue });
        if (result.error)
            return { value: result };
        venueIds.push(venueId);
        var dates = generateDateRange(startDate, endDate);
        var generatedDateAvailability = !Array.isArray(dateAvailability) &&
            [{ startTime: startTime, endTime: endTime }].concat(dates.map(function (date) { return ({
                date: formatDate(date),
                startTime: startTime,
                endTime: endTime,
            }); }));
        var addResult = addCourts({
            dateAvailability: dateAvailability || generatedDateAvailability,
            tournamentRecord: tournamentRecord,
            courtTimings: courtTimings,
            courtsCount: courtsCount,
            courtNames: courtNames,
            startTime: startTime,
            idPrefix: idPrefix,
            courtIds: courtIds,
            endTime: endTime,
            venueId: venueId,
            dates: dates,
        });
        if (addResult.error)
            return { value: addResult };
    };
    try {
        for (var _d = __values(venueProfiles.entries()), _e = _d.next(); !_e.done; _e = _d.next()) {
            var _f = __read(_e.value, 2), index = _f[0], venueProfile = _f[1];
            var state_1 = _loop_1(index, venueProfile);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return venueIds;
}

function getStageParticipantsCount(_a) {
    var drawProfiles = _a.drawProfiles, category = _a.category, gender = _a.gender;
    var uniqueParticipantsCount = {};
    var stageParticipantsCount = drawProfiles === null || drawProfiles === void 0 ? void 0 : drawProfiles.reduce(function (stageParticipantsCount, drawProfile) {
        var _a = drawProfile || {}, _b = _a.qualifyingPositions, qualifyingPositions = _b === void 0 ? 0 : _b, _c = _a.participantsCount, participantsCount = _c === void 0 ? 0 : _c, uniqueParticipants = _a.uniqueParticipants, _d = _a.stage, stage = _d === void 0 ? MAIN : _d, _e = _a.drawSize, drawSize = _e === void 0 ? 0 : _e;
        if (!Object.keys(stageParticipantsCount).includes(stage))
            stageParticipantsCount[stage] = 0;
        var stageCount = (participantsCount || drawSize) - qualifyingPositions;
        var requiresUniqueParticipants = uniqueParticipants || gender || category || stage === QUALIFYING;
        if (requiresUniqueParticipants) {
            if (!Object.keys(uniqueParticipantsCount).includes(stage))
                uniqueParticipantsCount[stage] = 0;
            uniqueParticipantsCount[stage] += stageCount;
        }
        else {
            stageParticipantsCount[stage] = Math.max(stageParticipantsCount[stage], stageCount);
        }
        return stageParticipantsCount;
    }, {});
    var uniqueParticipantStages = Object.keys(uniqueParticipantsCount);
    uniqueParticipantStages.forEach(function (stage) { return (stageParticipantsCount[stage] += uniqueParticipantsCount[stage]); });
    return {
        stageParticipantsCount: stageParticipantsCount,
        uniqueParticipantsCount: uniqueParticipantsCount,
        uniqueParticipantStages: uniqueParticipantStages,
    };
}

function getStageParticipants(_a) {
    var allUniqueParticipantIds = _a.allUniqueParticipantIds, stageParticipantsCount = _a.stageParticipantsCount, eventParticipantType = _a.eventParticipantType, targetParticipants = _a.targetParticipants;
    var mainParticipantsCount = stageParticipantsCount[MAIN] || 0;
    var qualifyingParticipantsCount = stageParticipantsCount[QUALIFYING] || 0;
    // this is only used for non-unique participants
    var stageParticipants = {
        QUALIFYING: targetParticipants
            .filter(function (_a) {
            var participantType = _a.participantType;
            return participantType === eventParticipantType;
        })
            .filter(function (_a) {
            var participantId = _a.participantId;
            return !allUniqueParticipantIds.includes(participantId);
        })
            .slice(0, qualifyingParticipantsCount),
        MAIN: targetParticipants
            .filter(function (_a) {
            var participantType = _a.participantType;
            return participantType === eventParticipantType;
        })
            .filter(function (_a) {
            var participantId = _a.participantId;
            return !allUniqueParticipantIds.includes(participantId);
        })
            .slice(qualifyingParticipantsCount, qualifyingParticipantsCount + mainParticipantsCount),
    };
    return { stageParticipants: stageParticipants };
}

function setParticipantScaleItem(params) {
    var removePriorValues = params.removePriorValues, tournamentRecord = params.tournamentRecord, participantId = params.participantId, scaleItem = params.scaleItem;
    var equivalentValue, participant;
    if (!isValidScaleItem({ scaleItem: scaleItem }))
        return { error: INVALID_SCALE_ITEM };
    if (participantId && Array.isArray(tournamentRecord.participants)) {
        participant = tournamentRecord.participants.find(function (participant) { return participant.participantId === participantId; });
        if (participant) {
            var result = addParticipantScaleItem({
                removePriorValues: removePriorValues,
                participant: participant,
                scaleItem: scaleItem,
            });
            if (result.error)
                return result;
            equivalentValue = !result.valueChanged;
            var topics = getTopics().topics;
            if (topics.includes(MODIFY_PARTICIPANTS)) {
                addNotice({
                    topic: MODIFY_PARTICIPANTS,
                    payload: {
                        tournamentId: tournamentRecord.tournamentId,
                        participants: [participant],
                    },
                });
            }
        }
    }
    return ((equivalentValue && __assign(__assign({}, SUCCESS), { info: VALUE_UNCHANGED, existingValue: scaleItem === null || scaleItem === void 0 ? void 0 : scaleItem.scaleValue })) ||
        (participant && __assign(__assign({}, SUCCESS), { newValue: scaleItem === null || scaleItem === void 0 ? void 0 : scaleItem.scaleValue })) || {
        error: PARTICIPANT_NOT_FOUND,
    });
}
function setParticipantScaleItems(params) {
    var e_1, _a, e_2, _b;
    var _c;
    var _d = params.scaleItemsWithParticipantIds, scaleItemsWithParticipantIds = _d === void 0 ? [] : _d, removePriorValues = params.removePriorValues, tournamentRecord = params.tournamentRecord, auditData = params.auditData, context = params.context;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!tournamentRecord.participants)
        return { error: MISSING_PARTICIPANTS };
    var modificationsApplied = 0;
    var participantScaleItemsMap = {};
    var modifiedParticipants = [];
    try {
        for (var scaleItemsWithParticipantIds_1 = __values(scaleItemsWithParticipantIds), scaleItemsWithParticipantIds_1_1 = scaleItemsWithParticipantIds_1.next(); !scaleItemsWithParticipantIds_1_1.done; scaleItemsWithParticipantIds_1_1 = scaleItemsWithParticipantIds_1.next()) {
            var item = scaleItemsWithParticipantIds_1_1.value;
            var participantId = item === null || item === void 0 ? void 0 : item.participantId;
            if (Array.isArray(item === null || item === void 0 ? void 0 : item.scaleItems)) {
                try {
                    for (var _e = (e_2 = void 0, __values(item.scaleItems)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var scaleItem = _f.value;
                        if (isValidScaleItem({ scaleItem: scaleItem })) {
                            if (!Array.isArray(participantScaleItemsMap[participantId])) {
                                participantScaleItemsMap[participantId] = [];
                            }
                            participantScaleItemsMap[participantId].push(scaleItem);
                        }
                        else {
                            return { error: INVALID_SCALE_ITEM };
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (scaleItemsWithParticipantIds_1_1 && !scaleItemsWithParticipantIds_1_1.done && (_a = scaleItemsWithParticipantIds_1.return)) _a.call(scaleItemsWithParticipantIds_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    tournamentRecord.participants.forEach(function (participant) {
        var participantId = (participant || {}).participantId;
        if (Array.isArray(participantScaleItemsMap[participantId])) {
            participantScaleItemsMap[participantId].forEach(function (scaleItem) {
                addParticipantScaleItem({ participant: participant, scaleItem: scaleItem, removePriorValues: removePriorValues });
                modifiedParticipants.push(participant);
                modificationsApplied++;
            });
        }
    });
    var info = !modificationsApplied ? NO_MODIFICATIONS_APPLIED : undefined;
    var topics = getTopics().topics;
    if (topics.includes(MODIFY_PARTICIPANTS) && modificationsApplied) {
        addNotice({
            topic: MODIFY_PARTICIPANTS,
            payload: {
                tournamentId: tournamentRecord.tournamentId,
                participants: modifiedParticipants,
            },
        });
    }
    if (context) {
        var eventId = context.eventId, drawId = context.drawId, itemValue = __rest(context, ["eventId", "drawId"]);
        var itemSubTypes = ((_c = itemValue.scaleAttributes) === null || _c === void 0 ? void 0 : _c.scaleType) && [itemValue.scaleAttributes.scaleType];
        if (Object.keys(itemValue).length) {
            var timeItem = {
                itemType: ADD_SCALE_ITEMS,
                itemValue: itemValue,
            };
            if (itemSubTypes)
                timeItem.itemSubTypes = itemSubTypes;
            if (drawId || eventId) {
                var _g = findEvent({
                    tournamentRecord: tournamentRecord,
                    eventId: eventId,
                    drawId: drawId,
                }), drawDefinition = _g.drawDefinition, event_1 = _g.event;
                if (drawId) {
                    addDrawDefinitionTimeItem({ drawDefinition: drawDefinition, timeItem: timeItem });
                }
                if (eventId) {
                    addEventTimeItem({ event: event_1, timeItem: timeItem });
                }
            }
            else {
                addTournamentTimeItem({ tournamentRecord: tournamentRecord, timeItem: timeItem });
            }
        }
    }
    if (auditData && topics.includes(AUDIT)) {
        addNotice({ topic: AUDIT, payload: auditData });
    }
    return definedAttributes(__assign(__assign({}, SUCCESS), { modificationsApplied: modificationsApplied, info: info }));
}
function isValidScaleItem(_a) {
    var scaleItem = _a.scaleItem;
    var scaleItemAttributes = scaleItem && Object.keys(scaleItem);
    var requiredAttributes = ['scaleType', 'eventType', 'scaleName'];
    var validScaleItem = requiredAttributes.filter(function (attribute) { return scaleItemAttributes === null || scaleItemAttributes === void 0 ? void 0 : scaleItemAttributes.includes(attribute); }).length ===
        requiredAttributes.length;
    return !!validScaleItem;
}
function addParticipantScaleItem(_a) {
    var removePriorValues = _a.removePriorValues, participant = _a.participant, scaleItem = _a.scaleItem;
    if (!participant) {
        return { error: MISSING_PARTICIPANT };
    }
    var scaleItemAttributes = scaleItem && Object.keys(scaleItem);
    var requiredAttributes = ['scaleType', 'eventType', 'scaleName'];
    var validScaleItem = requiredAttributes.filter(function (attribute) { return scaleItemAttributes.includes(attribute) && scaleItem[attribute]; }).length ===
        requiredAttributes.length;
    if (!validScaleItem)
        return { error: INVALID_SCALE_ITEM };
    var createdAt = new Date().toISOString();
    if (!participant.timeItems)
        participant.timeItems = [];
    var existingScaleItem = participantScaleItem({
        scaleAttributes: scaleItem,
        participant: participant,
    }).scaleItem;
    var isUndefined = function (value) { return [undefined, null, ''].includes(value); };
    var valueChanged = !(isUndefined(existingScaleItem === null || existingScaleItem === void 0 ? void 0 : existingScaleItem.scaleValue) && isUndefined(scaleItem.scaleValue)) &&
        JSON.stringify(existingScaleItem === null || existingScaleItem === void 0 ? void 0 : existingScaleItem.scaleValue) !== JSON.stringify(scaleItem.scaleValue);
    if (valueChanged) {
        var scaleType = scaleItem.scaleType, eventType = scaleItem.eventType, scaleName = scaleItem.scaleName;
        var itemType_1 = [SCALE$1, scaleType, eventType, scaleName].join('.');
        var timeItem = definedAttributes({
            itemValue: scaleItem.scaleValue,
            itemDate: scaleItem.scaleDate,
            createdAt: createdAt,
            itemType: itemType_1,
        });
        // if there is a unique identifier for the scale
        if (scaleItem.scaleId) {
            timeItem.itemSubTypes = [scaleItem.scaleId];
        }
        if (removePriorValues) {
            participant.timeItems = participant.timeItems.filter(function (timeItem) { return timeItem.itemType !== itemType_1; });
        }
        participant.timeItems.push(timeItem);
    }
    return __assign(__assign({}, SUCCESS), { valueChanged: valueChanged, newValue: scaleItem.scaleValue });
}

function getSetWinningSide(_a) {
    var matchUpScoringFormat = _a.matchUpScoringFormat, isDecidingSet = _a.isDecidingSet, isTiebreakSet = _a.isTiebreakSet, setObject = _a.setObject;
    if (!setObject)
        return undefined;
    var leadingSide = getLeadingSide$1({ set: setObject });
    var setIsComplete = checkSetIsComplete$1({
        matchUpScoringFormat: matchUpScoringFormat,
        isDecidingSet: isDecidingSet,
        isTiebreakSet: isTiebreakSet,
        set: setObject,
    });
    return (setIsComplete && leadingSide) || undefined;
}
function checkSetIsComplete$1(_a) {
    var _b = _a.ignoreTiebreak, ignoreTiebreak = _b === void 0 ? false : _b, matchUpScoringFormat = _a.matchUpScoringFormat, matchUpFormat = _a.matchUpFormat, isTiebreakSet = _a.isTiebreakSet, isDecidingSet = _a.isDecidingSet, set = _a.set;
    if (!set)
        return { error: MISSING_VALUE, info: 'missing set' };
    matchUpScoringFormat =
        matchUpScoringFormat || (matchUpFormat && parse(matchUpFormat));
    var setFormat = (isDecidingSet && matchUpScoringFormat.finalSetFormat) ||
        (matchUpScoringFormat === null || matchUpScoringFormat === void 0 ? void 0 : matchUpScoringFormat.setFormat) ||
        {};
    var side1Score = set.side1Score, side2Score = set.side2Score;
    var setTo = setFormat.setTo, tiebreakAt = setFormat.tiebreakAt, tiebreakFormat = setFormat.tiebreakFormat;
    var NoAD = tiebreakFormat === null || tiebreakFormat === void 0 ? void 0 : tiebreakFormat.NoAd;
    var leadingSide = getLeadingSide$1({ set: set });
    var scoreDiff = Math.abs(side1Score - side2Score);
    var containsSetTo = side1Score >= setTo || side2Score >= setTo;
    var requiresTiebreak = isTiebreakSet ||
        (side1Score >= setTo && side2Score >= setTo) ||
        (tiebreakAt &&
            tiebreakAt < setTo &&
            (side1Score === tiebreakAt || side2Score === tiebreakAt));
    var tiebreakIsValid = ignoreTiebreak ||
        (requiresTiebreak &&
            ((leadingSide === 1 && set.side1TiebreakScore > set.side2TiebreakScore) ||
                (leadingSide === 2 &&
                    set.side2TiebreakScore > set.side1TiebreakScore)));
    var winMargin = requiresTiebreak &&
        ((tiebreakAt && !isTiebreakSet) || (isTiebreakSet && NoAD))
        ? 1
        : 2;
    var hasWinMargin = scoreDiff >= winMargin;
    var validNormalSetScore = containsSetTo && (hasWinMargin || requiresTiebreak);
    return ((validNormalSetScore || isTiebreakSet) &&
        (!requiresTiebreak || tiebreakIsValid));
}
function getLeadingSide$1(_a) {
    var set = _a.set;
    if (set.side1Score || set.side2Score) {
        if (set.side1Score > set.side2Score)
            return 1;
        if (set.side2Score > set.side1Score)
            return 2;
    }
    else if (set.side1TiebreakScore || set.side2TiebreakScore) {
        if (set.side1TiebreakScore > set.side2TiebreakScore)
            return 1;
        if (set.side2TiebreakScore > set.side1TiebreakScore)
            return 2;
    }
    return undefined;
}

function analyzeSet(params) {
    var setObject = params.setObject, matchUpScoringFormat = params.matchUpScoringFormat;
    if (!setObject)
        return { error: MISSING_SET_OBJECT };
    var setNumber = (setObject || {}).setNumber;
    var bestOf = (matchUpScoringFormat || {}).bestOf;
    var isDecidingSet = !!(setNumber && bestOf && setNumber === bestOf);
    var setFormat = (isDecidingSet && (matchUpScoringFormat === null || matchUpScoringFormat === void 0 ? void 0 : matchUpScoringFormat.finalSetFormat)) ||
        (matchUpScoringFormat === null || matchUpScoringFormat === void 0 ? void 0 : matchUpScoringFormat.setFormat);
    var expectTiebreakSet = !!(setFormat === null || setFormat === void 0 ? void 0 : setFormat.tiebreakSet);
    var expectTimedSet = !!(setFormat === null || setFormat === void 0 ? void 0 : setFormat.timed);
    var expectStandardSet = !expectTiebreakSet && !expectTimedSet;
    var isValidSetNumber = !!(setNumber && bestOf && setNumber <= bestOf);
    var sideGameScores = [setObject === null || setObject === void 0 ? void 0 : setObject.side1Score, setObject === null || setObject === void 0 ? void 0 : setObject.side2Score];
    var sidePointScores = [
        setObject === null || setObject === void 0 ? void 0 : setObject.side1PointScore,
        setObject === null || setObject === void 0 ? void 0 : setObject.side2PointScore,
    ];
    var sideTiebreakScores = [
        setObject === null || setObject === void 0 ? void 0 : setObject.side1TiebreakScore,
        setObject === null || setObject === void 0 ? void 0 : setObject.side2TiebreakScore,
    ];
    var sideGameScoresCount = sideGameScores.filter(function (sideScore) { return sideScore !== undefined; }).length;
    var sidePointScoresCount = sidePointScores.filter(function (sideScore) { return sideScore !== undefined; }).length;
    var sideTiebreakScoresCount = sideTiebreakScores.filter(function (tiebreakScore) { return tiebreakScore !== undefined; }).length;
    var gameScoresCount = sideGameScores === null || sideGameScores === void 0 ? void 0 : sideGameScores.filter(function (s) { return !isNaN(s); }).length;
    var tiebreakScoresCount = sideTiebreakScores === null || sideTiebreakScores === void 0 ? void 0 : sideTiebreakScores.filter(function (s) { return !isNaN(s); }).length;
    var tiebreakAt = (setFormat || {}).tiebreakAt;
    var hasTiebreakCondition = tiebreakAt &&
        sideGameScores.filter(function (gameScore) { return gameScore >= tiebreakAt; }).length === 2;
    var leadingSide = hasTiebreakCondition &&
        ((sideGameScores[0] > sideGameScores[1] && 1) ||
            (sideGameScores[1] > sideGameScores[0] && 2) ||
            undefined);
    var isTiebreakSet = !!(tiebreakScoresCount && !gameScoresCount);
    var isCompletedSet = !!(setObject === null || setObject === void 0 ? void 0 : setObject.winningSide);
    var _a = checkValidStandardSetOutcome({
        setObject: setObject,
        setFormat: setFormat,
        sideGameScores: sideGameScores,
        sideTiebreakScores: sideTiebreakScores,
    }), standardSetError = _a.error, isValidStandardSetOutcome = _a.result;
    var _b = checkValidTiebreakSetOutcome({
        setObject: setObject,
        setFormat: setFormat,
        sideTiebreakScores: sideTiebreakScores,
    }), tiebreakSetError = _b.error, isValidTiebreakSetOutcome = _b.result;
    var isValidSetOutcome = (expectStandardSet && !isTiebreakSet && isValidStandardSetOutcome) ||
        (expectTiebreakSet && isTiebreakSet && isValidTiebreakSetOutcome);
    var isValidSet = isValidSetNumber &&
        !(expectTiebreakSet && !isTiebreakSet) &&
        !(expectStandardSet && isTiebreakSet) &&
        (!isCompletedSet || isValidSetOutcome);
    var winningSide = getSetWinningSide({
        isDecidingSet: isDecidingSet,
        isTiebreakSet: isTiebreakSet,
        matchUpScoringFormat: matchUpScoringFormat,
        setObject: setObject,
    });
    var analysis = {
        expectTiebreakSet: expectTiebreakSet,
        expectTimedSet: expectTimedSet,
        hasTiebreakCondition: hasTiebreakCondition,
        isCompletedSet: isCompletedSet,
        isDecidingSet: isDecidingSet,
        isTiebreakSet: isTiebreakSet,
        isValidSet: isValidSet,
        isValidSetNumber: isValidSetNumber,
        isValidSetOutcome: isValidSetOutcome,
        leadingSide: leadingSide,
        setFormat: setFormat,
        sideGameScores: sideGameScores,
        sideGameScoresCount: sideGameScoresCount,
        sidePointScores: sidePointScores,
        sidePointScoresCount: sidePointScoresCount,
        sideTiebreakScores: sideTiebreakScores,
        sideTiebreakScoresCount: sideTiebreakScoresCount,
        winningSide: winningSide,
    };
    if ((setObject === null || setObject === void 0 ? void 0 : setObject.winningSide) !== undefined) {
        if (isTiebreakSet) {
            analysis.isValidTiebreakSetOutcome = isValidTiebreakSetOutcome;
            if (!isValidTiebreakSetOutcome) {
                analysis.tiebreakSetError = tiebreakSetError;
            }
        }
        else {
            analysis.isValidStandardSetOutcome = isValidStandardSetOutcome;
            if (!isValidStandardSetOutcome) {
                analysis.standardSetError = standardSetError;
            }
        }
    }
    return analysis;
}
function checkValidStandardSetOutcome(_a) {
    var setObject = _a.setObject, setFormat = _a.setFormat, sideGameScores = _a.sideGameScores, sideTiebreakScores = _a.sideTiebreakScores;
    if (!setObject) {
        return { result: false, error: MISSING_SET_OBJECT };
    }
    var expectTiebreakSet = !!(setFormat === null || setFormat === void 0 ? void 0 : setFormat.tiebreakSet);
    var expectTimedSet = !!(setFormat === null || setFormat === void 0 ? void 0 : setFormat.timed);
    if (!setFormat || expectTiebreakSet || expectTimedSet) {
        return { result: false, error: INVALID_VALUES };
    }
    var validGameScores = (sideGameScores === null || sideGameScores === void 0 ? void 0 : sideGameScores.filter(function (s) { return !isNaN(s); }).length) === 2;
    if (!validGameScores)
        return { result: false, error: INVALID_GAME_SCORES };
    var _b = setFormat || {}, setTo = _b.setTo, tiebreakAt = _b.tiebreakAt, tiebreakFormat = _b.tiebreakFormat, NoAD = _b.NoAD;
    var meetsSetTo = !!(setTo && (sideGameScores === null || sideGameScores === void 0 ? void 0 : sideGameScores.find(function (gameScore) { return gameScore >= setTo; })));
    if (!meetsSetTo)
        return { result: false, error: INVALID_GAME_SCORES };
    var isValidWinningSide = [1, 2].includes(setObject === null || setObject === void 0 ? void 0 : setObject.winningSide);
    if (!setObject || !isValidWinningSide)
        return { result: false, error: INVALID_WINNING_SIDE };
    var winningSideIndex = (setObject === null || setObject === void 0 ? void 0 : setObject.winningSide) - 1;
    var losingSideIndex = 1 - winningSideIndex;
    var winningSideGameScore = sideGameScores[winningSideIndex];
    var losingSideGameScore = sideGameScores[losingSideIndex];
    var gamesDifference = winningSideGameScore - losingSideGameScore;
    var winningSideIsHighGameValue = winningSideGameScore > losingSideGameScore;
    if (!winningSideIsHighGameValue) {
        return {
            result: false,
            error: { message: 'winningSide game scoreString is not high' },
        };
    }
    var setTiebreakDefined = tiebreakAt && tiebreakFormat;
    var validTiebreakScores = (sideTiebreakScores === null || sideTiebreakScores === void 0 ? void 0 : sideTiebreakScores.filter(function (s) { return !isNaN(s); }).length) === 2;
    var winningSideTiebreakScore = sideTiebreakScores === null || sideTiebreakScores === void 0 ? void 0 : sideTiebreakScores[winningSideIndex];
    var losingSideTiebreakScore = sideTiebreakScores === null || sideTiebreakScores === void 0 ? void 0 : sideTiebreakScores[losingSideIndex];
    var hasTiebreakCondition = tiebreakAt &&
        sideGameScores.filter(function (gameScore) { return gameScore >= tiebreakAt; }).length === 2;
    if (setTiebreakDefined) {
        var tiebreakNoAD = tiebreakFormat.NoAD, tiebreakTo_1 = tiebreakFormat.tiebreakTo;
        if (hasTiebreakCondition) {
            if (gamesDifference > 1) {
                return {
                    result: false,
                    error: { message: 'invalid winning game scoreString (5)' },
                };
            }
            if (!validTiebreakScores) {
                return {
                    result: false,
                    error: { message: 'invalid tiebreak scores (1)' },
                };
            }
            if (isNaN(tiebreakTo_1)) {
                return { result: false, error: { message: 'tiebreakTo error' } }; // TODO: test this
            }
            var meetsTiebreakTo = !!(tiebreakTo_1 &&
                (sideTiebreakScores === null || sideTiebreakScores === void 0 ? void 0 : sideTiebreakScores.find(function (tiebreakScore) { return tiebreakScore >= tiebreakTo_1; })));
            if (!meetsTiebreakTo) {
                return {
                    result: false,
                    error: { message: 'invalid tiebreak scores (2)' },
                };
            }
            var maxGameScore = tiebreakAt < setTo ? setTo : setTo + 1;
            if (winningSideGameScore > maxGameScore) {
                return {
                    result: false,
                    error: { message: 'invalid winning game scoreString (1)' },
                };
            }
            if (!winningSideTiebreakScore ||
                !losingSideTiebreakScore ||
                winningSideTiebreakScore < losingSideTiebreakScore) {
                return {
                    result: false,
                    error: { message: 'winningSide tiebreak value is not high' },
                };
            }
            var minimumTiebreakWinMargin = tiebreakNoAD ? 1 : 2;
            var tiebreakDifference = winningSideTiebreakScore - losingSideTiebreakScore;
            var losingSideGameScoreAtTiebreakToThreshold = losingSideTiebreakScore >= tiebreakTo_1 - 1;
            var invalidTiebreakScore = tiebreakDifference &&
                losingSideGameScoreAtTiebreakToThreshold &&
                tiebreakDifference < minimumTiebreakWinMargin;
            if (invalidTiebreakScore) {
                return {
                    result: false,
                    error: { message: 'invalid tiebreak scores (3)' },
                };
            }
        }
        var hasTiebreakGameScore = winningSideGameScore > setTo;
        if (hasTiebreakGameScore && !hasTiebreakCondition) {
            return {
                result: false,
                error: { message: 'invalid winning game scoreString (2)' },
            };
        }
    }
    var minimumGamesWinMargin = NoAD ? 1 : 2;
    var losingSideGameScoreAtSetToThreshold = losingSideGameScore >= setTo - 1;
    var invalidWinningScore = gamesDifference &&
        losingSideGameScoreAtSetToThreshold &&
        !hasTiebreakCondition &&
        gamesDifference < minimumGamesWinMargin;
    if (invalidWinningScore) {
        return {
            result: false,
            error: { message: 'invalid winning game scoreString (3)' },
        };
    }
    if (gamesDifference > minimumGamesWinMargin && winningSideGameScore > setTo) {
        return {
            result: false,
            error: { message: 'invalid winning game scoreString (4)' },
        };
    }
    return { result: true };
}
function checkValidTiebreakSetOutcome(_a) {
    var setObject = _a.setObject, setFormat = _a.setFormat, sideTiebreakScores = _a.sideTiebreakScores;
    if (!setObject) {
        return { result: false, error: MISSING_SET_OBJECT };
    }
    var expectTiebreakSet = !!(setFormat === null || setFormat === void 0 ? void 0 : setFormat.tiebreakSet);
    var expectTimedSet = !!(setFormat === null || setFormat === void 0 ? void 0 : setFormat.timed);
    if (!setFormat || !expectTiebreakSet || expectTimedSet) {
        return { result: false, error: { message: 'not tiebreak set' } };
    }
    var isValidWinningSide = [1, 2].includes(setObject === null || setObject === void 0 ? void 0 : setObject.winningSide);
    if (!setObject || !isValidWinningSide)
        return { result: false, error: INVALID_WINNING_SIDE };
    var tiebreakSet = (setFormat || {}).tiebreakSet;
    var _b = tiebreakSet || {}, NoAD = _b.NoAD, tiebreakTo = _b.tiebreakTo;
    var validTiebreakScores = (sideTiebreakScores === null || sideTiebreakScores === void 0 ? void 0 : sideTiebreakScores.filter(function (s) { return !isNaN(s); }).length) === 2;
    if (!validTiebreakScores) {
        return { result: false, error: { message: 'invalid tiebreak scores (1)' } };
    }
    if (isNaN(tiebreakTo)) {
        return { result: false, error: { message: 'tiebreakTo error' } }; // TODO: test this
    }
    var meetsTiebreakTo = !!(sideTiebreakScores === null || sideTiebreakScores === void 0 ? void 0 : sideTiebreakScores.find(function (tiebreakScore) { return tiebreakScore >= tiebreakTo; }));
    if (!meetsTiebreakTo) {
        return { result: false, error: { message: 'invalid tiebreak scores (2)' } };
    }
    var winningSideIndex = (setObject === null || setObject === void 0 ? void 0 : setObject.winningSide) - 1;
    var losingSideIndex = 1 - winningSideIndex;
    var winningSideTiebreakScore = sideTiebreakScores[winningSideIndex];
    var losingSideTiebreakScore = sideTiebreakScores[losingSideIndex];
    if (!winningSideTiebreakScore ||
        !losingSideTiebreakScore ||
        winningSideTiebreakScore < losingSideTiebreakScore) {
        return {
            result: false,
            error: { message: 'winningSide tiebreak value is not high' },
        };
    }
    var minimumTiebreakWinMargin = NoAD ? 1 : 2;
    var tiebreakDifference = winningSideTiebreakScore - losingSideTiebreakScore;
    var losingSideGameScoreAtTiebreakToThreshold = losingSideTiebreakScore >= tiebreakTo - 1;
    var invalidTiebreakScore = tiebreakDifference &&
        losingSideGameScoreAtTiebreakToThreshold &&
        tiebreakDifference < minimumTiebreakWinMargin;
    if (invalidTiebreakScore) {
        return { result: false, error: { message: 'invalid tiebreak scores (3)' } };
    }
    return { result: true };
}

// TODO: what about checking array of sets are in order? ( setNumber )
function analyzeMatchUp(params) {
    var _a;
    var _b = params || {}, matchUp = _b.matchUp, sideNumber = _b.sideNumber, setNumber = _b.setNumber, isTiebreakValue = _b.isTiebreakValue, isPointValue = _b.isPointValue;
    var matchUpFormat = (params || {}).matchUpFormat;
    if (!matchUp)
        return { error: MISSING_MATCHUP };
    matchUpFormat = matchUpFormat || (matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpFormat);
    var matchUpScoringFormat = parse(matchUpFormat);
    var isCompletedMatchUp = !!(matchUp === null || matchUp === void 0 ? void 0 : matchUp.winningSide);
    var sets = (_a = matchUp.score) === null || _a === void 0 ? void 0 : _a.sets;
    var setsCount = sets === null || sets === void 0 ? void 0 : sets.length;
    var setIndex = setNumber && setNumber - 1;
    var isExistingSet = !!(sets === null || sets === void 0 ? void 0 : sets.find(function (set, index) { return set.setNumber === setNumber && index === setIndex; }));
    var completedSets = (sets === null || sets === void 0 ? void 0 : sets.filter(function (set) { return set === null || set === void 0 ? void 0 : set.winningSide; })) || [];
    var completedSetsCount = (completedSets === null || completedSets === void 0 ? void 0 : completedSets.length) || 0;
    var setsFollowingCurrent = (setNumber && (sets === null || sets === void 0 ? void 0 : sets.slice(setNumber))) || [];
    var isLastSetWithValues = !!(setsCount &&
        setNumber &&
        (
        // EVERY: is this a candidate for .every?
        setsFollowingCurrent === null || setsFollowingCurrent === void 0 ? void 0 : setsFollowingCurrent.reduce(function (noValues, set) {
            return ((!set ||
                (!set.side1Score &&
                    !set.side2Score &&
                    !set.side1TiebreakScore &&
                    !set.side2TiebreakScore &&
                    !set.side1PointScore &&
                    !set.side2PointScore)) &&
                noValues);
        }, true)));
    var setObject = setNumber <= setsCount && sets.find(function (set) { return set.setNumber === setNumber; });
    var specifiedSetAnalysis = setObject && analyzeSet({ setObject: setObject, matchUpScoringFormat: matchUpScoringFormat });
    var _c = specifiedSetAnalysis || {}, isCompletedSet = _c.isCompletedSet, sideGameScores = _c.sideGameScores, 
    // sidePointScores,
    sideTiebreakScores = _c.sideTiebreakScores;
    var isActiveSet = !!((setObject && !isCompletedSet && isLastSetWithValues) ||
        (setNumber && setNumber === setsCount + 1 && !isCompletedMatchUp));
    var isValidSideNumber = [1, 2].includes(sideNumber);
    var sideIndex = isValidSideNumber ? sideNumber - 1 : 0;
    var existingValue = setObject &&
        isValidSideNumber &&
        ((!isTiebreakValue && !isPointValue && sideGameScores[sideIndex] !== undefined && sideGameScores[sideIndex]) ||
            (isTiebreakValue && sideTiebreakScores[sideIndex] !== undefined && sideTiebreakScores[sideIndex]));
    var hasExistingValue = !!existingValue;
    var completedSetsHaveValidOutcomes = completedSets === null || completedSets === void 0 ? void 0 : completedSets.map(function (setObject) { return analyzeSet({ setObject: setObject, matchUpScoringFormat: matchUpScoringFormat }).isValidSetOutcome; }).reduce(function (valid, validOutcome) { return valid && validOutcome; }, true);
    var setsWinCounts = completedSets.reduce(function (counts, set) {
        var winningSide = set.winningSide;
        var winningSideIndex = winningSide - 1;
        counts[winningSideIndex]++;
        return counts;
    }, [0, 0]);
    var matchUpWinningSide = matchUp === null || matchUp === void 0 ? void 0 : matchUp.winningSide;
    var matchUpWinningSideIndex = matchUpWinningSide && matchUpWinningSide - 1;
    var matchUpLosingSideIndex = 1 - matchUpWinningSideIndex;
    var winningSideSetsCount = setsWinCounts[matchUpWinningSideIndex];
    var losingSideSetsCount = setsWinCounts[matchUpLosingSideIndex];
    var maxSetsCount = Math.max.apply(Math, __spreadArray([], __read(setsWinCounts), false));
    var maxSetsInstances = instanceCount(setsWinCounts)[maxSetsCount];
    var bestOf = (matchUpScoringFormat !== null && matchUpScoringFormat !== void 0 ? matchUpScoringFormat : {}).bestOf;
    var setsToWin = (bestOf && Math.ceil(bestOf / 2)) || 1;
    var calculatedWinningSide = (maxSetsCount === setsToWin && maxSetsInstances === 1 && setsWinCounts.indexOf(maxSetsCount) + 1) || undefined;
    var validMatchUpWinningSide = winningSideSetsCount > losingSideSetsCount && matchUpWinningSide === calculatedWinningSide;
    var validMatchUpOutcome = calculatedWinningSide && completedSetsHaveValidOutcomes && validMatchUpWinningSide;
    return __assign({ completedSetsHaveValidOutcomes: completedSetsHaveValidOutcomes, validMatchUpWinningSide: validMatchUpWinningSide, calculatedWinningSide: calculatedWinningSide, matchUpScoringFormat: matchUpScoringFormat, validMatchUpOutcome: validMatchUpOutcome, isLastSetWithValues: isLastSetWithValues, completedSetsCount: completedSetsCount, isCompletedMatchUp: isCompletedMatchUp, isValidSideNumber: isValidSideNumber, hasExistingValue: hasExistingValue, existingValue: existingValue, isExistingSet: isExistingSet, isActiveSet: isActiveSet }, specifiedSetAnalysis);
}

var _a$b;
// percentages rounded to the nearest whole number
var defaultStatusProfile = (_a$b = {},
    _a$b[WALKOVER$2] = 2,
    _a$b[DOUBLE_WALKOVER] = 1,
    _a$b[DOUBLE_DEFAULT] = 1,
    _a$b[RETIRED$1] = 1,
    _a$b[DEFAULTED] = 4,
    _a$b);
// TODO: timed sets && NoAd
/**
 *
 * @param {string} matchUpFormat - optional - TODS matchUpFormat code string - defaults to 'SET3-S:6/TB7'
 * @param {object} matchUpStatusProfile - optional - whole number percent for each target matchUpStatus { [matchUpStatus]: percentLikelihood }
 * @param {integer} pointsPerMinute - optional - value used for generating timed sets scores
 * @param {integer} sideWeight - optional - the larger the number the less likely a deciding (e.g. 3rd) set is generated
 * @param {integer} winningSide - optional - 1 or 2 forces the winningSide
 * @param {integer} defaultWithScorePercent - optional - percentage of the time a DEFAULT should include a score
 *
 * @returns {object} outcome - { score, winningSide, matchUpStatus }
 */
function generateOutcome(params) {
    var e_1, _a;
    var _b;
    var _c = params.defaultWithScorePercent, defaultWithScorePercent = _c === void 0 ? 2 : _c, winningSide = params.winningSide;
    var _d = params.matchUpStatusProfile, matchUpStatusProfile = _d === void 0 ? defaultStatusProfile : _d, // { matchUpStatusProfile: {} } will always return only { matchUpStatus: COMPLETED }
    _e = params.matchUpFormat, // { matchUpStatusProfile: {} } will always return only { matchUpStatus: COMPLETED }
    matchUpFormat = _e === void 0 ? FORMAT_STANDARD : _e, _f = params.pointsPerMinute, pointsPerMinute = _f === void 0 ? 1 : _f, _g = params.sideWeight, sideWeight = _g === void 0 ? 4 : _g;
    if (!isValidMatchUpFormat({ matchUpFormat: matchUpFormat }))
        return { error: INVALID_MATCHUP_FORMAT };
    if (typeof matchUpStatusProfile !== 'object')
        return { error: INVALID_VALUES };
    if (defaultWithScorePercent > 100)
        defaultWithScorePercent = 100;
    if (isNaN(defaultWithScorePercent) ||
        isNaN(pointsPerMinute) ||
        isNaN(sideWeight))
        return { error: INVALID_VALUES };
    var matchUpStatuses = Object.keys(matchUpStatusProfile).filter(function (matchUpStatus) {
        return Object.keys(matchUpStatusConstants).includes(matchUpStatus) &&
            matchUpStatus !== COMPLETED$1;
    });
    var matchUpStatusTotals = Object.keys(matchUpStatuses).reduce(function (total, key) { return total + matchUpStatusProfile[key]; }, 0);
    if (matchUpStatusTotals > 100)
        return { error: INVALID_VALUES, matchUpStatusProfile: matchUpStatusProfile };
    var matchUpStatusMap = matchUpStatuses.reduce(function (statusMap, matchUpStatus) {
        statusMap.pointer =
            statusMap.pointer + matchUpStatusProfile[matchUpStatus];
        statusMap.valueMap.push([statusMap.pointer, matchUpStatus]);
        return statusMap;
    }, { pointer: 0, valueMap: [] });
    var outcomePointer = randomInt(1, 100);
    var matchUpStatus = ((_b = matchUpStatusMap.valueMap.find(function (item) { return outcomePointer <= item[0]; })) !== null && _b !== void 0 ? _b : [100, COMPLETED$1])[1];
    var noScore = { sets: [], scoreStringSide1: '', side2ScoreString: '' };
    if ([WALKOVER$2, DEFAULTED].includes(matchUpStatus)) {
        winningSide = winningSide || randomInt(1, 2);
        var outcome_1 = {
            score: noScore,
            winningSide: winningSide,
            matchUpStatus: matchUpStatus,
        };
        var scoreDefaulted = matchUpStatus === DEFAULTED &&
            randomInt(1, 100) > 100 - defaultWithScorePercent;
        if (!scoreDefaulted)
            return { outcome: outcome_1 };
    }
    else if ([DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUpStatus)) {
        return { outcome: { score: noScore, matchUpStatus: matchUpStatus } };
    }
    var parsedFormat = parse(matchUpFormat);
    var _h = parsedFormat !== null && parsedFormat !== void 0 ? parsedFormat : {}, bestOf = _h.bestOf, setFormat = _h.setFormat, finalSetFormat = _h.finalSetFormat;
    var sets = [];
    var weightedSide = randomInt(0, 1);
    var weightedRange = winningSide
        ? [winningSide - 1]
        : __spreadArray(__spreadArray([], __read(generateRange(0, sideWeight).map(function () { return weightedSide; })), false), [
            1 - weightedSide,
        ], false);
    var incompleteSet = [RETIRED$1, DEFAULTED, INCOMPLETE, SUSPENDED].includes(matchUpStatus);
    // if there is to be an incomplete set randomize which set is incomplete
    // for 3 sets this will always be setNumber 1 or setNumber 2
    // because it is not known in advance whether 3 sets will be generated
    var incompleteAt = incompleteSet && (randomPop(generateRange(1, bestOf)) || 1);
    // used to capture winner by RETIREMENT or DEFAULT
    var weightedWinningSide;
    try {
        for (var _j = __values(generateRange(1, (bestOf !== null && bestOf !== void 0 ? bestOf : 0) + 1)), _k = _j.next(); !_k.done; _k = _j.next()) {
            var setNumber = _k.value;
            var isFinalSet = setNumber === bestOf;
            var _l = generateSet({
                incomplete: incompleteAt === setNumber,
                matchUpStatus: matchUpStatus,
                pointsPerMinute: pointsPerMinute,
                setFormat: (isFinalSet && finalSetFormat) || setFormat,
                setNumber: setNumber,
                weightedRange: weightedRange,
            }), set = _l.set, incomplete = _l.incomplete, winningSideNumber = _l.winningSideNumber;
            sets.push(set);
            if (incomplete) {
                weightedWinningSide = winningSideNumber;
                break;
            }
            var analysis_1 = analyzeMatchUp({
                matchUp: { score: { sets: sets }, matchUpFormat: matchUpFormat },
            });
            if (analysis_1.calculatedWinningSide)
                break;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_k && !_k.done && (_a = _j.return)) _a.call(_j);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var analysis = analyzeMatchUp({
        matchUp: { score: { sets: sets }, matchUpFormat: matchUpFormat },
    });
    var matchUpWinningSide = weightedWinningSide
        ? winningSide || weightedWinningSide
        : analysis.calculatedWinningSide;
    // add the side perspective stringScores
    var score = matchUpScore({
        score: { sets: sets },
        winningSide: matchUpWinningSide,
        matchUpStatus: matchUpStatus,
    }).score;
    var outcome = {
        score: score,
        winningSide: matchUpWinningSide,
        matchUpStatus: matchUpStatus,
    };
    return { outcome: outcome };
}
/**
 *
 * @param {integer} setNumber
 * @param {object} setFormat
 * @param {integer[]} weightedRange - weights one side to reduce the number of "deciding sets", e.g. 3 set matchUps
 * @returns
 */
function generateSet(_a) {
    var _b, _c, _d;
    var _e = _a.weightedRange, weightedRange = _e === void 0 ? [0, 1] : _e, pointsPerMinute = _a.pointsPerMinute, matchUpStatus = _a.matchUpStatus, incomplete = _a.incomplete, setFormat = _a.setFormat, setNumber = _a.setNumber;
    var set = { setNumber: setNumber };
    var setTo = setFormat.setTo, tiebreakFormat = setFormat.tiebreakFormat, tiebreakAt = setFormat.tiebreakAt, tiebreakSet = setFormat.tiebreakSet, timed = setFormat.timed, minutes = setFormat.minutes;
    // will tend to be more likely to either reverse or not revderse all sets
    // preserves randomness of winningSide while reducing deciding set outcomes
    var weightIndex = randomInt(0, weightedRange.length - 1);
    var reverseScores = weightedRange[weightIndex];
    var winningSideNumber;
    if (timed) {
        var calcPoints = minutes * pointsPerMinute;
        var pointsVariation = Math.round(calcPoints * 0.2);
        var totalPoints = calcPoints + randomPop([1, -1]) * pointsVariation;
        // the use of weightedRandom applies a bell curve distribution to the difference in side scores
        // the larger the second value, the more pronounced the bell curve will be
        var sidePoints = weightedRandom(totalPoints, 2);
        var scores = [sidePoints, totalPoints - sidePoints];
        if (reverseScores)
            scores.reverse();
        winningSideNumber = weightedRange[weightIndex] + 1;
        // sides could be tied
        var highSide = (scores[0] > scores[1] && 1) || (scores[1] > scores[0] && 2) || 0;
        if (incomplete) {
            var _f = __read(scores, 2), side1Score_1 = _f[0], side2Score_1 = _f[1];
            Object.assign(set, { side1Score: side1Score_1, side2Score: side2Score_1 });
            if (completedMatchUpStatuses.includes(matchUpStatus)) {
                return { set: set, incomplete: incomplete, winningSideNumber: winningSideNumber };
            }
            return { set: set, incomplete: incomplete };
        }
        if (!highSide)
            scores[randomInt(0, 1)] += 1;
        highSide = scores[0] > scores[1] ? 1 : 2; // sides are not tied
        if (highSide !== winningSideNumber)
            scores.reverse();
        var _g = __read(scores, 2), side1Score = _g[0], side2Score = _g[1];
        Object.assign(set, {
            side1Score: side1Score,
            side2Score: side2Score,
            winningSide: winningSideNumber,
        });
        return { set: set };
    }
    else if (incomplete) {
        set.side1Score = randomInt(0, tiebreakAt);
        set.side2Score = randomInt(0, tiebreakAt);
        if (completedMatchUpStatuses.includes(matchUpStatus)) {
            winningSideNumber = weightedRange[weightIndex] + 1;
        }
        return { set: set, incomplete: incomplete, winningSideNumber: winningSideNumber };
    }
    else {
        // weight the range of possible low scores such that tiebreak sets are less likely
        var range = generateRange(1, setTo + 1)
            .map(function (value) { return generateRange(0, setTo + 2 - value).map(function () { return value; }); })
            .flat();
        var lowValue = range[randomInt(0, range.length - 1)];
        var scores = setTo &&
            getSetComplement({
                isSide1: true,
                tiebreakAt: tiebreakAt,
                lowValue: lowValue,
                setTo: setTo,
            });
        var isTiebreakSet = !scores;
        var specifiedWinningSide = weightedRange.length === 1 && weightedRange[weightIndex] + 1;
        if (!isTiebreakSet) {
            if (specifiedWinningSide) {
                var highSide = scores[0] > scores[1] ? 1 : 2; // sides are not tied
                if (highSide !== specifiedWinningSide)
                    scores.reverse();
            }
            else if (reverseScores) {
                scores.reverse();
            }
            var _h = __read(scores, 2), side1Score = _h[0], side2Score = _h[1];
            Object.assign(set, { side1Score: side1Score, side2Score: side2Score });
        }
        var setAnalysis = analyzeSet({
            matchUpScoringFormat: { setFormat: setFormat },
            setObject: set,
        });
        var tiebreakWinningSide = void 0;
        if (setAnalysis.hasTiebreakCondition || isTiebreakSet) {
            var _j = tiebreakFormat || tiebreakSet || {}, tiebreakNoAd = _j.NoAD, tiebreakTo_1 = _j.tiebreakTo;
            var range_1 = generateRange(1, tiebreakTo_1 + 1)
                .map(function (value) {
                return generateRange(0, tiebreakTo_1 + 2 - value).map(function () { return value; });
            })
                .flat();
            var lowValue_1 = range_1[randomInt(0, range_1.length - 1)];
            var scores_1 = getTiebreakComplement({
                isSide1: true,
                tiebreakNoAd: tiebreakNoAd,
                tiebreakTo: tiebreakTo_1,
                lowValue: lowValue_1,
            });
            if (scores_1) {
                if (isTiebreakSet) {
                    var highSide = scores_1[0] > scores_1[1] ? 1 : 2; // sides are not tied
                    if (specifiedWinningSide) {
                        if (highSide !== specifiedWinningSide)
                            scores_1.reverse();
                    }
                    else if (reverseScores) {
                        scores_1.reverse();
                    }
                    _b = __read(scores_1, 2), set.side1TiebreakScore = _b[0], set.side2TiebreakScore = _b[1];
                    tiebreakWinningSide =
                        (scores_1[0] > scores_1[1] && 1) ||
                            (scores_1[1] > scores_1[0] && 2) ||
                            undefined;
                }
                else if (setAnalysis.leadingSide === 2) {
                    _c = __read(scores_1, 2), set.side1TiebreakScore = _c[0], set.side2TiebreakScore = _c[1];
                }
                else {
                    _d = __read(scores_1, 2), set.side2TiebreakScore = _d[0], set.side1TiebreakScore = _d[1];
                }
            }
        }
        set.winningSide =
            setAnalysis.winningSide ||
                setAnalysis.leadingSide ||
                specifiedWinningSide ||
                tiebreakWinningSide;
    }
    return { set: set };
}

function completeDrawMatchUps(params) {
    var e_1, _a, e_2, _b;
    var _c, _d, _e;
    var matchUpStatusProfile = params.matchUpStatusProfile, // { matchUpStatusProfile: {} } will always return only { matchUpStatus: COMPLETED }
    completeAllMatchUps = params.completeAllMatchUps, 
    // qualifyingProfiles, // CONSIDER: allowing completionGoal per structureProfile
    randomWinningSide = params.randomWinningSide, tournamentRecord = params.tournamentRecord, completionGoal = params.completionGoal, drawDefinition = params.drawDefinition, event = params.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var matchUpFormat = params.matchUpFormat || drawDefinition.matchUpFormat || (event === null || event === void 0 ? void 0 : event.matchUpFormat);
    var sortedStructures = drawDefinition.structures.slice().sort(structureSort);
    var completedCount = 0;
    var _f = getAllDrawMatchUps({
        contextFilters: {
            stages: [MAIN, QUALIFYING],
        },
        matchUpFilters: {
            matchUpTypes: [TEAM],
            roundNumbers: [1],
        },
        inContext: true,
        drawDefinition: drawDefinition,
    }), firstRoundDualMatchUps = _f.matchUps, matchUpsMap = _f.matchUpsMap;
    if (firstRoundDualMatchUps === null || firstRoundDualMatchUps === void 0 ? void 0 : firstRoundDualMatchUps.length) {
        var categoryName = ((_c = event === null || event === void 0 ? void 0 : event.category) === null || _c === void 0 ? void 0 : _c.ageCategoryCode) || ((_d = event === null || event === void 0 ? void 0 : event.category) === null || _d === void 0 ? void 0 : _d.categoryName);
        if (categoryName) {
            var scaleAccessor = {
                scaleName: categoryName,
                sortOrder: ASCENDING,
                scaleType: RANKING$1,
            };
            var result = generateLineUps({
                singlesOnly: true,
                tournamentRecord: tournamentRecord,
                drawDefinition: drawDefinition,
                scaleAccessor: scaleAccessor,
                event: event,
            });
            if (result.error)
                return result;
            var lineUps = result.lineUps, participantsToAdd = result.participantsToAdd;
            addParticipants({ tournamentRecord: tournamentRecord, participants: participantsToAdd });
            var extension = { name: LINEUPS, value: lineUps };
            addExtension({ element: drawDefinition, extension: extension });
        }
        else {
            var structureId = (_e = firstRoundDualMatchUps[0]) === null || _e === void 0 ? void 0 : _e.structureId;
            var positionAssignments_1 = getPositionAssignments$1({
                drawDefinition: drawDefinition,
                structureId: structureId,
            }).positionAssignments;
            if (positionAssignments_1 === null || positionAssignments_1 === void 0 ? void 0 : positionAssignments_1.length) {
                var teamParticipants_1 = getParticipants({
                    participantFilters: { participantTypes: [TEAM] },
                    tournamentRecord: tournamentRecord,
                }).participants;
                var assignParticipants = function (dualMatchUp) {
                    var singlesMatchUps = dualMatchUp.tieMatchUps.filter(function (_a) {
                        var matchUpType = _a.matchUpType;
                        return matchUpType === SINGLES;
                    });
                    var doublesMatchUps = dualMatchUp.tieMatchUps.filter(function (_a) {
                        var matchUpType = _a.matchUpType;
                        return matchUpType === DOUBLES;
                    });
                    singlesMatchUps.forEach(function (singlesMatchUp, i) {
                        var tieMatchUpId = singlesMatchUp.matchUpId;
                        singlesMatchUp.sides.forEach(function (side) {
                            var _a;
                            var drawPosition = side.drawPosition;
                            var teamParticipant = teamParticipants_1 === null || teamParticipants_1 === void 0 ? void 0 : teamParticipants_1.find(function (teamParticipant) {
                                var participantId = teamParticipant.participantId;
                                var assignment = positionAssignments_1.find(function (assignment) { return assignment.participantId === participantId; });
                                return (assignment === null || assignment === void 0 ? void 0 : assignment.drawPosition) === drawPosition;
                            });
                            if (teamParticipant) {
                                var individualParticipantId = (_a = teamParticipant.individualParticipantIds) === null || _a === void 0 ? void 0 : _a[i];
                                individualParticipantId &&
                                    assignTieMatchUpParticipantId({
                                        teamParticipantId: teamParticipant.participantId,
                                        participantId: individualParticipantId,
                                        tournamentRecord: tournamentRecord,
                                        drawDefinition: drawDefinition,
                                        tieMatchUpId: tieMatchUpId,
                                        event: event,
                                    });
                            }
                        });
                    });
                    doublesMatchUps.forEach(function (doublesMatchUp, i) {
                        var tieMatchUpId = doublesMatchUp.matchUpId;
                        doublesMatchUp.sides.forEach(function (side) {
                            var _a;
                            var drawPosition = side.drawPosition;
                            var teamParticipant = teamParticipants_1 === null || teamParticipants_1 === void 0 ? void 0 : teamParticipants_1.find(function (teamParticipant) {
                                var participantId = teamParticipant.participantId;
                                var assignment = positionAssignments_1.find(function (assignment) { return assignment.participantId === participantId; });
                                return (assignment === null || assignment === void 0 ? void 0 : assignment.drawPosition) === drawPosition;
                            });
                            if (teamParticipant) {
                                var individualParticipantIds = (_a = teamParticipant.individualParticipantIds) === null || _a === void 0 ? void 0 : _a.slice(i * 2, i * 2 + 2);
                                individualParticipantIds === null || individualParticipantIds === void 0 ? void 0 : individualParticipantIds.forEach(function (individualParticipantId) {
                                    assignTieMatchUpParticipantId({
                                        teamParticipantId: teamParticipant.participantId,
                                        participantId: individualParticipantId,
                                        tournamentRecord: tournamentRecord,
                                        drawDefinition: drawDefinition,
                                        tieMatchUpId: tieMatchUpId,
                                        event: event,
                                    });
                                });
                            }
                        });
                    });
                };
                firstRoundDualMatchUps.forEach(assignParticipants);
            }
        }
    }
    // to support legacy tests it is possible to use completeAllMatchUps
    // to pass a score string that will be applied to all matchUps
    var scoreString = typeof completeAllMatchUps === 'string' && completeAllMatchUps;
    var matchUpStatus = scoreString && COMPLETED$1;
    try {
        for (var sortedStructures_1 = __values(sortedStructures), sortedStructures_1_1 = sortedStructures_1.next(); !sortedStructures_1_1.done; sortedStructures_1_1 = sortedStructures_1.next()) {
            var structure = sortedStructures_1_1.value;
            if (completedCount >= completionGoal)
                break;
            var matchUps = getAllStructureMatchUps({
                matchUpFilters: { matchUpTypes: [DOUBLES, SINGLES] },
                afterRecoveryTimes: false,
                tournamentRecord: tournamentRecord,
                inContext: true,
                drawDefinition: drawDefinition,
                matchUpsMap: matchUpsMap,
                structure: structure,
                event: event,
            }).matchUps;
            var sortedMatchUpIds = matchUps
                .filter(function (_a) {
                var winningSide = _a.winningSide;
                return !winningSide;
            })
                .sort(matchUpSort)
                .map(getMatchUpId);
            var _loop_1 = function (matchUpId) {
                if (!isNaN(completionGoal) && completedCount >= completionGoal)
                    return "break";
                var matchUps_1 = getAllStructureMatchUps({
                    matchUpFilters: { matchUpTypes: [DOUBLES, SINGLES] },
                    afterRecoveryTimes: false,
                    tournamentRecord: tournamentRecord,
                    inContext: true,
                    drawDefinition: drawDefinition,
                    matchUpsMap: matchUpsMap,
                    structure: structure,
                    event: event,
                }).matchUps;
                var targetMatchUp = matchUps_1.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
                var isDoubleExit = [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(targetMatchUp.matchUpStatus);
                if ((targetMatchUp === null || targetMatchUp === void 0 ? void 0 : targetMatchUp.readyToScore) && !isDoubleExit) {
                    var result = smartComplete({
                        winningSide: !randomWinningSide && 1,
                        matchUpStatusProfile: matchUpStatusProfile,
                        tournamentRecord: tournamentRecord,
                        drawDefinition: drawDefinition,
                        targetMatchUp: targetMatchUp,
                        matchUpFormat: matchUpFormat,
                        matchUpStatus: matchUpStatus,
                        scoreString: scoreString,
                        event: event,
                    });
                    if (result === null || result === void 0 ? void 0 : result.error)
                        return { value: result };
                    completedCount += 1;
                }
            };
            try {
                for (var sortedMatchUpIds_1 = (e_2 = void 0, __values(sortedMatchUpIds)), sortedMatchUpIds_1_1 = sortedMatchUpIds_1.next(); !sortedMatchUpIds_1_1.done; sortedMatchUpIds_1_1 = sortedMatchUpIds_1.next()) {
                    var matchUpId = sortedMatchUpIds_1_1.value;
                    var state_1 = _loop_1(matchUpId);
                    if (typeof state_1 === "object")
                        return state_1.value;
                    if (state_1 === "break")
                        break;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (sortedMatchUpIds_1_1 && !sortedMatchUpIds_1_1.done && (_b = sortedMatchUpIds_1.return)) _b.call(sortedMatchUpIds_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (sortedStructures_1_1 && !sortedStructures_1_1.done && (_a = sortedStructures_1.return)) _a.call(sortedStructures_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign(__assign({}, SUCCESS), { completedCount: completedCount });
}
function completeDrawMatchUp(params) {
    var matchUpStatusCodes = params.matchUpStatusCodes, policyDefinitions = params.policyDefinitions, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, targetMatchUp = params.targetMatchUp, matchUpStatus = params.matchUpStatus, matchUpFormat = params.matchUpFormat, scoreString = params.scoreString, winningSide = params.winningSide, event = params.event;
    if (!targetMatchUp || targetMatchUp.matchUpStatus === BYE) {
        return;
    }
    var matchUpId = (targetMatchUp || {}).matchUpId;
    var outcome = generateOutcomeFromScoreString({
        matchUpFormat: matchUpFormat,
        matchUpStatus: matchUpStatus,
        scoreString: scoreString,
        winningSide: winningSide,
    }).outcome;
    if (matchUpStatusCodes)
        outcome.matchUpStatusCodes = matchUpStatusCodes;
    return setMatchUpStatus({
        tournamentRecord: tournamentRecord,
        policyDefinitions: policyDefinitions,
        drawDefinition: drawDefinition,
        matchUpFormat: matchUpFormat,
        matchUpId: matchUpId,
        outcome: outcome,
        event: event,
    });
}
// NOTE: matchUpFormat must come from collectionDefinition in TEAM events
function smartComplete(params) {
    var _a = params.matchUpStatusProfile, matchUpStatusProfile = _a === void 0 ? {} : _a, tournamentRecord = params.tournamentRecord, policyDefinitions = params.policyDefinitions, drawDefinition = params.drawDefinition, matchUpStatus = params.matchUpStatus, matchUpFormat = params.matchUpFormat, targetMatchUp = params.targetMatchUp, scoreString = params.scoreString, winningSide = params.winningSide, event = params.event;
    if (scoreString || matchUpStatus)
        return completeDrawMatchUp(params);
    var matchUpId = (targetMatchUp || {}).matchUpId;
    var outcome = generateOutcome({
        matchUpStatusProfile: matchUpStatusProfile,
        matchUpFormat: matchUpFormat,
        winningSide: winningSide,
    }).outcome;
    return setMatchUpStatus({
        policyDefinitions: policyDefinitions,
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        matchUpFormat: matchUpFormat,
        matchUpId: matchUpId,
        outcome: outcome,
        event: event,
    });
}

function generateFlightDrawDefinitions(_a) {
    var e_1, _b;
    var _c, _d, _e, _f;
    var matchUpStatusProfile = _a.matchUpStatusProfile, completeAllMatchUps = _a.completeAllMatchUps, randomWinningSide = _a.randomWinningSide, tournamentRecord = _a.tournamentRecord, drawProfiles = _a.drawProfiles, event = _a.event;
    var flightProfile = getFlightProfile({ event: event }).flightProfile;
    var eventName = event.eventName, eventType = event.eventType, category = event.category;
    var startDate = tournamentRecord.startDate;
    var drawIds = [];
    var categoryName = (category === null || category === void 0 ? void 0 : category.categoryName) || (category === null || category === void 0 ? void 0 : category.ageCategoryCode) || (category === null || category === void 0 ? void 0 : category.ratingType);
    var existingDrawIds = (_c = event.drawDefinitions) === null || _c === void 0 ? void 0 : _c.map(function (_a) {
        var drawId = _a.drawId;
        return drawId;
    });
    if (Array.isArray(flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights)) {
        var _loop_1 = function (index, flight) {
            var drawId = flight.drawId, stage = flight.stage, drawName = flight.drawName, drawEntries = flight.drawEntries;
            drawIds.push(flight.drawId);
            var drawProfile = drawProfiles[index];
            var _k = drawProfile || {}, seedsCount = _k.seedsCount, _l = _k.generate, generate = _l === void 0 ? true : _l;
            if (generate) {
                var drawParticipantIds_1 = drawEntries.filter(xa(PARTICIPANT_ID)).map(xa(PARTICIPANT_ID));
                var seedingScaleName_1 = categoryName || eventName;
                if (tournamentRecord && seedsCount && seedsCount <= drawParticipantIds_1.length) {
                    var scaleValues = generateRange(1, seedsCount + 1);
                    scaleValues.forEach(function (scaleValue, index) {
                        var scaleItem = {
                            scaleValue: scaleValue,
                            scaleName: seedingScaleName_1,
                            scaleType: SEEDING$1,
                            eventType: eventType,
                            scaleDate: startDate,
                        };
                        var participantId = drawParticipantIds_1[index];
                        setParticipantScaleItem({
                            tournamentRecord: tournamentRecord,
                            participantId: participantId,
                            scaleItem: scaleItem,
                        });
                    });
                }
                if (existingDrawIds === null || existingDrawIds === void 0 ? void 0 : existingDrawIds.includes(drawId))
                    return "break";
                var result = generateDrawDefinition(__assign(__assign({}, drawProfile), { matchUpType: eventType, seedingScaleName: seedingScaleName_1, tournamentRecord: tournamentRecord, isMock: true, drawEntries: drawEntries, drawName: drawName, drawId: drawId, event: event, stage: stage }));
                if (result.error)
                    return { value: { error: result.error, drawIds: [] } };
                var drawDefinition_1 = result.drawDefinition;
                if (!drawDefinition_1)
                    return { value: { error: DRAW_DEFINITION_NOT_FOUND } };
                var drawExtensions = (_d = drawProfiles[index]) === null || _d === void 0 ? void 0 : _d.drawExtensions;
                if (Array.isArray(drawExtensions)) {
                    drawExtensions
                        .filter(isValidExtension)
                        .forEach(function (extension) { return addExtension({ element: drawDefinition_1, extension: extension }); });
                }
                result = addDrawDefinition({
                    suppressNotifications: true,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition_1,
                    event: event,
                });
                if (result.error)
                    return { value: { error: result.error, drawIds: [] } };
                if (drawProfile === null || drawProfile === void 0 ? void 0 : drawProfile.withPlayoffs) {
                    var structureId = (_e = drawDefinition_1.structures) === null || _e === void 0 ? void 0 : _e[0].structureId;
                    var result_1 = addPlayoffStructures(__assign(__assign({ idPrefix: drawProfile.idPrefix }, drawProfile.withPlayoffs), { tournamentRecord: tournamentRecord, drawDefinition: drawDefinition_1, isMock: true, structureId: structureId, event: event }));
                    if (result_1 === null || result_1 === void 0 ? void 0 : result_1.error)
                        return { value: result_1 };
                }
                // TODO: enable { outcomes: [] } in eventProfile: { drawProfiles }
                var completionGoal = drawProfile === null || drawProfile === void 0 ? void 0 : drawProfile.completionGoal;
                var manual = (drawProfile === null || drawProfile === void 0 ? void 0 : drawProfile.automated) === false;
                if (!manual && (completeAllMatchUps || completionGoal)) {
                    var matchUpFormat = drawProfile === null || drawProfile === void 0 ? void 0 : drawProfile.matchUpFormat;
                    var result_2 = completeDrawMatchUps({
                        completeAllMatchUps: !completionGoal && completeAllMatchUps,
                        matchUpStatusProfile: matchUpStatusProfile,
                        randomWinningSide: randomWinningSide,
                        tournamentRecord: tournamentRecord,
                        completionGoal: completionGoal,
                        drawDefinition: drawDefinition_1,
                        matchUpFormat: matchUpFormat,
                        event: event,
                    });
                    if (result_2.error)
                        return { value: { error: result_2.error, drawIds: [] } };
                    var completedCount = result_2.completedCount;
                    if ((drawProfile === null || drawProfile === void 0 ? void 0 : drawProfile.drawType) === ROUND_ROBIN_WITH_PLAYOFF) {
                        var mainStructure = (_f = drawDefinition_1.structures) === null || _f === void 0 ? void 0 : _f.find(function (structure) { return structure.stage === MAIN; });
                        if (!mainStructure)
                            return { value: { error: STRUCTURE_NOT_FOUND } };
                        var result_3 = automatedPlayoffPositioning({
                            structureId: mainStructure.structureId,
                            tournamentRecord: tournamentRecord,
                            drawDefinition: drawDefinition_1,
                            event: event,
                        });
                        if (result_3.error)
                            return { value: { error: result_3.error, drawIds: [] } };
                        var playoffCompletionGoal = completionGoal ? completionGoal - (completedCount !== null && completedCount !== void 0 ? completedCount : 0) : undefined;
                        result_3 = completeDrawMatchUps({
                            completeAllMatchUps: !completionGoal && completeAllMatchUps,
                            completionGoal: completionGoal ? playoffCompletionGoal : undefined,
                            matchUpStatusProfile: matchUpStatusProfile,
                            randomWinningSide: randomWinningSide,
                            tournamentRecord: tournamentRecord,
                            drawDefinition: drawDefinition_1,
                            matchUpFormat: matchUpFormat,
                            event: event,
                        });
                        if (result_3.error)
                            return { value: { error: result_3.error, drawIds: [] } };
                    }
                }
            }
        };
        try {
            for (var _g = __values(flightProfile.flights.entries()), _h = _g.next(); !_h.done; _h = _g.next()) {
                var _j = __read(_h.value, 2), index = _j[0], flight = _j[1];
                var state_1 = _loop_1(index, flight);
                if (typeof state_1 === "object")
                    return state_1.value;
                if (state_1 === "break")
                    break;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return __assign(__assign({}, SUCCESS), { drawIds: drawIds });
}

function generateEventParticipants(params) {
    var _a, _b, _c;
    var _d = params.participantsProfile, participantsProfile = _d === void 0 ? {} : _d, uniqueParticipantsCount = params.uniqueParticipantsCount, ratingsParameters = params.ratingsParameters, tournamentRecord = params.tournamentRecord, eventProfile = params.eventProfile, eventIndex = params.eventIndex, event = params.event, uuids = params.uuids;
    var category = event.category, gender = event.gender, eventType = event.eventType;
    var eventParticipantType = (eventType === SINGLES$1 && INDIVIDUAL) ||
        (eventType === DOUBLES$1 && PAIR) ||
        eventType;
    var mainParticipantsCount = uniqueParticipantsCount[MAIN] || 0;
    var qualifyingParticipantsCount = uniqueParticipantsCount[QUALIFYING] || 0;
    var participantsCount = ((_a = eventProfile.drawProfiles) === null || _a === void 0 ? void 0 : _a.length)
        ? mainParticipantsCount + qualifyingParticipantsCount
        : (_c = (_b = eventProfile.participantsProfile) === null || _b === void 0 ? void 0 : _b.participantsCount) !== null && _c !== void 0 ? _c : 0;
    var sex = [MALE, FEMALE].includes(gender) ? gender : undefined;
    var idPrefix = (participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.idPrefix)
        ? "E-".concat(eventIndex, "-").concat(participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.idPrefix)
        : undefined;
    var uniqueFlightParticipants = generateParticipants(__assign(__assign({ uuids: eventProfile.uuids || uuids }, participantsProfile), { scaledParticipantsCount: eventProfile.scaledParticipantsCount, consideredDate: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.startDate, rankingRange: eventProfile.rankingRange, participantType: eventParticipantType, participantsCount: participantsCount, ratingsParameters: ratingsParameters, category: category, idPrefix: idPrefix, sex: sex })).participants;
    var participants = uniqueFlightParticipants;
    var result = addParticipants({
        tournamentRecord: tournamentRecord,
        participants: participants,
    });
    if (result.error)
        return result;
    var uniqueDrawParticipants = uniqueFlightParticipants === null || uniqueFlightParticipants === void 0 ? void 0 : uniqueFlightParticipants.filter(function (_a) {
        var participantType = _a.participantType;
        return participantType === eventParticipantType;
    });
    var uniqueParticipantIds = uniqueFlightParticipants === null || uniqueFlightParticipants === void 0 ? void 0 : uniqueFlightParticipants.map(getParticipantId);
    return { uniqueDrawParticipants: uniqueDrawParticipants, uniqueParticipantIds: uniqueParticipantIds };
}

function generateFlight(_a) {
    var autoEntryPositions = _a.autoEntryPositions, tournamentRecord = _a.tournamentRecord, drawParticipants = _a.drawParticipants, drawProfile = _a.drawProfile, event = _a.event;
    var _b = drawProfile.drawType, drawType = _b === void 0 ? SINGLE_ELIMINATION : _b, _c = drawProfile.qualifyingPositions, qualifyingPositions = _c === void 0 ? 0 : _c, _d = drawProfile.stage, stage = _d === void 0 ? MAIN : _d, _e = drawProfile.drawSize, drawSize = _e === void 0 ? 0 : _e, drawName = drawProfile.drawName, drawId = drawProfile.drawId;
    var entriesCount = drawSize - qualifyingPositions;
    var drawParticipantIds = drawParticipants
        .slice(0, entriesCount)
        .map(getParticipantId);
    if (drawParticipantIds.length) {
        var result_1 = addEventEntries({
            participantIds: drawParticipantIds,
            autoEntryPositions: autoEntryPositions,
            entryStage: stage,
            tournamentRecord: tournamentRecord,
            event: event,
        });
        if (result_1.error)
            return result_1;
    }
    var drawEntries = drawParticipantIds.map(function (participantId) { return ({
        entryStatus: DIRECT_ACCEPTANCE,
        entryStage: stage,
        participantId: participantId,
    }); });
    var result = addFlight({
        drawName: drawName || drawType,
        qualifyingPositions: qualifyingPositions,
        drawEntries: drawEntries,
        drawId: drawId,
        event: event,
        stage: stage,
    });
    if (result.error) {
        return result;
    }
    return __assign({}, SUCCESS);
}

function generateFlights(_a) {
    var e_1, _b;
    var uniqueDrawParticipants = _a.uniqueDrawParticipants, autoEntryPositions = _a.autoEntryPositions, stageParticipants = _a.stageParticipants, tournamentRecord = _a.tournamentRecord, drawProfiles = _a.drawProfiles, category = _a.category, gender = _a.gender, event = _a.event;
    var uniqueParticipantsIndex = 0;
    try {
        for (var drawProfiles_1 = __values(drawProfiles), drawProfiles_1_1 = drawProfiles_1.next(); !drawProfiles_1_1.done; drawProfiles_1_1 = drawProfiles_1.next()) {
            var drawProfile = drawProfiles_1_1.value;
            var _c = drawProfile.qualifyingPositions, qualifyingPositions = _c === void 0 ? 0 : _c, uniqueParticipants = drawProfile.uniqueParticipants, _d = drawProfile.stage, stage = _d === void 0 ? MAIN : _d, _e = drawProfile.drawSize, drawSize = _e === void 0 ? 0 : _e;
            var entriesCount = drawSize - qualifyingPositions;
            var requiresUniqueParticipants = uniqueParticipants || gender || category || stage === QUALIFYING;
            // if a drawProfile has specified uniqueParticipants...
            var drawParticipants = requiresUniqueParticipants
                ? uniqueDrawParticipants.slice(uniqueParticipantsIndex, uniqueParticipantsIndex + entriesCount)
                : stageParticipants[stage || MAIN] || [];
            if (requiresUniqueParticipants)
                uniqueParticipantsIndex += entriesCount;
            var result = generateFlight({
                autoEntryPositions: autoEntryPositions,
                drawParticipants: drawParticipants,
                tournamentRecord: tournamentRecord,
                drawProfile: drawProfile,
                event: event,
            });
            if (result.error)
                return result;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (drawProfiles_1_1 && !drawProfiles_1_1.done && (_b = drawProfiles_1.return)) _b.call(drawProfiles_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}

function generateEventWithFlights(params) {
    var e_1, _a, e_2, _b, _c;
    var _d;
    var allUniqueParticipantIds = params.allUniqueParticipantIds, matchUpStatusProfile = params.matchUpStatusProfile, participantsProfile = params.participantsProfile, completeAllMatchUps = params.completeAllMatchUps, autoEntryPositions = params.autoEntryPositions, hydrateCollections = params.hydrateCollections, randomWinningSide = params.randomWinningSide, ratingsParameters = params.ratingsParameters, tournamentRecord = params.tournamentRecord, eventProfile = params.eventProfile, eventIndex = params.eventIndex, publish = params.publish, isMock = params.isMock, uuids = params.uuids;
    var gender = eventProfile.gender;
    var eventName = eventProfile.eventName;
    var _e = eventProfile.eventType, eventType = _e === void 0 ? SINGLES$1 : _e, policyDefinitions = eventProfile.policyDefinitions, _f = eventProfile.drawProfiles, drawProfiles = _f === void 0 ? [] : _f, eventExtensions = eventProfile.eventExtensions, surfaceCategory = eventProfile.surfaceCategory, tieFormatName = eventProfile.tieFormatName, processCodes = eventProfile.processCodes, discipline = eventProfile.discipline, eventLevel = eventProfile.eventLevel, timeItems = eventProfile.timeItems, ballType = eventProfile.ballType, category = eventProfile.category;
    var eventId = eventProfile.eventId || UUID();
    var tieFormat = eventProfile.tieFormat ||
        (eventType === TEAM$2
            ? tieFormatDefaults({
                namedFormat: tieFormatName,
                event: { eventId: eventId, category: category, gender: gender },
                hydrateCollections: hydrateCollections,
                isMock: isMock,
            })
            : undefined);
    var targetParticipants = tournamentRecord.participants;
    try {
        for (var drawProfiles_1 = __values(drawProfiles), drawProfiles_1_1 = drawProfiles_1.next(); !drawProfiles_1_1.done; drawProfiles_1_1 = drawProfiles_1.next()) {
            var drawProfile = drawProfiles_1_1.value;
            if (!gender && drawProfile.gender)
                gender = drawProfile === null || drawProfile === void 0 ? void 0 : drawProfile.gender;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (drawProfiles_1_1 && !drawProfiles_1_1.done && (_a = drawProfiles_1.return)) _a.call(drawProfiles_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var _g = getStageParticipantsCount({
        drawProfiles: drawProfiles,
        category: category,
        gender: gender,
    }), stageParticipantsCount = _g.stageParticipantsCount, uniqueParticipantsCount = _g.uniqueParticipantsCount, uniqueParticipantStages = _g.uniqueParticipantStages;
    var eventParticipantType = (eventType === SINGLES$1 && INDIVIDUAL) || (eventType === DOUBLES$1 && PAIR) || eventType;
    var _h = uniqueParticipantStages
        ? generateEventParticipants({
            event: { eventType: eventType, category: category, gender: gender },
            uniqueParticipantsCount: uniqueParticipantsCount,
            participantsProfile: participantsProfile,
            ratingsParameters: ratingsParameters,
            tournamentRecord: tournamentRecord,
            eventProfile: eventProfile,
            eventIndex: eventIndex,
            uuids: uuids,
        })
        : {}, _j = _h.uniqueDrawParticipants, uniqueDrawParticipants = _j === void 0 ? [] : _j, _k = _h.uniqueParticipantIds, uniqueParticipantIds = _k === void 0 ? [] : _k;
    // Create event object -------------------------------------------------------
    var eventAttributes = eventProfile.eventAttributes;
    if (typeof eventAttributes !== 'object')
        eventAttributes = {};
    var categoryName = (category === null || category === void 0 ? void 0 : category.categoryName) || (category === null || category === void 0 ? void 0 : category.ageCategoryCode) || (category === null || category === void 0 ? void 0 : category.ratingType);
    eventName = eventName || categoryName || 'Generated Event';
    var newEvent = __assign(__assign({}, eventAttributes), { surfaceCategory: surfaceCategory, processCodes: processCodes, discipline: discipline, eventLevel: eventLevel, eventName: eventName, eventType: eventType, tieFormat: tieFormat, ballType: ballType, category: category, eventId: eventId, gender: gender });
    // attach any valid eventExtensions
    if ((eventExtensions === null || eventExtensions === void 0 ? void 0 : eventExtensions.length) && Array.isArray(eventExtensions)) {
        var extensions = eventExtensions.filter(isValidExtension);
        if (extensions === null || extensions === void 0 ? void 0 : extensions.length)
            Object.assign(newEvent, { extensions: extensions });
    }
    if (Array.isArray(timeItems)) {
        timeItems.forEach(function (timeItem) { return addEventTimeItem({ event: event, timeItem: timeItem }); });
    }
    if (typeof policyDefinitions === 'object') {
        try {
            for (var _l = __values(Object.keys(policyDefinitions)), _m = _l.next(); !_m.done; _m = _l.next()) {
                var policyType = _m.value;
                attachPolicies({
                    policyDefinitions: (_c = {}, _c[policyType] = policyDefinitions[policyType], _c),
                    event: newEvent,
                });
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_m && !_m.done && (_b = _l.return)) _b.call(_l);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    // only update on event since category is used in participant generation
    if (newEvent.category)
        newEvent.category.categoryName = categoryName;
    var drawIds;
    var eventResult = addEvent({
        suppressNotifications: false,
        internalUse: true,
        tournamentRecord: tournamentRecord,
        event: newEvent,
    });
    if (eventResult.error)
        return eventResult;
    var event = eventResult === null || eventResult === void 0 ? void 0 : eventResult.event;
    // Generate Flights ---------------------------------------------------------
    var stageParticipants = getStageParticipants({
        allUniqueParticipantIds: allUniqueParticipantIds,
        stageParticipantsCount: stageParticipantsCount,
        eventParticipantType: eventParticipantType,
        targetParticipants: targetParticipants,
    }).stageParticipants;
    if (drawProfiles === null || drawProfiles === void 0 ? void 0 : drawProfiles.length) {
        var flightResult = generateFlights({
            uniqueDrawParticipants: uniqueDrawParticipants,
            autoEntryPositions: autoEntryPositions,
            stageParticipants: stageParticipants,
            tournamentRecord: tournamentRecord,
            drawProfiles: drawProfiles,
            category: category,
            gender: gender,
            event: event,
        });
        if (flightResult.error)
            return flightResult;
        var drawDefinitionResult = generateFlightDrawDefinitions({
            matchUpStatusProfile: matchUpStatusProfile,
            completeAllMatchUps: completeAllMatchUps,
            randomWinningSide: randomWinningSide,
            tournamentRecord: tournamentRecord,
            drawProfiles: drawProfiles,
            event: event,
        });
        if (drawDefinitionResult.error)
            return drawDefinitionResult;
        drawIds = drawDefinitionResult.drawIds;
    }
    else if ((_d = eventProfile === null || eventProfile === void 0 ? void 0 : eventProfile.participantsProfile) === null || _d === void 0 ? void 0 : _d.participantsCount) {
        var eventParticipantIds = uniqueDrawParticipants.map(xa('participantId'));
        if (eventParticipantIds.length) {
            var result = addEventEntries({
                participantIds: eventParticipantIds,
                autoEntryPositions: autoEntryPositions,
                tournamentRecord: tournamentRecord,
                entryStage: MAIN,
                event: event,
            });
            if (result.error)
                return result;
        }
    }
    if (publish) {
        publishEvent({ tournamentRecord: tournamentRecord, event: event });
    }
    return { drawIds: drawIds, eventId: eventId, uniqueParticipantIds: uniqueParticipantIds };
}

function getCompetitionDateRange(_a) {
    var tournamentRecords = _a.tournamentRecords;
    if (!isObject(tournamentRecords))
        return { error: MISSING_TOURNAMENT_RECORDS };
    var tournamentIds = Object.keys(tournamentRecords !== null && tournamentRecords !== void 0 ? tournamentRecords : {});
    var dateRange = tournamentIds.reduce(function (dateRange, tournamentId) {
        var tournamentRecord = tournamentRecords[tournamentId];
        var _a = getTournamentInfo({ tournamentRecord: tournamentRecord }).tournamentInfo, startDate = _a.startDate, endDate = _a.endDate;
        var dateOfStart = startDate && new Date(extractDate(startDate));
        if (!dateRange.startDate ||
            (dateOfStart && dateOfStart < dateRange.startDate)) {
            dateRange.startDate = dateOfStart;
        }
        var dateOfEnd = endDate && new Date(extractDate(endDate));
        if (!dateRange.endDate || (dateOfEnd && dateOfEnd > dateRange.endDate)) {
            dateRange.endDate = dateOfEnd;
        }
        return dateRange;
    }, { startDate: undefined, endDate: undefined });
    var startDate = dateRange.startDate && extractDate(dateRange.startDate.toISOString());
    var endDate = dateRange.endDate && extractDate(dateRange.endDate.toISOString());
    if (!startDate || !endDate)
        return { error: MISSING_DATE };
    return { startDate: startDate, endDate: endDate };
}

function addSchedulingProfileRound(_a) {
    var tournamentRecords = _a.tournamentRecords, scheduleDate = _a.scheduleDate, venueId = _a.venueId, round = _a.round;
    if (!isValidDateString(scheduleDate)) {
        return { error: INVALID_DATE };
    }
    var stack = 'addSchedulingProfileRound';
    var extension = findExtension({
        name: SCHEDULING_PROFILE,
        tournamentRecords: tournamentRecords,
        discover: true,
    }).extension;
    var schedulingProfile = (extension === null || extension === void 0 ? void 0 : extension.value) || [];
    var dateProfile = schedulingProfile.find(function (dateProfile) {
        return sameDay(scheduleDate, dateProfile.scheduleDate);
    });
    if (!dateProfile) {
        var _b = getCompetitionDateRange({
            tournamentRecords: tournamentRecords,
        }), startDate = _b.startDate, endDate = _b.endDate;
        var dateObject = new Date(scheduleDate);
        if ((startDate && dateObject < new Date(startDate)) ||
            (endDate && dateObject > new Date(endDate))) {
            return { error: INVALID_DATE };
        }
        dateProfile = { scheduleDate: scheduleDate, venues: [] };
        schedulingProfile.push(dateProfile);
    }
    var venueOnDate = dateProfile.venues.find(function (venue) { return venue.venueId === venueId; });
    if (!venueOnDate) {
        venueOnDate = { venueId: venueId, rounds: [] };
        dateProfile.venues.push(venueOnDate);
    }
    // ensure round is not already present
    var excludeKeys = ['notBeforeTime'];
    var hashRound = function (r) {
        return Object.keys(r)
            .filter(function (key) { return !excludeKeys.includes(key); })
            .sort()
            .map(function (k) { return (isObject(r[k]) ? hashRound(r[k]) : r[k]); })
            .flat()
            .join('|');
    };
    var roundExists = venueOnDate.rounds.find(function (existingRound) { return hashRound(existingRound) === hashRound(round); });
    if (roundExists)
        return decorateResult({ result: { error: EXISTING_ROUND }, stack: stack });
    venueOnDate.rounds.push(round);
    var result = setSchedulingProfile({ tournamentRecords: tournamentRecords, schedulingProfile: schedulingProfile });
    if (result.error)
        return result;
    return __assign({}, SUCCESS);
}

function generateScheduledRounds(_a) {
    var e_1, _b, e_2, _c, e_3, _d;
    var _e, _f;
    var schedulingProfile = _a.schedulingProfile, tournamentRecord = _a.tournamentRecord;
    if (typeof schedulingProfile !== 'object')
        return { error: INVALID_VALUES };
    var containedStructures = getContainedStructures({
        tournamentRecord: tournamentRecord,
    }).containedStructures;
    var matchUps = (_e = allTournamentMatchUps({ tournamentRecord: tournamentRecord }).matchUps) !== null && _e !== void 0 ? _e : [];
    var tournamentId = tournamentRecord.tournamentId;
    var scheduledRounds = [];
    try {
        for (var schedulingProfile_1 = __values(schedulingProfile), schedulingProfile_1_1 = schedulingProfile_1.next(); !schedulingProfile_1_1.done; schedulingProfile_1_1 = schedulingProfile_1.next()) {
            var dateProfile = schedulingProfile_1_1.value;
            var scheduleDate = dateProfile.scheduleDate, _g = dateProfile.venues, venues = _g === void 0 ? [] : _g;
            try {
                for (var venues_1 = (e_2 = void 0, __values(venues)), venues_1_1 = venues_1.next(); !venues_1_1.done; venues_1_1 = venues_1.next()) {
                    var venue = venues_1_1.value;
                    var rounds = venue.rounds, venueId = venue.venueId;
                    var _loop_1 = function (round) {
                        var _h;
                        var drawId = round.drawId, winnerFinishingPositionRange = round.winnerFinishingPositionRange, roundSegment = round.roundSegment;
                        var targetMatchUps = matchUps.filter(function (matchUp) {
                            var _a;
                            var targetRange = (winnerFinishingPositionRange === null || winnerFinishingPositionRange === void 0 ? void 0 : winnerFinishingPositionRange.indexOf('-')) > 0 &&
                                winnerFinishingPositionRange.split('-').map(function (x) { return +x; });
                            var range = (_a = matchUp.finishingPositionRange) === null || _a === void 0 ? void 0 : _a.winner;
                            return (matchUp.drawId === drawId &&
                                (!round.roundNumber || matchUp.roundNumber === round.roundNumber) &&
                                (!range ||
                                    !targetRange ||
                                    intersection(range, targetRange).length === 2 ||
                                    (unique(range).length === unique(targetRange).length &&
                                        intersection(range, targetRange).length ===
                                            unique(range).length)));
                        });
                        var targetMatchUp = targetMatchUps[0];
                        if (targetMatchUp) {
                            var eventId = targetMatchUp.eventId, roundNumber = targetMatchUp.roundNumber, drawName = targetMatchUp.drawName, structureName = targetMatchUp.structureName, roundName = targetMatchUp.roundName;
                            var structureId_1 = targetMatchUp.structureId;
                            if (roundNumber && !winnerFinishingPositionRange) {
                                structureId_1 =
                                    (_f = Object.keys(containedStructures).find(function (containingStructureId) {
                                        return containedStructures[containingStructureId].includes(structureId_1);
                                    })) !== null && _f !== void 0 ? _f : structureId_1;
                            }
                            var roundToSchedule = {
                                tournamentId: tournamentId,
                                structureId: structureId_1,
                                roundNumber: roundNumber,
                                roundSegment: roundSegment,
                                eventId: eventId,
                                drawId: drawId,
                            };
                            var result = addSchedulingProfileRound({
                                tournamentRecords: (_h = {}, _h[tournamentId] = tournamentRecord, _h),
                                round: roundToSchedule,
                                scheduleDate: scheduleDate,
                                venueId: venueId,
                            });
                            if (result.error)
                                return { value: result };
                            scheduledRounds.push(__assign({ structureName: structureName, roundName: roundName, drawName: drawName }, roundToSchedule));
                        }
                    };
                    try {
                        for (var rounds_1 = (e_3 = void 0, __values(rounds)), rounds_1_1 = rounds_1.next(); !rounds_1_1.done; rounds_1_1 = rounds_1.next()) {
                            var round = rounds_1_1.value;
                            var state_1 = _loop_1(round);
                            if (typeof state_1 === "object")
                                return state_1.value;
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (rounds_1_1 && !rounds_1_1.done && (_d = rounds_1.return)) _d.call(rounds_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (venues_1_1 && !venues_1_1.done && (_c = venues_1.return)) _c.call(venues_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (schedulingProfile_1_1 && !schedulingProfile_1_1.done && (_b = schedulingProfile_1.return)) _b.call(schedulingProfile_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { scheduledRounds: scheduledRounds };
}

function generateEventWithDraw(params) {
    var _a, _b, e_1, _c, e_2, _d, e_3, _e;
    var _f, _g, _h;
    var _j = params.allUniqueParticipantIds, allUniqueParticipantIds = _j === void 0 ? [] : _j, _k = params.participantsProfile, participantsProfile = _k === void 0 ? {} : _k, matchUpStatusProfile = params.matchUpStatusProfile, completeAllMatchUps = params.completeAllMatchUps, autoEntryPositions = params.autoEntryPositions, hydrateCollections = params.hydrateCollections, randomWinningSide = params.randomWinningSide, ratingsParameters = params.ratingsParameters, tournamentRecord = params.tournamentRecord, _l = params.isMock, isMock = _l === void 0 ? true : _l, drawProfile = params.drawProfile, startDate = params.startDate, drawIndex = params.drawIndex, uuids = params.uuids;
    var drawProfileCopy = makeDeepCopy(drawProfile, false, true);
    var _m = drawProfileCopy.excessParticipantAlternates, excessParticipantAlternates = _m === void 0 ? true : _m, _o = drawProfileCopy.matchUpFormat, matchUpFormat = _o === void 0 ? FORMAT_STANDARD : _o, _p = drawProfileCopy.drawType, drawType = _p === void 0 ? SINGLE_ELIMINATION : _p, _q = drawProfileCopy.tournamentAlternates, tournamentAlternates = _q === void 0 ? 0 : _q, _r = drawProfileCopy.alternatesCount, alternatesCount = _r === void 0 ? 0 : _r, qualifyingPositions = drawProfileCopy.qualifyingPositions, qualifyingProfiles = drawProfileCopy.qualifyingProfiles, _s = drawProfileCopy.generate, generate = _s === void 0 ? true : _s, eventExtensions = drawProfileCopy.eventExtensions, drawExtensions = drawProfileCopy.drawExtensions, completionGoal = drawProfileCopy.completionGoal, tieFormatName = drawProfileCopy.tieFormatName, seedsCount = drawProfileCopy.seedsCount, timeItems = drawProfileCopy.timeItems, drawName = drawProfileCopy.drawName, category = drawProfileCopy.category, idPrefix = drawProfileCopy.idPrefix, publish = drawProfileCopy.publish, gender = drawProfileCopy.gender, stage = drawProfileCopy.stage;
    var drawSize = drawProfileCopy.drawSize || (drawProfileCopy.ignoreDefaults ? undefined : 32);
    var eventId = drawProfileCopy.eventId || UUID();
    var eventType = drawProfile.eventType || drawProfile.matchUpType || SINGLES$1;
    var participantType = eventType === DOUBLES$1 ? PAIR : INDIVIDUAL;
    var tieFormat = (typeof drawProfile.tieFormat === 'object' && drawProfile.tieFormat) ||
        (eventType === TEAM$1 &&
            tieFormatDefaults({
                event: { eventId: eventId, category: category, gender: gender },
                namedFormat: tieFormatName,
                hydrateCollections: hydrateCollections,
                isMock: isMock,
            })) ||
        undefined;
    var categoryName = (category === null || category === void 0 ? void 0 : category.categoryName) || (category === null || category === void 0 ? void 0 : category.ageCategoryCode) || (category === null || category === void 0 ? void 0 : category.ratingType);
    var eventName = drawProfile.eventName || categoryName || "Generated ".concat(eventType);
    var targetParticipants = (tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) || [];
    var qualifyingParticipantsCount = ((qualifyingProfiles === null || qualifyingProfiles === void 0 ? void 0 : qualifyingProfiles.map(function (profile) { return profile.structureProfiles || []; }).flat().reduce(function (count, profile) {
        var qpc = !profile.participantsCount || profile.participantsCount > profile.drawSize
            ? profile.drawSize
            : profile.participantsCount || 0;
        return count + qpc;
    }, 0)) || 0) * (participantType === PAIR ? 2 : 1);
    var participantsCount = (!drawProfile.participantsCount || drawProfile.participantsCount > drawSize
        ? drawSize
        : drawProfile.participantsCount) || 0;
    // TODO: implement use of tieFormats and tieFormatId
    var event = { eventName: eventName, eventType: eventType, tieFormat: tieFormat, category: category, eventId: eventId, gender: gender };
    if (Array.isArray(timeItems)) {
        timeItems.forEach(function (timeItem) { return addEventTimeItem({ event: event, timeItem: timeItem }); });
    }
    var eventAttributes = drawProfile.eventAttributes;
    if (typeof eventAttributes !== 'object')
        eventAttributes = {};
    Object.assign(event, eventAttributes);
    // attach any valid eventExtensions
    if ((eventExtensions === null || eventExtensions === void 0 ? void 0 : eventExtensions.length) && Array.isArray(eventExtensions)) {
        var extensions = eventExtensions.filter(isValidExtension);
        if (extensions === null || extensions === void 0 ? void 0 : extensions.length)
            Object.assign(event, { extensions: extensions });
    }
    var uniqueParticipantIds = [];
    if (qualifyingParticipantsCount || drawProfile.uniqueParticipants || !tournamentRecord || gender || category) {
        var drawParticipantsCount = (participantsCount || 0) + alternatesCount + qualifyingParticipantsCount;
        var individualParticipantCount = drawParticipantsCount;
        var gendersCount_1 = (_a = {}, _a[MALE] = 0, _a[FEMALE] = 0, _a);
        var teamSize = void 0, genders_1;
        if (eventType === TEAM$1) {
            (_b = processTieFormat({
                alternatesCount: alternatesCount,
                tieFormatName: tieFormatName,
                tieFormat: tieFormat,
                drawSize: drawSize,
            }), teamSize = _b.teamSize, genders_1 = _b.genders);
            Object.keys(genders_1).forEach(function (key) {
                if ([MALE, FEMALE].includes(key) && genders_1[key]) {
                    gendersCount_1[key] = drawSize * genders_1[key];
                }
            });
            individualParticipantCount = teamSize * ((drawSize || 0) + qualifyingParticipantsCount);
        }
        var idPrefix_1 = (participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.idPrefix) ? "D-".concat(drawIndex, "-").concat(participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.idPrefix) : undefined;
        var result_1 = generateParticipants(__assign(__assign({}, participantsProfile), { scaledParticipantsCount: drawProfile.scaledParticipantsCount || participantsProfile.scaledParticipantsCount, participantsCount: individualParticipantCount, consideredDate: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.startDate, sex: gender || (participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.sex), rankingRange: drawProfile.rankingRange, uuids: drawProfile.uuids || uuids, ratingsParameters: ratingsParameters, participantType: participantType, gendersCount: gendersCount_1, idPrefix: idPrefix_1, category: category }));
        var unique = result_1.participants;
        // update categoryName **after** generating participants
        if (event.category)
            event.category.categoryName = categoryName;
        if (tournamentRecord) {
            var result_2 = addParticipants({
                participants: unique,
                tournamentRecord: tournamentRecord,
            });
            if (result_2.error)
                return result_2;
        }
        unique.forEach(function (_a) {
            var participantId = _a.participantId;
            return uniqueParticipantIds.push(participantId);
        });
        targetParticipants = unique;
        if (eventType === TEAM$1) {
            var maleIndividualParticipantIds_1 = genders_1[MALE]
                ? unique
                    .filter(function (_a) {
                    var participantType = _a.participantType, person = _a.person;
                    return participantType === INDIVIDUAL && (person === null || person === void 0 ? void 0 : person.sex) === MALE;
                })
                    .map(getParticipantId)
                : [];
            var femaleIndividualParticipantIds_1 = genders_1[FEMALE]
                ? unique
                    .filter(function (_a) {
                    var participantType = _a.participantType, person = _a.person;
                    return participantType === INDIVIDUAL && (person === null || person === void 0 ? void 0 : person.sex) === FEMALE;
                })
                    .map(getParticipantId)
                : [];
            var remainingParticipantIds_1 = unique
                .filter(function (_a) {
                var participantType = _a.participantType;
                return participantType === INDIVIDUAL;
            })
                .map(getParticipantId)
                .filter(function (participantId) {
                return !maleIndividualParticipantIds_1.includes(participantId) &&
                    !femaleIndividualParticipantIds_1.includes(participantId);
            });
            var mixedCount_1 = teamSize - (genders_1[MALE] + genders_1[FEMALE]);
            // use indices to keep track of positions within pId arrays
            var fIndex_1 = 0, mIndex_1 = 0, rIndex_1 = 0;
            var teamParticipants = generateRange(0, drawParticipantsCount).map(function (teamIndex) {
                var fPIDs = femaleIndividualParticipantIds_1.slice(fIndex_1, fIndex_1 + genders_1[FEMALE]);
                var mPIDs = maleIndividualParticipantIds_1.slice(mIndex_1, mIndex_1 + genders_1[MALE]);
                var rIDs = remainingParticipantIds_1.slice(rIndex_1, rIndex_1 + mixedCount_1);
                fIndex_1 += genders_1[FEMALE];
                mIndex_1 += genders_1[MALE];
                rIndex_1 += mixedCount_1;
                return {
                    individualParticipantIds: __spreadArray(__spreadArray(__spreadArray([], __read(fPIDs), false), __read(mPIDs), false), __read(rIDs), false),
                    participantOtherName: "TM".concat(teamIndex + 1),
                    participantName: "Team ".concat(teamIndex + 1),
                    participantRole: COMPETITOR,
                    participantType: TEAM$1,
                    participantId: UUID(),
                };
            });
            var result_3 = addParticipants({
                participants: teamParticipants,
                tournamentRecord: tournamentRecord,
            });
            if (!result_3.success)
                return result_3;
            targetParticipants = teamParticipants;
        }
    }
    var isEventParticipantType = function (participant) {
        var participantType = participant.participantType;
        if (eventType === SINGLES$1 && participantType === INDIVIDUAL)
            return true;
        if (eventType === DOUBLES$1 && participantType === PAIR)
            return true;
        return eventType === TEAM$1 && participantType === TEAM$1;
    };
    var isEventGender = function (participant) {
        var _a, _b;
        if (!drawProfile.gender)
            return true;
        if (((_a = participant.person) === null || _a === void 0 ? void 0 : _a.sex) === drawProfile.gender)
            return true;
        return (_b = participant.individualParticipantIds) === null || _b === void 0 ? void 0 : _b.some(function (participantId) {
            var individualParticipant = targetParticipants.find(function (p) { return p.participantId === participantId; });
            return individualParticipant && isEventGender(individualParticipant);
        });
    };
    var consideredParticipants = targetParticipants
        .filter(isEventParticipantType)
        .filter(isEventGender)
        .filter(function (_a) {
        var participantId = _a.participantId;
        return !allUniqueParticipantIds.includes(participantId);
    });
    var participantIds = consideredParticipants.slice(0, participantsCount).map(function (p) { return p.participantId; });
    if (isMock && (participantIds === null || participantIds === void 0 ? void 0 : participantIds.length)) {
        var result_4 = addEventEntries({
            autoEntryPositions: autoEntryPositions,
            entryStage: stage,
            tournamentRecord: tournamentRecord,
            participantIds: participantIds,
            event: event,
        });
        if (result_4.error)
            return result_4;
    }
    var qualifyingParticipantIds = qualifyingParticipantsCount
        ? consideredParticipants
            .slice(participantsCount, participantsCount + qualifyingParticipantsCount)
            .map(function (p) { return p.participantId; })
        : 0;
    if (isMock && (qualifyingParticipantIds === null || qualifyingParticipantIds === void 0 ? void 0 : qualifyingParticipantIds.length)) {
        var qualifyingIndex = 0; // used to take slices of participants array
        var roundTarget = 1;
        var sequenceSort = function (a, b) { return a.stageSequence - b.stageSequence; };
        var roundTargetSort = function (a, b) { return a.roundTarget - b.roundTarget; };
        try {
            for (var _t = __values(qualifyingProfiles.sort(roundTargetSort)), _u = _t.next(); !_u.done; _u = _t.next()) {
                var roundTargetProfile = _u.value;
                roundTarget = roundTargetProfile.roundTarget || roundTarget;
                var entryStageSequence = 1;
                var qualifyingPositions_1 = void 0;
                try {
                    for (var _v = (e_2 = void 0, __values(roundTargetProfile.structureProfiles.sort(sequenceSort))), _w = _v.next(); !_w.done; _w = _v.next()) {
                        var structureProfile = _w.value;
                        var drawSize_1 = structureProfile.drawSize || coerceEven(structureProfile.participantsCount);
                        var participantsCount_1 = drawSize_1 - (qualifyingPositions_1 || 0); // minus qualifyingPositions
                        var participantIds_1 = qualifyingParticipantIds.slice(qualifyingIndex, qualifyingIndex + participantsCount_1);
                        var result_5 = addEventEntries({
                            entryStage: QUALIFYING,
                            entryStageSequence: entryStageSequence,
                            autoEntryPositions: autoEntryPositions,
                            tournamentRecord: tournamentRecord,
                            participantIds: participantIds_1,
                            roundTarget: roundTarget,
                            event: event,
                        });
                        if (result_5.error) {
                            return result_5;
                        }
                        qualifyingPositions_1 = structureProfile.qualifyingPositions;
                        qualifyingIndex += participantsCount_1;
                        entryStageSequence += 1;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_w && !_w.done && (_d = _v.return)) _d.call(_v);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                roundTarget += 1;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_u && !_u.done && (_c = _t.return)) _c.call(_t);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    // alternates can still be taken from existing participants
    // when unique participants are used for DIRECT_ACCEPTANCE entries
    var alternatesParticipantIds = excessParticipantAlternates &&
        ((_f = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) === null || _f === void 0 ? void 0 : _f.filter(function (_a) {
            var participantId = _a.participantId;
            return !participantIds.includes(participantId);
        }).filter(isEventParticipantType).filter(isEventGender).slice(0, alternatesCount || drawSize - participantsCount || tournamentAlternates).map(function (p) { return p.participantId; }));
    if (isMock && (alternatesParticipantIds === null || alternatesParticipantIds === void 0 ? void 0 : alternatesParticipantIds.length)) {
        var result_6 = addEventEntries({
            participantIds: alternatesParticipantIds,
            autoEntryPositions: false,
            entryStatus: ALTERNATE,
            tournamentRecord: tournamentRecord,
            event: event,
        });
        if (result_6.error)
            return result_6.error;
    }
    // now add seeding information for seedsCount participants
    var seedingScaleName = categoryName || eventName;
    if (tournamentRecord && seedsCount && seedsCount <= participantIds.length) {
        var scaleValues = generateRange(1, seedsCount + 1);
        scaleValues.forEach(function (scaleValue, index) {
            var scaleItem = {
                scaleName: seedingScaleName,
                scaleDate: startDate,
                scaleType: SEEDING,
                scaleValue: scaleValue,
                eventType: eventType,
            };
            var participantId = participantIds[index];
            setParticipantScaleItem({ tournamentRecord: tournamentRecord, participantId: participantId, scaleItem: scaleItem });
        });
    }
    var result = generateDrawDefinition(__assign(__assign({}, makeDeepCopy(drawProfile, false, true)), { tournamentRecord: tournamentRecord, seedingScaleName: seedingScaleName, matchUpFormat: matchUpFormat, eventId: eventId, isMock: isMock, event: event }));
    if (result.error)
        return result;
    if (!result.drawDefinition)
        return { error: DRAW_DEFINITION_NOT_FOUND };
    var drawDefinition = result.drawDefinition;
    var drawId = drawDefinition.drawId;
    if (Array.isArray(drawExtensions)) {
        drawExtensions
            .filter(isValidExtension)
            .forEach(function (extension) { return addExtension({ element: drawDefinition, extension: extension }); });
    }
    if (generate) {
        addDrawDefinition({ drawDefinition: drawDefinition, event: event, suppressNotifications: true });
        if (drawProfile.withPlayoffs) {
            var structureId = (_g = drawDefinition.structures) === null || _g === void 0 ? void 0 : _g[0].structureId;
            var result_7 = addPlayoffStructures(__assign(__assign({}, drawProfile.withPlayoffs), { tournamentRecord: tournamentRecord, drawDefinition: drawDefinition, structureId: structureId, idPrefix: idPrefix, isMock: isMock, event: event }));
            if (result_7 === null || result_7 === void 0 ? void 0 : result_7.error)
                return result_7;
        }
        var manual = drawProfile.automated === false;
        if (isMock && !manual) {
            // NOTE: completionGoal needs to come before outcomes array because setMatchUpStatus has integrity checks
            // ... which may require positionAssignments and/or drawPositions to have been propagated
            var goComplete = function (p) {
                var _a;
                var result = completeDrawMatchUps({
                    completeAllMatchUps: p.completeAllMatchUps,
                    completionGoal: p.completionGoal,
                    matchUpStatusProfile: matchUpStatusProfile,
                    // qualifyingProfiles,
                    randomWinningSide: randomWinningSide,
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    matchUpFormat: matchUpFormat,
                    event: event,
                });
                if (result.error)
                    return result;
                var completedCount = result.completedCount;
                if (drawType === ROUND_ROBIN_WITH_PLAYOFF) {
                    var mainStructure = (_a = drawDefinition.structures) === null || _a === void 0 ? void 0 : _a.find(function (structure) { return structure.stage === MAIN; });
                    if (!mainStructure)
                        return { error: STRUCTURE_NOT_FOUND };
                    automatedPlayoffPositioning({
                        structureId: mainStructure.structureId,
                        tournamentRecord: tournamentRecord,
                        drawDefinition: drawDefinition,
                        event: event,
                    });
                    // ignore when positioning cannot occur because of incomplete source structure
                    var playoffCompletionGoal = completionGoal ? completionGoal - (completedCount !== null && completedCount !== void 0 ? completedCount : 0) : undefined;
                    var result_8 = completeDrawMatchUps({
                        completionGoal: completionGoal ? playoffCompletionGoal : undefined,
                        matchUpStatusProfile: matchUpStatusProfile,
                        completeAllMatchUps: completeAllMatchUps,
                        randomWinningSide: randomWinningSide,
                        tournamentRecord: tournamentRecord,
                        drawDefinition: drawDefinition,
                        matchUpFormat: matchUpFormat,
                        event: event,
                    });
                    if (result_8.error)
                        return result_8;
                }
                // TODO: check if RRWPO & automate & complete
                return undefined;
            };
            // NOTE: completionGoal implies something less than "all matchUps"
            // ==> do this first with the assumption that any outcomes must come after
            if (completionGoal)
                goComplete({ completionGoal: completionGoal });
            if (drawProfile.outcomes) {
                var matchUps = allDrawMatchUps({
                    inContext: true,
                    drawDefinition: drawDefinition,
                    event: event,
                }).matchUps;
                var _loop_1 = function (outcomeDef) {
                    var _z = outcomeDef.matchUpStatus, matchUpStatus = _z === void 0 ? COMPLETED$1 : _z, matchUpStatusCodes = outcomeDef.matchUpStatusCodes, _0 = outcomeDef.stageSequence, stageSequence = _0 === void 0 ? 1 : _0, _1 = outcomeDef.matchUpIndex, matchUpIndex = _1 === void 0 ? 0 : _1, structureOrder = outcomeDef.structureOrder, // like a group number; for RR = the order of the structureType: ITEM within structureType: CONTAINER
                    matchUpFormat_1 = outcomeDef.matchUpFormat, drawPositions = outcomeDef.drawPositions, roundPosition = outcomeDef.roundPosition, _2 = outcomeDef.stage, stage_1 = _2 === void 0 ? MAIN : _2, roundNumber = outcomeDef.roundNumber, winningSide = outcomeDef.winningSide, scoreString = outcomeDef.scoreString;
                    var structureMatchUpIds = (_h = matchUps === null || matchUps === void 0 ? void 0 : matchUps.reduce(function (sm, matchUp) {
                        var structureId = matchUp.structureId, matchUpId = matchUp.matchUpId;
                        if (sm[structureId]) {
                            sm[structureId].push(matchUpId);
                        }
                        else {
                            sm[structureId] = [matchUpId];
                        }
                        return sm;
                    }, {})) !== null && _h !== void 0 ? _h : [];
                    var orderedStructures = Object.assign.apply(Object, __spreadArray([{}], __read(Object.keys(structureMatchUpIds).map(function (structureId, index) {
                        var _a;
                        return (_a = {},
                            _a[structureId] = index + 1,
                            _a);
                    })), false));
                    var targetMatchUps = matchUps === null || matchUps === void 0 ? void 0 : matchUps.filter(function (matchUp) {
                        return ((!stage_1 || matchUp.stage === stage_1) &&
                            (!stageSequence || matchUp.stageSequence === stageSequence) &&
                            (!roundNumber || matchUp.roundNumber === roundNumber) &&
                            (!roundPosition || matchUp.roundPosition === roundPosition) &&
                            (!structureOrder || orderedStructures[matchUp.structureId] === structureOrder) &&
                            (!drawPositions || intersection(drawPositions, matchUp.drawPositions).length === 2));
                    });
                    // targeting only one matchUp, specified by the index in the array of returned matchUps
                    var targetMatchUp = targetMatchUps === null || targetMatchUps === void 0 ? void 0 : targetMatchUps[matchUpIndex];
                    var result_9 = completeDrawMatchUp({
                        matchUpStatusCodes: matchUpStatusCodes,
                        tournamentRecord: tournamentRecord,
                        drawDefinition: drawDefinition,
                        targetMatchUp: targetMatchUp,
                        matchUpFormat: matchUpFormat_1,
                        matchUpStatus: matchUpStatus,
                        scoreString: scoreString,
                        winningSide: winningSide,
                    });
                    // will not throw errors for BYE matchUps
                    if (result_9 === null || result_9 === void 0 ? void 0 : result_9.error)
                        return { value: result_9 };
                };
                try {
                    for (var _x = __values(drawProfile.outcomes), _y = _x.next(); !_y.done; _y = _x.next()) {
                        var outcomeDef = _y.value;
                        var state_1 = _loop_1(outcomeDef);
                        if (typeof state_1 === "object")
                            return state_1.value;
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_y && !_y.done && (_e = _x.return)) _e.call(_x);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
            // NOTE: do this last => complete any matchUps which have not already been completed
            if (completeAllMatchUps)
                goComplete({ completeAllMatchUps: completeAllMatchUps });
        }
        if (publish) {
            publishEvent({ tournamentRecord: tournamentRecord, event: event });
        }
    }
    else {
        var result_10 = addFlight({
            drawEntries: drawDefinition.entries,
            drawName: drawName || drawType,
            qualifyingPositions: qualifyingPositions,
            drawId: drawId,
            event: event,
            stage: stage,
        });
        if (result_10.error) {
            return result_10;
        }
    }
    return __assign(__assign({}, SUCCESS), { event: definedAttributes(event), uniqueParticipantIds: uniqueParticipantIds, targetParticipants: targetParticipants, drawDefinition: drawDefinition, eventId: eventId, drawId: drawId });
}

var mockTournamentNames = [
    'Mock Tournament',
    'CourtHive Challenge',
    'Racket Rally',
    'Generated Tournament',
    'Factory Follies',
    'Open Competition',
];
function generateTournamentRecord(params) {
    var e_1, _a, _b, e_2, _c, e_3, _d, _e;
    var tournamentAttributes = params.tournamentAttributes, startDate = params.startDate, endDate = params.endDate;
    var _f = params.tournamentName, tournamentName = _f === void 0 ? randomPop(mockTournamentNames) : _f, _g = params.ratingsParameters, ratingsParameters$1 = _g === void 0 ? ratingsParameters : _g, scheduleCompletedMatchUps = params.scheduleCompletedMatchUps, tournamentExtensions = params.tournamentExtensions, matchUpStatusProfile = params.matchUpStatusProfile, completeAllMatchUps = params.completeAllMatchUps, participantsProfile = params.participantsProfile, autoEntryPositions = params.autoEntryPositions, hydrateCollections = params.hydrateCollections, randomWinningSide = params.randomWinningSide, policyDefinitions = params.policyDefinitions, schedulingProfile = params.schedulingProfile, periodLength = params.periodLength, autoSchedule = params.autoSchedule, eventProfiles = params.eventProfiles, venueProfiles = params.venueProfiles, drawProfiles = params.drawProfiles, uuids = params.uuids;
    if ((startDate && !isValidDateString(startDate)) || (endDate && !isValidDateString(endDate)))
        return { error: INVALID_DATE };
    if (eventProfiles && !Array.isArray(eventProfiles))
        return { error: INVALID_VALUES };
    if (!startDate) {
        var tournamentDate = new Date();
        startDate = formatDate(endDate !== null && endDate !== void 0 ? endDate : tournamentDate);
        endDate = formatDate(tournamentDate.setDate(tournamentDate.getDate() + 7));
    }
    if (!endDate) {
        var tournamentDate = new Date(startDate);
        endDate = formatDate(tournamentDate.setDate(tournamentDate.getDate() + 7));
    }
    if (typeof tournamentAttributes !== 'object')
        tournamentAttributes = {};
    var tournamentRecord = newTournamentRecord(__assign(__assign({}, tournamentAttributes), { tournamentName: tournamentName, isMock: true, startDate: startDate, endDate: endDate }));
    // attach any valid tournamentExtensions
    if ((tournamentExtensions === null || tournamentExtensions === void 0 ? void 0 : tournamentExtensions.length) && Array.isArray(tournamentExtensions)) {
        var extensions = tournamentExtensions.filter(function (extension) { return isValidExtension({ extension: extension }); });
        if (extensions === null || extensions === void 0 ? void 0 : extensions.length)
            Object.assign(tournamentRecord, { extensions: extensions, isMock: true });
    }
    if (typeof policyDefinitions === 'object') {
        try {
            for (var _h = __values(Object.keys(policyDefinitions)), _j = _h.next(); !_j.done; _j = _h.next()) {
                var policyType = _j.value;
                attachPolicies({
                    policyDefinitions: (_b = {}, _b[policyType] = policyDefinitions[policyType], _b),
                    tournamentRecord: tournamentRecord,
                });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_j && !_j.done && (_a = _h.return)) _a.call(_h);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    var result = addTournamentParticipants({
        participantsProfile: participantsProfile,
        tournamentRecord: tournamentRecord,
        eventProfiles: eventProfiles,
        drawProfiles: drawProfiles,
        startDate: startDate,
        uuids: uuids,
    });
    if (!result.success)
        return result;
    var allUniqueParticipantIds = [], eventIds = [], drawIds = [];
    if (Array.isArray(drawProfiles)) {
        var drawIndex = 0;
        try {
            for (var drawProfiles_1 = __values(drawProfiles), drawProfiles_1_1 = drawProfiles_1.next(); !drawProfiles_1_1.done; drawProfiles_1_1 = drawProfiles_1.next()) {
                var drawProfile = drawProfiles_1_1.value;
                var result_1 = generateEventWithDraw({
                    allUniqueParticipantIds: allUniqueParticipantIds,
                    matchUpStatusProfile: matchUpStatusProfile,
                    completeAllMatchUps: completeAllMatchUps,
                    autoEntryPositions: autoEntryPositions,
                    hydrateCollections: hydrateCollections,
                    participantsProfile: participantsProfile,
                    randomWinningSide: randomWinningSide,
                    ratingsParameters: ratingsParameters$1,
                    tournamentRecord: tournamentRecord,
                    isMock: true,
                    drawProfile: drawProfile,
                    startDate: startDate,
                    drawIndex: drawIndex,
                    uuids: uuids,
                });
                if (result_1.error)
                    return result_1;
                var drawId = result_1.drawId, eventId = result_1.eventId, event_1 = result_1.event, uniqueParticipantIds = result_1.uniqueParticipantIds;
                result_1 = addEvent({
                    suppressNotifications: false,
                    internalUse: true,
                    tournamentRecord: tournamentRecord,
                    event: event_1,
                });
                if (result_1.error)
                    return result_1;
                if (drawId)
                    drawIds.push(drawId);
                eventIds.push(eventId);
                if (uniqueParticipantIds === null || uniqueParticipantIds === void 0 ? void 0 : uniqueParticipantIds.length)
                    allUniqueParticipantIds.push.apply(allUniqueParticipantIds, __spreadArray([], __read(uniqueParticipantIds), false));
                drawIndex += 1;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (drawProfiles_1_1 && !drawProfiles_1_1.done && (_c = drawProfiles_1.return)) _c.call(drawProfiles_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    if (eventProfiles) {
        var eventIndex = 0;
        try {
            for (var eventProfiles_1 = __values(eventProfiles), eventProfiles_1_1 = eventProfiles_1.next(); !eventProfiles_1_1.done; eventProfiles_1_1 = eventProfiles_1.next()) {
                var eventProfile = eventProfiles_1_1.value;
                var result_2 = generateEventWithFlights({
                    allUniqueParticipantIds: allUniqueParticipantIds,
                    matchUpStatusProfile: matchUpStatusProfile,
                    participantsProfile: participantsProfile,
                    completeAllMatchUps: completeAllMatchUps,
                    autoEntryPositions: autoEntryPositions,
                    hydrateCollections: hydrateCollections,
                    randomWinningSide: randomWinningSide,
                    ratingsParameters: ratingsParameters$1,
                    tournamentRecord: tournamentRecord,
                    eventProfile: eventProfile,
                    eventIndex: eventIndex,
                    startDate: startDate,
                    uuids: uuids,
                });
                if (result_2.error)
                    return result_2;
                var eventId = result_2.eventId, generatedDrawIds = result_2.drawIds, uniqueParticipantIds = result_2.uniqueParticipantIds;
                if (generatedDrawIds)
                    drawIds.push.apply(drawIds, __spreadArray([], __read(generatedDrawIds), false));
                eventIds.push(eventId);
                if (uniqueParticipantIds === null || uniqueParticipantIds === void 0 ? void 0 : uniqueParticipantIds.length)
                    allUniqueParticipantIds.push.apply(allUniqueParticipantIds, __spreadArray([], __read(uniqueParticipantIds), false));
                eventIndex += 1;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (eventProfiles_1_1 && !eventProfiles_1_1.done && (_d = eventProfiles_1.return)) _d.call(eventProfiles_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    }
    var venueIds = (venueProfiles === null || venueProfiles === void 0 ? void 0 : venueProfiles.length) ? generateVenues({ tournamentRecord: tournamentRecord, venueProfiles: venueProfiles, uuids: uuids }) : [];
    var scheduledRounds;
    var schedulerResult = {};
    if (schedulingProfile) {
        var result_3 = generateScheduledRounds({
            schedulingProfile: schedulingProfile,
            tournamentRecord: tournamentRecord,
        });
        if (result_3.error)
            return result_3;
        scheduledRounds = result_3.scheduledRounds;
        if (autoSchedule) {
            var tournamentId = tournamentRecord.tournamentId;
            var tournamentRecords = (_e = {}, _e[tournamentId] = tournamentRecord, _e);
            schedulerResult = scheduleProfileRounds({
                scheduleCompletedMatchUps: scheduleCompletedMatchUps,
                tournamentRecords: tournamentRecords,
                periodLength: periodLength,
            });
        }
    }
    // clear globalState modified flag;
    cycleMutationStatus();
    return definedAttributes(__assign(__assign({}, SUCCESS), { tournamentRecord: tournamentRecord, scheduledRounds: scheduledRounds, schedulerResult: schedulerResult, eventIds: eventIds, venueIds: venueIds, drawIds: drawIds }));
}

function modifyTournamentRecord(params) {
    var e_1, _a, e_2, _b, _c, _d;
    var _e, _f, _g;
    var _h = params.ratingsParameters, ratingsParameters$1 = _h === void 0 ? ratingsParameters : _h, _j = params.participantsProfile, participantsProfile = _j === void 0 ? {} : _j, matchUpStatusProfile = params.matchUpStatusProfile, completeAllMatchUps = params.completeAllMatchUps, autoEntryPositions = params.autoEntryPositions, hydrateCollections = params.hydrateCollections, randomWinningSide = params.randomWinningSide, schedulingProfile = params.schedulingProfile, tournamentRecord = params.tournamentRecord, eventProfiles = params.eventProfiles, periodLength = params.periodLength, venueProfiles = params.venueProfiles, autoSchedule = params.autoSchedule, drawProfiles = params.drawProfiles, uuids = params.uuids;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var allUniqueParticipantIds = [];
    var eventIds = [];
    var drawIds = [];
    eventProfiles === null || eventProfiles === void 0 ? void 0 : eventProfiles.forEach(function (eventProfile) {
        var _a;
        var event = (_a = tournamentRecord.events) === null || _a === void 0 ? void 0 : _a.find(function (event, index) {
            return (eventProfile.eventIndex !== undefined &&
                index === eventProfile.eventIndex) ||
                (eventProfile.eventName &&
                    event.eventName === eventProfile.eventName) ||
                (eventProfile.eventId && event.eventId === eventProfile.eventId);
        });
        if (event === null || event === void 0 ? void 0 : event.gender) {
            eventProfile.gender = event.gender;
        }
    });
    var participantsCount = ((_e = tournamentRecord.participants) === null || _e === void 0 ? void 0 : _e.length) || undefined;
    if (participantsCount && (participantsProfile === null || participantsProfile === void 0 ? void 0 : participantsProfile.idPrefix)) {
        participantsProfile.idPrefix = "".concat(participantsProfile.idPrefix, "-").concat(participantsCount);
    }
    var result = addTournamentParticipants({
        startDate: tournamentRecord.startDate,
        participantsProfile: participantsProfile,
        tournamentRecord: tournamentRecord,
        eventProfiles: eventProfiles,
        drawProfiles: drawProfiles,
        uuids: uuids,
    });
    if (!result.success)
        return result;
    if (eventProfiles) {
        var eventIndex = ((_f = tournamentRecord.events) === null || _f === void 0 ? void 0 : _f.length) || 0;
        var _loop_1 = function (eventProfile) {
            var ratingsParameters_1 = eventProfile.ratingsParameters;
            var event_1 = (_g = tournamentRecord.events) === null || _g === void 0 ? void 0 : _g.find(function (event, index) {
                return (eventProfile.eventIndex !== undefined &&
                    index === eventProfile.eventIndex) ||
                    (eventProfile.eventName &&
                        event.eventName === eventProfile.eventName) ||
                    (eventProfile.eventId && event.eventId === eventProfile.eventId);
            });
            if (!event_1) {
                var result_1 = generateEventWithFlights({
                    startDate: tournamentRecord.startDate,
                    allUniqueParticipantIds: allUniqueParticipantIds,
                    matchUpStatusProfile: matchUpStatusProfile,
                    participantsProfile: participantsProfile,
                    completeAllMatchUps: completeAllMatchUps,
                    autoEntryPositions: autoEntryPositions,
                    randomWinningSide: randomWinningSide,
                    ratingsParameters: ratingsParameters_1,
                    tournamentRecord: tournamentRecord,
                    eventProfile: eventProfile,
                    eventIndex: eventIndex,
                    uuids: uuids,
                });
                if (result_1.error)
                    return { value: result_1 };
                var eventId = result_1.eventId, generatedDrawIds = result_1.drawIds, uniqueParticipantIds = result_1.uniqueParticipantIds;
                if (generatedDrawIds)
                    drawIds.push.apply(drawIds, __spreadArray([], __read(generatedDrawIds), false));
                eventIds.push(eventId);
                if (uniqueParticipantIds === null || uniqueParticipantIds === void 0 ? void 0 : uniqueParticipantIds.length)
                    allUniqueParticipantIds.push.apply(allUniqueParticipantIds, __spreadArray([], __read(uniqueParticipantIds), false));
                eventIndex += 1;
            }
            else {
                var gender = event_1.gender, category = event_1.category, eventType = event_1.eventType;
                var drawProfiles_2 = eventProfile.drawProfiles, publish = eventProfile.publish;
                var eventParticipantType = (eventType === SINGLES$1 && INDIVIDUAL) ||
                    (eventType === DOUBLES$1 && PAIR) ||
                    eventType;
                if (drawProfiles_2) {
                    var _k = getStageParticipantsCount({
                        drawProfiles: drawProfiles_2,
                        category: category,
                        gender: gender,
                    }), stageParticipantsCount = _k.stageParticipantsCount, uniqueParticipantsCount = _k.uniqueParticipantsCount, uniqueParticipantStages = _k.uniqueParticipantStages;
                    var _l = uniqueParticipantStages
                        ? generateEventParticipants({
                            event: { eventType: eventType, category: category, gender: gender },
                            uniqueParticipantsCount: uniqueParticipantsCount,
                            participantsProfile: participantsProfile,
                            ratingsParameters: ratingsParameters_1,
                            tournamentRecord: tournamentRecord,
                            eventProfile: eventProfile,
                            uuids: uuids,
                        })
                        : {}, _m = _l.uniqueDrawParticipants, uniqueDrawParticipants = _m === void 0 ? [] : _m, _o = _l.uniqueParticipantIds, uniqueParticipantIds = _o === void 0 ? [] : _o;
                    allUniqueParticipantIds.push.apply(allUniqueParticipantIds, __spreadArray([], __read(uniqueParticipantIds), false));
                    var stageParticipants = getStageParticipants({
                        targetParticipants: tournamentRecord.participants || [],
                        allUniqueParticipantIds: allUniqueParticipantIds,
                        stageParticipantsCount: stageParticipantsCount,
                        eventParticipantType: eventParticipantType,
                    }).stageParticipants;
                    var result_2 = generateFlights({
                        uniqueDrawParticipants: uniqueDrawParticipants,
                        autoEntryPositions: autoEntryPositions,
                        stageParticipants: stageParticipants,
                        tournamentRecord: tournamentRecord,
                        drawProfiles: drawProfiles_2,
                        category: category,
                        gender: gender,
                        event: event_1,
                    });
                    if (result_2.error)
                        return { value: result_2 };
                    result_2 = generateFlightDrawDefinitions({
                        matchUpStatusProfile: matchUpStatusProfile,
                        completeAllMatchUps: completeAllMatchUps,
                        randomWinningSide: randomWinningSide,
                        tournamentRecord: tournamentRecord,
                        drawProfiles: drawProfiles_2,
                        event: event_1,
                    });
                    if (result_2.error)
                        return { value: result_2 };
                    drawIds.push.apply(drawIds, __spreadArray([], __read(result_2.drawIds), false));
                }
                if (publish) {
                    publishEvent({ tournamentRecord: tournamentRecord, event: event_1 });
                }
            }
        };
        try {
            for (var eventProfiles_1 = __values(eventProfiles), eventProfiles_1_1 = eventProfiles_1.next(); !eventProfiles_1_1.done; eventProfiles_1_1 = eventProfiles_1.next()) {
                var eventProfile = eventProfiles_1_1.value;
                var state_1 = _loop_1(eventProfile);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (eventProfiles_1_1 && !eventProfiles_1_1.done && (_a = eventProfiles_1.return)) _a.call(eventProfiles_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    if (drawProfiles) {
        var drawIndex = (tournamentRecord.events || [])
            .map(function (event) { var _a; return ((_a = event.drawDefinitions) === null || _a === void 0 ? void 0 : _a.map(function () { return 1; })) || []; })
            .flat()
            .reduce(function (a, b) { return a + b; }, 0);
        try {
            for (var drawProfiles_1 = __values(drawProfiles), drawProfiles_1_1 = drawProfiles_1.next(); !drawProfiles_1_1.done; drawProfiles_1_1 = drawProfiles_1.next()) {
                var drawProfile = drawProfiles_1_1.value;
                var result_3 = generateEventWithDraw({
                    startDate: tournamentRecord.startDate,
                    allUniqueParticipantIds: allUniqueParticipantIds,
                    matchUpStatusProfile: matchUpStatusProfile,
                    participantsProfile: participantsProfile,
                    completeAllMatchUps: completeAllMatchUps,
                    autoEntryPositions: autoEntryPositions,
                    hydrateCollections: hydrateCollections,
                    randomWinningSide: randomWinningSide,
                    ratingsParameters: ratingsParameters$1,
                    tournamentRecord: tournamentRecord,
                    drawProfile: drawProfile,
                    drawIndex: drawIndex,
                    uuids: uuids,
                });
                if (result_3.error)
                    return result_3;
                var drawId = result_3.drawId, eventId = result_3.eventId, event_2 = result_3.event, uniqueParticipantIds = result_3.uniqueParticipantIds;
                result_3 = addEvent({ tournamentRecord: tournamentRecord, event: event_2, internalUse: true });
                if (result_3.error)
                    return result_3;
                if (drawId)
                    drawIds.push(drawId);
                eventIds.push(eventId);
                if (uniqueParticipantIds === null || uniqueParticipantIds === void 0 ? void 0 : uniqueParticipantIds.length)
                    allUniqueParticipantIds.push.apply(allUniqueParticipantIds, __spreadArray([], __read(uniqueParticipantIds), false));
                drawIndex += 1;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (drawProfiles_1_1 && !drawProfiles_1_1.done && (_b = drawProfiles_1.return)) _b.call(drawProfiles_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    var venueIds = (venueProfiles === null || venueProfiles === void 0 ? void 0 : venueProfiles.length)
        ? generateVenues({ tournamentRecord: tournamentRecord, venueProfiles: venueProfiles })
        : [];
    var scheduledRounds;
    var schedulerResult = {};
    if (schedulingProfile === null || schedulingProfile === void 0 ? void 0 : schedulingProfile.length) {
        var tournamentRecords = (_c = {},
            _c[tournamentRecord.tournamentId] = tournamentRecord,
            _c);
        var result_4 = setSchedulingProfile({
            tournamentRecords: tournamentRecords,
            schedulingProfile: schedulingProfile,
        });
        if (result_4.error)
            return result_4;
        if (autoSchedule) {
            var tournamentId = tournamentRecord.tournamentId;
            var tournamentRecords_1 = (_d = {}, _d[tournamentId] = tournamentRecord, _d);
            schedulerResult = scheduleProfileRounds({
                tournamentRecords: tournamentRecords_1,
                periodLength: periodLength,
            });
        }
    }
    var totalParticipantsCount = tournamentRecord.participants.length;
    return __assign(__assign({ totalParticipantsCount: totalParticipantsCount, scheduledRounds: scheduledRounds, schedulerResult: schedulerResult }, SUCCESS), { eventIds: eventIds, venueIds: venueIds, drawIds: drawIds });
}

function credits() {
    return "\n    This project would not have been possible without the generous input and patience\n    of tournament organizers and directors who worked with early versions of CourtHive/TMX.\n\n    Thanks to Pavel, Ivan, Mladen, Zdenko, Antonia, Jakov, Kreso, Barry, Jeff, Bobby... to name just a few. \n\n    The project would not have even begun without the support of Miro, or the introduction by Sretchko.\n    The project would not have succeeded without the enthusiasm of Randy and Bruce.\n    Thanks to serendipity and Luca and the ensuing TODS conversations with ITF.\n    Thanks to Scott and Jake for sanity checks, suggestions, and camaraderie.\n    Thanks to Zoran for inspiring the async support and getting into the weeds with subscriptions.\n    Thanks to Dave for backing the conversion of TMX 1.x source into the factory repository.\n    Thanks to Vuk and Pavle and Rich and Chris and Deepa for the direct engagement with the APIs.\n    Thanks to Joe for repeatedly challenging me and the many pointers to useful tooling.\n    Thanks to Shannon for the validation of the approach from his deep domain experience.\n    Thanks to Nikola for the ongoing camaraderie and explorations of what we can do with TODS.\n\n    And a special thanks to my family for putting up with the long days and weeks and months of coding\n    and conversations at all hours.\n  ";
}

var mocksGovernor = {
    generateOutcomeFromScoreString: generateOutcomeFromScoreString,
    anonymizeTournamentRecord: anonymizeTournamentRecord,
    generateTournamentRecord: generateTournamentRecord,
    modifyTournamentRecord: modifyTournamentRecord,
    generateEventWithDraw: generateEventWithDraw,
    generateParticipants: generateParticipants,
    parseScoreString: parseScoreString,
    generateOutcome: generateOutcome,
    credits: credits,
};

/**
 *
 * @param {object} tournamentRecord - passed in automatically by tournamentEngine
 * @param {string} groupingParticipantId - grouping participant to which participantIds are to be added
 * @param {string[]} individualParticipantIds - new value for individualParticipantIds array
 *
 */
function modifyIndividualParticipantIds(_a) {
    var individualParticipantIds = _a.individualParticipantIds, groupingParticipantId = _a.groupingParticipantId, tournamentRecord = _a.tournamentRecord;
    var stack = 'modifyIndividualParticipantIds';
    if (!tournamentRecord)
        return decorateResult({
            result: { error: MISSING_TOURNAMENT_RECORD },
            stack: stack,
        });
    if (!groupingParticipantId || !individualParticipantIds)
        return decorateResult({ result: { error: MISSING_VALUE }, stack: stack });
    var tournamentParticipants = tournamentRecord.participants || [];
    var groupingParticipant = tournamentParticipants.find(function (participant) {
        return participant.participantId === groupingParticipantId;
    });
    if (!groupingParticipant)
        return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack: stack });
    if (![TEAM$1, GROUP].includes(groupingParticipant.participantType)) {
        return decorateResult({
            result: { error: INVALID_PARTICIPANT_TYPE },
            context: {
                participantType: groupingParticipant.participantType,
            },
            stack: stack,
        });
    }
    // integrity chck to ensure only individuals can be added to groupings
    var invalidParticipantIds = individualParticipantIds.filter(function (participantId) {
        var participant = tournamentParticipants.find(function (tournamentParticipant) {
            return tournamentParticipant.participantId === participantId;
        });
        return (participant === null || participant === void 0 ? void 0 : participant.participantType) !== INDIVIDUAL;
    });
    if (invalidParticipantIds.length)
        return decorateResult({
            result: { error: INVALID_PARTICIPANT_IDS, invalidParticipantIds: invalidParticipantIds },
            stack: stack,
        });
    var existingIndividualParticipantIds = groupingParticipant.individualParticipantIds || [];
    var individualParticipantIdsToAdd = individualParticipantIds.filter(function (participantId) {
        return !existingIndividualParticipantIds.includes(participantId);
    });
    var individualParticipantIdsToRemove = existingIndividualParticipantIds.filter(function (participantId) {
        return !individualParticipantIds.includes(participantId);
    });
    var addResult = addIndividualParticipantIds({
        individualParticipantIds: individualParticipantIdsToAdd,
        groupingParticipantId: groupingParticipantId,
        tournamentRecord: tournamentRecord,
    });
    if (addResult.error)
        return decorateResult({ result: addResult, stack: stack });
    var removeResult = removeIndividualParticipantIds({
        individualParticipantIds: individualParticipantIdsToRemove,
        groupingParticipantId: groupingParticipantId,
        tournamentRecord: tournamentRecord,
    });
    if (removeResult.error)
        return decorateResult({ result: removeResult, stack: stack });
    var topics = getTopics().topics;
    if (topics.includes(MODIFY_PARTICIPANTS)) {
        var updatedParticipant = tournamentParticipants.find(function (_a) {
            var participantId = _a.participantId;
            return participantId === groupingParticipantId;
        });
        addNotice({
            topic: MODIFY_PARTICIPANTS,
            payload: {
                tournamentId: tournamentRecord.tournamentId,
                participants: [updatedParticipant],
            },
        });
    }
    return __assign(__assign({}, addResult), removeResult);
}

function modifyParticipantsSignInStatus(_a) {
    var e_1, _b;
    var tournamentRecord = _a.tournamentRecord, participantIds = _a.participantIds, signInState = _a.signInState;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!Array.isArray(participantIds))
        return { error: MISSING_VALUE };
    var validSignInState = [SIGNED_IN, SIGNED_OUT].includes(signInState);
    if (!validSignInState)
        return { error: INVALID_VALUES, signInState: signInState };
    var participants = tournamentRecord.participants || [];
    if (!participants.length)
        return { error: MISSING_PARTICIPANTS };
    var allParticipantIds = participants.map(getParticipantId);
    var invalidParticipantIds = participantIds.filter(function (participantId) { return !allParticipantIds.includes(participantId); });
    if (invalidParticipantIds.length)
        return { error: INVALID_VALUES, context: { invalidParticipantIds: invalidParticipantIds } };
    var modifiedParticipants = [];
    var createdAt = new Date().toISOString();
    try {
        for (var participants_1 = __values(participants), participants_1_1 = participants_1.next(); !participants_1_1.done; participants_1_1 = participants_1.next()) {
            var participant = participants_1_1.value;
            var participantId = participant.participantId;
            if (participantIds.includes(participantId)) {
                var timeItem = {
                    itemType: SIGN_IN_STATUS,
                    itemValue: signInState,
                    createdAt: createdAt,
                };
                var result = addParticipantTimeItem({
                    duplicateValues: false,
                    tournamentRecord: tournamentRecord,
                    participantId: participantId,
                    timeItem: timeItem,
                });
                if (result.error)
                    return result;
                modifiedParticipants.push(participant);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (participants_1_1 && !participants_1_1.done && (_b = participants_1.return)) _b.call(participants_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var topics = getTopics().topics;
    if (modifiedParticipants.length && topics.includes(MODIFY_PARTICIPANTS)) {
        addNotice({
            topic: MODIFY_PARTICIPANTS,
            payload: {
                tournamentId: tournamentRecord.tournamentId,
                participants: modifiedParticipants,
            },
        });
    }
    return __assign({}, SUCCESS);
}

function modifyParticipantOtherName(_a) {
    var tournamentRecord = _a.tournamentRecord, participantId = _a.participantId, participantOtherName = _a.participantOtherName;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!participantId)
        return { error: MISSING_PARTICIPANT_ID };
    var participant = findTournamentParticipant({
        tournamentRecord: tournamentRecord,
        participantId: participantId,
    }).participant;
    if (!participant)
        return { error: PARTICIPANT_NOT_FOUND };
    participant.participantOtherName = participantOtherName;
    var topics = getTopics().topics;
    if (topics.includes(MODIFY_PARTICIPANTS)) {
        addNotice({
            topic: MODIFY_PARTICIPANTS,
            payload: {
                tournamentId: tournamentRecord.tournamentId,
                participants: [participant],
            },
        });
    }
    return __assign({}, SUCCESS);
}

function formatPersonName(_a) {
    var _b, _c;
    var personFormat = _a.personFormat, person = _a.person;
    var alpha = function (str) { return str.replace(/\W/g, ''); };
    var allLowerCase = function (str) { return /^[a-z]*$/.test(alpha(str)); };
    var allUpperCase = function (str) { return /^[A-Z]*$/.test(alpha(str)); };
    var lastUpperCase = function (str) { return /^[LAST]{4}/.test(alpha(str)); };
    var lastFirst = function (str) {
        return str.toLowerCase().indexOf('l') < str.toLowerCase().indexOf('f');
    };
    var commaSeparated = function (str) { return str.indexOf(',') >= 0; };
    var firstInital = function (str) { return str.toLowerCase().indexOf('f.') >= 0; };
    var lastNameOnly = function (str) { return str.toLowerCase().indexOf('f') < 0; };
    var hasSpacing = function (str) { return str.indexOf(' ') > 0; };
    if (!person)
        return;
    var spacer = hasSpacing(personFormat) ? ' ' : '';
    var firstName = capitalizeFirst((_b = person === null || person === void 0 ? void 0 : person.standardGivenName) !== null && _b !== void 0 ? _b : '');
    var lastName = capitalizeFirst((_c = person === null || person === void 0 ? void 0 : person.standardFamilyName) !== null && _c !== void 0 ? _c : '');
    if (!personFormat)
        return "".concat(firstName).concat(spacer).concat(lastName);
    if (firstInital(personFormat) &&
        !commaSeparated(personFormat) &&
        !lastFirst(personFormat)) {
        firstName = "".concat(firstName[0], ".");
    }
    if (allLowerCase(personFormat)) {
        firstName = firstName.toLowerCase();
        lastName = lastName.toLowerCase();
    }
    else if (allUpperCase(personFormat)) {
        firstName = firstName.toUpperCase();
        lastName = lastName.toUpperCase();
    }
    else if (lastUpperCase(personFormat)) {
        lastName = lastName.toUpperCase();
    }
    var participantName = "".concat(firstName).concat(spacer).concat(lastName);
    if (lastNameOnly(personFormat)) {
        participantName = lastName;
    }
    else if (lastFirst(personFormat)) {
        if (commaSeparated(personFormat)) {
            participantName = "".concat(lastName, ",").concat(spacer).concat(firstName);
        }
        else {
            participantName = "".concat(lastName).concat(spacer).concat(firstName);
        }
    }
    return participantName;
}

function formatParticipantName(_a) {
    var participantMap = _a.participantMap, participant = _a.participant, formats = _a.formats;
    var participantType = participant.participantType, individualParticipantIds = participant.individualParticipantIds, person = participant.person;
    var format = participantType && formats[participantType];
    if (participantType === TEAM_PARTICIPANT)
        return;
    if (format) {
        var personFormat_1 = format.personFormat, doublesJoiner = format.doublesJoiner;
        if (participantType === INDIVIDUAL) {
            participant.participantName = formatPersonName({ person: person, personFormat: personFormat_1 });
        }
        if (participantType === PAIR) {
            participant.participantName = individualParticipantIds === null || individualParticipantIds === void 0 ? void 0 : individualParticipantIds.map(function (id) {
                var _a;
                var person = (_a = participantMap[id]) === null || _a === void 0 ? void 0 : _a.person;
                return formatPersonName({ person: person, personFormat: personFormat_1 });
            }).filter(Boolean).join(doublesJoiner !== null && doublesJoiner !== void 0 ? doublesJoiner : '/');
        }
    }
}

function regenerateParticipantNames(_a) {
    var e_1, _b;
    var _c;
    var tournamentRecord = _a.tournamentRecord, formats = _a.formats;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!isObject(formats))
        return { error: MISSING_VALUE };
    var participants = (_c = tournamentRecord.participants) !== null && _c !== void 0 ? _c : [];
    var participantMap = createMap(participants, 'participantId');
    try {
        for (var participants_1 = __values(participants), participants_1_1 = participants_1.next(); !participants_1_1.done; participants_1_1 = participants_1.next()) {
            var participant = participants_1_1.value;
            formatParticipantName({ participant: participant, participantMap: participantMap, formats: formats });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (participants_1_1 && !participants_1_1.done && (_b = participants_1.return)) _b.call(participants_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}

function createGroupParticipant(_a) {
    var e_1, _b;
    var _c;
    var _d = _a.individualParticipantIds, individualParticipantIds = _d === void 0 ? [] : _d, participantRoleResponsibilities = _a.participantRoleResponsibilities, _e = _a.participantRole, participantRole = _e === void 0 ? OTHER$1 : _e, tournamentRecord = _a.tournamentRecord, participantId = _a.participantId, groupName = _a.groupName;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!groupName)
        return { error: MISSING_VALUE, info: 'Missing groupName' };
    if (!Array.isArray(individualParticipantIds))
        return {
            info: 'Invalid individualParticipantIds',
            error: INVALID_VALUES,
        };
    var participants = (_c = getParticipants({
        participantFilters: { participantTypes: [INDIVIDUAL] },
        tournamentRecord: tournamentRecord,
    }).participants) !== null && _c !== void 0 ? _c : [];
    var tournamentIndividualParticipantIds = participants.map(function (participant) { return participant.participantId; });
    try {
        for (var individualParticipantIds_1 = __values(individualParticipantIds), individualParticipantIds_1_1 = individualParticipantIds_1.next(); !individualParticipantIds_1_1.done; individualParticipantIds_1_1 = individualParticipantIds_1.next()) {
            var participantId_1 = individualParticipantIds_1_1.value;
            if (!tournamentIndividualParticipantIds.includes(participantId_1)) {
                return { error: INVALID_PARTICIPANT_TYPE, participantId: participantId_1 };
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (individualParticipantIds_1_1 && !individualParticipantIds_1_1.done && (_b = individualParticipantIds_1.return)) _b.call(individualParticipantIds_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var groupParticipant = definedAttributes({
        participantId: participantId || UUID(),
        participantRoleResponsibilities: participantRoleResponsibilities,
        participantName: groupName,
        individualParticipantIds: individualParticipantIds,
        participantType: GROUP,
        participantRole: participantRole,
    });
    var result = addParticipant({
        participant: groupParticipant,
        tournamentRecord: tournamentRecord,
    });
    if (result.error)
        return result;
    var topics = getTopics().topics;
    if (topics.includes(ADD_PARTICIPANTS)) {
        addNotice({
            topic: ADD_PARTICIPANTS,
            payload: {
                tournamentId: tournamentRecord.tournamentId,
                participants: [groupParticipant],
            },
        });
    }
    return __assign(__assign({}, SUCCESS), { participant: makeDeepCopy(groupParticipant) });
}

function modifyParticipantName(_a) {
    var tournamentRecord = _a.tournamentRecord, participantName = _a.participantName, participantId = _a.participantId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!participantId)
        return { error: MISSING_PARTICIPANT_ID };
    if (!participantName)
        return { error: MISSING_VALUE, info: 'Missing participantName' };
    var participant = findTournamentParticipant({
        tournamentRecord: tournamentRecord,
        participantId: participantId,
    }).participant;
    if (!participant)
        return { error: PARTICIPANT_NOT_FOUND };
    participant.participantName = participantName;
    var topics = getTopics().topics;
    if (topics.includes(MODIFY_PARTICIPANTS)) {
        addNotice({
            topic: MODIFY_PARTICIPANTS,
            payload: {
                tournamentId: tournamentRecord.tournamentId,
                participants: [participant],
            },
        });
    }
    return __assign({}, SUCCESS);
}

function scaledTeamAssignment(_a) {
    var _b, e_1, _c, e_2, _d, e_3, _e, e_4, _f, e_5, _g, e_6, _h, e_7, _j;
    var _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
    var _x = _a.clearExistingAssignments, clearExistingAssignments = _x === void 0 ? true : _x, // by default remove all existing individualParticipantIds from targeted teams
    individualParticipantIds = _a.individualParticipantIds, // if scaledParticipants are provided, individualParticipants is ignored
    reverseAssignmentOrder = _a.reverseAssignmentOrder, // optional - reverses team order; useful for sequential assignment of participant groupings to ensure balanced distribution
    _y = _a.initialTeamIndex, // optional - reverses team order; useful for sequential assignment of participant groupings to ensure balanced distribution
    initialTeamIndex = _y === void 0 ? 0 : _y, // optional - allows assignment to begin at a specified array index; useful for sequential assignment of groups of scaledParticipants
    _z = _a.scaledParticipants, // optional - allows assignment to begin at a specified array index; useful for sequential assignment of groups of scaledParticipants
    scaledParticipants = _z === void 0 ? [] : _z, // optional - either scaledParticipants or (individualParticipantIds and scaleName) must be provided
    teamParticipantIds = _a.teamParticipantIds, // optional, IF teamsCount is provided then teams will be created
    tournamentRecord = _a.tournamentRecord, // supplied automatically by tournamentEngine
    scaleAttributes = _a.scaleAttributes, // ignored if scaledParticipants are provided; { scaleName, scaleType, sortOrder, eventType }
    teamNameBase = _a.teamNameBase, // optional - defaults to '[categoryName] TEAM #', where categoryName is derived from eventId (if supplied)
    teamsCount = _a.teamsCount, // optional - derived from teamParticipantIds (if provided) - create # of teams if teamParticipantIds provided are insufficient
    eventId = _a.eventId, // optional - source teamParticipantIds from DIRECT_ACCEPTANCE participants in a TEAM event
    event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if ((!Array.isArray(teamParticipantIds) &&
        !isConvertableInteger(teamsCount) &&
        !eventId) ||
        !isConvertableInteger(initialTeamIndex) ||
        (scaledParticipants && !Array.isArray(scaledParticipants)) ||
        (scaleAttributes &&
            (typeof scaleAttributes !== 'object' ||
                !Object.keys(scaleAttributes).length))) {
        return { error: INVALID_VALUES };
    }
    if ((!scaleAttributes && !scaledParticipants.length) ||
        (!scaledParticipants && !(individualParticipantIds && scaleAttributes))) {
        return { error: MISSING_VALUE, info: 'Missing scaling details' };
    }
    if (eventId && !teamParticipantIds) {
        if ((event === null || event === void 0 ? void 0 : event.eventType) !== TEAM_EVENT)
            return { error: INVALID_EVENT_TYPE };
        teamParticipantIds = (_k = event === null || event === void 0 ? void 0 : event.entries) === null || _k === void 0 ? void 0 : _k.filter(function (_a) {
            var entryStatus = _a.entryStatus;
            return entryStatus === DIRECT_ACCEPTANCE;
        }).map(getParticipantId);
    }
    if (!(teamParticipantIds === null || teamParticipantIds === void 0 ? void 0 : teamParticipantIds.length) && !teamsCount) {
        return {
            info: 'Missing teamParticipantIds or teamsCount',
            error: MISSING_VALUE,
        };
    }
    var participantIdsToAssign = individualParticipantIds !== null && individualParticipantIds !== void 0 ? individualParticipantIds : scaledParticipants.map(function (_a) {
        var participantId = _a.participantId;
        return participantId;
    });
    if (reverseAssignmentOrder) {
        teamParticipantIds === null || teamParticipantIds === void 0 ? void 0 : teamParticipantIds.reverse();
        initialTeamIndex += 1; // ensures that the targeted team remains the first team to receive an assignment
    }
    if (initialTeamIndex > ((teamParticipantIds === null || teamParticipantIds === void 0 ? void 0 : teamParticipantIds.length) || 0) - 1)
        initialTeamIndex = 0;
    var orderedTeamParticipantIds = (_l = teamParticipantIds === null || teamParticipantIds === void 0 ? void 0 : (_b = teamParticipantIds.slice(initialTeamIndex)).concat.apply(_b, __spreadArray([], __read(teamParticipantIds.slice(0, initialTeamIndex)), false))) !== null && _l !== void 0 ? _l : [];
    var relevantTeams = [];
    try {
        // build up an array of targeted TEAM participants
        for (var _0 = __values((_m = tournamentRecord.participants) !== null && _m !== void 0 ? _m : []), _1 = _0.next(); !_1.done; _1 = _0.next()) {
            var participant = _1.value;
            var participantId = participant.participantId, participantType = participant.participantType;
            if (!orderedTeamParticipantIds.includes(participantId))
                continue;
            if (participantType !== TEAM_PARTICIPANT)
                return { error: INVALID_PARTICIPANT_TYPE, participant: participant };
            relevantTeams.push(participant);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_1 && !_1.done && (_c = _0.return)) _c.call(_0);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (teamsCount && relevantTeams.length < teamsCount) {
        var addCount = teamsCount - ((relevantTeams === null || relevantTeams === void 0 ? void 0 : relevantTeams.length) || 0);
        var nameBase_1 = teamNameBase !== null && teamNameBase !== void 0 ? teamNameBase : 'Team';
        var teamParticipants = generateRange(0, addCount).map(function (i) { return ({
            participantName: "".concat(nameBase_1, " ").concat(i + 1),
            participantType: TEAM_PARTICIPANT,
            participantRole: COMPETITOR,
        }); });
        var _2 = addParticipants({
            participants: teamParticipants,
            returnParticipants: true,
            tournamentRecord: tournamentRecord,
        }).participants, participants = _2 === void 0 ? [] : _2;
        var addedParticipantIds_1 = participants.map(getParticipantId);
        var addedParticipants = (_p = (_o = tournamentRecord.participants) === null || _o === void 0 ? void 0 : _o.filter(function (_a) {
            var participantId = _a.participantId;
            return addedParticipantIds_1.includes(participantId);
        })) !== null && _p !== void 0 ? _p : [];
        relevantTeams.push.apply(relevantTeams, __spreadArray([], __read(addedParticipants), false));
    }
    if (!relevantTeams.length)
        return { error: TEAM_NOT_FOUND };
    if (clearExistingAssignments) {
        try {
            // clear pre-existing individualParticipantIds
            for (var relevantTeams_1 = __values(relevantTeams), relevantTeams_1_1 = relevantTeams_1.next(); !relevantTeams_1_1.done; relevantTeams_1_1 = relevantTeams_1.next()) {
                var relevantTeam = relevantTeams_1_1.value;
                relevantTeam.individualParticipantIds = [];
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (relevantTeams_1_1 && !relevantTeams_1_1.done && (_d = relevantTeams_1.return)) _d.call(relevantTeams_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    else {
        var preAssignedParticipantIds_1 = relevantTeams
            .map(function (individualParticipantIds) { return individualParticipantIds; })
            .flat();
        if (individualParticipantIds === null || individualParticipantIds === void 0 ? void 0 : individualParticipantIds.length) {
            participantIdsToAssign = participantIdsToAssign.filter(function (participantId) { return !preAssignedParticipantIds_1.includes(participantId); });
        }
        else {
            scaledParticipants = scaledParticipants === null || scaledParticipants === void 0 ? void 0 : scaledParticipants.filter(function (_a) {
                var participantId = _a.participantId;
                return !preAssignedParticipantIds_1.includes(participantId);
            });
        }
    }
    if (!(individualParticipantIds === null || individualParticipantIds === void 0 ? void 0 : individualParticipantIds.length) && !(scaledParticipants === null || scaledParticipants === void 0 ? void 0 : scaledParticipants.length)) {
        return { error: NO_CANDIDATES, info: 'Nothing to be done' };
    }
    if (!scaledParticipants.length) {
        try {
            for (var _3 = __values((_q = tournamentRecord.participants) !== null && _q !== void 0 ? _q : []), _4 = _3.next(); !_4.done; _4 = _3.next()) {
                var participant = _4.value;
                var participantId = participant.participantId, participantType = participant.participantType;
                if (!participantIdsToAssign.includes(participantId))
                    continue;
                if (participantType !== INDIVIDUAL)
                    return { error: INVALID_PARTICIPANT_TYPE, participant: participant };
                var scaleItem = (_r = participantScaleItem({
                    scaleAttributes: scaleAttributes,
                    participant: participant,
                })) === null || _r === void 0 ? void 0 : _r.scaleItem;
                var scaleValue = (scaleAttributes === null || scaleAttributes === void 0 ? void 0 : scaleAttributes.accessor)
                    ? (_s = scaleItem === null || scaleItem === void 0 ? void 0 : scaleItem.scaleValue) === null || _s === void 0 ? void 0 : _s[scaleAttributes === null || scaleAttributes === void 0 ? void 0 : scaleAttributes.accessor]
                    : scaleItem === null || scaleItem === void 0 ? void 0 : scaleItem.scaleValue;
                var scaledParticipant = { participantId: participantId, scaleValue: scaleValue };
                scaledParticipants.push(scaledParticipant);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_4 && !_4.done && (_e = _3.return)) _e.call(_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (!scaledParticipants.length)
            return { error: PARTICIPANT_NOT_FOUND };
    }
    scaledParticipants.sort(function (a, b) {
        return (scaleAttributes === null || scaleAttributes === void 0 ? void 0 : scaleAttributes.sortOrder)
            ? ((b === null || b === void 0 ? void 0 : b.scaleValue) || 0) - ((a === null || a === void 0 ? void 0 : a.scaleValue) || 0)
            : ((a === null || a === void 0 ? void 0 : a.scaleValue) || Infinity) - ((b === null || b === void 0 ? void 0 : b.scaleValue) || Infinity);
    });
    try {
        for (var scaledParticipants_1 = __values(scaledParticipants), scaledParticipants_1_1 = scaledParticipants_1.next(); !scaledParticipants_1_1.done; scaledParticipants_1_1 = scaledParticipants_1.next()) {
            var scaledParticipant = scaledParticipants_1_1.value;
            if (!scaledParticipant.participantId)
                return { error: INVALID_VALUES, scaledParticipant: scaledParticipant };
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (scaledParticipants_1_1 && !scaledParticipants_1_1.done && (_f = scaledParticipants_1.return)) _f.call(scaledParticipants_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    var index = 0;
    while (index < scaledParticipants.length) {
        try {
            for (var relevantTeams_2 = (e_5 = void 0, __values(relevantTeams)), relevantTeams_2_1 = relevantTeams_2.next(); !relevantTeams_2_1.done; relevantTeams_2_1 = relevantTeams_2.next()) {
                var relevantTeam = relevantTeams_2_1.value;
                if (index + 1 > scaledParticipants.length)
                    break;
                var scaledParticipant = scaledParticipants[index];
                relevantTeam.individualParticipantIds.push(scaledParticipant.participantId);
                index++;
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (relevantTeams_2_1 && !relevantTeams_2_1.done && (_g = relevantTeams_2.return)) _g.call(relevantTeams_2);
            }
            finally { if (e_5) throw e_5.error; }
        }
        relevantTeams.reverse();
    }
    var relevantTeamParticipantIds = relevantTeams.map(getParticipantId);
    try {
        // for all events, check if any relevant teams are present
        // if a relevant team is present, remove any UNGROUPED participants that are part of that team
        for (var _5 = __values((_t = tournamentRecord.events) !== null && _t !== void 0 ? _t : []), _6 = _5.next(); !_6.done; _6 = _5.next()) {
            var event_1 = _6.value;
            if (event_1.eventType !== TEAM_EVENT)
                continue;
            var relevantTeamEntries = ((_u = event_1.entries) !== null && _u !== void 0 ? _u : []).filter(function (entry) {
                return relevantTeamParticipantIds.includes(entry.participantId);
            });
            var _loop_1 = function (relevantEntry) {
                var relevantTeamParticipantId = relevantEntry.participantId;
                var relevantTeam = relevantTeams.find(function (teamParticipant) {
                    return teamParticipant.participantId === relevantTeamParticipantId;
                });
                var individualParticipantIds_1 = relevantTeam === null || relevantTeam === void 0 ? void 0 : relevantTeam.individualParticipantIds;
                // remove any relevant individualParticipant entries from event.entries
                event_1.entries = ((_v = event_1.entries) !== null && _v !== void 0 ? _v : []).filter(function (entry) { return !individualParticipantIds_1.includes(entry.participantId); });
                // also remove any relevant individualParticipant entries from drawDefinition.entries
                ((_w = event_1.drawDefinitions) !== null && _w !== void 0 ? _w : []).forEach(function (drawDefinition) {
                    var _a;
                    drawDefinition.entries = ((_a = drawDefinition.entries) !== null && _a !== void 0 ? _a : []).filter(function (entry) { return !individualParticipantIds_1.includes(entry.participantId); });
                });
                // also remove any relevant individualParticipant any flight.drawEntries
                var flightProfile = getFlightProfile({ event: event_1 }).flightProfile;
                ((flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) || []).forEach(function (flight) {
                    flight.drawEntries = (flight.drawEntries || []).filter(function (entry) { return !individualParticipantIds_1.includes(entry.participantId); });
                });
            };
            try {
                for (var relevantTeamEntries_1 = (e_7 = void 0, __values(relevantTeamEntries)), relevantTeamEntries_1_1 = relevantTeamEntries_1.next(); !relevantTeamEntries_1_1.done; relevantTeamEntries_1_1 = relevantTeamEntries_1.next()) {
                    var relevantEntry = relevantTeamEntries_1_1.value;
                    _loop_1(relevantEntry);
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (relevantTeamEntries_1_1 && !relevantTeamEntries_1_1.done && (_j = relevantTeamEntries_1.return)) _j.call(relevantTeamEntries_1);
                }
                finally { if (e_7) throw e_7.error; }
            }
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (_6 && !_6.done && (_h = _5.return)) _h.call(_5);
        }
        finally { if (e_6) throw e_6.error; }
    }
    return __assign(__assign({}, SUCCESS), { scaledParticipants: scaledParticipants });
}

function removePenalty(params) {
    var e_1, _a;
    var tournamentRecords = params.tournamentRecords;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    try {
        for (var _b = __values(Object.values(tournamentRecords)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var tournamentRecord = _c.value;
            var result = penaltyRemove(__assign(__assign({}, params), { tournamentRecord: tournamentRecord }));
            if (result.error && result.error !== PENALTY_NOT_FOUND)
                return result;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}
function penaltyRemove(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, penaltyId = _a.penaltyId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!penaltyId)
        return { error: MISSING_PENALTY_ID };
    var participants = (_b = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) !== null && _b !== void 0 ? _b : [];
    var modifiedParticipants = [];
    var penaltyRemoved = false;
    var removedPenalty;
    participants.forEach(function (participant) {
        var _a;
        var participantModified = false;
        participant.penalties = ((_a = participant.penalties) !== null && _a !== void 0 ? _a : []).filter(function (penalty) {
            if (penalty.penaltyId === penaltyId) {
                participantModified = true;
                if (!penaltyRemoved) {
                    removedPenalty = penalty;
                    penaltyRemoved = true;
                }
            }
            if (participantModified)
                modifiedParticipants.push(participant);
            return penalty.penaltyId !== penaltyId;
        });
    });
    if (removedPenalty) {
        addNotice({
            topic: MODIFY_PARTICIPANTS,
            payload: {
                tournamentId: tournamentRecord.tournamentId,
                participants: modifiedParticipants,
            },
        });
    }
    return removedPenalty
        ? __assign(__assign({}, SUCCESS), { penalty: removedPenalty }) : { error: PENALTY_NOT_FOUND };
}

var penaltyTemplate = function (_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.penaltyId, penaltyId = _c === void 0 ? UUID() : _c;
    return ({
        refereeParticipantId: undefined,
        penaltyCode: undefined,
        penaltyType: undefined,
        extensions: undefined,
        matchUpId: undefined,
        createdAt: undefined,
        issuedAt: undefined,
        notes: undefined,
        penaltyId: penaltyId,
    });
};

function modifyPenalty(params) {
    var e_1, _a;
    var tournamentRecords = params.tournamentRecords;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    try {
        for (var _b = __values(Object.values(tournamentRecords)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var tournamentRecord = _c.value;
            var result = penaltyModify(__assign(__assign({}, params), { tournamentRecord: tournamentRecord }));
            if (result.error && result.error !== PENALTY_NOT_FOUND)
                return result;
            if (result.success)
                return result;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { error: PENALTY_NOT_FOUND };
}
function penaltyModify(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, modifications = _a.modifications, penaltyId = _a.penaltyId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!modifications)
        return { error: INVALID_VALUES, modifications: modifications };
    if (!penaltyId)
        return { error: MISSING_PENALTY_ID };
    var participants = (_b = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) !== null && _b !== void 0 ? _b : [];
    var validAttributes = Object.keys(penaltyTemplate()).filter(function (attribute) { return attribute !== 'penaltyId'; });
    var validModificationAttributes = Object.keys(modifications).filter(function (attribute) { return validAttributes.includes(attribute); });
    if (!validModificationAttributes.length)
        return { error: NO_VALID_ATTRIBUTES };
    var updatedPenalty;
    var modifiedParticipants = [];
    participants.forEach(function (participant) {
        var _a;
        var participantModified = false;
        participant.penalties = ((_a = participant.penalties) !== null && _a !== void 0 ? _a : []).map(function (penalty) {
            if (penalty.penaltyId === penaltyId) {
                participantModified = true;
                validModificationAttributes.forEach(function (attribute) {
                    var _a;
                    return Object.assign(penalty, (_a = {}, _a[attribute] = modifications[attribute], _a));
                });
                if (!updatedPenalty)
                    updatedPenalty = penalty;
            }
            return penalty;
        });
        if (participantModified)
            modifiedParticipants.push(participant);
    });
    if (updatedPenalty) {
        addNotice({
            topic: MODIFY_PARTICIPANTS,
            payload: {
                tournamentId: tournamentRecord.tournamentId,
                participants: modifiedParticipants,
            },
        });
    }
    return updatedPenalty
        ? __assign(__assign({}, SUCCESS), { penalty: updatedPenalty }) : { error: PENALTY_NOT_FOUND };
}

// arrayMerge can be boolean or an array of target attributes which are arrays to merge
function deepMerge(existing, incoming, arrayMerge) {
    if (!existing && incoming)
        return incoming;
    if (existing && !incoming)
        return existing;
    if (typeof existing !== 'object' || typeof incoming !== 'object')
        return existing;
    var keys = unique(Object.keys(existing).concat(Object.keys(incoming)));
    return keys.reduce(function (merged, key) {
        if (!incoming[key]) {
            merged[key] = existing[key];
        }
        else if (!existing[key]) {
            merged[key] = incoming[key];
        }
        else if (typeof existing[key] !== typeof incoming[key]) {
            merged[key] = incoming[key];
        }
        else if (Array.isArray(existing[key])) {
            if (arrayMerge === true ||
                (Array.isArray(arrayMerge) && arrayMerge.includes(key))) {
                var mergedArrays = unique(existing[key]
                    .map(function (e) { return JSON.stringify(e); })
                    .concat(incoming[key].map(function (i) { return JSON.stringify(i); }))).map(function (u) { return JSON.parse(u); });
                merged[key] = mergedArrays;
            }
            else {
                // default is to overwrite existing array with incoming
                merged[key] = incoming[key];
            }
        }
        else if (typeof existing[key] === 'object') {
            merged[key] = deepMerge(existing[key], incoming[key], arrayMerge);
        }
        else {
            merged[key] = incoming[key];
        }
        return merged;
    }, {});
}

function mergeParticipants(_a) {
    var _b;
    var _c = _a.participants, incomingParticipants = _c === void 0 ? [] : _c, tournamentRecord = _a.tournamentRecord, arraysToMerge = _a.arraysToMerge;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!tournamentRecord.participants)
        tournamentRecord.participants = [];
    var mappedParticipants = incomingParticipants
        .filter(xa(PARTICIPANT_ID))
        .map(function (p) {
        var _a;
        return (_a = {}, _a[p.participantId] = p, _a);
    });
    var incomingIdMap = Object.assign.apply(Object, __spreadArray([{}], __read(mappedParticipants), false));
    // check for overlap with existing players, add any newly retrieved attributes to existing
    var modifiedParticipants = [];
    tournamentRecord.participants = tournamentRecord.participants.map(function (participant) {
        if (incomingIdMap[participant.participantId]) {
            var mergedParticipant = deepMerge(participant, incomingIdMap[participant.participantId], arraysToMerge);
            modifiedParticipants.push(mergedParticipant);
            return mergedParticipant;
        }
        return participant;
    });
    var existingParticipantIds = tournamentRecord.participants.map(xa(PARTICIPANT_ID)) || [];
    var newParticipants = incomingParticipants.filter(function (_a) {
        var participantId = _a.participantId;
        return !existingParticipantIds.includes(participantId);
    });
    var topics = getTopics().topics;
    if (newParticipants.length) {
        tournamentRecord.participants = (_b = tournamentRecord.participants).concat.apply(_b, __spreadArray([], __read(newParticipants), false));
        if (topics.includes(ADD_PARTICIPANTS)) {
            addNotice({
                topic: ADD_PARTICIPANTS,
                payload: { participants: newParticipants },
            });
        }
    }
    if (modifiedParticipants.length && topics.includes(MODIFY_PARTICIPANTS)) {
        addNotice({
            topic: MODIFY_PARTICIPANTS,
            payload: {
                tournamentId: tournamentRecord.tournamentId,
                participants: modifiedParticipants,
            },
        });
    }
    return __assign({ modifiedParticipantsCount: modifiedParticipants.length, newParticipantsCount: newParticipants.length }, SUCCESS);
}

function addPenalty(params) {
    var _a, e_1, _b;
    var _c, _d, _e, _f;
    var tournamentRecord = params.tournamentRecord, participantIds = params.participantIds;
    var tournamentRecords = (_d = (_c = params.tournamentRecords) !== null && _c !== void 0 ? _c : (tournamentRecord && (_a = {},
        _a[tournamentRecord.tournamentId] = tournamentRecord,
        _a))) !== null && _d !== void 0 ? _d : {};
    var penaltyId;
    try {
        for (var _g = __values(Object.values(tournamentRecords)), _h = _g.next(); !_h.done; _h = _g.next()) {
            var tournamentRecord_1 = _h.value;
            var participants = (_e = getParticipants({
                tournamentRecord: tournamentRecord_1,
            }).participants) !== null && _e !== void 0 ? _e : [];
            var tournamentParticipantIds = participants === null || participants === void 0 ? void 0 : participants.map(xa('participantId')).filter(function (participantId) { return participantIds.includes(participantId); });
            if (tournamentParticipantIds.length) {
                var result = penaltyAdd(__assign(__assign({}, params), { penaltyId: (_f = params.penaltyId) !== null && _f !== void 0 ? _f : penaltyId, tournamentRecord: tournamentRecord_1, participantIds: tournamentParticipantIds }));
                penaltyId = result.penaltyId;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return penaltyId ? __assign(__assign({}, SUCCESS), { penaltyId: penaltyId }) : { error: PARTICIPANT_NOT_FOUND };
}
function penaltyAdd(_a) {
    var _b;
    var refereeParticipantId = _a.refereeParticipantId, tournamentRecord = _a.tournamentRecord, participantIds = _a.participantIds, penaltyCode = _a.penaltyCode, penaltyType = _a.penaltyType, extensions = _a.extensions, penaltyId = _a.penaltyId, matchUpId = _a.matchUpId, issuedAt = _a.issuedAt, notes = _a.notes;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!participantIds)
        return { error: MISSING_PARTICIPANT_ID };
    if (!penaltyType)
        return { error: MISSING_PENALTY_TYPE };
    // TODO: add penalty timeItem to matchUp.timeItems[]
    var participants = (_b = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) !== null && _b !== void 0 ? _b : [];
    var relevantParticipants = participants.filter(function (participant) { return participantIds.includes(participant.participantId); });
    if (!relevantParticipants.length)
        return { error: PARTICIPANT_NOT_FOUND };
    var createdAt = new Date().toISOString();
    var penaltyItem = Object.assign(penaltyTemplate({ penaltyId: penaltyId }), {
        refereeParticipantId: refereeParticipantId,
        penaltyCode: penaltyCode,
        penaltyType: penaltyType,
        matchUpId: matchUpId,
        notes: notes,
        issuedAt: issuedAt,
        createdAt: createdAt,
    });
    if (Array.isArray(extensions)) {
        extensions.forEach(function (extension) { return addExtension({ element: penaltyItem, extension: extension }); });
    }
    relevantParticipants.forEach(function (participant) {
        if (!participant.penalties)
            participant.penalties = [];
        participant.penalties.push(penaltyItem);
    });
    addNotice({
        topic: MODIFY_PARTICIPANTS,
        payload: {
            tournamentId: tournamentRecord.tournamentId,
            participants: relevantParticipants,
        },
    });
    return __assign(__assign({}, SUCCESS), { penaltyId: penaltyItem.penaltyId });
}

// add persons to a tournamentRecord and create participants in the process
// include ability to specify a doubles partner by personId
function addPersons(_a) {
    var _b, _c;
    var _d = _a.participantRole, participantRole = _d === void 0 ? COMPETITOR : _d, tournamentRecord = _a.tournamentRecord, persons = _a.persons;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!Array.isArray(persons))
        return { error: INVALID_VALUES };
    if (!Object.keys(participantRoles).includes(participantRole))
        return { error: INVALID_PARTICIPANT_ROLE };
    var existingPersonIds = (tournamentRecord.participants || [])
        .map(function (_a) {
        var person = _a.person;
        return person === null || person === void 0 ? void 0 : person.personId;
    })
        .filter(Boolean);
    var newPersonIds = [];
    var personsToAdd = persons
        .filter(function (person) {
        return person &&
            // don't add a person if their personId is present in tournament.participants
            (!person.personId || !existingPersonIds.includes(person.personId));
    })
        .map(function (person) {
        if (!person.personId)
            person.personId = UUID();
        // keep track of all incoming personIds for doubles creation
        newPersonIds.push(person.personId);
        return person;
    });
    // remove top level attributes which are used for participant generation
    var excludeAttributes = function (element, attributes) {
        return Object.assign.apply(Object, __spreadArray([{}], __read(Object.keys(element)
            .filter(function (key) { return !attributes.includes(key); })
            .map(function (key) {
            var _a;
            return (_a = {}, _a[key] = element[key], _a);
        })), false));
    };
    var individualParticipants = personsToAdd.map(function (person) {
        return definedAttributes({
            extensions: person.participantExtensions,
            timeItems: person.participantTimeItems,
            participantType: INDIVIDUAL,
            participantRole: participantRole,
            person: excludeAttributes(person, [
                'participantExtensions',
                'participantTimeItems',
                'pairedPersons',
            ]),
        });
    });
    var addedPairParticipantsCount = 0;
    var addedIndividualParticipantsCount = 0;
    var result = addParticipants({
        participants: individualParticipants,
        tournamentRecord: tournamentRecord,
    });
    if (result.error)
        return result;
    addedIndividualParticipantsCount = result.addedCount || 0;
    var pairParticipants = [];
    var tournamentParticipants = (_c = (_b = getParticipants({
        participantFilters: { participantTypes: [INDIVIDUAL] },
        tournamentRecord: tournamentRecord,
    })) === null || _b === void 0 ? void 0 : _b.participants) !== null && _c !== void 0 ? _c : [];
    if (participantRole === COMPETITOR) {
        persons
            .filter(function (_a) {
            var pairedPersons = _a.pairedPersons;
            return pairedPersons;
        })
            .forEach(function (_a) {
            var personId = _a.personId, pairedPersons = _a.pairedPersons;
            Array.isArray(pairedPersons) &&
                pairedPersons.forEach(function (pairing) {
                    var individualParticipants = [personId, pairing.personId]
                        .map(function (id) {
                        return findParticipant({ tournamentParticipants: tournamentParticipants, personId: id });
                    })
                        .filter(Boolean);
                    if (individualParticipants.length === 2) {
                        var individualParticipantIds = individualParticipants.map(getParticipantId);
                        pairParticipants.push(definedAttributes({
                            extensions: pairing.participantExtensions,
                            timeItems: pairing.timeItems,
                            participantRole: COMPETITOR,
                            individualParticipantIds: individualParticipantIds,
                            participantType: PAIR,
                        }));
                    }
                });
        });
    }
    if (pairParticipants.length) {
        result = addParticipants({
            participants: pairParticipants,
            tournamentRecord: tournamentRecord,
        });
        if (result.error)
            return result;
        addedPairParticipantsCount = result.addedCount || 0;
    }
    var addedCount = addedIndividualParticipantsCount + addedPairParticipantsCount;
    return __assign(__assign({}, SUCCESS), { addedCount: addedCount, newPersonIds: newPersonIds });
}

var participantGovernor = {
    addIndividualParticipantIds: addIndividualParticipantIds,
    addParticipant: addParticipant,
    addParticipants: addParticipants,
    addPenalty: addPenalty,
    addPersons: addPersons,
    createGroupParticipant: createGroupParticipant,
    createTeamsFromParticipantAttributes: createTeamsFromParticipantAttributes,
    deleteParticipants: deleteParticipants,
    filterParticipants: filterParticipants,
    mergeParticipants: mergeParticipants,
    modifyIndividualParticipantIds: modifyIndividualParticipantIds,
    modifyParticipant: modifyParticipant,
    modifyParticipantName: modifyParticipantName,
    modifyParticipantOtherName: modifyParticipantOtherName,
    modifyParticipantsSignInStatus: modifyParticipantsSignInStatus,
    modifyPenalty: modifyPenalty,
    regenerateParticipantNames: regenerateParticipantNames,
    removeIndividualParticipantIds: removeIndividualParticipantIds,
    removeParticipantIdsFromAllTeams: removeParticipantIdsFromAllTeams,
    removePenalty: removePenalty,
    scaledTeamAssignment: scaledTeamAssignment,
    setParticipantScaleItem: setParticipantScaleItem,
    setParticipantScaleItems: setParticipantScaleItems,
};

function removePolicy(params) {
    var _a, _b, e_1, _c;
    var _d, _e;
    var checkParams = checkRequiredParameters(params, [
        (_a = {},
            _a[POLICY_TYPE] = true,
            _a._anyOf = (_b = {},
                _b[TOURNAMENT_RECORDS] = false,
                _b[TOURNAMENT_RECORD] = false,
                _b[DRAW_DEFINITION] = false,
                _b[EVENT] = false,
                _b),
            _a),
    ]);
    if (checkParams.error)
        return checkParams;
    var policyRemoved;
    var element = (_e = (_d = params.drawDefinition) !== null && _d !== void 0 ? _d : params.event) !== null && _e !== void 0 ? _e : ((params.tournamentId || !params.tournamentRecords) && params.tournamentRecord);
    if (element) {
        return policyDeletion(params, element);
    }
    else if (params.tournamentRecords) {
        var tournamentIds = Object.keys(params.tournamentRecords);
        if (!tournamentIds.length)
            return { error: MISSING_TOURNAMENT_RECORD };
        try {
            for (var tournamentIds_1 = __values(tournamentIds), tournamentIds_1_1 = tournamentIds_1.next(); !tournamentIds_1_1.done; tournamentIds_1_1 = tournamentIds_1.next()) {
                var tournamentId = tournamentIds_1_1.value;
                var tournamentRecord = params.tournamentRecords[tournamentId];
                var result = policyDeletion(params, tournamentRecord);
                if (result.error)
                    return result;
                policyRemoved = true;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (tournamentIds_1_1 && !tournamentIds_1_1.done && (_c = tournamentIds_1.return)) _c.call(tournamentIds_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else {
        return { error: MISSING_TOURNAMENT_RECORD };
    }
    return policyRemoved ? __assign({}, SUCCESS) : { error: POLICY_NOT_FOUND };
}
function policyDeletion(params, element) {
    var _a;
    var appliedPolicies = (_a = getAppliedPolicies(params).appliedPolicies) !== null && _a !== void 0 ? _a : {};
    if (appliedPolicies[params.policyType]) {
        delete appliedPolicies[params.policyType];
        if (Object.keys(appliedPolicies).length) {
            var extension = { name: APPLIED_POLICIES, value: appliedPolicies };
            addExtension({ element: element, extension: extension });
        }
        else {
            removeExtension({ element: element, name: APPLIED_POLICIES });
        }
        return __assign({}, SUCCESS);
    }
    return { error: POLICY_NOT_FOUND };
}

var policyGovernor = {
    attachPolicies: attachPolicies,
    removePolicy: removePolicy,
};

function unPublishOrderOfPlay(params) {
    var _a, e_1, _b;
    var _c, _d;
    var tournamentRecords = (_d = (_c = params === null || params === void 0 ? void 0 : params.tournamentRecords) !== null && _c !== void 0 ? _c : ((params === null || params === void 0 ? void 0 : params.tournamentRecord) && (_a = {},
        _a[params.tournamentRecord.tournamentId] = params.tournamentRecord,
        _a))) !== null && _d !== void 0 ? _d : {};
    if (!Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    try {
        for (var _e = __values(Object.values(tournamentRecords)), _f = _e.next(); !_f.done; _f = _e.next()) {
            var tournamentRecord = _f.value;
            var result = unPublishOOP(__assign({ tournamentRecord: tournamentRecord }, params));
            if (result.error)
                return result;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}
function unPublishOOP(_a) {
    var _b;
    var _c = _a.removePriorValues, removePriorValues = _c === void 0 ? true : _c, tournamentRecord = _a.tournamentRecord, _d = _a.status, status = _d === void 0 ? PUBLIC : _d;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var itemType = "".concat(PUBLISH, ".").concat(STATUS$1);
    var timeItem = getTimeItem({
        element: tournamentRecord,
        itemType: itemType,
    }).timeItem;
    var itemValue = (timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemValue) || (_b = {}, _b[status] = {}, _b);
    if (itemValue[status])
        delete itemValue[status].orderOfPlay;
    var updatedTimeItem = {
        itemValue: itemValue,
        itemType: itemType,
    };
    addTimeItem({
        timeItem: updatedTimeItem,
        element: tournamentRecord,
        removePriorValues: removePriorValues,
    });
    addNotice({
        topic: UNPUBLISH_ORDER_OF_PLAY,
        payload: {
            tournamentId: tournamentRecord.tournamentId,
        },
    });
    return __assign({}, SUCCESS);
}

function publishOrderOfPlay(params) {
    var e_1, _a;
    var tournamentRecords = resolveTournamentRecords(params);
    if (!Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    try {
        for (var _b = __values(Object.values(tournamentRecords)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var tournamentRecord = _c.value;
            var result = publishOOP(__assign({ tournamentRecord: tournamentRecord }, params));
            if (result.error)
                return result;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}
function publishOOP(_a) {
    var _b;
    var _c = _a.scheduledDates, scheduledDates = _c === void 0 ? [] : _c, removePriorValues = _a.removePriorValues, tournamentRecord = _a.tournamentRecord, _d = _a.status, status = _d === void 0 ? PUBLIC : _d, _e = _a.eventIds, eventIds = _e === void 0 ? [] : _e;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var itemType = "".concat(PUBLISH, ".").concat(STATUS$1);
    var timeItem = getTimeItem({
        element: tournamentRecord,
        itemType: itemType,
    }).timeItem;
    var itemValue = (timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemValue) || (_b = {}, _b[status] = {}, _b);
    itemValue[status].orderOfPlay = { published: true, scheduledDates: scheduledDates, eventIds: eventIds };
    var updatedTimeItem = {
        itemValue: itemValue,
        itemType: itemType,
    };
    addTimeItem({
        timeItem: updatedTimeItem,
        element: tournamentRecord,
        removePriorValues: removePriorValues,
    });
    addNotice({
        topic: PUBLISH_ORDER_OF_PLAY,
        payload: {
            tournamentId: tournamentRecord.tournamentId,
            scheduledDates: scheduledDates,
            eventIds: eventIds,
        },
    });
    return __assign({}, SUCCESS);
}

function setEventDisplay(_a) {
    var e_1, _b, e_2, _c;
    var _d;
    var removePriorValues = _a.removePriorValues, tournamentRecord = _a.tournamentRecord, displaySettings = _a.displaySettings, _e = _a.status, status = _e === void 0 ? PUBLIC : _e, event = _a.event;
    if (!tournamentRecord)
        return decorateResult({ result: { error: MISSING_TOURNAMENT_RECORD } });
    if (!event)
        return decorateResult({ result: { error: MISSING_EVENT } });
    if (!isObject(displaySettings))
        return decorateResult({ result: { error: MISSING_VALUE } });
    // combine ScheduleDetails that are equivalent
    if (isObject(displaySettings.draws)) {
        try {
            for (var _f = __values(Object.keys(displaySettings.draws)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var key = _g.value;
                var details = (_d = displaySettings.draws[key].scheduleDetails) !== null && _d !== void 0 ? _d : [];
                if (details.length) {
                    var scheduleDetails = [];
                    var _loop_1 = function (detail) {
                        var _h;
                        var existingDetail = scheduleDetails.find(function (sd) {
                            return objShallowEqual(sd.attributes, detail.attributes);
                        });
                        if ((existingDetail === null || existingDetail === void 0 ? void 0 : existingDetail.dates) && detail.dates) {
                            (_h = existingDetail.dates).push.apply(_h, __spreadArray([], __read(detail.dates), false));
                        }
                        else {
                            scheduleDetails.push(detail);
                        }
                    };
                    try {
                        for (var details_1 = (e_2 = void 0, __values(details)), details_1_1 = details_1.next(); !details_1_1.done; details_1_1 = details_1.next()) {
                            var detail = details_1_1.value;
                            _loop_1(detail);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (details_1_1 && !details_1_1.done && (_c = details_1.return)) _c.call(details_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    displaySettings.draws[key].scheduleDetails = scheduleDetails;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    var result = modifyEventPublishStatus({
        statusObject: { displaySettings: displaySettings },
        removePriorValues: removePriorValues,
        status: status,
        event: event,
    });
    if (result.error)
        return result;
    return __assign({}, SUCCESS);
}

function unPublishEvent(_a) {
    var _b;
    var _c = _a.removePriorValues, removePriorValues = _c === void 0 ? true : _c, tournamentRecord = _a.tournamentRecord, _d = _a.status, status = _d === void 0 ? PUBLIC : _d, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    var itemType = "".concat(PUBLISH, ".").concat(STATUS$1);
    var timeItem = getEventTimeItem({
        itemType: itemType,
        event: event,
    }).timeItem;
    var itemValue = (timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemValue) || (_b = {}, _b[status] = {}, _b);
    delete itemValue[status].structureIds; // legacy
    delete itemValue[status].drawDetails;
    delete itemValue[status].drawIds; // legacy
    var updatedTimeItem = { itemValue: itemValue, itemType: itemType };
    addEventTimeItem({ event: event, timeItem: updatedTimeItem, removePriorValues: removePriorValues });
    modifyEventPublishStatus({
        statusObject: {
            structureIds: undefined,
            drawIds: undefined,
            seeding: undefined,
        },
        removePriorValues: removePriorValues,
        status: status,
        event: event,
    });
    addNotice({
        topic: UNPUBLISH_EVENT,
        payload: {
            tournamentId: tournamentRecord.tournamentId,
            eventId: event.eventId,
        },
    });
    return __assign({ eventId: event.eventId }, SUCCESS);
}

function getAllEventData(_a) {
    var tournamentRecord = _a.tournamentRecord, policyDefinitions = _a.policyDefinitions;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var events = tournamentRecord.events || [];
    var tournamentParticipants = (tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) || [];
    var tournamentInfo = getTournamentInfo({ tournamentRecord: tournamentRecord }).tournamentInfo;
    var venuesData = getVenuesAndCourts({
        tournamentRecord: tournamentRecord,
    }).venues;
    var eventsData = events.map(function (event) {
        var eventId = event.eventId;
        var eventInfo = (function (_a) {
            var eventId = _a.eventId, eventName = _a.eventName, eventType = _a.eventType, eventLevel = _a.eventLevel, surfaceCategory = _a.surfaceCategory, matchUpFormat = _a.matchUpFormat, category = _a.category, gender = _a.gender, startDate = _a.startDate, endDate = _a.endDate, ballType = _a.ballType, discipline = _a.discipline;
            return ({
                eventId: eventId,
                eventName: eventName,
                eventType: eventType,
                eventLevel: eventLevel,
                surfaceCategory: surfaceCategory,
                matchUpFormat: matchUpFormat,
                category: category,
                gender: gender,
                startDate: startDate,
                endDate: endDate,
                ballType: ballType,
                discipline: discipline,
            });
        })(event);
        var scheduleTiming = getScheduleTiming({
            tournamentRecord: tournamentRecord,
            event: event,
        }).scheduleTiming;
        var drawsData = (event.drawDefinitions || []).map(function (drawDefinition) {
            var drawInfo = (function (_a) {
                var drawId = _a.drawId, drawName = _a.drawName, matchUpFormat = _a.matchUpFormat, updatedAt = _a.updatedAt;
                return ({
                    matchUpFormat: matchUpFormat,
                    updatedAt: updatedAt,
                    drawName: drawName,
                    drawId: drawId,
                });
            })(drawDefinition);
            var _a = getDrawMatchUps({
                requireParticipants: true,
                tournamentParticipants: tournamentParticipants,
                context: { eventId: eventId },
                policyDefinitions: policyDefinitions,
                tournamentRecord: tournamentRecord,
                inContext: true,
                scheduleTiming: scheduleTiming,
                drawDefinition: drawDefinition,
                event: event,
            }), abandonedMatchUps = _a.abandonedMatchUps, completedMatchUps = _a.completedMatchUps, upcomingMatchUps = _a.upcomingMatchUps, pendingMatchUps = _a.pendingMatchUps;
            return {
                drawInfo: drawInfo,
                matchUps: {
                    abandonedMatchUps: abandonedMatchUps,
                    completedMatchUps: completedMatchUps,
                    upcomingMatchUps: upcomingMatchUps,
                    pendingMatchUps: pendingMatchUps,
                },
            };
        });
        var publish = getEventPublishStatus({ event: event });
        Object.assign(eventInfo, {
            drawsData: drawsData,
            publish: publish,
        });
        return eventInfo;
    });
    var allEventData = { tournamentInfo: tournamentInfo, venuesData: venuesData, eventsData: eventsData };
    return { allEventData: allEventData };
}

function publishEventSeeding(_a) {
    var _b, _c, _d, _e;
    var _f = _a.removePriorValues, removePriorValues = _f === void 0 ? true : _f, stageSeedingScaleNames = _a.stageSeedingScaleNames, seedingScaleNames = _a.seedingScaleNames, tournamentRecord = _a.tournamentRecord, _g = _a.status, status = _g === void 0 ? PUBLIC : _g, _h = _a.drawIds, drawIds = _h === void 0 ? [] : _h, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    var eventPubStatus = getEventPublishStatus({ event: event, status: status });
    var updatedSeedingScaleNames = (((_b = eventPubStatus === null || eventPubStatus === void 0 ? void 0 : eventPubStatus.seeding) === null || _b === void 0 ? void 0 : _b.seedingScaleNames) ||
        seedingScaleNames) && __assign(__assign({}, (_c = eventPubStatus === null || eventPubStatus === void 0 ? void 0 : eventPubStatus.seeding) === null || _c === void 0 ? void 0 : _c.seedingScaleNames), seedingScaleNames);
    var updatedStageSeedingScaleNames = (((_d = eventPubStatus === null || eventPubStatus === void 0 ? void 0 : eventPubStatus.seeding) === null || _d === void 0 ? void 0 : _d.stageSeedingScaleNames) ||
        stageSeedingScaleNames) && __assign(__assign({}, (_e = eventPubStatus === null || eventPubStatus === void 0 ? void 0 : eventPubStatus.seeding) === null || _e === void 0 ? void 0 : _e.stageSeedingScaleNames), stageSeedingScaleNames);
    var seeding = definedAttributes({
        stageSeedingScaleNames: updatedStageSeedingScaleNames,
        seedingScaleNames: updatedSeedingScaleNames,
        published: true,
        drawIds: drawIds,
    });
    modifyEventPublishStatus({
        statusObject: { seeding: seeding },
        removePriorValues: removePriorValues,
        status: status,
        event: event,
    });
    addNotice({
        topic: PUBLISH_EVENT_SEEDING,
        payload: {
            tournamentId: tournamentRecord.tournamentId,
            eventId: event.eventId,
            drawIds: drawIds,
        },
    });
    return __assign({}, SUCCESS);
}
function unPublishEventSeeding(_a) {
    var e_1, _b;
    var _c, _d, _e;
    var _f = _a.removePriorValues, removePriorValues = _f === void 0 ? true : _f, seedingScaleNames = _a.seedingScaleNames, tournamentRecord = _a.tournamentRecord, _g = _a.status, status = _g === void 0 ? PUBLIC : _g, drawIds = _a.drawIds, stages = _a.stages, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    var eventPubStatus = getEventPublishStatus({ event: event });
    if (eventPubStatus) {
        var seeding = eventPubStatus.seeding;
        if (Array.isArray(stages) && seeding.stageSeedingScaleNames) {
            try {
                for (var stages_1 = __values(stages), stages_1_1 = stages_1.next(); !stages_1_1.done; stages_1_1 = stages_1.next()) {
                    var stage = stages_1_1.value;
                    if (seeding.stageSeedingScaleNames[stage]) {
                        delete seeding.stageSeedingScaleNames[stage];
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (stages_1_1 && !stages_1_1.done && (_b = stages_1.return)) _b.call(stages_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        if (Array.isArray(seedingScaleNames) && (seeding === null || seeding === void 0 ? void 0 : seeding.seedingScaleNames)) {
            seeding.seedingScaleNames = seeding.seedingScaleNames.filter(function (scaleName) { return !seedingScaleNames.includes(scaleName); });
        }
        if (Array.isArray(drawIds) && (seeding === null || seeding === void 0 ? void 0 : seeding.drawIds)) {
            seeding.drawIds = seeding.drawIds.filter(function (drawId) { return !drawIds.includes(drawId); });
        }
        if ((!Object.values((_c = seeding.stageSeedingScaleNames) !== null && _c !== void 0 ? _c : {}).length &&
            !((_d = seeding.seedingScaleNames) === null || _d === void 0 ? void 0 : _d.length) &&
            !((_e = seeding.drawIds) === null || _e === void 0 ? void 0 : _e.length)) ||
            (!stages && !seedingScaleNames && !(drawIds === null || drawIds === void 0 ? void 0 : drawIds.length))) {
            delete seeding.stageSeedingScaleNames;
            delete seeding.seedingScaleNames;
            delete seeding.drawIds;
            seeding.published = false;
        }
        modifyEventPublishStatus({
            statusObject: { seeding: seeding },
            removePriorValues: removePriorValues,
            status: status,
            event: event,
        });
    }
    addNotice({
        topic: UNPUBLISH_EVENT_SEEDING,
        payload: {
            tournamentId: tournamentRecord.tournamentId,
            eventId: event.eventId,
        },
    });
    return __assign({}, SUCCESS);
}

var publishingGovernor = {
    getAllEventData: getAllEventData,
    getCourtInfo: getCourtInfo,
    getDrawData: getDrawData,
    getEventData: getEventData,
    getPublishState: getPublishState,
    getVenueData: getVenueData,
    publishEvent: publishEvent,
    publishEventSeeding: publishEventSeeding,
    publishOrderOfPlay: publishOrderOfPlay,
    setEventDisplay: setEventDisplay,
    unPublishEvent: unPublishEvent,
    unPublishEventSeeding: unPublishEventSeeding,
    unPublishOrderOfPlay: unPublishOrderOfPlay,
};

function getEligibleVoluntaryConsolationParticipants(_a) {
    var e_1, _b;
    var _c, _d, _e, _f, _g, _h, _j, _k, _l;
    var _m = _a.excludedMatchUpStatuses, excludedMatchUpStatuses = _m === void 0 ? [] : _m, includeEventParticipants = _a.includeEventParticipants, // boolean - consider event entries rather than draw entries (if event is present)
    includeQualifyingStage = _a.includeQualifyingStage, finishingRoundLimit = _a.finishingRoundLimit, policyDefinitions = _a.policyDefinitions, roundNumberLimit = _a.roundNumberLimit, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, matchUpsLimit = _a.matchUpsLimit, requirePlay = _a.requirePlay, requireLoss = _a.requireLoss, allEntries = _a.allEntries, // boolean - consider all entries, regardless of whether placed in draw
    winsLimit = _a.winsLimit, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var stages = [MAIN, PLAY_OFF];
    if (includeQualifyingStage)
        stages.push(QUALIFYING);
    var eventMatchUpFilters = (event === null || event === void 0 ? void 0 : event.eventType)
        ? { matchUpTypes: [event.eventType] }
        : undefined;
    var drawMatchUpFilters = (drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.matchUpType)
        ? { matchUpTypes: [drawDefinition.matchUpType] }
        : undefined;
    var matchUps = includeEventParticipants && event
        ? (_d = (_c = allEventMatchUps({
            contextFilters: { stages: stages },
            matchUpFilters: eventMatchUpFilters,
            tournamentRecord: tournamentRecord,
            inContext: true,
            event: event,
        })) === null || _c === void 0 ? void 0 : _c.matchUps) !== null && _d !== void 0 ? _d : []
        : (_f = (_e = allDrawMatchUps({
            contextFilters: { stages: stages },
            matchUpFilters: drawMatchUpFilters,
            tournamentRecord: tournamentRecord,
            inContext: true,
            drawDefinition: drawDefinition,
        })) === null || _e === void 0 ? void 0 : _e.matchUps) !== null && _f !== void 0 ? _f : [];
    var voluntaryConsolationEntries = getStageEntries$1({
        stage: VOLUNTARY_CONSOLATION,
        drawDefinition: drawDefinition,
    });
    var voluntaryConsolationEntryIds = voluntaryConsolationEntries.map(function (_a) {
        var participantId = _a.participantId;
        return participantId;
    });
    var participantMatchUps = {};
    var losingParticipants = {};
    var matchUpParticipants = {};
    var participantWins = {};
    if (!policyDefinitions) {
        policyDefinitions = getPolicyDefinitions({
            policyTypes: [POLICY_TYPE_VOLUNTARY_CONSOLATION],
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            event: event,
        }).policyDefinitions;
    }
    // support POLICY_TYPE_VOLUNTARY_CONSOLATION
    var policy = policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_VOLUNTARY_CONSOLATION];
    excludedMatchUpStatuses =
        (excludedMatchUpStatuses.length && excludedMatchUpStatuses) ||
            (policy === null || policy === void 0 ? void 0 : policy.excludedMatchUpStatuses) ||
            [];
    includeEventParticipants =
        includeEventParticipants !== null && includeEventParticipants !== void 0 ? includeEventParticipants : policy === null || policy === void 0 ? void 0 : policy.includeEventParticipants;
    allEntries = allEntries !== null && allEntries !== void 0 ? allEntries : policy === null || policy === void 0 ? void 0 : policy.allEntries;
    finishingRoundLimit = finishingRoundLimit !== null && finishingRoundLimit !== void 0 ? finishingRoundLimit : policy === null || policy === void 0 ? void 0 : policy.finishingRoundLimit;
    roundNumberLimit = roundNumberLimit !== null && roundNumberLimit !== void 0 ? roundNumberLimit : policy === null || policy === void 0 ? void 0 : policy.roundNumberLimit;
    matchUpsLimit = matchUpsLimit !== null && matchUpsLimit !== void 0 ? matchUpsLimit : policy === null || policy === void 0 ? void 0 : policy.matchUpsLimit;
    if (requirePlay === undefined) {
        requirePlay = (policy === null || policy === void 0 ? void 0 : policy.requirePlay) !== undefined ? policy.requirePlay : true;
    }
    if (requireLoss === undefined) {
        requireLoss = (policy === null || policy === void 0 ? void 0 : policy.requireLoss) !== undefined ? policy.requireLoss : true;
    }
    // end policy support
    winsLimit = winsLimit !== null && winsLimit !== void 0 ? winsLimit : policy === null || policy === void 0 ? void 0 : policy.winsLimit;
    var _loop_1 = function (matchUp) {
        if (requirePlay &&
            matchUp.winningSide &&
            ![1, 2].includes(matchUp.winningSide) &&
            matchUp.matchUpStatus !== DOUBLE_WALKOVER)
            return "continue";
        if (matchUp.finishingRound &&
            finishingRoundLimit &&
            matchUp.finishingRound >= finishingRoundLimit)
            return "continue";
        if (matchUp.finishingRound &&
            roundNumberLimit &&
            matchUp.finishingRound <= roundNumberLimit)
            return "continue";
        var losingSide = (_g = matchUp.sides) === null || _g === void 0 ? void 0 : _g.find(function (_a) {
            var sideNumber = _a.sideNumber;
            return matchUp.winningSide && sideNumber === 3 - matchUp.winningSide;
        });
        var winningSide = (_h = matchUp.sides) === null || _h === void 0 ? void 0 : _h.find(function (_a) {
            var sideNumber = _a.sideNumber;
            return matchUp.winningSide && sideNumber === matchUp.winningSide;
        });
        (_j = matchUp.sides) === null || _j === void 0 ? void 0 : _j.forEach(function (side) {
            var _a;
            var participantId = (_a = side === null || side === void 0 ? void 0 : side.participant) === null || _a === void 0 ? void 0 : _a.participantId;
            if (participantId) {
                matchUpParticipants[participantId] = side.participant;
                if (matchUp.matchUpStatus === DOUBLE_WALKOVER && !requirePlay) {
                    losingParticipants[participantId] = side.participant;
                    if (!participantMatchUps[participantId])
                        participantMatchUps[participantId] = 0;
                    if (!matchUp.matchUpStatus ||
                        !excludedMatchUpStatuses.includes(matchUp.matchUpStatus))
                        participantMatchUps[participantId] += 1;
                }
            }
        });
        if (losingSide === null || losingSide === void 0 ? void 0 : losingSide.participant) {
            var participantId = losingSide.participant.participantId;
            losingParticipants[participantId] = losingSide.participant;
            if (!participantMatchUps[participantId])
                participantMatchUps[participantId] = 0;
            if (matchUp.matchUpStatus &&
                !excludedMatchUpStatuses.includes(matchUp.matchUpStatus))
                participantMatchUps[participantId] += 1;
        }
        if (winningSide === null || winningSide === void 0 ? void 0 : winningSide.participant) {
            var participantId = winningSide.participant.participantId;
            if (!participantWins[participantId])
                participantWins[participantId] = 0;
            participantWins[participantId] += 1;
            if (!participantMatchUps[participantId])
                participantMatchUps[participantId] = 0;
            if (matchUp.matchUpStatus &&
                !excludedMatchUpStatuses.includes(matchUp.matchUpStatus))
                participantMatchUps[participantId] += 1;
        }
    };
    try {
        for (var matchUps_1 = __values(matchUps), matchUps_1_1 = matchUps_1.next(); !matchUps_1_1.done; matchUps_1_1 = matchUps_1.next()) {
            var matchUp = matchUps_1_1.value;
            _loop_1(matchUp);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (matchUps_1_1 && !matchUps_1_1.done && (_b = matchUps_1.return)) _b.call(matchUps_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var considerEntered = (tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) &&
        !requirePlay &&
        !requireLoss &&
        allEntries;
    var enteredParticipantIds = considerEntered
        ? ((_k = (includeEventParticipants && event
            ? event.entries
            : drawDefinition.entries)) !== null && _k !== void 0 ? _k : [])
            .filter(function (entry) { return ![WITHDRAWN, UNGROUPED].includes(entry.entryStatus); })
            .map(function (_a) {
            var participantId = _a.participantId;
            return participantId;
        })
        : [];
    var losingParticipantIds = Object.keys(losingParticipants);
    var consideredParticipants = considerEntered
        ? ((_l = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) !== null && _l !== void 0 ? _l : []).filter(function (_a) {
            var participantId = _a.participantId;
            return enteredParticipantIds.includes(participantId);
        })
        : (requireLoss && Object.values(losingParticipants)) ||
            Object.values(matchUpParticipants);
    var satisfiesLoss = function (participantId) {
        return !requireLoss || losingParticipantIds.includes(participantId);
    };
    var satisfiesPlay = function (participantId) {
        return !requirePlay || (participantMatchUps[participantId] || 0) >= 0;
    };
    var satisfiesWinsLimit = function (participantId) {
        return !winsLimit || (participantWins[participantId] || 0) <= winsLimit;
    };
    var satisfiesMatchUpsLimit = function (participantId) {
        return !matchUpsLimit || participantMatchUps[participantId] <= matchUpsLimit;
    };
    var notPreviouslySelected = function (participantId) {
        return !voluntaryConsolationEntryIds.includes(participantId);
    };
    var eligibleParticipants = consideredParticipants
        .filter(function (participant) {
        return satisfiesLoss(participant.participantId) &&
            satisfiesPlay(participant.participantId) &&
            satisfiesWinsLimit(participant.participantId) &&
            satisfiesMatchUpsLimit(participant.participantId) &&
            notPreviouslySelected(participant.participantId);
    })
        .map(function (participant) {
        var _a;
        return __assign(__assign({}, participant), { individualParticipants: (_a = participant.individualParticipantIds) === null || _a === void 0 ? void 0 : _a.map(function (participantId) {
                var _a;
                return (_a = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) === null || _a === void 0 ? void 0 : _a.find(function (individual) { return individual.participantId === participantId; });
            }) });
    });
    // PRESERVED for debugging
    /*
    const lossCheck = consideredParticipants.map(({ participantId }) =>
      satisfiesLoss(participantId)
    );
    const playCheck = consideredParticipants.map(({ participantId }) =>
      satisfiesPlay(participantId)
    );
    const winsCheck = consideredParticipants.map(({ participantId }) =>
      satisfiesWinsLimit(participantId)
    );
    const limitCheck = consideredParticipants.map(({ participantId }) =>
      satisfiesMatchUpsLimit(participantId)
    );
    const selectCheck = consideredParticipants.map(({ participantId }) =>
      notPreviouslySelected(participantId)
    );
    console.log(
      lossCheck.length,
      playCheck.length,
      winsCheck.length,
      limitCheck.length,
      selectCheck.length,
      { requireLoss, requirePlay },
      consideredParticipants.length,
      losingParticipantIds.length,
      eligibleParticipants.length
    );
    */
    return __assign({ eligibleParticipants: eligibleParticipants, losingParticipantIds: losingParticipantIds }, SUCCESS);
}

function getExtensionUpdate(_a) {
    var e_1, _b, e_2, _c;
    var _d;
    var tournamentRecords = _a.tournamentRecords, extensionName = _a.extensionName;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var methods = [];
    var tournamentExtensionAdded;
    try {
        for (var _e = __values(Object.values(tournamentRecords)), _f = _e.next(); !_f.done; _f = _e.next()) {
            var tournamentRecord = _f.value;
            var extension = findExtension({
                element: tournamentRecord,
                name: extensionName,
            }).extension;
            // only necessary to push this method once to cover both tournaments
            if (extension && !tournamentExtensionAdded) {
                methods.push({
                    params: { extension: extension, discover: true },
                    method: 'addExtension',
                });
                tournamentExtensionAdded = true;
            }
            var tournamentEvents = (_d = tournamentRecord.events) !== null && _d !== void 0 ? _d : [];
            try {
                for (var tournamentEvents_1 = (e_2 = void 0, __values(tournamentEvents)), tournamentEvents_1_1 = tournamentEvents_1.next(); !tournamentEvents_1_1.done; tournamentEvents_1_1 = tournamentEvents_1.next()) {
                    var event_1 = tournamentEvents_1_1.value;
                    var eventId = event_1.eventId;
                    var extension_1 = findExtension({
                        name: extensionName,
                        element: event_1,
                    }).extension;
                    if (extension_1) {
                        methods.push({
                            params: { eventId: eventId, extension: extension_1 },
                            method: 'addEventExtension',
                        });
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (tournamentEvents_1_1 && !tournamentEvents_1_1.done && (_c = tournamentEvents_1.return)) _c.call(tournamentEvents_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { methods: methods };
}

function getMatchUpFormatTimingUpdate(_a) {
    var tournamentRecords = _a.tournamentRecords;
    return getExtensionUpdate({
        extensionName: SCHEDULE_TIMING,
        tournamentRecords: tournamentRecords,
    });
}

function getDrawParticipantRepresentativeIds(_a) {
    var _b;
    var drawDefinition = _a.drawDefinition;
    var result = findExtension({
        name: 'participantRepresentatives',
        element: drawDefinition,
    });
    if (result.error)
        return result;
    var representativeParticipantIds = ((_b = result.extension) === null || _b === void 0 ? void 0 : _b.value) || [];
    return { representativeParticipantIds: representativeParticipantIds };
}

var _a$a, _b$2, _c, _d, _e;
// categoryTypes
var ADULT = 'ADULT';
var JUNIOR = 'JUNIOR';
var WHEELCHAIR = 'WHEELCHAIR';
var POLICY_SCHEDULING_DEFAULT = (_a$a = {},
    _a$a[POLICY_TYPE_SCHEDULING] = {
        allowModificationWhenMatchUpsScheduled: {
            courts: false,
            venues: false,
        },
        defaultTimes: {
            averageTimes: [{ categoryNames: [], minutes: { default: 90 } }],
            recoveryTimes: [{ minutes: (_b$2 = {}, _b$2[DOUBLES] = 30, _b$2.default = 60, _b$2) }],
        },
        defaultDailyLimits: (_c = {},
            _c[SINGLES] = 2,
            _c[DOUBLES] = 2,
            _c.total = 3,
            _c),
        matchUpAverageTimes: [
            {
                matchUpFormatCodes: [FORMAT_STANDARD], // Best of 3 tiebreak sets
                averageTimes: [
                    {
                        categoryNames: [],
                        minutes: { default: 90 },
                    },
                    {
                        categoryTypes: [WHEELCHAIR],
                        minutes: { default: 120 },
                    },
                ],
            },
            {
                matchUpFormatCodes: ['SET3-S:6/TB7-F:TB10'], // Two tiebreak sets, 10-point match tiebreak at one set all
                averageTimes: [{ categoryNames: [], minutes: { default: 85 } }],
            },
            {
                matchUpFormatCodes: ['SET3-S:6/TB7-F:TB7'], // Two tiebreak sets, 7-point match tiebreak at one set all
                averageTimes: [{ categoryNames: [], minutes: { default: 70 } }],
            },
            {
                matchUpFormatCodes: ['SET3-S:4NOAD-F:TB7'], // Two short sets to 4 with deciding game at 3-3, 7-point match tiebreak at one set all
                averageTimes: [{ categoryNames: [], minutes: { default: 55 } }],
            },
            {
                matchUpFormatCodes: ['SET3-S:4/TB7'], // Best of 3 sets to 4
                averageTimes: [{ categoryNames: [], minutes: { default: 60 } }],
            },
            {
                matchUpFormatCodes: ['SET3-S:4/TB7-F:TB7'], // Two short sets to 4, 7-point match tiebreak at one set all
                averageTimes: [{ categoryNames: [], minutes: { default: 50 } }],
            },
            {
                matchUpFormatCodes: ['SET3-S:4/TB7-F:TB10'], // Two short sets to 4, 10-point match tiebreak at one set all
                averageTimes: [{ categoryNames: [], minutes: { default: 55 } }],
            },
            {
                matchUpFormatCodes: ['SET3-S:4/TB5@3'], // Two out of three short sets to 4 with 5-point tiebreak at 3 games all
                averageTimes: [{ categoryNames: [], minutes: { default: 45 } }],
            },
            {
                matchUpFormatCodes: [
                    'SET1-S:8/TB7' /* 8 game pro-set with 7 point tiebreak at 8 games all */,
                    'SET1-S:8/TB7@7' /* 8 game pro-set with 7 point tiebreak at 7 games all */,
                ],
                averageTimes: [{ categoryNames: [], minutes: { default: 40 } }],
            },
            {
                matchUpFormatCodes: ['SET1-S:5/TB9@4'], // One no advantage set to 5, tiebreak to 9 at 4-4
                averageTimes: [{ categoryNames: [], minutes: { default: 30 } }],
            },
            {
                matchUpFormatCodes: ['SET1-S:6/TB7'], // One standard tiebreak set to 6, 7-point tiebreak at 6 games all
                averageTimes: [{ categoryNames: [], minutes: { default: 30 } }],
            },
            {
                matchUpFormatCodes: ['SET1-S:6NOAD'], // One set to 6 with deciding game at 5 games all
                averageTimes: [{ categoryNames: [], minutes: { default: 30 } }],
            },
            {
                matchUpFormatCodes: [
                    'SET1-S:4/TB7' /* One short set to 4, 7-point tiebreak at 4 games all */,
                    'SET1-S:4/TB5@3' /* One short set to 4, 5-point tiebreak at 3 games all */,
                    'SET3-S:TB10' /* Best of 3 10-point tiebreak games */,
                    'SET1-S:T20' /* Timed 20 minute game - game based' */,
                ],
                averageTimes: [{ categoryNames: [], minutes: { default: 20 } }],
            },
            {
                matchUpFormatCodes: ['SET1-S:4NOAD'], // One short set to 4, deciding game is played at 3 games all
                averageTimes: [{ categoryNames: [], minutes: { default: 20 } }],
            },
            {
                matchUpFormatCodes: ['SET1-S:TB10'], // One 10-point tiebreak game
                averageTimes: [{ categoryNames: [], minutes: { default: 10 } }],
            },
        ],
        matchUpRecoveryTimes: [
            {
                matchUpFormatCodes: [
                    'SET3-S:6/TB7' /* Best of 3 tiebreak sets */,
                    'SET3-S:6/TB7-F:TB10' /* Two tiebreak sets, 10-point match tiebreak at one set all */,
                    'SET3-S:6/TB7-F:TB7' /* Two tiebreak sets, 7-point match tiebreak at one set all */,
                ],
                recoveryTimes: [
                    {
                        categoryTypes: [ADULT, WHEELCHAIR],
                        minutes: (_d = { default: 60 }, _d[DOUBLES] = 30, _d),
                    },
                    {
                        categoryTypes: [JUNIOR],
                        minutes: (_e = { default: 60 }, _e[DOUBLES] = 60, _e),
                    },
                ],
            },
            {
                matchUpFormatCodes: [
                    'SET3-S:4/TB7-F:TB7' /* Two short sets to 4, 7-point match tiebreak at one set all */,
                    'SET3-S:4/TB7-F:TB10' /* Two short sets to 4, 10-point match tiebreak at one set all */,
                    'SET3-S:4NOAD-F:TB7' /* Two short sets to 4 with deciding game at 3-3, 7-point match tiebreak at one set all */,
                    'SET3-S:4/TB7' /* Best of 3 sets to 4 */,
                    'SET3-S:4/TB5@3' /* Two out of three short sets to 4 with 5-point tiebreak at 3 games all */,
                ],
                recoveryTimes: [
                    {
                        categoryTypes: [ADULT, WHEELCHAIR],
                        minutes: { default: 30 },
                    },
                    {
                        categoryTypes: [JUNIOR],
                        minutes: { default: 60 },
                    },
                ],
            },
            {
                matchUpFormatCodes: [
                    'SET1-S:8/TB7' /* 8 game pro-set with 7 point tiebreak at 8 games all */,
                    'SET1-S:8/TB7@7' /* 8 game pro-set with 7 point tiebreak at 7 games all */,
                    'SET1-S:5/TB9@4' /* One no advantage set to 5, tiebreak to 9 at 4-4 */,
                    'SET1-S:6/TB7' /* One standard tiebreak set to 6, 7-point tiebreak at 6 games all */,
                    'SET1-S:6NOAD' /* One set to 6 with deciding game at 5 games all */,
                    'SET1-S:4/TB7' /* One short set to 4, 7-point tiebreak at 4 games all */,
                    'SET1-S:4NOAD' /* One short set to 4, deciding game is played at 3 games all */,
                    'SET3-S:TB10' /* Best of 3 10-point tiebreak games */,
                    'SET1-S:T20' /* Timed 20 minute game - game based */,
                ],
                recoveryTimes: [
                    {
                        categoryNames: [],
                        minutes: { default: 30 },
                    },
                ],
            },
            {
                matchUpFormatCodes: ['SET1-S:4/TB5@3'], // One short set to 4, 5-point tiebreak at 3 games all
                recoveryTimes: [
                    {
                        categoryTypes: [ADULT, JUNIOR],
                        minutes: { default: 30 },
                    },
                    {
                        categoryTypes: [WHEELCHAIR],
                        minutes: { default: 15 },
                    },
                ],
            },
            {
                matchUpFormatCodes: ['SET1-S:TB10'], // One 10-point tiebreak game
                recoveryTimes: [
                    {
                        categoryNames: [],
                        minutes: { default: 15 },
                    },
                ],
            },
        ],
        matchUpDailyLimits: [],
    },
    _a$a);

function getEventMatchUpFormatTiming(_a) {
    var _b, _c;
    var _d, _e;
    var tournamentRecord = _a.tournamentRecord, matchUpFormats = _a.matchUpFormats, // optional - can be retrieved from policy
    categoryType = _a.categoryType, // optional - categoryType is not part of event attributes
    event = _a.event;
    if (!event)
        return { error: MISSING_EVENT };
    var matchUpFormatDefinitions = [];
    var info;
    if (!(matchUpFormats === null || matchUpFormats === void 0 ? void 0 : matchUpFormats.length)) {
        var policy = findPolicy({
            policyType: POLICY_TYPE_SCORING,
            tournamentRecord: tournamentRecord,
            event: event,
        }).policy;
        if (policy === null || policy === void 0 ? void 0 : policy.matchUpFormats) {
            matchUpFormatDefinitions = policy === null || policy === void 0 ? void 0 : policy.matchUpFormats;
        }
        else {
            var extension = findExtension({
                name: SCHEDULE_TIMING,
                element: event,
            }).extension;
            var matchUpAverageTimes = void 0, matchUpRecoveryTimes = void 0;
            if (extension === null || extension === void 0 ? void 0 : extension.value) {
                (_b = extension.value, matchUpAverageTimes = _b.matchUpAverageTimes, matchUpRecoveryTimes = _b.matchUpRecoveryTimes);
            }
            else {
                (_c = POLICY_SCHEDULING_DEFAULT[POLICY_TYPE_SCHEDULING], matchUpAverageTimes = _c.matchUpAverageTimes, matchUpRecoveryTimes = _c.matchUpRecoveryTimes);
            }
            matchUpFormatDefinitions = unique(__spreadArray(__spreadArray([], __read((matchUpAverageTimes || []).map(function (at) { return at.matchUpFormatCodes; })), false), __read((matchUpRecoveryTimes || []).map(function (at) { return at.matchUpFormatCodes; })), false).flat()).map(function (matchUpFormat) { return ({ matchUpFormat: matchUpFormat }); });
            info = 'default scheduling policy in use';
        }
    }
    else {
        var uniqueMatchUpFormats_1 = [];
        matchUpFormatDefinitions = matchUpFormats
            .map(function (definition) {
            var definitionObject = typeof definition === 'string'
                ? { matchUpFormat: definition }
                : definition;
            if (uniqueMatchUpFormats_1.includes(definitionObject === null || definitionObject === void 0 ? void 0 : definitionObject.matchUpFormat))
                return;
            if (!isValidMatchUpFormat({
                matchUpFormat: definitionObject === null || definitionObject === void 0 ? void 0 : definitionObject.matchUpFormat,
            }))
                return;
            uniqueMatchUpFormats_1.push(definitionObject.matchUpFormat);
            return definitionObject;
        })
            .filter(Boolean);
    }
    var eventType = event.eventType, eventId = event.eventId, category = event.category;
    var categoryName = (_e = (_d = category === null || category === void 0 ? void 0 : category.categoryName) !== null && _d !== void 0 ? _d : category === null || category === void 0 ? void 0 : category.ageCategoryCode) !== null && _e !== void 0 ? _e : eventId;
    if (!eventId)
        return { error: MISSING_EVENT };
    var eventMatchUpFormatTiming = matchUpFormatDefinitions.map(function (_a) {
        var matchUpFormat = _a.matchUpFormat, description = _a.description;
        var timing = getMatchUpFormatTiming({
            tournamentRecord: tournamentRecord,
            matchUpFormat: matchUpFormat,
            categoryName: categoryName,
            categoryType: categoryType,
            eventType: eventType,
            event: event,
        });
        return __assign({ matchUpFormat: matchUpFormat, description: description }, timing);
    });
    return definedAttributes({ eventMatchUpFormatTiming: eventMatchUpFormatTiming, info: info });
}

function getModifiedMatchUpFormatTiming(params) {
    var _a, _b;
    var paramCheck = checkRequiredParameters(params, [
        (_a = {}, _a[TOURNAMENT_RECORD] = true, _a),
        (_b = {},
            _b[VALIDATE] = function (matchUpFormat) { return isValidMatchUpFormat({ matchUpFormat: matchUpFormat }); },
            _b[INVALID] = UNRECOGNIZED_MATCHUP_FORMAT,
            _b[MATCHUP_FORMAT] = true,
            _b),
    ]);
    if (paramCheck.error)
        return paramCheck;
    var tournamentRecord = params.tournamentRecord, matchUpFormat = params.matchUpFormat, event = params.event;
    var eventExtension = findExtension({
        name: SCHEDULE_TIMING,
        element: event,
    }).extension;
    var eventScheduling = eventExtension === null || eventExtension === void 0 ? void 0 : eventExtension.value;
    var tournamentExtension = findExtension({
        element: tournamentRecord,
        name: SCHEDULE_TIMING,
    }).extension;
    var tournamentScheduling = tournamentExtension === null || tournamentExtension === void 0 ? void 0 : tournamentExtension.value;
    var eventAverageTimes = (eventScheduling === null || eventScheduling === void 0 ? void 0 : eventScheduling.matchUpAverageTimes) &&
        findMatchupFormatAverageTimes(__assign(__assign({}, eventScheduling), { matchUpFormat: matchUpFormat }));
    var tournamentAverageTimes = (tournamentScheduling === null || tournamentScheduling === void 0 ? void 0 : tournamentScheduling.matchUpAverageTimes) &&
        findMatchupFormatAverageTimes(__assign(__assign({}, tournamentScheduling), { matchUpFormat: matchUpFormat }));
    var averageTimes = [eventAverageTimes, tournamentAverageTimes].find(function (f) { return f; });
    var eventRecoveryTimes = (eventScheduling === null || eventScheduling === void 0 ? void 0 : eventScheduling.matchUpRecoveryTimes) &&
        findMatchupFormatRecoveryTimes(__assign(__assign({}, eventScheduling), { matchUpFormat: matchUpFormat }));
    var tournamentRecoveryTimes = (tournamentScheduling === null || tournamentScheduling === void 0 ? void 0 : tournamentScheduling.matchUpRecoveryTimes) &&
        findMatchupFormatRecoveryTimes(__assign(__assign({}, tournamentScheduling), { matchUpFormat: matchUpFormat }));
    var recoveryTimes = [eventRecoveryTimes, tournamentRecoveryTimes].find(function (f) { return f; });
    return {
        matchUpFormat: matchUpFormat,
        recoveryTimes: recoveryTimes,
        averageTimes: averageTimes,
    };
}

function getSchedulingProfileIssues(params) {
    var e_1, _a;
    var _b = params !== null && params !== void 0 ? params : {}, _c = _b.scheduleDates, scheduleDates = _c === void 0 ? [] : _c, tournamentRecords = _b.tournamentRecords, _d = _b.periodLength, periodLength = _d === void 0 ? 30 : _d;
    if (typeof tournamentRecords !== 'object')
        return { error: INVALID_TOURNAMENT_RECORD };
    if (!Array.isArray(scheduleDates))
        return { error: INVALID_VALUES };
    var validDates = scheduleDates.every(isValidDateString);
    if (!validDates)
        return { error: INVALID_DATE };
    var issues = [];
    var issuesCount = 0;
    var roundIndexShouldBeAfter = {};
    var schedulingProfile = getSchedulingProfile({ tournamentRecords: tournamentRecords }).schedulingProfile;
    if (!schedulingProfile)
        return __assign({ issues: issues }, SUCCESS);
    var matchUps = allCompetitionMatchUps({
        nextMatchUps: true,
        tournamentRecords: tournamentRecords,
    }).matchUps;
    var _loop_1 = function (dateProfile) {
        var e_2, _e;
        var scheduleDate = dateProfile.scheduleDate, _f = dateProfile.venues, venues = _f === void 0 ? [] : _f;
        // skip scheduleDates that are not specified; process all if none specified
        if (!(scheduleDates === null || scheduleDates === void 0 ? void 0 : scheduleDates.length) || scheduleDates.includes(scheduleDate)) {
            var _loop_2 = function (venue) {
                if (venue) {
                    var rounds = venue.rounds;
                    var schedulingErrors_1 = [];
                    var _j = getScheduledRoundsDetails({
                        tournamentRecords: tournamentRecords,
                        periodLength: periodLength,
                        matchUps: matchUps,
                        rounds: rounds,
                    }), orderedMatchUpIds_1 = _j.orderedMatchUpIds, scheduledRoundsDetails_1 = _j.scheduledRoundsDetails;
                    var matchUpDependencies_1 = getMatchUpDependencies({
                        tournamentRecords: tournamentRecords,
                        matchUps: matchUps,
                    }).matchUpDependencies;
                    var getRoundIndex_1 = function (matchUpId) {
                        var roundIndex;
                        scheduledRoundsDetails_1 === null || scheduledRoundsDetails_1 === void 0 ? void 0 : scheduledRoundsDetails_1.find(function (round, index) {
                            var includes = round.matchUpIds.includes(matchUpId);
                            if (includes)
                                roundIndex = index;
                            return includes;
                        });
                        return roundIndex;
                    };
                    orderedMatchUpIds_1 === null || orderedMatchUpIds_1 === void 0 ? void 0 : orderedMatchUpIds_1.forEach(function (matchUpId, index) {
                        var _a;
                        var followingMatchUpIds = orderedMatchUpIds_1.slice(index + 1);
                        var shouldBeAfter = intersection(followingMatchUpIds, ((_a = matchUpDependencies_1 === null || matchUpDependencies_1 === void 0 ? void 0 : matchUpDependencies_1[matchUpId]) === null || _a === void 0 ? void 0 : _a.matchUpIds) || []);
                        if (shouldBeAfter.length)
                            schedulingErrors_1.push({ matchUpId: matchUpId, shouldBeAfter: shouldBeAfter });
                    });
                    if (schedulingErrors_1.length) {
                        issuesCount += schedulingErrors_1.length;
                        var errorsDetail = schedulingErrors_1.map(function (_a) {
                            var matchUpId = _a.matchUpId, shouldBeAfter = _a.shouldBeAfter;
                            var matchUpRoundIndex = getRoundIndex_1(matchUpId);
                            var earlierRoundIndices = unique(shouldBeAfter.map(getRoundIndex_1));
                            if (!roundIndexShouldBeAfter[scheduleDate]) {
                                roundIndexShouldBeAfter[scheduleDate] = {};
                            }
                            if (!roundIndexShouldBeAfter[scheduleDate][matchUpRoundIndex])
                                roundIndexShouldBeAfter[scheduleDate][matchUpRoundIndex] = [];
                            earlierRoundIndices.forEach(function (index) {
                                if (!roundIndexShouldBeAfter[scheduleDate][matchUpRoundIndex].includes(index)) {
                                    roundIndexShouldBeAfter[scheduleDate][matchUpRoundIndex].push(index);
                                }
                            });
                            return {
                                matchUpId: matchUpId,
                                matchUpRoundIndex: matchUpRoundIndex,
                                earlierRoundIndices: earlierRoundIndices,
                                shouldBeAfter: shouldBeAfter,
                            };
                        });
                        issues.push.apply(issues, __spreadArray([], __read(errorsDetail), false));
                    }
                }
            };
            try {
                for (var _g = (e_2 = void 0, __values(venues || [])), _h = _g.next(); !_h.done; _h = _g.next()) {
                    var venue = _h.value;
                    _loop_2(venue);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_h && !_h.done && (_e = _g.return)) _e.call(_g);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    };
    try {
        // for each date check the rounds for each venue
        for (var schedulingProfile_1 = __values(schedulingProfile), schedulingProfile_1_1 = schedulingProfile_1.next(); !schedulingProfile_1_1.done; schedulingProfile_1_1 = schedulingProfile_1.next()) {
            var dateProfile = schedulingProfile_1_1.value;
            _loop_1(dateProfile);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (schedulingProfile_1_1 && !schedulingProfile_1_1.done && (_a = schedulingProfile_1.return)) _a.call(schedulingProfile_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var profileIssues = {
        matchUpIdShouldBeAfter: Object.assign.apply(Object, __spreadArray([{}], __read(issues.map(function (issue) {
            var _a;
            var matchUpId = issue.matchUpId, shouldBeAfter = issue.shouldBeAfter, earlierRoundIndices = issue.earlierRoundIndices;
            return _a = {},
                _a[matchUpId] = { earlierRoundIndices: earlierRoundIndices, shouldBeAfter: shouldBeAfter },
                _a;
        })), false)),
    };
    return __assign({ issuesCount: issuesCount, profileIssues: profileIssues, roundIndexShouldBeAfter: roundIndexShouldBeAfter }, SUCCESS);
}

function getTournamentPenalties(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var participants = (_b = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants) !== null && _b !== void 0 ? _b : [];
    var allPenalties = participants.reduce(function (penalties, participant) {
        var _a;
        var participantId = participant.participantId;
        ((_a = participant.penalties) !== null && _a !== void 0 ? _a : []).forEach(function (penalty) {
            var penaltyId = (penalty || {}).penaltyId;
            if (penalties[penaltyId]) {
                penalties[penaltyId].participants.push(participantId);
            }
            else {
                penalties[penaltyId] = __assign(__assign({}, penalty), { participantIds: [participantId] });
            }
        });
        return penalties;
    }, {});
    return { penalties: Object.values(allPenalties) };
}

function getCompetitionPenalties(_a) {
    var e_1, _b;
    var tournamentRecords = _a.tournamentRecords;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var allPenalties = [];
    try {
        for (var _c = __values(Object.values(tournamentRecords)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var tournamentRecord = _d.value;
            var penalties = getTournamentPenalties({ tournamentRecord: tournamentRecord }).penalties;
            allPenalties.push.apply(allPenalties, __spreadArray([], __read((penalties !== null && penalties !== void 0 ? penalties : [])), false));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { penalties: allPenalties };
}

function getMatchUpDailyLimitsUpdate(_a) {
    var tournamentRecords = _a.tournamentRecords;
    return getExtensionUpdate({
        extensionName: SCHEDULE_LIMITS,
        tournamentRecords: tournamentRecords,
    });
}

function getCompetitionParticipants(params) {
    var e_1, _a;
    var tournamentRecords = (params || {}).tournamentRecords;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length) {
        return { error: MISSING_TOURNAMENT_RECORDS };
    }
    var participants = [];
    var participantMap = {}; // turn into Map
    var derivedEventInfo = {};
    var derivedDrawInfo = {};
    var matchUps = [];
    var mappedMatchUps = {};
    var participantIdsWithConflicts = [];
    try {
        for (var _b = __values(Object.values(tournamentRecords)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var tournamentRecord = _c.value;
            var _d = getParticipants(__assign(__assign({}, params), { tournamentRecord: tournamentRecord })), idsWithConflicts = _d.participantIdsWithConflicts, tournamentMappedMatchUps = _d.mappedMatchUps, tournamentParticipantMap = _d.participantMap, tournamentParticipants = _d.participants, tournamentMatchUps = _d.matchUps, eventInfo = _d.derivedEventInfo, drawInfo = _d.derivedDrawInfo;
            Object.assign(mappedMatchUps, tournamentMappedMatchUps);
            Object.assign(participantMap, tournamentParticipantMap);
            Object.assign(derivedEventInfo, eventInfo);
            Object.assign(derivedDrawInfo, drawInfo);
            /*
            // fits the use case where participantIds are equivalent to personIds
            for (const tournamentParticipant of tournamentParticipants ?? []) {
              const { participantId } = tournamentParticipant;
              if (!participantMap[participantId]) {
                participantMap[participantId] = tournamentParticipant;
              } else {
                // merge participant record context across tournaments
                participantMap[participantId] = deepMerge(tournamentParticipant, participantMap[participantId], true);
              }
            }
            */
            participants.push.apply(participants, __spreadArray([], __read((tournamentParticipants !== null && tournamentParticipants !== void 0 ? tournamentParticipants : [])), false));
            matchUps.push.apply(matchUps, __spreadArray([], __read((tournamentMatchUps !== null && tournamentMatchUps !== void 0 ? tournamentMatchUps : [])), false));
            idsWithConflicts === null || idsWithConflicts === void 0 ? void 0 : idsWithConflicts.forEach(function (participantId) {
                if (!participantIdsWithConflicts.includes(participantId))
                    participantIdsWithConflicts.push(participantId);
            });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign(__assign({ participantIdsWithConflicts: participantIdsWithConflicts, derivedEventInfo: derivedEventInfo, derivedDrawInfo: derivedDrawInfo, participantMap: participantMap, mappedMatchUps: mappedMatchUps, participants: participants }, SUCCESS), { matchUps: matchUps });
}

function getParticipantIdMatchUps(_a) {
    var tournamentParticipants = _a.tournamentParticipants, drawDefinition = _a.drawDefinition, event = _a.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var result = getAllDrawMatchUps({
        tournamentParticipants: tournamentParticipants,
        inContext: true,
        drawDefinition: drawDefinition,
        event: event,
    });
    var allMatchUps = makeDeepCopy(result.matchUps, false, true);
    var participantIds = unique(allMatchUps.reduce(function (participantIds, matchUp) {
        return participantIds.concat.apply(participantIds, __spreadArray([], __read(matchUp.sides.map(function (side) { return side.participantId; }).filter(Boolean)), false));
    }, []));
    var participantIdMatchUps = Object.assign.apply(Object, __spreadArray([{}], __read(participantIds.map(function (participantId) {
        var _a;
        var matchUps = allMatchUps.filter(function (matchUp) {
            var participantIds = matchUp.sides
                .map(function (side) { return side.participantId; })
                .filter(Boolean);
            return participantIds.includes(participantId);
        });
        return _a = {}, _a[participantId] = matchUps, _a;
    })), false));
    return { participantIds: participantIds, participantIdMatchUps: participantIdMatchUps };
}

function getParticipantIdFinishingPositions(_a) {
    var _b = _a.byeAdvancements, byeAdvancements = _b === void 0 ? false : _b, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var _c = getParticipantIdMatchUps({
        tournamentParticipants: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants,
        drawDefinition: drawDefinition,
    }), participantIds = _c.participantIds, participantIdMatchUps = _c.participantIdMatchUps;
    var participantIdFinishingPositions = participantIds.map(function (participantId) {
        var _a;
        var matchUps = participantIdMatchUps[participantId];
        var relevantMatchUps = matchUps.filter(function (matchUp) {
            return [COMPLETED$1, BYE].includes(matchUp.matchUpStatus) ||
                matchUp.winningSide;
        });
        var finishingPositionRanges = relevantMatchUps.map(function (matchUp) {
            var isByeMatchUp = matchUp.sides.find(function (side) { return side.bye; });
            var participantSide = matchUp.sides.find(function (side) { return side.participantId === participantId; }).sideNumber;
            var advancingSide = matchUp.winningSide ||
                (byeAdvancements && isByeMatchUp && participantSide);
            return advancingSide === participantSide
                ? matchUp.finishingPositionRange.winner
                : matchUp.finishingPositionRange.loser;
        });
        var diff = function (range) { return Math.abs(range[0] - range[1]); };
        var finishingPositionRange = finishingPositionRanges.reduce(function (finishingPositionRange, range) {
            if (!finishingPositionRange)
                return range;
            return diff(finishingPositionRange) < diff(range)
                ? finishingPositionRange
                : range;
        }, undefined);
        return _a = {},
            _a[participantId] = {
                relevantMatchUps: relevantMatchUps,
                finishingPositionRanges: finishingPositionRanges,
                finishingPositionRange: finishingPositionRange,
            },
            _a;
    });
    return Object.assign.apply(Object, __spreadArray([{}], __read(participantIdFinishingPositions), false));
}

function participantScheduledMatchUps(_a) {
    var _b = _a.scheduleAttributes, scheduleAttributes = _b === void 0 ? ['scheduledDate', 'scheduledTime'] : _b, _c = _a.matchUps, matchUps = _c === void 0 ? [] : _c;
    if (!validMatchUps(matchUps))
        return { error: MISSING_MATCHUPS };
    if (!Array.isArray(scheduleAttributes))
        return { error: INVALID_VALUES };
    var scheduledMatchUps = matchUps
        .filter(Boolean)
        .filter(function (_a) {
        var schedule = _a.schedule;
        return hasSchedule({ schedule: schedule, scheduleAttributes: scheduleAttributes });
    })
        .reduce(function (dateMatchUps, matchUp) {
        var schedule = matchUp.schedule;
        var date = extractDate(schedule === null || schedule === void 0 ? void 0 : schedule.scheduledDate);
        var time = extractTime(schedule === null || schedule === void 0 ? void 0 : schedule.scheduledTime);
        if (date && time) {
            if (dateMatchUps[date]) {
                dateMatchUps[date].push(matchUp);
            }
            else {
                dateMatchUps[date] = [matchUp];
            }
        }
        return dateMatchUps;
    }, {});
    // sort all date matchUps
    var dates = Object.keys(scheduledMatchUps);
    dates.forEach(function (date) {
        scheduledMatchUps[date].sort(function (a, b) {
            var _a, _b;
            return timeSort(extractTime((_a = a.schedule) === null || _a === void 0 ? void 0 : _a.scheduledTime), extractTime((_b = b.schedule) === null || _b === void 0 ? void 0 : _b.scheduledTime));
        });
    });
    return __assign(__assign({}, SUCCESS), { scheduledMatchUps: scheduledMatchUps });
}

function getParticipantEventDetails(_a) {
    var _b, _c;
    var tournamentRecord = _a.tournamentRecord, participantId = _a.participantId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!participantId)
        return { error: MISSING_PARTICIPANT_ID };
    // relveantParticipantIds is the target participantId along with any TEAM or PAIR participantIds to which participantId belongs
    var relevantParticipantIds = [participantId].concat(((_b = tournamentRecord.participants) !== null && _b !== void 0 ? _b : [])
        .filter(function (participant) {
        var _a;
        return (participant === null || participant === void 0 ? void 0 : participant.participantType) &&
            [TEAM$1, PAIR].includes(participant.participantType) &&
            ((_a = participant.individualParticipantIds) === null || _a === void 0 ? void 0 : _a.includes(participantId));
    })
        .map(function (participant) { return participant.participantId; }));
    var relevantEvents = ((_c = tournamentRecord.events) !== null && _c !== void 0 ? _c : [])
        .filter(function (event) {
        var _a;
        var enteredParticipantIds = ((_a = event === null || event === void 0 ? void 0 : event.entries) !== null && _a !== void 0 ? _a : []).map(function (entry) { return entry.participantId; });
        return overlap(enteredParticipantIds, relevantParticipantIds);
    })
        .map(function (event) { return ({ eventName: event.eventName, eventId: event.eventId }); });
    return { eventDetails: relevantEvents };
}

function getCompetitionPublishedDrawDetails(_a) {
    var e_1, _b, e_2, _c;
    var _d, _e;
    var tournamentRecords = _a.tournamentRecords;
    var drawIds = [];
    var detailsMap = {};
    try {
        for (var _f = __values(Object.values(tournamentRecords)), _g = _f.next(); !_g.done; _g = _f.next()) {
            var tournamentRecord = _g.value;
            var _loop_1 = function (event_1) {
                var eventPubStatus = getEventPublishStatus({ event: event_1 });
                var drawDetails = eventPubStatus === null || eventPubStatus === void 0 ? void 0 : eventPubStatus.drawDetails;
                if (isObject(drawDetails)) {
                    Object.assign(detailsMap, drawDetails);
                    drawIds.push.apply(drawIds, __spreadArray([], __read(Object.keys(drawDetails).filter(function (drawId) {
                        return getDrawPublishStatus({ drawId: drawId, drawDetails: drawDetails });
                    })), false));
                }
                else if ((_e = eventPubStatus === null || eventPubStatus === void 0 ? void 0 : eventPubStatus.drawIds) === null || _e === void 0 ? void 0 : _e.length) {
                    // LEGACY - deprecate
                    drawIds.push.apply(drawIds, __spreadArray([], __read(eventPubStatus.drawIds), false));
                }
            };
            try {
                for (var _h = (e_2 = void 0, __values((_d = tournamentRecord.events) !== null && _d !== void 0 ? _d : [])), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var event_1 = _j.value;
                    _loop_1(event_1);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { drawIds: drawIds, detailsMap: detailsMap };
}

function scheduledSortedMatchUps(_a) {
    var e_1, _b, e_2, _c, e_3, _d, e_4, _e;
    var schedulingProfile = _a.schedulingProfile, _f = _a.matchUps, matchUps = _f === void 0 ? [] : _f;
    var profileHash = {};
    // hash is used to store a sort order value for scheduled rounds
    var getHash = function (_a) {
        var eventId = _a.eventId, drawId = _a.drawId, structureId = _a.structureId, roundNumber = _a.roundNumber;
        return "".concat(eventId, "|").concat(drawId, "|").concat(structureId).concat(roundNumber);
    };
    if (schedulingProfile === null || schedulingProfile === void 0 ? void 0 : schedulingProfile.length) {
        var roundsGroupings = schedulingProfile
            .map(function (_a) {
            var venues = _a.venues;
            return venues.map(function (_a) {
                var rounds = _a.rounds;
                return rounds;
            });
        })
            .flat();
        roundsGroupings.forEach(function (grouping) {
            var sortedRounds = grouping.sort(function (a, b) { return (a.sortOrder || 0) - (b.sortOrder || 0); });
            sortedRounds.forEach(function (_a, index) {
                var eventId = _a.eventId, drawId = _a.drawId, structureId = _a.structureId, roundNumber = _a.roundNumber;
                var hash = getHash({ eventId: eventId, drawId: drawId, structureId: structureId, roundNumber: roundNumber });
                profileHash[hash] = index;
            });
        });
    }
    var sortedMatchUps = [];
    var dateGroups = { noScheduledDate: [] };
    try {
        // 1. Segregate matchUps by date (date can come from schedule.scheduledDate or schedule.scheduledTime)
        for (var matchUps_1 = __values(matchUps), matchUps_1_1 = matchUps_1.next(); !matchUps_1_1.done; matchUps_1_1 = matchUps_1.next()) {
            var matchUp = matchUps_1_1.value;
            var schedule = matchUp.schedule || {};
            var scheduledDate = (schedule.scheduledDate && extractDate(schedule.scheduledDate)) ||
                (schedule.scheduledTime && extractDate(schedule.scheduledTime)) ||
                'noScheduledDate';
            if (!dateGroups[scheduledDate])
                dateGroups[scheduledDate] = [];
            dateGroups[scheduledDate].push(matchUp);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (matchUps_1_1 && !matchUps_1_1.done && (_b = matchUps_1.return)) _b.call(matchUps_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // this works because all dates are strings and 'noScheduledDate' sorts to last after numeric strings
    var sortedDateKeys = Object.keys(dateGroups).sort();
    try {
        // 2. For each date group, sort all matchUps by time
        for (var sortedDateKeys_1 = __values(sortedDateKeys), sortedDateKeys_1_1 = sortedDateKeys_1.next(); !sortedDateKeys_1_1.done; sortedDateKeys_1_1 = sortedDateKeys_1.next()) {
            var scheduledDate = sortedDateKeys_1_1.value;
            var dateGroup = dateGroups[scheduledDate];
            var timeGroups = { noScheduledTime: [] };
            try {
                for (var dateGroup_1 = (e_3 = void 0, __values(dateGroup)), dateGroup_1_1 = dateGroup_1.next(); !dateGroup_1_1.done; dateGroup_1_1 = dateGroup_1.next()) {
                    var matchUp = dateGroup_1_1.value;
                    var schedule = matchUp.schedule || {};
                    var scheduledTime = (schedule.scheduledTime && extractTime(schedule.scheduledTime)) ||
                        'noScheduledTime';
                    if (!timeGroups[scheduledTime])
                        timeGroups[scheduledTime] = [];
                    timeGroups[scheduledTime].push(matchUp);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (dateGroup_1_1 && !dateGroup_1_1.done && (_d = dateGroup_1.return)) _d.call(dateGroup_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            // this works because all times are strings '00:00' and 'noScheduledTime' sorts to last after numeric strings
            var sortedTimeKeys = Object.keys(timeGroups).sort();
            try {
                // 3. for each time group, sort all matchUps by hash values derived from rounds group order
                for (var sortedTimeKeys_1 = (e_4 = void 0, __values(sortedTimeKeys)), sortedTimeKeys_1_1 = sortedTimeKeys_1.next(); !sortedTimeKeys_1_1.done; sortedTimeKeys_1_1 = sortedTimeKeys_1.next()) {
                    var scheduledTime = sortedTimeKeys_1_1.value;
                    var timeGroup = timeGroups[scheduledTime];
                    timeGroup.sort(function (a, b) {
                        var sortValueA = profileHash[getHash(a)] || 0;
                        var sortValueB = profileHash[getHash(b)] || 0;
                        return sortValueA - sortValueB;
                    });
                    sortedMatchUps.push.apply(sortedMatchUps, __spreadArray([], __read(timeGroup), false));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (sortedTimeKeys_1_1 && !sortedTimeKeys_1_1.done && (_e = sortedTimeKeys_1.return)) _e.call(sortedTimeKeys_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (sortedDateKeys_1_1 && !sortedDateKeys_1_1.done && (_c = sortedDateKeys_1.return)) _c.call(sortedDateKeys_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return sortedMatchUps;
}

function courtGridRows(_a) {
    var _b = _a.courtPrefix, courtPrefix = _b === void 0 ? 'C|' : _b, minRowsCount = _a.minRowsCount, courtsData = _a.courtsData;
    if (!Array.isArray(courtsData))
        return { error: INVALID_VALUES };
    var maxCourtOrder = courtsData === null || courtsData === void 0 ? void 0 : courtsData.reduce(function (order, court) {
        var matchUps = court.matchUps || [];
        var courtOrder = Math.max.apply(Math, __spreadArray([0], __read(matchUps.map(function (m) { return m.schedule.courtOrder || 0; })), false));
        return courtOrder > order ? courtOrder : order;
    }, 1);
    var rowsCount = minRowsCount
        ? Math.max(minRowsCount, maxCourtOrder)
        : maxCourtOrder;
    var rowBuilder = generateRange(0, rowsCount).map(function (rowIndex) { return ({
        matchUps: generateRange(0, courtsData.length).map(function (courtIndex) {
            var courtInfo = courtsData[courtIndex];
            var courtId = courtInfo.courtId, venueId = courtInfo.venueId;
            return {
                schedule: {
                    courtOrder: rowIndex + 1,
                    venueId: venueId,
                    courtId: courtId,
                },
            };
        }),
    }); });
    courtsData.forEach(function (courtInfo, i) {
        var e_1, _a;
        var _b;
        try {
            for (var _c = __values(courtInfo.matchUps), _d = _c.next(); !_d.done; _d = _c.next()) {
                var matchUp = _d.value;
                var courtOrder = (_b = matchUp.schedule) === null || _b === void 0 ? void 0 : _b.courtOrder;
                if (courtOrder) {
                    rowBuilder[courtOrder - 1].matchUps[i] = matchUp;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
    return {
        courtPrefix: courtPrefix,
        rows: rowBuilder.map(function (row, i) {
            return Object.assign.apply(Object, __spreadArray([{ rowId: "rowId-".concat(i + 1) }], __read(row.matchUps.map(function (matchUp, i) {
                var _a;
                return (_a = {},
                    _a["".concat(courtPrefix).concat(i)] = matchUp,
                    _a);
            })), false));
        }),
    };
}

function eventMatchUps(params) {
    var _a;
    var _b, _c, _d;
    var tournamentParticipants = params.participants, contextContent = params.contextContent, participantMap = params.participantMap;
    var tournamentAppliedPolicies = params.tournamentAppliedPolicies, scheduleVisibilityFilters = params.scheduleVisibilityFilters, participantsProfile = params.participantsProfile, afterRecoveryTimes = params.afterRecoveryTimes, policyDefinitions = params.policyDefinitions, useParticipantMap = params.useParticipantMap, tournamentRecord = params.tournamentRecord, usePublishState = params.usePublishState, contextFilters = params.contextFilters, matchUpFilters = params.matchUpFilters, contextProfile = params.contextProfile, nextMatchUps = params.nextMatchUps, tournamentId = params.tournamentId, inContext = params.inContext, context = params.context, event = params.event;
    if (!event)
        return { error: MISSING_EVENT };
    var eventId = event.eventId, eventName = event.eventName, endDate = event.endDate;
    var additionalContext = __assign(__assign({}, context), definedAttributes({
        eventId: eventId,
        eventName: eventName,
        endDate: endDate !== null && endDate !== void 0 ? endDate : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.endDate,
        tournamentId: tournamentId !== null && tournamentId !== void 0 ? tournamentId : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        indoorOutDoor: (_b = event.indoorOutdoor) !== null && _b !== void 0 ? _b : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.indoorOutdoor,
        surfaceCategory: (_c = event.surfaceCategory) !== null && _c !== void 0 ? _c : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.surfaceCategory,
    }));
    var groupInfo;
    if (!tournamentParticipants && tournamentRecord) {
        (_a = hydrateParticipants({
            participantsProfile: participantsProfile,
            policyDefinitions: policyDefinitions,
            useParticipantMap: useParticipantMap,
            tournamentRecord: tournamentRecord,
            contextProfile: contextProfile,
            inContext: inContext,
        }), tournamentParticipants = _a.participants, participantMap = _a.participantMap, groupInfo = _a.groupInfo);
    }
    if (contextProfile && !contextContent)
        contextContent = getContextContent({
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            contextProfile: contextProfile,
            event: event,
        });
    var publishStatus = getEventPublishStatus({ event: event });
    var drawDefinitions = (_d = event.drawDefinitions) !== null && _d !== void 0 ? _d : [];
    var eventResult = drawDefinitions.reduce(function (results, drawDefinition) {
        var drawMatchUpsResult = getDrawMatchUps({
            context: additionalContext,
            tournamentAppliedPolicies: tournamentAppliedPolicies,
            scheduleVisibilityFilters: scheduleVisibilityFilters,
            tournamentParticipants: tournamentParticipants,
            participantsProfile: participantsProfile,
            afterRecoveryTimes: afterRecoveryTimes,
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            usePublishState: usePublishState,
            contextContent: contextContent,
            contextFilters: contextFilters,
            matchUpFilters: matchUpFilters,
            participantMap: participantMap,
            publishStatus: publishStatus,
            contextProfile: contextProfile,
            drawDefinition: drawDefinition,
            nextMatchUps: nextMatchUps,
            inContext: inContext,
            event: event,
        });
        var keys = Object.keys(drawMatchUpsResult);
        keys === null || keys === void 0 ? void 0 : keys.forEach(function (key) {
            if (Array.isArray(drawMatchUpsResult[key])) {
                if (!results[key])
                    results[key] = [];
                results[key] = results[key].concat(drawMatchUpsResult[key]);
            }
        });
        return results;
    }, {});
    return __assign(__assign(__assign({}, eventResult), SUCCESS), { groupInfo: groupInfo });
}

function tournamentMatchUps(params) {
    var _a, _b, _c;
    if (!(params === null || params === void 0 ? void 0 : params.tournamentRecord))
        return { error: MISSING_TOURNAMENT_RECORD };
    var contextContent = params.contextContent;
    var scheduleVisibilityFilters = params.scheduleVisibilityFilters, participantsProfile = params.participantsProfile, afterRecoveryTimes = params.afterRecoveryTimes, policyDefinitions = params.policyDefinitions, useParticipantMap = params.useParticipantMap, tournamentRecord = params.tournamentRecord, _d = params.inContext, inContext = _d === void 0 ? true : _d, usePublishState = params.usePublishState, contextFilters = params.contextFilters, matchUpFilters = params.matchUpFilters, contextProfile = params.contextProfile, nextMatchUps = params.nextMatchUps, context = params.context;
    var tournamentId = (_a = params.tournamentId) !== null && _a !== void 0 ? _a : tournamentRecord.tournamentId;
    var events = (_b = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.events) !== null && _b !== void 0 ? _b : [];
    var _e = hydrateParticipants({
        participantsProfile: participantsProfile,
        policyDefinitions: policyDefinitions,
        useParticipantMap: useParticipantMap,
        tournamentRecord: tournamentRecord,
        contextProfile: contextProfile,
        inContext: inContext,
    }), participants = _e.participants, participantMap = _e.participantMap, groupInfo = _e.groupInfo;
    if (contextProfile && !contextContent)
        contextContent = getContextContent({
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            contextProfile: contextProfile,
        });
    var tournamentAppliedPolicies = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
    }).appliedPolicies;
    var filteredEventIds = (_c = contextFilters === null || contextFilters === void 0 ? void 0 : contextFilters.eventIds) !== null && _c !== void 0 ? _c : [];
    var eventsDrawsMatchUps = events
        .filter(function (event) { return !filteredEventIds.includes(event.eventId); })
        .map(function (event) {
        var _a, _b;
        var flightProfile = getFlightProfile({ event: event }).flightProfile;
        var additionalContext = __assign({ eventDrawsCount: ((_a = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _a === void 0 ? void 0 : _a.length) || ((_b = event.drawDefinitions) === null || _b === void 0 ? void 0 : _b.length) || 0 }, context);
        return eventMatchUps({
            context: additionalContext,
            tournamentAppliedPolicies: tournamentAppliedPolicies,
            scheduleVisibilityFilters: scheduleVisibilityFilters,
            participantsProfile: participantsProfile,
            afterRecoveryTimes: afterRecoveryTimes,
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            usePublishState: usePublishState,
            contextFilters: contextFilters,
            contextProfile: contextProfile,
            contextContent: contextContent,
            matchUpFilters: matchUpFilters,
            participantMap: participantMap,
            participants: participants,
            tournamentId: tournamentId,
            nextMatchUps: nextMatchUps,
            inContext: inContext,
            event: event,
        });
    });
    var eventsDrawMatchUpsResult = eventsDrawsMatchUps.reduce(function (matchUps, eventMatchUps) {
        var keys = eventMatchUps &&
            Object.keys(eventMatchUps).filter(function (key) { return !['success', 'matchUpsMap'].includes(key); });
        keys === null || keys === void 0 ? void 0 : keys.forEach(function (key) {
            if (Array.isArray(eventMatchUps[key])) {
                if (!matchUps[key])
                    matchUps[key] = [];
                matchUps[key] = matchUps[key].concat(eventMatchUps[key]);
                matchUps.matchUpsCount += eventMatchUps[key].length;
            }
        });
        return matchUps;
    }, { matchUpsCount: 0 });
    return __assign(__assign({}, eventsDrawMatchUpsResult), { groupInfo: groupInfo });
}

function getCompetitionMatchUps(_a) {
    var scheduleVisibilityFilters = _a.scheduleVisibilityFilters, participantsProfile = _a.participantsProfile, tournamentRecords = _a.tournamentRecords, policyDefinitions = _a.policyDefinitions, usePublishState = _a.usePublishState, matchUpFilters = _a.matchUpFilters, contextFilters = _a.contextFilters, nextMatchUps = _a.nextMatchUps, inContext = _a.inContext;
    if (typeof tournamentRecords !== 'object' || !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var tournamentIds = Object.keys(tournamentRecords);
    var tournamentsMatchUps = tournamentIds.map(function (tournamentId) {
        var tournamentRecord = tournamentRecords[tournamentId];
        return tournamentMatchUps({
            scheduleVisibilityFilters: scheduleVisibilityFilters,
            participantsProfile: participantsProfile,
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            usePublishState: usePublishState,
            matchUpFilters: matchUpFilters,
            contextFilters: contextFilters,
            nextMatchUps: nextMatchUps,
            inContext: inContext,
        });
    });
    var groupInfo = {};
    var competitionMatchUpsResult = tournamentsMatchUps.reduce(function (groupings, matchUpGroupings) {
        var keys = Object.keys(matchUpGroupings);
        keys.forEach(function (key) {
            if (Array.isArray(matchUpGroupings[key])) {
                if (!groupings[key])
                    groupings[key] = [];
                groupings[key] = groupings[key].concat(matchUpGroupings[key]);
            }
            if (key === 'groupInfo') {
                Object.assign(groupInfo, matchUpGroupings[key]);
            }
        });
        return groupings;
    }, {});
    return __assign(__assign({}, competitionMatchUpsResult), { groupInfo: groupInfo });
}

function competitionScheduleMatchUps(params) {
    var _a;
    var _b, _c, _d, _e, _f, _g, _h, _j;
    if (typeof (params === null || params === void 0 ? void 0 : params.tournamentRecords) !== 'object' || !Object.keys(params === null || params === void 0 ? void 0 : params.tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var _k = getVenuesAndCourts(params), courts = _k.courts, venues = _k.venues;
    var getResult = getSchedulingProfile(params);
    var schedulingProfile = getResult.schedulingProfile;
    var _l = params.sortDateMatchUps, sortDateMatchUps = _l === void 0 ? true : _l, courtCompletedMatchUps = params.courtCompletedMatchUps, alwaysReturnCompleted = params.alwaysReturnCompleted, activeTournamentId = params.activeTournamentId, tournamentRecords = params.tournamentRecords, withCourtGridRows = params.withCourtGridRows, minCourtGridRows = params.minCourtGridRows, usePublishState = params.usePublishState, _m = params.status, status = _m === void 0 ? PUBLIC : _m, sortCourtsData = params.sortCourtsData;
    // PUBLISH.STATUS is attached at the tournament level by `publishOrderOfPlay`
    var tournamentPublishStatus = usePublishState
        ? (_c = (_b = getTournamentTimeItem({
            tournamentRecord: tournamentRecords[activeTournamentId !== null && activeTournamentId !== void 0 ? activeTournamentId : getTournamentId()],
            itemType: "".concat(PUBLISH, ".").concat(STATUS$1),
        }).timeItem) === null || _b === void 0 ? void 0 : _b.itemValue) === null || _c === void 0 ? void 0 : _c[status]
        : undefined;
    var allCompletedMatchUps = alwaysReturnCompleted
        ? getCompetitionMatchUps(__assign(__assign({}, params), { matchUpFilters: __assign(__assign({}, params.matchUpFilters), { matchUpStatuses: [COMPLETED$1] }), contextFilters: params.contextFilters })).completedMatchUps
        : [];
    // if { usePublishState: true } only return non-completed matchUps if there is orderOfPlay detail
    if (usePublishState && (!tournamentPublishStatus || !Object.keys(tournamentPublishStatus).length)) {
        return {
            completedMatchUps: allCompletedMatchUps,
            dateMatchUps: [],
            courtsData: [],
            venues: venues,
        };
    }
    var publishedDrawIds, detailsMap;
    if (usePublishState) {
        (_a = getCompetitionPublishedDrawDetails({
            tournamentRecords: tournamentRecords,
        }), publishedDrawIds = _a.drawIds, detailsMap = _a.detailsMap);
    }
    if (publishedDrawIds === null || publishedDrawIds === void 0 ? void 0 : publishedDrawIds.length) {
        if (!params.contextFilters)
            params.contextFilters = {};
        if (!((_d = params.contextFilters) === null || _d === void 0 ? void 0 : _d.drawIds)) {
            params.contextFilters.drawIds = publishedDrawIds;
        }
        else {
            params.contextFilters.drawIds = params.contextFilters.drawIds.filter(function (drawId) {
                return publishedDrawIds.includes(drawId);
            });
        }
    }
    if ((_e = tournamentPublishStatus === null || tournamentPublishStatus === void 0 ? void 0 : tournamentPublishStatus.eventIds) === null || _e === void 0 ? void 0 : _e.length) {
        if (!params.matchUpFilters)
            params.matchUpFilters = {};
        if ((_f = params.matchUpFilters) === null || _f === void 0 ? void 0 : _f.eventIds) {
            if (!params.matchUpFilters.eventIds.length) {
                params.matchUpFilters.eventIds = tournamentPublishStatus.eventIds;
            }
            else {
                params.matchUpFilters.eventIds = params.matchUpFilters.eventIds.filter(function (eventId) {
                    return tournamentPublishStatus.eventIds.includes(eventId);
                });
            }
        }
        else {
            params.matchUpFilters.eventIds = tournamentPublishStatus.eventIds;
        }
    }
    if ((_g = tournamentPublishStatus === null || tournamentPublishStatus === void 0 ? void 0 : tournamentPublishStatus.scheduledDates) === null || _g === void 0 ? void 0 : _g.length) {
        if (!params.matchUpFilters)
            params.matchUpFilters = {};
        if (params.matchUpFilters.scheduledDates) {
            if (!params.matchUpFilters.scheduledDates.length) {
                params.matchUpFilters.scheduledDates = tournamentPublishStatus.scheduledDates;
            }
            else {
                params.matchUpFilters.scheduledDates = params.matchUpFilters.scheduledDates.filter(function (scheduledDate) {
                    return tournamentPublishStatus.scheduledDates.includes(scheduledDate);
                });
            }
        }
        else {
            params.matchUpFilters.scheduledDates = tournamentPublishStatus.scheduledDates;
        }
    }
    // optimization: if all completed matchUps have already been retrieved, skip the hydration process
    if (alwaysReturnCompleted) {
        if (!params.matchUpFilters)
            params.matchUpFilters = {};
        if ((_j = (_h = params.matchUpFilters) === null || _h === void 0 ? void 0 : _h.excludeMatchUpStatuses) === null || _j === void 0 ? void 0 : _j.length) {
            if (!params.matchUpFilters.excludeMatchUpStatuses.includes(COMPLETED$1)) {
                params.matchUpFilters.excludeMatchUpStatuses.push(COMPLETED$1);
            }
        }
        else {
            params.matchUpFilters.excludeMatchUpStatuses = [COMPLETED$1];
        }
    }
    var _o = getCompetitionMatchUps(__assign(__assign({}, params), { matchUpFilters: params.matchUpFilters, contextFilters: params.contextFilters })), completedMatchUps = _o.completedMatchUps, upcomingMatchUps = _o.upcomingMatchUps, pendingMatchUps = _o.pendingMatchUps, groupInfo = _o.groupInfo;
    var relevantMatchUps = __spreadArray(__spreadArray([], __read((upcomingMatchUps !== null && upcomingMatchUps !== void 0 ? upcomingMatchUps : [])), false), __read((pendingMatchUps !== null && pendingMatchUps !== void 0 ? pendingMatchUps : [])), false);
    // add any stage or structure filtering
    if (detailsMap && Object.keys(detailsMap).length) {
        relevantMatchUps = relevantMatchUps.filter(function (matchUp) {
            var drawId = matchUp.drawId, structureId = matchUp.structureId, stage = matchUp.stage;
            if (!detailsMap[drawId])
                return false;
            if (detailsMap[drawId].stageDetails) {
                var stageKeys = Object.keys(detailsMap[drawId].stageDetails);
                var unpublishedStages = stageKeys.filter(function (stage) { return !detailsMap[drawId].stageDetails[stage].published; });
                var publishedStages = stageKeys.filter(function (stage) { return detailsMap[drawId].stageDetails[stage].published; });
                if (unpublishedStages.length && unpublishedStages.includes(stage))
                    return false;
                if (publishedStages.length && publishedStages.includes(stage))
                    return true;
                return unpublishedStages.length && !unpublishedStages.includes(stage) && !publishedStages.length;
            }
            if (detailsMap[drawId].structureDetails) {
                var structureIdKeys = Object.keys(detailsMap[drawId].structureDetails);
                var unpublishedStructureIds = structureIdKeys.filter(function (structureId) { return !detailsMap[drawId].structureDetails[structureId].published; });
                var publishedStructureIds = structureIdKeys.filter(function (structureId) { return detailsMap[drawId].structureDetails[structureId].published; });
                if (unpublishedStructureIds.length && unpublishedStructureIds.includes(structureId))
                    return false;
                if (publishedStructureIds.length && publishedStructureIds.includes(structureId))
                    return true;
                return (unpublishedStructureIds.length &&
                    !unpublishedStructureIds.includes(structureId) &&
                    !publishedStructureIds.length);
            }
            return true;
        });
    }
    var dateMatchUps = sortDateMatchUps
        ? scheduledSortedMatchUps({ matchUps: relevantMatchUps, schedulingProfile: schedulingProfile })
        : relevantMatchUps;
    var courtsData = courts === null || courts === void 0 ? void 0 : courts.map(function (court) {
        var _a;
        var matchUps = getCourtMatchUps(court);
        return __assign({ surfaceCategory: (_a = court === null || court === void 0 ? void 0 : court.surfaceCategory) !== null && _a !== void 0 ? _a : '', matchUps: matchUps }, court);
    });
    var result = {
        completedMatchUps: alwaysReturnCompleted ? allCompletedMatchUps : completedMatchUps, // completed matchUps for the filter date
        dateMatchUps: dateMatchUps, // all incomplete matchUps for the filter date
        courtsData: courtsData,
        groupInfo: groupInfo,
        venues: venues,
    };
    if (withCourtGridRows) {
        var _p = courtGridRows({
            minRowsCount: minCourtGridRows,
            courtsData: courtsData,
        }), rows = _p.rows, courtPrefix = _p.courtPrefix;
        result.courtPrefix = courtPrefix; // pass through for access to internal defaults by consumer
        result.rows = rows;
    }
    return __assign(__assign({}, result), SUCCESS);
    function getCourtMatchUps(_a) {
        var courtId = _a.courtId;
        var matchUpsToConsider = courtCompletedMatchUps ? dateMatchUps.concat(completedMatchUps !== null && completedMatchUps !== void 0 ? completedMatchUps : []) : dateMatchUps;
        var courtMatchUps = matchUpsToConsider.filter(function (matchUp) {
            var _a, _b, _c;
            return ((_a = matchUp.schedule) === null || _a === void 0 ? void 0 : _a.courtId) === courtId ||
                ((_c = (_b = matchUp.schedule) === null || _b === void 0 ? void 0 : _b.allocatedCourts) === null || _c === void 0 ? void 0 : _c.map(function (_a) {
                    var courtId = _a.courtId;
                    return courtId;
                }).includes(courtId));
        });
        return sortCourtsData
            ? scheduledSortedMatchUps({
                matchUps: courtMatchUps,
                schedulingProfile: schedulingProfile,
            })
            : courtMatchUps;
    }
}

function getParticipantMembership(_a) {
    var tournamentRecord = _a.tournamentRecord, participantId = _a.participantId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!participantId)
        return { error: MISSING_PARTICIPANT_ID };
    var participants = getParticipants({
        participantFilters: { participantTypes: [TEAM$1, PAIR, GROUP] },
        tournamentRecord: tournamentRecord,
    }).participants;
    var memberOf = (participants !== null && participants !== void 0 ? participants : []).filter(function (participant) {
        var _a;
        return (_a = participant.individualParticipantIds) === null || _a === void 0 ? void 0 : _a.includes(participantId);
    });
    return memberOf.reduce(function (groupingTypesMap, participant) {
        var participantType = participant.participantType;
        if (participantType) {
            if (!groupingTypesMap[participantType])
                groupingTypesMap[participantType] = [];
            groupingTypesMap[participantType].push(participant);
        }
        return groupingTypesMap;
    }, {});
}

/**
 *
 * @param {object[]} outcomes - array of outcomes to be applied to matchUps, relevent attributes: { eventId: string; drawId: string; }
 *
 */
function bulkUpdatePublishedEventIds(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, outcomes = _a.outcomes;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!(outcomes === null || outcomes === void 0 ? void 0 : outcomes.length))
        return { error: MISSING_VALUE, info: 'Missing outcomes' };
    var eventIdsMap = outcomes.reduce(function (eventIdsMap, outcome) {
        var drawId = outcome.drawId, eventId = outcome.eventId;
        if (eventId && drawId) {
            if (!eventIdsMap[eventId]) {
                eventIdsMap[eventId] = [drawId];
            }
            else if (!eventIdsMap[eventId].includes(drawId)) {
                eventIdsMap[eventId].push(drawId);
            }
        }
        return eventIdsMap;
    }, {});
    var relevantEventsIds = Object.keys(eventIdsMap);
    var relevantEvents = (_b = tournamentRecord.events) === null || _b === void 0 ? void 0 : _b.filter(function (event) {
        return relevantEventsIds.includes(event.eventId);
    });
    var publishedEventIds = relevantEvents
        .filter(function (event) {
        var pubStatus = getEventPublishStatus({ event: event });
        var _a = pubStatus !== null && pubStatus !== void 0 ? pubStatus : {}, drawDetails = _a.drawDetails, drawIds = _a.drawIds;
        var eventId = event.eventId;
        var publishedDrawIds = eventIdsMap[eventId].filter(function (drawId) {
            var keyedDrawIds = drawDetails
                ? Object.keys(pubStatus.drawDetails).filter(function (drawId) {
                    return getDrawPublishStatus({ drawId: drawId, drawDetails: drawDetails });
                })
                : [];
            return (drawIds === null || drawIds === void 0 ? void 0 : drawIds.includes(drawId)) || keyedDrawIds.includes(drawId);
        });
        return publishedDrawIds.length;
    })
        .map(function (event) { return event.eventId; });
    return { publishedEventIds: publishedEventIds, eventIdPublishedDrawIdsMap: eventIdsMap };
}

function getSourceStructureIdsAndRelevantLinks(_a) {
    var targetRoundNumber = _a.targetRoundNumber, finishingPosition = _a.finishingPosition, drawDefinition = _a.drawDefinition, structureId = _a.structureId, // structure for which source and target links are to be found
    linkType = _a.linkType;
    var links = (getStructureLinks({
        drawDefinition: drawDefinition,
        structureId: structureId,
    }) || {}).links;
    var sourceLinks = ((links === null || links === void 0 ? void 0 : links.target) || [])
        .filter(function (_a) {
        var structureLinkType = _a.linkType;
        return structureLinkType === linkType;
    })
        // if a target roundNumber is provided, only consider structures with link target matching roundNumber
        .filter(function (_a) {
        var target = _a.target;
        return !targetRoundNumber || targetRoundNumber === target.roundNumber;
    });
    var relevantLinks = sourceLinks
        .map(function (link) {
        var sourceStructureId = link.source.structureId;
        var sourceStructure = findStructure({
            structureId: sourceStructureId,
            drawDefinition: drawDefinition,
        }).structure;
        // if finishingPosition has been specified and does not match, ignore link
        if (finishingPosition &&
            (sourceStructure === null || sourceStructure === void 0 ? void 0 : sourceStructure.finishingPosition) !== finishingPosition)
            return;
        return link;
    })
        .filter(Boolean);
    var sourceStructureIds = relevantLinks.map(function (_a) {
        var source = _a.source;
        return source.structureId;
    });
    return { sourceStructureIds: sourceStructureIds, relevantLinks: relevantLinks };
}

var QUALIFYING_PARTICIPANT_METHOD = 'qualifierDrawPositionAssignment';
var WITHDRAW_PARTICIPANT_METHOD = 'withdrawParticipantAtDrawPosition';
var ALTERNATE_PARTICIPANT_METHOD = 'alternateDrawPositionAssignment';
var LUCKY_PARTICIPANT_METHOD = 'luckyLoserDrawPositionAssignment';
var REMOVE_ASSIGNMENT_METHOD = 'removeDrawPositionAssignment';
var SWAP_PARTICIPANT_METHOD = 'swapDrawPositionAssignments';
var MODIFY_PAIR_ASSIGNMENT_METHOD = 'modifyPairAssignment';
var ADD_NICKNAME_METHOD = 'modifyParticipantOtherName';
var ASSIGN_PARTICIPANT_METHOD = 'assignDrawPosition';
var REMOVE_SEED_METHOD = 'removeSeededParticipant';
var ASSIGN_BYE_METHOD = 'assignDrawPositionBye';
var SEED_VALUE_METHOD = 'modifySeedAssignment';
var ADD_PENALTY_METHOD = 'addPenalty';
var MODIFY_PAIR_ASSIGNMENT = 'MODIFY_PAIR';
var QUALIFYING_PARTICIPANT = 'QUALIFIER';
var ALTERNATE_PARTICIPANT = 'ALTERNATE';
var WITHDRAW_PARTICIPANT = 'WITHDRAW';
var ASSIGN_PARTICIPANT = 'ASSIGN';
var REMOVE_ASSIGNMENT = 'REMOVE';
var LUCKY_PARTICIPANT = 'LUCKY';
var REMOVE_SEED = 'REMOVE_SEED';
var SWAP_PARTICIPANTS = 'SWAP';
var ADD_NICKNAME = 'NICKNAME';
var SEED_VALUE = 'SEED_VALUE';
var ADD_PENALTY = 'PENALTY';
var ASSIGN_BYE = 'BYE';
var positionActionConstants = {
    MODIFY_PAIR_ASSIGNMENT: MODIFY_PAIR_ASSIGNMENT,
    QUALIFYING_PARTICIPANT: QUALIFYING_PARTICIPANT,
    ALTERNATE_PARTICIPANT: ALTERNATE_PARTICIPANT,
    WITHDRAW_PARTICIPANT: WITHDRAW_PARTICIPANT,
    ASSIGN_PARTICIPANT: ASSIGN_PARTICIPANT,
    LUCKY_PARTICIPANT: LUCKY_PARTICIPANT,
    REMOVE_ASSIGNMENT: REMOVE_ASSIGNMENT,
    SWAP_PARTICIPANTS: SWAP_PARTICIPANTS,
    ADD_NICKNAME: ADD_NICKNAME,
    REMOVE_SEED: REMOVE_SEED,
    ADD_PENALTY: ADD_PENALTY,
    ASSIGN_BYE: ASSIGN_BYE,
    SEED_VALUE: SEED_VALUE,
};

function getValidModifyAssignedPairAction(_a) {
    var _b;
    var tournamentParticipants = _a.tournamentParticipants, returnParticipants = _a.returnParticipants, drawPosition = _a.drawPosition, participant = _a.participant, drawId = _a.drawId, event = _a.event;
    // only ungrouped individuals who are event.entries are valid
    var availableIndividualParticipantIds = ((_b = event === null || event === void 0 ? void 0 : event.entries) === null || _b === void 0 ? void 0 : _b.filter(function (_a) {
        var entryStatus = _a.entryStatus;
        return [UNGROUPED, UNPAIRED].includes(entryStatus);
    }).map(function (_a) {
        var participantId = _a.participantId;
        return participantId;
    })) || [];
    if (availableIndividualParticipantIds.length) {
        var existingIndividualParticipantIds_1 = participant.individualParticipantIds;
        var availableIndividualParticipants = returnParticipants
            ? tournamentParticipants.filter(function (_a) {
                var participantId = _a.participantId;
                return availableIndividualParticipantIds.includes(participantId);
            })
            : undefined;
        var existingIndividualParticipants = returnParticipants
            ? tournamentParticipants.filter(function (_a) {
                var participantId = _a.participantId;
                return existingIndividualParticipantIds_1.includes(participantId);
            })
            : undefined;
        var validModifyAssignedPairAction = definedAttributes({
            payload: {
                participantId: participant.participantId,
                replacementIndividualParticipantId: undefined,
                existingIndividualParticipantId: undefined,
                drawPosition: drawPosition,
                drawId: drawId,
            },
            method: MODIFY_PAIR_ASSIGNMENT_METHOD,
            availableIndividualParticipantIds: availableIndividualParticipantIds,
            availableIndividualParticipants: availableIndividualParticipants,
            existingIndividualParticipantIds: existingIndividualParticipantIds_1,
            existingIndividualParticipants: existingIndividualParticipants,
            type: MODIFY_PAIR_ASSIGNMENT,
        }, false, false, true);
        return { validModifyAssignedPairAction: validModifyAssignedPairAction };
    }
    return {};
}

function getValidLuckyLosersAction(_a) {
    var e_1, _b;
    var _c, _d, _e, _f, _g, _h;
    var _j = _a.tournamentParticipants, tournamentParticipants = _j === void 0 ? [] : _j, sourceStructuresComplete = _a.sourceStructuresComplete, possiblyDisablingAction = _a.possiblyDisablingAction, isWinRatioFedStructure = _a.isWinRatioFedStructure, activeDrawPositions = _a.activeDrawPositions, positionAssignments = _a.positionAssignments, drawDefinition = _a.drawDefinition, drawPosition = _a.drawPosition, structureId = _a.structureId, structure = _a.structure, drawId = _a.drawId, event = _a.event;
    if (activeDrawPositions.includes(drawPosition) ||
        // can't be a lucky loser if still have matches to play in a round robin structure!!
        (isWinRatioFedStructure && !sourceStructuresComplete)) {
        return {};
    }
    /*
    Available Lucky Losers are those participants who are assigned drawPositions
    in source draw structures and have already lost
  
    If links are by ROUND_OUTCOME, and...
    If there is only one source structure and only one target structure, then no round restrictions;
    otherwise restrict the aviailable lucky losers by the source round in the source structure
    */
    var _k = ((_c = drawDefinition.links) === null || _c === void 0 ? void 0 : _c.reduce(function (ids, link) {
        var _a, _b;
        var sourceStructureId = (_a = link.source) === null || _a === void 0 ? void 0 : _a.structureId;
        var targetStructureId = (_b = link.target) === null || _b === void 0 ? void 0 : _b.structureId;
        if (!ids.sourceStructureIds.includes(sourceStructureId))
            ids.sourceStructureIds.push(sourceStructureId);
        if (!ids.targetStructureIds.includes(targetStructureId))
            ids.targetStructureIds.push(targetStructureId);
        return ids;
    }, { sourceStructureIds: [], targetStructureIds: [] })) || {}, sourceStructureIds = _k.sourceStructureIds, targetStructureIds = _k.targetStructureIds;
    var availableLuckyLoserParticipantIds = [];
    var relevantLinks = (_e = (_d = drawDefinition.links) === null || _d === void 0 ? void 0 : _d.filter(function (link) { var _a; return ((_a = link.target) === null || _a === void 0 ? void 0 : _a.structureId) === structure.structureId; })) !== null && _e !== void 0 ? _e : [];
    var _loop_1 = function (relevantLink) {
        var sourceStructureId = (_f = relevantLink === null || relevantLink === void 0 ? void 0 : relevantLink.source) === null || _f === void 0 ? void 0 : _f.structureId;
        var sourceStructure = findStructure({
            structureId: sourceStructureId,
            drawDefinition: drawDefinition,
        }).structure;
        var restrictBySourceRound = (sourceStructure === null || sourceStructure === void 0 ? void 0 : sourceStructure.finishingPosition) === ROUND_OUTCOME &&
            ((sourceStructureIds === null || sourceStructureIds === void 0 ? void 0 : sourceStructureIds.length) !== 1 || (targetStructureIds === null || targetStructureIds === void 0 ? void 0 : targetStructureIds.length) !== 1);
        var matchUpFilters = {};
        if (restrictBySourceRound) {
            var matchUps = getAllStructureMatchUps({
                drawDefinition: drawDefinition,
                structure: structure,
                event: event,
            }).matchUps;
            var initialRoundNumber_1 = getInitialRoundNumber({
                drawPosition: drawPosition,
                matchUps: matchUps,
            }).initialRoundNumber;
            var relevantLink_1 = (_g = drawDefinition.links) === null || _g === void 0 ? void 0 : _g.find(function (link) { var _a; return ((_a = link.target) === null || _a === void 0 ? void 0 : _a.structureId) === (structure === null || structure === void 0 ? void 0 : structure.structureId) && link.target.roundNumber === initialRoundNumber_1; });
            var sourceRoundNumber = (_h = relevantLink_1 === null || relevantLink_1 === void 0 ? void 0 : relevantLink_1.source) === null || _h === void 0 ? void 0 : _h.roundNumber;
            matchUpFilters.roundNumbers = [sourceRoundNumber];
        }
        var completedMatchUps = getStructureMatchUps({
            structureId: sourceStructureId,
            inContext: true,
            matchUpFilters: matchUpFilters,
            drawDefinition: drawDefinition,
        }).completedMatchUps;
        var assignedParticipantIds = positionAssignments.map(function (assignment) { return assignment.participantId; }).filter(Boolean);
        var availableParticipantIds = completedMatchUps === null || completedMatchUps === void 0 ? void 0 : completedMatchUps.filter(function (_a) {
            var matchUpType = _a.matchUpType, winningSide = _a.winningSide;
            return winningSide && ((event === null || event === void 0 ? void 0 : event.eventType) !== TEAM$2 || matchUpType === TEAM$2);
        }).map(function (_a) {
            var winningSide = _a.winningSide, sides = _a.sides;
            return winningSide && (sides === null || sides === void 0 ? void 0 : sides[1 - (winningSide - 1)]);
        }).map(xa('participantId')).filter(function (participantId) { return participantId && !assignedParticipantIds.includes(participantId); });
        availableParticipantIds === null || availableParticipantIds === void 0 ? void 0 : availableParticipantIds.forEach(function (participantId) {
            // ensure if 'restrictBySourceRound' is false and there are multiple links that participants aren't added multiple times
            if (!availableLuckyLoserParticipantIds.includes(participantId))
                availableLuckyLoserParticipantIds.push(participantId);
        });
    };
    try {
        for (var relevantLinks_1 = __values(relevantLinks), relevantLinks_1_1 = relevantLinks_1.next(); !relevantLinks_1_1.done; relevantLinks_1_1 = relevantLinks_1.next()) {
            var relevantLink = relevantLinks_1_1.value;
            _loop_1(relevantLink);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (relevantLinks_1_1 && !relevantLinks_1_1.done && (_b = relevantLinks_1.return)) _b.call(relevantLinks_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var availableLuckyLosers = tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.filter(function (participant) { return availableLuckyLoserParticipantIds === null || availableLuckyLoserParticipantIds === void 0 ? void 0 : availableLuckyLoserParticipantIds.includes(participant.participantId); });
    availableLuckyLosers === null || availableLuckyLosers === void 0 ? void 0 : availableLuckyLosers.forEach(function (luckyLoser) {
        var _a;
        var entry = ((_a = drawDefinition.entries) !== null && _a !== void 0 ? _a : []).find(function (entry) { return entry.participantId === luckyLoser.participantId; });
        luckyLoser.entryPosition = entry === null || entry === void 0 ? void 0 : entry.entryPosition;
    });
    if (availableLuckyLoserParticipantIds === null || availableLuckyLoserParticipantIds === void 0 ? void 0 : availableLuckyLoserParticipantIds.length) {
        var validLuckyLosersAction = {
            type: LUCKY_PARTICIPANT,
            method: LUCKY_PARTICIPANT_METHOD,
            availableLuckyLosers: availableLuckyLosers,
            availableLuckyLoserParticipantIds: availableLuckyLoserParticipantIds,
            willDisableLinks: possiblyDisablingAction,
            payload: { drawId: drawId, structureId: structureId, drawPosition: drawPosition },
        };
        return { validLuckyLosersAction: validLuckyLosersAction };
    }
    return {};
}

function getValidAlternatesAction(_a) {
    var _b, _c, _d, _e, _f, _g;
    var _h = _a.tournamentParticipants, tournamentParticipants = _h === void 0 ? [] : _h, possiblyDisablingAction = _a.possiblyDisablingAction, activeDrawPositions = _a.activeDrawPositions, positionAssignments = _a.positionAssignments, returnParticipants = _a.returnParticipants, appliedPolicies = _a.appliedPolicies, drawDefinition = _a.drawDefinition, drawPosition = _a.drawPosition, validActions = _a.validActions, structureId = _a.structureId, structure = _a.structure, drawId = _a.drawId, event = _a.event;
    if (activeDrawPositions.includes(drawPosition))
        return {};
    var validAssignmentParticipantIds = (_b = validActions.find(function (action) { return action.type === ASSIGN_PARTICIPANT; })) === null || _b === void 0 ? void 0 : _b.availableParticipantIds;
    // TODO: document policy options
    var otherFlightEntries = (_c = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_POSITION_ACTIONS]) === null || _c === void 0 ? void 0 : _c.otherFlightEntries;
    var restrictQualifyingAlternates = (_d = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_POSITION_ACTIONS]) === null || _d === void 0 ? void 0 : _d.restrictQualifyingAlternates;
    var drawEnteredParticipantIds = ((_e = drawDefinition.entries) !== null && _e !== void 0 ? _e : [])
        .filter(function (_a) {
        var entryStage = _a.entryStage;
        return !restrictQualifyingAlternates ||
            (structure.stage === QUALIFYING
                ? entryStage === QUALIFYING
                : entryStage !== QUALIFYING);
    })
        .sort(function (a, b) { var _a, _b; return ((_a = a.entryPosition) !== null && _a !== void 0 ? _a : Infinity) - ((_b = b.entryPosition) !== null && _b !== void 0 ? _b : Infinity); })
        .map(function (_a) {
        var participantId = _a.participantId;
        return participantId;
    })
        .filter(Boolean);
    var allPositionedParticipantIds = getAllPositionedParticipantIds({
        drawDefinition: drawDefinition,
    }).allPositionedParticipantIds;
    var assignedParticipantIds = positionAssignments
        .map(function (assignment) { return assignment.participantId; })
        .filter(Boolean);
    var availableDrawEnteredParticipantIds = drawEnteredParticipantIds.filter(function (participantId) {
        return structure.stage && [QUALIFYING, MAIN, PLAY_OFF].includes(structure.stage)
            ? !(allPositionedParticipantIds === null || allPositionedParticipantIds === void 0 ? void 0 : allPositionedParticipantIds.includes(participantId))
            : !assignedParticipantIds.includes(participantId);
    });
    var eventEntries = (_f = event === null || event === void 0 ? void 0 : event.entries) !== null && _f !== void 0 ? _f : [];
    var availableEventAlternatesParticipantIds = eventEntries
        .filter(function (entry) {
        return entry.entryStatus === ALTERNATE &&
            eligibleEntryStage({
                restrictQualifyingAlternates: restrictQualifyingAlternates,
                structure: structure,
                entry: entry,
            }) &&
            (structure.stage &&
                [QUALIFYING, MAIN, PLAY_OFF].includes(structure.stage)
                ? !(allPositionedParticipantIds === null || allPositionedParticipantIds === void 0 ? void 0 : allPositionedParticipantIds.includes(entry.participantId))
                : !assignedParticipantIds.includes(entry.participantId));
    })
        .sort(function (a, b) { var _a, _b; return ((_a = a.entryPosition) !== null && _a !== void 0 ? _a : Infinity) - ((_b = b.entryPosition) !== null && _b !== void 0 ? _b : Infinity); })
        .map(function (entry) { return entry.participantId; });
    var availableAlternatesParticipantIds = unique(availableDrawEnteredParticipantIds.concat(availableEventAlternatesParticipantIds));
    if (otherFlightEntries) {
        var flightProfile = event
            ? getFlightProfile({ event: event }).flightProfile
            : undefined;
        var otherFlightEnteredParticipantIds = (_g = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _g === void 0 ? void 0 : _g.filter(function (flight) { return flight.drawId !== drawId; }).map(function (flight) {
            return flight.drawEntries
                .filter(function (entry) {
                return entry.participantId &&
                    ![WITHDRAWN, UNGROUPED, UNPAIRED].includes(entry.entryStatus) &&
                    !drawEnteredParticipantIds.includes(entry.participantId);
            })
                .map(function (_a) {
                var participantId = _a.participantId;
                return participantId;
            });
        }).flat().filter(Boolean);
        if (otherFlightEnteredParticipantIds === null || otherFlightEnteredParticipantIds === void 0 ? void 0 : otherFlightEnteredParticipantIds.length) {
            // include direct acceptance participants from other flights
            availableAlternatesParticipantIds.push.apply(availableAlternatesParticipantIds, __spreadArray([], __read(otherFlightEnteredParticipantIds), false));
        }
    }
    // ensure that participantId is not available in multiple assignment options
    if (validAssignmentParticipantIds === null || validAssignmentParticipantIds === void 0 ? void 0 : validAssignmentParticipantIds.length) {
        availableAlternatesParticipantIds =
            availableAlternatesParticipantIds.filter(function (id) { return !validAssignmentParticipantIds.includes(id); });
    }
    var availableAlternates = returnParticipants
        ? tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.filter(function (participant) {
            return availableAlternatesParticipantIds.includes(participant.participantId);
        })
        : undefined;
    availableAlternates === null || availableAlternates === void 0 ? void 0 : availableAlternates.forEach(function (alternate) {
        var _a;
        var entry = ((_a = drawDefinition.entries) !== null && _a !== void 0 ? _a : []).find(function (entry) { return entry.participantId === alternate.participantId; });
        alternate.entryPosition = entry === null || entry === void 0 ? void 0 : entry.entryPosition;
    });
    availableAlternates === null || availableAlternates === void 0 ? void 0 : availableAlternates.sort(function (a, b) {
        return (a.entryPosition || Infinity) - (b.entryPosition || Infinity);
    });
    if (availableAlternatesParticipantIds.length) {
        var validAlternatesAction = definedAttributes({
            payload: { drawId: drawId, structureId: structureId, drawPosition: drawPosition },
            willDisableLinks: possiblyDisablingAction,
            method: ALTERNATE_PARTICIPANT_METHOD,
            availableAlternatesParticipantIds: availableAlternatesParticipantIds,
            type: ALTERNATE_PARTICIPANT,
            availableAlternates: availableAlternates,
        });
        return { validAlternatesAction: validAlternatesAction };
    }
    return {};
}
function eligibleEntryStage(_a) {
    var restrictQualifyingAlternates = _a.restrictQualifyingAlternates, structure = _a.structure, entry = _a.entry;
    var stage = structure.stage;
    if (!entry.entryStage ||
        entry.entryStage === stage ||
        (stage === QUALIFYING && !restrictQualifyingAlternates) ||
        (entry.entryStage === MAIN && stage === CONSOLATION))
        return true;
    return undefined;
}

function getValidAssignmentActions(_a) {
    var _b, _c, _d;
    var positionSourceStructureIds = _a.positionSourceStructureIds, unassignedParticipantIds = _a.unassignedParticipantIds, possiblyDisablingAction = _a.possiblyDisablingAction, provisionalPositioning = _a.provisionalPositioning, tournamentParticipants = _a.tournamentParticipants, isWinRatioFedStructure = _a.isWinRatioFedStructure, positionAssignments = _a.positionAssignments, returnParticipants = _a.returnParticipants, appliedPolicies = _a.appliedPolicies, drawDefinition = _a.drawDefinition, seedingProfile = _a.seedingProfile, isByePosition = _a.isByePosition, drawPosition = _a.drawPosition, structureId = _a.structureId, event = _a.event;
    var drawId = drawDefinition.drawId;
    var validAssignmentActions = [];
    var unplacedSeedParticipantIds, unplacedSeedAssignments, unfilledPositions = [];
    var ignoreSeedPositions = (_c = (_b = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_SEEDING]) === null || _b === void 0 ? void 0 : _b.validSeedPositions) === null || _c === void 0 ? void 0 : _c.ignore;
    if (!ignoreSeedPositions) {
        var result = getNextSeedBlock({
            provisionalPositioning: provisionalPositioning,
            returnAllProxies: true,
            randomize: true,
            drawDefinition: drawDefinition,
            seedingProfile: seedingProfile,
            structureId: structureId,
            event: event,
        });
        (unplacedSeedParticipantIds = result.unplacedSeedParticipantIds, unplacedSeedAssignments = result.unplacedSeedAssignments, unfilledPositions = result.unfilledPositions);
    }
    // if there are no unfilledPositions for available seeds then return all unfilled positions
    if (!(unfilledPositions === null || unfilledPositions === void 0 ? void 0 : unfilledPositions.length)) {
        unfilledPositions = positionAssignments
            .filter(function (assignment) { return !assignment.participantId && !assignment.bye && !assignment.qualifier; })
            .map(function (assignment) { return assignment.drawPosition; });
    }
    if (!isByePosition) {
        validAssignmentActions.push({
            payload: { drawId: drawId, structureId: structureId, drawPosition: drawPosition, isPositionAction: true },
            willDisableLinks: possiblyDisablingAction,
            method: ASSIGN_BYE_METHOD,
            type: ASSIGN_BYE,
        });
    }
    if (isWinRatioFedStructure && ignoreSeedPositions) {
        var assignedParticipantIds_1 = positionAssignments.map(function (assignment) { return assignment.participantId; }).filter(Boolean);
        var matchUpFilters = { structureIds: positionSourceStructureIds };
        var completedMatchUps = getDrawMatchUps({
            inContext: true,
            matchUpFilters: matchUpFilters,
            drawDefinition: drawDefinition,
        }).completedMatchUps;
        var availableParticipantIds_1 = unique((_d = (completedMatchUps !== null && completedMatchUps !== void 0 ? completedMatchUps : [])
            // filter completedMatchUps to exclude SINGLES/DOUBLES for TEAM events
            .filter(function (_a) {
            var matchUpType = _a.matchUpType;
            return (event === null || event === void 0 ? void 0 : event.eventType) !== TEAM$2 || matchUpType === TEAM$2;
        })) === null || _d === void 0 ? void 0 : _d.map(function (_a) {
            var sides = _a.sides;
            return sides === null || sides === void 0 ? void 0 : sides.map(xa('participantId'));
        }).flat().filter(function (participantId) { return participantId && !assignedParticipantIds_1.includes(participantId); }));
        var participantsAvailable = returnParticipants
            ? tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.filter(function (participant) { return availableParticipantIds_1 === null || availableParticipantIds_1 === void 0 ? void 0 : availableParticipantIds_1.includes(participant.participantId); }).map(function (participant) { return makeDeepCopy(participant, undefined, true); })
            : undefined;
        participantsAvailable === null || participantsAvailable === void 0 ? void 0 : participantsAvailable.forEach(function (participant) {
            var _a;
            var entry = ((_a = drawDefinition.entries) !== null && _a !== void 0 ? _a : []).find(function (entry) { return entry.participantId === participant.participantId; });
            // TODO: determine if this is in fact used downstream
            participant.entryPosition = entry === null || entry === void 0 ? void 0 : entry.entryPosition;
        });
        if (participantsAvailable === null || participantsAvailable === void 0 ? void 0 : participantsAvailable.length) {
            validAssignmentActions.push(definedAttributes({
                payload: { drawId: drawId, structureId: structureId, drawPosition: drawPosition },
                willDisableLinks: possiblyDisablingAction,
                method: ASSIGN_PARTICIPANT_METHOD,
                type: ASSIGN_PARTICIPANT,
                availableParticipantIds: availableParticipantIds_1,
                participantsAvailable: participantsAvailable,
            }));
        }
        return { validAssignmentActions: validAssignmentActions };
    }
    if (unfilledPositions.includes(drawPosition) || isByePosition) {
        var availableParticipantIds_2;
        if (unplacedSeedAssignments === null || unplacedSeedAssignments === void 0 ? void 0 : unplacedSeedAssignments.length) {
            // return any valid seedAssignments
            var validToAssign = unplacedSeedAssignments.filter(function (seedAssignment) { return unplacedSeedParticipantIds === null || unplacedSeedParticipantIds === void 0 ? void 0 : unplacedSeedParticipantIds.includes(seedAssignment.participantId); });
            validToAssign.sort(validAssignmentsSort);
            availableParticipantIds_2 = validToAssign.map(function (assignment) { return assignment.participantId; });
        }
        else {
            // otherwise look for any unplaced entries
            availableParticipantIds_2 = unassignedParticipantIds;
        }
        // add structureId and drawPosition to the payload so the client doesn't need to discover
        var participantsAvailable = returnParticipants
            ? tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.filter(function (participant) { return availableParticipantIds_2.includes(participant.participantId); }).map(function (participant) { return makeDeepCopy(participant, undefined, true); })
            : undefined;
        if (participantsAvailable === null || participantsAvailable === void 0 ? void 0 : participantsAvailable.length) {
            validAssignmentActions.push(definedAttributes({
                payload: { drawId: drawId, structureId: structureId, drawPosition: drawPosition },
                willDisableLinks: possiblyDisablingAction,
                method: ASSIGN_PARTICIPANT_METHOD,
                type: ASSIGN_PARTICIPANT,
                availableParticipantIds: availableParticipantIds_2,
                participantsAvailable: participantsAvailable,
            }));
        }
    }
    return { validAssignmentActions: validAssignmentActions };
}
function validAssignmentsSort(a, b) {
    if (a.bye)
        return -1;
    if (getNumericSeedValue(a.seedValue) < getNumericSeedValue(b.seedValue) || (a.seedValue && !b.seedValue))
        return -1;
    return (a.seedNumber || 0) - (b.seedNumber || 0);
}

function getValidQualifiersAction(_a) {
    var e_1, _b, e_2, _c;
    var _d, _e, _f, _g;
    var 
    /*
    activeDrawPositions,
    isQualifierPosition, // restrict based on policyDefinition
    */
    drawPositionInitialRounds = _a.drawPositionInitialRounds, tournamentParticipants = _a.tournamentParticipants, positionAssignments = _a.positionAssignments, returnParticipants = _a.returnParticipants, appliedPolicies = _a.appliedPolicies, drawDefinition = _a.drawDefinition, drawPosition = _a.drawPosition, structureId = _a.structureId, drawId = _a.drawId;
    var qualifyingParticipants = [];
    var qualifyingParticipantIds = [];
    var validAssignmentActions = [];
    var sourceStructureIds = [];
    var assignedParticipantIds = positionAssignments
        .map(function (assignment) { return assignment.participantId; })
        .filter(Boolean);
    var policy = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_POSITION_ACTIONS];
    // get the round number in which the drawPosition initially occurs
    var targetRoundNumber = !(policy === null || policy === void 0 ? void 0 : policy.disableRoundRestrictions) &&
        drawPositionInitialRounds[drawPosition];
    // disallow placing qualifiers until source structure is completed
    var requireCompletedStructures = policy === null || policy === void 0 ? void 0 : policy.requireCompletedStructures;
    var _h = getSourceStructureIdsAndRelevantLinks({
        targetRoundNumber: targetRoundNumber, // look for soure structrues targeting roundNumber
        linkType: WINNER, // WINNER of qualifying structures will traverse link
        drawDefinition: drawDefinition,
        structureId: structureId,
    }) || {}, eliminationSoureStructureIds = _h.sourceStructureIds, eliminationSourceLinks = _h.relevantLinks;
    if (eliminationSoureStructureIds === null || eliminationSoureStructureIds === void 0 ? void 0 : eliminationSoureStructureIds.length)
        sourceStructureIds.push.apply(sourceStructureIds, __spreadArray([], __read(eliminationSoureStructureIds), false));
    var _j = getSourceStructureIdsAndRelevantLinks({
        targetRoundNumber: targetRoundNumber, // look for soure structrues targeting roundNumber
        linkType: POSITION, // link will define how many finishingPositions traverse the link
        drawDefinition: drawDefinition,
        structureId: structureId,
    }) || {}, roundRobinSourceStructureIds = _j.sourceStructureIds, roundRobinSourceLinks = _j.relevantLinks;
    if (roundRobinSourceStructureIds === null || roundRobinSourceStructureIds === void 0 ? void 0 : roundRobinSourceStructureIds.length)
        sourceStructureIds.push.apply(sourceStructureIds, __spreadArray([], __read(roundRobinSourceStructureIds), false));
    var _loop_1 = function (sourceLink) {
        var e_3, _k;
        var structure = (_d = drawDefinition.structures) === null || _d === void 0 ? void 0 : _d.find(function (structure) { return structure.structureId === sourceLink.source.structureId; });
        if ((structure === null || structure === void 0 ? void 0 : structure.stage) !== QUALIFYING)
            return "continue";
        var structureCompleted = isCompletedStructure({
            structureId: sourceLink.source.structureId,
            drawDefinition: drawDefinition,
        });
        if (!requireCompletedStructures || structureCompleted) {
            var qualifyingRoundNumber = structure.qualifyingRoundNumber;
            var matchUps = getAllStructureMatchUps({
                matchUpFilters: {
                    roundNumbers: [qualifyingRoundNumber],
                    hasWinningSide: true,
                },
                afterRecoveryTimes: false,
                tournamentParticipants: tournamentParticipants,
                inContext: true,
                structure: structure,
            }).matchUps;
            var _loop_3 = function (matchUp) {
                var winningSide = matchUp.sides.find(function (side) { return (side === null || side === void 0 ? void 0 : side.sideNumber) === matchUp.winningSide; });
                var relevantSide = matchUp.matchUpStatus === BYE &&
                    ((_e = matchUp.sides) === null || _e === void 0 ? void 0 : _e.find(function (_a) {
                        var participantId = _a.participantId;
                        return participantId;
                    }));
                if (winningSide || relevantSide) {
                    var _l = winningSide || relevantSide || {}, participantId = _l.participantId, participant = _l.participant;
                    if (participantId &&
                        !assignedParticipantIds.includes(participantId)) {
                        if (participant && returnParticipants)
                            qualifyingParticipants.push(participant);
                        qualifyingParticipantIds.push(participantId);
                    }
                }
            };
            try {
                for (var matchUps_1 = (e_3 = void 0, __values(matchUps)), matchUps_1_1 = matchUps_1.next(); !matchUps_1_1.done; matchUps_1_1 = matchUps_1.next()) {
                    var matchUp = matchUps_1_1.value;
                    _loop_3(matchUp);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (matchUps_1_1 && !matchUps_1_1.done && (_k = matchUps_1.return)) _k.call(matchUps_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    };
    try {
        for (var eliminationSourceLinks_1 = __values(eliminationSourceLinks), eliminationSourceLinks_1_1 = eliminationSourceLinks_1.next(); !eliminationSourceLinks_1_1.done; eliminationSourceLinks_1_1 = eliminationSourceLinks_1.next()) {
            var sourceLink = eliminationSourceLinks_1_1.value;
            _loop_1(sourceLink);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (eliminationSourceLinks_1_1 && !eliminationSourceLinks_1_1.done && (_b = eliminationSourceLinks_1.return)) _b.call(eliminationSourceLinks_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var _loop_2 = function (sourceLink) {
        var structure = (_f = drawDefinition.structures) === null || _f === void 0 ? void 0 : _f.find(function (structure) { return structure.structureId === sourceLink.source.structureId; });
        if ((structure === null || structure === void 0 ? void 0 : structure.stage) !== QUALIFYING)
            return "continue";
        var structureCompleted = isCompletedStructure({
            structureId: sourceLink.source.structureId,
            drawDefinition: drawDefinition,
        });
        if (!requireCompletedStructures || structureCompleted) {
            var positionAssignments_1 = getPositionAssignments$1({ structure: structure }).positionAssignments;
            var relevantParticipantIds_1 = (_g = positionAssignments_1 === null || positionAssignments_1 === void 0 ? void 0 : positionAssignments_1.map(function (assignment) {
                var _a;
                var participantId = assignment.participantId;
                var results = (_a = findExtension({
                    element: assignment,
                    name: TALLY,
                }).extension) === null || _a === void 0 ? void 0 : _a.value;
                return results
                    ? { participantId: participantId, groupOrder: results === null || results === void 0 ? void 0 : results.groupOrder }
                    : {};
            }).filter(function (_a) {
                var groupOrder = _a.groupOrder, participantId = _a.participantId;
                // TODO: is this limiting RR qualifiers to groupOrder: 1?
                return groupOrder === 1 &&
                    !assignedParticipantIds.includes(participantId);
            }).map(function (_a) {
                var participantId = _a.participantId;
                return participantId;
            })) !== null && _g !== void 0 ? _g : [];
            if (relevantParticipantIds_1)
                qualifyingParticipantIds.push.apply(qualifyingParticipantIds, __spreadArray([], __read(relevantParticipantIds_1), false));
            if (returnParticipants) {
                var relevantParticipants = tournamentParticipants.filter(function (_a) {
                    var participantId = _a.participantId;
                    return relevantParticipantIds_1.includes(participantId);
                });
                qualifyingParticipants.push.apply(qualifyingParticipants, __spreadArray([], __read(relevantParticipants), false));
            }
        }
    };
    try {
        for (var roundRobinSourceLinks_1 = __values(roundRobinSourceLinks), roundRobinSourceLinks_1_1 = roundRobinSourceLinks_1.next(); !roundRobinSourceLinks_1_1.done; roundRobinSourceLinks_1_1 = roundRobinSourceLinks_1.next()) {
            var sourceLink = roundRobinSourceLinks_1_1.value;
            _loop_2(sourceLink);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (roundRobinSourceLinks_1_1 && !roundRobinSourceLinks_1_1.done && (_c = roundRobinSourceLinks_1.return)) _c.call(roundRobinSourceLinks_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    // this should be "if qualifiers are available"
    if (qualifyingParticipantIds.length) {
        validAssignmentActions.push(definedAttributes({
            payload: {
                qualifyingParticipantId: undefined, // to be provided by client
                drawPosition: drawPosition,
                structureId: structureId,
                drawId: drawId,
            },
            method: QUALIFYING_PARTICIPANT_METHOD,
            type: QUALIFYING_PARTICIPANT,
            qualifyingParticipantIds: qualifyingParticipantIds,
            qualifyingParticipants: returnParticipants
                ? qualifyingParticipants
                : undefined,
        }));
    }
    return { validAssignmentActions: validAssignmentActions, sourceStructureIds: sourceStructureIds };
}
/**
  if (sourceStructureIds.length > 1)
    return decorateResult({
      stack: 'getValidQualifiersSaction',
      info: 'too many source structures',
      result: { error: INVALID_VALUES },
      context: { sourceStructureIds },
    });
  */

function getValidSwapAction(_a) {
    var _b;
    var _c = _a.onlyAssignedPositions, onlyAssignedPositions = _c === void 0 ? true : _c, possiblyDisablingAction = _a.possiblyDisablingAction, tournamentParticipants = _a.tournamentParticipants, inactiveDrawPositions = _a.inactiveDrawPositions, activeDrawPositions = _a.activeDrawPositions, positionAssignments = _a.positionAssignments, returnParticipants = _a.returnParticipants, byeDrawPositions = _a.byeDrawPositions, drawDefinition = _a.drawDefinition, isByePosition = _a.isByePosition, drawPosition = _a.drawPosition, structureId = _a.structureId, structure = _a.structure, drawId = _a.drawId, event = _a.event;
    if (activeDrawPositions.includes(drawPosition))
        return {};
    // assignmentCheck is used to filter out unassigned drawPositions
    var assignmentCheck = function (assignment) {
        return !onlyAssignedPositions ||
            assignment.participantId ||
            assignment.qualifier ||
            assignment.bye;
    };
    // availableDrawPositions filters out selectedDrawPosition
    // and if selectedDrawPosition is a BYE it filters out other drawPositions which are assigned BYEs
    var availableDrawPositions = inactiveDrawPositions === null || inactiveDrawPositions === void 0 ? void 0 : inactiveDrawPositions.filter(function (position) {
        return position !== drawPosition &&
            !(isByePosition && byeDrawPositions.includes(position));
    });
    // filteredAssignments are all assignements which are availble and pass assignmentCheck
    var filteredAssignments = (_b = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.filter(function (assignment) {
        return assignmentCheck(assignment) &&
            (availableDrawPositions === null || availableDrawPositions === void 0 ? void 0 : availableDrawPositions.includes(assignment.drawPosition));
    })) !== null && _b !== void 0 ? _b : [];
    // get relevant drawPositions => relevantMatchUps => sides => sourceDrawPositionRanges
    var filteredDrawPositions = filteredAssignments.map(function (_a) {
        var drawPosition = _a.drawPosition;
        return drawPosition;
    });
    var matchUps = getAllStructureMatchUps({
        afterRecoveryTimes: false,
        inContext: true,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    }).matchUps;
    var relevantMatchUps = matchUps.filter(function (_a) {
        var drawPositions = _a.drawPositions;
        return overlap(drawPositions, filteredDrawPositions);
    });
    var sourceDrawPositionRangeMap = Object.assign.apply(Object, __spreadArray([{}], __read(relevantMatchUps
        .map(function (matchUp) {
        var _a;
        return (_a = matchUp.sides) === null || _a === void 0 ? void 0 : _a.filter(function (_a) {
            var sourceDrawPositionRange = _a.sourceDrawPositionRange;
            return sourceDrawPositionRange;
        }).map(function (_a) {
            var _b;
            var drawPosition = _a.drawPosition, sourceDrawPositionRange = _a.sourceDrawPositionRange;
            return (_b = {},
                _b[drawPosition] = sourceDrawPositionRange,
                _b);
        });
    })
        .flat()), false));
    // availableAssignmentsMap is used to attach participant object to all filteredAssignments
    // which have a participant assginment so the client/UI has all relevant drawPosition details
    var availableParticipantIds = filteredAssignments
        .map(function (assignment) { return assignment.participantId; })
        .filter(Boolean);
    var participantsAvailable = (tournamentParticipants !== null && tournamentParticipants !== void 0 ? tournamentParticipants : []).filter(function (participant) { return availableParticipantIds.includes(participant.participantId); });
    var availableParticipantsMap = Object.assign.apply(Object, __spreadArray([{}], __read(participantsAvailable.map(function (participant) {
        var _a;
        return (_a = {},
            _a[participant.participantId] = participant,
            _a);
    })), false));
    var availableAssignments = filteredAssignments.map(function (assignment) {
        var participant = availableParticipantsMap === null || availableParticipantsMap === void 0 ? void 0 : availableParticipantsMap[assignment.participantId];
        var sourceDrawPositionRange = sourceDrawPositionRangeMap[assignment.drawPosition];
        return definedAttributes(__assign(__assign({}, assignment), { participant: returnParticipants
                ? makeDeepCopy(participant, false, true)
                : undefined, sourceDrawPositionRange: sourceDrawPositionRange }));
    });
    if (availableAssignments.length) {
        var validSwapAction = {
            payload: { drawId: drawId, structureId: structureId, drawPositions: [drawPosition] },
            willDisableLinks: possiblyDisablingAction,
            method: SWAP_PARTICIPANT_METHOD,
            type: SWAP_PARTICIPANTS,
            availableAssignments: availableAssignments,
        };
        return { validSwapAction: validSwapAction };
    }
    return {};
}

var _a$9;
var POLICY_POSITION_ACTIONS_DEFAULT = (_a$9 = {},
    _a$9[POLICY_TYPE_POSITION_ACTIONS] = {
        policyName: 'positionActionsDefault',
        // positionActions will be selectively enabled for structures matching { stages: [], stageSequences: [] }
        // enabledStructures: [] => all structures are enabled
        enabledStructures: [
            {
                stages: [QUALIFYING, MAIN], // stages to which this policy applies
                stageSequences: [1], // stageSequences to which this policy applies
                enabledActions: [], // enabledActions: [] => all actions are enabled
                disabledActions: [], // disabledActions: [] => no actions are disabled
            },
            {
                stages: [], // stages: [] => applies to all stages
                stageSequences: [], // stageSequences: [] => applies to all stageSequences
                enabledActions: [
                    ADD_NICKNAME,
                    ADD_PENALTY,
                    QUALIFYING_PARTICIPANT,
                    SEED_VALUE,
                ],
                disabledActions: [], // disabledActions: [] => no actions are disabled
            },
        ],
        // positionActions will be completely disabled for any structures matching { stages: [], stageSequences: [] }
        // disabledStructures: [] => no structures are disabled
        disbledStructures: [],
        // enables entries in other flights to be accessed as alternates
        otherFlightEntries: false,
        // enable specific actions even when there are active positions
        activePositionOverrides: [],
    },
    _a$9);

var POSITION_ACTION = 'positionAction';
var MATCHUP_ACTION = 'matchUpAction';
function getEnabledStructures(_a) {
    var _b, _c;
    var _d = _a.actionType, actionType = _d === void 0 ? POSITION_ACTION : _d, appliedPolicies = _a.appliedPolicies, drawDefinition = _a.drawDefinition, structure = _a.structure;
    var policyType = (actionType === POSITION_ACTION && POLICY_TYPE_POSITION_ACTIONS) ||
        (actionType === MATCHUP_ACTION && POLICY_TYPE_MATCHUP_ACTIONS);
    var defaultPolicy = (actionType === POSITION_ACTION && POLICY_POSITION_ACTIONS_DEFAULT) ||
        (actionType === MATCHUP_ACTION && POLICY_MATCHUP_ACTIONS_DEFAULT);
    var actionsPolicy = policyType &&
        ((appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[policyType]) || (defaultPolicy === null || defaultPolicy === void 0 ? void 0 : defaultPolicy[policyType]));
    var relevantLinks = (_b = drawDefinition.links) === null || _b === void 0 ? void 0 : _b.filter(function (link) { var _a; return ((_a = link === null || link === void 0 ? void 0 : link.target) === null || _a === void 0 ? void 0 : _a.structureId) === (structure === null || structure === void 0 ? void 0 : structure.structureId); });
    var targetFeedProfiles = (_c = relevantLinks === null || relevantLinks === void 0 ? void 0 : relevantLinks.map(function (_a) {
        var target = _a.target;
        return target.feedProfile;
    })) !== null && _c !== void 0 ? _c : [];
    var _e = actionsPolicy || {}, enabledStructures = _e.enabledStructures, disabledStructures = _e.disabledStructures;
    var actionsDisabled = disabledStructures === null || disabledStructures === void 0 ? void 0 : disabledStructures.find(function (structurePolicy) {
        var stages = structurePolicy.stages, stageSequences = structurePolicy.stageSequences, structureTypes = structurePolicy.structureTypes, feedProfiles = structurePolicy.feedProfiles;
        return ((!(feedProfiles === null || feedProfiles === void 0 ? void 0 : feedProfiles.length) ||
            (Array.isArray(feedProfiles) &&
                feedProfiles.some(function (feedProfile) {
                    return targetFeedProfiles.includes(feedProfile);
                }))) &&
            (!(stages === null || stages === void 0 ? void 0 : stages.length) ||
                (Array.isArray(stages) && (stages === null || stages === void 0 ? void 0 : stages.includes(structure === null || structure === void 0 ? void 0 : structure.stage)))) &&
            (!(structureTypes === null || structureTypes === void 0 ? void 0 : structureTypes.length) ||
                (Array.isArray(structureTypes) &&
                    (structureTypes === null || structureTypes === void 0 ? void 0 : structureTypes.includes(structure === null || structure === void 0 ? void 0 : structure.structureType)))) &&
            (!(stageSequences === null || stageSequences === void 0 ? void 0 : stageSequences.length) ||
                (Array.isArray(stageSequences) &&
                    stageSequences.includes(structure === null || structure === void 0 ? void 0 : structure.stageSequence))));
    });
    return { enabledStructures: enabledStructures, actionsDisabled: actionsDisabled, actionsPolicy: actionsPolicy };
}
function activePositionsCheck(_a) {
    var activePositionOverrides = _a.activePositionOverrides, activeDrawPositions = _a.activeDrawPositions, action = _a.action;
    if (action && activePositionOverrides.includes(action))
        return true;
    return !activeDrawPositions.length;
}
function getPolicyActions(_a) {
    var _b;
    var enabledStructures = _a.enabledStructures, drawDefinition = _a.drawDefinition, structure = _a.structure;
    if (enabledStructures === false)
        return {};
    if (!(enabledStructures === null || enabledStructures === void 0 ? void 0 : enabledStructures.length))
        return { policyActions: { enabledActions: [], disabledActions: [] } };
    var _c = structure || {}, stage = _c.stage, stageSequence = _c.stageSequence, structureType = _c.structureType;
    var relevantLinks = (_b = drawDefinition.links) === null || _b === void 0 ? void 0 : _b.filter(function (link) { var _a; return ((_a = link === null || link === void 0 ? void 0 : link.target) === null || _a === void 0 ? void 0 : _a.structureId) === (structure === null || structure === void 0 ? void 0 : structure.structureId); });
    var targetFeedProfiles = (relevantLinks === null || relevantLinks === void 0 ? void 0 : relevantLinks.map(function (_a) {
        var target = _a.target;
        return target.feedProfile;
    })) || [];
    var policyActions = enabledStructures.find(function (structurePolicy) {
        var _a = structurePolicy || {}, stages = _a.stages, stageSequences = _a.stageSequences, structureTypes = _a.structureTypes, feedProfiles = _a.feedProfiles;
        var matchesStage = !(stages === null || stages === void 0 ? void 0 : stages.length) || (Array.isArray(stages) && stages.includes(stage));
        var matchesStageSequence = !(stageSequences === null || stageSequences === void 0 ? void 0 : stageSequences.length) ||
            (Array.isArray(stageSequences) && stageSequences.includes(stageSequence));
        var matchesStructureType = !(structureTypes === null || structureTypes === void 0 ? void 0 : structureTypes.length) ||
            (Array.isArray(structureTypes) && structureTypes.includes(structureType));
        var matchesFeedProfile = !(feedProfiles === null || feedProfiles === void 0 ? void 0 : feedProfiles.length) ||
            (Array.isArray(feedProfiles) &&
                feedProfiles.some(function (feedProfile) {
                    return targetFeedProfiles.includes(feedProfile);
                }));
        return (matchesStageSequence &&
            matchesStructureType &&
            matchesFeedProfile &&
            structurePolicy &&
            matchesStage);
    });
    return { policyActions: policyActions };
}
function isAvailableAction(_a) {
    var _b;
    var action = _a.action, policyActions = _a.policyActions;
    var disabled = !(policyActions === null || policyActions === void 0 ? void 0 : policyActions.enabledActions) ||
        (((_b = policyActions === null || policyActions === void 0 ? void 0 : policyActions.disabledActions) === null || _b === void 0 ? void 0 : _b.length) &&
            policyActions.disabledActions.includes(action));
    if (disabled)
        return false;
    var enabled = (policyActions === null || policyActions === void 0 ? void 0 : policyActions.enabledActions.length) === 0 ||
        (policyActions === null || policyActions === void 0 ? void 0 : policyActions.enabledActions.includes(action));
    return enabled && !disabled;
}

var REPLACE_TEAM_POSITION_METHOD = 'replaceTieMatchUpParticipantId';
var ASSIGN_TEAM_POSITION_METHOD = 'assignTieMatchUpParticipantId';
var REMOVE_TEAM_POSITION_METHOD = 'removeTieMatchUpParticipantId';
var ASSIGN_SIDE_METHOD = 'assignMatchUpSideParticipant';
var REMOVE_SIDE_METHOD = 'removeMatchUpSideParticipant';
var SUBSTITUTION_METHOD = 'substituteParticipant';
var REMOVE_SUBSTITUTION = 'REMOVE_SUBSTITUTION';
var REPLACE_PARTICIPANT = 'REPLACE_PARTICIPANT';
var REMOVE_PARTICIPANT = 'REMOVE_PARTICIPANT';
var SCHEDULE_METHOD = 'setMatchUpStatus';
var SUBSTITUTION = 'SUBSTITUTION';
var SCHEDULE = 'SCHEDULE';
var PENALTY = 'PENALTY';
var REFEREE = 'REFEREE';
var STATUS = 'STATUS';
var START = 'START';
var SCORE = 'SCORE';
var END = 'END';
var matchUpActionConstants = {
    REPLACE_TEAM_POSITION_METHOD: REPLACE_TEAM_POSITION_METHOD,
    ASSIGN_TEAM_POSITION_METHOD: ASSIGN_TEAM_POSITION_METHOD,
    REMOVE_TEAM_POSITION_METHOD: REMOVE_TEAM_POSITION_METHOD,
    REPLACE_PARTICIPANT: REPLACE_PARTICIPANT,
    SUBSTITUTION_METHOD: SUBSTITUTION_METHOD,
    REMOVE_SUBSTITUTION: REMOVE_SUBSTITUTION,
    REMOVE_PARTICIPANT: REMOVE_PARTICIPANT,
    SCHEDULE_METHOD: SCHEDULE_METHOD,
    SUBSTITUTION: SUBSTITUTION,
    SCHEDULE: SCHEDULE,
    PENALTY: PENALTY,
    REFEREE: REFEREE,
    STATUS: STATUS,
    SCORE: SCORE,
    START: START,
    END: END,
};

function collectionMatchUpActions(_a) {
    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    var specifiedPolicyDefinitions = _a.specifiedPolicyDefinitions, inContextDrawMatchUps = _a.inContextDrawMatchUps, matchUpParticipantIds = _a.matchUpParticipantIds, matchUpActionsPolicy = _a.matchUpActionsPolicy, inContextMatchUp = _a.inContextMatchUp, policyActions = _a.policyActions, enforceGender = _a.enforceGender, participantId = _a.participantId, sideNumber = _a.sideNumber, matchUpId = _a.matchUpId, matchUp = _a.matchUp, drawId = _a.drawId, side = _a.side;
    var validActions = [];
    var firstFoundSide = (_b = inContextMatchUp.sides) === null || _b === void 0 ? void 0 : _b.find(function (side) { return side.participant; });
    var assignedGender = inContextMatchUp.gender === MIXED &&
        inContextMatchUp.sideNumber &&
        ((_c = inContextMatchUp.sides) === null || _c === void 0 ? void 0 : _c.filter(function (side) { return side.particiapntId; }).length) === 1 &&
        ((_e = (_d = firstFoundSide === null || firstFoundSide === void 0 ? void 0 : firstFoundSide.participant) === null || _d === void 0 ? void 0 : _d.person) === null || _e === void 0 ? void 0 : _e.sex);
    var matchUpType = inContextMatchUp.matchUpType;
    var genderEnforced = (enforceGender !== null && enforceGender !== void 0 ? enforceGender : (_f = matchUpActionsPolicy === null || matchUpActionsPolicy === void 0 ? void 0 : matchUpActionsPolicy.participants) === null || _f === void 0 ? void 0 : _f.enforceGender) !== false;
    var gender = genderEnforced ? inContextMatchUp.gender : undefined;
    var allParticipants = (_g = inContextMatchUp.sides) === null || _g === void 0 ? void 0 : _g.flatMap(function (side) { var _a; return ((_a = side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipants) || side.participant; }).filter(Boolean);
    var allParticipantIds = allParticipants === null || allParticipants === void 0 ? void 0 : allParticipants.map(xa('participantId'));
    var existingParticipants = (_h = inContextMatchUp.sides) === null || _h === void 0 ? void 0 : _h.filter(function (side) { return !sideNumber || side.sideNumber === sideNumber; }).flatMap(function (side) { var _a; return ((_a = side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipants) || side.participant; }).filter(Boolean);
    var existingParticipantIds = existingParticipants === null || existingParticipants === void 0 ? void 0 : existingParticipants.map(xa('participantId'));
    var inContextDualMatchUp = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.find(function (drawMatchUp) { return drawMatchUp.matchUpId === inContextMatchUp.matchUpTieId; });
    var availableIndividualParticipants = (_j = inContextDualMatchUp === null || inContextDualMatchUp === void 0 ? void 0 : inContextDualMatchUp.sides) === null || _j === void 0 ? void 0 : _j.map(function (side) {
        var _a;
        return (_a = side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipants.filter(function (_a) {
            var participantId = _a.participantId, person = _a.person;
            return !(existingParticipantIds === null || existingParticipantIds === void 0 ? void 0 : existingParticipantIds.includes(participantId)) &&
                (!gender ||
                    gender === ANY ||
                    person.sex === gender ||
                    // case where one gendered member has been assigned
                    (gender === MIXED && !assignedGender) ||
                    (assignedGender && person.sex !== assignedGender));
        });
    });
    // if no sideNumber is provided, segregate available by sideNumber and specify sideNumber
    var availableParticipants = sideNumber
        ? availableIndividualParticipants === null || availableIndividualParticipants === void 0 ? void 0 : availableIndividualParticipants[sideNumber - 1]
        : availableIndividualParticipants === null || availableIndividualParticipants === void 0 ? void 0 : availableIndividualParticipants.map(function (available, i) { return ({
            participants: available,
            sideNumber: i + 1,
        }); });
    var availableParticipantIds = sideNumber
        ? (_k = availableIndividualParticipants === null || availableIndividualParticipants === void 0 ? void 0 : availableIndividualParticipants[sideNumber - 1]) === null || _k === void 0 ? void 0 : _k.map(getParticipantId)
        : availableIndividualParticipants === null || availableIndividualParticipants === void 0 ? void 0 : availableIndividualParticipants.map(function (available, i) { return ({
            participants: available === null || available === void 0 ? void 0 : available.map(getParticipantId),
            sideNumber: i + 1,
        }); });
    var assignmentAvailable = (sideNumber &&
        ((matchUpType === SINGLES_MATCHUP && !(existingParticipantIds === null || existingParticipantIds === void 0 ? void 0 : existingParticipantIds.length)) ||
            (matchUpType === DOUBLES_MATCHUP && ((_l = existingParticipantIds === null || existingParticipantIds === void 0 ? void 0 : existingParticipantIds.length) !== null && _l !== void 0 ? _l : 0) < 2))) ||
        (!sideNumber &&
            ((matchUpType === SINGLES_MATCHUP && ((_m = existingParticipantIds === null || existingParticipantIds === void 0 ? void 0 : existingParticipantIds.length) !== null && _m !== void 0 ? _m : 0) < 2) ||
                (matchUpType === DOUBLES_MATCHUP && ((_o = existingParticipantIds === null || existingParticipantIds === void 0 ? void 0 : existingParticipantIds.length) !== null && _o !== void 0 ? _o : 0) < 4)));
    // extra step to avoid edge case where individual participant is part of both teams
    var availableIds = availableParticipantIds === null || availableParticipantIds === void 0 ? void 0 : availableParticipantIds.filter(function (id) { return !(allParticipantIds === null || allParticipantIds === void 0 ? void 0 : allParticipantIds.includes(id)); });
    var available = availableParticipants === null || availableParticipants === void 0 ? void 0 : availableParticipants.filter(function (_a) {
        var participantId = _a.participantId;
        return availableIds.includes(participantId);
    });
    if (assignmentAvailable && (availableIds === null || availableIds === void 0 ? void 0 : availableIds.length)) {
        validActions.push({
            availableParticipantIds: availableIds,
            method: ASSIGN_TEAM_POSITION_METHOD,
            availableParticipants: available,
            type: ASSIGN_PARTICIPANT,
            payload: {
                participantId: undefined,
                tieMatchUpId: matchUpId,
                sideNumber: sideNumber,
                drawId: drawId,
            },
        });
    }
    if ((existingParticipantIds === null || existingParticipantIds === void 0 ? void 0 : existingParticipantIds.length) && (!checkScoreHasValue(matchUp) || ((_p = side === null || side === void 0 ? void 0 : side.substitutions) === null || _p === void 0 ? void 0 : _p.length))) {
        validActions.push({
            method: REMOVE_TEAM_POSITION_METHOD,
            type: REMOVE_PARTICIPANT,
            existingParticipantIds: existingParticipantIds,
            payload: {
                participantId: undefined,
                tieMatchUpId: matchUpId,
                drawId: drawId,
            },
        });
    }
    if ((available === null || available === void 0 ? void 0 : available.length) && ((!sideNumber && (existingParticipantIds === null || existingParticipantIds === void 0 ? void 0 : existingParticipantIds.length)) || (sideNumber && (side === null || side === void 0 ? void 0 : side.participant)))) {
        validActions.push({
            availableParticipantIds: availableIds,
            method: REPLACE_TEAM_POSITION_METHOD,
            availableParticipants: available,
            type: REPLACE_PARTICIPANT,
            existingParticipantIds: existingParticipantIds,
            payload: {
                existingParticipantId: undefined,
                participantId: undefined,
                tieMatchUpId: matchUpId,
                drawId: drawId,
            },
        });
    }
    if (isAvailableAction({ policyActions: policyActions, action: REMOVE_SUBSTITUTION }) && ((_q = side === null || side === void 0 ? void 0 : side.substitutions) === null || _q === void 0 ? void 0 : _q.length)) {
        var sideIndividualParticipantIds_1 = (((_r = side.participant) === null || _r === void 0 ? void 0 : _r.participantType) === INDIVIDUAL && [side.participantId]) ||
            (((_s = side.participant) === null || _s === void 0 ? void 0 : _s.participantType) === PAIR && side.participant.individualParticipantIds) ||
            [];
        var substitutedParticipantIds = side.substitutions
            .map(function (sub) { return sub.participantId; })
            .filter(function (id) { return sideIndividualParticipantIds_1.includes(id); });
        if (!participantId || substitutedParticipantIds.includes(participantId)) {
            validActions.push({
                method: REMOVE_TEAM_POSITION_METHOD,
                type: REMOVE_SUBSTITUTION,
                substitutedParticipantIds: substitutedParticipantIds,
                payload: {
                    participantId: undefined,
                    tieMatchUpId: matchUpId,
                    drawId: drawId,
                },
            });
        }
    }
    var matchUpActionPolicy = specifiedPolicyDefinitions === null || specifiedPolicyDefinitions === void 0 ? void 0 : specifiedPolicyDefinitions[POLICY_TYPE_MATCHUP_ACTIONS];
    var substituteWithoutScore = matchUpActionPolicy === null || matchUpActionPolicy === void 0 ? void 0 : matchUpActionPolicy.substituteWithoutScore;
    var substituteAfterCompleted = matchUpActionPolicy === null || matchUpActionPolicy === void 0 ? void 0 : matchUpActionPolicy.substituteAfterCompleted;
    // SUBSTITUTION
    // substitution is only possible when both sides are present; otherwise => nonsensical
    if (isAvailableAction({ policyActions: policyActions, action: SUBSTITUTION }) &&
        matchUpParticipantIds.length === 2 &&
        ((!sideNumber && (existingParticipantIds === null || existingParticipantIds === void 0 ? void 0 : existingParticipantIds.length)) || (sideNumber && (side === null || side === void 0 ? void 0 : side.participant))) &&
        (substituteWithoutScore || checkScoreHasValue(matchUp)) &&
        (substituteAfterCompleted ||
            (matchUp.matchUpStatus && !completedMatchUpStatuses.includes(matchUp.matchUpStatus))) &&
        (existingParticipants === null || existingParticipants === void 0 ? void 0 : existingParticipants.length) &&
        availableParticipants.length) {
        // action is not valid if there are no existing assignments or no available substitutions
        var existingParticipantIds_1 = existingParticipants.map(getParticipantId);
        validActions.push({
            info: 'list of team players available for substitution',
            method: SUBSTITUTION_METHOD,
            availableParticipantIds: availableParticipantIds,
            existingParticipantIds: existingParticipantIds_1,
            availableParticipants: availableParticipants,
            existingParticipants: existingParticipants,
            type: SUBSTITUTION,
            payload: {
                substituteParticipantId: undefined,
                existingParticipantId: undefined,
                sideNumber: sideNumber,
                matchUpId: matchUpId,
                drawId: drawId,
            },
        });
    }
    return validActions;
}

function getEventAlternateParticipantIds(_a) {
    var eventEntries = _a.eventEntries, structure = _a.structure;
    var eligibleAlternate = function (entry) { return entry.entryStatus === ALTERNATE && eligibleEntryStage({ structure: structure, entry: entry }); };
    var entryPositionSort = function (a, b) { return (a.entryPosition || Infinity) - (b.entryPosition || Infinity); };
    return eventEntries.filter(eligibleAlternate).sort(entryPositionSort).map(xa('participantId'));
}

function adHocMatchUpActions(_a) {
    var _b, _c, _d, _e, _f, _g;
    var restrictAdHocRoundParticipants = _a.restrictAdHocRoundParticipants, tournamentParticipants = _a.tournamentParticipants, matchUpParticipantIds = _a.matchUpParticipantIds, otherFlightEntries = _a.otherFlightEntries, drawDefinition = _a.drawDefinition, structureId = _a.structureId, sideNumber = _a.sideNumber, matchUpId = _a.matchUpId, structure = _a.structure, matchUp = _a.matchUp, drawId = _a.drawId, event = _a.event;
    var validActions = [];
    var roundMatchUps = ((_b = structure === null || structure === void 0 ? void 0 : structure.matchUps) !== null && _b !== void 0 ? _b : []).filter(function (_a) {
        var roundNumber = _a.roundNumber;
        return roundNumber === matchUp.roundNumber;
    });
    var enteredParticipantIds = (_d = (_c = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.entries) === null || _c === void 0 ? void 0 : _c.filter(function (_a) {
        var entryStatus = _a.entryStatus;
        return entryStatus && DIRECT_ENTRY_STATUSES.includes(entryStatus);
    }).map(xa('participantId'))) !== null && _d !== void 0 ? _d : [];
    var roundAssignedParticipantIds = roundMatchUps
        .map(function (matchUp) { var _a; return ((_a = matchUp.sides) !== null && _a !== void 0 ? _a : []).flatMap(xa('participantId')); })
        .flat()
        .filter(Boolean);
    var availableParticipantIds = enteredParticipantIds.filter(function (participantId) {
        return !matchUpParticipantIds.includes(participantId) &&
            (!restrictAdHocRoundParticipants || !roundAssignedParticipantIds.includes(participantId));
    });
    var participantsAvailable = tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.filter(function (participant) { return availableParticipantIds === null || availableParticipantIds === void 0 ? void 0 : availableParticipantIds.includes(participant.participantId); }).map(function (participant) { return makeDeepCopy(participant, undefined, true); });
    participantsAvailable === null || participantsAvailable === void 0 ? void 0 : participantsAvailable.forEach(function (participant) {
        var _a;
        var entry = ((_a = drawDefinition.entries) !== null && _a !== void 0 ? _a : []).find(function (entry) { return entry.participantId === participant.participantId; });
        // used to sort available participants
        participant.entryPosition = entry === null || entry === void 0 ? void 0 : entry.entryPosition;
    });
    if (availableParticipantIds.length) {
        validActions.push({
            payload: { drawId: drawId, matchUpId: matchUpId, structureId: structureId, sideNumber: sideNumber },
            method: ASSIGN_SIDE_METHOD,
            type: ASSIGN_PARTICIPANT,
            availableParticipantIds: availableParticipantIds,
            participantsAvailable: participantsAvailable,
        });
    }
    var eventEntries = (_e = event === null || event === void 0 ? void 0 : event.entries) !== null && _e !== void 0 ? _e : [];
    var availableEventAlternatesParticipantIds = getEventAlternateParticipantIds({ eventEntries: eventEntries, structure: structure });
    var availableAlternatesParticipantIds = unique(enteredParticipantIds.concat(availableEventAlternatesParticipantIds));
    if (otherFlightEntries) {
        var flightProfile = event ? getFlightProfile({ event: event }) : undefined;
        var otherFlightEnteredParticipantIds = (_f = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) === null || _f === void 0 ? void 0 : _f.filter(function (flight) { return flight.drawId !== drawId; }).flatMap(function (flight) {
            return flight.drawEntries
                .filter(function (entry) { return entry.participantId && ![WITHDRAWN, UNGROUPED, UNPAIRED].includes(entry.entryStatus); })
                .map(function (_a) {
                var participantId = _a.participantId;
                return participantId;
            });
        }).filter(Boolean);
        if (otherFlightEnteredParticipantIds === null || otherFlightEnteredParticipantIds === void 0 ? void 0 : otherFlightEnteredParticipantIds.length) {
            // include direct acceptance participants from other flights
            availableAlternatesParticipantIds.push.apply(availableAlternatesParticipantIds, __spreadArray([], __read(otherFlightEnteredParticipantIds), false));
        }
    }
    availableAlternatesParticipantIds = availableAlternatesParticipantIds.filter(function (participantId) {
        return !matchUpParticipantIds.includes(participantId) &&
            !availableParticipantIds.includes(participantId) &&
            (!restrictAdHocRoundParticipants || !roundAssignedParticipantIds.includes(participantId));
    });
    var availableAlternates = tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.filter(function (participant) { return availableAlternatesParticipantIds.includes(participant.participantId); }).map(function (participant) { return makeDeepCopy(participant, undefined, true); });
    availableAlternates === null || availableAlternates === void 0 ? void 0 : availableAlternates.forEach(function (alternate) {
        var _a;
        var entry = ((_a = drawDefinition.entries) !== null && _a !== void 0 ? _a : []).find(function (entry) { return entry.participantId === alternate.participantId; });
        alternate.entryPosition = entry === null || entry === void 0 ? void 0 : entry.entryPosition;
    });
    availableAlternates === null || availableAlternates === void 0 ? void 0 : availableAlternates.sort(function (a, b) { return (a.entryPosition || Infinity) - (b.entryPosition || Infinity); });
    if (availableAlternatesParticipantIds.length) {
        validActions.push({
            payload: { drawId: drawId, matchUpId: matchUpId, structureId: structureId, sideNumber: sideNumber },
            availableParticipantIds: availableAlternatesParticipantIds,
            participantsAvailable: availableAlternates,
            method: ASSIGN_SIDE_METHOD,
            type: ALTERNATE,
        });
    }
    if (!checkScoreHasValue(matchUp) && sideNumber) {
        var side = (_g = matchUp.sides) === null || _g === void 0 ? void 0 : _g.find(function (side) { return side.sideNumber === sideNumber; });
        if (side === null || side === void 0 ? void 0 : side.participantId) {
            validActions.push({
                payload: { drawId: drawId, matchUpId: matchUpId, structureId: structureId, sideNumber: sideNumber },
                method: REMOVE_SIDE_METHOD,
                type: REMOVE_PARTICIPANT,
            });
        }
    }
    return validActions;
}

function matchUpActions(params) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    if (!params)
        return { error: INVALID_VALUES };
    var drawDefinition, event;
    var _u = params.restrictAdHocRoundParticipants, restrictAdHocRoundParticipants = _u === void 0 ? true : _u, // disallow the same participant being in the same round multiple times
    specifiedPolicyDefinitions = params.policyDefinitions, enforceGender = params.enforceGender, participantId = params.participantId, sideNumber = params.sideNumber, matchUpId = params.matchUpId;
    var tournamentRecord = (_a = params.tournamentRecord) !== null && _a !== void 0 ? _a : (params.tournamentId && isString(params.tournamentId) && ((_b = params.tournamentRecords) === null || _b === void 0 ? void 0 : _b[params.tournamentId]));
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!matchUpId || !isString(matchUpId))
        return { error: MISSING_MATCHUP_ID };
    if (sideNumber && ![1, 2].includes(sideNumber))
        return decorateResult({
            result: { error: INVALID_VALUES },
            context: { sideNumber: sideNumber },
        });
    if (!drawDefinition) {
        // if matchUp did not have context, find drawId by brute force
        var matchUps = (_c = allTournamentMatchUps({ tournamentRecord: tournamentRecord }).matchUps) !== null && _c !== void 0 ? _c : [];
        var matchUp_1 = matchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
        event = ((_d = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.events) !== null && _d !== void 0 ? _d : []).find(function (event) { return event.eventId === (matchUp_1 === null || matchUp_1 === void 0 ? void 0 : matchUp_1.eventId); });
        drawDefinition = ((_e = event === null || event === void 0 ? void 0 : event.drawDefinitions) !== null && _e !== void 0 ? _e : []).find(function (drawDefinition) { return drawDefinition.drawId === (matchUp_1 === null || matchUp_1 === void 0 ? void 0 : matchUp_1.drawId); });
    }
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var tournamentParticipants = getParticipants({
        tournamentRecord: tournamentRecord,
        withIndividualParticipants: true,
    }).participants;
    var drawId = drawDefinition.drawId;
    var _v = findDrawMatchUp({
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
        event: event,
    }), matchUp = _v.matchUp, structure = _v.structure;
    if (!matchUp)
        return { error: MATCHUP_NOT_FOUND };
    var appliedPolicies = (_f = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    }).appliedPolicies) !== null && _f !== void 0 ? _f : {};
    Object.assign(appliedPolicies, specifiedPolicyDefinitions !== null && specifiedPolicyDefinitions !== void 0 ? specifiedPolicyDefinitions : {});
    var otherFlightEntries = (_g = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_POSITION_ACTIONS]) === null || _g === void 0 ? void 0 : _g.otherFlightEntries;
    var matchUpActionsPolicy = (_h = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_MATCHUP_ACTIONS]) !== null && _h !== void 0 ? _h : POLICY_MATCHUP_ACTIONS_DEFAULT[POLICY_TYPE_MATCHUP_ACTIONS];
    var enabledStructures = getEnabledStructures({
        actionType: MATCHUP_ACTION,
        appliedPolicies: appliedPolicies,
        drawDefinition: drawDefinition,
        structure: structure,
    }).enabledStructures;
    var policyActions = getPolicyActions({
        enabledStructures: enabledStructures,
        drawDefinition: drawDefinition,
        structure: structure,
    }).policyActions;
    var matchUpsMap = (_j = params.matchUpsMap) !== null && _j !== void 0 ? _j : getMatchUpsMap({ drawDefinition: drawDefinition });
    var inContextDrawMatchUps = (_k = params.inContextDrawMatchUps) !== null && _k !== void 0 ? _k : getAllDrawMatchUps({
        tournamentParticipants: tournamentParticipants,
        inContext: true,
        drawDefinition: drawDefinition,
        matchUpsMap: matchUpsMap,
        event: event,
    }).matchUps;
    var inContextMatchUp = inContextDrawMatchUps === null || inContextDrawMatchUps === void 0 ? void 0 : inContextDrawMatchUps.find(function (drawMatchUp) { return drawMatchUp.matchUpId === matchUpId; });
    var side = sideNumber && ((_l = inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.sides) === null || _l === void 0 ? void 0 : _l.find(function (side) { return side.sideNumber === sideNumber; }));
    var matchUpParticipantIds = (_o = (_m = inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.sides) === null || _m === void 0 ? void 0 : _m.map(function (side) { var _a; return side.participantId || ((_a = side.participant) === null || _a === void 0 ? void 0 : _a.participantid); }).filter(Boolean)) !== null && _o !== void 0 ? _o : [];
    var _w = structureAssignedDrawPositions({ structure: structure }), assignedPositions = _w.assignedPositions, allPositionsAssigned = _w.allPositionsAssigned;
    var structureId = (structure !== null && structure !== void 0 ? structure : {}).structureId;
    var validActions = [];
    if (!structureId)
        return { validActions: validActions };
    var isAdHocMatchUp = isAdHoc({ drawDefinition: drawDefinition, structure: structure });
    var isCollectionMatchUp = matchUp.collectionId;
    if (isAdHocMatchUp && !isCollectionMatchUp) {
        var adHocValidActions = adHocMatchUpActions({
            restrictAdHocRoundParticipants: restrictAdHocRoundParticipants,
            tournamentParticipants: tournamentParticipants,
            matchUpParticipantIds: matchUpParticipantIds,
            otherFlightEntries: otherFlightEntries,
            drawDefinition: drawDefinition,
            structureId: structureId,
            sideNumber: sideNumber,
            matchUpId: matchUpId,
            structure: structure,
            matchUp: matchUp,
            drawId: drawId,
            event: event,
        });
        validActions.push.apply(validActions, __spreadArray([], __read(adHocValidActions), false));
    }
    var structureIsComplete = isCompletedStructure({
        drawDefinition: drawDefinition,
        structure: structure,
    });
    var participantAssignedDrawPositions = assignedPositions === null || assignedPositions === void 0 ? void 0 : assignedPositions.filter(function (assignment) { return assignment.participantId; }).map(function (assignment) { return assignment.drawPosition; });
    var byeAssignedDrawPositions = assignedPositions === null || assignedPositions === void 0 ? void 0 : assignedPositions.filter(function (assignment) { return assignment.bye; }).map(function (assignment) { return assignment.drawPosition; });
    var isByeMatchUp = matchUp.matchUpStatus === BYE ||
        (!isCollectionMatchUp &&
            ((_p = matchUp.drawPositions) === null || _p === void 0 ? void 0 : _p.reduce(function (isByeMatchUp, drawPosition) {
                return (byeAssignedDrawPositions === null || byeAssignedDrawPositions === void 0 ? void 0 : byeAssignedDrawPositions.includes(drawPosition)) || isByeMatchUp;
            }, false)));
    if (isByeMatchUp)
        return { validActions: validActions, isByeMatchUp: isByeMatchUp };
    // TODO: implement method action and pass participants whose role is REFEREE
    if (isAvailableAction({ policyActions: policyActions, action: REFEREE })) {
        validActions.push({ type: REFEREE, payload: { matchUpId: matchUpId } });
    }
    var isInComplete = !isDirectingMatchUpStatus({
        matchUpStatus: matchUp.matchUpStatus,
    });
    var structureScoringPolicies = (_q = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.scoring) === null || _q === void 0 ? void 0 : _q.structures;
    var stageSpecificPolicies = (structure === null || structure === void 0 ? void 0 : structure.stage) && (structureScoringPolicies === null || structureScoringPolicies === void 0 ? void 0 : structureScoringPolicies.stage) && (structureScoringPolicies === null || structureScoringPolicies === void 0 ? void 0 : structureScoringPolicies.stage[structure.stage]);
    var sequenceSpecificPolicies = (structure === null || structure === void 0 ? void 0 : structure.stageSequence) &&
        (stageSpecificPolicies === null || stageSpecificPolicies === void 0 ? void 0 : stageSpecificPolicies.stageSequence) &&
        stageSpecificPolicies.stageSequence[structure.stageSequence];
    var requireAllPositionsAssigned = ((_r = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies.scoring) === null || _r === void 0 ? void 0 : _r.requireAllPositionsAssigned) ||
        (stageSpecificPolicies === null || stageSpecificPolicies === void 0 ? void 0 : stageSpecificPolicies.requireAllPositionsAssigned) ||
        (sequenceSpecificPolicies === null || sequenceSpecificPolicies === void 0 ? void 0 : sequenceSpecificPolicies.requireAllPositionsAssigned);
    var scoringActive = !requireAllPositionsAssigned || allPositionsAssigned;
    var hasParticipants = matchUp.sides && matchUp.sides.filter(function (side) { return side === null || side === void 0 ? void 0 : side.participantId; }).length === 2;
    var isDoubleExit = matchUp.matchUpStatus && [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUp.matchUpStatus);
    var targetData = positionTargets({
        inContextDrawMatchUps: inContextDrawMatchUps,
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
    });
    var activeDownstream = isActiveDownstream({
        inContextDrawMatchUps: inContextDrawMatchUps,
        drawDefinition: drawDefinition,
        targetData: targetData,
    });
    var matchUpDrawPositionsAreAssigned = ((_s = inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.drawPositions) === null || _s === void 0 ? void 0 : _s.length) === 2 &&
        inContextMatchUp.drawPositions.every(function (drawPosition) { return participantAssignedDrawPositions === null || participantAssignedDrawPositions === void 0 ? void 0 : participantAssignedDrawPositions.includes(drawPosition); }) &&
        ((_t = inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.sides) === null || _t === void 0 ? void 0 : _t.length) === 2 &&
        inContextMatchUp.sides.every(function (_a) {
            var participantId = _a.participantId;
            return participantId;
        });
    var readyToScore = (matchUpDrawPositionsAreAssigned || hasParticipants) && !(isDoubleExit && activeDownstream);
    var addPenaltyAction = {
        method: ADD_PENALTY_METHOD,
        type: ADD_PENALTY,
        payload: {
            drawId: drawId,
            matchUpId: matchUpId,
            penaltyCode: undefined,
            penaltyType: undefined,
            participantIds: [],
            notes: undefined,
        },
    };
    if (isInComplete) {
        validActions.push({
            payload: { drawId: drawId, matchUpId: matchUpId, schedule: {} },
            method: SCHEDULE_METHOD,
            type: SCHEDULE,
        });
    }
    if (isAvailableAction({ policyActions: policyActions, action: ADD_PENALTY }) &&
        ((side === null || side === void 0 ? void 0 : side.participant) || (!sideNumber && (matchUpParticipantIds === null || matchUpParticipantIds === void 0 ? void 0 : matchUpParticipantIds.length)))) {
        validActions.push(addPenaltyAction);
    }
    if (isInComplete && readyToScore)
        validActions.push({ type: STATUS });
    if (scoringActive && readyToScore) {
        var matchUpId_1 = matchUp.matchUpId, matchUpFormat = matchUp.matchUpFormat;
        var payload = {
            drawId: drawId,
            matchUpId: matchUpId_1,
            matchUpFormat: matchUpFormat,
            outcome: {
                scoreStringSide1: undefined,
                scoreStringSide2: undefined,
                sets: [],
            },
            winningSide: undefined,
        };
        validActions.push({
            info: 'set outcome and winningSide',
            method: SCHEDULE_METHOD, // setMatchUpStatus
            type: SCORE,
            payload: payload,
        });
        if (isAvailableAction({ policyActions: policyActions, action: START })) {
            validActions.push({ type: START });
        }
        if (isAvailableAction({ policyActions: policyActions, action: END })) {
            validActions.push({ type: END });
        }
    }
    if (isCollectionMatchUp && inContextMatchUp) {
        var collectionValidActions = collectionMatchUpActions({
            specifiedPolicyDefinitions: specifiedPolicyDefinitions,
            inContextDrawMatchUps: inContextDrawMatchUps,
            matchUpParticipantIds: matchUpParticipantIds,
            matchUpActionsPolicy: matchUpActionsPolicy,
            inContextMatchUp: inContextMatchUp,
            policyActions: policyActions,
            enforceGender: enforceGender,
            participantId: participantId,
            sideNumber: sideNumber,
            matchUpId: matchUpId,
            matchUp: matchUp,
            drawId: drawId,
            side: side,
        });
        validActions.push.apply(validActions, __spreadArray([], __read(collectionValidActions), false));
    }
    return {
        structureIsComplete: structureIsComplete,
        validActions: validActions,
        isDoubleExit: isDoubleExit,
    };
}

/**
 * Calculates the valid actions for a draw position based on the provided parameters.
 *
 * @param params - The parameters for calculating the position actions.
 * @returns An object containing the valid actions for the draw position.
 */
function positionActions(params) {
    var _a, _b, _c, _d, _e, _f;
    var specifiedPolicyDefinitions = params.policyDefinitions, _g = params.returnParticipants, returnParticipants = _g === void 0 ? true : _g, provisionalPositioning = params.provisionalPositioning, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, drawPosition = params.drawPosition, event = params.event;
    if (!event)
        return { error: MISSING_EVENT };
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!params.structureId)
        return { error: MISSING_STRUCTURE_ID };
    var tournamentParticipants = (_b = (_a = params.tournamentParticipants) !== null && _a !== void 0 ? _a : (tournamentRecord &&
        getParticipants({
            withIndividualParticipants: true,
            tournamentRecord: tournamentRecord,
        }).participants)) !== null && _b !== void 0 ? _b : [];
    var result = findStructure({
        structureId: params.structureId,
        drawDefinition: drawDefinition,
    });
    if (result.error)
        return result;
    var structure = result.containingStructure || result.structure;
    if (!structure)
        return { error: STRUCTURE_NOT_FOUND };
    var structureId = structure.structureId;
    result = getStructureDrawPositionProfiles({
        drawDefinition: drawDefinition,
        structureId: structureId,
    });
    if (drawPosition === undefined && !result.isAdHoc) {
        return { error: MISSING_DRAW_POSITION };
    }
    if (result.isAdHoc)
        return matchUpActions(params);
    if (result.error)
        return result;
    var drawPositionInitialRounds = result.drawPositionInitialRounds, 
    // qualifyingDrawPositions,
    inactiveDrawPositions = result.inactiveDrawPositions, activeDrawPositions = result.activeDrawPositions, byeDrawPositions = result.byeDrawPositions;
    var appliedPolicies = (_c = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    }).appliedPolicies) !== null && _c !== void 0 ? _c : {};
    Object.assign(appliedPolicies, specifiedPolicyDefinitions !== null && specifiedPolicyDefinitions !== void 0 ? specifiedPolicyDefinitions : {});
    var _h = getEnabledStructures({
        actionType: POSITION_ACTION,
        appliedPolicies: appliedPolicies,
        drawDefinition: drawDefinition,
        structure: structure,
    }), positionActionsPolicy = _h.actionsPolicy, enabledStructures = _h.enabledStructures, actionsDisabled = _h.actionsDisabled;
    var activePositionOverrides = (positionActionsPolicy === null || positionActionsPolicy === void 0 ? void 0 : positionActionsPolicy.activePositionOverrides) || [];
    // targetRoundNumber will be > 1 for fed positions
    var positionSourceStructureIds = (getSourceStructureIdsAndRelevantLinks({
        finishingPosition: WIN_RATIO$1,
        targetRoundNumber: 1,
        linkType: POSITION,
        drawDefinition: drawDefinition,
        structureId: structureId,
    }) || {}).sourceStructureIds;
    var sourceStructuresComplete;
    if (positionSourceStructureIds === null || positionSourceStructureIds === void 0 ? void 0 : positionSourceStructureIds.length) {
        // EVERY: this can probably be changed to .every
        sourceStructuresComplete = positionSourceStructureIds.reduce(function (ready, sourceStructureId) {
            var completed = isCompletedStructure({
                structureId: sourceStructureId,
                drawDefinition: drawDefinition,
            });
            return completed && ready;
        }, true);
    }
    var isWinRatioFedStructure = positionSourceStructureIds.length;
    var disablePlacementActions = positionSourceStructureIds.length && !sourceStructuresComplete;
    var policyActions = getPolicyActions({
        enabledStructures: enabledStructures,
        drawDefinition: drawDefinition,
        structure: structure,
    }).policyActions;
    var possiblyDisablingAction = ![QUALIFYING, MAIN].includes(structure.stage) || structure.stageSequence !== 1;
    var drawId = drawDefinition.drawId;
    var validActions = [];
    var _j = structureAssignedDrawPositions({ structure: structure }), assignedPositions = _j.assignedPositions, positionAssignments = _j.positionAssignments;
    var positionAssignment = assignedPositions === null || assignedPositions === void 0 ? void 0 : assignedPositions.find(function (assignment) { return assignment.drawPosition === drawPosition; });
    var drawPositions = positionAssignments === null || positionAssignments === void 0 ? void 0 : positionAssignments.map(function (assignment) { return assignment.drawPosition; });
    if (!(drawPositions === null || drawPositions === void 0 ? void 0 : drawPositions.includes(drawPosition)))
        return { error: INVALID_DRAW_POSITION };
    var stage = structure.stage, stageSequence = structure.stageSequence;
    var stages = [stage];
    // allow unassigneParticipantIds from MAIN in positionActions for consolation
    if (stage === CONSOLATION)
        stages.push(MAIN);
    if (stage === MAIN)
        stages.push(CONSOLATION);
    var stageEntries = getStageEntries$1({
        entryStatuses: DIRECT_ENTRY_STATUSES,
        provisionalPositioning: provisionalPositioning,
        drawDefinition: drawDefinition,
        stageSequence: stageSequence,
        structureId: structureId,
        stages: stages,
    });
    var stageAssignedParticipantIds = (_d = getAssignedParticipantIds({
        drawDefinition: drawDefinition,
        stages: stages,
    }).assignedParticipantIds) !== null && _d !== void 0 ? _d : [];
    var unassignedParticipantIds = stageEntries
        .filter(function (entry) { return !stageAssignedParticipantIds.includes(entry.participantId); })
        .map(function (entry) { return entry.participantId; });
    var isByePosition = byeDrawPositions.includes(drawPosition);
    var isActiveDrawPosition = activeDrawPositions.includes(drawPosition);
    if (actionsDisabled)
        return {
            hasPositionAssigned: !!positionAssignment,
            info: 'Actions Disabled for structure',
            isActiveDrawPosition: isActiveDrawPosition,
            isDrawPosition: true,
            validActions: [],
            isByePosition: isByePosition,
        };
    if (isAvailableAction({ policyActions: policyActions, action: ASSIGN_PARTICIPANT }) &&
        !isActiveDrawPosition &&
        positionAssignments &&
        !disablePlacementActions &&
        (!positionAssignment || isByePosition)) {
        var validAssignmentActions = getValidAssignmentActions({
            positionSourceStructureIds: positionSourceStructureIds,
            unassignedParticipantIds: unassignedParticipantIds,
            possiblyDisablingAction: possiblyDisablingAction,
            isWinRatioFedStructure: isWinRatioFedStructure,
            tournamentParticipants: tournamentParticipants,
            positionAssignments: positionAssignments,
            returnParticipants: returnParticipants,
            appliedPolicies: appliedPolicies,
            drawDefinition: drawDefinition,
            isByePosition: isByePosition,
            drawPosition: drawPosition,
            structureId: structureId,
            event: event,
        }).validAssignmentActions;
        validAssignmentActions === null || validAssignmentActions === void 0 ? void 0 : validAssignmentActions.forEach(function (action) { return validActions.push(action); });
    }
    if (isAvailableAction({ policyActions: policyActions, action: QUALIFYING_PARTICIPANT })) {
        var validAssignmentActions = getValidQualifiersAction({
            drawPositionInitialRounds: drawPositionInitialRounds,
            tournamentParticipants: tournamentParticipants,
            positionAssignments: positionAssignments,
            returnParticipants: returnParticipants,
            appliedPolicies: appliedPolicies,
            drawDefinition: drawDefinition,
            drawPosition: drawPosition,
            structureId: structureId,
            drawId: drawId,
        }).validAssignmentActions;
        validAssignmentActions === null || validAssignmentActions === void 0 ? void 0 : validAssignmentActions.forEach(function (action) { return validActions.push(action); });
    }
    var participantId = (positionAssignment || {}).participantId;
    var participant = participantId && tournamentParticipants.find(function (participant) { return participant.participantId === participantId; });
    if (positionAssignment) {
        if (isAvailableAction({ policyActions: policyActions, action: REMOVE_ASSIGNMENT }) && !isActiveDrawPosition) {
            validActions.push({
                type: REMOVE_ASSIGNMENT,
                method: REMOVE_ASSIGNMENT_METHOD,
                payload: { drawId: drawId, structureId: structureId, drawPosition: drawPosition },
                willDisableLinks: possiblyDisablingAction,
            });
            if (!isByePosition) {
                validActions.push({
                    type: WITHDRAW_PARTICIPANT,
                    method: WITHDRAW_PARTICIPANT_METHOD,
                    payload: { drawId: drawId, structureId: structureId, drawPosition: drawPosition },
                    willDisableLinks: possiblyDisablingAction,
                });
            }
            // in this case the ASSIGN_BYE_METHOD is called after removing assigned participant
            // option should not be available if exising assignment is a bye
            if (isAvailableAction({ policyActions: policyActions, action: ASSIGN_BYE }) && !isByePosition) {
                validActions.push({
                    type: ASSIGN_BYE,
                    method: REMOVE_ASSIGNMENT_METHOD,
                    payload: { drawId: drawId, structureId: structureId, drawPosition: drawPosition, replaceWithBye: true },
                    willDisableLinks: possiblyDisablingAction,
                });
            }
        }
        var validToAssignSeed = structure.stage === QUALIFYING || (structure.stage === MAIN && structure.stageSequence === 1);
        if (!isByePosition &&
            // if any drawPositions are active, action is disabled unless override in policy
            activePositionsCheck({
                activePositionOverrides: activePositionOverrides,
                activeDrawPositions: activeDrawPositions,
                action: SEED_VALUE,
            }) &&
            isAvailableAction({ policyActions: policyActions, action: SEED_VALUE }) &&
            isValidSeedPosition({ drawDefinition: drawDefinition, structureId: structureId, drawPosition: drawPosition }) &&
            validToAssignSeed) {
            var seedAssignments = getStructureSeedAssignments({
                returnAllProxies: true,
                drawDefinition: drawDefinition,
                structure: structure,
            }).seedAssignments;
            var _k = (_e = seedAssignments === null || seedAssignments === void 0 ? void 0 : seedAssignments.find(function (assignment) { return assignment.participantId === participantId; })) !== null && _e !== void 0 ? _e : {}, seedNumber = _k.seedNumber, seedValue = _k.seedValue;
            validActions.push({
                type: SEED_VALUE,
                method: SEED_VALUE_METHOD,
                participant: participant,
                seedNumber: seedNumber,
                payload: {
                    drawId: drawId,
                    structureId: structureId,
                    participantId: participantId,
                    seedValue: seedValue,
                },
            });
        }
        if (!isByePosition &&
            // if any drawPositions are active, action is disabled unless override in policy
            activePositionsCheck({
                activePositionOverrides: activePositionOverrides,
                activeDrawPositions: activeDrawPositions,
                action: REMOVE_SEED,
            }) &&
            isAvailableAction({ policyActions: policyActions, action: REMOVE_SEED }) &&
            isValidSeedPosition({ drawDefinition: drawDefinition, structureId: structureId, drawPosition: drawPosition }) &&
            validToAssignSeed) {
            var seedAssignments = getStructureSeedAssignments({
                returnAllProxies: true,
                drawDefinition: drawDefinition,
                structure: structure,
            }).seedAssignments;
            var seedNumber = ((_f = seedAssignments === null || seedAssignments === void 0 ? void 0 : seedAssignments.find(function (assignment) { return assignment.participantId === participantId; })) !== null && _f !== void 0 ? _f : {}).seedNumber;
            validActions.push({
                method: REMOVE_SEED_METHOD,
                type: REMOVE_SEED,
                participant: participant,
                seedNumber: seedNumber,
                payload: {
                    participantId: participantId,
                    structureId: structureId,
                    drawId: drawId,
                },
            });
        }
        if (!isByePosition && participantId) {
            if (isAvailableAction({ policyActions: policyActions, action: ADD_PENALTY })) {
                var addPenaltyAction = {
                    type: ADD_PENALTY,
                    method: ADD_PENALTY_METHOD,
                    participant: participant,
                    payload: {
                        penaltyCode: undefined,
                        penaltyType: undefined,
                        participantIds: [],
                        notes: undefined,
                        drawId: drawId,
                    },
                };
                validActions.push(addPenaltyAction);
            }
            if (isAvailableAction({ policyActions: policyActions, action: ADD_NICKNAME })) {
                var addNicknameAction = {
                    type: ADD_NICKNAME,
                    method: ADD_NICKNAME_METHOD,
                    participant: participant,
                    payload: {
                        participantId: participantId,
                        otherName: undefined,
                    },
                };
                validActions.push(addNicknameAction);
            }
        }
        if (isAvailableAction({ policyActions: policyActions, action: SWAP_PARTICIPANTS })) {
            var validSwapAction = getValidSwapAction({
                possiblyDisablingAction: possiblyDisablingAction,
                tournamentParticipants: tournamentParticipants,
                inactiveDrawPositions: inactiveDrawPositions,
                activeDrawPositions: activeDrawPositions,
                positionAssignments: positionAssignments,
                returnParticipants: returnParticipants,
                byeDrawPositions: byeDrawPositions,
                drawDefinition: drawDefinition,
                isByePosition: isByePosition,
                drawPosition: drawPosition,
                structureId: structureId,
                structure: structure,
                drawId: drawId,
            }).validSwapAction;
            if (validSwapAction)
                validActions.push(validSwapAction);
        }
    }
    if (isAvailableAction({ policyActions: policyActions, action: ALTERNATE_PARTICIPANT }) && !disablePlacementActions) {
        var validAlternatesAction = getValidAlternatesAction({
            possiblyDisablingAction: possiblyDisablingAction,
            tournamentParticipants: tournamentParticipants,
            positionAssignments: positionAssignments,
            activeDrawPositions: activeDrawPositions,
            returnParticipants: returnParticipants,
            appliedPolicies: appliedPolicies,
            drawDefinition: drawDefinition,
            drawPosition: drawPosition,
            validActions: validActions,
            structureId: structureId,
            structure: structure,
            drawId: drawId,
            event: event,
        }).validAlternatesAction;
        if (validAlternatesAction)
            validActions.push(validAlternatesAction);
    }
    if (isAvailableAction({ policyActions: policyActions, action: LUCKY_PARTICIPANT }) &&
        !disablePlacementActions &&
        positionAssignments) {
        var validLuckyLosersAction = getValidLuckyLosersAction({
            sourceStructuresComplete: sourceStructuresComplete,
            possiblyDisablingAction: possiblyDisablingAction,
            isWinRatioFedStructure: isWinRatioFedStructure,
            tournamentParticipants: tournamentParticipants,
            activeDrawPositions: activeDrawPositions,
            positionAssignments: positionAssignments,
            drawDefinition: drawDefinition,
            drawPosition: drawPosition,
            structureId: structureId,
            structure: structure,
            drawId: drawId,
        }).validLuckyLosersAction;
        if (validLuckyLosersAction)
            validActions.push(validLuckyLosersAction);
    }
    if ((participant === null || participant === void 0 ? void 0 : participant.participantType) === PAIR && isAvailableAction({ policyActions: policyActions, action: MODIFY_PAIR_ASSIGNMENT })) {
        var validModifyAssignedPairAction = getValidModifyAssignedPairAction({
            tournamentParticipants: tournamentParticipants,
            returnParticipants: returnParticipants,
            drawPosition: drawPosition,
            participant: participant,
            drawId: drawId,
            event: event,
        }).validModifyAssignedPairAction;
        if (validModifyAssignedPairAction)
            validActions.push(validModifyAssignedPairAction);
    }
    return {
        hasPositionAssigned: !!positionAssignment,
        isActiveDrawPosition: isActiveDrawPosition,
        isDrawPosition: true,
        isByePosition: isByePosition,
        validActions: validActions,
    };
}

function getParticipantSchedules(_a) {
    var e_1, _b;
    var _c, _d, _e;
    var _f = _a.participantFilters, participantFilters = _f === void 0 ? {} : _f, tournamentRecord = _a.tournamentRecord;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (typeof participantFilters !== 'object')
        return { error: INVALID_OBJECT, context: { participantFilters: participantFilters } };
    var contextFilters = { eventIds: participantFilters.eventIds };
    var matchUps = (_c = allTournamentMatchUps({
        tournamentRecord: tournamentRecord,
        contextFilters: contextFilters,
    }).matchUps) !== null && _c !== void 0 ? _c : [];
    var matchUpsMap = Object.assign.apply(Object, __spreadArray([{}], __read(matchUps.map(function (matchUp) {
        var _a;
        return (_a = {}, _a[matchUp.matchUpId] = matchUp, _a);
    })), false));
    var scheduledMatchUps = matchUps.filter(function (_a) {
        var schedule = _a.schedule;
        return schedule && Object.keys(schedule).length;
    });
    var sourceMatchUpIds = (_d = getMatchUpDependencies({
        tournamentRecord: tournamentRecord,
        matchUps: matchUps,
    }).sourceMatchUpIds) !== null && _d !== void 0 ? _d : [];
    var participantAggregator = {};
    var _loop_1 = function (matchUp) {
        var e_2, _g, e_3, _h;
        var sides = matchUp.sides;
        var relevantSourceMatchUps;
        var participants = (_e = sides === null || sides === void 0 ? void 0 : sides.map(function (side) {
            var _a;
            if (side.participant) {
                return (_a = [side.participant]).concat.apply(_a, __spreadArray([], __read((side.participant.individualParticipants || [])), false));
            }
            else if (sourceMatchUpIds[matchUp.matchUpId] &&
                !relevantSourceMatchUps) {
                relevantSourceMatchUps = (sourceMatchUpIds[matchUp.matchUpId] || [])
                    .map(function (matchUpId) { return matchUpsMap[matchUpId]; })
                    .filter(function (_a) {
                    var winningSide = _a.winningSide, bye = _a.bye;
                    return !winningSide && !bye;
                });
            }
            return undefined;
        }).filter(Boolean).flat()) !== null && _e !== void 0 ? _e : [];
        try {
            for (var participants_1 = (e_2 = void 0, __values(participants)), participants_1_1 = participants_1.next(); !participants_1_1.done; participants_1_1 = participants_1.next()) {
                var participant = participants_1_1.value;
                var participantId = participant.participantId;
                if (!participantAggregator[participantId]) {
                    participantAggregator[participantId] = {
                        potentialMatchUps: [],
                        participant: participant,
                        matchUps: [],
                    };
                }
                participantAggregator[participantId].matchUps.push(matchUp);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (participants_1_1 && !participants_1_1.done && (_g = participants_1.return)) _g.call(participants_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var potentialParticipants = (relevantSourceMatchUps === null || relevantSourceMatchUps === void 0 ? void 0 : relevantSourceMatchUps.map(function (_a) {
            var sides = _a.sides;
            return sides;
        }).flat().map(function (_a) {
            var _b;
            var participant = _a.participant;
            return participant && (_b = [participant]).concat.apply(_b, __spreadArray([], __read((participant.individualParticipants || [])), false));
        }).filter(Boolean).flat()) || [];
        try {
            for (var potentialParticipants_1 = (e_3 = void 0, __values(potentialParticipants)), potentialParticipants_1_1 = potentialParticipants_1.next(); !potentialParticipants_1_1.done; potentialParticipants_1_1 = potentialParticipants_1.next()) {
                var participant = potentialParticipants_1_1.value;
                var participantId = participant.participantId;
                if (!participantAggregator[participantId]) {
                    participantAggregator[participantId] = {
                        potentialMatchUps: [],
                        participant: participant,
                        matchUps: [],
                    };
                }
                participantAggregator[participantId].potentialMatchUps.push(matchUp);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (potentialParticipants_1_1 && !potentialParticipants_1_1.done && (_h = potentialParticipants_1.return)) _h.call(potentialParticipants_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    try {
        for (var scheduledMatchUps_1 = __values(scheduledMatchUps), scheduledMatchUps_1_1 = scheduledMatchUps_1.next(); !scheduledMatchUps_1_1.done; scheduledMatchUps_1_1 = scheduledMatchUps_1.next()) {
            var matchUp = scheduledMatchUps_1_1.value;
            _loop_1(matchUp);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (scheduledMatchUps_1_1 && !scheduledMatchUps_1_1.done && (_b = scheduledMatchUps_1.return)) _b.call(scheduledMatchUps_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var aggregators = Object.values(participantAggregator);
    var participantSchedules = aggregators.filter(function (_a) {
        var participant = _a.participant;
        return !((participantFilters.participantIds &&
            !participantFilters.participantIds.includes(participant.participantId)) ||
            (participantFilters.participantTypes &&
                !participantFilters.participantTypes.includes(participant.participantType)));
    });
    return __assign({ participantSchedules: participantSchedules }, SUCCESS);
}

function isValidForQualifying(_a) {
    var structureId = _a.structureId, drawDefinition = _a.drawDefinition;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    if (!isString(structureId))
        return { error: INVALID_VALUES };
    var result = getStructureLinks({
        drawDefinition: drawDefinition,
        structureId: structureId,
    });
    if (result.error)
        return result;
    var targetFeedProfiles = result.links.target
        .flatMap(function (t) { return t.target.feedProfile; })
        .filter(Boolean);
    var valid = !intersection([BOTTOM_UP, TOP_DOWN, RANDOM, WATERFALL], targetFeedProfiles).length;
    return __assign(__assign({}, SUCCESS), { valid: valid });
}

function getTournamentPersons(_a) {
    var tournamentRecord = _a.tournamentRecord, participantFilters = _a.participantFilters;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var tournamentParticipants = tournamentRecord.participants || [];
    if (participantFilters)
        tournamentParticipants = filterParticipants({
            participants: tournamentParticipants,
            participantFilters: participantFilters,
            tournamentRecord: tournamentRecord,
        });
    var tournamentPersons = {};
    var extractPerson = function (participant) {
        if (participant.person) {
            var personId = participant.person.personId;
            if (tournamentPersons[personId]) {
                // case where personId is used for multiple participants, e.g. COMPETITOR as well as OFFICIAL
                tournamentPersons[personId].participantIds.push(participant.participantId);
            }
            else {
                tournamentPersons[personId] = __assign(__assign({}, participant.person), { participantIds: [participant.participantId] });
            }
        }
    };
    tournamentParticipants.forEach(function (participant) {
        if (participant.person)
            extractPerson(participant);
    });
    return { tournamentPersons: Object.values(tournamentPersons) };
}

function getPredictiveAccuracy(params) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    var matchUps = params.matchUps;
    var singlesForDoubles = params.singlesForDoubles, tournamentRecord = params.tournamentRecord, drawDefinition = params.drawDefinition, excludeMargin = params.excludeMargin, exclusionRule = params.exclusionRule, zoneDoubling = params.zoneDoubling, matchUpType = params.matchUpType, scaleName = params.scaleName, eventId = params.eventId, zonePct = params.zonePct, drawId = params.drawId, event = params.event;
    if (!tournamentRecord && !matchUps)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (matchUpType && ![SINGLES, DOUBLES].includes(matchUpType))
        return { error: INVALID_VALUES, info: { matchUpType: matchUpType } };
    if (matchUps && !validMatchUps(matchUps))
        return { error: INVALID_VALUES, context: { matchUps: matchUps } };
    var scaleProfile = ratingsParameters[scaleName];
    var ascending = (_b = (_a = scaleProfile === null || scaleProfile === void 0 ? void 0 : scaleProfile.ascending) !== null && _a !== void 0 ? _a : params.ascending) !== null && _b !== void 0 ? _b : false;
    var valueAccessor = (_c = scaleProfile === null || scaleProfile === void 0 ? void 0 : scaleProfile.accessor) !== null && _c !== void 0 ? _c : params.valueAccessor;
    var ratingsRangeDifference = Array.isArray(scaleProfile === null || scaleProfile === void 0 ? void 0 : scaleProfile.range)
        ? Math.abs(scaleProfile.range[0] - scaleProfile.range[1])
        : 0;
    var zoneMargin = isConvertableInteger(zonePct) && ratingsRangeDifference
        ? (zonePct !== null && zonePct !== void 0 ? zonePct : 0 / 100) * ratingsRangeDifference
        : (_d = params.zoneMargin) !== null && _d !== void 0 ? _d : ratingsRangeDifference;
    var contextProfile = { withScaleValues: true, withCompetitiveness: true };
    var contextFilters = {
        matchUpTypes: matchUpType ? [matchUpType] : [SINGLES, DOUBLES],
    };
    var participants = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.participants;
    if ((_e = matchUps === null || matchUps === void 0 ? void 0 : matchUps[0]) === null || _e === void 0 ? void 0 : _e.hasContext) {
        if (drawId) {
            matchUps = matchUps.filter(function (matchUp) { return matchUp.drawId === drawId; });
        }
        else if (eventId) {
            matchUps = matchUps.filter(function (matchUp) { return matchUp.eventId === eventId; });
        }
    }
    else if (matchUps === undefined) {
        matchUps =
            (drawId && !drawDefinition && []) ||
                (!drawId && eventId && !event && []) ||
                (drawId &&
                    ((_f = allDrawMatchUps({
                        inContext: true,
                        drawDefinition: drawDefinition,
                        contextFilters: contextFilters,
                        contextProfile: contextProfile,
                        participants: participants,
                    })) === null || _f === void 0 ? void 0 : _f.matchUps)) ||
                (!drawId &&
                    eventId &&
                    ((_g = allEventMatchUps({
                        inContext: true,
                        contextFilters: contextFilters,
                        contextProfile: contextProfile,
                        participants: participants,
                        event: event,
                    })) === null || _g === void 0 ? void 0 : _g.matchUps)) ||
                ((_h = allTournamentMatchUps({
                    tournamentRecord: tournamentRecord,
                    contextFilters: contextFilters,
                    contextProfile: contextProfile,
                })) === null || _h === void 0 ? void 0 : _h.matchUps) ||
                [];
    }
    if (matchUpType) {
        matchUps = matchUps.filter(function (matchUp) { return matchUp.matchUpType === matchUpType; });
    }
    var relevantMatchUps = matchUps.filter(function (_a) {
        var winningSide = _a.winningSide, score = _a.score, sides = _a.sides, matchUpStatus = _a.matchUpStatus;
        return ![RETIRED$1, DEFAULTED, WALKOVER$2, DEAD_RUBBER, ABANDONED$1].includes(matchUpStatus !== null && matchUpStatus !== void 0 ? matchUpStatus : '') &&
            checkScoreHasValue({ score: score }) &&
            (sides === null || sides === void 0 ? void 0 : sides.length) === 2 &&
            winningSide;
    });
    var accuracy = getGroupingAccuracy({
        matchUps: relevantMatchUps,
        excludeMargin: excludeMargin,
        exclusionRule: exclusionRule,
        valueAccessor: valueAccessor,
        ascending: ascending,
        scaleName: scaleName,
    });
    var marginCalc = !zoneDoubling || matchUpType === SINGLES
        ? zoneMargin
        : (zoneMargin || 0) * 2;
    var zoneData = zoneMargin
        ? relevantMatchUps
            .map(function (_a) {
            var competitiveProfile = _a.competitiveProfile, matchUpType = _a.matchUpType, score = _a.score, sides = _a.sides;
            var sideValues = getSideValues({
                singlesForDoubles: singlesForDoubles,
                valueAccessor: valueAccessor,
                matchUpType: matchUpType,
                scaleName: scaleName,
                sides: sides,
            });
            var valuesGap = Math.abs(sideValues[0].value - sideValues[1].value);
            return {
                competitiveness: competitiveProfile === null || competitiveProfile === void 0 ? void 0 : competitiveProfile.competitiveness,
                valuesGap: valuesGap,
                score: score,
            };
        })
            .filter(function (_a) {
            var valuesGap = _a.valuesGap;
            return valuesGap <= marginCalc;
        })
        : [];
    var zoneBands = getGroupingBands({ zoneData: zoneData });
    var totalZoneMatchUps = zoneBands && [].concat(Object.values(zoneBands)).flat().length;
    var zoneDistribution = totalZoneMatchUps && Object.assign.apply(Object, __spreadArray([{}], __read(Object.keys(zoneBands).map(function (key) {
        var _a;
        return (_a = {},
            _a[key] = Math.round((10000 * zoneBands[key].length) / totalZoneMatchUps) / 100,
            _a);
    })), false));
    var nonZone = relevantMatchUps.length - ((zoneData === null || zoneData === void 0 ? void 0 : zoneData.length) || 0);
    return __assign(__assign({}, SUCCESS), { relevantMatchUps: relevantMatchUps, zoneDistribution: zoneDistribution, zoneData: zoneData, accuracy: accuracy, nonZone: nonZone });
}
function getGroupingBands(_a) {
    var _b, e_1, _c;
    var zoneData = _a.zoneData;
    var bands = (_b = {}, _b[COMPETITIVE] = [], _b[ROUTINE] = [], _b[DECISIVE] = [], _b);
    try {
        for (var zoneData_1 = __values(zoneData), zoneData_1_1 = zoneData_1.next(); !zoneData_1_1.done; zoneData_1_1 = zoneData_1.next()) {
            var data = zoneData_1_1.value;
            var competitiveness = data.competitiveness, score = data.score, valuesGap = data.valuesGap;
            if (bands[competitiveness]) {
                bands[competitiveness].push({ score: score, valuesGap: valuesGap });
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (zoneData_1_1 && !zoneData_1_1.done && (_c = zoneData_1.return)) _c.call(zoneData_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return bands;
}
function getSideValues(_a) {
    var singlesForDoubles = _a.singlesForDoubles, exclusionRule = _a.exclusionRule, valueAccessor = _a.valueAccessor, matchUpType = _a.matchUpType, scaleName = _a.scaleName, sides = _a.sides;
    var sortedRange = exclusionRule === null || exclusionRule === void 0 ? void 0 : exclusionRule.range.sort();
    var checkExcludeParticipant = function (scaleValue) {
        var exclusionValue = scaleValue === null || scaleValue === void 0 ? void 0 : scaleValue[exclusionRule === null || exclusionRule === void 0 ? void 0 : exclusionRule.valueAccessor];
        var exclude = exclusionRule &&
            exclusionValue >= sortedRange[0] &&
            exclusionValue <= sortedRange[1];
        return { exclude: exclude, exclusionValue: exclusionValue };
    };
    return sides
        .sort(function (a, b) { return a.sideNumber - b.sideNumber; })
        .map(function (_a) {
        var e_2, _b;
        var participant = _a.participant;
        var exclusionValues = [];
        var individualParticipants = participant === null || participant === void 0 ? void 0 : participant.individualParticipants;
        if (individualParticipants === null || individualParticipants === void 0 ? void 0 : individualParticipants.length) {
            var scaleValues = [];
            var value = 0;
            try {
                for (var individualParticipants_1 = __values(individualParticipants), individualParticipants_1_1 = individualParticipants_1.next(); !individualParticipants_1_1.done; individualParticipants_1_1 = individualParticipants_1.next()) {
                    var participant_1 = individualParticipants_1_1.value;
                    var _c = getSideValue({
                        singlesForDoubles: singlesForDoubles,
                        valueAccessor: valueAccessor,
                        participant: participant_1,
                        matchUpType: matchUpType,
                        scaleName: scaleName,
                    }), scaleValue = _c.scaleValue, pValue = _c.value;
                    var _d = checkExcludeParticipant(scaleValue), exclude = _d.exclude, exclusionValue = _d.exclusionValue;
                    if (exclude)
                        exclusionValues.push(exclusionValue);
                    scaleValues.push(scaleValue);
                    if (pValue && !isNaN(value)) {
                        value += pValue;
                    }
                    else {
                        value = undefined;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (individualParticipants_1_1 && !individualParticipants_1_1.done && (_b = individualParticipants_1.return)) _b.call(individualParticipants_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return {
                participantName: participant.participantName,
                exclusionValues: exclusionValues,
                scaleValues: scaleValues,
                value: value,
            };
        }
        else if (participant) {
            var _e = getSideValue({
                singlesForDoubles: singlesForDoubles,
                valueAccessor: valueAccessor,
                matchUpType: matchUpType,
                participant: participant,
                scaleName: scaleName,
            }), scaleValue = _e.scaleValue, value = _e.value;
            var _f = checkExcludeParticipant(scaleValue), exclude = _f.exclude, exclusionValue = _f.exclusionValue;
            if (exclude)
                exclusionValues.push(exclusionValue);
            return {
                participantName: participant.participantName,
                exclusionValues: exclusionValues,
                scaleValue: scaleValue,
                value: value,
            };
        }
        else {
            return {};
        }
    });
}
function getSideValue(_a) {
    var _b, _c, _d, _e, _f;
    var singlesForDoubles = _a.singlesForDoubles, valueAccessor = _a.valueAccessor, matchUpType = _a.matchUpType, participant = _a.participant, scaleName = _a.scaleName;
    var type = singlesForDoubles ? SINGLES : matchUpType;
    var ranking = (_c = (_b = participant === null || participant === void 0 ? void 0 : participant.rankings) === null || _b === void 0 ? void 0 : _b[type]) === null || _c === void 0 ? void 0 : _c.find(function (ranking) { return ranking.scaleName === scaleName; });
    var rating = (_e = (_d = participant === null || participant === void 0 ? void 0 : participant.ratings) === null || _d === void 0 ? void 0 : _d[type]) === null || _e === void 0 ? void 0 : _e.find(function (rating) { return rating.scaleName === scaleName; });
    var scaleValue = (_f = (rating || ranking)) === null || _f === void 0 ? void 0 : _f.scaleValue;
    var value = valueAccessor ? scaleValue === null || scaleValue === void 0 ? void 0 : scaleValue[valueAccessor] : scaleValue;
    return { scaleValue: scaleValue, value: value };
}
// given a grouping of matchUps, how accurate were the scaleValues in predicting winner
function getGroupingAccuracy(_a) {
    var e_3, _b;
    var excludeMargin = _a.excludeMargin, exclusionRule = _a.exclusionRule, valueAccessor = _a.valueAccessor, ascending = _a.ascending, scaleName = _a.scaleName, matchUps = _a.matchUps;
    var accuracy = { affirmative: [], negative: [], excluded: [] };
    try {
        for (var matchUps_1 = __values(matchUps), matchUps_1_1 = matchUps_1.next(); !matchUps_1_1.done; matchUps_1_1 = matchUps_1.next()) {
            var matchUp = matchUps_1_1.value;
            var matchUpType = matchUp.matchUpType, sides = matchUp.sides, score = matchUp.score, winningSide = matchUp.winningSide;
            if (!winningSide)
                continue;
            if (exclusionRule &&
                (!exclusionRule.valueAccessor || !exclusionRule.range)) {
                return {
                    info: 'exclusionRule requires valueAccessor and range',
                    error: MISSING_VALUE,
                };
            }
            var winningIndex = winningSide - 1;
            var sideValues = getSideValues({
                exclusionRule: exclusionRule,
                valueAccessor: valueAccessor,
                matchUpType: matchUpType,
                scaleName: scaleName,
                sides: sides,
            });
            if (exclusionRule) {
                var exclusionValues = sideValues
                    .map(function (_a) {
                    var exclusionValues = _a.exclusionValues;
                    return exclusionValues;
                })
                    .flat();
                if (exclusionValues.length) {
                    accuracy.excluded.push({
                        scoreString: score === null || score === void 0 ? void 0 : score.scoreStringSide1,
                        exclusionValues: exclusionValues,
                        winningSide: winningSide,
                        sideValues: sideValues,
                    });
                    continue;
                }
            }
            if (sideValues.filter(function (value) { return ![undefined, '', null].includes(value.value); })
                .length < 2) {
                accuracy.excluded.push({
                    scoreString: score === null || score === void 0 ? void 0 : score.scoreStringSide1,
                    missingValues: true,
                    winningSide: winningSide,
                    sideValues: sideValues,
                });
                continue;
            }
            var valuesGap = sideValues[winningIndex].value - sideValues[1 - winningIndex].value;
            var floatMargin = parseFloat(excludeMargin || 0);
            var excludeGap = floatMargin && Math.abs(valuesGap) < floatMargin;
            if (excludeGap) {
                accuracy.excluded.push({
                    scoreString: score === null || score === void 0 ? void 0 : score.scoreStringSide1,
                    excludeMargin: excludeMargin,
                    winningSide: winningSide,
                    excludeGap: excludeGap,
                    sideValues: sideValues,
                    valuesGap: valuesGap,
                });
                continue;
            }
            // when ascending is true winning value will be greater than losing value
            var signedGap = ascending ? valuesGap : valuesGap * -1;
            var winningScoreString = winningSide === 1 ? score === null || score === void 0 ? void 0 : score.scoreStringSide1 : score === null || score === void 0 ? void 0 : score.scoreStringSide2;
            if (signedGap > 0) {
                accuracy.affirmative.push({
                    winningScoreString: winningScoreString,
                    winningSide: winningSide,
                    sideValues: sideValues,
                    valuesGap: valuesGap,
                    score: score,
                });
            }
            else {
                accuracy.negative.push({
                    winningScoreString: winningScoreString,
                    winningSide: winningSide,
                    sideValues: sideValues,
                    valuesGap: valuesGap,
                    score: score,
                });
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (matchUps_1_1 && !matchUps_1_1.done && (_b = matchUps_1.return)) _b.call(matchUps_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    var denominator = accuracy.affirmative.length + accuracy.negative.length;
    var percent = denominator && (accuracy.affirmative.length / denominator) * 100;
    accuracy.percent = percent ? Math.round(100 * percent) / 100 : 0;
    return accuracy;
}

function getParticipantSignInStatus(_a) {
    var tournamentRecord = _a.tournamentRecord, participantId = _a.participantId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!participantId)
        return { error: MISSING_PARTICIPANT_ID };
    var participant = findTournamentParticipant({
        tournamentRecord: tournamentRecord,
        participantId: participantId,
    }).participant;
    if (!participant)
        return { error: PARTICIPANT_NOT_FOUND };
    var timeItem = getTimeItem({
        itemType: SIGN_IN_STATUS,
        element: participant,
    }).timeItem;
    return timeItem && timeItem.itemValue === SIGNED_IN && SIGNED_IN;
}

function getMatchUpContextIds(_a) {
    var matchUps = _a.matchUps, matchUpId = _a.matchUpId;
    if (!validMatchUps(matchUps))
        return { error: INVALID_VALUES };
    var matchUp = matchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
    var _b = matchUp || {}, drawId = _b.drawId, eventId = _b.eventId, structureId = _b.structureId, tournamentId = _b.tournamentId;
    return { matchUpId: matchUpId, drawId: drawId, eventId: eventId, structureId: structureId, tournamentId: tournamentId };
}

function getMaxEntryPosition(params) {
    var _a = params.entries, entries = _a === void 0 ? [] : _a, entryStatus = params.entryStatus, stage = params.stage;
    return Math.max.apply(Math, __spreadArray(__spreadArray([], __read(entries
        .filter(function (entry) {
        return (!stage || stage === entry.entryStage) &&
            (!entryStatus || entry.entryStatus === entryStatus) &&
            !isNaN(entry.entryPosition);
    })
        .map(function (_a) {
        var entryPosition = _a.entryPosition;
        return ensureInt(entryPosition || 0);
    })), false), [0], false));
}

function checkIsDual(tournamentRecord) {
    var _a, _b, _c, _d, _e;
    var teamParticipants = (_a = tournamentRecord.participants) === null || _a === void 0 ? void 0 : _a.filter(function (_a) {
        var participantType = _a.participantType;
        return participantType === TEAM$1;
    });
    var twoTeams = (teamParticipants === null || teamParticipants === void 0 ? void 0 : teamParticipants.length) === 2;
    var event = ((_b = tournamentRecord.events) === null || _b === void 0 ? void 0 : _b.length) === 1 && tournamentRecord.events[0];
    var drawDefinition = ((_c = event === null || event === void 0 ? void 0 : event.drawDefinitions) === null || _c === void 0 ? void 0 : _c.length) === 1 && event.drawDefinitions[0];
    var structure = ((_d = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.structures) === null || _d === void 0 ? void 0 : _d.length) === 1 && drawDefinition.structures[0];
    var twoDrawPositions = ((_e = structure === null || structure === void 0 ? void 0 : structure.positionAssignments) === null || _e === void 0 ? void 0 : _e.length) === 2;
    return !!(event.tieFormat && twoTeams && twoDrawPositions);
}

function analyzeTournament(_a) {
    var tournamentRecord = _a.tournamentRecord;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var drawsAnalysis = analyzeDraws({ tournamentRecord: tournamentRecord }).drawsAnalysis;
    var analysis = {
        isDual: checkIsDual(tournamentRecord),
        drawsAnalysis: drawsAnalysis,
    };
    return __assign(__assign({}, SUCCESS), { analysis: analysis });
}

function getMatchUpFormat(params) {
    var _a, _b, _c, _d;
    var _e;
    var structureId = params.structureId, matchUpId = params.matchUpId, event = params.event;
    var drawDefinition = params.drawDefinition;
    var paramCheck = checkRequiredParameters(params, [
        (_a = {}, _a[TOURNAMENT_RECORD] = true, _a),
        (_b = {},
            _b[ANY_OF] = (_c = {},
                _c[STRUCTURE_ID] = false,
                _c[MATCHUP_ID] = false,
                _c[DRAW_ID] = false,
                _c[EVENT] = false,
                _c),
            _b),
    ]);
    if (paramCheck[ERROR])
        return paramCheck;
    var resolutions = resolveFromParameters(params, [(_d = {}, _d[PARAM] = MATCHUP, _d[ERROR] = MISSING_VALUE, _d)]);
    var matchUpResult = resolutions === null || resolutions === void 0 ? void 0 : resolutions.matchUp;
    if (matchUpId && (matchUpResult === null || matchUpResult === void 0 ? void 0 : matchUpResult.error)) {
        return matchUpResult;
    }
    else if (!drawDefinition && (matchUpResult === null || matchUpResult === void 0 ? void 0 : matchUpResult.drawDefinition)) {
        drawDefinition = matchUpResult === null || matchUpResult === void 0 ? void 0 : matchUpResult.drawDefinition;
    }
    var structure = matchUpResult === null || matchUpResult === void 0 ? void 0 : matchUpResult.structure;
    if (!structure && structureId && !matchUpId) {
        if (!drawDefinition)
            return { error: MISSING_DRAW_ID };
        var structureResult = findStructure({ drawDefinition: drawDefinition, structureId: structureId });
        if (structureResult.error)
            return structureResult;
        structure = structureResult.structure;
    }
    var structureDefaultMatchUpFormat = structure === null || structure === void 0 ? void 0 : structure.matchUpFormat;
    var drawDefaultMatchUpFormat = drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.matchUpFormat;
    var eventDefaultMatchUpFormat = event === null || event === void 0 ? void 0 : event.matchUpFormat;
    var matchUpFormat = ((_e = matchUpResult === null || matchUpResult === void 0 ? void 0 : matchUpResult.matchUp) === null || _e === void 0 ? void 0 : _e.matchUpFormat) ||
        structureDefaultMatchUpFormat ||
        drawDefaultMatchUpFormat ||
        eventDefaultMatchUpFormat;
    return {
        structureDefaultMatchUpFormat: structureDefaultMatchUpFormat,
        eventDefaultMatchUpFormat: eventDefaultMatchUpFormat,
        drawDefaultMatchUpFormat: drawDefaultMatchUpFormat,
        matchUpFormat: matchUpFormat,
    };
}

function publicFindParticipant(params) {
    var _a, e_1, _b;
    var tournamentRecord = params.tournamentRecord, policyDefinitions = params.policyDefinitions, contextProfile = params.contextProfile, participantId = params.participantId, personId = params.personId;
    var tournamentRecords = params.tournamentRecords ||
        (tournamentRecord && (_a = {},
            _a[tournamentRecord.tournamentId] = tournamentRecord,
            _a)) ||
        {};
    if (typeof participantId !== 'string' && typeof personId !== 'string')
        return { error: MISSING_VALUE, stack: 'publicFindParticipant' };
    var participant, tournamentId;
    try {
        for (var _c = __values(Object.values(tournamentRecords)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var tournamentRecord_1 = _d.value;
            tournamentId = tournamentRecord_1.tournamentId;
            var tournamentParticipants = tournamentRecord_1.participants || [];
            participant = findParticipant({
                tournamentParticipants: tournamentParticipants,
                internalUse: true,
                policyDefinitions: policyDefinitions,
                contextProfile: contextProfile,
                participantId: participantId,
                personId: personId,
            });
            if (participant)
                break;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({ participant: participant, tournamentId: tournamentId }, SUCCESS);
}

function getEventProperties(_a) {
    var _b, _c;
    var tournamentRecord = _a.tournamentRecord, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    var eventEntries = event.entries || [];
    var tournamentParticipants = tournamentRecord.participants || [];
    var scaleName = ((_b = event.category) === null || _b === void 0 ? void 0 : _b.categoryName) || ((_c = event.category) === null || _c === void 0 ? void 0 : _c.ageCategoryCode);
    var eventType = event.eventType;
    var enteredParticipantIds = eventEntries.map(function (entry) { return entry.participantId; });
    var enteredParticipants = tournamentParticipants.filter(function (participant) {
        return enteredParticipantIds.includes(participant.participantId);
    });
    var hasSeededParticipants, hasRankedParticipants, hasRatedParticipants;
    var entryScaleAttributes = enteredParticipants.map(function (participant) {
        var _a, _b, _c, _d, _e, _f;
        var participantId = participant.participantId, participantName = participant.participantName, name = participant.name;
        var scaleAttributes = { scaleType: SEEDING, eventType: eventType, scaleName: scaleName };
        var seed = (_b = (_a = participantScaleItem({ participant: participant, scaleAttributes: scaleAttributes })) === null || _a === void 0 ? void 0 : _a.scaleItem) === null || _b === void 0 ? void 0 : _b.scaleValue;
        scaleAttributes = { scaleType: RANKING, eventType: eventType, scaleName: scaleName };
        var ranking = (_d = (_c = participantScaleItem({ participant: participant, scaleAttributes: scaleAttributes })) === null || _c === void 0 ? void 0 : _c.scaleItem) === null || _d === void 0 ? void 0 : _d.scaleValue;
        scaleAttributes = { scaleType: RATING, eventType: eventType, scaleName: scaleName };
        var rating = (_f = (_e = participantScaleItem({ participant: participant, scaleAttributes: scaleAttributes })) === null || _e === void 0 ? void 0 : _e.scaleItem) === null || _f === void 0 ? void 0 : _f.scaleValue;
        hasSeededParticipants = !!(hasSeededParticipants || seed);
        hasRankedParticipants = !!(hasRankedParticipants || ranking);
        hasRatedParticipants = !!(hasRatedParticipants || rating);
        return {
            participantId: participantId,
            participantName: participantName || name, // support legacy
            seed: seed,
            ranking: ranking,
            rating: rating,
        };
    });
    return {
        entryScaleAttributes: entryScaleAttributes,
        hasSeededParticipants: hasSeededParticipants,
        hasRankedParticipants: hasRankedParticipants,
        hasRatedParticipants: hasRatedParticipants,
    };
}

function getMatchUpsStats(_a) {
    var _b, _c;
    var profileBands = _a.profileBands, tournamentRecord = _a.tournamentRecord, matchUps = _a.matchUps;
    if (!validMatchUps(matchUps))
        return { error: MISSING_MATCHUPS };
    var policy = !profileBands &&
        findPolicy({
            policyType: POLICY_TYPE_COMPETITIVE_BANDS,
            tournamentRecord: tournamentRecord,
        }).policy;
    var bandProfiles = profileBands ||
        (policy === null || policy === void 0 ? void 0 : policy.profileBands) ||
        POLICY_COMPETITIVE_BANDS_DEFAULT[POLICY_TYPE_COMPETITIVE_BANDS]
            .profileBands;
    var relevantMatchUps = matchUps.filter(function (_a) {
        var winningSide = _a.winningSide;
        return winningSide;
    });
    var gamesMap = relevantMatchUps.map(getScoreComponents);
    var categorize = function (p, spread) {
        var band = getBand(spread, bandProfiles);
        p[band] += 1;
        return p;
    };
    var pctspd = pctSpread(gamesMap).reduce(function (p, c) { return categorize(p, c); }, (_b = {},
        _b[COMPETITIVE] = 0,
        _b[ROUTINE] = 0,
        _b[DECISIVE] = 0,
        _b[WALKOVER$1] = 0,
        _b));
    var total = Object.keys(pctspd).reduce(function (a, k) { return (pctspd[k] || 0) + a; }, 0);
    var competitiveBands = Object.keys(pctspd).map(function (k) {
        var _a;
        var value = parseFloat((pctspd[k] / total).toFixed(4));
        return _a = {},
            _a[k] = value * 100,
            _a;
    });
    var retiredCount = relevantMatchUps.filter(function (_a) {
        var matchUpStatus = _a.matchUpStatus;
        return matchUpStatus === RETIRED;
    }).length;
    competitiveBands.push((_c = {},
        _c[RETIRED] = parseFloat((retiredCount / total).toFixed(4)) * 100,
        _c));
    return __assign({ competitiveBands: Object.assign.apply(Object, __spreadArray([{}], __read(competitiveBands), false)) }, SUCCESS);
}

function getRoundId(obj) {
    var containerStructureId = obj.containerStructureId, roundSegment = obj.roundSegment, isRoundRobin = obj.isRoundRobin, tournamentId = obj.tournamentId, roundNumber = obj.roundNumber, structureId = obj.structureId, eventId = obj.eventId, drawId = obj.drawId;
    var relevantStructureId = isRoundRobin ? containerStructureId : structureId;
    // retain order
    var id = [
        tournamentId, // 1
        eventId, // 2
        drawId, // 3
        relevantStructureId, // 4
        roundNumber, // 5
    ].join('|');
    return definedAttributes({
        structureId: relevantStructureId,
        roundSegment: roundSegment,
        tournamentId: tournamentId,
        roundNumber: roundNumber,
        eventId: eventId,
        drawId: drawId,
        id: id,
    });
}
function getRoundTiming(_a) {
    var round = _a.round, matchUps = _a.matchUps, events = _a.events, tournamentRecords = _a.tournamentRecords;
    var event = events.find(function (event) { return event.eventId === round.eventId; });
    var _b = event || {}, eventType = _b.eventType, category = _b.category, categoryType = _b.categoryType;
    var _c = category || {}, categoryName = _c.categoryName, ageCategoryCode = _c.ageCategoryCode;
    var formatCounts = instanceCount(matchUps.map(function (_a) {
        var matchUpFormat = _a.matchUpFormat;
        return matchUpFormat;
    }));
    var roundMinutes = 0;
    Object.keys(formatCounts).forEach(function (matchUpFormat) {
        var formatCount = formatCounts[matchUpFormat];
        var result = findMatchUpFormatTiming({
            categoryName: categoryName || ageCategoryCode,
            tournamentId: round.tournamentId,
            eventId: round.eventId,
            tournamentRecords: tournamentRecords,
            matchUpFormat: matchUpFormat,
            categoryType: categoryType,
            eventType: eventType,
        });
        if (result.error)
            return result;
        var formatMinutes = result.averageMinutes * formatCount;
        if (!isNaN(roundMinutes))
            roundMinutes += formatMinutes;
        return undefined;
    });
    return { roundMinutes: roundMinutes };
}
function getFinishingPositionDetails(matchUps) {
    return (matchUps || []).reduce(function (foo, matchUp) {
        var _a, _b;
        var sum = (((_a = matchUp.finishingPositionRange) === null || _a === void 0 ? void 0 : _a.winner) || []).reduce(function (a, b) { return a + b; }, 0);
        var winnerFinishingPositionRange = (((_b = matchUp.finishingPositionRange) === null || _b === void 0 ? void 0 : _b.winner) || []).join('-') || '';
        return !foo.minFinishingSum || sum < foo.minFinishingSum
            ? { minFinishingSum: sum, winnerFinishingPositionRange: winnerFinishingPositionRange }
            : foo;
    }, { minFinishingSum: 0, winnerFinishingPositionRange: '' });
}
function getRoundProfile(matchUps) {
    var matchUpsCount = matchUps.length;
    var byeCount = matchUps.filter(function (_a) {
        var sides = _a.sides;
        return sides === null || sides === void 0 ? void 0 : sides.some(function (_a) {
            var bye = _a.bye;
            return bye;
        });
    }).length || 0;
    var completedCount = matchUps.filter(function (_a) {
        var winningSide = _a.winningSide, matchUpStatus = _a.matchUpStatus;
        return winningSide || completedMatchUpStatuses.includes(matchUpStatus);
    }).length || 0;
    var scheduledCount = matchUps.filter(function (_a) {
        var schedule = _a.schedule, matchUpStatus = _a.matchUpStatus;
        return (schedule === null || schedule === void 0 ? void 0 : schedule.scheduledDate) &&
            (schedule === null || schedule === void 0 ? void 0 : schedule.scheduledTime) &&
            matchUpStatus !== BYE;
    }).length || 0;
    var consideredCount = matchUpsCount - byeCount;
    var isComplete = consideredCount === completedCount;
    var unscheduledCount = consideredCount - scheduledCount;
    var incompleteCount = consideredCount - scheduledCount;
    var isScheduled = consideredCount === scheduledCount;
    return {
        unscheduledCount: unscheduledCount,
        incompleteCount: incompleteCount,
        scheduledCount: scheduledCount,
        completedCount: completedCount,
        matchUpsCount: matchUpsCount,
        isScheduled: isScheduled,
        isComplete: isComplete,
        byeCount: byeCount,
    };
}

function getProfileRounds(_a) {
    var _b;
    var tournamentRecords = _a.tournamentRecords, schedulingProfile = _a.schedulingProfile, tournamentRecord = _a.tournamentRecord, withRoundId = _a.withRoundId;
    if (tournamentRecord && !tournamentRecords) {
        if (typeof tournamentRecord !== 'object') {
            return { error: INVALID_TOURNAMENT_RECORD };
        }
        else {
            tournamentRecords = (_b = {}, _b[tournamentRecord.tournamentId] = tournamentRecord, _b);
        }
    }
    if (schedulingProfile) {
        var profileValidity = validateSchedulingProfile({
            tournamentRecords: tournamentRecords,
            schedulingProfile: schedulingProfile,
        });
        if (profileValidity.error)
            return profileValidity;
    }
    if (!schedulingProfile && tournamentRecords) {
        var result = getSchedulingProfile({ tournamentRecords: tournamentRecords });
        if (result.error)
            return result;
        schedulingProfile = result.schedulingProfile;
    }
    if (!schedulingProfile)
        return { error: NOT_FOUND };
    var segmentedRounds = {};
    var profileRounds = schedulingProfile
        .map(function (_a) {
        var venues = _a.venues, scheduleDate = _a.scheduleDate;
        return venues.map(function (_a) {
            var rounds = _a.rounds;
            return rounds.map(function (round) {
                var _a;
                var roundRef = getRoundId(round);
                if ((_a = roundRef.roundSegment) === null || _a === void 0 ? void 0 : _a.segmentsCount) {
                    segmentedRounds[roundRef.id] = roundRef.roundSegment.segmentsCount;
                }
                return definedAttributes(__assign({ id: withRoundId ? roundRef.id : undefined, scheduleDate: scheduleDate }, roundRef));
            });
        });
    })
        .flat(Infinity);
    return { profileRounds: profileRounds, segmentedRounds: segmentedRounds };
}

var stageOrder = drawDefinitionConstants.stageOrder;
// Sort rounds by order in which they will be played
function roundSort(a, b) {
    return (a.eventName.localeCompare(b.eventName) ||
        a.eventId.localeCompare(b.eventId) ||
        (stageOrder[a === null || a === void 0 ? void 0 : a.stage] || 0) - (stageOrder[b === null || b === void 0 ? void 0 : b.stage] || 0) ||
        b.matchUpsCount - a.matchUpsCount ||
        "".concat(a.stageSequence, "-").concat(a.roundNumber, "-").concat(a.minFinishingSum).localeCompare("".concat(b.stageSequence, "-").concat(b.roundNumber, "-").concat(b.minFinishingSum)));
}

function getRounds(_a) {
    var _b;
    var _c;
    var excludeScheduleDateProfileRounds = _a.excludeScheduleDateProfileRounds, excludeScheduledRounds = _a.excludeScheduledRounds, excludeCompletedRounds = _a.excludeCompletedRounds, inContextMatchUps = _a.inContextMatchUps, tournamentRecords = _a.tournamentRecords, schedulingProfile = _a.schedulingProfile, tournamentRecord = _a.tournamentRecord, withSplitRounds = _a.withSplitRounds, matchUpFilters = _a.matchUpFilters, scheduleDate = _a.scheduleDate, withRoundId = _a.withRoundId, venueId = _a.venueId, context = _a.context;
    if (inContextMatchUps && !Array.isArray(inContextMatchUps || typeof inContextMatchUps[0] !== 'object')) {
        return { error: INVALID_VALUES, inContextMatchUps: inContextMatchUps };
    }
    if (tournamentRecord && !tournamentRecords) {
        if (typeof tournamentRecord !== 'object') {
            return { error: INVALID_TOURNAMENT_RECORD };
        }
        else {
            tournamentRecords = (_b = {}, _b[tournamentRecord.tournamentId] = tournamentRecord, _b);
        }
    }
    var noTournamentRecords = typeof tournamentRecords !== 'object' || !Object.keys(tournamentRecords).length;
    var needsTournamentRecords = venueId ||
        scheduleDate ||
        !inContextMatchUps ||
        (!schedulingProfile &&
            (excludeScheduleDateProfileRounds || excludeCompletedRounds || schedulingProfile || withSplitRounds));
    if (needsTournamentRecords && noTournamentRecords)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var tournamentVenueIds = Object.assign.apply(Object, __spreadArray([{}], __read(Object.values(tournamentRecords !== null && tournamentRecords !== void 0 ? tournamentRecords : {}).map(function (_a) {
        var _b;
        var _c = _a.venues, venues = _c === void 0 ? [] : _c, tournamentId = _a.tournamentId;
        return (_b = {},
            _b[tournamentId] = venues === null || venues === void 0 ? void 0 : venues.map(function (_a) {
                var venueId = _a.venueId;
                return venueId;
            }),
            _b);
    })), false));
    var events = Object.values(tournamentRecords !== null && tournamentRecords !== void 0 ? tournamentRecords : {})
        .map(function (_a) {
        var _b = _a.events, events = _b === void 0 ? [] : _b, tournamentId = _a.tournamentId, startDate = _a.startDate, endDate = _a.endDate;
        return events.map(function (event) {
            var _a, _b;
            return (__assign(__assign({}, event), { validVenueIds: tournamentVenueIds[tournamentId], startDate: (_a = event.startDate) !== null && _a !== void 0 ? _a : startDate, endDate: (_b = event.endDate) !== null && _b !== void 0 ? _b : endDate }));
        });
    })
        .flat();
    var _d = (tournamentRecords &&
        (excludeScheduleDateProfileRounds || excludeCompletedRounds || schedulingProfile || withSplitRounds) &&
        getProfileRounds({ tournamentRecords: tournamentRecords, schedulingProfile: schedulingProfile })) ||
        {}, segmentedRounds = _d.segmentedRounds, profileRounds = _d.profileRounds;
    var profileRoundsMap = excludeScheduleDateProfileRounds && Object.assign.apply(Object, __spreadArray([{}], __read(profileRounds.map(function (profile) {
        var _a;
        return (_a = {}, _a[profile.id] = profile, _a);
    })), false));
    var consideredMatchUps = inContextMatchUps ||
        (tournamentRecords && ((_c = allCompetitionMatchUps({ tournamentRecords: tournamentRecords, matchUpFilters: matchUpFilters })) === null || _c === void 0 ? void 0 : _c.matchUps)) ||
        [];
    var excludedRounds = [];
    var rounds = (consideredMatchUps &&
        Object.values(consideredMatchUps.reduce(function (rounds, matchUp) {
            var _a;
            var _b, _c;
            var id = getRoundId(matchUp).id;
            var segmentsCount = segmentedRounds === null || segmentedRounds === void 0 ? void 0 : segmentedRounds[id];
            var matchUps = __spreadArray(__spreadArray([], __read(((_c = (_b = rounds[id]) === null || _b === void 0 ? void 0 : _b.matchUps) !== null && _c !== void 0 ? _c : [])), false), [matchUp], false);
            var containerStructureId = matchUp.containerStructureId, stageSequence = matchUp.stageSequence, structureName = matchUp.structureName, tournamentId = matchUp.tournamentId, isRoundRobin = matchUp.isRoundRobin, matchUpType = matchUp.matchUpType, roundNumber = matchUp.roundNumber, roundOffset = matchUp.roundOffset, structureId = matchUp.structureId, eventName = matchUp.eventName, roundName = matchUp.roundName, drawName = matchUp.drawName, eventId = matchUp.eventId, drawId = matchUp.drawId;
            var relevantStructureId = isRoundRobin ? containerStructureId : structureId;
            return __assign(__assign({}, rounds), (_a = {}, _a[id] = {
                id: withRoundId ? id : undefined,
                structureId: relevantStructureId,
                stageSequence: stageSequence,
                segmentsCount: segmentsCount,
                structureName: structureName,
                tournamentId: tournamentId,
                matchUpType: matchUpType,
                roundNumber: roundNumber,
                roundOffset: roundOffset,
                eventName: eventName,
                roundName: roundName,
                drawName: drawName,
                matchUps: matchUps,
                eventId: eventId,
                drawId: drawId,
            }, _a));
        }, {}))
            .map(function (round) {
            var _a = getFinishingPositionDetails(round.matchUps), minFinishingSum = _a.minFinishingSum, winnerFinishingPositionRange = _a.winnerFinishingPositionRange;
            var segmentsCount = round.segmentsCount;
            if (segmentsCount) {
                var chunkSize = round.matchUps.length / segmentsCount;
                var sortedMatchUps = chunkArray(round.matchUps.sort(function (a, b) { return a.roundPosition - b.roundPosition; }), chunkSize);
                return sortedMatchUps.map(function (matchUps, i) {
                    var _a = getRoundProfile(matchUps), unscheduledCount = _a.unscheduledCount, incompleteCount = _a.incompleteCount, matchUpsCount = _a.matchUpsCount, isScheduled = _a.isScheduled, isComplete = _a.isComplete, byeCount = _a.byeCount;
                    var roundTiming = getRoundTiming({
                        matchUps: round.matchUps,
                        tournamentRecords: tournamentRecords,
                        events: events,
                        round: round,
                    });
                    return definedAttributes(__assign(__assign(__assign({}, round), context), { roundSegment: { segmentsCount: segmentsCount, segmentNumber: i + 1 }, winnerFinishingPositionRange: winnerFinishingPositionRange, unscheduledCount: unscheduledCount, incompleteCount: incompleteCount, minFinishingSum: minFinishingSum, matchUpsCount: matchUpsCount, isScheduled: isScheduled, roundTiming: roundTiming, isComplete: isComplete, byeCount: byeCount, matchUps: matchUps }));
                });
            }
            var _b = getRoundProfile(round.matchUps), unscheduledCount = _b.unscheduledCount, incompleteCount = _b.incompleteCount, matchUpsCount = _b.matchUpsCount, isScheduled = _b.isScheduled, isComplete = _b.isComplete, byeCount = _b.byeCount;
            var roundTiming = getRoundTiming({
                matchUps: round.matchUps,
                tournamentRecords: tournamentRecords,
                events: events,
                round: round,
            });
            return definedAttributes(__assign(__assign(__assign({}, round), context), { winnerFinishingPositionRange: winnerFinishingPositionRange, unscheduledCount: unscheduledCount, incompleteCount: incompleteCount, minFinishingSum: minFinishingSum, matchUpsCount: matchUpsCount, isScheduled: isScheduled, roundTiming: roundTiming, isComplete: isComplete, byeCount: byeCount }));
        })
            .flat()
            .filter(function (round) {
            var _a, _b;
            if (excludeScheduleDateProfileRounds) {
                var scheduleDate_1 = extractDate(excludeScheduleDateProfileRounds);
                var roundId = withRoundId ? round.id : getRoundId(round).id;
                if (scheduleDate_1 &&
                    profileRoundsMap[roundId] &&
                    extractDate(profileRoundsMap[roundId].scheduleDate) === scheduleDate_1) {
                    return false;
                }
            }
            var isComplete = round.isComplete, isScheduled = round.isScheduled;
            var keepComplete = !excludeCompletedRounds || !isComplete;
            var keepScheduled = !excludeScheduledRounds || !isScheduled;
            var event = venueId || scheduleDate ? events === null || events === void 0 ? void 0 : events.find(function (_a) {
                var eventId = _a.eventId;
                return eventId === round.eventId;
            }) : undefined;
            var startDate = (_a = event === null || event === void 0 ? void 0 : event.startDate) !== null && _a !== void 0 ? _a : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.startDate;
            var endDate = (_b = event === null || event === void 0 ? void 0 : event.endDate) !== null && _b !== void 0 ? _b : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.endDate;
            var validStartDate = !scheduleDate || !startDate || new Date(scheduleDate) >= new Date(startDate);
            var validEndDate = !scheduleDate || !endDate || new Date(scheduleDate) <= new Date(endDate);
            var validDate = validStartDate && validEndDate;
            var validVenue = !venueId || (event === null || event === void 0 ? void 0 : event.validVenueIds.includes(venueId));
            var keepRound = keepComplete && keepScheduled && validVenue && validDate;
            if (!keepRound)
                excludedRounds.push(round);
            return keepRound;
        })
            .sort(roundSort)) ||
        [];
    return __assign(__assign({}, SUCCESS), { rounds: rounds, excludedRounds: excludedRounds });
}

function getTieFormat(_a) {
    var _b, _c, _d, _e, _f;
    var tournamentRecord = _a.tournamentRecord, // passed in automatically by tournamentEngine
    drawDefinition = _a.drawDefinition, // passed in automatically by tournamentEngine when drawId provided
    structureId = _a.structureId, // optional - if only the default matchUpFormat for a structure is required
    matchUpId = _a.matchUpId, // id of matchUp for which the scoped matchUpFormat(s) are desired
    structure = _a.structure, // optional optimization - when structure already known
    eventId = _a.eventId, // optional - if only the default matchUpFormat for an event is required
    drawId = _a.drawId, // avoid brute force search for matchUp
    event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!drawId && !event && !structureId && !matchUpId)
        return decorateResult({
            result: { error: MISSING_VALUE },
            stack: 'getTieFormat',
        });
    if (eventId && !event) {
        event = (_b = tournamentRecord.events) === null || _b === void 0 ? void 0 : _b.find(function (event) { return event.eventId === eventId; });
    }
    var matchUpResult = publicFindMatchUp({
        tournamentRecord: tournamentRecord,
        drawDefinition: drawDefinition,
        matchUpId: matchUpId,
        drawId: drawId,
        event: event,
    });
    if (matchUpId && (matchUpResult === null || matchUpResult === void 0 ? void 0 : matchUpResult.error)) {
        return matchUpResult;
    }
    else if (!drawDefinition && (matchUpResult === null || matchUpResult === void 0 ? void 0 : matchUpResult.drawDefinition)) {
        drawDefinition = matchUpResult === null || matchUpResult === void 0 ? void 0 : matchUpResult.drawDefinition;
    }
    structure = structure !== null && structure !== void 0 ? structure : matchUpResult === null || matchUpResult === void 0 ? void 0 : matchUpResult.structure;
    if (!structure && structureId && !matchUpId) {
        if (!drawDefinition)
            return { error: MISSING_DRAW_ID };
        var structureResult = findStructure({ drawDefinition: drawDefinition, structureId: structureId });
        if (structureResult.error)
            return structureResult;
        structure = structureResult.structure;
    }
    var structureDefaultTieFormat = ((structure === null || structure === void 0 ? void 0 : structure.tieFormat) || (structure === null || structure === void 0 ? void 0 : structure.tieFormatId)) &&
        ((_c = resolveTieFormat({ structure: structure, drawDefinition: drawDefinition, event: event })) === null || _c === void 0 ? void 0 : _c.tieFormat);
    var drawDefaultTieFormat = ((drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.tieFormat) || (drawDefinition === null || drawDefinition === void 0 ? void 0 : drawDefinition.tieFormatId)) &&
        ((_d = resolveTieFormat({
            drawDefinition: drawDefinition,
            event: event,
        })) === null || _d === void 0 ? void 0 : _d.tieFormat);
    var eventDefaultTieFormat = (_e = resolveTieFormat({ event: event })) === null || _e === void 0 ? void 0 : _e.tieFormat;
    var tieFormat = (_f = resolveTieFormat({
        matchUp: matchUpResult === null || matchUpResult === void 0 ? void 0 : matchUpResult.matchUp,
        drawDefinition: drawDefinition,
        structure: structure,
        event: event,
    })) === null || _f === void 0 ? void 0 : _f.tieFormat;
    return __assign(__assign({}, SUCCESS), { matchUp: matchUpResult === null || matchUpResult === void 0 ? void 0 : matchUpResult.matchUp, structureDefaultTieFormat: copyTieFormat(structureDefaultTieFormat), eventDefaultTieFormat: copyTieFormat(eventDefaultTieFormat), drawDefaultTieFormat: copyTieFormat(drawDefaultTieFormat), tieFormat: copyTieFormat(tieFormat), structure: structure });
}

function drawMatchUps(_a) {
    var _b;
    var _c, _d, _e;
    var tournamentParticipants = _a.participants, tournamentAppliedPolicies = _a.tournamentAppliedPolicies, scheduleVisibilityFilters = _a.scheduleVisibilityFilters, participantsProfile = _a.participantsProfile, afterRecoveryTimes = _a.afterRecoveryTimes, policyDefinitions = _a.policyDefinitions, useParticipantMap = _a.useParticipantMap, tournamentRecord = _a.tournamentRecord, usePublishState = _a.usePublishState, contextFilters = _a.contextFilters, contextContent = _a.contextContent, matchUpFilters = _a.matchUpFilters, participantMap = _a.participantMap, publishStatus = _a.publishStatus, contextProfile = _a.contextProfile, drawDefinition = _a.drawDefinition, nextMatchUps = _a.nextMatchUps, tournamentId = _a.tournamentId, inContext = _a.inContext, context = _a.context, event = _a.event;
    var _f = event !== null && event !== void 0 ? event : {}, eventId = _f.eventId, eventName = _f.eventName, endDate = _f.endDate;
    var additionalContext = __assign(__assign({}, context), definedAttributes({
        eventId: eventId,
        eventName: eventName,
        endDate: (_c = endDate !== null && endDate !== void 0 ? endDate : event === null || event === void 0 ? void 0 : event.endDate) !== null && _c !== void 0 ? _c : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.endDate,
        tournamentId: tournamentId !== null && tournamentId !== void 0 ? tournamentId : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
        indoorOutDoor: (_d = event === null || event === void 0 ? void 0 : event.indoorOutdoor) !== null && _d !== void 0 ? _d : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.indoorOutdoor,
        surfaceCategory: (_e = event === null || event === void 0 ? void 0 : event.surfaceCategory) !== null && _e !== void 0 ? _e : tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.surfaceCategory,
    }));
    var groupInfo;
    if (!(tournamentParticipants === null || tournamentParticipants === void 0 ? void 0 : tournamentParticipants.length) && tournamentRecord) {
        (_b = hydrateParticipants({
            participantsProfile: participantsProfile,
            policyDefinitions: policyDefinitions,
            useParticipantMap: useParticipantMap,
            tournamentRecord: tournamentRecord,
            contextProfile: contextProfile,
            inContext: inContext,
        }), tournamentParticipants = _b.participants, participantMap = _b.participantMap, groupInfo = _b.groupInfo);
    }
    if (event && contextProfile && !contextContent)
        contextContent = getContextContent({
            policyDefinitions: policyDefinitions,
            tournamentRecord: tournamentRecord,
            contextProfile: contextProfile,
            drawDefinition: drawDefinition,
            event: event,
        });
    var drawMatchUpsResult = getDrawMatchUps({
        context: additionalContext,
        tournamentAppliedPolicies: tournamentAppliedPolicies,
        scheduleVisibilityFilters: scheduleVisibilityFilters,
        tournamentParticipants: tournamentParticipants,
        participantsProfile: participantsProfile,
        afterRecoveryTimes: afterRecoveryTimes,
        policyDefinitions: policyDefinitions,
        tournamentRecord: tournamentRecord,
        usePublishState: usePublishState,
        participantMap: participantMap,
        contextContent: contextContent,
        contextFilters: contextFilters,
        matchUpFilters: matchUpFilters,
        publishStatus: publishStatus,
        contextProfile: contextProfile,
        drawDefinition: drawDefinition,
        nextMatchUps: nextMatchUps,
        inContext: inContext,
        event: event,
    });
    return __assign(__assign({}, drawMatchUpsResult), { groupInfo: groupInfo });
}

function getVenuesReport(_a) {
    var _b, _c;
    var _d = _a.ignoreDisabled, ignoreDisabled = _d === void 0 ? true : _d, tournamentRecords = _a.tournamentRecords, tournamentId = _a.tournamentId, _e = _a.venueIds, venueIds = _e === void 0 ? [] : _e, _f = _a.dates, dates = _f === void 0 ? [] : _f;
    if (!Array.isArray(dates))
        return { error: INVALID_VALUES, dates: dates };
    if (!Array.isArray(venueIds))
        return { error: INVALID_VALUES, venueIds: venueIds };
    var tournamentIds = (tournamentRecords &&
        Object.keys(tournamentRecords).filter(function (id) { return !tournamentId || id === tournamentId; })) ||
        [];
    if (!tournamentIds.length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var validDates = dates.every(isValidDateString);
    if (!validDates)
        return { error: INVALID_DATE };
    var result = getVenuesAndCourts({
        tournamentRecords: tournamentRecords,
        ignoreDisabled: ignoreDisabled,
        dates: dates,
    });
    if (result.error)
        return result;
    var venues = (_b = result === null || result === void 0 ? void 0 : result.venues) === null || _b === void 0 ? void 0 : _b.filter(function (_a) {
        var venueId = _a.venueId;
        return !(venueIds === null || venueIds === void 0 ? void 0 : venueIds.length) || venueIds.includes(venueId);
    });
    var courtDates = (_c = result.courts) === null || _c === void 0 ? void 0 : _c.reduce(function (dates, court) {
        var _a;
        (_a = court.dateAvailability) === null || _a === void 0 ? void 0 : _a.forEach(function (availability) {
            var date = availability.date;
            if (!dates.includes(date))
                dates.push(date);
        });
        return dates;
    }, []).filter(function (date) { return !dates.length || dates.includes(date); });
    var matchUpFilters = { venueIds: venues === null || venues === void 0 ? void 0 : venues.map(function (_a) {
            var venueId = _a.venueId;
            return venueId;
        }) };
    var matchUps = allCompetitionMatchUps({
        afterRecoveryTimes: true,
        tournamentRecords: tournamentRecords,
        matchUpFilters: matchUpFilters,
    }).matchUps;
    var venuesReport = venues === null || venues === void 0 ? void 0 : venues.map(function (venue) {
        return getVenueReport(courtDates, venue, matchUps);
    });
    return { venuesReport: venuesReport };
}
function getVenueReport(dates, venue, matchUps) {
    var venueId = venue.venueId, courts = venue.courts, venueName = venue.venueName;
    var venueReport = {};
    dates.forEach(function (date) {
        var e_1, _a;
        // for each venue court calculate the available minutes on specified date
        var availableMinutes = 0, scheduledMinutes = 0, availableCourts = 0;
        try {
            for (var courts_1 = __values(courts), courts_1_1 = courts_1.next(); !courts_1_1.done; courts_1_1 = courts_1.next()) {
                var court = courts_1_1.value;
                var courtDate = court.dateAvailability.find(function (availability) { return availability.date === date; });
                var timeSlots = courtDate && generateTimeSlots({ courtDate: courtDate });
                var courtAvailableMinutes = timeSlots === null || timeSlots === void 0 ? void 0 : timeSlots.reduce(function (minutes, timeSlot) {
                    var startTime = timeSlot.startTime, endTime = timeSlot.endTime;
                    var timeSlotMinutes = timeStringMinutes(endTime) - timeStringMinutes(startTime);
                    return minutes + timeSlotMinutes;
                }, 0);
                if (courtAvailableMinutes)
                    availableCourts += 1;
                availableMinutes += courtAvailableMinutes;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (courts_1_1 && !courts_1_1.done && (_a = courts_1.return)) _a.call(courts_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var venueMatchUps = matchUps.filter(function (_a) {
            var schedule = _a.schedule;
            return schedule.venueId === venueId && sameDay(date, schedule.scheduledDate);
        });
        venueMatchUps.forEach(function (_a) {
            var schedule = _a.schedule;
            var startTime = extractTime(schedule.scheduledTime);
            var endTime = addMinutesToTimeString(startTime, schedule.averageMinutes);
            var matchUpScheduledMinutes = timeStringMinutes(endTime) - timeStringMinutes(startTime);
            scheduledMinutes += matchUpScheduledMinutes;
        });
        var percentUtilization = availableMinutes
            ? ((scheduledMinutes / availableMinutes) * 100).toFixed(2)
            : '100';
        venueReport[date] = {
            scheduledMatchUpsCount: venueMatchUps.length,
            availableCourts: availableCourts,
            availableMinutes: availableMinutes,
            scheduledMinutes: scheduledMinutes,
            percentUtilization: percentUtilization,
        };
    });
    return {
        venueId: venueId,
        venueName: venueName,
        venueReport: venueReport,
    };
}

/**
 *
 * @param {string} venueId - optional -
 * @param {string[]} venueIds - optional -
 */
function getCourts(_a) {
    var tournamentRecord = _a.tournamentRecord, venueId = _a.venueId, venueIds = _a.venueIds;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var courts = (tournamentRecord.venues || [])
        .filter(function (venue) {
        if (venueId)
            return venue.venueId === venueId;
        if (venueIds)
            return venueIds.includes(venue.venueId);
        return true;
    })
        .map(function (venue) {
        var venueId = venue.venueId;
        var venueCourts = makeDeepCopy(venue.courts || []);
        venueCourts.forEach(function (court) { return Object.assign(court, { venueId: venueId }); });
        return venueCourts;
    })
        .flat();
    return { courts: courts };
}

function getEvents(_a) {
    var e_1, _b;
    var _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    var tournamentRecord = _a.tournamentRecord, withScaleValues = _a.withScaleValues, scaleEventType = _a.scaleEventType, inContext = _a.inContext, // hydrate with tournamentId
    eventIds = _a.eventIds, // only return events with these eventIds
    drawIds = _a.drawIds, // only return events with these drawIds, and only drawDefinitions with these drawIds
    context = _a.context;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var tournamentId = tournamentRecord.tournamentId;
    var eventCopies = ((_c = tournamentRecord.events) !== null && _c !== void 0 ? _c : [])
        .filter(function (_a) {
        var eventId = _a.eventId;
        return !eventIds || (Array.isArray(eventIds) && eventIds.includes(eventId));
    })
        .map(function (event) {
        var _a;
        var eventDrawIds = (_a = event.drawDefinitions) === null || _a === void 0 ? void 0 : _a.map(xa('drawId'));
        if ((drawIds === null || drawIds === void 0 ? void 0 : drawIds.length) && !intersection(drawIds, eventDrawIds).length)
            return;
        var eventCopy = makeDeepCopy(event);
        if (inContext)
            Object.assign(eventCopy, { tournamentId: tournamentId });
        if (context)
            Object.assign(eventCopy, context);
        return eventCopy;
    })
        .filter(Boolean);
    var eventsMap = {};
    if (withScaleValues) {
        var participantMap_1 = getParticipants({
            withScaleValues: true,
            tournamentRecord: tournamentRecord,
        }).participantMap;
        var sum = function (values) { return values.reduce(function (total, value) { return total + parseFloat(value); }, 0); };
        var _loop_1 = function (event_1) {
            var e_2, _o, e_3, _p, e_4, _q, e_5, _r, e_6, _s, e_7, _t, e_8, _u;
            var eventType = scaleEventType !== null && scaleEventType !== void 0 ? scaleEventType : event_1.eventType;
            var eventId = event_1.eventId;
            if (!eventsMap[eventId])
                eventsMap[eventId] = {
                    ratingsStats: {},
                    ratings: {},
                    ranking: {},
                    draws: {},
                };
            var selectedEntries = ((_d = event_1.entries) !== null && _d !== void 0 ? _d : []).filter(function (_a) {
                var entryStatus = _a.entryStatus;
                return STRUCTURE_SELECTED_STATUSES.includes(entryStatus);
            });
            var participantIds = selectedEntries.map(xa(PARTICIPANT_ID));
            var processParticipant = function (participant) {
                var e_9, _a, e_10, _b;
                var _c, _d, _e, _f, _g, _h, _j, _k;
                if ((_c = participant === null || participant === void 0 ? void 0 : participant.ratings) === null || _c === void 0 ? void 0 : _c[eventType]) {
                    try {
                        for (var _l = (e_9 = void 0, __values((_e = (_d = participant === null || participant === void 0 ? void 0 : participant.ratings) === null || _d === void 0 ? void 0 : _d[eventType]) !== null && _e !== void 0 ? _e : [])), _m = _l.next(); !_m.done; _m = _l.next()) {
                            var rating = _m.value;
                            var scaleName = rating.scaleName;
                            if (!eventsMap[eventId].ratings[scaleName])
                                eventsMap[eventId].ratings[scaleName] = [];
                            var accessor = (_f = ratingsParameters[scaleName]) === null || _f === void 0 ? void 0 : _f.accessor;
                            if (accessor) {
                                var value = parseFloat((_g = rating.scaleValue) === null || _g === void 0 ? void 0 : _g[accessor]);
                                if (value)
                                    eventsMap[eventId].ratings[scaleName].push(value);
                            }
                        }
                    }
                    catch (e_9_1) { e_9 = { error: e_9_1 }; }
                    finally {
                        try {
                            if (_m && !_m.done && (_a = _l.return)) _a.call(_l);
                        }
                        finally { if (e_9) throw e_9.error; }
                    }
                }
                if ((_h = participant === null || participant === void 0 ? void 0 : participant.rankings) === null || _h === void 0 ? void 0 : _h[eventType]) {
                    try {
                        for (var _o = (e_10 = void 0, __values((_k = (_j = participant === null || participant === void 0 ? void 0 : participant.rankings) === null || _j === void 0 ? void 0 : _j[eventType]) !== null && _k !== void 0 ? _k : [])), _p = _o.next(); !_p.done; _p = _o.next()) {
                            var ranking = _p.value;
                            var scaleName = ranking.scaleName;
                            if (!eventsMap[eventId].ranking[scaleName])
                                eventsMap[eventId].ranking[scaleName] = [];
                            if (ranking.scaleValue)
                                eventsMap[eventId].ranking[scaleName].push(ranking.scaleValue);
                        }
                    }
                    catch (e_10_1) { e_10 = { error: e_10_1 }; }
                    finally {
                        try {
                            if (_p && !_p.done && (_b = _o.return)) _b.call(_o);
                        }
                        finally { if (e_10) throw e_10.error; }
                    }
                }
            };
            try {
                for (var participantIds_1 = (e_2 = void 0, __values(participantIds)), participantIds_1_1 = participantIds_1.next(); !participantIds_1_1.done; participantIds_1_1 = participantIds_1.next()) {
                    var participantId = participantIds_1_1.value;
                    var participant = (_e = participantMap_1 === null || participantMap_1 === void 0 ? void 0 : participantMap_1[participantId]) === null || _e === void 0 ? void 0 : _e.participant;
                    if ((participant === null || participant === void 0 ? void 0 : participant.participantType) !== INDIVIDUAL) {
                        try {
                            for (var _v = (e_3 = void 0, __values((_f = participant === null || participant === void 0 ? void 0 : participant.individualParticipantIds) !== null && _f !== void 0 ? _f : [])), _w = _v.next(); !_w.done; _w = _v.next()) {
                                var individualParticipantId = _w.value;
                                var individualParticipant = (_g = participantMap_1 === null || participantMap_1 === void 0 ? void 0 : participantMap_1[individualParticipantId]) === null || _g === void 0 ? void 0 : _g.participant;
                                processParticipant(individualParticipant);
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (_w && !_w.done && (_p = _v.return)) _p.call(_v);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                    }
                    else {
                        processParticipant(participant);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (participantIds_1_1 && !participantIds_1_1.done && (_o = participantIds_1.return)) _o.call(participantIds_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            // add stats for all event-level entries ratings
            var ratings = eventsMap[eventId].ratings;
            try {
                for (var _x = (e_4 = void 0, __values(Object.keys(ratings))), _y = _x.next(); !_y.done; _y = _x.next()) {
                    var scaleName = _y.value;
                    var scaleRating = ratings[scaleName];
                    if (!scaleRating.length)
                        continue;
                    var med = (_h = median(scaleRating)) === null || _h === void 0 ? void 0 : _h.toFixed(2);
                    eventsMap[eventId].ratingsStats[scaleName] = {
                        avg: parseFloat((sum(scaleRating) / scaleRating.length).toFixed(2)),
                        median: med ? parseFloat(med) : undefined,
                        max: Math.max.apply(Math, __spreadArray([], __read(scaleRating), false)),
                        min: Math.min.apply(Math, __spreadArray([], __read(scaleRating), false)),
                    };
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_y && !_y.done && (_q = _x.return)) _q.call(_x);
                }
                finally { if (e_4) throw e_4.error; }
            }
            var processFlight = function (drawId, participantIds) {
                var e_11, _a, e_12, _b;
                var _c, _d, _e;
                var processParticipant = function (participant) {
                    var e_13, _a, e_14, _b;
                    var _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
                    if (((_c = eventsMap[eventId].draws) === null || _c === void 0 ? void 0 : _c[drawId]) && ((_d = participant === null || participant === void 0 ? void 0 : participant.ratings) === null || _d === void 0 ? void 0 : _d[eventType])) {
                        try {
                            for (var _q = (e_13 = void 0, __values((_f = (_e = participant === null || participant === void 0 ? void 0 : participant.ratings) === null || _e === void 0 ? void 0 : _e[eventType]) !== null && _f !== void 0 ? _f : [])), _r = _q.next(); !_r.done; _r = _q.next()) {
                                var rating = _r.value;
                                var scaleName = rating.scaleName;
                                if (!((_g = eventsMap[eventId].draws[drawId]) === null || _g === void 0 ? void 0 : _g.ratings[scaleName]))
                                    eventsMap[eventId].draws[drawId].ratings[scaleName] = [];
                                var accessor = (_h = ratingsParameters[scaleName]) === null || _h === void 0 ? void 0 : _h.accessor;
                                if (accessor) {
                                    var value = parseFloat((_j = rating.scaleValue) === null || _j === void 0 ? void 0 : _j[accessor]);
                                    if (value) {
                                        eventsMap[eventId].draws[drawId].ratings[scaleName].push(value);
                                    }
                                }
                            }
                        }
                        catch (e_13_1) { e_13 = { error: e_13_1 }; }
                        finally {
                            try {
                                if (_r && !_r.done && (_a = _q.return)) _a.call(_q);
                            }
                            finally { if (e_13) throw e_13.error; }
                        }
                    }
                    if (((_k = eventsMap[eventId].draws) === null || _k === void 0 ? void 0 : _k[drawId]) && ((_l = participant === null || participant === void 0 ? void 0 : participant.rankings) === null || _l === void 0 ? void 0 : _l[eventType])) {
                        try {
                            for (var _s = (e_14 = void 0, __values((_o = (_m = participant === null || participant === void 0 ? void 0 : participant.rankings) === null || _m === void 0 ? void 0 : _m[eventType]) !== null && _o !== void 0 ? _o : [])), _t = _s.next(); !_t.done; _t = _s.next()) {
                                var ranking = _t.value;
                                var scaleName = ranking.scaleName;
                                if (!((_p = eventsMap[eventId].draws[drawId]) === null || _p === void 0 ? void 0 : _p.ranking[scaleName]))
                                    eventsMap[eventId].draws[drawId].ranking[scaleName] = [];
                                var value = ranking.scaleValue;
                                if (value) {
                                    eventsMap[eventId].draws[drawId].ranking[scaleName].push(value);
                                }
                            }
                        }
                        catch (e_14_1) { e_14 = { error: e_14_1 }; }
                        finally {
                            try {
                                if (_t && !_t.done && (_b = _s.return)) _b.call(_s);
                            }
                            finally { if (e_14) throw e_14.error; }
                        }
                    }
                };
                try {
                    for (var _f = (e_11 = void 0, __values(participantIds.filter(Boolean))), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var participantId = _g.value;
                        var participant = (_c = participantMap_1 === null || participantMap_1 === void 0 ? void 0 : participantMap_1[participantId]) === null || _c === void 0 ? void 0 : _c.participant;
                        if ((participant === null || participant === void 0 ? void 0 : participant.participantType) !== INDIVIDUAL) {
                            try {
                                for (var _h = (e_12 = void 0, __values((_d = participant === null || participant === void 0 ? void 0 : participant.individualParticipantIds) !== null && _d !== void 0 ? _d : [])), _j = _h.next(); !_j.done; _j = _h.next()) {
                                    var individualParticipantId = _j.value;
                                    var individualParticipant = (_e = participantMap_1 === null || participantMap_1 === void 0 ? void 0 : participantMap_1[individualParticipantId]) === null || _e === void 0 ? void 0 : _e.participant;
                                    processParticipant(individualParticipant);
                                }
                            }
                            catch (e_12_1) { e_12 = { error: e_12_1 }; }
                            finally {
                                try {
                                    if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                                }
                                finally { if (e_12) throw e_12.error; }
                            }
                        }
                        else {
                            processParticipant(participant);
                        }
                    }
                }
                catch (e_11_1) { e_11 = { error: e_11_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                    }
                    finally { if (e_11) throw e_11.error; }
                }
            };
            var processedDrawIds = [];
            var ignoreDrawId = function (drawId) {
                return ((drawIds === null || drawIds === void 0 ? void 0 : drawIds.length) && drawIds.includes(drawId)) || processedDrawIds.includes(drawId);
            };
            try {
                for (var _z = (e_5 = void 0, __values((_j = event_1.drawDefinitions) !== null && _j !== void 0 ? _j : [])), _0 = _z.next(); !_0.done; _0 = _z.next()) {
                    var drawDefinition = _0.value;
                    var drawId = drawDefinition.drawId;
                    if (ignoreDrawId(drawId))
                        continue;
                    var participantIds_2 = (_k = getAssignedParticipantIds({
                        drawDefinition: drawDefinition,
                    }).assignedParticipantIds) !== null && _k !== void 0 ? _k : [];
                    if (!eventsMap[eventId].draws[drawId])
                        eventsMap[eventId].draws[drawId] = {
                            ratingsStats: {},
                            ratings: {},
                            ranking: {},
                        };
                    processedDrawIds.push(drawId);
                    processFlight(drawId, participantIds_2);
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_0 && !_0.done && (_r = _z.return)) _r.call(_z);
                }
                finally { if (e_5) throw e_5.error; }
            }
            var flightProfile = getFlightProfile({ event: event_1 }).flightProfile;
            try {
                for (var _1 = (e_6 = void 0, __values((_l = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.flights) !== null && _l !== void 0 ? _l : [])), _2 = _1.next(); !_2.done; _2 = _1.next()) {
                    var flight = _2.value;
                    var drawId = flight.drawId;
                    if (ignoreDrawId(drawId))
                        continue;
                    var participantIds_3 = flight.drawEntries.map(xa(PARTICIPANT_ID));
                    processFlight(drawId, participantIds_3);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_2 && !_2.done && (_s = _1.return)) _s.call(_1);
                }
                finally { if (e_6) throw e_6.error; }
            }
            try {
                for (var processedDrawIds_1 = (e_7 = void 0, __values(processedDrawIds)), processedDrawIds_1_1 = processedDrawIds_1.next(); !processedDrawIds_1_1.done; processedDrawIds_1_1 = processedDrawIds_1.next()) {
                    var drawId = processedDrawIds_1_1.value;
                    var ratings_1 = eventsMap[eventId].draws[drawId].ratings;
                    try {
                        for (var _3 = (e_8 = void 0, __values(Object.keys(ratings_1))), _4 = _3.next(); !_4.done; _4 = _3.next()) {
                            var scaleName = _4.value;
                            var scaleRating = ratings_1[scaleName];
                            if (!scaleRating.length)
                                continue;
                            var med = (_m = median(scaleRating)) === null || _m === void 0 ? void 0 : _m.toFixed(2);
                            eventsMap[eventId].draws[drawId].ratingsStats[scaleName] = {
                                avg: parseFloat((sum(scaleRating) / scaleRating.length).toFixed(2)),
                                median: med ? parseFloat(med) : undefined,
                                max: Math.max.apply(Math, __spreadArray([], __read(scaleRating), false)),
                                min: Math.min.apply(Math, __spreadArray([], __read(scaleRating), false)),
                            };
                        }
                    }
                    catch (e_8_1) { e_8 = { error: e_8_1 }; }
                    finally {
                        try {
                            if (_4 && !_4.done && (_u = _3.return)) _u.call(_3);
                        }
                        finally { if (e_8) throw e_8.error; }
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (processedDrawIds_1_1 && !processedDrawIds_1_1.done && (_t = processedDrawIds_1.return)) _t.call(processedDrawIds_1);
                }
                finally { if (e_7) throw e_7.error; }
            }
        };
        try {
            for (var eventCopies_1 = __values(eventCopies), eventCopies_1_1 = eventCopies_1.next(); !eventCopies_1_1.done; eventCopies_1_1 = eventCopies_1.next()) {
                var event_1 = eventCopies_1_1.value;
                _loop_1(event_1);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (eventCopies_1_1 && !eventCopies_1_1.done && (_b = eventCopies_1.return)) _b.call(eventCopies_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return definedAttributes(__assign({ eventScaleValues: eventsMap, events: eventCopies }, SUCCESS));
}

function getEvent(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, context = _a.context, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!event)
        return { error: MISSING_EVENT };
    var eventCopy = makeDeepCopy(event);
    if (context)
        Object.assign(eventCopy, context);
    var drawDefinitionCopy = drawDefinition &&
        ((_b = eventCopy.drawDefinitions) === null || _b === void 0 ? void 0 : _b.find(function (_a) {
            var drawId = _a.drawId;
            return drawDefinition.drawId === drawId;
        }));
    return definedAttributes({
        drawDefinition: drawDefinitionCopy,
        event: eventCopy,
    });
}

function findDrawDefinition(_a) {
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!drawDefinition)
        return { error: MISSING_DRAW_ID };
    return { drawDefinition: makeDeepCopy(drawDefinition) };
}
var queryGovernor = {
    allCompetitionMatchUps: allCompetitionMatchUps,
    allDrawMatchUps: allDrawMatchUps,
    allEventMatchUps: allEventMatchUps,
    allTournamentMatchUps: allTournamentMatchUps,
    analyzeDraws: analyzeDraws,
    analyzeMatchUp: analyzeMatchUp,
    analyzeTournament: analyzeTournament,
    bulkUpdatePublishedEventIds: bulkUpdatePublishedEventIds,
    categoryCanContain: categoryCanContain,
    checkMatchUpIsComplete: checkMatchUpIsComplete,
    checkValidEntries: checkValidEntries,
    competitionScheduleMatchUps: competitionScheduleMatchUps,
    credits: credits,
    drawMatchUps: drawMatchUps,
    eventMatchUps: eventMatchUps,
    findDrawDefinition: findDrawDefinition,
    findExtension: findExtension,
    findMatchUp: publicFindMatchUp,
    findParticipant: publicFindParticipant,
    findPolicy: findPolicy,
    getAllDrawMatchUps: getAllDrawMatchUps,
    getAllowedDrawTypes: getAllowedDrawTypes,
    getAllowedMatchUpFormats: getAllowedMatchUpFormats,
    getAppliedPolicies: getAppliedPolicies,
    getAssignedParticipantIds: getAssignedParticipantIds,
    getCompetitionDateRange: getCompetitionDateRange,
    getCompetitionMatchUps: getCompetitionMatchUps,
    getCompetitionParticipants: getCompetitionParticipants,
    getCompetitionPenalties: getCompetitionPenalties, // test
    getCompetitionVenues: getCompetitionVenues,
    getCourts: getCourts,
    getDrawDefinitionTimeItem: getDrawDefinitionTimeItem,
    getDrawParticipantRepresentativeIds: getDrawParticipantRepresentativeIds,
    getDrawTypeCoercion: getDrawTypeCoercion,
    getEligibleVoluntaryConsolationParticipants: getEligibleVoluntaryConsolationParticipants,
    getEntriesAndSeedsCount: getEntriesAndSeedsCount,
    getEvent: getEvent,
    getEventMatchUpFormatTiming: getEventMatchUpFormatTiming,
    getEventProperties: getEventProperties,
    getEvents: getEvents,
    getEventStructures: getEventStructures,
    getEventTimeItem: getEventTimeItem,
    getFlightProfile: getFlightProfile,
    getLinkedTournamentIds: getLinkedTournamentIds,
    getMatchUpCompetitiveProfile: getMatchUpCompetitiveProfile,
    getMatchUpDailyLimits: getMatchUpDailyLimits, // document
    getMatchUpDailyLimitsUpdate: getMatchUpDailyLimitsUpdate, // document
    getMatchUpDependencies: getMatchUpDependencies,
    getMatchUpFormat: getMatchUpFormat,
    getMatchUpFormatTiming: getMatchUpFormatTiming,
    getMatchUpFormatTimingUpdate: getMatchUpFormatTimingUpdate,
    getMatchUpScheduleDetails: getMatchUpScheduleDetails,
    getMatchUpsStats: getMatchUpsStats,
    getMatchUpType: getMatchUpType,
    getMaxEntryPosition: getMaxEntryPosition,
    getModifiedMatchUpFormatTiming: getModifiedMatchUpFormatTiming,
    getPairedParticipant: getPairedParticipant,
    getParticipantEventDetails: getParticipantEventDetails,
    getParticipantIdFinishingPositions: getParticipantIdFinishingPositions,
    getParticipantMembership: getParticipantMembership,
    getParticipants: getParticipants,
    getParticipantScaleItem: getParticipantScaleItem,
    getParticipantSchedules: getParticipantSchedules,
    getParticipantSignInStatus: getParticipantSignInStatus,
    getParticipantTimeItem: getParticipantTimeItem,
    getPersonRequests: getPersonRequests,
    getPolicyDefinitions: getPolicyDefinitions,
    getPositionAssignments: getPositionAssignments,
    getPredictiveAccuracy: getPredictiveAccuracy,
    getRoundMatchUps: getRoundMatchUps,
    getRounds: getRounds,
    getScaledEntries: getScaledEntries,
    getScheduledRoundsDetails: getScheduledRoundsDetails,
    getSchedulingProfileIssues: getSchedulingProfileIssues,
    getSeedsCount: getSeedsCount,
    getStructureSeedAssignments: getStructureSeedAssignments,
    getTeamLineUp: getTeamLineUp,
    getTieFormat: getTieFormat,
    getTournamentIds: getTournamentIds,
    getTournamentInfo: getTournamentInfo,
    getTournamentPenalties: getTournamentPenalties,
    getTournamentPersons: getTournamentPersons,
    getTournamentStructures: getTournamentStructures,
    getTournamentTimeItem: getTournamentTimeItem,
    getVenuesAndCourts: getVenuesAndCourts,
    getVenuesReport: getVenuesReport,
    isValidForQualifying: isValidForQualifying,
    isValidMatchUpFormat: isValidMatchUpFormat,
    matchUpActions: matchUpActions,
    participantScaleItem: participantScaleItem,
    participantScheduledMatchUps: participantScheduledMatchUps,
    positionActions: positionActions,
    tallyParticipantResults: tallyParticipantResults,
    tournamentMatchUps: tournamentMatchUps,
    validateCollectionDefinition: validateCollectionDefinition,
    validateLineUp: validateLineUp,
    validMatchUp: validMatchUp,
    validMatchUps: validMatchUps,
    allPlayoffPositionsFilled: allPlayoffPositionsFilled,
    getCategoryAgeDetails: getCategoryAgeDetails,
    calculateWinCriteria: calculateWinCriteria,
    compareTieFormats: compareTieFormats,
    getMatchUpContextIds: getMatchUpContextIds,
    getScaleValues: getScaleValues,
    getSeedingThresholds: getSeedingThresholds,
    getTimeItem: getTimeItem,
    getValidGroupSizes: getValidGroupSizes,
    isAdHoc: isAdHoc,
    isCompletedStructure: isCompletedStructure,
    roundRobinGroups: roundRobinGroups,
    tieFormatGenderValidityCheck: tieFormatGenderValidityCheck,
    validateCategory: validateCategory,
};

function getDetailsWTN(_a) {
    var _b, _c, _d, _e, _f, _g;
    var participant = _a.participant, eventType = _a.eventType;
    var personId = (_b = participant === null || participant === void 0 ? void 0 : participant.person) === null || _b === void 0 ? void 0 : _b.personId;
    var personOtherId = (_d = (_c = participant === null || participant === void 0 ? void 0 : participant.person) === null || _c === void 0 ? void 0 : _c.personOtherIds) === null || _d === void 0 ? void 0 : _d[0];
    var tennisId = (_e = participant === null || participant === void 0 ? void 0 : participant.person) === null || _e === void 0 ? void 0 : _e.tennisId;
    var scaleItem = (_g = (_f = participant === null || participant === void 0 ? void 0 : participant.ratings) === null || _f === void 0 ? void 0 : _f[eventType]) === null || _g === void 0 ? void 0 : _g.find(function (_a) {
        var scaleName = _a.scaleName;
        return scaleName === WTN;
    });
    var personWTN = scaleItem === null || scaleItem === void 0 ? void 0 : scaleItem.scaleValue;
    var _h = personWTN || {}, wtnRating = _h.wtnRating, confidence = _h.confidence;
    return {
        timeStamp: scaleItem === null || scaleItem === void 0 ? void 0 : scaleItem.scaleDate,
        personOtherId: personOtherId,
        confidence: confidence,
        wtnRating: wtnRating,
        personId: personId,
        tennisId: tennisId,
    };
}

function getEntryStatusReports(_a) {
    var e_1, _b;
    var _c, _d;
    var tournamentRecord = _a.tournamentRecord;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var tournamentId = tournamentRecord.tournamentId;
    var participantMap = getParticipants({
        withScaleValues: true,
        withEvents: true, // so that event rankings will be present
        withSeeding: true,
        tournamentRecord: tournamentRecord,
        withDraws: true,
    }).participantMap;
    var nonTeamMatchUps = (_c = allTournamentMatchUps({
        matchUpFilters: { matchUpTypes: [SINGLES_MATCHUP, DOUBLES_MATCHUP] },
        tournamentRecord: tournamentRecord,
    }).matchUps) !== null && _c !== void 0 ? _c : [];
    var nonTeamEnteredParticipantIds = nonTeamMatchUps
        .flatMap(function (_a) {
        var sides = _a.sides, matchUpType = _a.matchUpType;
        return sides === null || sides === void 0 ? void 0 : sides.flatMap(function (side) {
            var _a, _b;
            return matchUpType === DOUBLES_MATCHUP
                ? (_a = side === null || side === void 0 ? void 0 : side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipantIds
                : ((_b = side === null || side === void 0 ? void 0 : side.participant) === null || _b === void 0 ? void 0 : _b.participantId) || side.participantId;
        }).filter(Boolean);
    })
        .filter(Boolean);
    var withDrawnParticipantIds = [];
    var participantEntryReports = {};
    var entryStatusReports = {};
    var eventReports = {};
    var drawDefinitionsCount = 0;
    var pushEntryReport = function (_a) {
        var _b, _c;
        var id = _a.id, entry = _a.entry, eventId = _a.eventId, eventType = _a.eventType;
        var qualifyingSeeding = entry.qualifyingSeeding, mainSeeding = entry.mainSeeding, entryStatus = entry.entryStatus, entryStage = entry.entryStage, drawId = entry.drawId;
        if (!participantEntryReports[id])
            participantEntryReports[id] = [];
        var _d = (_b = participantMap === null || participantMap === void 0 ? void 0 : participantMap[id]) !== null && _b !== void 0 ? _b : {}, participant = _d.participant, events = _d.events;
        var entryDetailsWTN = getDetailsWTN({ participant: participant, eventType: eventType });
        var ranking = (_c = events === null || events === void 0 ? void 0 : events[eventId]) === null || _c === void 0 ? void 0 : _c.ranking;
        if (entryStatus === WITHDRAW_PARTICIPANT)
            withDrawnParticipantIds.push(id);
        participantEntryReports[id].push(__assign(__assign({ participantType: participant === null || participant === void 0 ? void 0 : participant.participantType, participantId: id, tournamentId: tournamentId, eventType: eventType, eventId: eventId, drawId: drawId, entryStatus: entryStatus, entryStage: entryStage }, entryDetailsWTN), { ranking: ranking, mainSeeding: mainSeeding, qualifyingSeeding: qualifyingSeeding }));
    };
    var _loop_1 = function (event_1) {
        var entryStatuses = {};
        var countEntryStatus = function (entryStatus) {
            if (!entryStatuses[entryStatus])
                entryStatuses[entryStatus] = { count: 0 };
            entryStatuses[entryStatus].count += 1;
        };
        var _g = event_1.drawDefinitions, drawDefinitions = _g === void 0 ? [] : _g, eventType = event_1.eventType, eventId = event_1.eventId;
        var entries = drawDefinitions.flatMap(function (params) {
            var _a;
            var drawId = params.drawId, entries = params.entries;
            drawDefinitionsCount += 1;
            // build up assignedParticipantIds array
            // to ensure that only assignedParticipants are included
            var stageFilter = function (_a) {
                var stage = _a.stage, stageSequence = _a.stageSequence;
                return (stage === MAIN && stageSequence === 1) || stage === QUALIFYING;
            };
            var structures = (_a = params.structures) !== null && _a !== void 0 ? _a : [];
            var assignedParticipantIds = structures
                .filter(stageFilter)
                .flatMap(function (_a) {
                var positionAssignments = _a.positionAssignments;
                return positionAssignments;
            })
                .filter(Boolean)
                .map(function (_a) {
                var participantId = _a.participantId;
                return participantId;
            });
            var entryFilter = function (_a) {
                var participantId = _a.participantId;
                return assignedParticipantIds.includes(participantId);
            };
            var createEntryProfile = function (params) {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                var participantId = params.participantId, entryStatus = params.entryStatus, entryStage = params.entryStage;
                countEntryStatus(entryStatus);
                var mainSeeding = (_d = (_c = (_b = (_a = participantMap === null || participantMap === void 0 ? void 0 : participantMap[participantId]) === null || _a === void 0 ? void 0 : _a.draws) === null || _b === void 0 ? void 0 : _b[drawId]) === null || _c === void 0 ? void 0 : _c.seedAssignments) === null || _d === void 0 ? void 0 : _d[MAIN];
                var qualifyingSeeding = (_h = (_g = (_f = (_e = participantMap === null || participantMap === void 0 ? void 0 : participantMap[participantId]) === null || _e === void 0 ? void 0 : _e.draws) === null || _f === void 0 ? void 0 : _f[drawId]) === null || _g === void 0 ? void 0 : _g.seedAssignments) === null || _h === void 0 ? void 0 : _h[QUALIFYING];
                return {
                    qualifyingSeeding: qualifyingSeeding,
                    participantId: participantId,
                    mainSeeding: mainSeeding,
                    entryStatus: entryStatus,
                    entryStage: entryStage,
                    drawId: drawId,
                };
            };
            return entries === null || entries === void 0 ? void 0 : entries.filter(entryFilter).map(createEntryProfile);
        });
        var createEntryMap = function (entry) {
            var _a;
            var _b;
            var participantId = entry.participantId;
            var individualParticipantIds = (_b = participantMap === null || participantMap === void 0 ? void 0 : participantMap[participantId].participant.individualParticipantIds) === null || _b === void 0 ? void 0 : _b.filter(
            // ensure that for TEAM events individuals who did not compete are not included
            function (id) { return nonTeamEnteredParticipantIds.includes(id); });
            return participantId && (_a = {}, _a[participantId] = { individualParticipantIds: individualParticipantIds }, _a);
        };
        var processDoublesEvent = function () {
            var participantEntriesMap = Object.assign.apply(Object, __spreadArray([{}], __read(entries.map(createEntryMap).filter(Boolean)), false));
            var processIndividuals = function (entry) {
                participantEntriesMap[entry.participantId].individualParticipantIds.forEach(function (individualParticipantId) {
                    pushEntryReport({
                        id: individualParticipantId,
                        eventType: eventType,
                        eventId: eventId,
                        entry: entry,
                    });
                });
            };
            // add entry details into participantEntryReports
            entries.forEach(processIndividuals);
        };
        if (eventType === DOUBLES_EVENT) {
            processDoublesEvent();
        }
        else {
            // add entry details into participantEntryReports
            entries.forEach(function (entry) {
                pushEntryReport({
                    id: entry === null || entry === void 0 ? void 0 : entry.participantId,
                    eventType: eventType,
                    eventId: eventId,
                    entry: entry,
                });
            });
        }
        var totalEntries = Object.values(entryStatuses).reduce(function (p, c) { return p + c.count; }, 0);
        Object.keys(entryStatuses).forEach(function (key) {
            entryStatuses[key].pct = (entryStatuses[key].count / totalEntries) * 100;
        });
        // for each entry of each event get their WTN and eventRanking
        eventReports[eventId] = { tournamentId: tournamentId, eventId: eventId, entries: entries, entryStatuses: entryStatuses };
        var selectedStatuses = Object.assign.apply(Object, __spreadArray([{}], __read(STRUCTURE_SELECTED_STATUSES.flatMap(function (entryStatus) {
            var _a, _b;
            var _c, _d;
            return [
                (_a = {},
                    _a[entryStatus + '_count'] = (_c = entryStatuses[entryStatus]) === null || _c === void 0 ? void 0 : _c.count,
                    _a),
                (_b = {},
                    _b[entryStatus + '_pct'] = (_d = entryStatuses[entryStatus]) === null || _d === void 0 ? void 0 : _d.pct,
                    _b),
            ];
        })), false));
        entryStatusReports[eventId] = __assign({ tournamentId: tournamentId, eventId: eventId }, selectedStatuses);
    };
    try {
        // Who was in a draw and how they got there...
        for (var _e = __values((_d = tournamentRecord.events) !== null && _d !== void 0 ? _d : []), _f = _e.next(); !_f.done; _f = _e.next()) {
            var event_1 = _f.value;
            _loop_1(event_1);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var individualParticipants = Object.values(participantMap !== null && participantMap !== void 0 ? participantMap : {}).filter(function (_a) {
        var _b = _a.participant, participantType = _b.participantType, participantRole = _b.participantRole;
        return participantType === INDIVIDUAL && participantRole === COMPETITOR;
    });
    var nonParticipatingParticipantIds = individualParticipants
        .filter(function (_a) {
        var participant = _a.participant;
        return !nonTeamEnteredParticipantIds.includes(participant.participantId);
    })
        .map(function (_a) {
        var participant = _a.participant;
        return participant.participantId;
    });
    var tournamentEntryReport = {
        nonParticipatingEntriesCount: nonParticipatingParticipantIds.length,
        individualParticipantsCount: individualParticipants.length,
        eventsCount: Object.values(eventReports).length,
        nonParticipatingParticipantIds: nonParticipatingParticipantIds,
        drawDefinitionsCount: drawDefinitionsCount,
        tournamentId: tournamentId,
    };
    return {
        entryStatusReports: Object.values(entryStatusReports).flat(),
        participantEntryReports: Object.values(participantEntryReports).flat(),
        eventReports: Object.values(eventReports).flat(),
        withDrawnParticipantIds: withDrawnParticipantIds,
        tournamentEntryReport: tournamentEntryReport,
    };
}

function getParticipantStats(_a) {
    var e_1, _b, e_2, _c, e_3, _d, e_4, _e, e_5, _f, e_6, _g, e_7, _h;
    var _j, _k, _l, _m, _o, _p;
    var withCompetitiveProfiles = _a.withCompetitiveProfiles, opponentParticipantId = _a.opponentParticipantId, withIndividualStats = _a.withIndividualStats, teamParticipantId = _a.teamParticipantId, tournamentRecord = _a.tournamentRecord, withScaleValues = _a.withScaleValues, tallyPolicy = _a.tallyPolicy, matchUps = _a.matchUps;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (matchUps && !Array.isArray(matchUps))
        return { error: INVALID_MATCHUP };
    var participantsProfile = withScaleValues ? { withScaleValues: withScaleValues } : undefined;
    matchUps = matchUps !== null && matchUps !== void 0 ? matchUps : allTournamentMatchUps({ tournamentRecord: tournamentRecord, participantsProfile: participantsProfile }).matchUps;
    if (!(matchUps === null || matchUps === void 0 ? void 0 : matchUps.length))
        return { error: MISSING_MATCHUPS };
    var teamParticipantIds = [];
    if (opponentParticipantId)
        teamParticipantIds.push(opponentParticipantId);
    if (teamParticipantId)
        teamParticipantIds.push(teamParticipantId);
    var participantFilters = !teamParticipantIds.length
        ? { participantTypes: [TEAM_PARTICIPANT] }
        : { participantIds: teamParticipantIds };
    var teamParticipants = (_j = getParticipants({ participantFilters: participantFilters, tournamentRecord: tournamentRecord }).participants) !== null && _j !== void 0 ? _j : [];
    if (!teamParticipants.every(function (_a) {
        var participantType = _a.participantType;
        return participantType === TEAM_PARTICIPANT;
    })) {
        return { error: INVALID_PARTICIPANT_IDS };
    }
    if (!teamParticipantIds.length)
        teamParticipantIds.push.apply(teamParticipantIds, __spreadArray([], __read(teamParticipants.map(xa('participantId'))), false));
    var participantDetails = new Map();
    var participantStats = new Map();
    var participating = new Map();
    var teamMap = new Map();
    var initStats = function (participantId, participantName) {
        if (participantName === void 0) { participantName = ''; }
        return participantStats.get(participantId) ||
            (participantStats.set(participantId, {
                participantName: participantName,
                participantId: participantId,
                competitorIds: [],
                competitiveness: {},
                matchUpStatuses: {},
                tiebreaks: [0, 0],
                matchUps: [0, 0],
                points: [0, 0],
                games: [0, 0],
                sets: [0, 0],
            }) &&
                participantStats.get(participantId));
    };
    try {
        for (var teamParticipants_1 = __values(teamParticipants), teamParticipants_1_1 = teamParticipants_1.next(); !teamParticipants_1_1.done; teamParticipants_1_1 = teamParticipants_1.next()) {
            var teamParticipant = teamParticipants_1_1.value;
            var participantId = teamParticipant.participantId, individualParticipantIds = teamParticipant.individualParticipantIds;
            teamMap.set(participantId, individualParticipantIds !== null && individualParticipantIds !== void 0 ? individualParticipantIds : []);
            initStats(participantId, teamParticipant.participantName);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (teamParticipants_1_1 && !teamParticipants_1_1.done && (_b = teamParticipants_1.return)) _b.call(teamParticipants_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (teamParticipantId && !teamMap.get(teamParticipantId))
        return decorateResult({
            result: { error: PARTICIPANT_NOT_FOUND },
            context: { teamParticipantId: teamParticipantId },
        });
    if (opponentParticipantId && !teamMap.get(opponentParticipantId))
        return decorateResult({
            result: { error: PARTICIPANT_NOT_FOUND },
            context: { opponentParticipantId: opponentParticipantId },
        });
    var relevantMatchUps = [];
    var getSideParticipantIds = function (sides) {
        var e_8, _a, e_9, _b, e_10, _c;
        var sideParticipantIds = [[], []];
        try {
            for (var sides_1 = __values(sides), sides_1_1 = sides_1.next(); !sides_1_1.done; sides_1_1 = sides_1.next()) {
                var side = sides_1_1.value;
                var participant = side.participant;
                if (participant === null || participant === void 0 ? void 0 : participant.participantName) {
                    participantDetails.set(participant.participantId, {
                        participantName: participant.participantName,
                        ratings: participant.ratings,
                    });
                    var stats = participantStats.get(participant.participantId);
                    if (stats)
                        stats.participantName = participant.participantName;
                }
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (sides_1_1 && !sides_1_1.done && (_a = sides_1.return)) _a.call(sides_1);
            }
            finally { if (e_8) throw e_8.error; }
        }
        var getCompetitorIds = function (_a) {
            var _b, _c, _d, _e, _f;
            var side = _a.side, individualParticipantIds = _a.individualParticipantIds;
            return ((side.participantId &&
                (!(individualParticipantIds === null || individualParticipantIds === void 0 ? void 0 : individualParticipantIds.length) || individualParticipantIds.includes(side.participantId)) && [
                side.participantId,
            ]) ||
                (((_c = (_b = side.participant) === null || _b === void 0 ? void 0 : _b.individualParticipantIds) === null || _c === void 0 ? void 0 : _c.length) &&
                    (!(individualParticipantIds === null || individualParticipantIds === void 0 ? void 0 : individualParticipantIds.length) ||
                        intersection(individualParticipantIds, (_d = side.participant) === null || _d === void 0 ? void 0 : _d.individualParticipantIds).length ===
                            ((_f = (_e = side.participant) === null || _e === void 0 ? void 0 : _e.individualParticipantIds) === null || _f === void 0 ? void 0 : _f.length)) &&
                    side.participant.individualParticipantIds));
        };
        if (teamMap.size) {
            var processSides = function (thisTeamId, individualParticipantIds) {
                var e_11, _a, e_12, _b;
                try {
                    for (var sides_3 = __values(sides), sides_3_1 = sides_3.next(); !sides_3_1.done; sides_3_1 = sides_3.next()) {
                        var side = sides_3_1.value;
                        if (!side.participant)
                            continue;
                        var competitorIds = getCompetitorIds({
                            individualParticipantIds: individualParticipantIds,
                            side: side,
                        });
                        if (competitorIds === null || competitorIds === void 0 ? void 0 : competitorIds.length) {
                            var sideNumber = side.sideNumber;
                            if (!sideNumber)
                                continue;
                            var ids = [thisTeamId];
                            if (withIndividualStats)
                                ids.push.apply(ids, __spreadArray([], __read(competitorIds), false));
                            sideParticipantIds[sideNumber - 1] = ids;
                            var stats = participantStats.get(thisTeamId);
                            try {
                                for (var _c = (e_12 = void 0, __values(competitorIds.filter(Boolean))), _d = _c.next(); !_d.done; _d = _c.next()) {
                                    var id = _d.value;
                                    if (stats && !stats.competitorIds.includes(id))
                                        stats.competitorIds.push(id);
                                }
                            }
                            catch (e_12_1) { e_12 = { error: e_12_1 }; }
                            finally {
                                try {
                                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                                }
                                finally { if (e_12) throw e_12.error; }
                            }
                        }
                    }
                }
                catch (e_11_1) { e_11 = { error: e_11_1 }; }
                finally {
                    try {
                        if (sides_3_1 && !sides_3_1.done && (_a = sides_3.return)) _a.call(sides_3);
                    }
                    finally { if (e_11) throw e_11.error; }
                }
            };
            if (teamParticipantId) {
                var processForTeam = !opponentParticipantId ||
                    sides.every(function (side) {
                        return (side.participant &&
                            (getCompetitorIds({
                                individualParticipantIds: teamMap.get(teamParticipantId),
                                side: side,
                            }) ||
                                getCompetitorIds({
                                    individualParticipantIds: teamMap.get(opponentParticipantId),
                                    side: side,
                                })));
                    });
                if (processForTeam) {
                    processSides(teamParticipantId, teamMap.get(teamParticipantId));
                }
            }
            else {
                try {
                    for (var teamMap_1 = __values(teamMap), teamMap_1_1 = teamMap_1.next(); !teamMap_1_1.done; teamMap_1_1 = teamMap_1.next()) {
                        var _d = __read(teamMap_1_1.value, 2), thisTeamId = _d[0], individualParticipantIds = _d[1];
                        processSides(thisTeamId, individualParticipantIds);
                    }
                }
                catch (e_9_1) { e_9 = { error: e_9_1 }; }
                finally {
                    try {
                        if (teamMap_1_1 && !teamMap_1_1.done && (_b = teamMap_1.return)) _b.call(teamMap_1);
                    }
                    finally { if (e_9) throw e_9.error; }
                }
            }
        }
        else if (withIndividualStats) {
            try {
                // no teams so process individuals
                for (var sides_2 = __values(sides), sides_2_1 = sides_2.next(); !sides_2_1.done; sides_2_1 = sides_2.next()) {
                    var side = sides_2_1.value;
                    if (!side.participant)
                        continue;
                    var competitorIds = getCompetitorIds({
                        individualParticipantIds: [],
                        side: side,
                    });
                    var sideNumber = side.sideNumber;
                    if (!sideNumber)
                        continue;
                    sideParticipantIds[sideNumber - 1] = competitorIds;
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (sides_2_1 && !sides_2_1.done && (_c = sides_2.return)) _c.call(sides_2);
                }
                finally { if (e_10) throw e_10.error; }
            }
        }
        return sideParticipantIds;
    };
    var _loop_1 = function (matchUp) {
        if (!isObject(matchUp))
            return { value: { error: INVALID_MATCHUP } };
        var matchUpStatus = matchUp.matchUpStatus, matchUpFormat = matchUp.matchUpFormat, matchUpType = matchUp.matchUpType, winningSide = matchUp.winningSide, score = matchUp.score, sides = matchUp.sides;
        if (!sides || !score || matchUpType === TEAM_MATCHUP || matchUpStatus === BYE)
            return "continue";
        var sideParticipantIds = getSideParticipantIds(sides);
        if (!sideParticipantIds.filter(Boolean).length)
            return "continue";
        var competitiveness = withCompetitiveProfiles && winningSide && ((_k = getMatchUpCompetitiveProfile({ matchUp: matchUp })) === null || _k === void 0 ? void 0 : _k.competitiveness);
        relevantMatchUps.push(matchUp);
        var setsTally = countSets({
            matchUpStatus: matchUpStatus,
            matchUpFormat: matchUpFormat,
            tallyPolicy: tallyPolicy,
            winningSide: winningSide,
            score: score,
        });
        var gamesTally = countGames({
            matchUpStatus: matchUpStatus,
            matchUpFormat: matchUpFormat,
            tallyPolicy: tallyPolicy,
            winningSide: winningSide,
            score: score,
        });
        var _v = countPoints({
            matchUpFormat: matchUpFormat,
            score: score,
        }), pointsTally = _v.pointsTally, tiebreaksTally = _v.tiebreaksTally;
        sideParticipantIds.forEach(function (ids, index) {
            var e_13, _a;
            var _b;
            var _loop_2 = function (id) {
                var participantName = (_b = participantDetails.get(id)) === null || _b === void 0 ? void 0 : _b.participantName;
                var stats = initStats(id, participantName);
                if (stats) {
                    var teamSumTally = function (stat, tally) { return tally.forEach(function (t, i) { return (stats[stat][i] += t); }); };
                    var tiebreaks = index ? __spreadArray([], __read(tiebreaksTally), false).reverse() : tiebreaksTally;
                    var points = index ? __spreadArray([], __read(pointsTally), false).reverse() : pointsTally;
                    var games = index ? __spreadArray([], __read(gamesTally), false).reverse() : gamesTally;
                    var sets = index ? __spreadArray([], __read(setsTally), false).reverse() : setsTally;
                    teamSumTally('tiebreaks', tiebreaks);
                    teamSumTally('points', points);
                    teamSumTally('games', games);
                    teamSumTally('sets', sets);
                    if (winningSide) {
                        var tallyIndex = winningSide - 1 === index ? 0 : 1;
                        stats.matchUps[tallyIndex] += 1;
                    }
                    if (competitiveness) {
                        var attr = competitiveness.toLowerCase();
                        if (!stats.competitiveness[attr])
                            stats.competitiveness[attr] = [0, 0];
                        stats.competitiveness[attr][index] += 1;
                    }
                    if (matchUpStatus) {
                        var attr = matchUpStatus.toLowerCase();
                        if (!stats.matchUpStatuses[attr])
                            stats.matchUpStatuses[attr] = 0;
                        stats.matchUpStatuses[attr] += 1;
                    }
                }
            };
            try {
                for (var ids_1 = (e_13 = void 0, __values(ids)), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
                    var id = ids_1_1.value;
                    _loop_2(id);
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (ids_1_1 && !ids_1_1.done && (_a = ids_1.return)) _a.call(ids_1);
                }
                finally { if (e_13) throw e_13.error; }
            }
        });
    };
    try {
        for (var matchUps_1 = __values(matchUps), matchUps_1_1 = matchUps_1.next(); !matchUps_1_1.done; matchUps_1_1 = matchUps_1.next()) {
            var matchUp = matchUps_1_1.value;
            var state_1 = _loop_1(matchUp);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (matchUps_1_1 && !matchUps_1_1.done && (_c = matchUps_1.return)) _c.call(matchUps_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var statsattributes = ['tiebreaks', 'matchUps', 'points', 'games', 'sets'];
    var competitivenessAttributes = ['competitive', 'routine', 'decisive'];
    var ratio = new Map();
    var add = function (a, b) { return (a !== null && a !== void 0 ? a : 0) + (b !== null && b !== void 0 ? b : 0); };
    try {
        for (var _q = __values(participantStats.entries()), _r = _q.next(); !_r.done; _r = _q.next()) {
            var _s = __read(_r.value, 2), participantId = _s[0], stats = _s[1];
            try {
                for (var statsattributes_1 = (e_4 = void 0, __values(statsattributes)), statsattributes_1_1 = statsattributes_1.next(); !statsattributes_1_1.done; statsattributes_1_1 = statsattributes_1.next()) {
                    var attr = statsattributes_1_1.value;
                    var total = stats[attr].reduce(add);
                    if (total) {
                        var value = stats[attr][0] / total;
                        var accessor = "".concat(attr, "Ratio");
                        var fixedValue = parseFloat(value.toFixed(2));
                        stats[accessor] = fixedValue;
                        participating.set(participantId, true);
                        if (!ratio.has(accessor))
                            ratio.set(accessor, []);
                        (_l = ratio.get(accessor)) === null || _l === void 0 ? void 0 : _l.push(fixedValue);
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (statsattributes_1_1 && !statsattributes_1_1.done && (_e = statsattributes_1.return)) _e.call(statsattributes_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
            try {
                for (var competitivenessAttributes_1 = (e_5 = void 0, __values(competitivenessAttributes)), competitivenessAttributes_1_1 = competitivenessAttributes_1.next(); !competitivenessAttributes_1_1.done; competitivenessAttributes_1_1 = competitivenessAttributes_1.next()) {
                    var attr = competitivenessAttributes_1_1.value;
                    var total = (_o = (_m = stats.competitiveness) === null || _m === void 0 ? void 0 : _m[attr]) === null || _o === void 0 ? void 0 : _o.reduce(add);
                    if (total) {
                        var value = stats.competitiveness[attr][0] / total;
                        var accessor = "".concat(attr, "Ratio");
                        var fixedValue = parseFloat(value.toFixed(2));
                        stats[accessor] = fixedValue;
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (competitivenessAttributes_1_1 && !competitivenessAttributes_1_1.done && (_f = competitivenessAttributes_1.return)) _f.call(competitivenessAttributes_1);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_r && !_r.done && (_d = _q.return)) _d.call(_q);
        }
        finally { if (e_3) throw e_3.error; }
    }
    if (!teamParticipantId) {
        var highLowSort = function (a, b) { return b - a; };
        try {
            for (var _t = __values(participantStats.values()), _u = _t.next(); !_u.done; _u = _t.next()) {
                var stats = _u.value;
                try {
                    for (var statsattributes_2 = (e_7 = void 0, __values(statsattributes)), statsattributes_2_1 = statsattributes_2.next(); !statsattributes_2_1.done; statsattributes_2_1 = statsattributes_2.next()) {
                        var attr = statsattributes_2_1.value;
                        // now rank each team by their ratio on each attribute
                        var accessor = "".concat(attr, "Ratio");
                        if (typeof stats[accessor] === 'number') {
                            var index = (_p = ratio.get(accessor)) === null || _p === void 0 ? void 0 : _p.sort(highLowSort).indexOf(stats[accessor]);
                            if (typeof index === 'number' && index >= 0) {
                                var rankAccessor = "".concat(attr, "Rank");
                                stats[rankAccessor] = index + 1;
                            }
                        }
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (statsattributes_2_1 && !statsattributes_2_1.done && (_h = statsattributes_2.return)) _h.call(statsattributes_2);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_u && !_u.done && (_g = _t.return)) _g.call(_t);
            }
            finally { if (e_6) throw e_6.error; }
        }
    }
    var result = __assign({ relevantMatchUps: relevantMatchUps }, SUCCESS);
    if (teamParticipantId) {
        result.teamStats = participantStats.get(teamParticipantId);
        if (opponentParticipantId)
            result.opponentStats = participantStats.get(opponentParticipantId);
    }
    else {
        result.participatingTeamsCount = participating.size;
    }
    result.allParticipantStats = __spreadArray([], __read(participantStats.values()), false);
    return result;
}

function getAvgWTN(_a) {
    var eventType = _a.eventType, matchUps = _a.matchUps, eventId = _a.eventId, drawId = _a.drawId;
    var matchUpFormatCounts = {};
    var countMatchUpFormat = function (params) {
        var matchUpFormat = params === null || params === void 0 ? void 0 : params.matchUpFormat;
        if (!matchUpFormat)
            return;
        if (!matchUpFormatCounts[matchUpFormat])
            matchUpFormatCounts[matchUpFormat] = 0;
        matchUpFormatCounts[matchUpFormat] += 1;
    };
    var participantsMap = matchUps
        .filter(function (matchUp) {
        return eventId ? matchUp.eventId === eventId : matchUp.drawId === drawId;
    })
        .reduce(function (participants, matchUp) {
        var _a;
        countMatchUpFormat(matchUp);
        ((_a = matchUp.sides) !== null && _a !== void 0 ? _a : [])
            .flatMap(function (side) {
            var _a;
            return (((_a = side === null || side === void 0 ? void 0 : side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipants) || [side === null || side === void 0 ? void 0 : side.participant]).filter(Boolean);
        })
            .forEach(function (participant) {
            return (participants[participant.participantId] = participant);
        });
        return participants;
    }, {});
    var eventParticipants = Object.values(participantsMap);
    var wtnRatings = eventParticipants
        .map(function (participant) { return getDetailsWTN({ participant: participant, eventType: eventType }); })
        .filter(function (_a) {
        var wtnRating = _a.wtnRating;
        return wtnRating;
    });
    var pctNoRating = ((eventParticipants.length - wtnRatings.length) /
        eventParticipants.length) *
        100;
    var wtnTotals = wtnRatings.reduce(function (totals, wtnDetails) {
        var wtnRating = wtnDetails.wtnRating, confidence = wtnDetails.confidence;
        totals.totalWTN += wtnRating;
        totals.totalConfidence += confidence;
        return totals;
    }, { totalWTN: 0, totalConfidence: 0 });
    var avgWTN = (wtnRatings === null || wtnRatings === void 0 ? void 0 : wtnRatings.length)
        ? wtnTotals.totalWTN / wtnRatings.length
        : 0;
    var avgConfidence = (wtnRatings === null || wtnRatings === void 0 ? void 0 : wtnRatings.length)
        ? wtnTotals.totalConfidence / wtnRatings.length
        : 0;
    var counts = Object.values(matchUpFormatCounts);
    var matchUpsCount = counts.reduce(function (p, c) {
        return p + (c || 0);
    }, 0);
    return {
        matchUpFormatCounts: matchUpFormatCounts,
        matchUpsCount: matchUpsCount,
        avgConfidence: avgConfidence,
        pctNoRating: pctNoRating,
        avgWTN: avgWTN,
    };
}

function getStructureReports(_a) {
    var _b, _c;
    var _d = _a.firstFlightOnly, firstFlightOnly = _d === void 0 ? true : _d, extensionProfiles = _a.extensionProfiles, tournamentRecord = _a.tournamentRecord;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_ID };
    var eventStructureReports = {};
    var extensionValues = Object.assign.apply(Object, __spreadArray([{}], __read((extensionProfiles !== null && extensionProfiles !== void 0 ? extensionProfiles : []).map(function (_a) {
        var _b;
        var _c, _d, _e;
        var name = _a.name, label = _a.label, accessor = _a.accessor;
        var element = (_d = (_c = findExtension({
            element: tournamentRecord,
            name: name,
        })) === null || _c === void 0 ? void 0 : _c.extension) === null || _d === void 0 ? void 0 : _d.value;
        var value = accessor
            ? (_e = getAccessorValue({ element: element, accessor: accessor })) === null || _e === void 0 ? void 0 : _e.value
            : element;
        return _b = {}, _b[label || name] = value, _b;
    })), false));
    var tournamentId = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId;
    var participantsProfile = { withScaleValues: true };
    var matchUps = (_b = allTournamentMatchUps({
        participantsProfile: participantsProfile,
        tournamentRecord: tournamentRecord,
    }).matchUps) !== null && _b !== void 0 ? _b : [];
    var getSeedingBasis = function (timeItems) {
        var _a, _b;
        var timeItem = (_a = getTimeItem({
            itemType: ADD_SCALE_ITEMS,
            itemSubTypes: [SEEDING$1],
            element: { timeItems: timeItems },
        })) === null || _a === void 0 ? void 0 : _a.timeItem;
        return (_b = timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemValue) === null || _b === void 0 ? void 0 : _b.scaleBasis;
    };
    var tournamentStructureData = (_c = tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.events) === null || _c === void 0 ? void 0 : _c.flatMap(function (_a) {
        var _b, _c, _d, _e;
        var eventTimeItems = _a.timeItems, _f = _a.drawDefinitions, drawDefinitions = _f === void 0 ? [] : _f, extensions = _a.extensions, eventType = _a.eventType, eventId = _a.eventId, category = _a.category;
        var flightProfile = extensions === null || extensions === void 0 ? void 0 : extensions.find(function (x) { return x.name === FLIGHT_PROFILE; });
        var flightNumbers = (_c = (_b = flightProfile === null || flightProfile === void 0 ? void 0 : flightProfile.value) === null || _b === void 0 ? void 0 : _b.flights) === null || _c === void 0 ? void 0 : _c.map(function (flight) {
            var _a;
            return (_a = {},
                _a[flight.drawId] = flight.flightNumber,
                _a);
        });
        var flightMap = flightNumbers && Object.assign.apply(Object, __spreadArray([{}], __read(flightNumbers), false));
        var drawDeletionsCount = ((_e = (_d = extensions === null || extensions === void 0 ? void 0 : extensions.find(function (x) { return x.name === DRAW_DELETIONS; })) === null || _d === void 0 ? void 0 : _d.value) === null || _e === void 0 ? void 0 : _e.length) || 0;
        var mapValues = Object.values(flightMap);
        var minFlightNumber = flightMap && Math.min.apply(Math, __spreadArray([], __read(mapValues), false));
        var eventSeedingBasis = getSeedingBasis(eventTimeItems);
        eventStructureReports[eventId] = {
            totalPositionManipulations: 0,
            maxPositionManipulations: 0,
            generatedDrawsCount: 0,
            drawDeletionsCount: drawDeletionsCount,
            seedingBasis: eventSeedingBasis
                ? JSON.stringify(eventSeedingBasis)
                : undefined,
            tournamentId: tournamentId,
            eventId: eventId,
        };
        return (
        // check whether to only pull data from initial flights & ignore all other flights
        drawDefinitions
            .filter(function (d) {
            return !firstFlightOnly ||
                !flightNumbers ||
                flightMap[d.drawId] === minFlightNumber;
        })
            .flatMap(function (dd) {
            var drawMatchUpFormat = dd.matchUpFormat, drawTieFormat = dd.tieFormat, drawTimeItems = dd.timeItems, extensions = dd.extensions, structures = dd.structures, drawType = dd.drawType, drawId = dd.drawId;
            var _a = getAvgWTN({
                eventType: eventType,
                matchUps: matchUps,
                drawId: drawId,
            }), matchUpFormatCounts = _a.matchUpFormatCounts, matchUpsCount = _a.matchUpsCount, avgConfidence = _a.avgConfidence, pctNoRating = _a.pctNoRating, avgWTN = _a.avgWTN;
            var seedingBasis = getSeedingBasis(drawTimeItems) || eventSeedingBasis;
            var positionManipulations = getPositionManipulations({
                extensions: extensions,
            });
            var manipulationsCount = (positionManipulations === null || positionManipulations === void 0 ? void 0 : positionManipulations.length) || 0;
            eventStructureReports[eventId].totalPositionManipulations +=
                manipulationsCount;
            eventStructureReports[eventId].generatedDrawsCount += 1;
            if (manipulationsCount >
                eventStructureReports[eventId].maxPositionManipulations)
                eventStructureReports[eventId].maxPositionManipulations =
                    manipulationsCount;
            return structures === null || structures === void 0 ? void 0 : structures.filter(function (s) {
                return s.stageSequence === 1 &&
                    [QUALIFYING, MAIN, CONSOLATION, PLAY_OFF].includes(s.stage);
            }).map(function (s) {
                var _a, _b;
                var finalMatchUp = [MAIN, PLAY_OFF].includes(s.stage)
                    ? matchUps.find(function (matchUp) {
                        return matchUp.structureId === s.structureId &&
                            matchUp.finishingRound === 1 &&
                            matchUp.winningSide;
                    })
                    : undefined;
                var winningSide = (_a = finalMatchUp === null || finalMatchUp === void 0 ? void 0 : finalMatchUp.sides) === null || _a === void 0 ? void 0 : _a.find(function (side) { return side.sideNumber === finalMatchUp.winningSide; });
                var winningParticipant = winningSide === null || winningSide === void 0 ? void 0 : winningSide.participant;
                var winningTeamId = (winningParticipant === null || winningParticipant === void 0 ? void 0 : winningParticipant.participantType) === TEAM_PARTICIPANT &&
                    winningParticipant.participantId;
                var individualParticipants = (winningParticipant === null || winningParticipant === void 0 ? void 0 : winningParticipant.participantType) === PAIR
                    ? winningParticipant.individualParticipants
                    : [];
                var winningPersonWTN = getDetailsWTN({
                    participant: (individualParticipants === null || individualParticipants === void 0 ? void 0 : individualParticipants[0]) || winningParticipant,
                    eventType: eventType,
                });
                var _c = winningPersonWTN || {}, winningPersonId = _c.personId, winningPersonOtherId = _c.personOtherId, winningPersonTennisId = _c.tennisId, confidence1 = _c.confidence, wtnRating1 = _c.wtnRating;
                var winningPerson2WTN = getDetailsWTN({
                    participant: individualParticipants === null || individualParticipants === void 0 ? void 0 : individualParticipants[1],
                    eventType: eventType,
                });
                var _d = winningPerson2WTN || {}, winningPerson2Id = _d.personId, winningPerson2OtherId = _d.personOtherId, winningPerson2TennisId = _d.tennisId, confidence2 = _d.confidence, wtnRating2 = _d.wtnRating;
                var _e = category !== null && category !== void 0 ? category : {}, ageCategoryCode = _e.ageCategoryCode, categoryName = _e.categoryName, subType = _e.subType;
                var matchUpFormat = s.matchUpFormat || drawMatchUpFormat;
                var matchUpsInitialFormat = matchUpFormatCounts[matchUpFormat] || 0;
                var pctInitialMatchUpFormat = (matchUpsInitialFormat / matchUpsCount) * 100;
                var _f = getTieFormatDesc(drawTieFormat), drawTieFormatName = _f.tieFormatName, drawTieFormatDesc = _f.tieFormatDesc;
                var _g = getTieFormatDesc(s.tieFormat), structureTieFormatName = _g.tieFormatName, structureTieFormatDesc = _g.tieFormatDesc;
                var equivalentTieFormatDesc = drawTieFormatDesc === structureTieFormatDesc;
                var tieFormatName = !equivalentTieFormatDesc && structureTieFormatName;
                var tieFormatDesc = s.tieFormat &&
                    !equivalentTieFormatDesc &&
                    structureTieFormatDesc;
                var manipulations = ((_b = positionManipulations === null || positionManipulations === void 0 ? void 0 : positionManipulations.filter(function (action) { return action.structureId === s.structureId; })) === null || _b === void 0 ? void 0 : _b.length) || 0;
                return __assign(__assign({}, extensionValues), { tournamentId: tournamentId, eventId: eventId, structureId: s.structureId, drawId: drawId, eventType: eventType, category: subType, categoryName: categoryName, ageCategoryCode: ageCategoryCode, flightNumber: flightMap[drawId], drawType: drawType, stage: s.stage, seedingBasis: seedingBasis
                        ? JSON.stringify(seedingBasis)
                        : undefined, winningPersonId: winningPersonId, winningPersonOtherId: winningPersonOtherId, winningPersonTennisId: winningPersonTennisId, winningPersonWTNrating: wtnRating1, winningPersonWTNconfidence: confidence1, winningPerson2Id: winningPerson2Id, winningPerson2OtherId: winningPerson2OtherId, winningPerson2TennisId: winningPerson2TennisId, winningPerson2WTNrating: wtnRating2, winningPerson2WTNconfidence: confidence2, winningTeamId: winningTeamId, positionManipulations: manipulations, pctNoRating: pctNoRating, matchUpFormat: matchUpFormat, pctInitialMatchUpFormat: pctInitialMatchUpFormat, matchUpsCount: matchUpsCount, drawTieFormatName: drawTieFormatName, drawTieFormatDesc: drawTieFormatDesc, tieFormatName: tieFormatName, tieFormatDesc: tieFormatDesc, avgConfidence: avgConfidence, avgWTN: avgWTN });
            });
        }));
    });
    return {
        eventStructureReports: Object.values(eventStructureReports),
        structureReports: tournamentStructureData,
    };
}
function getPositionManipulations(_a) {
    var _b, _c;
    var extensions = _a.extensions;
    return (_c = (_b = extensions === null || extensions === void 0 ? void 0 : extensions.find(function (_a) {
        var name = _a.name;
        return name === AUDIT_POSITION_ACTIONS;
    })) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.slice(1);
}

var reportGovernor = {
    getStructureReports: getStructureReports,
    getEntryStatusReports: getEntryStatusReports,
    getParticipantStats: getParticipantStats,
};

function generateTimeCode(index) {
    if (index === void 0) { index = 0; }
    var uidate = new Date();
    uidate.setHours(uidate.getHours() + index);
    return uidate.getTime().toString(36).slice(-6).toUpperCase();
}

// check whether there is a request for the date with overlapping times
// extend startTime/endTime rather than creating multiple
// ... only pertains to { requestType: DO_NOT_SCHEDULE }
function mergePersonRequests(_a) {
    var e_1, _b;
    var personRequests = _a.personRequests, personId = _a.personId, requests = _a.requests;
    if (!personRequests[personId])
        personRequests[personId] = [];
    var filteredRequests = requests
        .filter(function (_a) {
        var requestType = _a.requestType;
        return requestType;
    })
        .map(function (request) {
        var date = request.date, startTime = request.startTime, endTime = request.endTime;
        // validate requestType
        if (request.requestType === DO_NOT_SCHEDULE) {
            date = extractDate(date);
            startTime = extractTime(startTime);
            endTime = extractTime(endTime);
            if (date && startTime && endTime) {
                return { date: date, startTime: startTime, endTime: endTime, requestType: request.requestType };
            }
        }
        return request;
    })
        .filter(Boolean);
    try {
        // Do not add any request that is missing requestType
        for (var filteredRequests_1 = __values(filteredRequests), filteredRequests_1_1 = filteredRequests_1.next(); !filteredRequests_1_1.done; filteredRequests_1_1 = filteredRequests_1.next()) {
            var request = filteredRequests_1_1.value;
            request.requestId = generateTimeCode();
            personRequests[personId].push(request);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (filteredRequests_1_1 && !filteredRequests_1_1.done && (_b = filteredRequests_1.return)) _b.call(filteredRequests_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { mergeCount: filteredRequests.length };
}

function savePersonRequests(params) {
    var _a, e_1, _b, e_2, _c;
    var _d;
    var tournamentRecords = params.tournamentRecords, personRequests = params.personRequests;
    var paramsCheck = checkRequiredParameters(params, [(_a = {}, _a[TOURNAMENT_RECORDS] = true, _a)]);
    if (paramsCheck.error)
        return paramsCheck;
    if (!personRequests)
        return __assign({}, SUCCESS);
    var tournaments = Object.values(tournamentRecords);
    try {
        for (var tournaments_1 = __values(tournaments), tournaments_1_1 = tournaments_1.next(); !tournaments_1_1.done; tournaments_1_1 = tournaments_1.next()) {
            var tournamentRecord = tournaments_1_1.value;
            var tournamentParticipants = (_d = tournamentRecord.participants) !== null && _d !== void 0 ? _d : [];
            var relevantPersonRequests = [];
            try {
                for (var _e = (e_2 = void 0, __values(Object.keys(personRequests))), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var personId = _f.value;
                    if (findParticipant({ tournamentParticipants: tournamentParticipants, personId: personId })) {
                        var requests = personRequests[personId];
                        if (requests.length)
                            relevantPersonRequests.push({ personId: personId, requests: requests });
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            if (Object.keys(relevantPersonRequests).length) {
                var extension = {
                    value: relevantPersonRequests,
                    name: PERSON_REQUESTS,
                };
                addExtension({ element: tournamentRecord, extension: extension });
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (tournaments_1_1 && !tournaments_1_1.done && (_b = tournaments_1.return)) _b.call(tournaments_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}

// can be used to both add and remove requests
// requests which don't have existing requestId will be added
// requests which don't have requestType will be removed
function modifyPersonRequests(params) {
    var _a, _b, e_1, _c;
    var tournamentRecords = params.tournamentRecords, requests = params.requests, personId = params.personId;
    var paramsCheck = checkRequiredParameters(params, [
        (_a = {}, _a[TOURNAMENT_RECORDS] = true, _a),
        (_b = { requests: true }, _b[OF_TYPE] = ARRAY, _b[INVALID] = INVALID_VALUES, _b),
    ]);
    if (paramsCheck.error)
        return paramsCheck;
    var requestIds = requests.map(function (_a) {
        var requestId = _a.requestId;
        return requestId;
    }).filter(Boolean);
    var personRequests = getPersonRequests({ tournamentRecords: tournamentRecords }).personRequests;
    var modifyRequests = function (personId) {
        if (personRequests) {
            personRequests[personId] = personRequests[personId]
                .map(function (request) {
                // if requestId not in requestIds then return unmodified
                if (!requestIds.includes(request.requestId))
                    return request;
                // find the updatedRequest
                var modification = requests.find(function (updatedRequest) { return updatedRequest.requestId === request.requestId; });
                // FEATURE: returning an updatedRequest without a requestType will remove it
                if (!modification.requestType)
                    return;
                return Object.assign(request, modification);
            })
                .filter(Boolean);
        }
    };
    if (personId && (personRequests === null || personRequests === void 0 ? void 0 : personRequests[personId])) {
        modifyRequests(personId);
    }
    else if (personRequests) {
        try {
            for (var _d = __values(Object.keys(personRequests)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var personId_1 = _e.value;
                modifyRequests(personId_1);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    var newRequests = requests.filter(function (request) { return !request.requestId; });
    if (newRequests.length) {
        mergePersonRequests({ personRequests: personRequests, personId: personId, requests: newRequests });
    }
    return savePersonRequests({ tournamentRecords: tournamentRecords, personRequests: personRequests });
}

function removePersonRequests(params) {
    var _a, e_1, _b;
    var tournamentRecords = params.tournamentRecords, requestType = params.requestType, requestId = params.requestId, personId = params.personId, date = params.date;
    var paramsCheck = checkRequiredParameters(params, [
        (_a = {}, _a[TOURNAMENT_RECORDS] = true, _a),
    ]);
    if (paramsCheck.error)
        return paramsCheck;
    var personRequests = getPersonRequests({ tournamentRecords: tournamentRecords }).personRequests;
    var filterRequests = function (personId) {
        var _a;
        if (personRequests) {
            personRequests[personId] = personRequests[personId].filter(function (request) {
                return ((!requestType || request.requestType !== requestType) &&
                    (!requestId || request.requestId !== requestId) &&
                    (!date || request.date !== date));
            });
            if (!((_a = personRequests === null || personRequests === void 0 ? void 0 : personRequests[personId]) === null || _a === void 0 ? void 0 : _a.length))
                delete personRequests[personId];
        }
    };
    var removeAll = !requestType && !requestId && !personId && !date;
    if (!removeAll) {
        if (personId && (personRequests === null || personRequests === void 0 ? void 0 : personRequests[personId])) {
            filterRequests(personId);
        }
        else if (personRequests) {
            try {
                for (var _c = __values(Object.keys(personRequests)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var personId_1 = _d.value;
                    filterRequests(personId_1);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
    if (removeAll || !personRequests || !Object.keys(personRequests).length) {
        return removeExtension({
            name: PERSON_REQUESTS,
            tournamentRecords: tournamentRecords,
            discover: true,
        });
    }
    else {
        return savePersonRequests({ tournamentRecords: tournamentRecords, personRequests: personRequests });
    }
}

function addPersonRequests(params) {
    var _a, _b;
    var tournamentRecords = params.tournamentRecords, personId = params.personId, requests = params.requests;
    var paramsCheck = checkRequiredParameters(params, [
        (_a = {}, _a[TOURNAMENT_RECORDS] = true, _a[PERSON_ID] = true, _a),
        (_b = { requests: true }, _b[OF_TYPE] = ARRAY, _b[INVALID] = INVALID_VALUES, _b),
    ]);
    if (paramsCheck.error)
        return paramsCheck;
    var personRequests = getPersonRequests({ tournamentRecords: tournamentRecords }).personRequests;
    var mergeCount = mergePersonRequests({
        personRequests: personRequests,
        personId: personId,
        requests: requests,
    }).mergeCount;
    if (mergeCount && personRequests) {
        return savePersonRequests({ tournamentRecords: tournamentRecords, personRequests: personRequests });
    }
    else {
        return { error: INVALID_VALUES };
    }
}

function calculateScheduleTimes(_a) {
    var _b, _c;
    var _d = _a.calculateStartTimeFromCourts, calculateStartTimeFromCourts = _d === void 0 ? true : _d, _e = _a.defaultRecoveryMinutes, defaultRecoveryMinutes = _e === void 0 ? 0 : _e, _f = _a.averageMatchUpMinutes, averageMatchUpMinutes = _f === void 0 ? 90 : _f, remainingScheduleTimes = _a.remainingScheduleTimes, clearScheduleDates = _a.clearScheduleDates, tournamentRecords = _a.tournamentRecords, periodLength = _a.periodLength, scheduleDate = _a.scheduleDate, startTime = _a.startTime, venueIds = _a.venueIds, endTime = _a.endTime;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    periodLength =
        periodLength !== null && periodLength !== void 0 ? periodLength : calculatePeriodLength({
            recoveryMinutes: defaultRecoveryMinutes,
            averageMatchUpMinutes: averageMatchUpMinutes,
        });
    var _g = getVenuesAndCourts({
        dates: [scheduleDate],
        ignoreDisabled: true,
        tournamentRecords: tournamentRecords,
    }), allCourts = _g.courts, venues = _g.venues;
    var courts = allCourts === null || allCourts === void 0 ? void 0 : allCourts.filter(function (court) { return !venueIds || venueIds.includes(court.venueId); });
    if (!startTime) {
        startTime = courts === null || courts === void 0 ? void 0 : courts.reduce(function (minStartTime, court) {
            var _a, _b;
            var dateAvailability = (_a = court.dateAvailability) === null || _a === void 0 ? void 0 : _a.find(
            // if no date is specified consider it to be default for all tournament dates
            function (availability) {
                return !availability.date || sameDay(scheduleDate, availability.date);
            });
            var comparisonStartTime = (_b = dateAvailability === null || dateAvailability === void 0 ? void 0 : dateAvailability.startTime) !== null && _b !== void 0 ? _b : court.startTime;
            return comparisonStartTime &&
                (!minStartTime ||
                    timeStringMinutes(comparisonStartTime) <
                        timeStringMinutes(minStartTime))
                ? comparisonStartTime
                : minStartTime;
        }, undefined);
    }
    if (!endTime) {
        endTime = courts === null || courts === void 0 ? void 0 : courts.reduce(function (maxEndTime, court) {
            var _a, _b;
            var dateAvailability = (_a = court.dateAvailability) === null || _a === void 0 ? void 0 : _a.find(
            // if no date is specified consider it to be default for all tournament dates
            function (availability) {
                return !availability.date || sameDay(scheduleDate, availability.date);
            });
            var comparisonEndTime = (_b = dateAvailability === null || dateAvailability === void 0 ? void 0 : dateAvailability.endTime) !== null && _b !== void 0 ? _b : court.endTime;
            return comparisonEndTime &&
                (!maxEndTime ||
                    timeStringMinutes(comparisonEndTime) > timeStringMinutes(maxEndTime))
                ? comparisonEndTime
                : maxEndTime;
        }, undefined);
    }
    // get a mapping of eventIds to category details
    var tournaments = Object.values(tournamentRecords);
    var eventDetails = Object.assign.apply(Object, __spreadArray([{}], __read(tournaments
        .map(function (tournamentRecord) {
        var _a;
        return ((_a = tournamentRecord.events) !== null && _a !== void 0 ? _a : []).map(function (event) {
            var _a;
            var scheduleTiming = getScheduleTiming({
                tournamentRecord: tournamentRecord,
                event: event,
            }).scheduleTiming;
            return _a = {},
                _a[event.eventId] = { event: event, scheduleTiming: scheduleTiming },
                _a;
        });
    })
        .flat()), false));
    // Get an array of all matchUps scheduled for the date
    // some of them may have courts assigned and some may only have venueIds
    // need to reduce courts available for a given time period by the number of matchUps scheduled at a given venue
    var matchUpFilters = { scheduledDate: scheduleDate, venueIds: venueIds };
    var matchUpsWithSchedule = competitionScheduleMatchUps({
        sortDateMatchUps: false, // unnecessary for extracting bookings; reduce processing overhead;
        tournamentRecords: tournamentRecords,
        matchUpFilters: matchUpFilters,
    });
    var dateMatchUps = (_b = matchUpsWithSchedule === null || matchUpsWithSchedule === void 0 ? void 0 : matchUpsWithSchedule.dateMatchUps) !== null && _b !== void 0 ? _b : [];
    var completedMatchUps = (_c = matchUpsWithSchedule === null || matchUpsWithSchedule === void 0 ? void 0 : matchUpsWithSchedule.completedMatchUps) !== null && _c !== void 0 ? _c : [];
    var relevantMatchUps = [];
    relevantMatchUps.push.apply(relevantMatchUps, __spreadArray([], __read(dateMatchUps), false));
    relevantMatchUps.push.apply(relevantMatchUps, __spreadArray([], __read(completedMatchUps), false));
    var defaultTiming = {
        averageTimes: [{ minutes: { default: averageMatchUpMinutes } }],
        recoveryTimes: [{ minutes: { default: defaultRecoveryMinutes } }],
    };
    var bookings = relevantMatchUps === null || relevantMatchUps === void 0 ? void 0 : relevantMatchUps.map(function (_a) {
        var eventId = _a.eventId, schedule = _a.schedule, matchUpFormat = _a.matchUpFormat;
        var _b = eventDetails[eventId], event = _b.event, scheduleTiming = _b.scheduleTiming;
        var eventType = event === null || event === void 0 ? void 0 : event.eventType;
        var timingDetails = __assign(__assign({}, scheduleTiming), { defaultTiming: defaultTiming, matchUpFormat: matchUpFormat });
        var _c = matchUpFormatTimes({
            eventType: eventType,
            timingDetails: timingDetails,
        }), averageMinutes = _c.averageMinutes, recoveryMinutes = _c.recoveryMinutes;
        var courtId = schedule.courtId, venueId = schedule.venueId;
        var startTime = extractTime(schedule.scheduledTime);
        var endTime = addMinutesToTimeString(startTime, averageMinutes);
        return {
            recoveryMinutes: recoveryMinutes,
            averageMinutes: averageMinutes,
            periodLength: periodLength,
            startTime: startTime,
            endTime: endTime,
            courtId: courtId,
            venueId: venueId,
        };
    });
    var timingParameters = {
        calculateStartTimeFromCourts: calculateStartTimeFromCourts,
        remainingScheduleTimes: remainingScheduleTimes,
        averageMatchUpMinutes: averageMatchUpMinutes,
        date: scheduleDate,
        clearScheduleDates: clearScheduleDates,
        periodLength: periodLength,
        startTime: startTime,
        endTime: endTime,
        bookings: bookings,
        courts: courts,
    };
    var scheduleTimes = getScheduleTimes(timingParameters).scheduleTimes;
    // if a single venue specified, or only one venue available, return venueId
    var venueId = ((venueIds === null || venueIds === void 0 ? void 0 : venueIds.length) === 1 && venueIds[0]) ||
        ((venues === null || venues === void 0 ? void 0 : venues.length) === 1 && venues[0].venueId) ||
        undefined;
    var dateScheduledMatchUpIds = relevantMatchUps.map(getMatchUpId);
    return { venueId: venueId, scheduleTimes: scheduleTimes, dateScheduledMatchUpIds: dateScheduledMatchUpIds };
}

function modifyMatchUpFormatTiming(params) {
    var _a, e_1, _b;
    var _c, _d;
    var matchUpFormat = params.matchUpFormat, recoveryTimes = params.recoveryTimes, averageTimes = params.averageTimes, tournamentId = params.tournamentId, eventId = params.eventId;
    var tournamentRecords = (_d = (_c = params === null || params === void 0 ? void 0 : params.tournamentRecords) !== null && _c !== void 0 ? _c : ((params === null || params === void 0 ? void 0 : params.tournamentRecord) && (_a = {},
        _a[params.tournamentRecord.tournamentId] = params.tournamentRecord,
        _a))) !== null && _d !== void 0 ? _d : {};
    if (!Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var tournamentIds = Object.keys(tournamentRecords).filter(function (currentTournamentId) {
        return !tournamentId || tournamentId === currentTournamentId;
    });
    if (tournamentId && !tournamentIds.includes(tournamentId))
        return { error: INVALID_VALUES };
    var eventModified;
    try {
        for (var tournamentIds_1 = __values(tournamentIds), tournamentIds_1_1 = tournamentIds_1.next(); !tournamentIds_1_1.done; tournamentIds_1_1 = tournamentIds_1.next()) {
            var currentTournamentId = tournamentIds_1_1.value;
            var tournamentRecord = tournamentRecords[currentTournamentId];
            var event_1 = findEvent({ tournamentRecord: tournamentRecord, eventId: eventId }).event;
            if (eventId && event_1)
                eventModified = true;
            var result = modifyTiming({
                tournamentRecord: tournamentRecord,
                event: event_1,
                matchUpFormat: matchUpFormat,
                averageTimes: averageTimes,
                recoveryTimes: recoveryTimes,
            });
            if (result.error)
                return result;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (tournamentIds_1_1 && !tournamentIds_1_1.done && (_b = tournamentIds_1.return)) _b.call(tournamentIds_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return !eventId || eventModified
        ? __assign({}, SUCCESS) : { error: EVENT_NOT_FOUND };
}
function modifyTiming(_a) {
    var tournamentRecord = _a.tournamentRecord, recoveryTimes = _a.recoveryTimes, matchUpFormat = _a.matchUpFormat, averageTimes = _a.averageTimes, event = _a.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (averageTimes && !Array.isArray(averageTimes))
        return { error: INVALID_VALUES };
    if (recoveryTimes && !Array.isArray(recoveryTimes))
        return { error: INVALID_VALUES };
    var name = SCHEDULE_TIMING;
    if (event) {
        var extension = findExtension({ element: event, name: name }).extension;
        var eventScheduling = (extension === null || extension === void 0 ? void 0 : extension.value) || {};
        var value = modifyScheduling(__assign(__assign({}, eventScheduling), { matchUpFormat: matchUpFormat, averageTimes: averageTimes, recoveryTimes: recoveryTimes }));
        addExtension({ element: event, extension: { name: name, value: value } });
    }
    else {
        var extension = findExtension({
            element: tournamentRecord,
            name: name,
        }).extension;
        var tournamentScheduling = (extension === null || extension === void 0 ? void 0 : extension.value) || {};
        var value = modifyScheduling(__assign(__assign({}, tournamentScheduling), { matchUpFormat: matchUpFormat, averageTimes: averageTimes, recoveryTimes: recoveryTimes }));
        addExtension({
            extension: { name: name, value: value },
            element: tournamentRecord,
        });
    }
    return __assign({}, SUCCESS);
}
function modifyScheduling(params) {
    var _a = params.matchUpRecoveryTimes, matchUpRecoveryTimes = _a === void 0 ? [] : _a, _b = params.matchUpAverageTimes, matchUpAverageTimes = _b === void 0 ? [] : _b, matchUpFormat = params.matchUpFormat;
    var formatAverageTimes = params.averageTimes, formatRecoveryTimes = params.recoveryTimes;
    // don't allow modification without categoryName
    formatAverageTimes = (formatAverageTimes || []).filter(function (averageTime) { var _a, _b; return ((_a = averageTime === null || averageTime === void 0 ? void 0 : averageTime.categoryNames) === null || _a === void 0 ? void 0 : _a.length) || ((_b = averageTime === null || averageTime === void 0 ? void 0 : averageTime.categoryTypes) === null || _b === void 0 ? void 0 : _b.length); });
    // if there are formatAverageTimes specified...
    var updatedMatchUpAverageTimes = (formatAverageTimes === null || formatAverageTimes === void 0 ? void 0 : formatAverageTimes.length) &&
        matchUpAverageTimes
            .map(function (definition) {
            var _a;
            // filter out any existing definitions for this matchUpFormat
            return (definition === null || definition === void 0 ? void 0 : definition.matchUpFormatCodes.includes(matchUpFormat))
                ? __assign(__assign({}, definition), { matchUpFormatCodes: (_a = definition.matchUpFormatCodes) === null || _a === void 0 ? void 0 : _a.filter(function (code) { return code !== matchUpFormat; }) }) : definition;
        })
            // filter out any definitions that no longer have matchUpFormatCodes
            .filter(function (_a) {
            var matchUpFormatCodes = _a.matchUpFormatCodes;
            return matchUpFormatCodes === null || matchUpFormatCodes === void 0 ? void 0 : matchUpFormatCodes.length;
        })
            .concat({
            matchUpFormatCodes: [matchUpFormat],
            averageTimes: formatAverageTimes,
        });
    // don't allow modification without categoryName
    formatRecoveryTimes = (formatRecoveryTimes || []).filter(function (recoveryTime) { var _a, _b; return ((_a = recoveryTime === null || recoveryTime === void 0 ? void 0 : recoveryTime.categoryNames) === null || _a === void 0 ? void 0 : _a.length) || ((_b = recoveryTime === null || recoveryTime === void 0 ? void 0 : recoveryTime.categoryTypes) === null || _b === void 0 ? void 0 : _b.length); });
    // if there are formatRecoveryTimes specified...
    var updatedMatchUpRecoveryTimes = (formatRecoveryTimes === null || formatRecoveryTimes === void 0 ? void 0 : formatRecoveryTimes.length) &&
        matchUpRecoveryTimes
            .map(function (definition) {
            var _a;
            // filter out any existing definitions for this matchUpFormat
            return (definition === null || definition === void 0 ? void 0 : definition.matchUpFormatCodes.includes(matchUpFormat))
                ? __assign(__assign({}, definition), { matchUpFormatCodes: (_a = definition.matchUpFormatCodes) === null || _a === void 0 ? void 0 : _a.filter(function (code) { return code !== matchUpFormat; }) }) : definition;
        })
            // filter out any definitions that no longer have matchUpFormatCodes OR averageTimes
            // recoveryTimes can be keyed to averageTimes instead of matchUpFormats...
            .filter(function (_a) {
            var matchUpFormatCodes = _a.matchUpFormatCodes, averageTimes = _a.averageTimes;
            return (matchUpFormatCodes === null || matchUpFormatCodes === void 0 ? void 0 : matchUpFormatCodes.length) || averageTimes;
        })
            .concat({
            matchUpFormatCodes: [matchUpFormat],
            recoveryTimes: formatRecoveryTimes,
        });
    return {
        matchUpAverageTimes: ((updatedMatchUpAverageTimes === null || updatedMatchUpAverageTimes === void 0 ? void 0 : updatedMatchUpAverageTimes.length) && updatedMatchUpAverageTimes) ||
            matchUpAverageTimes,
        matchUpRecoveryTimes: ((updatedMatchUpRecoveryTimes === null || updatedMatchUpRecoveryTimes === void 0 ? void 0 : updatedMatchUpRecoveryTimes.length) && updatedMatchUpRecoveryTimes) ||
            matchUpRecoveryTimes,
    };
}

function modifyEventMatchUpFormatTiming(params) {
    var _a, _b;
    var tournamentRecord = params.tournamentRecord, recoveryMinutes = params.recoveryMinutes, averageMinutes = params.averageMinutes, matchUpFormat = params.matchUpFormat, categoryType = params.categoryType, eventId = params.eventId, event = params.event;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!isValidMatchUpFormat({ matchUpFormat: matchUpFormat }))
        return { error: INVALID_VALUES };
    if (!event)
        return { error: MISSING_EVENT };
    var _c = getModifiedMatchUpFormatTiming({
        tournamentRecord: tournamentRecord,
        matchUpFormat: matchUpFormat,
        event: event,
    }), _d = _c.averageTimes, averageTimes = _d === void 0 ? [] : _d, _e = _c.recoveryTimes, recoveryTimes = _e === void 0 ? [] : _e;
    var category = event.category;
    var categoryName = (category === null || category === void 0 ? void 0 : category.categoryName) || (category === null || category === void 0 ? void 0 : category.ageCategoryCode) || (event === null || event === void 0 ? void 0 : event.eventId);
    var currentAverageTime = { categoryNames: [categoryName], minutes: {} };
    var currentRecoveryTime = { categoryNames: [categoryName], minutes: {} };
    var newTiming = function (timing) {
        var _a, _b;
        if ((_a = timing.categoryTypes) === null || _a === void 0 ? void 0 : _a.includes(categoryType)) {
            // TODO
            console.log('encountered:', { categoryType: categoryType });
        }
        if ((_b = timing.categoryNames) === null || _b === void 0 ? void 0 : _b.includes(categoryName)) {
            timing.categoryNames = timing.categoryNames.filter(function (c) { return c !== categoryName; });
            currentAverageTime = {
                minutes: timing.minutes,
                categoryNames: [categoryName],
            };
            if (!timing.categoryNames.length)
                return;
        }
        return timing;
    };
    var validAverageMinutes = averageMinutes && !isNaN(ensureInt(averageMinutes));
    var validRecoveryMinutes = recoveryMinutes && !isNaN(ensureInt(recoveryMinutes));
    var newAverageTimes = averageTimes
        .map(newTiming)
        .filter(function (f) { var _a; return (_a = f === null || f === void 0 ? void 0 : f.categoryNames) === null || _a === void 0 ? void 0 : _a.length; });
    var newRecoveryTimes = recoveryTimes
        .map(newTiming)
        .filter(function (f) { var _a; return (_a = f === null || f === void 0 ? void 0 : f.categoryNames) === null || _a === void 0 ? void 0 : _a.length; });
    if (validAverageMinutes) {
        Object.assign(currentAverageTime.minutes, (_a = {},
            _a[(event === null || event === void 0 ? void 0 : event.eventType) || SINGLES] = averageMinutes,
            _a));
        newAverageTimes.push(currentAverageTime);
    }
    if (validRecoveryMinutes) {
        Object.assign(currentRecoveryTime.minutes, (_b = {},
            _b[(event === null || event === void 0 ? void 0 : event.eventType) || SINGLES] = recoveryMinutes,
            _b));
        newRecoveryTimes.push(currentRecoveryTime);
    }
    if (!validAverageMinutes && !validRecoveryMinutes)
        return { error: INVALID_VALUES };
    return modifyMatchUpFormatTiming({
        averageTimes: validAverageMinutes && newAverageTimes,
        recoveryTimes: validRecoveryMinutes && newRecoveryTimes,
        tournamentRecord: tournamentRecord,
        matchUpFormat: matchUpFormat,
        eventId: eventId,
        event: event,
    });
}

function removeEventMatchUpFormatTiming(params) {
    var _a, _b, e_1, _c;
    if (params.event) {
        return removeTiming({ event: params.event });
    }
    else {
        if (params.tournamentRecord && !params.tournamentRecords) {
            params.tournamentRecords = (_a = {},
                _a[params.tournamentRecord.tournamentId] = params.tournamentRecord,
                _a);
        }
        var paramCheck = checkRequiredParameters(params, [(_b = {}, _b[TOURNAMENT_RECORDS] = true, _b[EVENT_ID] = true, _b)]);
        if (paramCheck.error)
            return paramCheck;
        var tournamentRecords = params.tournamentRecords, eventId = params.eventId;
        try {
            for (var _d = __values(Object.values(tournamentRecords !== null && tournamentRecords !== void 0 ? tournamentRecords : {})), _e = _d.next(); !_e.done; _e = _d.next()) {
                var tournamentRecord = _e.value;
                var event_1 = findEvent({ tournamentRecord: tournamentRecord, eventId: eventId }).event;
                if (event_1)
                    return removeTiming({ event: event_1 });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return { error: EVENT_NOT_FOUND };
}
function removeTiming(_a) {
    var event = _a.event;
    return removeEventExtension({ event: event, name: SCHEDULE_TIMING });
}

function removeMatchUpCourtAssignment(params) {
    var _a;
    var _b, _c;
    var paramsCheck = checkRequiredParameters(params, [(_a = {}, _a[TOURNAMENT_RECORDS] = true, _a)]);
    if (paramsCheck.error)
        return paramsCheck;
    var removePriorValues = params.removePriorValues, tournamentRecords = params.tournamentRecords, tournamentId = params.tournamentId, courtDayDate = params.courtDayDate, matchUpId = params.matchUpId, courtId = params.courtId, drawId = params.drawId;
    var tournamentRecord = tournamentRecords[tournamentId];
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var _d = findDrawDefinition$1({
        tournamentRecord: tournamentRecord,
        drawId: drawId,
    }), drawDefinition = _d.drawDefinition, event = _d.event;
    if (!drawDefinition)
        return { error: MISSING_DRAW_DEFINITION };
    var result = findDrawMatchUp({ drawDefinition: drawDefinition, event: event, matchUpId: matchUpId });
    if (result.error)
        return result;
    if (((_b = result === null || result === void 0 ? void 0 : result.matchUp) === null || _b === void 0 ? void 0 : _b.matchUpType) === TEAM_MATCHUP) {
        var allocatedCourts = latestVisibleTimeItemValue({
            timeItems: (_c = result.matchUp.timeItems) !== null && _c !== void 0 ? _c : [],
            itemType: ALLOCATE_COURTS,
        }).itemValue;
        var itemValue = courtId && allocatedCourts.filter(function (court) { return court.courtId !== courtId; });
        var timeItem = { itemType: ALLOCATE_COURTS, itemValue: itemValue };
        return addMatchUpTimeItem({
            duplicateValues: false,
            removePriorValues: removePriorValues,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            matchUpId: matchUpId,
            timeItem: timeItem,
        });
    }
    else {
        return assignMatchUpCourt({
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            courtDayDate: courtDayDate,
            courtId: '',
            matchUpId: matchUpId,
        });
    }
}

function proAutoSchedule(_a) {
    var scheduleCompletedMatchUps = _a.scheduleCompletedMatchUps, tournamentRecords = _a.tournamentRecords, scheduledDate = _a.scheduledDate, matchUps = _a.matchUps;
    if (!validMatchUps(matchUps))
        return { error: INVALID_VALUES };
    if (matchUps.some(function (_a) {
        var hasContext = _a.hasContext;
        return !hasContext;
    })) {
        return {
            info: 'matchUps must have { inContext: true, nextMatchUps: true }',
            error: MISSING_CONTEXT,
        };
    }
    var matchUpFilters = { localPerspective: true, scheduledDate: scheduledDate };
    var result = competitionScheduleMatchUps({
        courtCompletedMatchUps: true,
        withCourtGridRows: true,
        minCourtGridRows: 10,
        tournamentRecords: tournamentRecords,
        matchUpFilters: matchUpFilters,
    });
    if (result.error)
        return result;
    var rows = result.rows;
    var gridMatchUps = [];
    var getMatchUpParticipantIds = function (matchUp) {
        return [
            (matchUp.sides || []).map(function (side) {
                var _a;
                return [
                    side.participantId,
                    (_a = side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipantIds,
                ];
            }),
            (matchUp.potentialParticipants || [])
                .flat()
                .map(function (p) { return [p.participantId, p.individualParticipantIds]; }),
        ]
            .flat(Infinity)
            .filter(Boolean);
    };
    var gridRows = rows === null || rows === void 0 ? void 0 : rows.reduce(function (gridRows, row) {
        var matchUpIds = [], participantIds = [];
        Object.values(row).forEach(function (c) {
            if (isObject(c)) {
                if (c.matchUpId) {
                    matchUpIds.push(c.matchUpId);
                    gridMatchUps.push(c);
                }
                if (c.sides) {
                    var matchUpParticipantIds = getMatchUpParticipantIds(c);
                    participantIds.push.apply(participantIds, __spreadArray([], __read(matchUpParticipantIds), false));
                }
            }
        });
        var availableCourts = Object.values(row).filter(function (c) { return isObject(c) && !c.matchUpId; });
        return gridRows.concat({
            matchUpIds: matchUpIds,
            availableCourts: availableCourts,
            rowId: row.rowId,
            participantIds: participantIds,
        });
    }, []);
    matchUps
        .filter(function (_a) {
        var matchUpStatus = _a.matchUpStatus;
        return matchUpStatus &&
            matchUpStatus !== BYE &&
            (scheduleCompletedMatchUps ||
                !completedMatchUpStatuses.includes(matchUpStatus));
    })
        .sort(matchUpSort);
    var deps = getMatchUpDependencies({
        matchUps: matchUps.concat(gridMatchUps),
        includeParticipantDependencies: true,
        tournamentRecords: tournamentRecords,
    }).matchUpDependencies;
    var scheduled = [];
    var previousRowMatchUpIds = [];
    while (matchUps.length && gridRows.length) {
        var row = gridRows.shift();
        var unscheduledMatchUps = [];
        var _loop_1 = function () {
            var _b;
            var unscheduledMatchUpIds = matchUps
                .concat(unscheduledMatchUps)
                .map(function (m) { return m.matchUpId; });
            var matchUp = matchUps.shift();
            var matchUpId = matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpId;
            var linkedMatchUpIds = matchUpId &&
                deps[matchUpId].matchUpIds.concat(deps[matchUpId].dependentMatchUpIds);
            var unscheduledContainSource = matchUpId &&
                unscheduledMatchUpIds.some(function (id) {
                    return deps[matchUpId].matchUpIds.includes(id);
                });
            var previousIncludesDependent = matchUpId &&
                previousRowMatchUpIds.some(function (id) {
                    return deps[matchUpId].dependentMatchUpIds.includes(id);
                });
            var rowIncludesLinked = row.matchUpIds.some(function (id) {
                return linkedMatchUpIds.includes(id);
            });
            var participantIds = getMatchUpParticipantIds(matchUp);
            var rowContainsParticipants = row.participantIds.some(function (id) {
                return participantIds.includes(id);
            });
            if (matchUp &&
                !rowIncludesLinked &&
                !unscheduledContainSource &&
                !rowContainsParticipants &&
                !previousIncludesDependent) {
                var court = row.availableCourts.shift();
                Object.assign(matchUp.schedule, court.schedule);
                Object.assign(court, matchUp);
                scheduled.push(matchUp);
                (_b = row.participantIds).push.apply(_b, __spreadArray([], __read(participantIds), false));
                row.matchUpIds.push(matchUpId);
            }
            else if (matchUp) {
                unscheduledMatchUps.push(matchUp);
            }
        };
        while (matchUps.length && row.availableCourts.length) {
            _loop_1();
        }
        matchUps.push.apply(matchUps, __spreadArray([], __read(unscheduledMatchUps), false));
        previousRowMatchUpIds.push.apply(previousRowMatchUpIds, __spreadArray([], __read(row.matchUpIds), false));
    }
    var matchUpDetails = scheduled.map(function (_a) {
        var matchUpId = _a.matchUpId, tournamentId = _a.tournamentId, schedule = _a.schedule, drawId = _a.drawId;
        return ({
            tournamentId: tournamentId,
            matchUpId: matchUpId,
            drawId: drawId,
            schedule: __assign(__assign({}, schedule), { scheduledDate: scheduledDate }),
        });
    });
    result = bulkScheduleMatchUps({ tournamentRecords: tournamentRecords, matchUpDetails: matchUpDetails });
    var notScheduled = matchUps;
    return __assign(__assign({}, result), { scheduled: scheduled, notScheduled: notScheduled });
}

function bulkUpdateCourtAssignments(params) {
    var _a, _b;
    var courtDayDate = params.courtDayDate;
    var paramsCheck = checkRequiredParameters(params, [
        (_a = { courtAssignments: true }, _a[OF_TYPE] = ARRAY, _a[INVALID] = MISSING_VALUE, _a),
        (_b = {}, _b[TOURNAMENT_RECORDS] = true, _b),
    ]);
    if (paramsCheck.error)
        return paramsCheck;
    var tournamentMap = params.courtAssignments.reduce(function (tournamentMap, assignment) {
        var tournamentId = assignment.tournamentId;
        if (!tournamentMap[tournamentId])
            tournamentMap[tournamentId] = [];
        tournamentMap[tournamentId].push(assignment);
        return tournamentMap;
    }, {});
    var error;
    var tournamentIds = Object.keys(tournamentMap);
    tournamentIds.every(function (tournamentId) {
        var tournamentRecord = params[TOURNAMENT_RECORDS][tournamentId];
        if (!tournamentRecord) {
            error = { error: MISSING_TOURNAMENT_RECORD };
            return false;
        }
        var drawMap = tournamentMap[tournamentId].reduce(function (drawMap, assignment) {
            var drawId = assignment.drawId;
            if (!drawMap[drawId])
                drawMap[drawId] = [];
            drawMap[drawId].push(assignment);
            return drawMap;
        }, {});
        var drawIds = Object.keys(drawMap);
        drawIds.every(function (drawId) {
            var drawDefinition = findEvent({ tournamentRecord: tournamentRecord, drawId: drawId }).drawDefinition;
            if (!drawDefinition) {
                error = { error: MISSING_DRAW_DEFINITION };
                return false;
            }
            drawMap[drawId].every(function (assignment) {
                var matchUpId = assignment.matchUpId, courtId = assignment.courtId;
                var result = assignMatchUpCourt({
                    tournamentRecord: tournamentRecord,
                    drawDefinition: drawDefinition,
                    courtDayDate: courtDayDate,
                    matchUpId: matchUpId,
                    courtId: courtId,
                });
                if (result.success) {
                    return result === null || result === void 0 ? void 0 : result.success;
                }
                else {
                    error = { error: UNABLE_TO_ASSIGN_COURT };
                }
                return undefined;
            });
            return true;
        });
        return undefined;
    });
    return error || SUCCESS;
}

/**
 *
 * @param {object[]} tournamentRecords - provided by competitionEngine
 * @param {string[]} matchUpIds - matchUpIds to schedule
 * @param {string[]} venueIds - venueIds of venues where dateAvailability for courts is found
 * @param {string} scheduleDate - YYYY-MM-DD string representing day on which matchUps should be scheduled
 * @param {string} startTime - 00:00 - military time string
 * @param {string} endTime - 00:00 - military time string
 *
 * @param {number} periodLength - granularity of time blocks to consider, in minutes
 * @param {number} averageMatchUpMinutes - how long the expected matchUps are expected to last, in minutes, on average
 * @param {number} recoveryMinutes - time in minutes that should be alloted for participants to recover between matches
 * @param {object} matchUpDailyLimits - { SINGLES, DOUBLES, TOTAL } - maximum number of matches allowed per participant
 * @param {boolean} checkPotentialRequestConflicts - check personRequests when person is only potentially in matchUp being scheduled
 *
 * @returns scheduledMatchUpIds, individualParticipantProfiles
 */
function scheduleMatchUps(params) {
    var _a, _b, _c;
    var _d, _e, _f, _g;
    var tournamentRecords = params.tournamentRecords, _h = params.allDateMatchUpIds, allDateMatchUpIds = _h === void 0 ? [] : _h, _j = params.averageMatchUpMinutes, averageMatchUpMinutes = _j === void 0 ? 90 : _j, _k = params.recoveryMinutes, recoveryMinutes = _k === void 0 ? 0 : _k, recoveryMinutesMap = params.recoveryMinutesMap, // for matchUpIds batched by averageMatchUpMinutes this enables varying recoveryMinutes
    _l = params.matchUpPotentialParticipantIds, // for matchUpIds batched by averageMatchUpMinutes this enables varying recoveryMinutes
    matchUpPotentialParticipantIds = _l === void 0 ? {} : _l, _m = params.individualParticipantProfiles, individualParticipantProfiles = _m === void 0 ? {} : _m, _o = params.matchUpNotBeforeTimes, matchUpNotBeforeTimes = _o === void 0 ? {} : _o, _p = params.matchUpDailyLimits, matchUpDailyLimits = _p === void 0 ? {} : _p, _q = params.checkPotentialRequestConflicts, checkPotentialRequestConflicts = _q === void 0 ? true : _q, remainingScheduleTimes = params.remainingScheduleTimes, clearScheduleDates = params.clearScheduleDates, _r = params.periodLength, periodLength = _r === void 0 ? 30 : _r, scheduleDate = params.scheduleDate, matchUpIds = params.matchUpIds, venueIds = params.venueIds, startTime = params.startTime, endTime = params.endTime, dryRun = params.dryRun;
    var paramCheck = checkRequiredParameters(params, [
        (_a = {}, _a[TOURNAMENT_RECORDS] = true, _a[MATCHUP_IDS] = true, _a),
        (_b = {},
            _b[VALIDATE] = isValidDateString,
            _b[INVALID] = INVALID_DATE,
            _b[SCHEDULE_DATE] = true,
            _b),
        (_c = {},
            _c[VALIDATE] = function (value) { return !value || !isNaN(value); },
            _c[AVERAGE_MATCHUP_MINUTES] = false,
            _c[INVALID] = INVALID_VALUES,
            _c[RECOVERY_MINUTES] = false,
            _c[PERIOD_LENGTH] = false,
            _c),
    ]);
    if (paramCheck.error)
        return paramCheck;
    // if competitionMatchUps not provided as a parameter
    // scheduleMatchUpProfiles has already called processNextMatchUps for all
    var competitionMatchUps = (_e = (_d = params.competitionMatchUps) !== null && _d !== void 0 ? _d : allCompetitionMatchUps({
        nextMatchUps: true,
        tournamentRecords: tournamentRecords,
    }).matchUps) !== null && _e !== void 0 ? _e : [];
    var matchUpDependencies = (_f = params.matchUpDependencies) !== null && _f !== void 0 ? _f : getMatchUpDependencies({
        includeParticipantDependencies: true,
        matchUps: competitionMatchUps,
        tournamentRecords: tournamentRecords,
    }).matchUpDependencies;
    competitionMatchUps.forEach(function (matchUp) {
        var _a;
        if (((_a = matchUp.schedule) === null || _a === void 0 ? void 0 : _a.scheduledDate) && sameDay(scheduleDate, extractDate(matchUp.schedule.scheduledDate))) {
            processNextMatchUps({
                matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
                matchUpNotBeforeTimes: matchUpNotBeforeTimes,
                matchUp: matchUp,
            });
        }
    });
    // this must be done to preserve the order of matchUpIds
    var targetMatchUps = matchUpIds
        .map(function (matchUpId) { return competitionMatchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; }); })
        .filter(Boolean);
    // determines court availability taking into account already scheduled matchUps on the scheduleDate
    // optimization to pass already retrieved competitionMatchUps to avoid refetch (requires refactor)
    var _s = calculateScheduleTimes({
        tournamentRecords: tournamentRecords,
        remainingScheduleTimes: remainingScheduleTimes,
        startTime: extractTime(startTime),
        endTime: extractTime(endTime),
        scheduleDate: extractDate(scheduleDate),
        averageMatchUpMinutes: averageMatchUpMinutes,
        clearScheduleDates: clearScheduleDates,
        periodLength: periodLength,
        venueIds: venueIds,
    }), venueId = _s.venueId, scheduleTimes = _s.scheduleTimes, dateScheduledMatchUpIds = _s.dateScheduledMatchUpIds;
    var requestConflicts = {};
    var skippedScheduleTimes = [];
    var matchUpScheduleTimes = {};
    var recoveryTimeDeferred = {};
    var dependencyDeferred = {};
    // first build up a map of matchUpNotBeforeTimes and matchUpPotentialParticipantIds
    // based on already scheduled matchUps
    var dateScheduledMatchUps = competitionMatchUps.filter(function (_a) {
        var matchUpId = _a.matchUpId;
        return dateScheduledMatchUpIds === null || dateScheduledMatchUpIds === void 0 ? void 0 : dateScheduledMatchUpIds.includes(matchUpId);
    });
    dateScheduledMatchUps.forEach(function (matchUp) {
        var _a;
        modifyParticipantMatchUpsCount({
            matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
            individualParticipantProfiles: individualParticipantProfiles,
            matchUp: matchUp,
            value: 1,
        });
        var scheduleTime = (_a = matchUp.schedule) === null || _a === void 0 ? void 0 : _a.scheduledTime;
        if (scheduleTime) {
            matchUpScheduleTimes[matchUp.matchUpId] = scheduleTime;
            var mappedRecoveryMinutes = recoveryMinutesMap === null || recoveryMinutesMap === void 0 ? void 0 : recoveryMinutesMap[matchUp.matchUpId];
            updateTimeAfterRecovery({
                recoveryMinutes: mappedRecoveryMinutes || recoveryMinutes,
                matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
                individualParticipantProfiles: individualParticipantProfiles,
                matchUpNotBeforeTimes: matchUpNotBeforeTimes,
                averageMatchUpMinutes: averageMatchUpMinutes,
                matchUpDependencies: matchUpDependencies,
                scheduleTime: scheduleTime,
                matchUp: matchUp,
            });
        }
    });
    // matchUps are assumed to be in the desired order for scheduling
    var matchUpsToSchedule = targetMatchUps.filter(function (matchUp) {
        var alreadyScheduled = dateScheduledMatchUpIds === null || dateScheduledMatchUpIds === void 0 ? void 0 : dateScheduledMatchUpIds.includes(matchUp.matchUpId);
        var doNotSchedule = [BYE, DEFAULTED, COMPLETED$1, ABANDONED$1, RETIRED$1, WALKOVER$2].includes(matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpStatus);
        return !alreadyScheduled && !matchUp.winningSide && !doNotSchedule;
    });
    // for optimization, build up an object for each tournament and an array for each draw with target matchUps
    // keep track of matchUps counts per participant and don't add matchUps for participants beyond those limits
    var _t = matchUpsToSchedule.reduce(function (aggregator, matchUp) {
        var _a;
        var drawId = matchUp.drawId, tournamentId = matchUp.tournamentId, matchUpType = matchUp.matchUpType;
        var _b = checkDailyLimits({
            individualParticipantProfiles: individualParticipantProfiles,
            matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
            matchUpDailyLimits: matchUpDailyLimits,
            matchUp: matchUp,
        }), participantIdsAtLimit = _b.participantIdsAtLimit, relevantParticipantIds = _b.relevantParticipantIds;
        if (participantIdsAtLimit === null || participantIdsAtLimit === void 0 ? void 0 : participantIdsAtLimit.length) {
            aggregator.overLimitMatchUpIds.push(matchUp.matchUpId);
            (_a = aggregator.participantIdsAtLimit).push.apply(_a, __spreadArray([], __read(participantIdsAtLimit), false));
            return aggregator;
        }
        relevantParticipantIds.forEach(function (participantId) {
            checkParticipantProfileInitialization({
                individualParticipantProfiles: individualParticipantProfiles,
                participantId: participantId,
            });
            var counters = individualParticipantProfiles[participantId].counters;
            if (counters[matchUpType])
                counters[matchUpType] += 1;
            else
                counters[matchUpType] = 1;
            if (counters[TOTAL])
                counters[TOTAL] += 1;
            else
                counters[TOTAL] = 1;
        });
        if (!aggregator.matchUpMap[tournamentId])
            aggregator.matchUpMap[tournamentId] = {};
        if (!aggregator.matchUpMap[tournamentId][drawId]) {
            aggregator.matchUpMap[tournamentId][drawId] = [matchUp];
        }
        else {
            aggregator.matchUpMap[tournamentId][drawId].push(matchUp);
        }
        // since this matchUp is to be scheduled, update the matchUpPotentialParticipantIds
        processNextMatchUps({
            matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
            matchUpNotBeforeTimes: matchUpNotBeforeTimes,
            matchUp: matchUp,
        });
        return aggregator;
    }, { matchUpMap: {}, overLimitMatchUpIds: [], participantIdsAtLimit: [] }), matchUpMap = _t.matchUpMap, overLimitMatchUpIds = _t.overLimitMatchUpIds, participantIdsAtLimit = _t.participantIdsAtLimit;
    matchUpsToSchedule = matchUpsToSchedule.filter(function (_a) {
        var matchUpId = _a.matchUpId;
        return !overLimitMatchUpIds.includes(matchUpId);
    });
    var iterations = 0;
    var failSafe = (_g = scheduleTimes === null || scheduleTimes === void 0 ? void 0 : scheduleTimes.length) !== null && _g !== void 0 ? _g : 0;
    var personRequests = getPersonRequests({
        tournamentRecords: tournamentRecords,
        requestType: DO_NOT_SCHEDULE,
    }).personRequests;
    var _loop_1 = function () {
        iterations++;
        var scheduleTime = scheduleTimes.shift().scheduleTime;
        // find a matchUp where all individual participants had enough recovery time
        var scheduledMatchUp = matchUpsToSchedule.find(function (matchUp) {
            var matchUpId = matchUp.matchUpId;
            var _a = checkDependenciesScheduled({
                matchUpScheduleTimes: matchUpScheduleTimes,
                matchUpDependencies: matchUpDependencies,
                allDateMatchUpIds: allDateMatchUpIds,
                matchUp: matchUp,
            }), dependenciesScheduled = _a.dependenciesScheduled, remainingDependencies = _a.remainingDependencies;
            if (!dependenciesScheduled) {
                if (!dependencyDeferred[matchUpId])
                    dependencyDeferred[matchUpId] = [];
                dependencyDeferred[matchUpId].push({
                    scheduleTime: scheduleTime,
                    remainingDependencies: remainingDependencies,
                });
                return false;
            }
            var enoughTime = checkRecoveryTime({
                individualParticipantProfiles: individualParticipantProfiles,
                matchUpNotBeforeTimes: matchUpNotBeforeTimes,
                matchUpDependencies: matchUpDependencies,
                scheduleTime: scheduleTime,
                matchUp: matchUp,
            }).enoughTime;
            if (!enoughTime) {
                if (!recoveryTimeDeferred[matchUpId])
                    recoveryTimeDeferred[matchUpId] = [];
                recoveryTimeDeferred[matchUpId].push({
                    scheduleTime: scheduleTime,
                });
                return false;
            }
            var conflicts = checkRequestConflicts({
                potentials: checkPotentialRequestConflicts,
                averageMatchUpMinutes: averageMatchUpMinutes,
                requestConflicts: requestConflicts,
                personRequests: personRequests,
                scheduleTime: scheduleTime,
                scheduleDate: scheduleDate,
                matchUp: matchUp,
            }).conflicts;
            if (conflicts === null || conflicts === void 0 ? void 0 : conflicts.length)
                return false;
            var mappedRecoveryMinutes = recoveryMinutesMap === null || recoveryMinutesMap === void 0 ? void 0 : recoveryMinutesMap[matchUp.matchUpId];
            updateTimeAfterRecovery({
                recoveryMinutes: mappedRecoveryMinutes || recoveryMinutes,
                matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
                individualParticipantProfiles: individualParticipantProfiles,
                matchUpNotBeforeTimes: matchUpNotBeforeTimes,
                averageMatchUpMinutes: averageMatchUpMinutes,
                matchUpDependencies: matchUpDependencies,
                scheduleTime: scheduleTime,
                matchUp: matchUp,
            });
            matchUpScheduleTimes[matchUp.matchUpId] = scheduleTime;
            return true;
        });
        matchUpsToSchedule = matchUpsToSchedule.filter(function (_a) {
            var matchUpId = _a.matchUpId;
            return matchUpId !== (scheduledMatchUp === null || scheduledMatchUp === void 0 ? void 0 : scheduledMatchUp.matchUpId);
        });
        if (!scheduledMatchUp) {
            skippedScheduleTimes.push(scheduleTime);
        }
    };
    // while there are still matchUps to schedule and scheduleTimes, assign scheduleTimes to matchUps;
    while ((scheduleTimes === null || scheduleTimes === void 0 ? void 0 : scheduleTimes.length) && matchUpsToSchedule.length && iterations <= failSafe) {
        _loop_1();
    }
    // cleanup limits counters for matchUps which could not be scheduled due to recovery times
    matchUpsToSchedule.forEach(function (matchUp) {
        modifyParticipantMatchUpsCount({
            individualParticipantProfiles: individualParticipantProfiles,
            matchUpPotentialParticipantIds: matchUpPotentialParticipantIds,
            value: -1,
            matchUp: matchUp,
        });
    });
    var scheduledMatchUpIds = [];
    Object.keys(matchUpMap).forEach(function (tournamentId) {
        var tournamentRecord = tournamentRecords[tournamentId];
        if (tournamentRecord) {
            Object.keys(matchUpMap[tournamentId]).forEach(function (drawId) {
                var drawDefinition = findDrawDefinition$1({
                    tournamentRecord: tournamentRecord,
                    drawId: drawId,
                }).drawDefinition;
                if (drawDefinition) {
                    var drawMatchUps = matchUpMap[tournamentId][drawId];
                    drawMatchUps.forEach(function (_a) {
                        var matchUpId = _a.matchUpId;
                        var scheduleTime = matchUpScheduleTimes[matchUpId];
                        if (scheduleTime) {
                            // must include scheduleDate being scheduled to generate proper ISO string
                            var formatTime = scheduleTime.split(':').map(zeroPad).join(':');
                            var scheduledTime = "".concat(extractDate(scheduleDate), "T").concat(formatTime);
                            if (dryRun) {
                                scheduledMatchUpIds.push(matchUpId);
                            }
                            else {
                                var result = addMatchUpScheduledTime({
                                    drawDefinition: drawDefinition,
                                    matchUpId: matchUpId,
                                    scheduledTime: scheduledTime,
                                });
                                if (result.success)
                                    scheduledMatchUpIds.push(matchUpId);
                                if (venueId) {
                                    assignMatchUpVenue({
                                        tournamentRecords: tournamentRecords,
                                        tournamentRecord: tournamentRecord,
                                        drawDefinition: drawDefinition,
                                        matchUpId: matchUpId,
                                        venueId: venueId,
                                    });
                                }
                            }
                        }
                    });
                }
            });
        }
    });
    var noTimeMatchUpIds = getMatchUpIds(matchUpsToSchedule);
    return __assign(__assign({}, SUCCESS), { requestConflicts: Object.values(requestConflicts), remainingScheduleTimes: scheduleTimes === null || scheduleTimes === void 0 ? void 0 : scheduleTimes.map(function (_a) {
            var scheduleTime = _a.scheduleTime;
            return scheduleTime;
        }), individualParticipantProfiles: individualParticipantProfiles, matchUpNotBeforeTimes: matchUpNotBeforeTimes, participantIdsAtLimit: participantIdsAtLimit, // at the moment this is only those participants at limit BEFORE scheduling begins
        skippedScheduleTimes: skippedScheduleTimes, overLimitMatchUpIds: overLimitMatchUpIds, scheduledMatchUpIds: scheduledMatchUpIds, noTimeMatchUpIds: noTimeMatchUpIds, recoveryTimeDeferred: recoveryTimeDeferred, dependencyDeferred: dependencyDeferred });
}

function proConflicts(_a) {
    var tournamentRecords = _a.tournamentRecords, matchUps = _a.matchUps;
    if (!validMatchUps(matchUps))
        return { error: MISSING_MATCHUPS };
    if (matchUps.some(function (_a) {
        var matchUpId = _a.matchUpId, hasContext = _a.hasContext;
        return matchUpId && !hasContext;
    })) {
        return {
            info: 'matchUps must have { inContext: true, nextMatchUps: true }',
            error: MISSING_CONTEXT,
        };
    }
    var maxCourtOrder = Math.max.apply(Math, __spreadArray([], __read(matchUps
        .map(function (_a) {
        var schedule = _a.schedule;
        return (schedule === null || schedule === void 0 ? void 0 : schedule.courtOrder) || 1;
    })
        .map(function (order) { return ensureInt(order); })), false));
    var filteredRows = generateRange(1, maxCourtOrder + 1).map(function (courtOrder) {
        return matchUps.filter(function (m) { var _a; return ensureInt((_a = m.schedule) === null || _a === void 0 ? void 0 : _a.courtOrder) === courtOrder; });
    });
    var rowIndices = {};
    var courtIssues = {};
    var mappedMatchUps = {};
    var sortedFiltered = filteredRows.flat().filter(Boolean).sort(matchUpSort);
    sortedFiltered.forEach(function (_a) {
        var schedule = _a.schedule;
        return delete schedule[SCHEDULE_STATE];
    });
    var drawIds = unique(matchUps.map(function (_a) {
        var drawId = _a.drawId;
        return drawId;
    }));
    var deps = getMatchUpDependencies({
        includeParticipantDependencies: true,
        tournamentRecords: tournamentRecords,
        drawIds: drawIds,
    }).matchUpDependencies;
    var rowProfiles = filteredRows.map(function (row, rowIndex) {
        return row.reduce(function (profile, matchUp) {
            var _a, _b;
            var _c;
            if (!matchUp.matchUpId)
                return profile;
            var matchUpId = matchUp.matchUpId, winnerMatchUpId = matchUp.winnerMatchUpId, loserMatchUpId = matchUp.loserMatchUpId, schedule = matchUp.schedule, sides = matchUp.sides, potentialParticipants = matchUp.potentialParticipants;
            var courtId = schedule === null || schedule === void 0 ? void 0 : schedule.courtId;
            rowIndices[matchUpId] = rowIndex;
            courtIssues[courtId] = [];
            profile.matchUpIds.push(matchUpId);
            mappedMatchUps[matchUpId] = matchUp;
            var sourceMatchUpIds = deps[matchUpId].matchUpIds;
            sourceMatchUpIds.length && (_a = profile.sourceMatchUpIds).push.apply(_a, __spreadArray([], __read(sourceMatchUpIds), false));
            var matchUpParticipantIds = (_c = sides === null || sides === void 0 ? void 0 : sides.map(function (side) {
                var _a;
                return [
                    (_a = side.participant) === null || _a === void 0 ? void 0 : _a.individualParticipantIds,
                    side.participantId,
                ];
            }).flat().filter(Boolean)) !== null && _c !== void 0 ? _c : [];
            var potentialMatchUpParticipantIds = (potentialParticipants === null || potentialParticipants === void 0 ? void 0 : potentialParticipants.flat().map(function (_a) {
                var individualParticipantIds = _a.individualParticipantIds, participantId = _a.participantId;
                return [
                    individualParticipantIds,
                    participantId,
                ];
            }).flat().filter(Boolean)) || [];
            (_b = profile.participantIds).push.apply(_b, __spreadArray(__spreadArray([], __read(potentialMatchUpParticipantIds), false), __read(matchUpParticipantIds), false));
            winnerMatchUpId && profile.targetMatchUpIds.push(winnerMatchUpId);
            loserMatchUpId && profile.targetMatchUpIds.push(loserMatchUpId);
            return profile;
        }, {
            sourceMatchUpIds: [],
            targetMatchUpIds: [],
            participantIds: [],
            matchUpIds: [],
        });
    });
    var sourceDistance = function (a, b) {
        return deps[a].sources.reduce(function (distance, round, index) { return (round.includes(b) && index + 1) || distance; }, 0);
    };
    var rowIssues = rowProfiles.map(function () { return []; });
    var annotate = function (matchUpId, issue, issueType, issueIds) {
        if (!mappedMatchUps[matchUpId].schedule[SCHEDULE_STATE]) {
            // store issue for display below by order of severity
            mappedMatchUps[matchUpId].schedule[SCHEDULE_STATE] = issue;
            mappedMatchUps[matchUpId].schedule[SCHEDULE_ISSUE_IDS] = issueIds;
            // update row issues
            rowIssues[rowIndices[matchUpId]].push({
                matchUpId: matchUpId,
                issueType: issueType,
                issueIds: issueIds,
                issue: issue,
            });
            // update court issues
            var courtId = mappedMatchUps[matchUpId].schedule.courtId;
            if (!courtIssues[courtId])
                courtIssues[courtId] = [];
            courtIssues[courtId].push({ matchUpId: matchUpId, issue: issue, issueType: issueType, issueIds: issueIds });
        }
    };
    rowProfiles.forEach(function (row, rowIndex) {
        var previousRow = rowIndex ? rowProfiles[rowIndex - 1] : undefined;
        var subsequentRows = rowProfiles.slice(rowIndex + 1);
        var participantConflicts = {};
        var instances = instanceCount(row.participantIds);
        var conflictedParticipantIds = Object.keys(instances).filter(function (key) { return instances[key] > 1; });
        var conflictedMatchUpIds = row.matchUpIds.filter(function (matchUpId) {
            return deps[matchUpId].participantIds.some(function (id) {
                return conflictedParticipantIds.includes(id);
            });
        });
        conflictedMatchUpIds.forEach(function (matchUpId) {
            if (!participantConflicts[matchUpId])
                participantConflicts[matchUpId] = {};
            if (!participantConflicts[matchUpId][SCHEDULE_CONFLICT]) {
                participantConflicts[matchUpId][SCHEDULE_CONFLICT] =
                    conflictedMatchUpIds.filter(function (id) { return id !== matchUpId; });
            }
        });
        var previousRowWarnings = previousRow &&
            row.participantIds.filter(function (id) {
                return previousRow.participantIds.includes(id);
            });
        if (previousRowWarnings) {
            previousRowWarnings.forEach(function (participantId) {
                var warnedMatchUpIds = row.matchUpIds
                    .concat(previousRow.matchUpIds)
                    .filter(function (matchUpId) {
                    return deps[matchUpId].participantIds.includes(participantId);
                });
                warnedMatchUpIds.forEach(function (matchUpId) {
                    if (!participantConflicts[matchUpId])
                        participantConflicts[matchUpId] = {};
                    if (!participantConflicts[matchUpId][SCHEDULE_WARNING]) {
                        participantConflicts[matchUpId][SCHEDULE_WARNING] =
                            warnedMatchUpIds.filter(function (id) { return id !== matchUpId; });
                    }
                });
            });
        }
        row.matchUpIds.forEach(function (matchUpId) {
            var e_1, _a;
            var _b, _c, _d, _e;
            var sourceMatchUpIds = deps[matchUpId].matchUpIds;
            try {
                // IMPORTANT: maintain order of annotations
                // SCHEDULE_STATE values progress from ERROR => CONFLICT => WARNING
                // ERRORS Section
                for (var subsequentRows_1 = __values(subsequentRows), subsequentRows_1_1 = subsequentRows_1.next(); !subsequentRows_1_1.done; subsequentRows_1_1 = subsequentRows_1.next()) {
                    var subsequentRow = subsequentRows_1_1.value;
                    var sourceAfter = subsequentRow.matchUpIds.filter(function (id) {
                        return sourceMatchUpIds.includes(id);
                    });
                    if (sourceAfter === null || sourceAfter === void 0 ? void 0 : sourceAfter.length) {
                        sourceAfter.forEach(function (id) {
                            return annotate(id, SCHEDULE_ERROR, CONFLICT_MATCHUP_ORDER, [matchUpId]);
                        });
                        annotate(matchUpId, SCHEDULE_ERROR, CONFLICT_MATCHUP_ORDER, sourceAfter);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (subsequentRows_1_1 && !subsequentRows_1_1.done && (_a = subsequentRows_1.return)) _a.call(subsequentRows_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // CONFLICTS Section
            if ((_b = participantConflicts[matchUpId]) === null || _b === void 0 ? void 0 : _b[SCHEDULE_CONFLICT]) {
                annotate(matchUpId, SCHEDULE_CONFLICT, CONFLICT_PARTICIPANTS, participantConflicts[matchUpId][SCHEDULE_CONFLICT]);
            }
            // if the matchUpId is part of the sources for other row matchUps => conflict
            if (row.sourceMatchUpIds.includes(matchUpId)) {
                var sources = row.matchUpIds.filter(function (id) {
                    return deps[id].matchUpIds.includes(matchUpId);
                });
                annotate(matchUpId, SCHEDULE_CONFLICT, CONFLICT_MATCHUP_ORDER, sources);
                row.matchUpIds
                    .filter(function (id) { return deps[id].matchUpIds.includes(matchUpId); })
                    .forEach(function (id) {
                    return annotate(id, SCHEDULE_CONFLICT, CONFLICT_MATCHUP_ORDER, [matchUpId]);
                });
            }
            // ISSUES Section
            var insufficientGap = (_c = previousRow === null || previousRow === void 0 ? void 0 : previousRow.matchUpIds) === null || _c === void 0 ? void 0 : _c.filter(function (id) { return sourceDistance(matchUpId, id) > 1; });
            if (insufficientGap === null || insufficientGap === void 0 ? void 0 : insufficientGap.length) {
                annotate(matchUpId, SCHEDULE_ISSUE, CONFLICT_MATCHUP_ORDER, insufficientGap);
                insufficientGap.forEach(function (id) {
                    return annotate(id, SCHEDULE_ISSUE, CONFLICT_MATCHUP_ORDER, [matchUpId]);
                });
            }
            // WARNINGS Section
            if ((_d = participantConflicts[matchUpId]) === null || _d === void 0 ? void 0 : _d[SCHEDULE_WARNING]) {
                annotate(matchUpId, SCHEDULE_WARNING, CONFLICT_PARTICIPANTS, participantConflicts[matchUpId][SCHEDULE_WARNING]);
            }
            if ((_e = previousRow === null || previousRow === void 0 ? void 0 : previousRow.targetMatchUpIds) === null || _e === void 0 ? void 0 : _e.includes(matchUpId)) {
                // IF: connected matchUps are on the same court with sufficient time between them
                // OR: connected matchUps are on the same court and the target matchUp has 'FOLLOWED_BY'
                // THEN: no WARNING will be given
                var consideredCourtId_1 = mappedMatchUps[matchUpId].schedule.courtId;
                var warningMatchUpIds = sourceMatchUpIds.filter(function (id) {
                    return previousRow.matchUpIds.includes(id);
                });
                var allSameCourt = warningMatchUpIds.some(function (id) { return mappedMatchUps[id].schedule.courtId === consideredCourtId_1; });
                if (!allSameCourt) {
                    warningMatchUpIds.forEach(function (id) {
                        return annotate(id, SCHEDULE_WARNING, CONFLICT_MATCHUP_ORDER, [matchUpId]);
                    });
                    annotate(matchUpId, SCHEDULE_WARNING, CONFLICT_MATCHUP_ORDER, warningMatchUpIds);
                }
            }
        });
    });
    return { courtIssues: courtIssues, rowIssues: rowIssues };
}

/**
 * Reorders an array of time-ordered matchUps by re-assigning their times
 * Assumes:
 * 1. that only the matchUps which need to be reordered are present in the matchUpContextIds array
 * 2. that either a match has moved from the bottom of the group to the top or vice-versa
 */
function reorderUpcomingMatchUps(params) {
    var stack = 'reorderUpcomingMatchUps';
    var tournamentRecords = params.tournamentRecords;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return decorateResult({
            result: { error: MISSING_TOURNAMENT_RECORDS },
            stack: stack,
        });
    var matchUpsContextIds = params.matchUpsContextIds, firstToLast = params.firstToLast;
    if (!matchUpsContextIds)
        return decorateResult({ result: { error: MISSING_VALUE }, stack: stack });
    var matchUpsCount = matchUpsContextIds === null || matchUpsContextIds === void 0 ? void 0 : matchUpsContextIds.length;
    if (!matchUpsCount)
        return __assign({}, SUCCESS);
    var matchUpsModified = 0;
    matchUpsContextIds.forEach(function (context, index) {
        var tournamentId = context.tournamentId, drawId = context.drawId, matchUpId = context.matchUpId;
        var calculatedIndex = index + (firstToLast ? -1 : 1);
        if (calculatedIndex < 0)
            calculatedIndex = matchUpsCount - 1;
        if (calculatedIndex === matchUpsCount)
            calculatedIndex = 0;
        var scheduledTime = matchUpsContextIds[calculatedIndex].schedule.scheduledTime;
        var result = assignMatchUpScheduledTime({
            tournamentId: tournamentId,
            scheduledTime: scheduledTime,
            matchUpId: matchUpId,
            drawId: drawId,
        });
        if (result.success) {
            matchUpsModified++;
        }
        else {
            return result;
        }
    });
    return matchUpsModified === matchUpsCount
        ? SUCCESS
        : decorateResult({ result: { error: MODIFICATIONS_FAILED }, stack: stack });
    function assignMatchUpScheduledTime(_a) {
        var tournamentId = _a.tournamentId, scheduledTime = _a.scheduledTime, matchUpId = _a.matchUpId, drawId = _a.drawId;
        var tournamentRecord = tournamentRecords[tournamentId];
        var drawDefinition = findDrawDefinition$1({
            tournamentRecord: tournamentRecord,
            drawId: drawId,
        }).drawDefinition;
        if (!drawDefinition)
            return { error: DRAW_DEFINITION_NOT_FOUND };
        return addMatchUpScheduledTime({
            drawDefinition: drawDefinition,
            scheduledTime: scheduledTime,
            matchUpId: matchUpId,
        });
    }
}

function bulkRescheduleMatchUps(params) {
    var e_1, _a;
    var _b, _c;
    var scheduleChange = params.scheduleChange, matchUpIds = params.matchUpIds, dryRun = params.dryRun;
    if (!matchUpIds || !Array.isArray(matchUpIds))
        return { error: MISSING_MATCHUP_IDS };
    if (typeof scheduleChange !== 'object')
        return { error: INVALID_VALUES };
    var tournamentRecords = resolveTournamentRecords(params);
    var rescheduled = [];
    var notRescheduled = [];
    var _loop_1 = function (tournamentRecord) {
        var result = bulkReschedule({
            tournamentRecord: tournamentRecord,
            scheduleChange: scheduleChange,
            matchUpIds: matchUpIds,
            dryRun: dryRun,
        });
        if (result.error)
            return { value: result };
        if (Array.isArray(result.notRescheduled))
            notRescheduled.push.apply(notRescheduled, __spreadArray([], __read(result.notRescheduled), false));
        // this is a check in case something has been rescheduled multiple times in the same call
        var notRescheduledIds = getMatchUpIds(result.notRescheduled);
        var removeFromNotScheduledIds = [];
        (_b = result.rescheduled) === null || _b === void 0 ? void 0 : _b.forEach(function (matchUp) {
            var matchUpId = matchUp.matchUpId;
            if (notRescheduledIds.includes(matchUpId)) {
                removeFromNotScheduledIds.push(matchUpId);
            }
            rescheduled.push(matchUp);
        });
        if (removeFromNotScheduledIds.length) {
            notRescheduled =
                ((_c = result === null || result === void 0 ? void 0 : result.notRescheduled) === null || _c === void 0 ? void 0 : _c.filter(function (_a) {
                    var matchUpId = _a.matchUpId;
                    return !removeFromNotScheduledIds.includes(matchUpId);
                })) || [];
        }
    };
    try {
        for (var _d = __values(Object.values(tournamentRecords)), _e = _d.next(); !_e.done; _e = _d.next()) {
            var tournamentRecord = _e.value;
            var state_1 = _loop_1(tournamentRecord);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var allRescheduled = !!(rescheduled.length && !notRescheduled.length);
    return __assign(__assign({}, SUCCESS), { rescheduled: rescheduled, notRescheduled: notRescheduled, allRescheduled: allRescheduled });
}
/**
 *
 * @param {object} tournamentRecord - passed in automatically by tournamentEngine
 * @param {string[]} matchUpIds - array of matchUpIds to be scheduled
 * @param {object} scheduleChange - { minutesChange, daysChange }
 *
 */
function bulkReschedule(_a) {
    var e_2, _b, e_3, _c;
    var _d;
    var tournamentRecord = _a.tournamentRecord, scheduleChange = _a.scheduleChange, matchUpIds = _a.matchUpIds, dryRun = _a.dryRun;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!matchUpIds || !Array.isArray(matchUpIds))
        return { error: MISSING_MATCHUP_IDS };
    if (typeof scheduleChange !== 'object')
        return { error: INVALID_VALUES };
    var rescheduledMatchUpIds = [];
    var notRescheduledMatchUpIds = [];
    var minutesChange = scheduleChange.minutesChange, daysChange = scheduleChange.daysChange;
    if (!minutesChange && !daysChange)
        return __assign({}, SUCCESS);
    if (minutesChange && isNaN(minutesChange))
        return { error: INVALID_VALUES };
    if (daysChange && isNaN(daysChange))
        return { error: INVALID_VALUES };
    var matchUps = allTournamentMatchUps({
        matchUpFilters: { matchUpIds: matchUpIds },
        tournamentRecord: tournamentRecord,
    }).matchUps;
    var notCompleted = function (_a) {
        var matchUpStatus = _a.matchUpStatus;
        return !completedMatchUpStatuses.includes(matchUpStatus);
    };
    // return success if there are no scheduled matchUps to reschedule
    var scheduledNotCompletedMatchUps = matchUps === null || matchUps === void 0 ? void 0 : matchUps.filter(function (matchUp) { return hasSchedule({ schedule: matchUp.schedule }); }).filter(function (matchUp) {
        return notCompleted({ matchUpStatus: matchUp.matchUpStatus });
    });
    if (!(scheduledNotCompletedMatchUps === null || scheduledNotCompletedMatchUps === void 0 ? void 0 : scheduledNotCompletedMatchUps.length))
        return __assign({}, SUCCESS);
    var tournamentInfo = getTournamentInfo({ tournamentRecord: tournamentRecord }).tournamentInfo;
    var startDate = tournamentInfo.startDate, endDate = tournamentInfo.endDate;
    // first organize matchUpIds by drawId
    var drawIdMap = scheduledNotCompletedMatchUps === null || scheduledNotCompletedMatchUps === void 0 ? void 0 : scheduledNotCompletedMatchUps.reduce(function (drawIdMap, matchUp) {
        var matchUpId = matchUp.matchUpId, drawId = matchUp.drawId;
        if (drawIdMap[drawId]) {
            drawIdMap[drawId].push(matchUpId);
        }
        else {
            drawIdMap[drawId] = [matchUpId];
        }
        return drawIdMap;
    }, {});
    var dayTotalMinutes = 1440;
    try {
        for (var _e = __values(Object.keys(drawIdMap)), _f = _e.next(); !_f.done; _f = _e.next()) {
            var drawId = _f.value;
            var result = findDrawDefinition$1({
                tournamentRecord: tournamentRecord,
                drawId: drawId,
            });
            if (result.error)
                return result;
            var drawDefinition = result.drawDefinition;
            var drawMatchUpIds = drawIdMap[drawId].filter(function (matchUpId) {
                return matchUpIds.includes(matchUpId);
            });
            var _loop_2 = function (matchUpId) {
                if (matchUpId && drawDefinition) {
                    var inContextMatchUp = scheduledNotCompletedMatchUps.find(function (matchUp) { return matchUp.matchUpId === matchUpId; });
                    var schedule = inContextMatchUp === null || inContextMatchUp === void 0 ? void 0 : inContextMatchUp.schedule;
                    var scheduledTime = schedule.scheduledTime, scheduledDate = schedule.scheduledDate;
                    var doNotReschedule = void 0, newScheduledTime = void 0, newScheduledDate = void 0;
                    if (!doNotReschedule && daysChange && scheduledDate) {
                        var currentDate = extractDate(scheduledDate);
                        newScheduledDate = dateStringDaysChange(currentDate, daysChange);
                        doNotReschedule =
                            new Date(newScheduledDate) < new Date(startDate) ||
                                new Date(newScheduledDate) > new Date(endDate);
                    }
                    if (minutesChange && scheduledTime) {
                        var scheduledTimeDate = extractDate(scheduledTime);
                        var currentDayMinutes = timeStringMinutes(extractTime(scheduledTime));
                        var newTime = currentDayMinutes + minutesChange;
                        doNotReschedule = newTime < 0 || newTime > dayTotalMinutes;
                        if (!doNotReschedule) {
                            var timeString = addMinutesToTimeString(scheduledTime, minutesChange);
                            var timeStringDate = (scheduledTimeDate && newScheduledDate) ||
                                (scheduledDate === scheduledTimeDate && scheduledTimeDate);
                            newScheduledTime = timeStringDate
                                ? "".concat(timeStringDate, "T").concat(timeString)
                                : timeString;
                        }
                    }
                    if (doNotReschedule) {
                        notRescheduledMatchUpIds.push(matchUpId);
                    }
                    else {
                        if (!dryRun) {
                            if (newScheduledTime) {
                                var result_1 = addMatchUpScheduledTime({
                                    scheduledTime: newScheduledTime,
                                    drawDefinition: drawDefinition,
                                    matchUpId: matchUpId,
                                });
                                if (result_1.error)
                                    return { value: result_1 };
                            }
                            if (newScheduledDate) {
                                var result_2 = addMatchUpScheduledDate({
                                    scheduledDate: newScheduledDate,
                                    drawDefinition: drawDefinition,
                                    matchUpId: matchUpId,
                                });
                                if (result_2.error)
                                    return { value: result_2 };
                            }
                        }
                        if (newScheduledTime || newScheduledDate) {
                            rescheduledMatchUpIds.push(matchUpId);
                        }
                    }
                }
            };
            try {
                for (var drawMatchUpIds_1 = (e_3 = void 0, __values(drawMatchUpIds)), drawMatchUpIds_1_1 = drawMatchUpIds_1.next(); !drawMatchUpIds_1_1.done; drawMatchUpIds_1_1 = drawMatchUpIds_1.next()) {
                    var matchUpId = drawMatchUpIds_1_1.value;
                    var state_2 = _loop_2(matchUpId);
                    if (typeof state_2 === "object")
                        return state_2.value;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (drawMatchUpIds_1_1 && !drawMatchUpIds_1_1.done && (_c = drawMatchUpIds_1.return)) _c.call(drawMatchUpIds_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var updatedInContext = (_d = allTournamentMatchUps({
        matchUpFilters: { matchUpIds: matchUpIds },
        tournamentRecord: tournamentRecord,
    }).matchUps) !== null && _d !== void 0 ? _d : [];
    var rescheduled = updatedInContext.filter(function (_a) {
        var matchUpId = _a.matchUpId;
        return rescheduledMatchUpIds.includes(matchUpId);
    });
    var notRescheduled = updatedInContext.filter(function (_a) {
        var matchUpId = _a.matchUpId;
        return notRescheduledMatchUpIds.includes(matchUpId);
    });
    var allRescheduled = rescheduled.length && !notRescheduled.length;
    return __assign(__assign({}, SUCCESS), { rescheduled: rescheduled, notRescheduled: notRescheduled, allRescheduled: allRescheduled });
}

function matchUpScheduleChange(params) {
    var stack = 'matchUpScheduleChange';
    var tournamentRecords = params.tournamentRecords;
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var _a = params || {}, sourceMatchUpContextIds = _a.sourceMatchUpContextIds, targetMatchUpContextIds = _a.targetMatchUpContextIds, sourceCourtId = _a.sourceCourtId, targetCourtId = _a.targetCourtId, courtDayDate = _a.courtDayDate;
    var _b = sourceMatchUpContextIds || {}, sourceDrawId = _b.drawId, sourceMatchUpId = _b.matchUpId, sourceTournamentId = _b.tournamentId;
    var _c = targetMatchUpContextIds || {}, targetDrawId = _c.drawId, targetMatchUpId = _c.matchUpId, targetTournamentId = _c.tournamentId;
    if (!sourceMatchUpId && !targetMatchUpId)
        return decorateResult({ result: { error: MISSING_VALUE }, stack: stack });
    var matchUps = allCompetitionMatchUps({
        matchUpFilters: {
            matchUpIds: [sourceMatchUpId, targetMatchUpId].filter(Boolean),
            drawIds: [sourceDrawId, targetDrawId].filter(Boolean),
        },
        tournamentRecords: params.tournamentRecords,
    }).matchUps;
    var sourceMatchUp = matchUps === null || matchUps === void 0 ? void 0 : matchUps.find(function (_a) {
        var matchUpId = _a.matchUpId;
        return matchUpId === sourceMatchUpId;
    });
    var targetMatchUp = matchUps === null || matchUps === void 0 ? void 0 : matchUps.find(function (_a) {
        var matchUpId = _a.matchUpId;
        return matchUpId === targetMatchUpId;
    });
    var matchUpsModified = 0;
    if (targetCourtId && sourceMatchUpId && !targetMatchUpId) {
        var result = assignMatchUp({
            tournamentId: sourceTournamentId,
            matchUpId: sourceMatchUpId,
            courtId: targetCourtId,
            matchUp: sourceMatchUp,
            drawId: sourceDrawId,
            tournamentRecords: tournamentRecords,
            sourceCourtId: sourceCourtId,
            courtDayDate: courtDayDate,
        });
        if (result === null || result === void 0 ? void 0 : result.success)
            matchUpsModified++;
        if (result.error)
            return decorateResult({ result: result, stack: stack });
    }
    else if (sourceCourtId &&
        targetCourtId &&
        sourceMatchUpId &&
        targetMatchUpId) {
        var sourceResult = assignMatchUp({
            tournamentId: sourceTournamentId,
            matchUpId: sourceMatchUpId,
            courtId: targetCourtId,
            matchUp: sourceMatchUp,
            drawId: sourceDrawId,
            tournamentRecords: tournamentRecords,
            sourceCourtId: sourceCourtId,
            courtDayDate: courtDayDate,
        });
        if (sourceResult.success)
            matchUpsModified++;
        if (sourceResult.error)
            return decorateResult({ result: sourceResult, stack: stack, info: 'source' });
        var targetResult = assignMatchUp({
            tournamentId: targetTournamentId,
            sourceCourtId: targetCourtId,
            matchUpId: targetMatchUpId,
            matchUp: targetMatchUp,
            courtId: sourceCourtId,
            drawId: targetDrawId,
            tournamentRecords: tournamentRecords,
            courtDayDate: courtDayDate,
        });
        if (targetResult.success)
            matchUpsModified++;
        if (targetResult.error)
            return decorateResult({ result: targetResult, stack: stack, info: 'target' });
    }
    else {
        return { error: MISSING_VALUE };
    }
    return matchUpsModified
        ? SUCCESS
        : decorateResult({ result: { error: NO_MODIFICATIONS_APPLIED }, stack: stack });
    function assignMatchUp(params) {
        var tournamentRecords = params.tournamentRecords, tournamentId = params.tournamentId, matchUp = params.matchUp, drawId = params.drawId;
        var tournamentRecord = tournamentRecords[tournamentId];
        var drawDefinition = findDrawDefinition$1({
            tournamentRecord: tournamentRecord,
            drawId: drawId,
        }).drawDefinition;
        if (matchUp.matchUpType === TEAM) {
            return allocateCourts(__assign(__assign({}, params), { tournamentRecord: tournamentRecord, drawDefinition: drawDefinition }));
        }
        else {
            return assignMatchUpCourt(__assign(__assign({}, params), { tournamentRecord: tournamentRecord, drawDefinition: drawDefinition }));
        }
    }
    function allocateCourts(_a) {
        var removePriorValues = _a.removePriorValues, tournamentRecords = _a.tournamentRecords, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, sourceCourtId = _a.sourceCourtId, courtDayDate = _a.courtDayDate, matchUpId = _a.matchUpId, matchUp = _a.matchUp, courtId = _a.courtId;
        var courtIds = [courtId].concat(matchUp.schedule.allocatedCourts
            .map(function (_a) {
            var courtId = _a.courtId;
            return courtId;
        })
            .filter(function (courtId) { return courtId !== sourceCourtId; }));
        return allocateTeamMatchUpCourts({
            removePriorValues: removePriorValues,
            tournamentRecords: tournamentRecords,
            tournamentRecord: tournamentRecord,
            drawDefinition: drawDefinition,
            courtDayDate: courtDayDate,
            matchUpId: matchUpId,
            courtIds: courtIds,
        });
    }
}

function clearMatchUpSchedule(_a) {
    var _b, _c, _d;
    var _e = _a.scheduleAttributes, scheduleAttributes = _e === void 0 ? [
        ALLOCATE_COURTS,
        ASSIGN_COURT,
        ASSIGN_VENUE,
        SCHEDULED_DATE,
        SCHEDULED_TIME,
        START_TIME,
        END_TIME,
        RESUME_TIME,
        STOP_TIME,
    ] : _e, tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, matchUpId = _a.matchUpId;
    var stack = 'clearMatchUpSchedule';
    var matchUp = drawDefinition
        ? (_b = allDrawMatchUps({
            matchUpFilters: { matchUpIds: [matchUpId] },
            inContext: false,
            drawDefinition: drawDefinition,
        }).matchUps) === null || _b === void 0 ? void 0 : _b[0]
        : (_c = allTournamentMatchUps({
            matchUpFilters: { matchUpIds: [matchUpId] },
            tournamentRecord: tournamentRecord,
            inContext: false,
        }).matchUps) === null || _c === void 0 ? void 0 : _c[0];
    if (!matchUp)
        return { error: MATCHUP_NOT_FOUND };
    var newTimeItems = ((_d = matchUp.timeItems) !== null && _d !== void 0 ? _d : []).filter(function (timeItem) {
        return (timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType) && !scheduleAttributes.includes(timeItem === null || timeItem === void 0 ? void 0 : timeItem.itemType);
    });
    matchUp.timeItems = newTimeItems;
    modifyMatchUpNotice({
        tournamentId: tournamentRecord.tournamentId,
        context: stack,
        drawDefinition: drawDefinition,
        matchUp: matchUp,
    });
    return __assign({}, SUCCESS);
}

function setMatchUpDailyLimits(params) {
    var _a, e_1, _b;
    var tournamentRecord = params.tournamentRecord, tournamentId = params.tournamentId, dailyLimits = params.dailyLimits;
    var tournamentRecords = params.tournamentRecords ||
        (tournamentRecord && (_a = {},
            _a[tournamentRecord.tournamentId] = tournamentRecord,
            _a)) ||
        {};
    if (typeof tournamentRecords !== 'object' ||
        !Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    if (typeof dailyLimits !== 'object')
        return { error: INVALID_OBJECT };
    var tournamentIds = Object.keys(tournamentRecords).filter(function (currentTournamentId) {
        return !tournamentId || tournamentId === currentTournamentId;
    });
    if (tournamentId && !tournamentIds.includes(tournamentId))
        return { error: INVALID_VALUES };
    try {
        for (var tournamentIds_1 = __values(tournamentIds), tournamentIds_1_1 = tournamentIds_1.next(); !tournamentIds_1_1.done; tournamentIds_1_1 = tournamentIds_1.next()) {
            var currentTournamentId = tournamentIds_1_1.value;
            var tournamentRecord_1 = tournamentRecords[currentTournamentId];
            var result = addExtension({
                element: tournamentRecord_1,
                extension: { name: SCHEDULE_LIMITS, value: { dailyLimits: dailyLimits } },
            });
            if (result.error)
                return result;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (tournamentIds_1_1 && !tournamentIds_1_1.done && (_b = tournamentIds_1.return)) _b.call(tournamentIds_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}

var scheduleGovernor = {
    addMatchUpCourtOrder: addMatchUpCourtOrder,
    addMatchUpEndTime: addMatchUpEndTime,
    addMatchUpOfficial: addMatchUpOfficial,
    addMatchUpResumeTime: addMatchUpResumeTime,
    addMatchUpScheduledDate: addMatchUpScheduledDate,
    addMatchUpScheduledTime: addMatchUpScheduledTime,
    addMatchUpScheduleItems: addMatchUpScheduleItems,
    addMatchUpStartTime: addMatchUpStartTime,
    addMatchUpStopTime: addMatchUpStopTime,
    addPersonRequests: addPersonRequests,
    addSchedulingProfileRound: addSchedulingProfileRound,
    allocateTeamMatchUpCourts: allocateTeamMatchUpCourts,
    assignMatchUpCourt: assignMatchUpCourt,
    assignMatchUpVenue: assignMatchUpVenue,
    bulkRescheduleMatchUps: bulkRescheduleMatchUps,
    bulkScheduleMatchUps: bulkScheduleMatchUps,
    bulkScheduleTournamentMatchUps: bulkScheduleTournamentMatchUps,
    bulkUpdateCourtAssignments: bulkUpdateCourtAssignments,
    calculateScheduleTimes: calculateScheduleTimes,
    clearMatchUpSchedule: clearMatchUpSchedule,
    clearScheduledMatchUps: clearScheduledMatchUps,
    courtGridRows: courtGridRows,
    findCourt: publicFindCourt,
    findMatchUpFormatTiming: findMatchUpFormatTiming,
    findVenue: findVenue,
    generateBookings: generateBookings,
    generateVirtualCourts: generateVirtualCourts,
    getProfileRounds: getProfileRounds,
    getSchedulingProfile: getSchedulingProfile,
    matchUpScheduleChange: matchUpScheduleChange,
    modifyEventMatchUpFormatTiming: modifyEventMatchUpFormatTiming,
    modifyMatchUpFormatTiming: modifyMatchUpFormatTiming,
    modifyPersonRequests: modifyPersonRequests,
    proAutoSchedule: proAutoSchedule,
    proConflicts: proConflicts,
    removeEventMatchUpFormatTiming: removeEventMatchUpFormatTiming,
    removeMatchUpCourtAssignment: removeMatchUpCourtAssignment,
    removePersonRequests: removePersonRequests,
    reorderUpcomingMatchUps: reorderUpcomingMatchUps,
    scheduleMatchUps: scheduleMatchUps,
    scheduleProfileRounds: scheduleProfileRounds,
    setMatchUpDailyLimits: setMatchUpDailyLimits, // document
    setSchedulingProfile: setSchedulingProfile,
    toggleParticipantCheckInState: toggleParticipantCheckInState,
    validateSchedulingProfile: validateSchedulingProfile,
};

var standardSet = '\\d+-\\d+';
var tiebreakSet = '\\d+-\\d+\\(\\d+\\)';
var matchTiebreak = '\\[\\d+-\\d+\\]';
var incompleteSet = '\\d+-\\d+\\(\\d+-\\d+\\)';
var standardSetComma = new RegExp("(".concat(standardSet, "),"), 'g');
var tiebreakSetComma = new RegExp("(".concat(tiebreakSet, "),"), 'g');
var setTypes = [standardSet, tiebreakSet, matchTiebreak, incompleteSet];
// prettier-ignore
var patternGenerator = [
    '0', '1', '2', '00', '01', '10', '11',
    '002', '012', '102', '112',
    '000', '001', '010', '100', '011', '101',
    '110', '111', '002', '012', '102', '112',
    '0002', '0012', '0102', '1002',
    '0112', '1012', '1102', '1112',
    // retired matchUpStatus
    '3', '03', '13', '013', '103'
];
var regularExpressions = patternGenerator.map(function (pattern) {
    var arrayIndices = pattern.split('');
    var expression = arrayIndices.map(function (index) { return setTypes[index]; }).join(' ');
    return new RegExp("^".concat(expression, "$"));
});
function isValidPattern(score) {
    return !score || regularExpressions.some(function (re) { return re.test(score); });
}

function correctContainerMismatch(score) {
    var brackets = '[];';
    var parens = '()';
    var types = brackets + parens;
    var openers = [brackets[0], parens[0]];
    var typeCount = Object.assign.apply(Object, __spreadArray([{}], __read(types.split('').map(function (char) {
        var _a;
        return (_a = {}, _a[char] = 0, _a);
    })), false));
    var lastType = '';
    var corrected = score
        .split('')
        .map(function (char) {
        var type = types.includes(char) && char;
        var isOpener = openers.includes(type);
        if (isOpener && type) {
            typeCount[type] += 1;
            lastType = type;
            return char;
        }
        if (!isOpener && type && lastType && type !== lastType) {
            typeCount[lastType] -= 1;
            var domain = (brackets.includes(lastType) && brackets) ||
                (parens.includes(lastType) && parens) ||
                '';
            var complement = domain.split('').find(function (c) { return c !== lastType; });
            if (!domain.includes(type)) {
                if (!typeCount[type])
                    lastType = '';
                return complement;
            }
            else {
                if (!typeCount[lastType])
                    lastType = '';
            }
        }
        return char;
    })
        .join('');
    if (score !== corrected) {
        return corrected;
    }
    return score;
}

function isTiebreakScore(part) {
    return /^\(\d+\)$/.test(part) || /^\(\d+$/.test(part);
}
function isBracketScore(part) {
    return /^\(\d+-\d+\)$/.test(part) || /^\[\d+-\d+\]$/.test(part);
}
function isDiffOne(score) {
    var strip = function (value) { return value === null || value === void 0 ? void 0 : value.split('-').join('').split('/').join(''); };
    var stripped = strip(score);
    if (/^\d+$/.test(stripped) && stripped.length === 2) {
        var scores = stripped.split('');
        var diff = Math.abs(scores.reduce(function (a, b) { return +a - +b; }));
        return diff === 1;
    }
    return false;
}
function getSuper(values, index) {
    var parts = [
        values.slice(index, index + 2),
        index ? values.slice(0, 1) : values.slice(2),
    ].map(function (n) { return parseInt(n.join('')); });
    // preserve order
    if (index)
        parts.reverse();
    var scores = parts;
    var diff = Math.abs(scores.reduce(function (a, b) { return +a - +b; }));
    if (diff >= 2)
        return scores.join('-');
    return undefined;
}
function dashJoin(part) {
    if (part.length === 2) {
        return part.split('').join('-');
    }
    [', ', ',', '/', ' '].forEach(function (separator) { return (part = part.split(separator).join('-')); });
    part = part.replace(/-{2,}/, '-'); // handle repeating '-'
    return part;
}
function isContained(part) {
    return part.startsWith('(') && part.endsWith(')');
}

function punctuationAdjustments(_a) {
    var e_1, _b, e_2, _c, e_3, _d, e_4, _e;
    var score = _a.score, applied = _a.applied;
    score = correctContainerMismatch(score);
    var closeParenDigit = /\)(\d+)/g;
    if (closeParenDigit.test(score)) {
        try {
            for (var _f = __values(score.match(closeParenDigit)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var instance = _g.value;
                var replacement = instance.replace(')', ') ');
                score = score.replace(instance, replacement);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    score = score.replace(/\)\//g, ') / ');
    score = score.replace(/\/\)/g, ')');
    // convert (# - # ) => (#-#)
    var bwsg = /\(([\d- ]+)\)/g;
    var bws = /\(([\d- ]+)\)/;
    var ws = score.match(bwsg);
    try {
        for (var _h = __values(ws || []), _j = _h.next(); !_j.done; _j = _h.next()) {
            var s = _j.value;
            var _k = __read(s.match(bws).slice(1), 1), v = _k[0];
            var trimmedBracketValue = v.replace(/ /g, '');
            score = score.replace(s, "(".concat(trimmedBracketValue, ")"));
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var doubleBracketed = /\(\(\d-\d\)\)/g;
    if (doubleBracketed.test(score)) {
        var dbls = score.match(doubleBracketed);
        if (dbls.length) {
            dbls.forEach(function (dbl) {
                var m = dbl.match(/\((\(\d-\d\))\)/).slice(1)[0];
                score = score.replace(dbl, m);
            });
        }
    }
    doubleBracketed = /\(\((\d)\)\)/g;
    if (doubleBracketed.test(score)) {
        var dbls = score.match(doubleBracketed);
        if (dbls.length) {
            dbls.forEach(function (dbl) {
                var m = dbl.match(/\((\(\d\))\)/).slice(1)[0];
                score = score.replace(dbl, m);
            });
        }
    }
    // must occur before repating dash or dash with comma
    if (/(^|\s)6-,/.test(score)) {
        score = score.replace(/(^|\s)6-,/g, '6-0,');
    }
    // repeating dash or dash with comma
    var repeatingDash = new RegExp(/[-,]{2,}/g);
    score = score.replace(repeatingDash, '-');
    // dash space or space dash
    ['- ', ' -'].forEach(function (dashScenario) {
        var dashSpace = new RegExp("(\\d+)".concat(dashScenario, "(\\d+)"), 'g');
        var spacedDash = score.match(dashSpace);
        if (spacedDash) {
            spacedDash.forEach(function (spaced) {
                return (score = score.replace(spaced, spaced.split(dashScenario).join('-')));
            });
        }
    });
    // remove punctuation-only results
    if (/^[(-/,]+$/.test(score)) {
        score = '';
    }
    // remove extraneous trailing punctuation
    if (/\)[-/,]+$/.test(score)) {
        score = score.slice(0, score.length - 1);
    }
    // space slash surrounded by digits
    if (/\d \/\d/.test(score))
        score = score.replace(/ \//g, '/');
    // all other space slashes are replaced by space
    if (score.includes(' /'))
        score = score.replace(/ \//g, ' ');
    var ghost = /\(\d+, \)/g;
    if (ghost.test(score)) {
        var ghosts = score.match(ghost);
        ghosts.forEach(function (g) {
            var _a = __read(g.match(/\((\d+), \)/).slice(1), 1), digits = _a[0];
            if (digits.length === 2) {
                score = score.replace(g, "(".concat(digits, ")"));
            }
            else if (digits.length === 1 && digits === '6') {
                score = score.replace(g, "(6-0)");
            }
        });
    }
    var slashClose = /\((\d+)\/\)/g;
    if (slashClose.test(score)) {
        var sc = score.match(slashClose);
        sc.forEach(function (s) {
            var _a = __read(s.match(/\((\d+)\/\)/).slice(1), 1), digits = _a[0];
            if (digits.length === 2) {
                score = score.replace(s, "(".concat(digits, ")"));
            }
            else if (digits.length === 1 && digits === '6') {
                // TODO: some logic to determine whether tiebreak value is expected
                score = score.replace(s, "(6-0)");
            }
            else {
                // TODO: some logic to determine whether tiebreak value is expected
                score = score.replace(s, "(".concat(digits, ")"));
            }
        });
    }
    var slashComma = /\d\/\d\/,/g;
    if (slashComma.test(score)) {
        var sc = score.match(slashComma);
        sc.forEach(function (s) {
            var _a = __read(s.match(/(\d\/\d)\/,/).slice(1), 1), digits = _a[0];
            score = score.replace(s, "".concat(digits, ","));
            applied.push('slashComma');
        });
    }
    var slashOpen = /\(\/(\d+)\)/g;
    if (slashOpen.test(score)) {
        var sc = score.match(slashOpen);
        sc.forEach(function (s) {
            var _a = __read(s.match(/\(\/(\d+)\)/).slice(1), 1), digits = _a[0];
            if (digits.length === 2) {
                score = score.replace(s, "(".concat(digits, ")"));
            }
            else if (digits.length === 1 && parseInt(digits) < 6) {
                score = score.replace(s, "(6-".concat(digits, ")"));
            }
            else {
                // TODO: some logic to determine whether tiebreak value is expected
                score = score.replace(s, "(".concat(digits, ")"));
            }
        });
    }
    var missingOpenParen, missingCloseParen, missingCloseBracket, noClose, counts;
    var getMissing = function () {
        counts = instanceCount(score.split(''));
        missingCloseParen = counts['('] === (counts[')'] || 0) + 1;
        missingOpenParen = (counts['('] || 0) + 1 === counts[')'];
        missingCloseBracket = counts['['] === counts[']'] + 1;
        noClose = missingCloseParen && !missingCloseBracket;
    };
    getMissing();
    var unclosed = /(\d+-\d+\(\d+)0,/;
    if (unclosed.test(score)) {
        var _l = __read(score.match(unclosed).slice(1), 1), setScore = _l[0];
        score = score.replace(unclosed, setScore + ')');
    }
    if (counts['('] === counts[')'] && counts['('] > 1) {
        var parts = score.split(')(').join(') (').split(' ');
        if (parts.every(isContained)) {
            score = parts
                .map(function (part) {
                var innards = part.slice(1, part.length - 1);
                return innards.length > 2 ? innards : part;
            })
                .join(' ');
        }
        else {
            score = parts.join(' ');
        }
    }
    getMissing();
    var hasAlpha = /[A-Za-z]+/.test(score);
    var hasDigits = /\d+/.test(score);
    if (!hasAlpha && !hasDigits)
        return { score: '' };
    // remove enclosing [] provided there is anything other than numbers contained
    // don't want to remove for e.g. "[1]" which is dealt with as seeding value
    if (/^\[.+\]$/.test(score) &&
        '()/,- '.split('').some(function (punctuation) { return counts[punctuation]; })) {
        score = score.slice(1, score.length - 1);
    }
    // remove enclosing () provided contained punctuation
    if (/^\(.+\)$/.test(score) &&
        counts['('] === 1 &&
        counts[')'] === 1 &&
        '[]/,'.split('').some(function (punctuation) { return counts[punctuation] > 1; })) {
        score = score.slice(1, score.length - 1);
    }
    if (score.startsWith('(') && score.endsWith('))')) {
        score = score.slice(1, score.length - 1);
    }
    if (counts['('] > (counts[')'] || 0) && score[score.length - 1] === '(') {
        score = score.slice(0, score.length - 1) + ')';
        getMissing();
    }
    if (counts['('] === 1 && !counts[')'] && score[0] === '(') {
        score = score + ')';
        getMissing();
    }
    if (counts['('] > (counts[')'] || 0) && score.slice(0, 2) === '((') {
        score = score.slice(1);
    }
    if (missingOpenParen) {
        if (/^9\d/.test(score)) {
            score = '(' + score.slice(1);
        }
        else if (score[0] !== '(') {
            score = '(' + score;
        }
        else {
            var reconstructed = [];
            var open_1 = 0;
            try {
                // step through characters and insert close before open when open
                for (var _m = __values(score.split('').reverse()), _o = _m.next(); !_o.done; _o = _m.next()) {
                    var char = _o.value;
                    if (char === ')') {
                        if (open_1) {
                            reconstructed.push('(');
                        }
                        else {
                            open_1 += 1;
                        }
                    }
                    if (char === '(')
                        open_1 -= 1;
                    reconstructed.push(char);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
                }
                finally { if (e_3) throw e_3.error; }
            }
            reconstructed.reverse();
            score = reconstructed.join('');
        }
        getMissing();
    }
    if (counts[')'] > (counts['('] || 0) && score[0] === ')') {
        score = '(' + score.slice(1);
        getMissing();
    }
    if (noClose && (score.endsWith(9) || /\d+0$/.test(score))) {
        score = score.slice(0, score.length - 1) + ')';
        getMissing();
    }
    if (noClose && (!score.endsWith(')') || score.startsWith('(('))) {
        score = score + ')';
        getMissing();
    }
    if (noClose) {
        var reconstructed = '';
        var open_2 = 0;
        try {
            // step through characters and insert close before open when open
            for (var _p = __values(score.split('')), _q = _p.next(); !_q.done; _q = _p.next()) {
                var char = _q.value;
                if (char === '(') {
                    if (open_2) {
                        reconstructed += ')';
                    }
                    else {
                        open_2 += 1;
                    }
                }
                if (char === ')')
                    open_2 -= 1;
                reconstructed += char;
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
            }
            finally { if (e_4) throw e_4.error; }
        }
        score = reconstructed;
    }
    getMissing();
    if (missingCloseBracket && !missingCloseParen)
        score = score + ']';
    // this is potentially problematic as enclosing with '[]' yields tiebreak...
    // ... wheres enclosing with '()' yields a set which gets converted to a supertiebreak!
    // Really it would be better to convert to set and determine later which type of tiebreak based on previous set
    if (score.includes('([') && score.includes('])')) {
        score = score.split('([').join('[').split('])').join(']');
        getMissing();
    }
    if (/\(\d+0$/.test(score)) {
        score = score.slice(0, score.length - 1) + ')';
    }
    getMissing();
    if (counts[')'] === 1 && !counts['('] && score.endsWith(')')) {
        score = score.slice(0, score.length - 1);
    }
    if (score.startsWith('(') &&
        score.endsWith(')') &&
        counts['('] === 1 &&
        counts[')'] === 1) {
        score = score.slice(1, score.length - 1);
        getMissing();
    }
    var openFirst = function (value) {
        var open = value.indexOf('(');
        var close = value.indexOf(')');
        return open >= 0 && close >= 0 && open < close;
    };
    if (/^\([\d ]+.*[\d ]+\)$/.test(score) && counts['('] === counts[')']) {
        var proposed = score.slice(1, score.length - 1);
        if (openFirst(proposed)) {
            score = proposed;
            getMissing();
        }
    }
    return { score: score, applied: applied };
}

function dashMash(segment) {
    if (!/^[\d-]+(\(\d\))*$/.test(segment)) {
        return segment;
    }
    var dashIndices = arrayIndices('-', segment.split(''));
    if (!dashIndices.length)
        return segment;
    var numbers = segment.split('-');
    var eventNumberCount = !(numbers.length % 2);
    var oddDashCount = !!(dashIndices.length % 2);
    // handle situation where too many dashes join what should be sets
    // multiple sets were found within a parenthetical
    if (eventNumberCount &&
        oddDashCount &&
        dashIndices.length > numbers.length / 2) {
        var spaceIndices = dashIndices.filter(function (_, i) { return i % 2; });
        spaceIndices.forEach(function (index) {
            segment =
                segment.substring(0, index) + ' ' + segment.substring(index + 1);
        });
    }
    return segment;
}

function handleBracketSpacing(_a) {
    var score = _a.score, applied = _a.applied;
    if (score.includes('( ')) {
        applied.push('removeParenSpacingAfterOpen');
        score = score
            .split('( ')
            .map(function (part) { return part.trim(); })
            .join('(');
    }
    if (score.includes(' )')) {
        applied.push('removeParenSpacingBeforeClose');
        score = score
            .split(' )')
            .map(function (part) { return part.trim(); })
            .join(')');
    }
    [standardSetComma, tiebreakSetComma].forEach(function (setComma) {
        var setsEndComma = score.match(setComma);
        if (setsEndComma === null || setsEndComma === void 0 ? void 0 : setsEndComma.length) {
            setsEndComma.forEach(function (commaEnd) {
                score = score.replace(commaEnd, commaEnd.slice(0, commaEnd.length - 1) + ' ');
            });
            applied.push('setsEndComma');
        }
    });
    // remove extraneous spaces
    score = score.split(' ').filter(Boolean).map(dashMash).join(' ');
    return { score: score, applied: applied };
}

function joinFloatingTiebreak(_a) {
    var e_1, _b;
    var score = _a.score;
    if (typeof score !== 'string')
        return { score: score };
    var strip = function (value) { return value === null || value === void 0 ? void 0 : value.split('-').join('').split('/').join(''); };
    var bracketToParen = function (value) {
        return value.split('[').join('(').split(']').join(')');
    };
    score = score.split(', ').join(' ');
    var parts = score.split(' ');
    score = parts
        .map(function (part) {
        var deDash = /^-(\d+)$/;
        if (deDash.test(part)) {
            var _a = __read(part.match(deDash).slice(1), 1), value = _a[0];
            if (value.length === 2) {
                return value.split('').join('-');
            }
        }
        return part;
    })
        .join(' ');
    parts = score.split(' ');
    var floatingTiebreaks = parts.filter(isTiebreakScore);
    var lastIndex = 0;
    var joinedScore = '';
    try {
        for (var floatingTiebreaks_1 = __values(floatingTiebreaks), floatingTiebreaks_1_1 = floatingTiebreaks_1.next(); !floatingTiebreaks_1_1.done; floatingTiebreaks_1_1 = floatingTiebreaks_1.next()) {
            var floatingTiebreak = floatingTiebreaks_1_1.value;
            var thisIndex = arrayIndices(floatingTiebreak, parts).filter(function (index) { return !lastIndex || index > lastIndex; })[0];
            var leading = parts.slice(lastIndex, thisIndex - 1);
            var prior = parts[thisIndex - 1];
            var stripped = strip(prior);
            if (/^\d+$/.test(stripped) && stripped.length === 2) {
                var scores = stripped.split('');
                var diff = Math.abs(scores.reduce(function (a, b) { return +a - +b; }));
                if (diff === 1) {
                    var joined = [
                        leading.join(' '),
                        [prior, floatingTiebreak].join(''),
                    ].join(' ');
                    joinedScore += joined;
                    lastIndex = thisIndex + 1;
                }
                else if (diff === 0) {
                    var sameScore = Math.max.apply(Math, __spreadArray([], __read(scores), false));
                    if ([4, 5, 6, 7, 8, 9].includes(sameScore)) {
                        var pairedScore = [6, 4].includes(sameScore)
                            ? sameScore + 1
                            : sameScore - 1;
                        var setScore = [sameScore, pairedScore].sort().reverse().join('-');
                        var joined = [
                            leading.join(' '),
                            [setScore, floatingTiebreak].join(''),
                        ].join(' ');
                        joinedScore += joined;
                        lastIndex = thisIndex + 1;
                    }
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (floatingTiebreaks_1_1 && !floatingTiebreaks_1_1.done && (_b = floatingTiebreaks_1.return)) _b.call(floatingTiebreaks_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (floatingTiebreaks.length && joinedScore.length) {
        var remainder = parts.slice(lastIndex).join(' ');
        joinedScore = [joinedScore, remainder].join(' ');
        return { score: joinedScore.trim() };
    }
    if (parts.length === 2 &&
        ['(', '['].some(function (punctuation) { return parts[1].includes(punctuation); })) {
        var stripped = strip(parts[0]);
        var scores = stripped.split('');
        var diff = Math.abs(scores.reduce(function (a, b) { return +a - +b; }, 0));
        if (diff === 1) {
            parts[1] = bracketToParen(parts[1]);
            return { score: parts.join('') };
        }
    }
    var parenScores = parts.map(function (part) { return (isBracketScore(part) && 'bracket') || (isDiffOne(part) && 'set'); });
    if (parenScores.includes('set') && parenScores.includes('bracket')) {
        var lastPart_1;
        var joinedParts_1 = '';
        parts.forEach(function (part, i) {
            if (parenScores[i] === 'bracket' && lastPart_1 === 'set') {
                part = bracketToParen(part);
                joinedParts_1 += part;
            }
            else {
                joinedParts_1 += " ".concat(part);
            }
            lastPart_1 = parenScores[i];
        });
        return { score: joinedParts_1.trim() };
    }
    // recognize tiebreak scores which look like sets s#-s# tb#-tb#
    parts = score.split(' ');
    var lastSet;
    var profile = parts.map(function (part) {
        var re = new RegExp(/^(\d+)-(\d+)$/); // only consider sets which have no existing tiebreak score
        if (re.test(part)) {
            var _a = __read(part.match(re).slice(1), 2), n1 = _a[0], n2 = _a[1];
            var diff = Math.abs([n1, n2].reduce(function (a, b) { return +a - +b; }));
            var max = Math.max(n1, n2);
            if (diff === 1) {
                lastSet = 'tiebreakSet';
                return lastSet;
            }
            else if (diff >= 2 && max >= 7 && lastSet === 'tiebreakSet') {
                lastSet = 'tiebreak';
                return lastSet;
            }
        }
    });
    var tiebreakIndices = arrayIndices('tiebreak', profile);
    if (tiebreakIndices.length) {
        var joinedParts_2 = '';
        parts.forEach(function (part, i) {
            if (tiebreakIndices.includes(i)) {
                joinedParts_2 += "(".concat(part, ") ");
            }
            else if (tiebreakIndices.includes(i + 1)) {
                joinedParts_2 += "".concat(part);
            }
            else {
                joinedParts_2 += "".concat(part, " ");
            }
        });
        score = joinedParts_2.trim();
    }
    var setCheck = /(\d+-\d+)\((\d+)-(\d+)\)$/;
    if (setCheck.test(score)) {
        var _c = __read(score.match(setCheck).slice(1), 3), setScore = _c[0], t1 = _c[1], t2 = _c[2];
        var maxTiebreakScore = Math.max(t1, t2);
        var potentialSuper = maxTiebreakScore >= 10;
        if (!isDiffOne(setScore) && potentialSuper) {
            score = score.replace(setCheck, "".concat(setScore, " [").concat(t1, "-").concat(t2, "]"));
        }
    }
    profile = [];
    score = score
        .split(' ')
        .map(function (set) {
        var getContained = /^\((.*)\)$/;
        var isContained = getContained.test(set);
        var setType = (new RegExp(matchTiebreak).test(set) && 'super') ||
            (new RegExp(tiebreakSet).test(set) && 'tiebreak') ||
            (new RegExp(standardSet).test(set) && 'standard') ||
            'unknown';
        profile.push(setType);
        if (setType === 'standard' && isContained) {
            return set.match(getContained)[1];
        }
        return set;
    })
        .join(' ');
    return { score: score };
}

function matchKnownPatterns(_a) {
    var e_1, _b, e_2, _c, e_3, _d, e_4, _e;
    var score = _a.score, applied = _a.applied;
    try {
        for (var _f = __values(['.', ',', ' ', '/']), _g = _f.next(); !_g.done; _g = _f.next()) {
            var punctuation = _g.value;
            var re = new RegExp("^(\\d+)\\".concat(punctuation, "(\\d+)$"));
            if (re.test(score)) {
                var numbers = score
                    .match(re)
                    .slice(1)
                    .map(function (n) { return parseInt(n); });
                var diff = Math.abs(numbers[0] - numbers[1]);
                if (diff <= 10 && diff >= 2) {
                    score = score.split(punctuation).join('-');
                    applied.push('variedJoinerPattern');
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (score.includes(';')) {
        score = score.split(';').join(' ');
        applied.push('semicolon set separation');
    }
    var smashSlash = /(^|\s)(\d)\/(\d)(\d)\/(\d)(\(|$)/;
    if (smashSlash.test(score)) {
        var _h = __read(score.match(smashSlash).slice(1), 6), before = _h[0], s1 = _h[1], s2 = _h[2], s3 = _h[3], s4 = _h[4], after = _h[5];
        score = score.replace(smashSlash, "".concat(before).concat(s1, "-").concat(s2, " ").concat(s3, "-").concat(s4).concat(after));
        applied.push('smashSlashPattern');
    }
    var incompleteFinalSet = /.*\s6[/-]+$/;
    if (incompleteFinalSet.test(score)) {
        score += '0';
        applied.push('incompleteFinalSetPattern');
    }
    var missingZero = /\(6,\)/g;
    if (missingZero.test(score)) {
        score = score.replace(missingZero, '(6, 0)');
        applied.push('missingZeroPattern1');
    }
    // insert spaces before and after parentheses
    var noSpacing = /^\d{3,}\(/;
    var parenStart = /\(\d+\)\d+/;
    var considerations = [noSpacing, parenStart];
    considerations.forEach(function () {
        var parts = score.split(' ');
        score = parts
            .map(function (part) {
            if (noSpacing.test(part)) {
                part = part.replace('(', ' (');
            }
            if (parenStart.test(part)) {
                part = part.replace(')', ') ');
            }
            return part;
        })
            .join(' ');
        applied.push('spaceConsiderationPatterns');
    });
    var deDashMash = dashMash(score);
    if (deDashMash !== score) {
        score = deDashMash;
        applied.push('deDashMash');
    }
    var smashedSets = /^(\d)[-/,]+(\d{2})[-/,]+(\d)$/;
    if (smashedSets.test(score)) {
        var _j = __read(score.match(smashedSets).slice(1), 3), s1 = _j[0], ss = _j[1], s4 = _j[2];
        var _k = __read(ss.split(''), 2), s2 = _k[0], s3 = _k[1];
        score = "".concat(s1, "-").concat(s2, " ").concat(s3, "-").concat(s4);
        applied.push('smashSetPattern');
    }
    var setSpacing = /^(\d+)[ -](\d+)$/;
    var slashSeparation = /^([\d -]+)\/([\d -]+)$/;
    if (slashSeparation.test(score)) {
        var _l = __read(score.match(slashSeparation).slice(1), 2), left = _l[0], right = _l[1];
        var s1 = left.trim();
        var s2 = right.trim();
        if (setSpacing.test(s1) && setSpacing.test(s2)) {
            var set1 = s1.match(setSpacing).slice(1, 3).join('-');
            var set2 = s2.match(setSpacing).slice(1, 3).join('-');
            score = "".concat(set1, " ").concat(set2);
            applied.push('slashSeparationPattern');
        }
    }
    var commaSeparation = /^([\d -]+),([\d -]+)$/;
    if (commaSeparation.test(score)) {
        var _m = __read(score.match(commaSeparation).slice(1), 2), left = _m[0], right = _m[1];
        var s1 = left.trim();
        var s2 = right.trim();
        if (setSpacing.test(s1) && setSpacing.test(s2)) {
            var set1 = s1.match(setSpacing).slice(1, 3).join('-');
            var set2 = s2.match(setSpacing).slice(1, 3).join('-');
            score = "".concat(set1, " ").concat(set2);
            applied.push('commaSeparationPattern');
        }
    }
    var singleSetCommaSeparation = /^\d \d,/;
    if (singleSetCommaSeparation.test(score)) {
        var set = score.match(singleSetCommaSeparation)[0];
        var replacement = set
            .slice(0, set.length - 1)
            .split(' ')
            .join('-');
        score = score.replace(set, replacement);
        applied.push('singleSetCommaSeparationPattern');
    }
    // pattern \d+-\d{2}-\d+ => \d-\d \d-\d
    var failSafe = 0;
    var noSetSeparation = /(\d+)-(\d{2})-(\d+)/;
    while (noSetSeparation.test(score) && failSafe < 3) {
        var _o = __read(score.match(noSetSeparation).slice(1), 3), left = _o[0], middle = _o[1], right = _o[2];
        var separated = middle.split('');
        var reformatted = "".concat(left, "-").concat(separated[0], " ").concat(separated[1], "-").concat(right);
        score = score.replace(noSetSeparation, reformatted);
        applied.push('noSetSeparationPattern');
        failSafe += 1;
    }
    var getFloatingTiebreaks = /(^|\s)7-6\s(\d+)\s/g;
    var floatingTiebreaks = score.match(getFloatingTiebreaks);
    if (floatingTiebreaks === null || floatingTiebreaks === void 0 ? void 0 : floatingTiebreaks.length) {
        var getFloatingTiebreak_1 = /(^|\s)7-6\s(\d+)\s/;
        floatingTiebreaks.forEach(function (floater) {
            var tiebreakScore = floater.match(getFloatingTiebreak_1).slice(2)[0];
            score = score.replace(floater, "7-6(".concat(tiebreakScore, ") "));
            applied.push('floatingTiebreakPattern1');
        });
    }
    var spaceSeparatedSets = score.match(/\d \d /);
    spaceSeparatedSets === null || spaceSeparatedSets === void 0 ? void 0 : spaceSeparatedSets.forEach(function (ss) {
        var replacement = ss
            .slice(0, ss.length - 1)
            .split(' ')
            .join('-');
        score = score.replace(ss, replacement);
        applied.push('spaceSeparatedSetPattern1');
    });
    spaceSeparatedSets = score.match(/ \d \d$/);
    spaceSeparatedSets === null || spaceSeparatedSets === void 0 ? void 0 : spaceSeparatedSets.forEach(function (ss) {
        var replacement = ' ' + ss.slice(1).split(' ').join('-');
        score = score.replace(ss, replacement);
        applied.push('spaceSeparatedSetPattern2');
    });
    // slash separated sets with comma separated games
    // pattern /\d+,\s?\d/+\/\d+\s?\d+/
    var slashCommaSets = /^\d, *\d\/\d, *\d/;
    if (slashCommaSets.test(score)) {
        var excerpt = score.match(slashCommaSets)[0];
        var replacement = excerpt
            .split('/')
            .map(function (e) { return "(".concat(e, ")"); })
            .join(' ') + ' ';
        score = score.replace(excerpt, replacement);
        applied.push('slashCommaSetPattern');
    }
    var missedSet0 = /\(6-\)/g;
    if (missedSet0.test(score)) {
        score = score.replace(missedSet0, '(6-0)');
        applied.push('missingZeroPattern2');
    }
    // IMPORTANT: must occur last...
    var slashSetGlobal = /(?<!-)(\d+)\/(\d+)(?!-)/g;
    if (slashSetGlobal.test(score)) {
        var slashSets = score.match(slashSetGlobal);
        var slashSet_1 = /(?<!-)(\d+)\/(\d+)(?!-)/;
        var newScore_1 = score;
        slashSets.forEach(function (set) {
            var _a = __read(set.match(slashSet_1).slice(1), 2), s1 = _a[0], s2 = _a[1];
            var dashSet = "".concat(s1, "-").concat(s2);
            newScore_1 = newScore_1.replace(set, dashSet);
        });
        score = newScore_1;
        applied.push('slashSetPattern');
    }
    // space separated match tiebreak
    var spaceSeparatedSuper = /(.*)\s(1\d)\s(\d+)$/;
    if (spaceSeparatedSuper.test(score)) {
        var _p = __read(score.match(spaceSeparatedSuper).slice(1), 3), start = _p[0], s1 = _p[1], s2 = _p[2];
        var digitCount = start.replace(/\D/g, '').length;
        if (digitCount >= 4) {
            score = start + " ".concat(s1).concat(s2);
            applied.push('spaceSeparatedSuperPattern');
        }
    }
    // space separated set tiebreak
    // #-# # => #-#(#) with boundary constraints
    var spaceSeparatedSetTB = /(^|\s)(\d+-\d+)\s(\d+)(\s|$)/g;
    try {
        for (var _q = __values(score.match(spaceSeparatedSetTB) || []), _r = _q.next(); !_r.done; _r = _q.next()) {
            var ssb = _r.value;
            var _s = __read(ssb
                .match(/(^|\s)(\d+-\d+)\s(\d+)(\s|$)/)
                .slice(1), 4), before = _s[0], setScore = _s[1], tb = _s[2], after = _s[3];
            var _t = __read(setScore.split('-').map(function (s) { return parseInt(s); }), 2), s1 = _t[0], s2 = _t[1];
            var diff = Math.abs(s1 - s2);
            if (diff === 1) {
                score = score.replace(ssb, "".concat(before).concat(setScore, "(").concat(tb, ")").concat(after));
                applied.push('spaceSeparatedSetPattern');
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_r && !_r.done && (_c = _q.return)) _c.call(_q);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var getFloaters = /\d-\d \(\d{1,2}\)(\s|$|,)/g;
    try {
        for (var _u = __values(score.match(getFloaters) || []), _v = _u.next(); !_v.done; _v = _u.next()) {
            var floater = _v.value;
            var getFloater = /(\d-\d) \((\d{1,2})\)(\s|$|,)/;
            var _w = __read(floater.match(getFloater).slice(1), 3), setScore = _w[0], tb = _w[1], tail = _w[2];
            var _x = __read(setScore.split('-').map(function (s) { return parseInt(s); }), 2), s1 = _x[0], s2 = _x[1];
            var diff = Math.abs(s1 - s2);
            if (diff === 1) {
                score = score.replace(floater, "".concat(setScore, "(").concat(tb, ")").concat(tail));
                applied.push('floatingTiebreakPattern2');
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_v && !_v.done && (_d = _u.return)) _d.call(_u);
        }
        finally { if (e_3) throw e_3.error; }
    }
    var getSpacedTibreakSets = /(^|\s)(\d \d)\(/g;
    try {
        for (var _y = __values(score.match(getSpacedTibreakSets) || []), _z = _y.next(); !_z.done; _z = _y.next()) {
            var spacedTB = _z.value;
            var getSpacedTibreakSet = /(^|\s)(\d \d)\(/;
            var _0 = __read(spacedTB.match(getSpacedTibreakSet).slice(1), 2), before = _0[0], spacedScore = _0[1];
            score = score.replace(spacedTB, "".concat(before).concat(spacedScore.split(' ').join('-'), "("));
            applied.push('spacedTiebreakPattern');
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_z && !_z.done && (_e = _y.return)) _e.call(_y);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return { score: score, applied: applied };
}

function properTiebreak(_a) {
    var e_1, _b;
    var _c;
    var score = _a.score, matchUpStatus = _a.matchUpStatus;
    var parts = score === null || score === void 0 ? void 0 : score.split(' ');
    score = parts
        .map(function (part) {
        if (part.endsWith(']')) {
            var setScores = part.split('[');
            if (isDiffOne(setScores[0])) {
                return (setScores[0] + "(".concat(setScores[1].slice(0, setScores[1].length - 1), ")"));
            }
        }
        return part;
    })
        .join(' ');
    var tb = new RegExp(/(\([\d ]+\))/g);
    // const tb = new RegExp(/(\([\d+ ]+\))/g);
    if (tb.test(score)) {
        try {
            // handle tiebreak score which has no delimiter
            for (var _d = __values(score.match(tb)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var t = _e.value;
                var replacement = t.replace(' ', '-');
                // score = score.replace(t, replacement);
                var tiebreakScore = (_c = replacement.match(/\((.*)\)/)) === null || _c === void 0 ? void 0 : _c[1];
                if (isNumeric(tiebreakScore) && (tiebreakScore === null || tiebreakScore === void 0 ? void 0 : tiebreakScore[0]) > 2) {
                    if ([2, 4].includes(tiebreakScore.length)) {
                        tiebreakScore = tiebreakScore.split('').join('-');
                    }
                    else if (tiebreakScore.length === 3) {
                        var oneIndex = tiebreakScore.indexOf('1');
                        tiebreakScore = getSuper(tiebreakScore.split(''), oneIndex);
                    }
                }
                score = score.replace(t, "(".concat(tiebreakScore, ")"));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    parts = score === null || score === void 0 ? void 0 : score.split(' ');
    // handles tiebreaks (#-#) or (#/#)
    var re = new RegExp(/^(\d[-/]+\d)\((\d+)[-/]+(\d+)\)$/);
    var lastIndex = parts.length - 1;
    score = parts
        .map(function (part, index) {
        var considerCompleted = [undefined, '', 'COMPLETED'].includes(matchUpStatus) ||
            index !== lastIndex;
        if (re.test(part) && considerCompleted) {
            var _a = __read(Array.from(part.match(re)).slice(1), 3), set = _a[0], tb1 = _a[1], tb2 = _a[2];
            var lowTiebreakScore = Math.min(tb1, tb2);
            return "".concat(set, "(").concat(lowTiebreakScore, ")");
        }
        return part;
    })
        .join(' ');
    // convert ##(#) => #-#(#)
    parts = score === null || score === void 0 ? void 0 : score.split(' ');
    re = new RegExp(/^(\d{2})\((\d+)\)$/);
    score = parts
        .map(function (part) {
        if (re.test(part)) {
            var _a = __read(Array.from(part.match(re)).slice(1), 2), set = _a[0], lowTiebreakScore = _a[1];
            var setScores = set.split('');
            return "".concat(setScores[0], "-").concat(setScores[1], "(").concat(lowTiebreakScore, ")");
        }
        return part;
    })
        .join(' ');
    // convert (#-#)# to #-#(#)
    parts = score === null || score === void 0 ? void 0 : score.split(' ');
    re = new RegExp(/^\((\d[-/]+\d)\)(\d+)$/);
    score = parts
        .map(function (part) {
        if (re.test(part)) {
            var _a = __read(Array.from(part.match(re)).slice(1), 2), set = _a[0], lowTiebreakScore = _a[1];
            if (isDiffOne(set)) {
                return "".concat(set, "(").concat(lowTiebreakScore, ")");
            }
            else {
                // discard the number outside the bracket as erroneous
                return set;
            }
        }
        return part;
    })
        .join(' ');
    // convert 1-0(#) to super tiebreak
    parts = score === null || score === void 0 ? void 0 : score.split(' ');
    re = new RegExp(/^1-0\((\d+)\)$/);
    score = parts
        .map(function (part) {
        if (re.test(part)) {
            var _a = __read(part.match(re).slice(1), 1), lowTiebreakScore = _a[0];
            var hightiebreakScore = lowTiebreakScore < 9 ? 10 : parseInt(lowTiebreakScore) + 2;
            return "[".concat(hightiebreakScore, "-").concat(lowTiebreakScore, "]");
        }
        return part;
    })
        .join(' ');
    // (#0, => (#) // ')' mistyped as '0'
    var misTyped0 = /\((\d)+0 /;
    if (misTyped0.test(score)) {
        var value = score.match(misTyped0)[1];
        score = score.replace(misTyped0, "(".concat(value, ") "));
    }
    return { score: score };
}

function containedSets(_a) {
    var e_1, _b;
    var _c;
    var score = _a.score, attributes = _a.attributes, identifier = _a.identifier;
    if (typeof score !== 'string')
        return { score: score, identifier: identifier };
    var withParens = new RegExp(/\([\d,/ ]+\)/g);
    var contained = score.match(withParens);
    try {
        for (var _d = __values(contained || []), _e = _d.next(); !_e.done; _e = _d.next()) {
            var container = _e.value;
            var matched = container.match(/^\((.*)\)$/);
            var innards = (_c = matched === null || matched === void 0 ? void 0 : matched.slice(1)) === null || _c === void 0 ? void 0 : _c[0];
            // don't split double digits if they follow digits with diff 1
            var before = score.split(container)[0];
            var priorDigits = before.split(')').reverse()[0].replace(/\D/g, '');
            if ((innards === null || innards === void 0 ? void 0 : innards.length) === 2 && (priorDigits === null || priorDigits === void 0 ? void 0 : priorDigits.length) >= 2) {
                var priorTwo = priorDigits
                    .slice(priorDigits.length - 2)
                    .split('')
                    .map(function (d) { return parseInt(d); });
                var diff = Math.abs(priorTwo[0] - priorTwo[1]);
                if (diff === 1)
                    continue;
            }
            var joined = dashJoin(innards);
            var mashed = dashMash(joined);
            score = score.replace(container, "(".concat(mashed, ")")).trim();
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var withBrackets = new RegExp(/\[[\d,/ ]+\]/g);
    var bracketed = score.match(withBrackets);
    bracketed === null || bracketed === void 0 ? void 0 : bracketed.forEach(function (container) {
        var innards = dashJoin(container.match(/^\[(.*)\]$/)[1]);
        score = score.replace(container, "(".concat(innards, ") ")).trim();
    });
    var potentialEndings = [')', ']'];
    var potentialMiddles = [')(', '), (', ') (', ')[', ") [", '](', '] ('];
    if (score.startsWith('(') &&
        potentialEndings.some(function (ending) { return score.endsWith(ending); }) &&
        potentialMiddles.some(function (middle) { return score.includes(middle); })) {
        var newScore_1 = '';
        var parts = score
            .split(/[)\]]/)
            .filter(Boolean)
            .map(function (part) {
            if (part.startsWith(','))
                part = part.slice(1);
            return part.trim();
        });
        var commadDelimited = parts.every(function (part) { return part.includes(',') || isTiebreakScore(part); });
        var slashDelimited = parts.every(function (part) { return part.includes('/') || isTiebreakScore(part); });
        var dashDelimited = parts.every(function (part) { return part.includes('-') || isTiebreakScore(part); });
        var delimiter_1 = (commadDelimited && ',') ||
            (dashDelimited && '-') ||
            (slashDelimited && '/');
        if (delimiter_1) {
            var lastPart_1;
            parts.forEach(function (part) {
                if (part.startsWith('(')) {
                    // is a set score
                    if (lastPart_1 === 'set')
                        newScore_1 += ' ';
                    if (part.includes(delimiter_1)) {
                        newScore_1 += part
                            .slice(1)
                            .split(delimiter_1)
                            .map(function (s) { return s.trim(); })
                            .join('-');
                        lastPart_1 = 'set';
                    }
                    else {
                        var value = part.slice(1);
                        newScore_1 += "(".concat(value, ") ");
                        lastPart_1 = 'tiebreak';
                    }
                }
                else if (part.startsWith('[')) {
                    var values = part
                        .slice(1)
                        .split(delimiter_1)
                        .map(function (s) { return parseInt(s.trim()); });
                    var highValue = Math.min.apply(Math, __spreadArray([], __read(values), false));
                    // is a tiebreak score
                    if (lastPart_1 === 'set') {
                        newScore_1 += "(".concat(highValue, ") ");
                    }
                    else {
                        newScore_1 += "[".concat(values.join('-'), "] ");
                    }
                    lastPart_1 = 'tiebreak';
                }
            });
            score = newScore_1.trim();
        }
    }
    var counts = instanceCount(score.split(''));
    if (counts['('] === 1 &&
        counts[')'] === 1 &&
        score.startsWith('(') &&
        score.endsWith(')')) {
        score = score.slice(1, score.length - 1);
        // is a tiebreakSet; check for valid removed tiebreak value
        if (counts['-'] === 1 &&
            isDiffOne(score) &&
            isNumeric(attributes === null || attributes === void 0 ? void 0 : attributes.removed)) {
            score = score + "(".concat(attributes.removed, ")");
            attributes.removed = undefined;
        }
    }
    var emptyParens = /\(\)/g;
    if (emptyParens.test(score)) {
        score = score.replace(emptyParens, '').trim();
    }
    return { score: score };
}

function setBuilder(_a) {
    var score = _a.score;
    var chars = score.split('');
    var sets = [];
    var set;
    var resetSet = function () { return (set = [undefined, undefined, undefined]); };
    var completeSet = function () {
        var joinedSet = "".concat(set[0], "-").concat(set[1]);
        if (set[2])
            joinedSet += " (".concat(set[2], ")");
        resetSet();
        set.push(set);
        return joinedSet;
    };
    resetSet();
    // let tiebreak = '';
    var getDiff = function () {
        return (set[0] !== undefined &&
            set[1] !== undefined &&
            Math.abs(parseInt(set[0]) - parseInt(set[1])));
    };
    while (chars.length) {
        var char = chars.shift();
        var digit = isNumeric(char) && parseInt(char);
        var twoSetScores = set[0] !== undefined && set[1] !== undefined;
        if (isNumeric(digit)) {
            if (set[0] === undefined) {
                set[0] = digit;
                continue;
            }
            if (set[1] === undefined) {
                set[1] = digit;
                if (getDiff() || 0 > 1) {
                    sets.push(completeSet());
                    set = [undefined, undefined];
                    continue;
                }
            }
            if (twoSetScores && chars.length === 1 && isNumeric(chars[0])) {
                var lastChar = chars.pop();
                set[0] = set[0].toString() + set[1].toString();
                set[1] = lastChar;
                sets.push(completeSet());
                set = [undefined, undefined];
            }
            if (twoSetScores && getDiff() === 1) ;
            // const diff = getDiff();
        }
    }
    return { sets: sets };
}

function parseSuper(score) {
    var oneIndex = score.indexOf('1');
    var numbers = score.split('');
    var allNumeric = numbers.every(function (n) { return !isNaN(n); });
    if (allNumeric && score.length === 3 && oneIndex === 0) {
        var superTiebreak = getSuper(numbers, oneIndex);
        if (superTiebreak)
            return superTiebreak;
    }
    if (allNumeric && score.length === 7 && oneIndex > 3) {
        var tiebreak = numbers.slice(4);
        var superTiebreak = getSuper(tiebreak, oneIndex - 4);
        if (superTiebreak) {
            return "".concat(numbers[0], "-").concat(numbers[1], " ").concat(numbers[2], "-").concat(numbers[3], " ").concat(superTiebreak);
        }
    }
    return undefined;
}

function handleNumeric(params) {
    var score = params.score;
    var applied = params.applied, matchUpStatus = params.matchUpStatus;
    var onlyNumbers = score === null || score === void 0 ? void 0 : score.toString().split('');
    var allNumeric = onlyNumbers === null || onlyNumbers === void 0 ? void 0 : onlyNumbers.every(function (d) { return isNumeric(d); });
    var getDiff = function (values) { return Math.abs(values[0] - values[1]); };
    if (typeof score === 'number' || allNumeric) {
        score = score.toString().toLowerCase();
        if (allNumeric)
            score = onlyNumbers.join('');
        var numbers = allNumeric
            ? onlyNumbers.map(function (n) { return parseInt(n); })
            : score.split('').map(function (n) { return parseInt(n); });
        setBuilder({ score: score }).sets;
        if (numbers.length === 6) ;
        if (score.length === 3 && getDiff(numbers.slice(0, 2)) === 1) {
            var _a = __read(numbers, 3), s1 = _a[0], s2 = _a[1], tb = _a[2];
            score = "".concat(s1, "-").concat(s2, "(").concat(tb, ")");
            applied.push('numericTiebreakPattern1');
        }
        else if (score.length === 3 && numbers[0] === 1) {
            var _b = __read(numbers, 3), mtb1 = _b[0], mtb2 = _b[1], mtb3 = _b[2];
            score = "[".concat(mtb1).concat(mtb2, "-").concat(mtb3, "]");
            applied.push('numericTiebreakPattern2');
        }
        else if (score.length === 4 &&
            getDiff(numbers.slice(0, 2)) === 1 &&
            '987654'.split('').includes(numbers[0].toString())) {
            var _c = __read(numbers, 4), s1 = _c[0], s2 = _c[1], tb1 = _c[2], tb2 = _c[3];
            var tb = Math.min(tb1, tb2);
            score = "".concat(s1, "-").concat(s2, "(").concat(tb, ")");
            applied.push('numericTiebreakPattern3');
        }
        else if (score.length === 4 && numbers[0] === 1 && numbers[2] === 1) {
            var _d = __read(numbers, 4), tb1 = _d[0], tb2 = _d[1], tb3 = _d[2], tb4 = _d[3];
            score = "[".concat(tb1).concat(tb2, "-").concat(tb3).concat(tb4, "]");
            applied.push('bigSuper');
        }
        else if (score.length === 4) {
            var _e = __read(numbers, 4), s1 = _e[0], s2 = _e[1], s3 = _e[2], s4 = _e[3];
            score = "".concat(s1).concat(s2, " ").concat(s3).concat(s4);
            applied.push('split4');
        }
        else if (score.length === 5 && getDiff(numbers.slice(0, 2)) === 1) {
            var _f = __read(numbers, 5), s1 = _f[0], s2 = _f[1], tb = _f[2], s3 = _f[3], s4 = _f[4];
            score = "".concat(s1, "-").concat(s2, "(").concat(tb, ") ").concat(s3, "-").concat(s4);
            applied.push('numericTiebreakPattern4');
        }
        else if (score.length === 5 && getDiff(numbers.slice(3)) === 1) {
            var _g = __read(numbers, 5), s1 = _g[0], s2 = _g[1], s3 = _g[2], s4 = _g[3], tb = _g[4];
            score = "".concat(s1, "-").concat(s2, " ").concat(s3, "-").concat(s4, "(").concat(tb, ")");
            applied.push('numericTiebreakPattern5');
        }
        else if (numbers.length === 7) {
            if (getDiff(numbers.slice(0, 2)) > 1 &&
                getDiff(numbers.slice(2, 4)) > 1 &&
                numbers[4] === 1) {
                var _h = __read(numbers, 7), s1 = _h[0], s2 = _h[1], s3 = _h[2], s4 = _h[3], mtb1 = _h[4], mtb2 = _h[5], mtb3 = _h[6];
                score = "".concat(s1, "-").concat(s2, " ").concat(s3, "-").concat(s4, " [").concat(mtb1).concat(mtb2, "-").concat(mtb3, "]");
                applied.push('numericTiebreakPattern6');
            }
            else if (getDiff(numbers.slice(0, 2)) === 1 &&
                getDiff(numbers.slice(3, 5)) > 1 &&
                getDiff(numbers.slice(5, 7)) > 1) {
                var _j = __read(numbers, 7), s1 = _j[0], s2 = _j[1], tb = _j[2], s3 = _j[3], s4 = _j[4], s5 = _j[5], s6 = _j[6];
                score = "".concat(s1, "-").concat(s2, "(").concat(tb, ") ").concat(s3, "-").concat(s4, " ").concat(s5, "-").concat(s6);
                applied.push('numericTiebreakPattern7');
            }
            else if (getDiff(numbers.slice(0, 2)) > 1 &&
                getDiff(numbers.slice(2, 4)) === 1 &&
                getDiff(numbers.slice(5, 7)) > 1) {
                var _k = __read(numbers, 7), s1 = _k[0], s2 = _k[1], s3 = _k[2], s4 = _k[3], tb = _k[4], s5 = _k[5], s6 = _k[6];
                /**
                if (tb === 1) {
                  score = `${s1}-${s2} ${s3}-${s4} [${tb}${s5}-${s6}]`;
                  applied.push('numericTiebreakPattern8');
                } else {
                */
                score = "".concat(s1, "-").concat(s2, " ").concat(s3, "-").concat(s4, "(").concat(tb, ") ").concat(s5, "-").concat(s6);
                applied.push('numericTiebreakPattern8');
                //}
            }
            else if (getDiff(numbers.slice(0, 2)) > 1 &&
                getDiff(numbers.slice(2, 4)) > 1 &&
                getDiff(numbers.slice(4, 6)) === 1) {
                var _l = __read(numbers, 7), s1 = _l[0], s2 = _l[1], s3 = _l[2], s4 = _l[3], s5 = _l[4], s6 = _l[5], tb = _l[6];
                score = "".concat(s1, "-").concat(s2, " ").concat(s3, "-").concat(s4, " ").concat(s5, "-").concat(s6, "(").concat(tb, ")");
                applied.push('numericTiebreakPattern9');
            }
            else {
                score =
                    score.slice(0, 2) + ' ' + score.slice(2, 4) + ' ' + score.slice(4);
                applied.push('numericMatchTiebreakPattern');
            }
        }
        else if (!(score.length % 2)) {
            var chunks = chunkArray(score.split(''), 2).map(function (part) {
                return part.join('');
            });
            var chunkCharacter = chunks.map(function (chunk) {
                var _a = __read(chunk.split('').map(function (s) { return parseInt(s); }), 2), s1 = _a[0], s2 = _a[1];
                var diff = Math.abs(s1 - s2);
                var winner = s1 > s2 ? 1 : 2;
                return (diff > 1 && winner) || winner * -1;
            });
            var allWinners = chunkCharacter.reduce(function (a, b) { return a > 0 && b > 0; }, 1);
            var instances = instanceCount(chunkCharacter);
            var positiveCharacter = chunkCharacter.map(function (c) { return Math.abs(c); });
            var positiveInstances = instanceCount(positiveCharacter);
            var set1tb = chunkCharacter[0] < 0;
            var set2tb = !set1tb && chunkCharacter[1] < 0;
            if (chunkCharacter[0] > 0 &&
                chunkCharacter[1] > 0 &&
                chunkCharacter[0] !== chunkCharacter[1]) {
                score = [chunks.slice(0, 2).join(' '), chunks.slice(2).join('-')].join(' ');
                applied.push('numeric3rdSetTiebreakPattern');
            }
            else if (allWinners) {
                score = chunks.join(' ');
                applied.push('chunkSplit');
            }
            else if (numbers.length == 6) {
                if (instances[1] == 2 || instances[2] === 2) {
                    if (!Object.values(positiveInstances).includes(3)) {
                        score = chunks.join(' ');
                        applied.push('chunkSplit');
                    }
                    else {
                        var _m = __read(numbers, 6), n1 = _m[0], n2 = _m[1], n3 = _m[2], n4 = _m[3], n5 = _m[4], n6 = _m[5];
                        var tiebreakChunkIndex = chunkCharacter.reduce(function (index, chunk, i) { return (chunk < 0 ? i : index); }, undefined);
                        if (tiebreakChunkIndex === 0) {
                            var tb = Math.min(n3, n4);
                            score = "".concat(n1, "-").concat(n2, "(").concat(tb, ") ").concat(n5, "-").concat(n6);
                            applied.push('chunkSplitTiebreak1');
                        }
                        else if (tiebreakChunkIndex === 1) {
                            var tb = Math.min(n5, n6);
                            score = "".concat(n1, "-").concat(n2, " ").concat(n3, "-").concat(n4, "(").concat(tb, ")");
                            applied.push('chunkSplitTiebreak2');
                        }
                        else {
                            score = "".concat(n1, "-").concat(n2, " ").concat(n3, "-").concat(n4);
                            applied.push('chunkSplitTrimExtraneous');
                        }
                    }
                }
            }
            else if (numbers.length === 8) {
                var _o = __read(numbers, 8), n1 = _o[0], n2 = _o[1], n3 = _o[2], n4 = _o[3], n5 = _o[4], n6 = _o[5], n7 = _o[6], n8 = _o[7];
                if (set1tb || set2tb) {
                    // there is a tiebreak in the first two sets
                    // remaining 3 digits can be super or another tiebreak set
                    if (numbers[5] === 1) {
                        // 3rd set match tiebreak
                        if (set1tb) {
                            score = "".concat(n1, "-").concat(n2, "(").concat(n3, ") ").concat(n4, "-").concat(n5, " [").concat(n6).concat(n7, "-").concat(n8, "]");
                        }
                        else {
                            score = "".concat(n1, "-").concat(n2, " ").concat(n3, "-").concat(n4, "(").concat(n5, ") [").concat(n6).concat(n7, "-").concat(n8, "]");
                        }
                    }
                }
                else if (chunkCharacter[0] !== chunkCharacter[1]) ;
            }
        }
        else {
            var superParse = parseSuper(score);
            if (superParse && score !== superParse) {
                applied.push('parsedSuperPattern');
            }
            score = superParse !== null && superParse !== void 0 ? superParse : score;
        }
    }
    return { score: score, applied: applied, matchUpStatus: matchUpStatus };
}

function getWinningSide$1(score) {
    var setsWon = [0, 0];
    var setWinners = [];
    var sets = score.split(' ');
    var getSetScores = /(\d+)-(\d+)/;
    sets.forEach(function (set) {
        if (getSetScores.test(set)) {
            var setScores = set
                .match(getSetScores)
                .slice(1)
                .map(function (s) { return parseInt(s); });
            var winningSide_1 = (setScores[0] > setScores[1] && 1) ||
                (setScores[1] > setScores[0] && 2);
            if (winningSide_1) {
                setsWon[winningSide_1 - 1] += 1;
                setWinners.push(winningSide_1);
            }
        }
    });
    var winningSide = (setsWon[0] > setsWon[1] && 1) || (setsWon[1] > setsWon[0] && 2);
    var setsTied = setsWon[0] > 0 && setsWon[0] === setsWon[1];
    var totalSets = setsWon.reduce(function (a, b) { return a + b; }, 0);
    return { setsWon: setsWon, setsTied: setsTied, setWinners: setWinners, totalSets: totalSets, winningSide: winningSide };
}

function sensibleSets(_a) {
    var score = _a.score, matchUpStatus = _a.matchUpStatus, attributes = _a.attributes;
    var profile = [];
    var maxSetValue;
    var sets = score.split(' ');
    var setsCount = sets.length;
    score = sets
        .map(function (set, index) {
        var _a;
        if (new RegExp(tiebreakSet).test(set)) {
            var tiebreak = set.slice(3);
            var setScores = set.slice(0, 3);
            var sideScores = setScores.split('-');
            if (!isDiffOne(setScores) && !matchUpStatus) {
                var maxSetScore = Math.max.apply(Math, __spreadArray([], __read(sideScores), false));
                var maxIndex = setScores.indexOf(maxSetScore);
                var sensibleSetScores = [maxSetScore, maxSetScore - 1];
                if (maxIndex)
                    sensibleSetScores.reverse();
                var sensibleSetScore = sensibleSetScores.join('-');
                return sensibleSetScore + tiebreak;
            }
        }
        else if (set.length === 2 && isNumeric(set)) {
            return set.split('').join('-');
        }
        set = dashMash(set);
        var setType = (new RegExp("^".concat(matchTiebreak, "$")).test(set) && 'super') ||
            (new RegExp("^".concat(tiebreakSet, "$")).test(set) && 'tiebreak') ||
            (new RegExp("^".concat(standardSet, "$")).test(set) && 'standard') ||
            'unknown';
        profile.push(setType);
        // check for reasonable set scores in the first two sets
        if (setsCount > 1 && setType === 'standard' && index < 2) {
            var _b = __read(set.split('-'), 2), s1 = _b[0], s2 = _b[1];
            var diff = Math.abs(parseInt(s1) - parseInt(s2));
            var max = Math.max(s1, s2);
            var min_1 = Math.min(s1, s2);
            var minIndex = [parseInt(s1), parseInt(s2)].indexOf(min_1);
            // identify problematic score
            // coerce larger value to something reasonable
            if (max > 9 && diff > 2) {
                var splitMax = max.toString().split('');
                var reasonable = (_a = splitMax.find(function (value) {
                    return parseInt(value) > min_1 ||
                        (index && parseInt(value) <= maxSetValue);
                })) !== null && _a !== void 0 ? _a : splitMax[0];
                if (reasonable) {
                    set = minIndex
                        ? [reasonable, min_1].join('-')
                        : [min_1, reasonable].join('-');
                }
            }
            if (max > (maxSetValue || 0))
                maxSetValue = max;
        }
        // throw out any sets where the values are equal and there is no retirement
        if (setType === 'standard') {
            var _c = __read(set.split('-'), 2), s1 = _c[0], s2 = _c[1];
            var diff = Math.abs(parseInt(s1) - parseInt(s2));
            if (!diff && matchUpStatus !== 'RETIRED') {
                return '';
            }
        }
        return set;
    })
        .filter(Boolean)
        .join(' ');
    var _b = getWinningSide$1(score), setsWon = _b.setsWon, setWinners = _b.setWinners, totalSets = _b.totalSets;
    // if there was a 6 removed from the end of the score and there is only one set...
    if (totalSets === 1 && (attributes === null || attributes === void 0 ? void 0 : attributes.removed) === '6') {
        score += ' 6-0';
    }
    // if a side won the first two sets and there are more than 2 sets, trim the score
    if (score.split(' ').length > 2 &&
        Math.max.apply(Math, __spreadArray([], __read(setsWon), false)) >= 2 &&
        setWinners[0] === setWinners[1]) {
        score = score.split(' ').slice(0, 2).join(' ');
    }
    if (Math.max.apply(Math, __spreadArray([], __read(setsWon), false)) > 2) {
        var counts_1 = [0, 0];
        score = score
            .split(' ')
            .map(function (set, i) {
            counts_1[setWinners[i]] += 1;
            return Math.max.apply(Math, __spreadArray([], __read(counts_1), false)) > 2 ? undefined : set;
        })
            .filter(Boolean)
            .join(' ');
    }
    return { score: score, profile: profile };
}

function superSquare(_a) {
    var score = _a.score;
    var _b = getWinningSide$1(score), setsTied = _b.setsTied, winningSide = _b.winningSide;
    // when final set is (#) match tiebreak
    var finalSetMatchTiebreak = /\s\((\d+)\)$/;
    if (!winningSide && setsTied && finalSetMatchTiebreak.test(score)) {
        var lowTiebreakScore = score.match(finalSetMatchTiebreak).slice(1)[0];
        var highTiebreakScore = lowTiebreakScore <= 8 ? 10 : lowTiebreakScore + 2;
        score = score.replace(finalSetMatchTiebreak, " [".concat(highTiebreakScore, "-").concat(lowTiebreakScore, "]"));
    }
    var sets = score.split(' ');
    var finalSet = sets[sets.length - 1];
    if (!finalSet.includes('-') || finalSet.indexOf('(') > 0)
        return { score: score };
    var scores = finalSet.split('(').join('').split(')').join('').split('-');
    if (!scores.every(function (score) { return isNumeric(score); }))
        return { score: score };
    if (scores[0] === '76') {
        var tb = scores[1].length === 2
            ? Math.min.apply(Math, __spreadArray([], __read(scores[1].split('').map(function (n) { return parseInt(n); })), false)) : scores[1];
        score = __spreadArray(__spreadArray([], __read(sets.slice(0, sets.length - 1)), false), ["7-6(".concat(tb, ")")], false).join(' ');
    }
    else {
        scores = scores.map(function (score) { return parseInt(score); });
        var maxSetScore_1 = Math.max.apply(Math, __spreadArray([], __read(scores), false));
        var diff = Math.abs(scores[0] - scores[1]);
        if (maxSetScore_1 >= 10) {
            // if both scores are greater than 10 and diff > 2 then attempt to modify
            if (diff > 2 && scores.every(function (s) { return +s >= 10; })) {
                var modifiedScores = scores
                    .map(function (s) { return (s === maxSetScore_1 ? s - 10 : 10); })
                    .sort();
                diff = Math.abs(modifiedScores[0] - modifiedScores[1]);
                if (diff > 2)
                    scores = modifiedScores;
            }
            score = __spreadArray(__spreadArray([], __read(sets.slice(0, sets.length - 1)), false), ["[".concat(scores.join('-'), "]")], false).join(' ');
        }
        else if (sets.length === 3 && maxSetScore_1 >= 7 && diff > 2) {
            score = __spreadArray(__spreadArray([], __read(sets.slice(0, sets.length - 1)), false), ["[".concat(scores.join('-'), "]")], false).join(' ');
        }
    }
    return { score: score };
}

function stringScore(_a) {
    var score = _a.score;
    score = (score === null || score === void 0 ? void 0 : score.toString().toLowerCase()) || '';
    return { score: score };
}
function replaceOh(_a) {
    var score = _a.score, applied = _a.applied;
    if (typeof score !== 'string')
        return { score: score };
    if (score.toLowerCase().includes('o')) {
        score = score
            .toLowerCase()
            .split(' ')
            .map(function (part) { return part.split('o').join('0'); })
            .join(' ');
        applied.push('replaceOh');
    }
    return { score: score, applied: applied };
}
function separateScoreBlocks(_a) {
    var score = _a.score, applied = _a.applied;
    if (typeof score !== 'string')
        return { score: score };
    score = score
        .toLowerCase()
        .split(' ')
        .map(function (part) {
        if (/^\d+$/.test(part) && part.length > 2) {
            var oneIndex = part.indexOf('1');
            if (!(part.length % 2)) {
                var _a = handleNumeric({
                    score: part,
                    applied: [],
                }), xPart = _a.score, app = _a.applied;
                if (xPart !== part) {
                    part = xPart;
                    applied.push.apply(applied, __spreadArray([], __read(app), false));
                }
            }
            else if (part.length === 3 && oneIndex === 0) {
                var tiebreakScore = getSuper(part.split(''), oneIndex);
                applied.push('getSuper');
                return tiebreakScore;
            }
        }
        return part;
    })
        .join(' ');
    return { score: score, applied: applied };
}
function removeErroneous(_a) {
    var score = _a.score, applied = _a.applied;
    if (typeof score !== 'string')
        return { score: score };
    if ([3, 4].includes(score.length) && parseSuper(score)) {
        var superTie = parseSuper(score);
        return { score: superTie };
    }
    score = score
        .toLowerCase()
        .split(' ')
        .map(function (part) {
        if (/^\d+$/.test(part) && part.length === 1) {
            applied.push('removeErroneous1');
            return;
        }
        return part;
    })
        .filter(Boolean)
        .join(' ');
    return { score: score, applied: applied };
}
function handleWalkover(_a) {
    var score = _a.score, applied = _a.applied;
    if (['walkover', 'wo', 'w/o', 'w-o'].includes(score === null || score === void 0 ? void 0 : score.toString().toLowerCase())) {
        applied.push('handleWalkover');
        return { matchUpStatus: 'walkover', score: '', applied: applied };
    }
    return { score: score };
}
function handleRetired(_a) {
    var _b;
    var score = _a.score, profile = _a.profile, applied = _a.applied;
    score = score === null || score === void 0 ? void 0 : score.toString().toLowerCase();
    var re = /^(.*\d+.*)(ret|con)+[A-Za-z ]*$/; // at least one digit
    if (re.test(score)) {
        var _c = __read(score.match(re).slice(1), 1), leading = _c[0];
        applied.push('handleRetired');
        return { score: leading.trim(), matchUpStatus: 'retired', applied: applied };
    }
    var providerRetired = (_b = profile === null || profile === void 0 ? void 0 : profile.matchUpStatuses) === null || _b === void 0 ? void 0 : _b.retired;
    var additionalRetired = Array.isArray(providerRetired)
        ? providerRetired
        : [providerRetired].filter(Boolean);
    // accommodate other variations
    var retired = __spreadArray(['rtd'], __read(additionalRetired), false).find(function (ret) { return score === null || score === void 0 ? void 0 : score.endsWith(ret); });
    if (retired) {
        applied.push('handleRetired');
        return {
            matchUpStatus: 'retired',
            score: score === null || score === void 0 ? void 0 : score.replace(retired, '').trim(),
            applied: applied,
        };
    }
    return { score: score };
}
function removeDanglingBits(_a) {
    var score = _a.score, attributes = _a.attributes;
    if (score.endsWith(' am') || score.endsWith(' pm'))
        score = '';
    score = score.replace(/[A-Za-z]+/g, '').trim();
    if (['.', ','].some(function (punctuation) { return score.endsWith(punctuation); })) {
        score = score.slice(0, score.length - 1);
    }
    var targetPunctuation = '()/-'
        .split('')
        .some(function (punctuation) { return score.includes(punctuation); });
    if (/ \d$/.test(score) && targetPunctuation) {
        var removed = score.slice(score.length - 2).trim();
        attributes = { removed: removed };
        score = score.slice(0, score.length - 2);
    }
    var alphaEnding = /(.*)[A-Za-z]+$/;
    if (alphaEnding.test(score)) {
        var scorePart = score.match(alphaEnding).slice(1)[0];
        score = scorePart.trim();
    }
    return { score: score, attributes: attributes };
}
function handleSetSlashSeparation(_a) {
    var score = _a.score;
    var re = new RegExp(/-\d+\/\d+-/);
    if (re.test(score)) {
        score = score.split('/').join(' ');
    }
    return { score: score };
}
function handleGameSeparation(_a) {
    var score = _a.score;
    var re = new RegExp(/^\d+\/\d+/);
    var parts = score.split(' ');
    if (parts.some(function (part) { return re.test(part); })) {
        score = parts
            .map(function (part) { return (re.test(part) ? part.replace('/', '-') : part); })
            .join(' ');
    }
    var singleSet = /^(\d+), *(\d+)$/;
    if (singleSet.test(score)) {
        var _b = __read(score.match(singleSet).slice(1), 2), s1 = _b[0], s2 = _b[1];
        var setScore = [s1, s2].join('-');
        score = setScore;
    }
    return { score: score };
}
function handleTiebreakSlashSeparation(_a) {
    var e_1, _b;
    var score = _a.score;
    var re = new RegExp(/\(\d+\/\d+\)/g);
    var tiebreaks = score.match(re);
    try {
        for (var _c = __values(tiebreaks || []), _d = _c.next(); !_d.done; _d = _c.next()) {
            var tiebreak = _d.value;
            var replacement = tiebreak.replace('/', '-');
            score = score.replace(tiebreak, replacement);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { score: score };
}
function handleSpaceSeparator(_a) {
    var score = _a.score;
    if (score.includes(',')) {
        var sets = score.split(',').map(function (set) { return set.trim(); });
        var isSpaced = function (set) { return /\d \d/.test(set); };
        var spacedSets = sets.every(isSpaced);
        if (spacedSets)
            score = sets
                .map(function (set) {
                var e_2, _a;
                var spaceSeparatedDigits = /\d+ \d+/g;
                try {
                    for (var _b = __values(set.match(spaceSeparatedDigits)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var ssd = _c.value;
                        var _d = __read(ssd.match(/(\d+) (\d+)/).slice(1), 2), d1 = _d[0], d2 = _d[1];
                        set = set.replace(ssd, "".concat(d1, "-").concat(d2));
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                return set;
            })
                .join(' ');
    }
    if (score.includes(' ')) {
        var noSpaces = score.replace(/[ ,]/g, '');
        var isNumber = noSpaces.split('').every(function (char) { return isNumeric(char); });
        if (isNumber && noSpaces.length === 4) {
            score = noSpaces;
        }
    }
    return { score: score };
}
function excisions(_a) {
    var score = _a.score;
    var re = new RegExp(/^\[\d+\](.*)$/);
    if (re.test(score)) {
        score = score.match(re).slice(1)[0].trim();
    }
    var openComma = /\(,/g;
    if (openComma.test(score)) {
        score = score.replace(openComma, '(');
    }
    return { score: score };
}
var transforms = {
    handleTiebreakSlashSeparation: handleTiebreakSlashSeparation,
    handleSetSlashSeparation: handleSetSlashSeparation,
    punctuationAdjustments: punctuationAdjustments,
    handleGameSeparation: handleGameSeparation,
    joinFloatingTiebreak: joinFloatingTiebreak,
    handleBracketSpacing: handleBracketSpacing,
    handleSpaceSeparator: handleSpaceSeparator,
    separateScoreBlocks: separateScoreBlocks,
    matchKnownPatterns: matchKnownPatterns,
    removeDanglingBits: removeDanglingBits,
    removeErroneous: removeErroneous,
    handleWalkover: handleWalkover,
    properTiebreak: properTiebreak,
    handleNumeric: handleNumeric,
    handleRetired: handleRetired,
    containedSets: containedSets,
    sensibleSets: sensibleSets,
    stringScore: stringScore,
    superSquare: superSquare,
    setBuilder: setBuilder,
    excisions: excisions,
    replaceOh: replaceOh,
};

var transformations = {};
var processingOrder = [
    'handleNumeric',
    'handleWalkover',
    'handleRetired',
    'replaceOh',
    'stringScore',
    'punctuationAdjustments',
    'excisions',
    'handleSpaceSeparator',
    'matchKnownPatterns',
    'removeDanglingBits',
    'handleBracketSpacing',
    'matchKnownPatterns',
    'containedSets',
    'separateScoreBlocks',
    'handleGameSeparation',
    'removeErroneous',
    'joinFloatingTiebreak',
    'handleSetSlashSeparation',
    'handleTiebreakSlashSeparation',
    'properTiebreak',
    'sensibleSets',
    'superSquare',
];
// secondPass is used to process only numbers which have been extracted from strings
var secondPass = [
    'handleNumeric',
    'separateScoreBlocks',
    'sensibleSets',
    'superSquare',
];
function tidyScore(params) {
    if (!params.score)
        return { error: INVALID_VALUES };
    var incomingScore = params.score; params.sheetName; var identifier = params.identifier; params.fileName; var stepLog = params.stepLog, fullLog = params.fullLog, profile = params.profile;
    var modifications = [];
    var matchUpStatus, applied = [], attributes, result;
    var score = incomingScore;
    var doProcess = function (methods) {
        methods.forEach(function (method) {
            result = transforms[method]({
                profile: profile, // config object compatible with provider profiles
                identifier: identifier, // optional identifier (used in test harness)
                matchUpStatus: matchUpStatus,
                attributes: attributes,
                applied: applied,
                score: score,
            });
            var modified = result.score !== score;
            if (modified) {
                modifications.push({ method: method, score: result.score });
            }
            if (stepLog &&
                (fullLog || modified || result.matchUpStatus !== matchUpStatus)) {
                if (matchUpStatus) {
                    console.log({ score: result.score, matchUpStatus: matchUpStatus }, method);
                }
                else {
                    console.log({ score: result.score }, method);
                }
            }
            if (result.matchUpStatus)
                matchUpStatus = result.matchUpStatus;
            if (result.attributes)
                attributes = result.attributes;
            if (result.applied)
                applied = result.applied;
            score = result.score;
        });
    };
    doProcess(processingOrder);
    var isValid = isValidPattern(score);
    if (!isValid) {
        // Hail Mary: extract only the numbers from the string
        score = incomingScore.toString().replace(/\D/g, '');
        if (attributes === null || attributes === void 0 ? void 0 : attributes.removed) {
            attributes.removed = undefined;
        }
        doProcess(secondPass);
        isValid = isValidPattern(score);
        if (!isValid) {
            score = '';
        }
    }
    applied.forEach(function (application) {
        if (!transformations[application]) {
            transformations[application] = 0;
        }
        transformations[application] += 1;
    });
    return {
        matchUpStatus: matchUpStatus === null || matchUpStatus === void 0 ? void 0 : matchUpStatus.toUpperCase(),
        modifications: modifications,
        attributes: attributes,
        isValid: isValid,
        score: score,
    };
}

function reverseScore(params) {
    if (!(params === null || params === void 0 ? void 0 : params.score))
        return { error: MISSING_VALUE };
    var sets = params.score.sets;
    var reversedSets = sets.map(function (set) {
        var side1TiebreakScore = set.side1TiebreakScore, side2TiebreakScore = set.side2TiebreakScore, winningSide = set.winningSide, side1Score = set.side1Score, side2Score = set.side2Score, setNumber = set.setNumber;
        return definedAttributes({
            winningSide: winningSide ? 3 - winningSide : undefined,
            side1TiebreakScore: side2TiebreakScore,
            side2TiebreakScore: side1TiebreakScore,
            side1Score: side2Score,
            side2Score: side1Score,
            setNumber: setNumber,
        });
    });
    var scoreStringSide1 = generateScoreString({ sets: reversedSets });
    var scoreStringSide2 = generateScoreString({
        sets: reversedSets,
        reversed: true,
    });
    return __assign({ reversedScore: { sets: reversedSets, scoreStringSide1: scoreStringSide1, scoreStringSide2: scoreStringSide2 } }, SUCCESS);
}

function getWinningSide(_a) {
    var analysis = _a.analysis, set = _a.set;
    var leadingSide = getLeadingSide({ set: set });
    var isDecidingSet = analysis.isDecidingSet, isTiebreakSet = analysis.isTiebreakSet, matchUpScoringFormat = analysis.matchUpScoringFormat;
    var setIsComplete = checkSetIsComplete({
        matchUpScoringFormat: matchUpScoringFormat,
        isDecidingSet: isDecidingSet,
        isTiebreakSet: isTiebreakSet,
        set: set,
    });
    return setIsComplete && leadingSide;
}
function checkSetIsComplete(params) {
    var matchUpScoringFormat = params.matchUpScoringFormat;
    var _a = params.ignoreTiebreak, ignoreTiebreak = _a === void 0 ? false : _a, matchUpFormat = params.matchUpFormat, isTiebreakSet = params.isTiebreakSet, isDecidingSet = params.isDecidingSet, set = params.set;
    if (!set)
        return { error: MISSING_VALUE };
    matchUpScoringFormat = matchUpScoringFormat || matchUpFormat;
    var setFormat = (isDecidingSet && matchUpScoringFormat.finalSetFormat) ||
        (matchUpScoringFormat === null || matchUpScoringFormat === void 0 ? void 0 : matchUpScoringFormat.setFormat) ||
        {};
    var side1Score = set.side1Score, side2Score = set.side2Score;
    var NoAD = setFormat.NoAD, setTo = setFormat.setTo, tiebreakAt = setFormat.tiebreakAt, tiebreakFormat = setFormat.tiebreakFormat;
    var tiebreakNoAd = tiebreakFormat === null || tiebreakFormat === void 0 ? void 0 : tiebreakFormat.NoAd;
    var leadingSide = getLeadingSide({ set: set });
    var scoreDiff = Math.abs(side1Score - side2Score);
    var containsSetTo = side1Score >= setTo || side2Score >= setTo;
    var requiresTiebreak = isTiebreakSet ||
        (side1Score >= setTo && side2Score >= setTo) ||
        (tiebreakAt &&
            tiebreakAt < setTo &&
            (side1Score === tiebreakAt || side2Score === tiebreakAt));
    var tiebreakIsValid = ignoreTiebreak ||
        (requiresTiebreak &&
            ((leadingSide === 1 && set.side1TiebreakScore > set.side2TiebreakScore) ||
                (leadingSide === 2 &&
                    set.side2TiebreakScore > set.side1TiebreakScore)));
    var winMargin = NoAD ||
        (requiresTiebreak &&
            ((tiebreakAt && !isTiebreakSet) || (isTiebreakSet && tiebreakNoAd)))
        ? 1
        : 2;
    var hasWinMargin = scoreDiff >= winMargin;
    var validNormalSetScore = containsSetTo && (hasWinMargin || requiresTiebreak);
    return ((validNormalSetScore || isTiebreakSet) &&
        (!requiresTiebreak || tiebreakIsValid));
}
function getLeadingSide(_a) {
    var set = _a.set;
    if (set.side1Score || set.side2Score) {
        if (set.side1Score > set.side2Score)
            return 1;
        if (set.side2Score > set.side1Score)
            return 2;
    }
    else if (set.side1TiebreakScore || set.side2TiebreakScore) {
        if (set.side1TiebreakScore > set.side2TiebreakScore)
            return 1;
        if (set.side2TiebreakScore > set.side1TiebreakScore)
            return 2;
    }
    return undefined;
}

var SPACE_CHARACTER = ' ';
var OUTCOME_DEFAULT = 'DEF';
var OUTCOME_COMPLETE = 'COMPLETED';
var OUTCOME_WALKOVER = 'WO';
var OUTCOME_DOUBLE_WALKOVER = 'WO/WO';
var OUTCOME_ABANDONED = 'ABN';
var OUTCOME_SUSPENDED = 'SUS';
var OUTCOME_RETIREMENT = 'RET';
var OUTCOME_INTERRUPTED = 'INT';
var OUTCOMES = [
    OUTCOME_RETIREMENT,
    OUTCOME_DEFAULT,
    OUTCOME_WALKOVER,
    OUTCOME_DOUBLE_WALKOVER,
    OUTCOME_ABANDONED,
    OUTCOME_SUSPENDED,
    OUTCOME_INTERRUPTED,
];
var STATUS_DEFAULT = 'DEFAULTED';
var STATUS_WALKOVER = 'WALKOVER';
var STATUS_ABANDONED = 'ABANDONED';
var STATUS_SUSPENDED = 'SUSPENDED';
var STATUS_RETIREMENT = 'RETIRED';
var STATUS_INTERRUPTED = 'INTERRUPTED';
var WINNING_STATUSES = [
    STATUS_RETIREMENT,
    STATUS_DEFAULT,
    STATUS_WALKOVER,
];
var PROMPT = 'Enter Score';
var SET_TIEBREAK_BRACKETS = '()';
var MATCH_TIEBREAK_BRACKETS = '[]';
var MOVEUP = ['up', 'left', 'shift+tab'];
var MOVEDOWN = ['enter', 'down', 'tab', 'right'];
var BACKSPACE = 'backspace';
var RETIRE = 'r';
var SUSPEND = 's';
var ABANDON = 'a';
var DEFAULT = 'd';
var WALKOVER = 'w';
var INTERRUPT = 'i';
var OUTCOMEKEYS = [
    RETIRE,
    DEFAULT,
    WALKOVER,
    ABANDON,
    SUSPEND,
    INTERRUPT,
];
var SPACE_KEY = 'space';
var OPENERS = ['[', '('];
var CLOSERS = __spreadArray(__spreadArray(__spreadArray([], __read(MOVEUP), false), __read(MOVEDOWN), false), [SPACE_KEY, ']'], false);
var DASH = '-';
var FORWARD_SLASH = '/';
var SCORE_JOINER = DASH;
var MATCH_TIEBREAK_JOINER = DASH;
var ALTERNATE_JOINERS = [FORWARD_SLASH];
var ZERO = 0;
var TEST = ['=', '+', 'num_1', 'num_2', 'shift+=', 'shift+-'];
var SIDE1KEYS = [
    '0',
    '1',
    '2',
    '3',
    '4',
    '5',
    '6',
    '7',
    '8',
    '9',
].concat(OUTCOMEKEYS);
var SIDE2KEYS = SIDE1KEYS.map(function (key) { return "shift+".concat(key); });
var MODIFIERS = [SCORE_JOINER, BACKSPACE].concat(CLOSERS, ALTERNATE_JOINERS);
var VALID_VALUE_KEYS = [SIDE1KEYS, SIDE2KEYS, MODIFIERS].join(',');
var HOTKEYS = [VALID_VALUE_KEYS, MOVEUP, MOVEDOWN, TEST].join(',');
// for testing purposes; side keys overrepresented
[].concat.apply([], __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(SIDE1KEYS), false), __read(SIDE1KEYS), false), __read(MODIFIERS), false), __read(SIDE1KEYS), false), __read(SIDE1KEYS), false), __read(SIDE1KEYS), false), __read(SIDE1KEYS), false), __read(SIDE1KEYS), false), __read(SIDE1KEYS), false));
var keyValueConstants = {
    OUTCOMEKEYS: OUTCOMEKEYS,
    SIDE1KEYS: SIDE1KEYS,
    SIDE2KEYS: SIDE2KEYS,
    MODIFIERS: MODIFIERS,
    PROMPT: PROMPT,
    MOVEUP: MOVEUP,
    MOVEDOWN: MOVEDOWN,
    HOTKEYS: HOTKEYS,
};

function processIncompleteSetScore(_a) {
    var analysis = _a.analysis, scoreString = _a.scoreString, sets = _a.sets, value = _a.value;
    var updated;
    if (!(sets === null || sets === void 0 ? void 0 : sets.length))
        return { sets: [] };
    var set = sets[sets.length - 1];
    value = ensureInt(value);
    var _b = checkValidSide2Score({
        analysis: analysis,
        set: set,
        value: value,
    }), validSide2Score = _b.validSide2Score, requiresTiebreak = _b.requiresTiebreak;
    if (validSide2Score) {
        updated = true;
        scoreString = (scoreString || '') + value;
        set.side2Score = value;
        var winningSide = getWinningSide({
            analysis: analysis,
            set: sets[sets.length - 1],
        });
        set.winningSide = winningSide || undefined;
        if (requiresTiebreak) {
            var open_1 = SET_TIEBREAK_BRACKETS.split('')[0];
            scoreString += open_1;
        }
        else if (!analysis.isDecidingSet) {
            scoreString += SPACE_CHARACTER;
        }
    }
    return { sets: sets, scoreString: scoreString, updated: updated };
}
function checkValidSide2Score(_a) {
    var analysis = _a.analysis, _b = _a.set, set = _b === void 0 ? {} : _b, value = _a.value;
    var setFormat = (analysis.isDecidingSet && analysis.matchUpScoringFormat.finalSetFormat) ||
        analysis.matchUpScoringFormat.setFormat;
    var tiebreakAt = setFormat.tiebreakAt, setTo = setFormat.setTo, NoAD = setFormat.NoAD;
    var side1Score = set.side1Score;
    var validSide2Score, requiresTiebreak;
    if (tiebreakAt && tiebreakAt < setTo) {
        if (side1Score === tiebreakAt) {
            validSide2Score = value <= setTo;
        }
        else {
            validSide2Score = value <= tiebreakAt;
        }
    }
    else if (side1Score === setTo) {
        if (NoAD) {
            validSide2Score = value < setTo;
        }
        else {
            validSide2Score = value <= setTo + 1;
        }
    }
    else if (side1Score === setTo - 1) {
        if (NoAD) {
            validSide2Score = value <= setTo;
        }
        else {
            validSide2Score = value <= setTo + 1;
        }
    }
    else if (side1Score === setTo + 1) {
        validSide2Score = value === setTo || value === setTo - 1;
    }
    else {
        validSide2Score = value <= setTo;
    }
    if (validSide2Score) {
        if (tiebreakAt && tiebreakAt < setTo) {
            requiresTiebreak =
                (side1Score === setTo && value === tiebreakAt) ||
                    (side1Score === tiebreakAt && value === setTo);
        }
        else {
            requiresTiebreak =
                side1Score >= setTo && value >= setTo && side1Score !== value;
        }
    }
    return { validSide2Score: validSide2Score, requiresTiebreak: requiresTiebreak };
}

function addOutcome(_a) {
    var scoreString = _a.scoreString, lowSide = _a.lowSide, outcome = _a.outcome;
    (scoreString = removeOutcome({ scoreString: scoreString }).scoreString);
    if (lowSide === 2) {
        var lastScoreCharacter = scoreString && scoreString[scoreString.length - 1];
        var spacer = lastScoreCharacter !== SPACE_CHARACTER ? SPACE_CHARACTER : '';
        return scoreString + spacer + outcome;
    }
    else {
        return outcome + SPACE_CHARACTER + scoreString;
    }
}
function removeOutcome(_a) {
    var e_1, _b;
    var scoreString = _a.scoreString;
    if (!scoreString)
        return { scoreString: '' };
    var removed = false;
    try {
        for (var OUTCOMES_1 = __values(OUTCOMES), OUTCOMES_1_1 = OUTCOMES_1.next(); !OUTCOMES_1_1.done; OUTCOMES_1_1 = OUTCOMES_1.next()) {
            var outcome = OUTCOMES_1_1.value;
            var index = scoreString === null || scoreString === void 0 ? void 0 : scoreString.indexOf(outcome);
            if (index === 0) {
                scoreString =
                    scoreString.slice(outcome.length + 1).trim() + SPACE_CHARACTER;
            }
            else if (index > 0) {
                scoreString = scoreString.slice(0, index);
            }
            if (index >= 0)
                removed = true;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (OUTCOMES_1_1 && !OUTCOMES_1_1.done && (_b = OUTCOMES_1.return)) _b.call(OUTCOMES_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (!(scoreString === null || scoreString === void 0 ? void 0 : scoreString.trim()))
        scoreString = '';
    return { scoreString: scoreString, removed: removed };
}
function removeFromScore(_a) {
    var _b, _c, _d;
    var analysis = _a.analysis, scoreString = _a.scoreString, sets = _a.sets, lowSide = _a.lowSide;
    var newScore, newSets;
    if (!scoreString)
        return { scoreString: scoreString, sets: sets };
    var _e = removeOutcome({
        scoreString: scoreString,
    }), outcomeRemoved = _e.scoreString, removed = _e.removed;
    scoreString = outcomeRemoved;
    if (removed)
        return { scoreString: scoreString, sets: sets, outcomeRemoved: true };
    var lastSet = sets[sets.length - 1] || {};
    // Looking for the last set which has some values defined
    // setValues Count determines if there are any values other than setNumber
    var setValuesCount = Object.values(lastSet).filter(function (f) { return f !== undefined; }).length;
    if (lastSet.setNumber && setValuesCount === 1) {
        sets = sets.slice(0, sets.length - 1);
        lastSet = sets[sets.length - 1] || {};
    }
    var tiebreakSet = analysis.setFormat.tiebreakSet;
    var _f = tiebreakSet || {}, tiebreakTo = _f.tiebreakTo, NoAD = _f.NoAD;
    var isMatchTiebreak = testTiebreakEntry({
        brackets: MATCH_TIEBREAK_BRACKETS,
        scoreString: scoreString,
    }).isTiebreakEntry;
    var index = lastNumericIndex(scoreString);
    if (index >= 0) {
        newScore = scoreString.slice(0, index);
        var openSetTiebreak = testTiebreakEntry({
            brackets: SET_TIEBREAK_BRACKETS,
            scoreString: newScore,
        }).isTiebreakEntry;
        var _g = testTiebreakEntry({
            brackets: MATCH_TIEBREAK_BRACKETS,
            scoreString: newScore,
        }), lastMatchTiebreakOpenBracketIndex = _g.lastOpenBracketIndex, openMatchTiebreak = _g.isTiebreakEntry;
        var lastNewScoreChar = newScore && newScore[newScore.length - 1].trim();
        var remainingNumbers = newScore && !isNaN(lastNewScoreChar);
        var isIncompleteScore = analysis.isIncompleteSetScore;
        if (isMatchTiebreak && openMatchTiebreak) {
            var matchTiebreakScoreString = newScore.slice(lastMatchTiebreakOpenBracketIndex + 1);
            var splitScoreString = matchTiebreakScoreString.split(MATCH_TIEBREAK_JOINER);
            var side1TiebreakScore = ((splitScoreString === null || splitScoreString === void 0 ? void 0 : splitScoreString.length) > 0 &&
                splitScoreString[0] !== undefined &&
                !isNaN(parseInt(splitScoreString[0])) &&
                parseInt(splitScoreString[0])) ||
                undefined;
            var side2TiebreakScore = ((splitScoreString === null || splitScoreString === void 0 ? void 0 : splitScoreString.length) > 1 &&
                splitScoreString[1] !== undefined &&
                parseInt(splitScoreString[1])) ||
                undefined;
            var matchTiebreakScores = [side1TiebreakScore, side2TiebreakScore];
            if (side2TiebreakScore) {
                var highIndex = lowSide === 1 ? 1 : 0;
                matchTiebreakScores[highIndex] =
                    ((matchTiebreakScores === null || matchTiebreakScores === void 0 ? void 0 : matchTiebreakScores[1 - highIndex]) || 0) + (NoAD ? 1 : 2);
                if ((matchTiebreakScores[highIndex] || 0) < tiebreakTo)
                    matchTiebreakScores[highIndex] = tiebreakTo;
                newScore = scoreString.slice(0, lastMatchTiebreakOpenBracketIndex + 1);
                newScore += matchTiebreakScores.join(MATCH_TIEBREAK_JOINER);
            }
            else if (side1TiebreakScore !== undefined) {
                newScore = scoreString.slice(0, lastMatchTiebreakOpenBracketIndex + 1);
                newScore += side1TiebreakScore;
            }
            else {
                newScore = scoreString.slice(0, lastMatchTiebreakOpenBracketIndex);
                isIncompleteScore = true;
            }
            lastSet.side1TiebreakScore = matchTiebreakScores[0] || 0;
            lastSet.side2TiebreakScore = matchTiebreakScores[1] || 0;
        }
        if (!newScore.length)
            newScore = undefined;
        if (isIncompleteScore) {
            var side1Score = (_b = lastSet.side1Score) === null || _b === void 0 ? void 0 : _b.toString();
            if (side1Score) {
                var newSide1Score = side1Score === null || side1Score === void 0 ? void 0 : side1Score.slice(0, side1Score.length - 1);
                lastSet.side1Score =
                    (!isNaN(newSide1Score) && parseInt(newSide1Score)) || undefined;
                if (lastSet.side1Score === undefined)
                    lastSet.side2Score = undefined;
            }
            if (analysis.isTimedSet) {
                newSets = lastSet.side1Score
                    ? sets
                    : (sets === null || sets === void 0 ? void 0 : sets.slice(0, sets.length - 1)) || [];
                newSets[sets.length - 1] = lastSet;
            }
            else {
                newSets = (sets === null || sets === void 0 ? void 0 : sets.slice(0, sets.length - 1)) || [];
            }
        }
        else if (remainingNumbers) {
            var side2Score = (_c = lastSet.side2Score) === null || _c === void 0 ? void 0 : _c.toString();
            var side1Score = (_d = lastSet.side1Score) === null || _d === void 0 ? void 0 : _d.toString();
            if (!analysis.isTiebreakEntry && !analysis.isMatchTiebreak) {
                if (lastSet.side2Score) {
                    var newSide2Score = side2Score === null || side2Score === void 0 ? void 0 : side2Score.slice(0, side2Score.length - 1);
                    lastSet.side2Score =
                        (!isNaN(newSide2Score) && parseInt(newSide2Score)) || undefined;
                }
                else {
                    var newSide1Score = side1Score === null || side1Score === void 0 ? void 0 : side1Score.slice(0, side1Score.length - 1);
                    lastSet.side1Score =
                        (!isNaN(newSide1Score) && parseInt(newSide1Score)) || undefined;
                }
            }
            if (analysis.isTimedSet) {
                if (lastSet.side1Score) {
                    newSets = sets || [];
                    newSets[sets.length - 1] = lastSet;
                }
                else {
                    newSets = (sets === null || sets === void 0 ? void 0 : sets.slice(0, sets.length - 1)) || [];
                }
            }
            else {
                newSets = sets || [];
                newSets[sets.length - 1] = lastSet;
            }
            if (newSets[newSets.length - 1]) {
                Object.assign(newSets[newSets.length - 1], { winningSide: undefined });
            }
        }
        else if (openSetTiebreak) {
            newSets = sets || [];
            Object.assign(newSets[newSets.length - 1] || {}, {
                winningSide: undefined,
                side1TiebreakScore: undefined,
                side2TiebreakScore: undefined,
            });
        }
        else {
            if (isMatchTiebreak && !openMatchTiebreak) {
                newSets = (sets === null || sets === void 0 ? void 0 : sets.slice(0, sets.length - 1)) || [];
            }
            else {
                newSets = sets;
                newSets[sets.length - 1] = lastSet;
            }
            if (!isMatchTiebreak) {
                newSets[newSets.length - 1].side2Score = 0;
                newSets[newSets.length - 1].winningSide = undefined;
            }
        }
        return { scoreString: newScore, sets: newSets };
    }
    return { scoreString: scoreString, sets: sets };
}
function testTiebreakEntry(_a) {
    var _b = _a.brackets, brackets = _b === void 0 ? SET_TIEBREAK_BRACKETS : _b, scoreString = _a.scoreString;
    if (!scoreString)
        return {};
    var _c = __read(brackets.split(''), 2), open = _c[0], close = _c[1];
    var splitScore = scoreString.split('');
    var lastOpenBracketIndex = Math.max.apply(Math, __spreadArray([], __read(arrayIndices(open, splitScore)), false));
    var lastCloseBracketIndex = Math.max.apply(Math, __spreadArray([], __read(arrayIndices(close, splitScore)), false));
    var isTiebreakEntry = lastOpenBracketIndex > lastCloseBracketIndex;
    return { isTiebreakEntry: isTiebreakEntry, lastOpenBracketIndex: lastOpenBracketIndex };
}
function checkValidMatchTiebreak(_a) {
    var scoreString = _a.scoreString;
    if (!scoreString)
        return false;
    var lastScoreChar = scoreString && scoreString[scoreString.length - 1].trim();
    var isNumericEnding = scoreString && !isNaN(lastScoreChar);
    var _b = __read(MATCH_TIEBREAK_BRACKETS.split(''), 2), open = _b[0], close = _b[1];
    var splitScore = scoreString.split('');
    var lastOpenBracketIndex = Math.max.apply(Math, __spreadArray([], __read(arrayIndices(open, splitScore)), false));
    var lastCloseBracketIndex = Math.max.apply(Math, __spreadArray([], __read(arrayIndices(close, splitScore)), false));
    var lastJoinerIndex = Math.max.apply(Math, __spreadArray([], __read(arrayIndices(MATCH_TIEBREAK_JOINER, splitScore)), false));
    return (isNumericEnding &&
        lastOpenBracketIndex > lastCloseBracketIndex &&
        lastJoinerIndex > lastOpenBracketIndex);
}
function lastNumericIndex(str) {
    var arr = str.split('');
    var arrayIndices = arr.reduce(function (a, e, i) {
        if (e.match(/\d+/g))
            a.push(i);
        return a;
    }, []);
    return arrayIndices.pop();
}
function getHighTiebreakValue(params) {
    var _a = params || {}, _b = _a.lowValue, lowValue = _b === void 0 ? 0 : _b, _c = _a.NoAD, NoAD = _c === void 0 ? false : _c, tiebreakTo = _a.tiebreakTo;
    var winBy = NoAD ? 1 : 2;
    if (lowValue + 1 >= tiebreakTo) {
        return lowValue + winBy;
    }
    return parseInt(tiebreakTo);
}
function getMatchUpWinner(_a) {
    var matchUpFormat = _a.matchUpFormat, matchUpStatus = _a.matchUpStatus, winningSide = _a.winningSide, sets = _a.sets;
    var matchUpScoringFormat = parse(matchUpFormat);
    var bestOf = matchUpScoringFormat.bestOf;
    var scoreGoal = Math.ceil(bestOf / 2);
    var sideScores = sets === null || sets === void 0 ? void 0 : sets.reduce(function (scores, set) {
        var winningSide = set.winningSide;
        if (winningSide)
            scores[winningSide - 1]++;
        return scores;
    }, [0, 0]);
    var matchUpWinningSide = (sideScores === null || sideScores === void 0 ? void 0 : sideScores.indexOf(scoreGoal)) + 1 || undefined;
    if (WINNING_STATUSES.includes(matchUpStatus) && winningSide) {
        matchUpWinningSide = winningSide;
    }
    return { matchUpWinningSide: matchUpWinningSide };
}

function processOutcome(_a) {
    var lowSide = _a.lowSide, value = _a.value, sets = _a.sets, scoreString = _a.scoreString, winningSide = _a.winningSide, matchUpStatus = _a.matchUpStatus;
    var updated;
    if (value === RETIRE) {
        if (scoreString) {
            updated = true;
            scoreString = addOutcome({
                scoreString: scoreString,
                lowSide: lowSide,
                outcome: OUTCOME_RETIREMENT,
            });
            winningSide = lowSide === 2 ? 1 : 2;
            matchUpStatus = STATUS_RETIREMENT;
        }
        else {
            updated = true;
            scoreString = addOutcome({
                scoreString: scoreString,
                lowSide: lowSide,
                outcome: OUTCOME_DEFAULT,
            });
            winningSide = lowSide === 2 ? 1 : 2;
            matchUpStatus = STATUS_DEFAULT;
        }
    }
    else if (value === DEFAULT) {
        updated = true;
        scoreString = addOutcome({
            scoreString: scoreString,
            lowSide: lowSide,
            outcome: OUTCOME_DEFAULT,
        });
        winningSide = lowSide === 2 ? 1 : 2;
        matchUpStatus = STATUS_DEFAULT;
    }
    else if (value === WALKOVER) {
        updated = true;
        sets = [];
        scoreString = OUTCOME_WALKOVER;
        winningSide = lowSide === 2 ? 1 : 2;
        matchUpStatus = STATUS_WALKOVER;
    }
    else if (value === SUSPEND && scoreString) {
        updated = true;
        scoreString = addOutcome({
            scoreString: scoreString,
            lowSide: lowSide,
            outcome: OUTCOME_SUSPENDED,
        });
        matchUpStatus = STATUS_SUSPENDED;
        winningSide = undefined;
    }
    else if (value === ABANDON) {
        updated = true;
        scoreString = addOutcome({
            scoreString: scoreString,
            lowSide: lowSide,
            outcome: OUTCOME_ABANDONED,
        });
        matchUpStatus = STATUS_ABANDONED;
        winningSide = undefined;
    }
    else if (value === INTERRUPT && scoreString) {
        updated = true;
        scoreString = addOutcome({
            scoreString: scoreString,
            lowSide: lowSide,
            outcome: OUTCOME_INTERRUPTED,
        });
        matchUpStatus = STATUS_INTERRUPTED;
        winningSide = undefined;
    }
    return { updated: updated, sets: sets, scoreString: scoreString, matchUpStatus: matchUpStatus, winningSide: winningSide };
}

function keyValueTimedSetScore(params) {
    var _a, _b;
    var sets = params.sets, info = params.info, scoreString = params.scoreString, winningSide = params.winningSide, matchUpStatus = params.matchUpStatus;
    var analysis = params.analysis, lowSide = params.lowSide, value = params.value;
    var updated, outcomeRemoved;
    if (!(sets === null || sets === void 0 ? void 0 : sets.length) && value !== BACKSPACE)
        sets = [{ setNumber: 1 }];
    var setIndex = sets.length - 1;
    if (OUTCOMEKEYS.includes(value)) {
        var lastSet = sets[sets.length - 1] || {};
        var side1Score = lastSet.side1Score, side2Score = lastSet.side2Score;
        if (side1Score && !side2Score) {
            info = 'missing side2Score';
        }
        else if (analysis.finalSetIsComplete || winningSide) {
            info = 'final set is already complete';
        }
        else if (analysis.isIncompleteSetScore) {
            info = 'incomplete set scoreString';
        }
        else if (!analysis.isIncompleteSetScore) {
            (_a = processOutcome({
                lowSide: lowSide,
                value: value,
                sets: sets,
                scoreString: scoreString,
                matchUpStatus: matchUpStatus,
                winningSide: winningSide,
            }), sets = _a.sets, scoreString = _a.scoreString, winningSide = _a.winningSide, matchUpStatus = _a.matchUpStatus, updated = _a.updated);
        }
    }
    else if (value === BACKSPACE) {
        (_b = removeFromScore({
            analysis: analysis,
            scoreString: scoreString,
            sets: sets,
        }), scoreString = _b.scoreString, sets = _b.sets, outcomeRemoved = _b.outcomeRemoved);
        if ((scoreString === null || scoreString === void 0 ? void 0 : scoreString.trim()) === '') {
            scoreString = scoreString.trim();
        }
        if (!scoreString)
            sets = [];
        if (outcomeRemoved) {
            var lastSet = sets[sets.length - 1] || {};
            var side1Score = lastSet.side1Score, side2Score = lastSet.side2Score;
            if (side1Score && side2Score) {
                var winningSide_1 = (side1Score > side2Score && 1) ||
                    (side2Score > side1Score && 2) ||
                    undefined;
                if (winningSide_1) {
                    lastSet.winningSide = winningSide_1;
                    sets.push({ setNumber: sets.length + 1 });
                }
            }
        }
        matchUpStatus = undefined;
        winningSide = undefined;
        updated = true;
    }
    else if (analysis.hasOutcome) {
        info = 'has outcome';
    }
    else if (winningSide) {
        return {
            sets: sets,
            scoreString: scoreString,
            winningSide: winningSide,
            matchUpStatus: matchUpStatus,
            updated: false,
            info: 'matchUp is complete',
        };
        // SPACE_KEY indicates moving on to next set
    }
    else if (value === SPACE_KEY) {
        var lastSet = sets[sets.length - 1] || {};
        var side1Score = lastSet.side1Score, side2Score = lastSet.side2Score;
        var setWinningSide = (side1Score > side2Score && 1) ||
            (side2Score > side1Score && 2) ||
            undefined;
        if (setWinningSide && !winningSide && !analysis.isIncompleteSetScore) {
            sets[sets.length - 1].winningSide = setWinningSide;
            sets.push({ setNumber: sets.length + 1 });
            scoreString += ' ';
            updated = true;
        }
        // SCORE_JOINGER is only valid if side1Score exists and side2Score doesn't exist
    }
    else if (value === SCORE_JOINER &&
        sets[setIndex].side1Score !== undefined &&
        sets[setIndex].side2Score === undefined &&
        scoreString &&
        analysis.isNumericEnding) {
        scoreString += '-';
        sets[setIndex].side2Score = 0;
        matchUpStatus = undefined;
        winningSide = undefined;
        updated = true;
    }
    else if (!isNaN(value)) {
        var currentSetScore = void 0;
        if (sets[setIndex].side2Score === undefined) {
            var newValue = ensureInt((sets[setIndex].side1Score || 0).toString() + value)
                .toString()
                .slice(0, 2);
            sets[setIndex].side1Score = ensureInt(newValue);
            currentSetScore = sets[setIndex].side1Score.toString();
            updated = true;
        }
        else {
            var newValue = ensureInt((sets[setIndex].side2Score || 0).toString() + value)
                .toString()
                .slice(0, 2);
            sets[setIndex].side2Score = ensureInt(newValue);
            currentSetScore = [
                sets[setIndex].side1Score,
                sets[setIndex].side2Score,
            ].join('-');
            updated = true;
        }
        if (updated) {
            var priorSetScores = (sets.slice(0, setIndex) || [])
                .filter(function (set) { return set; })
                .map(function (set) {
                var side1Score = set.side1Score, side2Score = set.side2Score;
                return [side1Score, side2Score].join('-');
            })
                .join(' ');
            if (priorSetScores) {
                scoreString = priorSetScores + ' ' + currentSetScore;
            }
            else {
                scoreString = currentSetScore;
            }
        }
    }
    return { sets: sets, scoreString: scoreString, winningSide: winningSide, matchUpStatus: matchUpStatus, info: info, updated: updated };
}

function processTiebreakSet(_a) {
    var _b;
    var analysis = _a.analysis, auto = _a.auto, lowSide = _a.lowSide, _c = _a.scoreString, scoreString = _c === void 0 ? '' : _c, sets = _a.sets, value = _a.value;
    var updated, info;
    var _d = analysis.setFormat.tiebreakSet, tiebreakTo = _d.tiebreakTo, NoAD = _d.NoAD;
    var _e = __read(MATCH_TIEBREAK_BRACKETS.split(''), 1), open = _e[0];
    if (!analysis.isMatchTiebreakEntry) {
        scoreString += open;
    }
    var tiebreakSet = sets[analysis.setNumber - 1];
    if (!tiebreakSet) {
        var highValue = getHighTiebreakValue({
            lowValue: ensureInt(value || 0),
            tiebreakTo: tiebreakTo,
            NoAD: NoAD,
        });
        var setScores = [ensureInt(value), highValue];
        if (lowSide === 2)
            setScores.reverse();
        var set = {
            side1TiebreakScore: setScores[0],
            side2TiebreakScore: setScores[1],
            setNumber: (sets === null || sets === void 0 ? void 0 : sets.length) + 1 || 1,
        };
        sets.push(set);
        scoreString += setScores.join(MATCH_TIEBREAK_JOINER);
        updated = true;
    }
    else {
        // if not auto-calculating high scores add new value at the end of string
        var lastOpenBracketIndex = testTiebreakEntry({
            brackets: MATCH_TIEBREAK_BRACKETS,
            scoreString: scoreString,
        }).lastOpenBracketIndex;
        var matchTiebreakScoreString = scoreString.slice((lastOpenBracketIndex !== null && lastOpenBracketIndex !== void 0 ? lastOpenBracketIndex : 0) + 1) + (auto ? '' : value);
        var matchTiebreakScores = matchTiebreakScoreString.split(MATCH_TIEBREAK_JOINER);
        var lowSideLength = ((_b = matchTiebreakScores[lowSide - 1]) === null || _b === void 0 ? void 0 : _b.length) || 0;
        if (lowSideLength >= 2) {
            // don't allow tiebreak scores to have more than two digits
            info = 'tiebreak digit limit';
        }
        else if (auto) {
            if (lowSide === 1)
                matchTiebreakScores[0] = (matchTiebreakScores[0] || '') + value;
            if (lowSide === 2)
                matchTiebreakScores[1] = (matchTiebreakScores[1] || '') + value;
            var setScores = [
                matchTiebreakScores[0] || 0,
                matchTiebreakScores[1] || 0,
            ].map(function (s) { return ensureInt(s); });
            var highIndex = lowSide === 1 ? 1 : 0;
            setScores[highIndex] = setScores[1 - highIndex] + (NoAD ? 1 : 2);
            if (setScores[highIndex] < tiebreakTo)
                setScores[highIndex] = tiebreakTo;
            var lastSet = sets[sets.length - 1];
            lastSet.side1TiebreakScore = setScores[0];
            lastSet.side2TiebreakScore = setScores[1];
            scoreString = scoreString.slice(0, (lastOpenBracketIndex !== null && lastOpenBracketIndex !== void 0 ? lastOpenBracketIndex : 0) + 1);
            scoreString += setScores.join(MATCH_TIEBREAK_JOINER);
            updated = true;
        }
        else {
            var setScores = [
                matchTiebreakScores[0] || 0,
                matchTiebreakScores[1] || 0,
            ].map(function (s) { return ensureInt(s); });
            var lastSet = sets[sets.length - 1];
            lastSet.side1TiebreakScore = setScores[0];
            lastSet.side2TiebreakScore = setScores[1];
            scoreString += value;
            updated = true;
        }
    }
    return { info: info, scoreString: scoreString, sets: sets, updated: updated };
}

function keyValueSetScore(_a) {
    var analysis = _a.analysis, lowSide = _a.lowSide, scoreString = _a.scoreString, value = _a.value;
    var _b = (analysis === null || analysis === void 0 ? void 0 : analysis.setFormat) || {}, setTo = _b.setTo, tiebreakAt = _b.tiebreakAt, NoAD = _b.NoAD;
    var needsTiebreak = value === parseInt(tiebreakAt || setTo);
    if (tiebreakAt && tiebreakAt < setTo && value > tiebreakAt)
        return { scoreString: scoreString };
    if ((NoAD && value === setTo) || value > setTo)
        return { scoreString: scoreString };
    var highValue = getHighSetValue();
    var setScores = [value, highValue];
    if (lowSide === 2)
        setScores.reverse();
    var brackets = SET_TIEBREAK_BRACKETS;
    var open = brackets.split('')[0];
    var addition = setScores.join(SCORE_JOINER) + (needsTiebreak ? open : SPACE_CHARACTER);
    scoreString = (scoreString || '') + addition;
    var set = {
        side1Score: setScores[0],
        side2Score: setScores[1],
    };
    var winningSide = getWinningSide({ analysis: analysis, set: set });
    set.winningSide = winningSide || undefined;
    return { scoreString: scoreString, set: set };
    function getHighSetValue() {
        if (needsTiebreak)
            return value + 1;
        if (value + 1 === setTo) {
            return value + (NoAD ? 1 : 2);
        }
        return setTo;
    }
}

function getScoreAnalysis(_a) {
    var _b, _c, _d;
    var matchUpFormat = _a.matchUpFormat, scoreString = _a.scoreString, winningSide = _a.winningSide, value = _a.value, sets = _a.sets;
    var completedSets = ((_b = sets === null || sets === void 0 ? void 0 : sets.filter(function (set) { return set === null || set === void 0 ? void 0 : set.winningSide; })) === null || _b === void 0 ? void 0 : _b.length) || 0;
    var setNumber = completedSets + (winningSide ? 0 : 1);
    var matchUpScoringFormat = parse(matchUpFormat);
    var isDecidingSet = setNumber === (matchUpScoringFormat === null || matchUpScoringFormat === void 0 ? void 0 : matchUpScoringFormat.bestOf);
    var setFormat = (isDecidingSet && (matchUpScoringFormat === null || matchUpScoringFormat === void 0 ? void 0 : matchUpScoringFormat.finalSetFormat)) ||
        (matchUpScoringFormat === null || matchUpScoringFormat === void 0 ? void 0 : matchUpScoringFormat.setFormat) ||
        {};
    var isTimedSet = setFormat === null || setFormat === void 0 ? void 0 : setFormat.timed;
    var finalSet = isDecidingSet && sets[(matchUpScoringFormat === null || matchUpScoringFormat === void 0 ? void 0 : matchUpScoringFormat.bestOf) - 1];
    var finalSetIsComplete = finalSet === null || finalSet === void 0 ? void 0 : finalSet.winningSide;
    var isSetTiebreakEntry = testTiebreakEntry({
        brackets: SET_TIEBREAK_BRACKETS,
        scoreString: scoreString,
    }).isTiebreakEntry;
    var isMatchTiebreakEntry = testTiebreakEntry({
        brackets: MATCH_TIEBREAK_BRACKETS,
        scoreString: scoreString,
    }).isTiebreakEntry;
    var isTiebreakEntry = isSetTiebreakEntry || isMatchTiebreakEntry;
    var isTiebreakSet = !!setFormat.tiebreakSet;
    var lastScoreChar = (_c = scoreString === null || scoreString === void 0 ? void 0 : scoreString[scoreString.length - 1]) === null || _c === void 0 ? void 0 : _c.trim();
    var isNumericEnding = scoreString && !isNaN(lastScoreChar);
    var isIncompleteSetScore = !isTiebreakEntry && lastScoreChar === SCORE_JOINER;
    var isIncompleteSetTiebreak = isSetTiebreakEntry && OPENERS.includes(lastScoreChar);
    var isIncompleteMatchTiebreak = isMatchTiebreakEntry && OPENERS.includes(lastScoreChar);
    var isPartialMatchTiebreakValue = isMatchTiebreakEntry && lastScoreChar === MATCH_TIEBREAK_JOINER;
    var splitScore = scoreString === null || scoreString === void 0 ? void 0 : scoreString.split('');
    var _e = __read(MATCH_TIEBREAK_BRACKETS.split(''), 1), open = _e[0];
    var lastOpenBracketIndex = splitScore && Math.max.apply(Math, __spreadArray([], __read(arrayIndices(open, splitScore)), false));
    var lastJoinerIndex = splitScore && Math.max.apply(Math, __spreadArray([], __read(arrayIndices(MATCH_TIEBREAK_JOINER, splitScore)), false));
    var matchTiebreakHasJoiner = splitScore && lastJoinerIndex > lastOpenBracketIndex;
    var lastSetIsComplete = (_d = sets[sets.length - 1]) === null || _d === void 0 ? void 0 : _d.winningSide;
    var isGameScoreEntry = (sets === null || sets === void 0 ? void 0 : sets.length) && !lastSetIsComplete;
    var hasOutcome = OUTCOMES.find(function (outcome) { return (scoreString === null || scoreString === void 0 ? void 0 : scoreString.indexOf(outcome)) >= 0; });
    var isNumericValue = !isNaN(value);
    var isSpace = value === SPACE_KEY;
    var isCloser = CLOSERS.includes(value);
    var hasOpener = scoreString === null || scoreString === void 0 ? void 0 : scoreString.split('').find(function (char) { return OPENERS.includes(char); });
    var isInvalidMatchTiebreakValue = isCloser &&
        isMatchTiebreakEntry &&
        !isIncompleteMatchTiebreak &&
        (isPartialMatchTiebreakValue || !checkValidMatchTiebreak({ scoreString: scoreString }));
    var isInvalidSetTiebreakValue = isSpace && isTiebreakEntry && isIncompleteSetTiebreak;
    var isTiebreakCloser = isCloser && hasOpener && isTiebreakEntry && isNumericEnding;
    var isTiebreakSetValue = isTiebreakSet && isNumericValue;
    return {
        isTiebreakSetValue: isTiebreakSetValue,
        matchUpScoringFormat: matchUpScoringFormat,
        setNumber: setNumber,
        setFormat: setFormat,
        matchTiebreakHasJoiner: matchTiebreakHasJoiner,
        isGameScoreEntry: isGameScoreEntry,
        isSpace: isSpace,
        isCloser: isCloser,
        isTiebreakCloser: isTiebreakCloser,
        isDecidingSet: isDecidingSet,
        isTiebreakSet: isTiebreakSet,
        isTimedSet: isTimedSet,
        isNumericEnding: isNumericEnding,
        isNumericValue: isNumericValue,
        hasOpener: hasOpener,
        hasOutcome: hasOutcome,
        finalSet: finalSet,
        finalSetIsComplete: finalSetIsComplete,
        lastSetIsComplete: lastSetIsComplete,
        isInvalidSetTiebreakValue: isInvalidSetTiebreakValue,
        isInvalidMatchTiebreakValue: isInvalidMatchTiebreakValue,
        isTiebreakEntry: isTiebreakEntry,
        isSetTiebreakEntry: isSetTiebreakEntry,
        isMatchTiebreakEntry: isMatchTiebreakEntry,
        isIncompleteSetScore: isIncompleteSetScore,
        isIncompleteSetTiebreak: isIncompleteSetTiebreak,
        isIncompleteMatchTiebreak: isIncompleteMatchTiebreak,
        isPartialMatchTiebreakValue: isPartialMatchTiebreakValue,
    };
}

/* shiftFirst indicates that SHIFT key refers to first opponent, rather than second */
function keyValueScore(params) {
    var _a, _b, _c, _d, _e, _f;
    var _g = params.lowSide, lowSide = _g === void 0 ? 1 : _g, value = params.value;
    var scoreString = params.scoreString, sets = params.sets, winningSide = params.winningSide, matchUpStatus = params.matchUpStatus;
    var matchUpFormat = params.matchUpFormat, shiftFirst = params.shiftFirst, _h = params.auto, auto = _h === void 0 ? true : _h;
    var updated, info;
    var isShifted = (shiftFirst && lowSide === 2) || (!shiftFirst && lowSide === 1);
    if (!VALID_VALUE_KEYS.includes(value)) {
        return { updated: false, info: 'invalid key' };
    }
    if (shiftFirst)
        lowSide = 3 - lowSide;
    var matchUpWinningSide = getMatchUpWinner({
        sets: sets,
        winningSide: winningSide,
        matchUpStatus: matchUpStatus,
        matchUpFormat: matchUpFormat,
    }).matchUpWinningSide;
    winningSide = matchUpWinningSide;
    var analysis = getScoreAnalysis({
        value: value,
        winningSide: winningSide,
        scoreString: scoreString,
        sets: sets,
        matchUpFormat: matchUpFormat,
    });
    if (ALTERNATE_JOINERS.includes(value))
        value = SCORE_JOINER;
    if (analysis.hasOpener &&
        analysis.isTiebreakEntry &&
        !analysis.isTiebreakSet &&
        isShifted &&
        ensureInt(value) === 0) {
        analysis.isTiebreakCloser = true;
    }
    if (CLOSERS.includes(value) && analysis.hasOpener) {
        value = '';
    }
    if (CLOSERS.includes(value)) {
        // TODO: not sure this is necessary
        value = SPACE_KEY;
    }
    if (analysis.lastSetIsComplete) {
        var finalCharacter = (scoreString === null || scoreString === void 0 ? void 0 : scoreString.length) && scoreString[scoreString.length - 1];
        if (scoreString && finalCharacter !== ' ') {
            scoreString += ' ';
        }
    }
    if (analysis.isTimedSet) {
        (_a = keyValueTimedSetScore({
            analysis: analysis,
            lowSide: lowSide,
            scoreString: scoreString,
            sets: sets,
            matchUpStatus: matchUpStatus,
            winningSide: winningSide,
            value: value,
        }), info = _a.info, sets = _a.sets, scoreString = _a.scoreString, updated = _a.updated, matchUpStatus = _a.matchUpStatus, winningSide = _a.winningSide);
    }
    else if (OUTCOMEKEYS.includes(value)) {
        if (analysis.finalSetIsComplete || winningSide) {
            info = 'final set is already complete';
        }
        else if (!analysis.isTiebreakEntry && !analysis.isIncompleteSetScore) {
            (_b = processOutcome({
                lowSide: lowSide,
                sets: sets,
                scoreString: scoreString,
                matchUpStatus: matchUpStatus,
                winningSide: winningSide,
                value: value,
            }), sets = _b.sets, scoreString = _b.scoreString, matchUpStatus = _b.matchUpStatus, winningSide = _b.winningSide, updated = _b.updated);
        }
        else if (analysis.isTiebreakEntry || analysis.isIncompleteSetScore) {
            info = 'incomplete set scoreString or tiebreak entry';
        }
        else {
            console.log('handle case', { value: value });
        }
    }
    else if (value === BACKSPACE) {
        updated = true;
        (_c = removeFromScore({
            analysis: analysis,
            scoreString: scoreString,
            sets: sets,
            lowSide: lowSide,
        }), scoreString = _c.scoreString, sets = _c.sets);
        if (!scoreString)
            sets = [];
        matchUpStatus = undefined;
        winningSide = undefined;
    }
    else if (analysis.hasOutcome) {
        info = 'has outcome';
    }
    else if (value === SCORE_JOINER && !analysis.isMatchTiebreakEntry) {
        if (!analysis.isSetTiebreakEntry ||
            (analysis.isSetTiebreakEntry && !analysis.isNumericEnding)) {
            updated = true;
            (_d = removeFromScore({
                analysis: analysis,
                scoreString: scoreString,
                sets: sets,
                lowSide: lowSide,
            }), scoreString = _d.scoreString, sets = _d.sets);
            matchUpStatus = undefined;
        }
    }
    else if (value === MATCH_TIEBREAK_JOINER &&
        analysis.isMatchTiebreakEntry &&
        !analysis.isSetTiebreakEntry) {
        if (analysis.matchTiebreakHasJoiner) {
            info = 'existing joiner';
        }
        else if (analysis.isNumericEnding) {
            updated = true;
            scoreString += MATCH_TIEBREAK_JOINER;
        }
    }
    else if ([SCORE_JOINER, MATCH_TIEBREAK_JOINER].includes(value)) {
        info = 'invalid location for joiner';
    }
    else if (winningSide) {
        return { updated: false, info: 'matchUp is complete' };
    }
    else if (analysis.isIncompleteSetScore) {
        if (analysis.isNumericValue) {
            (_e = processIncompleteSetScore({
                analysis: analysis,
                scoreString: scoreString,
                sets: sets,
                value: value,
            }), sets = _e.sets, scoreString = _e.scoreString, updated = _e.updated);
        }
    }
    else if (analysis.isInvalidMatchTiebreakValue) {
        info = 'invalid matchUp tiebreak character';
    }
    else if (analysis.isInvalidSetTiebreakValue) {
        info = 'invalid set tiebreak character';
    }
    else if (analysis.isTiebreakCloser) {
        var brackets = analysis.isSetTiebreakEntry
            ? SET_TIEBREAK_BRACKETS
            : MATCH_TIEBREAK_BRACKETS;
        var close_1 = brackets.split('').reverse()[0];
        var open_1 = brackets.split('')[0];
        var set = sets[sets.length - 1];
        var tiebreakFormat = analysis.setFormat.tiebreakFormat;
        var _j = tiebreakFormat || {}, tiebreakTo = _j.tiebreakTo, NoAD = _j.NoAD;
        var leadingSide = getLeadingSide({ set: set });
        if (!analysis.isTiebreakSet) {
            var lowTiebreakScore = parseInt(scoreString.split(open_1).reverse()[0]);
            var highTiebreakScore = getHighTiebreakValue({
                lowValue: lowTiebreakScore,
                tiebreakTo: tiebreakTo,
                NoAD: NoAD,
            });
            if (leadingSide === 1) {
                set.side1TiebreakScore = highTiebreakScore;
                set.side2TiebreakScore = lowTiebreakScore;
            }
            else {
                set.side1TiebreakScore = lowTiebreakScore;
                set.side2TiebreakScore = highTiebreakScore;
            }
        }
        scoreString = (scoreString || '') + close_1;
        if (!analysis.isDecidingSet)
            scoreString += SPACE_CHARACTER;
        var winningSide_2 = getWinningSide({ analysis: analysis, set: set });
        set.winningSide = winningSide_2 || undefined;
        updated = true;
    }
    else if (analysis.isTiebreakSetValue) {
        (_f = processTiebreakSet({
            analysis: analysis,
            auto: auto,
            lowSide: lowSide,
            scoreString: scoreString,
            sets: sets,
            value: value,
        }), info = _f.info, scoreString = _f.scoreString, sets = _f.sets, updated = _f.updated);
    }
    else if (analysis.isSetTiebreakEntry) {
        var _k = __read(SET_TIEBREAK_BRACKETS.split(''), 1), open_2 = _k[0];
        var lastOpenBracketIndex = Math.max.apply(Math, __spreadArray([], __read(arrayIndices(open_2, scoreString.split(''))), false));
        var tiebreakValue = scoreString.slice(lastOpenBracketIndex + 1);
        var hasZeroStart = tiebreakValue && ensureInt(tiebreakValue) === ZERO;
        var newTiebreakValue = ensureInt(tiebreakValue ? tiebreakValue + value : value);
        var tiebreakFormat = analysis.setFormat.tiebreakFormat;
        var _l = tiebreakFormat || {}, tiebreakTo = _l.tiebreakTo, NoAD = _l.NoAD;
        if (!hasZeroStart && tiebreakValue.length < 2) {
            if (NoAD && newTiebreakValue > tiebreakTo - 1) {
                info = 'invalid low value for NoAD tiebreak';
            }
            else {
                updated = true;
                scoreString = (scoreString || '') + value;
            }
        }
        else {
            info = hasZeroStart
                ? 'tiebreak begins with zero'
                : 'tiebreak digit limit';
        }
    }
    else if (analysis.isCloser) {
        info = "invalid key: ".concat(value);
    }
    else if (analysis.isGameScoreEntry) {
        info = 'game scoreString entry';
    }
    else {
        if (analysis.lastSetIsComplete || !sets.length) {
            updated = true;
            var _m = keyValueSetScore({
                analysis: analysis,
                lowSide: lowSide,
                scoreString: scoreString,
                value: ensureInt(value),
            }), newScore = _m.scoreString, set = _m.set;
            if (set)
                set.setNumber = (sets === null || sets === void 0 ? void 0 : sets.length) + 1 || 1;
            sets = (sets === null || sets === void 0 ? void 0 : sets.concat(set).filter(Boolean)) || [set];
            scoreString = newScore || undefined;
        }
        else {
            console.log('error: unknown outcome');
        }
    }
    if (updated) {
        sets = sets === null || sets === void 0 ? void 0 : sets.filter(Boolean);
        var matchUpWinningSide_1 = getMatchUpWinner({
            sets: sets,
            winningSide: winningSide,
            matchUpStatus: matchUpStatus,
            matchUpFormat: matchUpFormat,
        }).matchUpWinningSide;
        winningSide = matchUpWinningSide_1;
        if (matchUpWinningSide_1 &&
            (!matchUpStatus || [TO_BE_PLAYED, INCOMPLETE].includes(matchUpStatus))) {
            matchUpStatus = OUTCOME_COMPLETE;
            sets = sets.filter(function (set) {
                var side1Score = set.side1Score, side2Score = set.side2Score, side1TiebreakScore = set.side1TiebreakScore, side2TiebreakScore = set.side2TiebreakScore;
                return (side1Score || side2Score || side1TiebreakScore || side2TiebreakScore);
            });
        }
        else if (scoreString &&
            !winningSide &&
            ![STATUS_SUSPENDED, STATUS_ABANDONED, STATUS_INTERRUPTED].includes(matchUpStatus)) {
            matchUpStatus = undefined;
        }
        return { updated: updated, scoreString: scoreString, sets: sets, winningSide: winningSide, matchUpStatus: matchUpStatus, info: info };
    }
    return { updated: updated, scoreString: scoreString, sets: sets, winningSide: winningSide, matchUpStatus: matchUpStatus, info: info };
}

function getHistory(_a) {
    var matchUp = _a.matchUp;
    var extension = findExtension({
        name: MATCHUP_HISTORY,
        element: matchUp,
    }).extension;
    if (!extension)
        return { error: NOT_FOUND };
    var _b = extension.value, _c = _b.history, history = _c === void 0 ? [] : _c, _d = _b.undoHistory, undoHistory = _d === void 0 ? [] : _d;
    return __assign({ history: history, undoHistory: undoHistory }, SUCCESS);
}

function calculateHistoryScore(params) {
    var e_1, _a;
    var _b;
    if (!params)
        return { error: MISSING_VALUE };
    var matchUp = params.matchUp, updateScore = params.updateScore;
    if (!matchUp)
        return { error: MISSING_MATCHUP };
    var history = ((_b = getHistory({ matchUp: matchUp })) === null || _b === void 0 ? void 0 : _b.history) || [];
    if (!Array.isArray(history))
        return { error: INVALID_VALUES, info: 'history is not an array' };
    var matchUpFormat = matchUp.matchUpFormat;
    if (!matchUpFormat)
        return { error: MISSING_MATCHUP_FORMAT };
    if (!isValidMatchUpFormat({ matchUpFormat: matchUpFormat }))
        return { error: INVALID_MATCHUP_FORMAT };
    var parsedFormat = parse(matchUpFormat);
    var bestOf = parsedFormat.bestOf, finalSetFormat = parsedFormat.finalSetFormat, setFormat = parsedFormat.setFormat;
    var pointProgression = ['0', '15', '30', '40', 'A', 'G'];
    //  const statsCounters = { 1: {}, 2: {} };
    var score = { sets: [] };
    var unknowns = [];
    var tiebreakServingSide;
    var sidePoints = [0, 0];
    var servingSide = 1;
    var setNumber = 0;
    var isFinalSet;
    var faults = 0;
    var isValidSide = function (value) { return [1, 2].includes(value); };
    var newSet = function () {
        setNumber += 1;
        return {
            winningSide: undefined,
            side1Score: 0,
            side2Score: 0,
            setNumber: setNumber,
            games: [],
        };
    };
    var newGame = function () {
        return {
            winningSide: undefined,
            points: [],
        };
    };
    var newPoint = function () {
        return {
            winningSide: undefined,
            side1Score: '',
            side2Score: '',
            shots: [],
        };
    };
    var point = newPoint();
    var game = newGame();
    var set = newSet();
    var processedCount = 0;
    var _loop_1 = function (item) {
        processedCount += 1;
        isFinalSet = score.sets.length + 1 === bestOf;
        var format = isFinalSet && finalSetFormat ? finalSetFormat : setFormat;
        var tiebreakAt = format.tiebreakAt, setTo = format.setTo, NoAD = format.NoAD, tiebbreakFormat = format.tiebbreakFormat;
        var isTiebreak = set.side1Score === tiebreakAt && set.side1Score === set.side2Score;
        var isTiebreakSet = !!format.tiebreakSet;
        var tiebreakDetails = isTiebreakSet
            ? format.tiebreakSet
            : tiebbreakFormat;
        var _c = tiebreakDetails || {}, tiebreakTo = _c.tiebreakTo, tiebreakNoAD = _c.NoAD;
        var cleanup = function () {
            tiebreakServingSide = undefined;
            sidePoints = [0, 0];
            servingSide = 3 - servingSide;
            set.side1TiebreakScore = 0;
            set.side2TiebreakScore = 0;
            set.side1PointScore = '';
            set.side2PointScore = '';
            faults = 0;
        };
        var completeSet = function (winningSide) {
            set.winningSide = winningSide;
            set.s; var rest = __rest(set, ["s"]);
            score.sets.push(rest);
            point = newPoint();
            game = newGame();
            set = newSet();
            cleanup();
        };
        var completeGame = function (winningSide) {
            game.winningSide = winningSide;
            game.g; var rest = __rest(game, ["g"]);
            set.games.push(rest);
            point = newPoint();
            game = newGame();
            cleanup();
            var winningScoreSide = "side".concat(winningSide, "Score");
            set[winningScoreSide] += 1;
        };
        var completePoint = function (winningSide) {
            point.winningSide = winningSide;
            point.p; var rest = __rest(point, ["p"]);
            game.points.push(rest);
            point = newPoint();
            faults = 0;
            var getTiebreakServingSide = function () {
                var pointsCount = sidePoints.reduce(function (a, b) { return a + b; });
                var value = (pointsCount % 4) / 4;
                return value > 0.5 ? servingSide : 3 - servingSide;
            };
            var winningIndex = winningSide - 1;
            if (isTiebreak || isTiebreakSet) {
                sidePoints[winningIndex] += 1;
                tiebreakServingSide = getTiebreakServingSide();
                set["side".concat(winningSide, "TiebreakScore")] = sidePoints[winningIndex];
                set["side".concat(3 - winningSide, "TiebreakScore")] =
                    sidePoints[1 - winningIndex];
                var winBy = tiebreakNoAD ? 1 : 2;
                if (sidePoints[winningIndex] >= tiebreakTo &&
                    sidePoints[winningIndex] >= sidePoints[1 - winningIndex] + winBy) {
                    completeGame(winningSide);
                    return { gameCompleted: true };
                }
            }
            else {
                if (sidePoints[1 - winningIndex] === 4 &&
                    sidePoints[winningIndex] === 3) {
                    // return to deuce
                    sidePoints[1 - winningIndex] -= 1;
                }
                else {
                    sidePoints[winningIndex] += 1;
                }
                set.side1PointScore = pointProgression[sidePoints[0]];
                set.side2PointScore = pointProgression[sidePoints[1]];
                if (sidePoints[winningIndex] === 5 ||
                    (sidePoints[winningIndex] === 4 &&
                        sidePoints[1 - winningIndex] < 3) ||
                    (NoAD && sidePoints[winningIndex] === 4)) {
                    completeGame(winningSide);
                    return { gameCompleted: true };
                }
            }
            return undefined;
        };
        if (isValidSide(item.srv)) {
            servingSide = item.srv;
        }
        if (['p', 's', 'g', 'o'].includes(item.u)) {
            unknowns.push(item.u);
        }
        if (item.shotOutcome) {
            point.shots.push(item);
            var isServe = item.shotType === 'SERVE';
            if (isServe && ['OUT', 'NET'].includes(item.shotOutcome))
                faults += 1;
            if (faults === 2) {
                var winningSide = 3 - servingSide;
                completePoint(winningSide);
            }
        }
        if (isValidSide(item.p) || isConvertableInteger(item.pointNumber)) {
            var winningSide = item.winningSide || item.p;
            var result = completePoint(winningSide);
            if (result === null || result === void 0 ? void 0 : result.gameCompleted)
                return "continue";
        }
        if (isValidSide(item.g) || isConvertableInteger(item.gameNumber)) {
            var winningSide = item.winningSide || item.g;
            game.winningSide = winningSide;
            var winningScoreSide = "side".concat(winningSide, "Score");
            var losingScoreSide = "side".concat(3 - winningSide, "Score");
            if (unknowns.length) {
                if (unknowns.includes('p')) ;
                unknowns = [];
            }
            completeGame(winningSide);
            var setIsComplete = set[winningScoreSide] === setTo &&
                set[winningScoreSide] - set[losingScoreSide] >= (NoAD ? 1 : 2);
            if (setIsComplete) {
                completeSet(winningSide);
                if (isFinalSet)
                    return "break";
            }
        }
        if (isValidSide(item.s) || isConvertableInteger(item.setNumber)) {
            var winningSide = item.winningSide || item.s;
            completeSet(winningSide);
            if (unknowns.length) {
                if (unknowns.includes('p')) ;
                if (unknowns.includes('g')) ;
                unknowns = [];
            }
            // check if match is complete
            if (isFinalSet)
                return "break";
        }
    };
    try {
        for (var history_1 = __values(history), history_1_1 = history_1.next(); !history_1_1.done; history_1_1 = history_1.next()) {
            var item = history_1_1.value;
            var state_1 = _loop_1(item);
            if (state_1 === "break")
                break;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (history_1_1 && !history_1_1.done && (_a = history_1.return)) _a.call(history_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (processedCount !== history.length) {
        console.log({ error: 'Match completed with excess history' });
    }
    if (set.side1Score ||
        set.side2Score ||
        set.games.length ||
        set.side1TiebreakScore ||
        set.side2TiebreakScore) {
        score.sets.push(set);
    }
    score.scoreStringSide1 = generateScoreString(__assign(__assign({}, score), { matchUpFormat: matchUpFormat }));
    score.scoreStringSide2 = generateScoreString(__assign(__assign({}, score), { matchUpFormat: matchUpFormat, reversed: true }));
    servingSide = tiebreakServingSide || servingSide;
    if (updateScore)
        matchUp.score = score;
    return __assign(__assign({}, SUCCESS), { servingSide: servingSide, score: score });
}

function saveHistory(_a) {
    var undoHistory = _a.undoHistory, history = _a.history, matchUp = _a.matchUp;
    var extension = {
        value: { history: history, undoHistory: undoHistory },
        name: MATCHUP_HISTORY,
    };
    return addExtension({ element: matchUp, extension: extension });
}

function setServingSide(_a) {
    var matchUp = _a.matchUp, sideNumber = _a.sideNumber;
    // TODO: check game validity
    if (![1, 2].includes(sideNumber))
        return { error: INVALID_SIDE_NUMBER };
    // do not destructure undoHistory; it is destroyed when adding to history
    var _b = getHistory({ matchUp: matchUp }).history, history = _b === void 0 ? [] : _b;
    history.push({ srv: sideNumber });
    return saveHistory({ matchUp: matchUp, history: history });
}

function clearHistory(_a) {
    var matchUp = _a.matchUp;
    return saveHistory({ matchUp: matchUp });
}

function addPoint(_a) {
    var matchUp = _a.matchUp, point = _a.point;
    // TODO: check point validity
    if (!point)
        return { error: MISSING_VALUE };
    if (typeof point !== 'object')
        return { error: INVALID_VALUES, context: { point: point } };
    // do not destructure undoHistory; it is destroyed when adding to history
    var _b = getHistory({ matchUp: matchUp }).history, history = _b === void 0 ? [] : _b;
    history.push(point);
    return saveHistory({ matchUp: matchUp, history: history });
}

function addGame(_a) {
    var matchUp = _a.matchUp, game = _a.game;
    // TODO: check game validity
    if (typeof game !== 'object')
        return { error: INVALID_VALUES, context: { game: game } };
    // do not destructure undoHistory; it is destroyed when adding to history
    var _b = getHistory({ matchUp: matchUp }).history, history = _b === void 0 ? [] : _b;
    history.push(game);
    return saveHistory({ matchUp: matchUp, history: history });
}

function addShot(_a) {
    var matchUp = _a.matchUp, shot = _a.shot;
    // TODO: check game validity
    if (typeof shot !== 'object')
        return { error: MISSING_VALUE };
    // do not destructure undoHistory; it is destroyed when adding to history
    var _b = getHistory({ matchUp: matchUp }).history, history = _b === void 0 ? [] : _b;
    history.push(shot);
    return saveHistory({ matchUp: matchUp, history: history });
}

function addSet(_a) {
    var matchUp = _a.matchUp, set = _a.set;
    // TODO: check set validity
    if (typeof set !== 'object')
        return { error: MISSING_VALUE };
    // do not destructure undoHistory; it is destroyed when adding to history
    var _b = getHistory({ matchUp: matchUp }).history, history = _b === void 0 ? [] : _b;
    history.push(set);
    return saveHistory({ matchUp: matchUp, history: history });
}

function redo(_a) {
    var matchUp = _a.matchUp;
    var _b = getHistory({ matchUp: matchUp }), _c = _b.history, history = _c === void 0 ? [] : _c, _d = _b.undoHistory, undoHistory = _d === void 0 ? [] : _d;
    if (undoHistory.length)
        history.push(undoHistory.pop());
    return saveHistory({ matchUp: matchUp, history: history, undoHistory: undoHistory });
}

function undo(_a) {
    var matchUp = _a.matchUp;
    var _b = getHistory({ matchUp: matchUp }), _c = _b.history, history = _c === void 0 ? [] : _c, _d = _b.undoHistory, undoHistory = _d === void 0 ? [] : _d;
    undoHistory.push(history.pop());
    return saveHistory({ matchUp: matchUp, history: history, undoHistory: undoHistory });
}

var umo = {
    scoreboard: function () { },
    addPoints: function () { },
    addPoint: function () { },
};

var scoreGovernor = {
    analyzeSet: analyzeSet,
    checkScoreHasValue: checkScoreHasValue,
    checkSetIsComplete: checkSetIsComplete,
    generateScoreString: generateScoreString,
    generateTieMatchUpScore: generateTieMatchUpScore,
    getSetComplement: getSetComplement,
    getTiebreakComplement: getTiebreakComplement,
    isValidMatchUpFormat: isValidMatchUpFormat,
    keyValueScore: keyValueScore,
    parseMatchUpFormat: parse,
    reverseScore: reverseScore,
    stringifyMatchUpFormat: stringify,
    tidyScore: tidyScore,
    updateTieMatchUpScore: updateTieMatchUpScore,
    validateScore: validateScore,
    validateTieFormat: validateTieFormat,
    calculateHistoryScore: calculateHistoryScore,
    setServingSide: setServingSide,
    clearHistory: clearHistory,
    addPoint: addPoint,
    addGame: addGame,
    addShot: addShot,
    addSet: addSet,
    redo: redo,
    undo: undo,
    umo: umo,
};

var ABANDONED = 'ABANDONED';
var ACTIVE = 'ACTIVE';
var CANCELLED = 'CANCELLED';
var COMPLETED = 'COMPLETED';
var IN_PROGRESS = 'IN_PROGRESS';
var tournamentConstants = {
    ABANDONED: ABANDONED,
    ACTIVE: ACTIVE,
    CANCELLED: CANCELLED,
    COMPLETED: COMPLETED,
    IN_PROGRESS: IN_PROGRESS,
};

function setTournamentStatus(_a) {
    var tournamentRecord = _a.tournamentRecord, status = _a.status;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (status && !Object.keys(tournamentConstants).includes(status))
        return { error: INVALID_VALUES, info: 'Unknown status' };
    tournamentRecord.tournamentStatus = status;
    return __assign({}, SUCCESS);
}

function addOnlineResource(_a) {
    var _b, _c, _d, _e, _f, _g;
    var tournamentRecord = _a.tournamentRecord, onlineResource = _a.onlineResource, organisationId = _a.organisationId, participantId = _a.participantId, personId = _a.personId, courtId = _a.courtId, venueId = _a.venueId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!isObject(onlineResource))
        return { error: MISSING_VALUE };
    if (intersection(Object.keys(onlineResource), [
        'resourceSubType',
        'resourceType',
        'identifier',
    ]).length !== 3)
        return decorateResult({
            result: { error: INVALID_OBJECT },
            context: { onlineResource: onlineResource },
        });
    if (organisationId) {
        if (((_b = tournamentRecord.parentOrganisation) === null || _b === void 0 ? void 0 : _b.parentOrganisationId) !==
            organisationId) {
            return decorateResult({ result: { error: NOT_FOUND } });
        }
        if (!tournamentRecord.parentOrganisation.onlineResources)
            tournamentRecord.parentOrganisation.onlineResources = [];
        tournamentRecord.parentOrganisation.onlineResources.push(onlineResource);
    }
    else if (participantId || personId) {
        var participant = ((_c = tournamentRecord.participants) !== null && _c !== void 0 ? _c : []).find(function (p) {
            var _a;
            return (personId && ((_a = p.person) === null || _a === void 0 ? void 0 : _a.personId) === personId) ||
                p.participantId === participantId;
        });
        if (!participant) {
            if (personId) {
                return decorateResult({ result: { error: NOT_FOUND } });
            }
            else {
                return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND } });
            }
        }
        if (personId) {
            if (((_d = participant.person) === null || _d === void 0 ? void 0 : _d.personId) !== personId) {
                // both personId and participantId were provided and person does not match found participant
                return decorateResult({ result: { error: INVALID_PARTICIPANT } });
            }
            if (!participant.person.onlineResources)
                participant.person.onlineResources = [];
            participant.person.onlineResources.push(onlineResource);
        }
        else {
            if (!participant.onlineResources)
                participant.onlineResources = [];
            participant.onlineResources.push(onlineResource);
        }
    }
    else if (courtId) {
        var court = (_f = ((_e = tournamentRecord.venues) !== null && _e !== void 0 ? _e : [])
            .filter(function (v) { return !venueId || v.venueId === venueId; })
            .flatMap(function (v) { var _a; return ((_a = v.courts) !== null && _a !== void 0 ? _a : []).filter(function (c) { return c.courtId === courtId; }); })) === null || _f === void 0 ? void 0 : _f[0];
        if (!court)
            return decorateResult({ result: { error: COURT_NOT_FOUND } });
        if (!court.onlineResources)
            court.onlineResources = [];
        court.onlineResources.push(onlineResource);
    }
    else if (venueId) {
        var venue = ((_g = tournamentRecord.venues) !== null && _g !== void 0 ? _g : []).find(function (v) { return v.venueId === venueId; });
        if (!venue)
            return decorateResult({ result: { error: VENUE_NOT_FOUND } });
        if (!venue.onlineResources)
            venue.onlineResources = [];
        venue.onlineResources.push(onlineResource);
    }
    else {
        if (!tournamentRecord.onlineResources)
            tournamentRecord.onlineResources = [];
        tournamentRecord.onlineResources.push(onlineResource);
    }
    return __assign({}, SUCCESS);
}

function setTournamentName(_a) {
    var tournamentRecord = _a.tournamentRecord, promotionalName = _a.promotionalName, tournamentName = _a.tournamentName, formalName = _a.formalName;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (tournamentName)
        tournamentRecord.tournamentName = tournamentName;
    if (promotionalName)
        tournamentRecord.promotionalName = promotionalName;
    if (formalName)
        tournamentRecord.formalName = formalName;
    if (tournamentRecord.promotionalName === tournamentRecord.tournamentName) {
        delete tournamentRecord.promotionalName;
    }
    if (tournamentRecord.formalName === tournamentRecord.tournamentName) {
        delete tournamentRecord.formalName;
    }
    return __assign({}, SUCCESS);
}
function setTournamentNotes(_a) {
    var tournamentRecord = _a.tournamentRecord, notes = _a.notes;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    return addNotes({ element: tournamentRecord, notes: notes });
}
function setTournamentCategories(_a) {
    var tournamentRecord = _a.tournamentRecord, categories = _a.categories;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    categories = (categories || []).filter(function (category) {
        return category.categoryName && category.type;
    });
    tournamentRecord.tournamentCategories = categories;
    return __assign({}, SUCCESS);
}

// bulk update when tournament dates change
// TODO: check to see if court is present in other linked tournaments
function updateCourtAvailability(_a) {
    var e_1, _b, e_2, _c;
    var _d, _e, _f;
    var tournamentRecord = _a.tournamentRecord;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var startDate = tournamentRecord.startDate, endDate = tournamentRecord.endDate;
    var tournamentDates = generateDateRange(startDate, endDate);
    var courts = [];
    try {
        for (var _g = __values(tournamentRecord.venues || []), _h = _g.next(); !_h.done; _h = _g.next()) {
            var venue = _h.value;
            if ((_d = venue === null || venue === void 0 ? void 0 : venue.courts) === null || _d === void 0 ? void 0 : _d.length)
                courts.push.apply(courts, __spreadArray([], __read(venue.courts), false));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var _loop_1 = function (court) {
        var _j = ((_e = court.dateAvailability) !== null && _e !== void 0 ? _e : []).reduce(function (extents, availability) {
            var startMinutes = timeStringMinutes(extents.startTime);
            var endMinutes = timeStringMinutes(extents.endTime);
            if (availability.startTime && timeStringMinutes(availability.startTime) < startMinutes)
                extents.startTime = availability.startTime;
            if (availability.endTime && timeStringMinutes(availability.endTime) > endMinutes)
                extents.endTime = availability.endTime;
            return extents;
        }, { startTime: '08:00', endTime: '18:00' }), startTime = _j.startTime, endTime = _j.endTime;
        var updatedDateAvailability = tournamentDates.map(function (date) {
            var _a;
            var existing = (_a = court.dateAvailability) === null || _a === void 0 ? void 0 : _a.find(function (availability) { return availability.date === date; });
            return existing !== null && existing !== void 0 ? existing : { date: date, startTime: startTime, endTime: endTime };
        });
        var defaultAvailability = (_f = court.dateAvailability) === null || _f === void 0 ? void 0 : _f.find(function (availability) { return !availability.date; });
        if (defaultAvailability)
            updatedDateAvailability.unshift(defaultAvailability);
        court.dateAvailability = updatedDateAvailability;
    };
    try {
        for (var courts_1 = __values(courts), courts_1_1 = courts_1.next(); !courts_1_1.done; courts_1_1 = courts_1.next()) {
            var court = courts_1_1.value;
            _loop_1(court);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (courts_1_1 && !courts_1_1.done && (_c = courts_1.return)) _c.call(courts_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return __assign({}, SUCCESS);
}

function setTournamentDates(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, startDate = _a.startDate, endDate = _a.endDate;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if ((startDate && !dateValidation.test(startDate)) ||
        (endDate && !dateValidation.test(endDate)))
        return { error: INVALID_DATE };
    if (!startDate && !endDate)
        return { error: MISSING_DATE };
    if (endDate && startDate && new Date(endDate) < new Date(startDate))
        return { error: INVALID_VALUES };
    var checkScheduling;
    // if start has moved closer to end or end has moved closer to start, check for scheduling issues
    if ((startDate &&
        tournamentRecord.startDate &&
        new Date(startDate) > new Date(tournamentRecord.startDate)) ||
        (endDate &&
            tournamentRecord.endDate &&
            new Date(endDate) < new Date(tournamentRecord.endDate))) {
        checkScheduling = true;
    }
    if (startDate)
        tournamentRecord.startDate = startDate;
    if (endDate)
        tournamentRecord.endDate = endDate;
    // if there is a startDate specified after current endDate, endDate must be set to startDate
    if (startDate &&
        tournamentRecord.endDate &&
        new Date(startDate) > new Date(tournamentRecord.endDate)) {
        tournamentRecord.endDate = startDate;
    }
    // if there is a endDate specified before current startDate, startDate must be set to endDate
    if (endDate &&
        tournamentRecord.startDate &&
        new Date(endDate) < new Date(tournamentRecord.startDate)) {
        tournamentRecord.startDate = endDate;
    }
    var unscheduledMatchUpIds = checkScheduling &&
        ((_b = removeInvalidScheduling({ tournamentRecord: tournamentRecord })) === null || _b === void 0 ? void 0 : _b.unscheduledMatchUpIds);
    updateCourtAvailability({ tournamentRecord: tournamentRecord });
    addNotice({
        topic: MODIFY_TOURNAMENT_DETAIL,
        payload: { startDate: startDate, endDate: endDate },
    });
    return __assign(__assign({}, SUCCESS), { unscheduledMatchUpIds: unscheduledMatchUpIds });
}
function setTournamentStartDate(_a) {
    var tournamentRecord = _a.tournamentRecord, startDate = _a.startDate;
    return setTournamentDates({ tournamentRecord: tournamentRecord, startDate: startDate });
}
function setTournamentEndDate(_a) {
    var tournamentRecord = _a.tournamentRecord, endDate = _a.endDate;
    return setTournamentDates({ tournamentRecord: tournamentRecord, endDate: endDate });
}
// unschedule scheduled matchUps that fall outside of tournament dates
function removeInvalidScheduling(_a) {
    var e_1, _b;
    var _c;
    var tournamentRecord = _a.tournamentRecord;
    var matchUps = (_c = allTournamentMatchUps({ tournamentRecord: tournamentRecord }).matchUps) !== null && _c !== void 0 ? _c : [];
    var startDate = tournamentRecord.startDate && new Date(tournamentRecord.startDate);
    var endDate = tournamentRecord.endDate && new Date(tournamentRecord.endDate);
    var invalidScheduledDates = [];
    var invalidSchedulingMatchUpIds = [];
    try {
        for (var matchUps_1 = __values(matchUps), matchUps_1_1 = matchUps_1.next(); !matchUps_1_1.done; matchUps_1_1 = matchUps_1.next()) {
            var matchUp = matchUps_1_1.value;
            var schedule = matchUp.schedule, matchUpId = matchUp.matchUpId;
            if (!schedule)
                continue;
            if (schedule.scheduledDate) {
                var scheduledDate = new Date(schedule.scheduledDate);
                if ((startDate && scheduledDate < startDate) ||
                    (endDate && scheduledDate > endDate)) {
                    invalidSchedulingMatchUpIds.push(matchUpId);
                    if (!invalidScheduledDates.includes(schedule.scheduledDate))
                        invalidScheduledDates.push(schedule.scheduledDate);
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (matchUps_1_1 && !matchUps_1_1.done && (_b = matchUps_1.return)) _b.call(matchUps_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (invalidScheduledDates.length) {
        var result = clearScheduledMatchUps({
            scheduledDates: invalidScheduledDates,
            tournamentRecord: tournamentRecord,
        });
        if (!result.clearedScheduleCount)
            return { error: SCHEDULE_NOT_CLEARED };
    }
    return { unscheduledMatchUpIds: invalidSchedulingMatchUpIds };
}

var tournamentGovernor = {
    addDrawDefinitionExtension: addDrawDefinitionExtension,
    addEventExtension: addEventExtension,
    addEventTimeItem: addEventTimeItem,
    addExtension: addExtension,
    addNotes: addNotes,
    addOnlineResource: addOnlineResource,
    addParticipantExtension: addParticipantExtension,
    addParticipantTimeItem: addParticipantTimeItem,
    addTimeItem: addTimeItem,
    addTournamentExtension: addTournamentExtension,
    addTournamentTimeItem: addTournamentTimeItem,
    getProfileRounds: getProfileRounds,
    removeDrawDefinitionExtension: removeDrawDefinitionExtension,
    removeEventExtension: removeEventExtension,
    removeExtension: removeExtension,
    removeNotes: removeNotes,
    removeParticipantExtension: removeParticipantExtension,
    removeTournamentExtension: removeTournamentExtension,
    setTournamentCategories: setTournamentCategories,
    setTournamentDates: setTournamentDates,
    setTournamentEndDate: setTournamentEndDate,
    setTournamentName: setTournamentName,
    setTournamentNotes: setTournamentNotes,
    setTournamentStartDate: setTournamentStartDate,
    setTournamentStatus: setTournamentStatus,
};

function visualizeScheduledMatchUps(_a) {
    var scheduledMatchUps = _a.scheduledMatchUps, showGlobalLog = _a.showGlobalLog;
    purgeGlobalLog();
    var structureIds = scheduledMatchUps === null || scheduledMatchUps === void 0 ? void 0 : scheduledMatchUps.reduce(function (structureIds, _a) {
        var structureId = _a.structureId;
        return structureIds.includes(structureId)
            ? structureIds
            : structureIds.concat(structureId);
    }, []);
    var structureNames = Array.isArray(structureIds) && __assign({}, structureIds.map(function (structureId) {
        var _a;
        var _b = scheduledMatchUps.find(function (matchUp) { return matchUp.structureId === structureId; }), structureName = _b.structureName, matchUpType = _b.matchUpType;
        return _a = {},
            _a[structureId] = "".concat(structureName, " ").concat(matchUpType),
            _a;
    }));
    structureIds === null || structureIds === void 0 ? void 0 : structureIds.forEach(function (structureId) {
        var _a;
        pushGlobalLog({
            color: 'blue',
            method: 'draw',
            structure: structureNames[structureId],
            keyColors: {
                structure: 'magenta',
            },
        }, true);
        var structureMatchUps = scheduledMatchUps.filter(function (matchUp) { return matchUp.structureId === structureId; });
        var roundMatchUps = ((_a = getRoundMatchUps({
            matchUps: structureMatchUps,
        })) === null || _a === void 0 ? void 0 : _a.roundMatchUps) || [];
        Object.keys(roundMatchUps).forEach(function (roundNumber) {
            pushGlobalLog({
                roundNumber: roundNumber,
                keyColors: {
                    roundNumber: 'brightcyan',
                },
            }, true);
            roundMatchUps[roundNumber].forEach(function (_a) {
                var matchUpId = _a.matchUpId, schedule = _a.schedule;
                var scheduledTime = extractTime(schedule.scheduledTime);
                pushGlobalLog({
                    matchUpId: matchUpId,
                    time: scheduledTime,
                    date: schedule.scheduledDate,
                    venue: schedule.venueId,
                    keyColors: {
                        time: 'brightcyan',
                        date: 'brightcyan',
                        matchUpId: 'yellow',
                        venue: 'magenta',
                    },
                }, true);
            });
        });
    });
    if (showGlobalLog)
        printGlobalLog();
}

function dehydrateMatchUps(_a) {
    var tournamentRecord = _a.tournamentRecord;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (typeof tournamentRecord !== 'object' || !tournamentRecord.tournamentId)
        return { error: INVALID_VALUES };
    var matchUps = allTournamentMatchUps({
        tournamentRecord: tournamentRecord,
        inContext: false,
    }).matchUps;
    if (matchUps === null || matchUps === void 0 ? void 0 : matchUps.length) {
        var matchUpFormatMap = getMatchUpFormatMap({ tournamentRecord: tournamentRecord });
        removeExtraneousAttributes(matchUps, matchUpFormatMap);
    }
    return __assign({}, SUCCESS);
}
function getMatchUpFormatMap(_a) {
    var e_1, _b, e_2, _c, e_3, _d, e_4, _e;
    var tournamentRecord = _a.tournamentRecord;
    var matchUpFormatMap = {};
    try {
        for (var _f = __values(tournamentRecord.events || []), _g = _f.next(); !_g.done; _g = _f.next()) {
            var event_1 = _g.value;
            if (event_1.matchUpFormat)
                matchUpFormatMap[event_1.eventId] = event_1.matchUpFormat;
            try {
                for (var _h = (e_2 = void 0, __values(event_1.drawDefinitions || [])), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var drawDefinition = _j.value;
                    if (drawDefinition.matchUpFormat)
                        matchUpFormatMap[drawDefinition.drawId] = drawDefinition.matchUpFormat;
                    try {
                        for (var _k = (e_3 = void 0, __values(drawDefinition.structures || [])), _l = _k.next(); !_l.done; _l = _k.next()) {
                            var structure = _l.value;
                            if (structure.matchUpFormat)
                                matchUpFormatMap[structure.structureId] = structure.matchUpFormat;
                            try {
                                for (var _m = (e_4 = void 0, __values(structure.structures || [])), _o = _m.next(); !_o.done; _o = _m.next()) {
                                    var childStructure = _o.value;
                                    if (childStructure.matchUpFormat)
                                        matchUpFormatMap[childStructure.structureId] =
                                            childStructure.matchUpFormat;
                                }
                            }
                            catch (e_4_1) { e_4 = { error: e_4_1 }; }
                            finally {
                                try {
                                    if (_o && !_o.done && (_e = _m.return)) _e.call(_m);
                                }
                                finally { if (e_4) throw e_4.error; }
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_l && !_l.done && (_d = _k.return)) _d.call(_k);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return matchUpFormatMap;
}
var baseAttributeKeys = [
    'collectionId',
    'collectionPosition',
    'drawPositions',
    'extensions',
    'finishingPositionRange',
    'finishingRound',
    'isMock',
    'matchUpId',
    'matchUpStatus',
    'matchUpStatusCodes',
    'orderOfFinish',
    'processCodes',
    'roundNumber',
    'tieFormat',
    'tieMatchUps',
    'roundPosition',
    'score',
    'sides', // can be removed only if drawPositions is present and is not a TEAM matchUp
    'winnerMatchUpId',
    'loserMatchUpId',
    'matchUpDuration',
    'winningSide',
];
function removeExtraneousAttributes(matchUps, matchUpFormatMap) {
    var e_5, _a, e_6, _b;
    if (matchUpFormatMap === void 0) { matchUpFormatMap = {}; }
    try {
        for (var matchUps_1 = __values(matchUps), matchUps_1_1 = matchUps_1.next(); !matchUps_1_1.done; matchUps_1_1 = matchUps_1.next()) {
            var matchUp = matchUps_1_1.value;
            var structureId = matchUp.structureId, drawId = matchUp.drawId, eventId = matchUp.eventId;
            var inheritedMatchUpFormat = matchUpFormatMap[structureId] ||
                matchUpFormatMap[drawId] ||
                matchUpFormatMap[eventId];
            var matchUpFormat = matchUp.matchUpFormat === inheritedMatchUpFormat
                ? undefined
                : matchUp.matchUpFormat;
            try {
                for (var _c = (e_6 = void 0, __values(Object.keys(matchUp))), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var key = _d.value;
                    if (!baseAttributeKeys.includes(key))
                        delete matchUp[key];
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_6) throw e_6.error; }
            }
            if (matchUp.sides && matchUp.drawPositions && !matchUp.tieMatchUps) {
                delete matchUp.sides;
            }
            if (matchUpFormat)
                matchUp.matchUpFormat = matchUpFormat;
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (matchUps_1_1 && !matchUps_1_1.done && (_a = matchUps_1.return)) _a.call(matchUps_1);
        }
        finally { if (e_5) throw e_5.error; }
    }
}

/**
 *
 * @param {object[]} arrayOfJSON - JSON objects array
 * @param {object} config - object which configures processing (see below)
 * @returns {string} - joined by '\r\n' or specified line separator
 *
 * config {
 *  {boolean} includeTransformAccessors, // transform accessors are included with columnAccessors
 *  {string[]} columnAccessors, // [ 'includeThis', 'andThis' ]
 *  {object} columnTransform, // e.g. { 'newColumnName': ['oldColumn1', 'oldColumn2' ]}
 *  {object} columnMap, // e.g. { 'columnName': 'newColumnName' }
 *  {object} valuesMap, // e.g. { 'columnName': { 'value1': 'mappedValue' }} // useful for mapping IDs
 *  {array} sortOrder // e.g. ['columnName1', 'columnName2'] // determine order of csv columns
 *  {object} context, // attributes which are to be added to all rows { 'columnName': 'value }
 *  {string} delimiter, // defaults to '"'
 *  {string} columnJoiner, // defaults to ',' // defines how CSV columns are joined
 *  {string} rowJoiner, // defaults to '\r\n' // defines how CSV lines are joined
 *  {string} keyJoiner, // defaults to '.' // defines how flattened column names are constructed
 * }
 *
 * NOTE: `columnTransform` mapped array elements are sensitive to order and will resolve to the first matching value
 * NOTE: `columnMap` should not contain new columnName(s) that are `columnTransform` keys
 */
function JSON2CSV(arrayOfJSON, config) {
    if (config && typeof config !== 'object')
        return INVALID_VALUES;
    var _a = (config || {}).columnTransform, columnTransform = _a === void 0 ? {} : _a;
    var _b = config || {}, includeTransformAccessors = _b.includeTransformAccessors, _c = _b.includeHeaderRow, includeHeaderRow = _c === void 0 ? true : _c, returnTransformedJSON = _b.returnTransformedJSON, removeEmptyColumns = _b.removeEmptyColumns, onlyHeaderRow = _b.onlyHeaderRow, _d = _b.columnAccessors, columnAccessors = _d === void 0 ? [] : _d, _e = _b.functionMap, functionMap = _e === void 0 ? {} : _e, _f = _b.columnMap, columnMap = _f === void 0 ? {} : _f, _g = _b.valuesMap, valuesMap = _g === void 0 ? {} : _g, _h = _b.context, context = _h === void 0 ? {} : _h, _j = _b.delimiter, delimiter = _j === void 0 ? '"' : _j, _k = _b.columnJoiner, columnJoiner = _k === void 0 ? ',' : _k, _l = _b.rowJoiner, rowJoiner = _l === void 0 ? '\r\n' : _l, _m = _b.keyJoiner, keyJoiner = _m === void 0 ? '.' : _m;
    if (!Array.isArray(arrayOfJSON) ||
        !Array.isArray(columnAccessors) ||
        typeof context !== 'object' ||
        typeof columnMap !== 'object' ||
        typeof columnTransform !== 'object' ||
        typeof functionMap !== 'object' ||
        typeof valuesMap !== 'object' ||
        typeof columnJoiner !== 'string' ||
        typeof rowJoiner !== 'string' ||
        typeof keyJoiner !== 'string' ||
        typeof delimiter !== 'string')
        return INVALID_VALUES;
    // ensure all column transformers are arrays
    columnTransform = Object.assign.apply(Object, __spreadArray([{}], __read(Object.keys(columnTransform)
        .reverse() // reverse so that exported CSV columns are in the order as defined
        .map(function (key) {
        var _a;
        return (_a = {},
            _a[key] = Array.isArray(columnTransform[key])
                ? columnTransform[key]
                : [
                    // ensure transform attributes are strings
                    typeof columnTransform[key] === 'string' && columnTransform[key],
                ].filter(Boolean),
            _a);
    })), false));
    var flattened = arrayOfJSON
        .filter(Boolean)
        .map(function (obj) { return flattenJSON(obj, keyJoiner); });
    var transformColumns = Object.values(columnTransform).flat();
    if (includeTransformAccessors)
        columnAccessors.push.apply(columnAccessors, __spreadArray([], __read(transformColumns), false));
    var headerRow = flattened
        .reduce(function (aggregator, row) {
        return Object.keys(row).every(function (key) { return (!aggregator.includes(key) && aggregator.push(key)) || true; }) && aggregator;
    }, [])
        .filter(function (key) { return !(columnAccessors === null || columnAccessors === void 0 ? void 0 : columnAccessors.length) || columnAccessors.includes(key); });
    var accessorMap = Object.assign.apply(Object, __spreadArray([{}], __read(Object.keys(columnTransform)
        .reverse() // so that original order is preserved when later pushed
        .map(function (transform) {
        return columnTransform[transform]
            .map(function (value) {
            var _a;
            return (_a = {}, _a[value] = transform, _a);
        })
            .flat();
    })
        .flat()), false));
    var sortColumns = function (a, b) {
        return !(config === null || config === void 0 ? void 0 : config.sortOrder)
            ? 0
            : (config.sortOrder.includes(a) &&
                config.sortOrder.includes(b) &&
                config.sortOrder.indexOf(a) - config.sortOrder.indexOf(b)) ||
                (!config.sortOrder.includes(b) && -1);
    };
    var tranformedHeaderRow = headerRow
        .reduce(function (def, key) {
        var transform = accessorMap[key];
        if (transform) {
            if (!def.includes(transform))
                def.push(transform);
        }
        else {
            def.push(key);
        }
        return def;
    }, [])
        .sort(sortColumns);
    Object.keys(columnMap).forEach(function (columnName) {
        return !tranformedHeaderRow.includes(columnName) &&
            tranformedHeaderRow.unshift(columnName);
    });
    Object.keys(columnTransform).forEach(function (columnName) {
        return !tranformedHeaderRow.includes(columnName) &&
            tranformedHeaderRow.unshift(columnName);
    });
    typeof context === 'object' &&
        Object.keys(context).forEach(function (columnName) {
            return !tranformedHeaderRow.includes(columnName) &&
                tranformedHeaderRow.unshift(columnName);
        });
    var mappedHeaderRow = tranformedHeaderRow.map(function (key) { return columnMap[key] || key; });
    if (onlyHeaderRow)
        return [mappedHeaderRow];
    var withDelimiter = function (value) { return "".concat(delimiter).concat(value).concat(delimiter); };
    var columnValueCounts = [];
    var processRow = function (row) {
        return Object.values(tranformedHeaderRow.reduce(function (columnsMap, columnName, columnIndex) {
            var _a;
            var accessors = columnTransform[columnName];
            var value = ((accessors === null || accessors === void 0 ? void 0 : accessors.length)
                ? row[accessors.find(function (accessor) { return row[accessor]; })]
                : row[columnName]) ||
                (context === null || context === void 0 ? void 0 : context[columnName]) ||
                '';
            var mappedValue = ((_a = valuesMap[columnName]) === null || _a === void 0 ? void 0 : _a[value]) || value;
            var fxValue = typeof functionMap[columnName] === 'function'
                ? functionMap[columnName](mappedValue)
                : mappedValue;
            columnsMap[columnName] = withDelimiter(fxValue);
            if (fxValue) {
                columnValueCounts[columnIndex] =
                    (columnValueCounts[columnIndex] || 0) + 1;
            }
            return columnsMap;
        }, {}));
    };
    var flattenedRows = flattened.map(processRow);
    var indicesToRemove = removeEmptyColumns &&
        __spreadArray([], __read(columnValueCounts), false).map(function (count, index) { return !count && index; })
            .filter(isNumeric)
            .reverse();
    if (indicesToRemove) {
        var purge = function (row) {
            return row.filter(function (_, index) { return !indicesToRemove.includes(index); });
        };
        flattenedRows = flattenedRows.map(purge);
        mappedHeaderRow = purge(mappedHeaderRow);
    }
    var rows = flattenedRows.map(function (row) { return row.join(columnJoiner); });
    if (returnTransformedJSON) {
        return rows.map(function (row) {
            var columnValues = row.split(columnJoiner);
            return Object.assign.apply(Object, __spreadArray([{}], __read(columnValues.map(function (v, i) {
                var _a;
                return (_a = {}, _a[mappedHeaderRow[i]] = v, _a);
            })), false));
        });
    }
    return includeHeaderRow
        ? __spreadArray([mappedHeaderRow.map(withDelimiter).join(columnJoiner)], __read(rows), false).join(rowJoiner)
        : rows.join(rowJoiner);
}
function flattenJSON(obj, keyJoiner, path) {
    if (keyJoiner === void 0) { keyJoiner = '.'; }
    if (path === void 0) { path = []; }
    return (typeof obj === 'object' &&
        Object.keys(obj).reduce(function (result, key) {
            if (typeof obj[key] !== 'object') {
                result[path.concat(key).join(keyJoiner)] = obj[key];
                return result;
            }
            return Object.assign(result, flattenJSON(obj[key], keyJoiner, path.concat(key)));
        }, {}));
}

var utilitiesGovernor = {
    visualizeScheduledMatchUps: visualizeScheduledMatchUps,
    dehydrateMatchUps: dehydrateMatchUps,
    structureSort: structureSort,
    allNumeric: allNumeric$1,
    attributeFilter: attributeFilter,
    chunkArray: chunkArray,
    chunkByNth: chunkByNth,
    chunkSizeProfile: chunkSizeProfile,
    constantToString: constantToString,
    countValues: countValues,
    createMap: createMap,
    dateTime: dateTime,
    definedAttributes: definedAttributes,
    extractAttributes: extractAttributes,
    flattenJSON: flattenJSON,
    generateDateRange: generateDateRange,
    generateHashCode: generateHashCode,
    generateRange: generateRange,
    generateTimeCode: generateTimeCode,
    groupValues: groupValues,
    hasAttributeValues: hasAttributeValues,
    instanceCount: instanceCount,
    intersection: intersection,
    isConvertableInteger: isConvertableInteger,
    isNumeric: isNumeric,
    isOdd: isOdd,
    isPowerOf2: isPowerOf2,
    JSON2CSV: JSON2CSV,
    makeDeepCopy: makeDeepCopy,
    matchUpSort: matchUpSort,
    nearestPowerOf2: nearestPowerOf2,
    nextPowerOf2: nextPowerOf2,
    noNulls: noNulls,
    noNumeric: noNumeric,
    numericSort: numericSort,
    occurrences: occurrences,
    overlap: overlap,
    randomMember: randomMember,
    randomPop: randomPop,
    shuffleArray: shuffleArray,
    subSort: subSort,
    undefinedToNull: undefinedToNull,
    unique: unique,
    UUID: UUID,
    UUIDS: UUIDS,
};
var utilities = utilitiesGovernor;

function getScheduledCourtMatchUps(params) {
    if (!(params === null || params === void 0 ? void 0 : params.tournamentRecord) && !Array.isArray(params === null || params === void 0 ? void 0 : params.venueMatchUps))
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!(params === null || params === void 0 ? void 0 : params.courtId))
        return { error: MISSING_COURT_ID };
    var scheduleVisibilityFilters = params.scheduleVisibilityFilters, tournamentRecord = params.tournamentRecord, matchUpFilters = params.matchUpFilters, venueMatchUps = params.venueMatchUps, courtId = params.courtId;
    var schedulingProfile = getSchedulingProfile({ tournamentRecord: tournamentRecord }).schedulingProfile;
    if (Array.isArray(venueMatchUps))
        return { matchUps: getCourtMatchUps({ matchUps: venueMatchUps, courtId: courtId }) };
    var tournamentMatchUps = allTournamentMatchUps({
        scheduleVisibilityFilters: scheduleVisibilityFilters,
        tournamentRecord: tournamentRecord,
        matchUpFilters: matchUpFilters,
    }).matchUps;
    var matchUps = getCourtMatchUps({ matchUps: tournamentMatchUps, courtId: courtId });
    return { matchUps: matchUps };
    function getCourtMatchUps(_a) {
        var matchUps = _a.matchUps, courtId = _a.courtId;
        var courtMatchUps = matchUps.filter(function (matchUp) {
            var _a, _b, _c;
            // allocatedCourtIds only applies to TEAM matchUps
            var allocatedCourtIds = (_b = (_a = matchUp.schedule) === null || _a === void 0 ? void 0 : _a.allocatedCourts) === null || _b === void 0 ? void 0 : _b.map(function (_a) {
                var courtId = _a.courtId;
                return courtId;
            });
            return ((_c = matchUp.schedule) === null || _c === void 0 ? void 0 : _c.courtId) === courtId || (allocatedCourtIds === null || allocatedCourtIds === void 0 ? void 0 : allocatedCourtIds.includes(courtId));
        });
        return scheduledSortedMatchUps({
            matchUps: courtMatchUps,
            schedulingProfile: schedulingProfile,
        });
    }
}
function getScheduledVenueMatchUps(_a) {
    var scheduleVisibilityFilters = _a.scheduleVisibilityFilters, tournamentRecord = _a.tournamentRecord, matchUpFilters = _a.matchUpFilters, venueId = _a.venueId;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!venueId)
        return { error: MISSING_VENUE_ID };
    var schedulingProfile = getSchedulingProfile({ tournamentRecord: tournamentRecord }).schedulingProfile;
    var tournamentMatchUps = allTournamentMatchUps({
        scheduleVisibilityFilters: scheduleVisibilityFilters,
        tournamentRecord: tournamentRecord,
        matchUpFilters: matchUpFilters,
    }).matchUps;
    var matchUps = getVenueMatchUps({ matchUps: tournamentMatchUps, venueId: venueId });
    return { matchUps: matchUps };
    function getVenueMatchUps(_a) {
        var matchUps = _a.matchUps, venueId = _a.venueId;
        var venueMatchUps = matchUps.filter(function (matchUp) {
            var _a, _b, _c;
            // allocatedCourtIds only applies to TEAM matchUps
            var allocatedVenueIds = (_b = (_a = matchUp.schedule) === null || _a === void 0 ? void 0 : _a.allocatedCourts) === null || _b === void 0 ? void 0 : _b.map(function (_a) {
                var venueId = _a.venueId;
                return venueId;
            });
            return ((_c = matchUp.schedule) === null || _c === void 0 ? void 0 : _c.venueId) === venueId || (allocatedVenueIds === null || allocatedVenueIds === void 0 ? void 0 : allocatedVenueIds.includes(venueId));
        });
        return scheduledSortedMatchUps({
            matchUps: venueMatchUps,
            schedulingProfile: schedulingProfile,
        });
    }
}

function modifyCourtAvailability(_a) {
    var _b, _c, _d;
    var tournamentRecord = _a.tournamentRecord, dateAvailability = _a.dateAvailability, disableNotice = _a.disableNotice, venueMatchUps = _a.venueMatchUps, courtId = _a.courtId, force = _a.force;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!courtId)
        return { error: MISSING_COURT_ID };
    var dateResult = validDateAvailability({ dateAvailability: dateAvailability });
    if (dateResult.error)
        return dateResult;
    // TODO: build up a map of affected dates and:
    // 1. whether aggregate time on given dates has increased or decreased
    // 2. specific periods of time on given dates that are no longer available
    var _e = sortAndMergeDateAvailability(dateAvailability), updatedDateAvailability = _e.updatedDateAvailability, totalMergeCount = _e.totalMergeCount;
    dateAvailability = updatedDateAvailability;
    var courtResult = findCourt({ tournamentRecord: tournamentRecord, courtId: courtId });
    if (courtResult.error)
        return courtResult;
    var court = courtResult.court, venue = courtResult.venue;
    var courtMatchUps = getScheduledCourtMatchUps({
        tournamentRecord: tournamentRecord,
        venueMatchUps: venueMatchUps,
        courtId: courtId,
    }).matchUps;
    // TODO: check whether there are matchUps which are no longer possible to play
    // In the first instance, matchUps which are explicitly scheduled on the court for times which are no longer available
    // NOTE: see dateAvailability.test.ts
    if (courtMatchUps === null || courtMatchUps === void 0 ? void 0 : courtMatchUps.length) {
        var appliedPolicies = (_b = getAppliedPolicies({
            tournamentRecord: tournamentRecord,
        })) === null || _b === void 0 ? void 0 : _b.appliedPolicies;
        var allowModificationWhenMatchUpsScheduled = force !== null && force !== void 0 ? force : (_d = (_c = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_SCHEDULING]) === null || _c === void 0 ? void 0 : _c.allowDeletionWithScoresPresent) === null || _d === void 0 ? void 0 : _d.courts;
        // Iterate through courtMatchUps and check that scheduledTime/scheduledDate still avilable
        var matchUpsWithInvalidScheduling = [];
        if (matchUpsWithInvalidScheduling.length) {
            if (allowModificationWhenMatchUpsScheduled) ;
            else {
                console.log('throw error: scheduled court matchUps', matchUpsWithInvalidScheduling.length);
            }
        }
    }
    // TODO: In the second instance, if there is reduced aggregate court time matchUps scheduled on the affected dates (but not specific court)
    // would have scheduling impacts impacts
    if (court) {
        court.dateAvailability = dateAvailability;
        if (!disableNotice && venue)
            addNotice({
                payload: { venue: venue, tournamentId: tournamentRecord.tournamentId },
                topic: MODIFY_VENUE,
                key: venue.venueId,
            });
    }
    return __assign(__assign({}, SUCCESS), { totalMergeCount: totalMergeCount });
}
function sortAndMergeDateAvailability(dateAvailability) {
    var totalMergeCount = 0;
    var availabilityByDate = dateAvailability.reduce(function (byDate, availability) {
        var date = availability.date, startTime = availability.startTime, endTime = availability.endTime, bookings = availability.bookings;
        if (!byDate[date])
            byDate[date] = [];
        byDate[date].push({ startTime: startTime, endTime: endTime, bookings: bookings });
        return byDate;
    }, {});
    var updatedDateAvailability = [];
    Object.keys(availabilityByDate).forEach(function (date) {
        availabilityByDate[date].sort(startTimeSort);
        var _a = getMergedAvailability(availabilityByDate[date]), mergedAvailability = _a.mergedAvailability, mergeCount = _a.mergeCount;
        updatedDateAvailability.push.apply(updatedDateAvailability, __spreadArray([], __read(mergedAvailability.map(function (availability) { return (__assign({ date: date }, availability)); })), false));
        totalMergeCount += mergeCount;
    });
    return { updatedDateAvailability: updatedDateAvailability, totalMergeCount: totalMergeCount };
}
function getMergedAvailability(dateDetails) {
    var lastStartTime, lastEndTime, lastBookings, safety = dateDetails.length, mergeCount = 0;
    var mergedAvailability = [];
    while (dateDetails.length && safety) {
        var details = dateDetails.shift();
        var startTime = details.startTime, endTime = details.endTime, bookings = details.bookings;
        safety -= 1;
        if (!lastStartTime) {
            lastStartTime = startTime;
            lastBookings = bookings;
            lastEndTime = endTime;
        }
        else {
            var difference = minutesDifference(timeToDate(lastEndTime), timeToDate(startTime), false);
            if (difference > 0) {
                var availability_1 = {
                    startTime: lastStartTime,
                    endTime: lastEndTime,
                };
                if (lastBookings === null || lastBookings === void 0 ? void 0 : lastBookings.length)
                    availability_1.bookings = lastBookings;
                mergedAvailability.push(availability_1);
                lastStartTime = startTime;
                lastBookings = bookings;
                lastEndTime = endTime;
            }
            else {
                if (bookings) {
                    if (lastBookings) {
                        lastBookings.push(bookings);
                    }
                    else {
                        lastBookings = bookings;
                    }
                }
                lastEndTime = endTime;
                mergeCount += 1;
            }
        }
    }
    var availability = { startTime: lastStartTime, endTime: lastEndTime };
    if (lastBookings === null || lastBookings === void 0 ? void 0 : lastBookings.length)
        availability.bookings = lastBookings;
    mergedAvailability.push(availability);
    return { mergedAvailability: mergedAvailability, mergeCount: mergeCount };
}

function deletionMessage(_a) {
    var _b = _a.matchUpsCount, matchUpsCount = _b === void 0 ? 0 : _b;
    var singularPlural = matchUpsCount === 1 ? 'matchUp' : 'matchUps';
    var info = "Schedule would be deleted from ".concat(matchUpsCount, " ").concat(singularPlural, "; use { force: true }");
    return {
        error: SCHEDULED_MATCHUPS,
        info: info,
    };
}

function removeCourtAssignment(_a) {
    var _b;
    var tournamentRecord = _a.tournamentRecord, drawDefinition = _a.drawDefinition, matchUpId = _a.matchUpId, drawId = _a.drawId;
    var stack = 'removeCourtAssignment';
    if (!matchUpId)
        return { error: MISSING_MATCHUP_ID };
    if (!drawDefinition && !drawId)
        return { error: MISSING_DRAW_ID };
    var matchUp;
    if (!drawDefinition) {
        if (!tournamentRecord)
            return { error: MISSING_TOURNAMENT_RECORD };
        (drawDefinition = findEvent({ tournamentRecord: tournamentRecord, drawId: drawId }).drawDefinition);
    }
    if (drawDefinition) {
        (matchUp = findDrawMatchUp({ drawDefinition: drawDefinition, matchUpId: matchUpId }).matchUp);
    }
    else {
        if (!tournamentRecord)
            return { error: MISSING_TOURNAMENT_RECORD };
        var matchUps = (_b = allTournamentMatchUps({ tournamentRecord: tournamentRecord, inContext: false }).matchUps) !== null && _b !== void 0 ? _b : [];
        (matchUp = getMatchUp$1({ matchUps: matchUps, matchUpId: matchUpId }).matchUp);
    }
    if (!matchUp)
        return { error: MATCHUP_NOT_FOUND };
    if (matchUp.timeItems) {
        var hasCourtAssignment = matchUp.timeItems.find(function (candidate) {
            return [ASSIGN_COURT, ALLOCATE_COURTS].includes(candidate.itemType);
        });
        if (hasCourtAssignment) {
            matchUp.timeItems = matchUp.timeItems.filter(function (_a) {
                var itemType = _a.itemType;
                return ![ASSIGN_COURT, ALLOCATE_COURTS].includes(itemType);
            });
            modifyMatchUpNotice({
                tournamentId: tournamentRecord === null || tournamentRecord === void 0 ? void 0 : tournamentRecord.tournamentId,
                context: stack,
                drawDefinition: drawDefinition,
                matchUp: matchUp,
            });
        }
    }
    return __assign({}, SUCCESS);
}

function deleteVenue(params) {
    var _a, e_1, _b;
    var _c, _d, _e, _f, _g;
    if (typeof (params === null || params === void 0 ? void 0 : params.venueId) !== 'string')
        return { error: MISSING_VENUE_ID };
    var tournamentRecord = params.tournamentRecord, venueId = params.venueId, force = params.force;
    var tournamentRecords = params.tournamentRecords ||
        (tournamentRecord && (_a = {},
            _a[tournamentRecord.tournamentId] = tournamentRecord,
            _a)) ||
        {};
    if (!Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORD };
    var contextFilters = { venueIds: [venueId] };
    var matchUpsToUnschedule = (_c = allCompetitionMatchUps({
        tournamentRecords: tournamentRecords,
        contextFilters: contextFilters,
    }).matchUps) !== null && _c !== void 0 ? _c : [];
    var appliedPolicies = (_d = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
    })) === null || _d === void 0 ? void 0 : _d.appliedPolicies;
    var allowModificationWhenMatchUpsScheduled = force !== null && force !== void 0 ? force : (_f = (_e = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_SCHEDULING]) === null || _e === void 0 ? void 0 : _e.allowDeletionWithScoresPresent) === null || _f === void 0 ? void 0 : _f.venues;
    if (!matchUpsToUnschedule.length || allowModificationWhenMatchUpsScheduled) {
        var _loop_1 = function (tournamentRecord_1) {
            var e_2, _k;
            try {
                // if no matchUpsToUnschedule this does nothing but avoid the deletionMessage
                for (var matchUpsToUnschedule_1 = (e_2 = void 0, __values(matchUpsToUnschedule)), matchUpsToUnschedule_1_1 = matchUpsToUnschedule_1.next(); !matchUpsToUnschedule_1_1.done; matchUpsToUnschedule_1_1 = matchUpsToUnschedule_1.next()) {
                    var matchUp = matchUpsToUnschedule_1_1.value;
                    var result = removeCourtAssignment({
                        matchUpId: matchUp.matchUpId,
                        drawId: matchUp.drawId,
                        tournamentRecord: tournamentRecord_1,
                    });
                    if (result.error)
                        return { value: result };
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (matchUpsToUnschedule_1_1 && !matchUpsToUnschedule_1_1.done && (_k = matchUpsToUnschedule_1.return)) _k.call(matchUpsToUnschedule_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var deleted;
            tournamentRecord_1.venues = ((_g = tournamentRecord_1.venues) !== null && _g !== void 0 ? _g : []).filter(function (venue) {
                if ((venue === null || venue === void 0 ? void 0 : venue.venueId) !== venueId)
                    return true;
                deleted = true;
                return false;
            });
            if (deleted) {
                addNotice({
                    payload: { venueId: venueId, tournamentId: tournamentRecord_1.tournamentId },
                    topic: DELETE_VENUE,
                    key: venueId,
                });
            }
        };
        try {
            for (var _h = __values(Object.values(tournamentRecords)), _j = _h.next(); !_j.done; _j = _h.next()) {
                var tournamentRecord_1 = _j.value;
                var state_1 = _loop_1(tournamentRecord_1);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else {
        return deletionMessage({ matchUpsCount: matchUpsToUnschedule.length });
    }
    checkAndUpdateSchedulingProfile({ tournamentRecords: tournamentRecords });
    return __assign({}, SUCCESS);
}
function deleteVenues(_a) {
    var e_3, _b;
    var tournamentRecord = _a.tournamentRecord, venueIds = _a.venueIds, force = _a.force;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!Array.isArray(venueIds))
        return { error: INVALID_VALUES };
    try {
        for (var _c = __values(tournamentRecord.venues || []), _d = _c.next(); !_d.done; _d = _c.next()) {
            var venue = _d.value;
            var venueId = venue.venueId;
            if (venueIds.includes(venueId)) {
                var venueId_1 = venue.venueId;
                var result = deleteVenue({ tournamentRecord: tournamentRecord, venueId: venueId_1, force: force });
                if (result.error)
                    return result;
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return __assign({}, SUCCESS);
}

function disableCourts(params) {
    var _a, e_1, _b;
    var courtIds = params.courtIds, dates = params.dates;
    var tournamentRecords = resolveTournamentRecords(params);
    var paramsToCheck = [
        (_a = {}, _a[TOURNAMENT_RECORDS] = true, _a[COURT_IDS] = true, _a),
    ];
    var paramCheck = checkRequiredParameters(params, paramsToCheck);
    if (paramCheck.error)
        return paramCheck;
    try {
        for (var _c = __values(Object.values(tournamentRecords)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var tournamentRecord = _d.value;
            courtsDisable({ tournamentRecord: tournamentRecord, courtIds: courtIds, dates: dates });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}
function courtsDisable(_a) {
    var e_2, _b, e_3, _c;
    var tournamentRecord = _a.tournamentRecord, courtIds = _a.courtIds, dates = _a.dates;
    var disabledValue = Array.isArray(dates) && dates.length ? { dates: dates } : true;
    var disableCourt = function (court) {
        return addExtension({
            extension: { value: disabledValue, name: DISABLED },
            creationTime: false,
            element: court,
        });
    };
    try {
        for (var _d = __values(tournamentRecord.venues || []), _e = _d.next(); !_e.done; _e = _d.next()) {
            var venue = _e.value;
            try {
                for (var _f = (e_3 = void 0, __values(venue.courts || [])), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var court = _g.value;
                    if (courtIds === null || courtIds === void 0 ? void 0 : courtIds.includes(court.courtId)) {
                        var result = disableCourt(court);
                        if (result.error)
                            return result;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return __assign({}, SUCCESS);
}

function disableVenues(params) {
    var _a, e_1, _b;
    var tournamentRecords = params.tournamentRecords, tournamentId = params.tournamentId, venueIds = params.venueIds;
    var paramsToCheck = [
        (_a = {}, _a[TOURNAMENT_RECORDS] = true, _a[VENUE_IDS] = true, _a),
    ];
    var paramCheck = checkRequiredParameters(params, paramsToCheck);
    if (paramCheck.error)
        return paramCheck;
    var tournamentIds = Object.keys(tournamentRecords).filter(function (id) { return !tournamentId || id === tournamentId; });
    try {
        for (var tournamentIds_1 = __values(tournamentIds), tournamentIds_1_1 = tournamentIds_1.next(); !tournamentIds_1_1.done; tournamentIds_1_1 = tournamentIds_1.next()) {
            var tournamentId_1 = tournamentIds_1_1.value;
            var tournamentRecord = tournamentRecords[tournamentId_1];
            venuesDisable({ tournamentRecord: tournamentRecord, venueIds: venueIds });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (tournamentIds_1_1 && !tournamentIds_1_1.done && (_b = tournamentIds_1.return)) _b.call(tournamentIds_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}
function venuesDisable(_a) {
    var e_2, _b;
    var tournamentRecord = _a.tournamentRecord, venueIds = _a.venueIds;
    try {
        for (var _c = __values(tournamentRecord.venues || []), _d = _c.next(); !_d.done; _d = _c.next()) {
            var venue = _d.value;
            if (venueIds === null || venueIds === void 0 ? void 0 : venueIds.includes(venue.venueId)) {
                var result = addExtension({
                    creationTime: false,
                    element: venue,
                    extension: {
                        name: DISABLED,
                        value: true,
                    },
                });
                if (result.error)
                    return result;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return __assign({}, SUCCESS);
}

function enableCourts(params) {
    var _a, _b, e_1, _c;
    var tournamentRecords = resolveTournamentRecords(params);
    var paramsToCheck = [(_a = {}, _a[TOURNAMENT_RECORDS] = true, _a)];
    !params.enableAll && paramsToCheck.push((_b = {}, _b[COURT_IDS] = true, _b));
    var paramCheck = checkRequiredParameters(params, paramsToCheck);
    if (paramCheck.error)
        return paramCheck;
    var enableAll = params.enableAll, courtIds = params.courtIds, dates = params.dates;
    try {
        for (var _d = __values(Object.values(tournamentRecords)), _e = _d.next(); !_e.done; _e = _d.next()) {
            var tournamentRecord = _e.value;
            courtsEnable({ tournamentRecord: tournamentRecord, courtIds: courtIds, enableAll: enableAll, dates: dates });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}
function courtsEnable(_a) {
    var e_2, _b, e_3, _c;
    var tournamentRecord = _a.tournamentRecord, courtIds = _a.courtIds, enableAll = _a.enableAll, dates = _a.dates;
    try {
        for (var _d = __values(tournamentRecord.venues || []), _e = _d.next(); !_e.done; _e = _d.next()) {
            var venue = _e.value;
            try {
                for (var _f = (e_3 = void 0, __values(venue.courts || [])), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var court = _g.value;
                    if (enableAll || (courtIds === null || courtIds === void 0 ? void 0 : courtIds.includes(court.courtId)))
                        if (Array.isArray(dates)) {
                            var extension = findExtension({
                                element: court,
                                name: DISABLED,
                            }).extension;
                            if (extension) {
                                var value = extension.value;
                                if (Array.isArray(value.dates)) {
                                    value.dates = value.dates.filter(function (date) { return !dates.includes(date); });
                                }
                                addExtension({
                                    extension: { name: DISABLED, value: value },
                                    creationTime: false,
                                    element: court,
                                });
                            }
                        }
                        else {
                            removeExtension({ element: court, name: DISABLED });
                        }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return __assign({}, SUCCESS);
}

function enableVenues(params) {
    var _a, _b, e_1, _c, e_2, _d;
    var tournamentRecords = resolveTournamentRecords(params);
    var paramsToCheck = [(_a = {}, _a[TOURNAMENT_RECORDS] = true, _a)];
    !params.enableAll && paramsToCheck.push((_b = {}, _b[VENUE_IDS] = true, _b));
    var paramCheck = checkRequiredParameters(params, paramsToCheck);
    if (paramCheck.error)
        return paramCheck;
    var venueIds = params.venueIds, enableAll = params.enableAll;
    try {
        for (var _e = __values(Object.values(tournamentRecords)), _f = _e.next(); !_f.done; _f = _e.next()) {
            var tournamentRecord = _f.value;
            try {
                for (var _g = (e_2 = void 0, __values(tournamentRecord.venues || [])), _h = _g.next(); !_h.done; _h = _g.next()) {
                    var venue = _h.value;
                    if (enableAll || (venueIds === null || venueIds === void 0 ? void 0 : venueIds.includes(venue.venueId)))
                        removeExtension({ element: venue, name: DISABLED });
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_h && !_h.done && (_d = _g.return)) _d.call(_g);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, SUCCESS);
}

function deleteCourt(params) {
    var _a, e_1, _b;
    var courtId = params.courtId, disableNotice = params.disableNotice, force = params.force;
    var tournamentRecords = resolveTournamentRecords(params);
    var paramsCheck = checkRequiredParameters(params, [
        (_a = {}, _a[TOURNAMENT_RECORDS] = true, _a[COURT_ID] = true, _a),
    ]);
    if (paramsCheck.error)
        return paramsCheck;
    var courtDeleted;
    var result;
    try {
        for (var _c = __values(Object.values(tournamentRecords)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var tournamentRecord = _d.value;
            result = courtDeletion({ tournamentRecord: tournamentRecord, disableNotice: disableNotice, courtId: courtId, force: force });
            if (result.error && result.error !== COURT_NOT_FOUND)
                return result;
            if (result.success)
                courtDeleted = true;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return courtDeleted ? __assign({}, SUCCESS) : result;
}
function courtDeletion(_a) {
    var e_2, _b;
    var _c, _d, _e, _f;
    var tournamentRecord = _a.tournamentRecord, disableNotice = _a.disableNotice, courtId = _a.courtId, force = _a.force;
    var result = findCourt({ tournamentRecord: tournamentRecord, courtId: courtId });
    if (result.error)
        return result;
    var venue = result.venue;
    var matchUps = getScheduledCourtMatchUps({
        tournamentRecord: tournamentRecord,
        courtId: courtId,
    }).matchUps;
    var appliedPolicies = (_c = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
    })) === null || _c === void 0 ? void 0 : _c.appliedPolicies;
    var allowModificationWhenMatchUpsScheduled = force !== null && force !== void 0 ? force : (_e = (_d = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_SCHEDULING]) === null || _d === void 0 ? void 0 : _d.allowDeletionWithScoresPresent) === null || _e === void 0 ? void 0 : _e.courts;
    if (!(matchUps === null || matchUps === void 0 ? void 0 : matchUps.length) || allowModificationWhenMatchUpsScheduled) {
        try {
            for (var _g = __values(matchUps !== null && matchUps !== void 0 ? matchUps : []), _h = _g.next(); !_h.done; _h = _g.next()) {
                var matchUp = _h.value;
                var result_1 = removeCourtAssignment({
                    matchUpId: matchUp.matchUpId,
                    drawId: matchUp.drawId,
                    tournamentRecord: tournamentRecord,
                });
                if (result_1.error)
                    return result_1;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (venue) {
            venue.courts = ((_f = venue.courts) !== null && _f !== void 0 ? _f : []).filter(function (courtRecord) {
                return courtRecord.courtId !== courtId;
            });
            if (!disableNotice)
                addNotice({
                    payload: { venue: venue, tournamentId: tournamentRecord.tournamentId },
                    topic: MODIFY_VENUE,
                    key: venue.venueId,
                });
        }
    }
    else {
        return deletionMessage({ matchUpsCount: matchUps.length });
    }
    return __assign({}, SUCCESS);
}

function modifyCourt(params) {
    var e_1, _a;
    var disableNotice = params.disableNotice, modifications = params.modifications, courtId = params.courtId, force = params.force, venueMatchUps = params.venueMatchUps;
    var tournamentRecords = resolveTournamentRecords(params);
    if (!Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    var courtModified;
    var error;
    try {
        for (var _b = __values(Object.values(tournamentRecords)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var tournamentRecord = _c.value;
            var result = courtModification({
                tournamentRecord: tournamentRecord,
                disableNotice: disableNotice,
                venueMatchUps: venueMatchUps,
                modifications: modifications,
                courtId: courtId,
                force: force,
            });
            if (result === null || result === void 0 ? void 0 : result.error)
                return result;
            courtModified = true;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return courtModified ? __assign({}, SUCCESS) : error;
}
function courtModification(_a) {
    var tournamentRecord = _a.tournamentRecord, disableNotice = _a.disableNotice, venueMatchUps = _a.venueMatchUps, modifications = _a.modifications, courtId = _a.courtId, force = _a.force;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!courtId)
        return { error: MISSING_COURT_ID };
    if (!modifications || typeof modifications !== 'object')
        return { error: INVALID_OBJECT };
    var result = findCourt({ tournamentRecord: tournamentRecord, courtId: courtId });
    if (result.error)
        return result;
    var venue = result.venue, court = result.court;
    // not valid to modify a courtId
    var validAttributes = Object.keys(courtTemplate()).filter(function (attribute) { return attribute !== 'courtId'; });
    var validModificationAttributes = Object.keys(modifications).filter(function (attribute) { return validAttributes.includes(attribute); });
    if (!validModificationAttributes.length)
        return { error: NO_VALID_ATTRIBUTES };
    // not valid to replace the dateAvailability array
    var validReplacements = validAttributes.filter(function (attribute) { return !['dateAvailability'].includes(attribute); });
    var validReplacementAttributes = Object.keys(modifications).filter(function (attribute) { return validReplacements.includes(attribute); });
    if (court)
        validReplacementAttributes.forEach(function (attribute) {
            var _a;
            return Object.assign(court, (_a = {}, _a[attribute] = modifications[attribute], _a));
        });
    if (modifications.dateAvailability) {
        var result_1 = modifyCourtAvailability({
            dateAvailability: modifications.dateAvailability,
            tournamentRecord: tournamentRecord,
            venueMatchUps: venueMatchUps,
            disableNotice: disableNotice,
            courtId: courtId,
            force: force,
        });
        if (result_1.error)
            return result_1;
    }
    if (!disableNotice) {
        addNotice({
            payload: { venue: venue, tournamentId: tournamentRecord.tournamentId },
            topic: MODIFY_VENUE,
            key: venue === null || venue === void 0 ? void 0 : venue.venueId,
        });
    }
    return __assign(__assign({}, SUCCESS), { court: makeDeepCopy(court) });
}

var venueTemplate = function () { return ({
    venueId: undefined,
    venueName: '',
    venueAbbreviation: '',
    onlineResources: [],
    venueType: undefined,
    addresses: [],
    contacts: [],
    courts: [],
    roles: [],
}); };

function modifyVenue(params) {
    var e_1, _a;
    var modifications = params.modifications, venueId = params.venueId, force = params.force;
    var tournamentRecords = resolveTournamentRecords(params);
    if (!Object.keys(tournamentRecords).length)
        return { error: MISSING_TOURNAMENT_RECORDS };
    if (typeof venueId !== 'string')
        return { error: MISSING_VENUE_ID };
    var error;
    var success;
    try {
        // in this case suppress NOT FOUND errors if there is at least one success
        for (var _b = __values(Object.values(tournamentRecords)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var tournamentRecord = _c.value;
            var result = venueModify({
                tournamentRecord: tournamentRecord,
                modifications: modifications,
                venueId: venueId,
                force: force,
            });
            if (result.success)
                success = true;
            if (result.error)
                error = result.error;
            if (result.error && result.error !== VENUE_NOT_FOUND)
                return result;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    checkAndUpdateSchedulingProfile({ tournamentRecords: tournamentRecords });
    return success ? __assign({}, SUCCESS) : { error: error };
}
function venueModify(_a) {
    var e_2, _b;
    var _c, _d, _e, _f, _g, _h, _j, _k;
    var tournamentRecord = _a.tournamentRecord, modifications = _a.modifications, venueId = _a.venueId, force = _a.force;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!modifications || typeof modifications !== 'object')
        return { error: INVALID_OBJECT };
    if (!venueId)
        return { error: MISSING_VENUE_ID };
    var appliedPolicies = (_c = getAppliedPolicies({
        tournamentRecord: tournamentRecord,
    })) === null || _c === void 0 ? void 0 : _c.appliedPolicies;
    var allowModificationWhenMatchUpsScheduled = force !== null && force !== void 0 ? force : (_e = (_d = appliedPolicies === null || appliedPolicies === void 0 ? void 0 : appliedPolicies[POLICY_TYPE_SCHEDULING]) === null || _d === void 0 ? void 0 : _d.allowDeletionWithScoresPresent) === null || _e === void 0 ? void 0 : _e.venues;
    var venueMatchUps = getScheduledVenueMatchUps({
        tournamentRecord: tournamentRecord,
        venueId: venueId,
    }).matchUps;
    var result = findVenue({ tournamentRecord: tournamentRecord, venueId: venueId });
    if (result.error)
        return result;
    var venue = result.venue;
    // not valid to modify a venueId
    var validAttributes = Object.keys(venueTemplate()).filter(function (attribute) { return attribute !== 'venueId'; });
    var validModificationAttributes = Object.keys(modifications).filter(function (attribute) {
        return validAttributes.includes(attribute);
    });
    if (!validModificationAttributes.length)
        return { error: NO_VALID_ATTRIBUTES };
    var validReplacements = validAttributes.filter(function (attribute) { return !['courts', 'onlineResources'].includes(attribute); });
    var validReplacementAttributes = Object.keys(modifications).filter(function (attribute) {
        return validReplacements.includes(attribute);
    });
    venue &&
        validReplacementAttributes.forEach(function (attribute) {
            var _a;
            return Object.assign(venue, (_a = {}, _a[attribute] = modifications[attribute], _a));
        });
    var existingCourtIds = (_g = (_f = venue === null || venue === void 0 ? void 0 : venue.courts) === null || _f === void 0 ? void 0 : _f.map(function (court) { return court.courtId; })) !== null && _g !== void 0 ? _g : [];
    var courtIdsToModify = ((_h = modifications.courts) === null || _h === void 0 ? void 0 : _h.map(function (court) { return court.courtId; })) || [];
    var courtIdsToDelete = courtIdsToModify.length && existingCourtIds.filter(function (courtId) { return !courtIdsToModify.includes(courtId); });
    var matchUpsWithCourtId = [];
    if (courtIdsToDelete.length) {
        var courtsToDelete = (_j = venue === null || venue === void 0 ? void 0 : venue.courts) === null || _j === void 0 ? void 0 : _j.filter(function (court) { return courtIdsToDelete.includes(court.courtId); });
        var scheduleDeletionsCount = courtsToDelete === null || courtsToDelete === void 0 ? void 0 : courtsToDelete.map(function (court) {
            var e_3, _a;
            var _b, _c, _d;
            // check whether deleting court would remove schedule from any matchUps
            var result = getScheduledCourtMatchUps({
                courtId: court.courtId,
                tournamentRecord: tournamentRecord,
                venueMatchUps: venueMatchUps,
            });
            try {
                for (var _e = __values((_b = result.matchUps) !== null && _b !== void 0 ? _b : []), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var matchUp = _f.value;
                    matchUpsWithCourtId.push({
                        matchUpId: matchUp.matchUpId,
                        drawId: matchUp.drawId,
                    });
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return (_d = (_c = result.matchUps) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
        }).reduce(function (a, b) { return a + b; });
        console.log({ scheduleDeletionsCount: scheduleDeletionsCount });
        if (venue && (!scheduleDeletionsCount || allowModificationWhenMatchUpsScheduled)) {
            venue.courts = (_k = venue.courts) === null || _k === void 0 ? void 0 : _k.filter(function (court) { return courtIdsToModify.includes(court.courtId); });
            bulkScheduleTournamentMatchUps({
                schedule: { courtId: '', scheduledDate: '' },
                matchUpDetails: matchUpsWithCourtId,
                removePriorValues: true,
                tournamentRecord: tournamentRecord,
            });
        }
        else {
            return deletionMessage({
                matchUpsCount: scheduleDeletionsCount,
            });
        }
    }
    if (modifications.courts) {
        try {
            for (var _l = __values(modifications.courts), _m = _l.next(); !_m.done; _m = _l.next()) {
                var court = _m.value;
                var courtId = (court || {}).courtId;
                var result_1 = modifyCourt({
                    modifications: court,
                    disableNotice: true,
                    tournamentRecord: tournamentRecord,
                    venueMatchUps: venueMatchUps,
                    courtId: courtId,
                    force: force,
                });
                if (result_1.error === COURT_NOT_FOUND) {
                    result_1 = addCourt({
                        disableNotice: true,
                        tournamentRecord: tournamentRecord,
                        venueId: venueId,
                        court: court,
                    });
                }
                if (result_1.error)
                    return result_1;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_m && !_m.done && (_b = _l.return)) _b.call(_l);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    checkAndUpdateSchedulingProfile({ tournamentRecord: tournamentRecord });
    if (venue) {
        addNotice({
            payload: { venue: venue, tournamentId: tournamentRecord.tournamentId },
            topic: MODIFY_VENUE,
            key: venue === null || venue === void 0 ? void 0 : venue.venueId,
        });
    }
    return __assign(__assign({}, SUCCESS), { venue: makeDeepCopy(venue) });
}

var venueGovernor = {
    addCourt: addCourt,
    addCourts: addCourts,
    addVenue: addVenue,
    deleteCourt: deleteCourt,
    deleteVenue: deleteVenue,
    deleteVenues: deleteVenues,
    disableCourts: disableCourts,
    disableVenues: disableVenues,
    enableCourts: enableCourts,
    enableVenues: enableVenues,
    findVenue: publicFindVenue,
    modifyCourt: modifyCourt,
    modifyCourtAvailability: modifyCourtAvailability,
    modifyVenue: modifyVenue,
};

var governors = {
    competitionGovernor: competitionGovernor,
    eventGovernor: eventGovernor,
    generationGovernor: generationGovernor,
    matchUpFormatGovernor: matchUpFormatCode,
    mocksGovernor: mocksGovernor,
    participantGovernor: participantGovernor,
    policyGovernor: policyGovernor,
    publishingGovernor: publishingGovernor,
    queryGovernor: queryGovernor,
    reportGovernor: reportGovernor,
    scheduleGovernor: scheduleGovernor,
    scoreGovernor: scoreGovernor,
    tournamentGovernor: tournamentGovernor,
    utilitiesGovernor: utilitiesGovernor,
    venueGovernor: venueGovernor,
};

var forge = {};

var _a$8;
function notifySubscribers(params) {
    var e_1, _a;
    var _b = params || {}, mutationStatus = _b.mutationStatus, tournamentId = _b.tournamentId, directives = _b.directives, timeStamp = _b.timeStamp;
    var topics = getTopics().topics;
    try {
        for (var _c = __values(__spreadArray([], __read(topics), false).sort(topicSort)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var topic = _d.value;
            var notices = getNotices({ topic: topic });
            if (notices)
                callListener({ topic: topic, notices: notices });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (mutationStatus && timeStamp && topics.includes(MUTATIONS)) {
        callListener({
            notices: [{ tournamentId: tournamentId, directives: directives, timeStamp: timeStamp }],
            topic: MUTATIONS,
        });
    }
}
function notifySubscribersAsync(params) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, mutationStatus, tournamentId, directives, timeStamp, topics, _b, _c, topic, notices, e_2_1;
        var e_2, _d;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    _a = params || {}, mutationStatus = _a.mutationStatus, tournamentId = _a.tournamentId, directives = _a.directives, timeStamp = _a.timeStamp;
                    topics = getTopics().topics;
                    _e.label = 1;
                case 1:
                    _e.trys.push([1, 6, 7, 8]);
                    _b = __values(__spreadArray([], __read(topics), false).sort(topicSort)), _c = _b.next();
                    _e.label = 2;
                case 2:
                    if (!!_c.done) return [3 /*break*/, 5];
                    topic = _c.value;
                    notices = getNotices({ topic: topic });
                    if (!notices) return [3 /*break*/, 4];
                    return [4 /*yield*/, callListener({ topic: topic, notices: notices })];
                case 3:
                    _e.sent();
                    _e.label = 4;
                case 4:
                    _c = _b.next();
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 8];
                case 6:
                    e_2_1 = _e.sent();
                    e_2 = { error: e_2_1 };
                    return [3 /*break*/, 8];
                case 7:
                    try {
                        if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                    return [7 /*endfinally*/];
                case 8:
                    if (mutationStatus && timeStamp && topics.includes(MUTATIONS)) {
                        callListener({
                            notices: [{ tournamentId: tournamentId, directives: directives, timeStamp: timeStamp }],
                            topic: MUTATIONS,
                        });
                    }
                    return [2 /*return*/];
            }
        });
    });
}
var topicValues = (_a$8 = {},
    _a$8[UNPUBLISH_EVENT_SEEDING] = 5,
    _a$8[UNPUBLISH_EVENT] = 5,
    _a$8[UNPUBLISH_ORDER_OF_PLAY] = 5,
    _a$8[MODIFY_SEED_ASSIGNMENTS] = 5,
    _a$8[MODIFY_POSITION_ASSIGNMENTS] = 5,
    _a$8[MODIFY_DRAW_DEFINITION] = 5,
    _a$8[MODIFY_DRAW_ENTRIES] = 5,
    _a$8[MODIFY_EVENT_ENTRIES] = 5,
    _a$8[MODIFY_MATCHUP] = 1,
    _a$8[UPDATE_INCONTEXT_MATCHUP] = 1,
    _a$8[MODIFY_PARTICIPANTS] = 5,
    _a$8[MODIFY_VENUE] = 5,
    _a$8[DELETED_MATCHUP_IDS] = 4,
    _a$8[DELETE_PARTICIPANTS] = 4,
    _a$8[DELETE_VENUE] = 4,
    _a$8[DELETED_DRAW_IDS] = 4,
    _a$8[ADD_MATCHUPS] = 3,
    _a$8[ADD_DRAW_DEFINITION] = 2,
    _a$8);
function topicSort(a, b) {
    return (topicValues[b] || 0) - (topicValues[a] || 0);
}

var FACTORY = extensionConstants.FACTORY;
function updateFactoryExtension(_a) {
    var tournamentRecord = _a.tournamentRecord, value = _a.value;
    var extension = findExtension({
        element: tournamentRecord,
        name: FACTORY,
    }).extension;
    var updatedExtension = {
        name: FACTORY,
        value: __assign(__assign({}, extension === null || extension === void 0 ? void 0 : extension.value), value),
    };
    addExtension({ element: tournamentRecord, extension: updatedExtension });
}

function getMutationStatus(_a) {
    var timeStamp = _a.timeStamp;
    var tournamentRecords = getTournamentRecords();
    var mutationStatus = cycleMutationStatus();
    if (mutationStatus) {
        Object.values(tournamentRecords).forEach(function (tournamentRecord) {
            updateFactoryExtension({
                tournamentRecord: tournamentRecord,
                value: {
                    version: factoryVersion(),
                    timeStamp: timeStamp,
                },
            });
        });
    }
    return mutationStatus;
}

function engineLogging(_a) {
    var _b, _c;
    var engineType = _a.engineType, methodName = _a.methodName, elapsed = _a.elapsed, params = _a.params, result = _a.result;
    var devContext = getDevContext();
    if (typeof devContext !== 'object')
        return;
    var log = { method: methodName };
    var logError = (result === null || result === void 0 ? void 0 : result.error) &&
        (devContext.errors === true ||
            (Array.isArray(devContext.errors) &&
                devContext.errors.includes(methodName)));
    var specifiedMethodParams = Array.isArray(devContext.params) && ((_b = devContext.params) === null || _b === void 0 ? void 0 : _b.includes(methodName));
    var logParams = (devContext.params && !Array.isArray(devContext.params)) ||
        specifiedMethodParams;
    var exclude = Array.isArray(devContext.exclude) &&
        devContext.exclude.includes(methodName);
    if (!exclude &&
        ![undefined, false].includes(devContext.perf) &&
        !isNaN(devContext.perf) &&
        elapsed >= devContext.perf) {
        log.elapsed = elapsed;
    }
    if (!exclude && (logError || logParams)) {
        log.params = params;
    }
    if (!exclude &&
        (logError ||
            (devContext.result &&
                !Array.isArray(devContext.result) &&
                (!Array.isArray(devContext.params) || specifiedMethodParams)) ||
            (Array.isArray(devContext.result) &&
                ((_c = devContext.result) === null || _c === void 0 ? void 0 : _c.includes(methodName))))) {
        log.result = result;
    }
    if (Object.keys(log).length > 1)
        globalLog$1(engineType, log);
}

function logMethodNotFound(_a) {
    var methodName = _a.methodName, params = _a.params, start = _a.start;
    var result = { error: METHOD_NOT_FOUND, methodName: methodName };
    var elapsed = start ? Date.now() - start : 0;
    engineLogging({
        result: result,
        methodName: methodName,
        elapsed: elapsed,
        params: params,
        engineType: 'sync',
    });
    return result;
}

function paramsMiddleware(tournamentRecords, params) {
    var _a, _b;
    if (params._middleware === false)
        return params;
    // first check validity of params.tournamentId, if present
    if (params.tournamentId && !tournamentRecords[params.tournamentId]) {
        return { error: MISSING_TOURNAMENT_RECORD };
    }
    var drawId = params.drawId || ((_a = params.matchUp) === null || _a === void 0 ? void 0 : _a.drawId);
    if (drawId) {
        var _c = findEvent({
            tournamentRecords: tournamentRecords,
            drawId: drawId,
        }), event_1 = _c.event, drawDefinition = _c.drawDefinition, tournamentId_1 = _c.tournamentId;
        // NOTE: not important if nothing is found; will overwrite params.drawDefinition, params.event, and params.tournamentId
        if (drawDefinition)
            params.drawDefinition = drawDefinition;
        if (tournamentId_1)
            params.tournamentId = tournamentId_1;
        if (event_1)
            params.event = event_1;
    }
    if (params.eventId && !params.event) {
        var _d = findEvent({
            eventId: params.eventId,
            tournamentRecords: tournamentRecords,
        }), event_2 = _d.event, tournamentId_2 = _d.tournamentId;
        if (!event_2)
            return { error: EVENT_NOT_FOUND };
        // NOTE:  will overwrite params.event, and params.tournamentId
        params.tournamentId = tournamentId_2;
        params.event = event_2;
    }
    var tournamentId = (_b = params.tournamentId) !== null && _b !== void 0 ? _b : getTournamentId();
    if (!tournamentId && params)
        return params;
    var tournamentRecord = tournamentRecords[tournamentId];
    if (tournamentId && !tournamentRecord) {
        return { error: MISSING_TOURNAMENT_RECORD };
    }
    if (!tournamentRecord)
        return params;
    params.tournamentRecord = tournamentRecord;
    return params;
}

/**
 * Executes a function within a FactoryEngine.
 *
 * @param engine - The FactoryEngine object.
 * @param method - The function to be executed.
 * @param params - The parameters to be passed to the function.
 * @param methodName - The name of the method being executed.
 * @param engineType - The type of the engine.
 * @returns The result of the function execution.
 */
function executeFunction(engine, method, params, methodName, engineType) {
    var _a;
    delete engine.success;
    delete engine.error;
    var start = Date.now();
    var tournamentId = getTournamentId();
    if (params)
        params.activeTournamentId = tournamentId;
    if ((params === null || params === void 0 ? void 0 : params.sandboxTournament) && !(params === null || params === void 0 ? void 0 : params.sandboxTournament.tournamentId))
        return { error: INVALID_VALUES };
    var tournamentRecord = (params === null || params === void 0 ? void 0 : params.sandboxTournament) || getTournamentRecord(tournamentId);
    var tournamentRecords = (params === null || params === void 0 ? void 0 : params.sandboxTournament)
        ? (_a = {}, _a[params === null || params === void 0 ? void 0 : params.sandboxTournament.tournamentId] = params.sandboxTournament, _a) : getTournamentRecords();
    // ENSURE that logged params are not mutated by middleware
    var paramsToLog = params ? makeDeepCopy(params, undefined, true) : undefined;
    var augmentedParams = params ? paramsMiddleware(tournamentRecords, params) : undefined;
    if (augmentedParams === null || augmentedParams === void 0 ? void 0 : augmentedParams.error)
        return augmentedParams;
    var result = invoke({
        params: augmentedParams,
        tournamentRecords: tournamentRecords,
        tournamentRecord: tournamentRecord,
        methodName: methodName,
        method: method,
    });
    var elapsed = Date.now() - start;
    engineLogging({ result: result, methodName: methodName, elapsed: elapsed, params: paramsToLog, engineType: engineType });
    return result;
}
function invoke(_a) {
    var tournamentRecords = _a.tournamentRecords, tournamentRecord = _a.tournamentRecord, params = _a.params, methodName = _a.methodName, method = _a.method;
    if (getDevContext()) {
        return method(__assign({ tournamentRecords: tournamentRecords, tournamentRecord: tournamentRecord }, params));
    }
    else {
        try {
            return method(__assign({ tournamentRecords: tournamentRecords, tournamentRecord: tournamentRecord }, params));
        }
        catch (err) {
            return handleCaughtError({
                engineName: 'engine',
                methodName: methodName,
                params: params,
                err: err,
            });
        }
    }
}

function getState$1(_a) {
    var convertExtensions = _a.convertExtensions, removeExtensions = _a.removeExtensions;
    var tournamentRecords = getTournamentRecords();
    var tournamentId = getTournamentId();
    return {
        tournamentId: tournamentId,
        tournamentRecords: makeDeepCopy(tournamentRecords, convertExtensions, false, removeExtensions),
    };
}
function getTournament(params) {
    var _a;
    var _b = params !== null && params !== void 0 ? params : {}, _c = _b.convertExtensions, convertExtensions = _c === void 0 ? false : _c, _d = _b.removeExtensions, removeExtensions = _d === void 0 ? false : _d;
    var tournamentId = (_a = params === null || params === void 0 ? void 0 : params.tournamentId) !== null && _a !== void 0 ? _a : getTournamentId();
    if (typeof tournamentId !== 'string')
        return {};
    var tournamentRecord = getTournamentRecord(tournamentId);
    return {
        tournamentRecord: makeDeepCopy(tournamentRecord, convertExtensions, false, removeExtensions),
    };
}
function removeUnlinkedTournamentRecords() {
    var _a;
    var tournamentRecords = getTournamentRecords();
    var extension = findExtension({
        name: LINKED_TOURNAMENTS,
        tournamentRecords: tournamentRecords,
        discover: true,
    }).extension;
    var tournamentIds = ((_a = extension === null || extension === void 0 ? void 0 : extension.value) === null || _a === void 0 ? void 0 : _a.tournamentIds) || [];
    Object.keys(tournamentRecords).forEach(function (tournamentId) {
        if (!tournamentIds.includes(tournamentId))
            delete tournamentRecords[tournamentId];
    });
    return setTournamentRecords(tournamentRecords);
}
function setTournamentRecord(record, deepCopyOption) {
    if (deepCopyOption === void 0) { deepCopyOption = true; }
    if (typeof record !== 'object' || Array.isArray(record))
        return { error: INVALID_OBJECT };
    if (!(record === null || record === void 0 ? void 0 : record.tournamentId))
        return { error: INVALID_VALUES };
    return setTournamentRecord$1(deepCopyOption ? makeDeepCopy(record) : record);
}
function setState$1(records, deepCopyOption) {
    var _a;
    if (deepCopyOption === void 0) { deepCopyOption = true; }
    if (typeof records !== 'object')
        return { error: INVALID_OBJECT };
    setTournamentId();
    if (Array.isArray(records)) {
        var validRecordsArray = records.filter(function (record) { return record === null || record === void 0 ? void 0 : record.tournamentId; }).length ===
            records.length;
        if (!validRecordsArray)
            return { error: INVALID_RECORDS };
        records = Object.assign.apply(Object, __spreadArray([{}], __read(records.map(function (record) {
            var _a;
            return (_a = {}, _a[record.tournamentId] = record, _a);
        })), false));
    }
    else if (records === null || records === void 0 ? void 0 : records.tournamentId) {
        records = (_a = {}, _a[records.tournamentId] = records, _a);
        setTournamentId(records.tournamentId);
    }
    else {
        var validRecordsObject = Object.keys(records).every(function (tournamentId) { return records[tournamentId].tournamentId === tournamentId; });
        if (!validRecordsObject)
            return { error: INVALID_RECORDS };
    }
    return setTournamentRecords(deepCopyOption ? makeDeepCopy(records) : records);
}

function asyncExecutionQueue(engine, directives, rollbackOnError) {
    return __awaiter(this, void 0, void 0, function () {
        var methods, start, snapshot, results, directives_1, directives_1_1, directive, methodName, _a, params, pipe, lastResult, pipeKeys, pipeKeys_1, pipeKeys_1_1, pipeKey, result, timeStamp, mutationStatus, success;
        var e_1, _b, e_2, _c;
        return __generator(this, function (_d) {
            if (!Array.isArray(directives))
                return [2 /*return*/, { error: INVALID_VALUES, message: 'directives must be an array' }];
            methods = getMethods();
            start = Date.now();
            snapshot = rollbackOnError && makeDeepCopy(getTournamentRecords(), false, true);
            results = [];
            try {
                for (directives_1 = __values(directives), directives_1_1 = directives_1.next(); !directives_1_1.done; directives_1_1 = directives_1.next()) {
                    directive = directives_1_1.value;
                    if (typeof directive !== 'object')
                        return [2 /*return*/, { error: INVALID_VALUES, message: 'directive must be an object' }];
                    methodName = directive.method, _a = directive.params, params = _a === void 0 ? {} : _a, pipe = directive.pipe;
                    if (!methods[methodName])
                        return [2 /*return*/, logMethodNotFound({ methodName: methodName, start: start, params: params })];
                    if (pipe) {
                        lastResult = results[results.length - 1];
                        pipeKeys = Object.keys(pipe);
                        try {
                            for (pipeKeys_1 = (e_2 = void 0, __values(pipeKeys)), pipeKeys_1_1 = pipeKeys_1.next(); !pipeKeys_1_1.done; pipeKeys_1_1 = pipeKeys_1.next()) {
                                pipeKey = pipeKeys_1_1.value;
                                if (lastResult[pipeKey])
                                    params[pipeKey] = lastResult[pipeKey];
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (pipeKeys_1_1 && !pipeKeys_1_1.done && (_c = pipeKeys_1.return)) _c.call(pipeKeys_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                    result = executeFunction(engine, methods[methodName], params, methodName, 'async');
                    if (result === null || result === void 0 ? void 0 : result.error) {
                        if (snapshot)
                            setState$1(snapshot);
                        return [2 /*return*/, __assign(__assign({}, result), { rolledBack: !!snapshot })];
                    }
                    results.push(__assign(__assign({}, result), { methodName: methodName }));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (directives_1_1 && !directives_1_1.done && (_b = directives_1.return)) _b.call(directives_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            timeStamp = Date.now();
            mutationStatus = getMutationStatus({ timeStamp: timeStamp });
            notifySubscribersAsync({ directives: directives, mutationStatus: mutationStatus, timeStamp: timeStamp });
            deleteNotices();
            success = results.every(function (r) { return r.success; });
            return [2 /*return*/, { success: success, results: results }];
        });
    });
}

function asyncEngineInvoke(engine, args) {
    var _a;
    return __awaiter(this, void 0, void 0, function () {
        var methodsCount, methodName, _b, _c, passedMethod, remainingArgs, params, snapshot, method, result, timeStamp, mutationStatus, notify;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    if (!isObject(args))
                        return [2 /*return*/, { error: INVALID_VALUES, message: 'args must be an object' }];
                    methodsCount = Object.values(args).filter(isFunction).length;
                    if (methodsCount > 1)
                        return [2 /*return*/, {
                                message: 'there must be only one arg with typeof function',
                                error: INVALID_VALUES,
                            }];
                    methodName = methodsCount
                        ? Object.keys(args).find(function (key) { return isFunction(args[key]); })
                        : isString(args.method) && args.method;
                    if (!methodName)
                        return [2 /*return*/, { error: METHOD_NOT_FOUND }];
                    _b = args, _c = methodName, passedMethod = _b[_c], remainingArgs = __rest(_b, [typeof _c === "symbol" ? _c : _c + ""]);
                    params = (args === null || args === void 0 ? void 0 : args.params) || __assign({}, remainingArgs);
                    snapshot = params.rollbackOnError && makeDeepCopy(getTournamentRecords(), false, true);
                    method = passedMethod || engine[methodName] || getMethods$1()[methodName];
                    if (!method)
                        return [2 /*return*/, logMethodNotFound({ methodName: methodName, params: params })];
                    return [4 /*yield*/, executeFunction(engine, method, params, methodName, 'async')];
                case 1:
                    result = (_a = (_d.sent())) !== null && _a !== void 0 ? _a : {};
                    if ((result === null || result === void 0 ? void 0 : result.error) && snapshot)
                        setState$1(snapshot);
                    timeStamp = Date.now();
                    mutationStatus = getMutationStatus({ timeStamp: timeStamp });
                    notify = (result === null || result === void 0 ? void 0 : result.success) &&
                        (params === null || params === void 0 ? void 0 : params.delayNotify) !== true &&
                        (params === null || params === void 0 ? void 0 : params.doNotNotify) !== true;
                    if (!notify) return [3 /*break*/, 3];
                    return [4 /*yield*/, notifySubscribersAsync({
                            directives: [{ method: method, params: params }],
                            mutationStatus: mutationStatus,
                            timeStamp: timeStamp,
                        })];
                case 2:
                    _d.sent();
                    _d.label = 3;
                case 3:
                    if (notify || !(result === null || result === void 0 ? void 0 : result.success) || (params === null || params === void 0 ? void 0 : params.doNotNotify))
                        deleteNotices();
                    return [2 /*return*/, result];
            }
        });
    });
}

function importMethods(engine, engineInvoke, methods) {
    if (!isObject(methods))
        return { error: INVALID_VALUES };
    setMethods(methods);
    var methodNames = Object.keys(methods).filter(function (key) {
        return isFunction(methods[key]);
    });
    methodNames.forEach(function (methodName) {
        engine[methodName] = function (params) {
            var invoke = function () {
                var _a;
                return engineInvoke(engine, __assign((_a = {}, _a[methodName] = methods[methodName], _a), params));
            };
            if (getDevContext()) {
                return invoke();
            }
            else {
                try {
                    return invoke();
                }
                catch (err) {
                    handleCaughtError({
                        engineName: 'engine',
                        methodName: methodName,
                        params: params,
                        err: err,
                    });
                }
            }
        };
    });
    return __assign(__assign({}, SUCCESS), engine);
}

function processResult(engine, result) {
    if (result === null || result === void 0 ? void 0 : result.error) {
        engine.error = result.error;
        engine.success = false;
    }
    else {
        engine.error = undefined;
        engine.success = true;
    }
    return engine;
}

/**
 * Starts the engine by initializing its methods and properties.
 * @param engine - The FactoryEngine object.
 * @param engineInvoke - The engineInvoke object.
 */
function engineStart(engine, engineInvoke) {
    engine.importMethods = function (methods) {
        return importMethods(engine, engineInvoke, methods);
    };
    engine.getTournament = function (params) { return getTournament(params); };
    engine.getState = function (params) {
        return getState$1({
            convertExtensions: params === null || params === void 0 ? void 0 : params.convertExtensions,
            removeExtensions: params === null || params === void 0 ? void 0 : params.removeExtensions,
        });
    };
    engine.version = function () { return factoryVersion(); };
    engine.reset = function () {
        setTournamentRecords({});
        return processResult(engine);
    };
    engine.devContext = function (contextCriteria) {
        setDevContext(contextCriteria);
        return processResult(engine);
    };
    engine.getDevContext = function (contextCriteria) { return getDevContext(contextCriteria); };
    engine.newTournamentRecord = function (params) {
        if (params === void 0) { params = {}; }
        var result = newTournamentRecord(params);
        var tournamentId = result.tournamentId;
        if (result.error)
            return result;
        setTournamentRecord(result);
        setTournamentId(tournamentId);
        return __assign(__assign({}, SUCCESS), { tournamentId: tournamentId });
    };
    engine.setState = function (records, deepCopyOption, deepCopyAttributes) {
        setDeepCopy(deepCopyOption, deepCopyAttributes);
        var result = setState$1(records, deepCopyOption);
        return processResult(engine, result);
    };
    engine.setTournamentId = function (tournamentId) { return setTournamentId(tournamentId); };
    engine.getTournamentId = function () { return getTournamentId(); };
    engine.setTournamentRecord = function (tournamentRecord, deepCopyOption, deepCopyAttributes) {
        setDeepCopy(deepCopyOption, deepCopyAttributes);
        var result = setTournamentRecord(tournamentRecord, deepCopyOption);
        return processResult(engine, result);
    };
    engine.removeTournamentRecord = function (tournamentId) {
        var result = removeTournamentRecord(tournamentId);
        return processResult(engine, result);
    };
    engine.removeUnlinkedTournamentRecords = function () {
        var result = removeUnlinkedTournamentRecords();
        return processResult(engine, result);
    };
}

function asyncEngine(test) {
    var result = createInstanceState();
    if (result.error && !test)
        return result;
    var engine = {
        executionQueue: function (directives, rollbackOnError) {
            return asyncExecutionQueue(engine, directives, rollbackOnError);
        },
        execute: function (args) { return asyncEngineInvoke(engine, args); },
    };
    engineStart(engine, asyncEngineInvoke);
    return engine;
}

function askInvoke(engine, args) {
    if (!isObject(args))
        return { error: INVALID_VALUES, message: 'args must be an object' };
    var methodsCount = Object.values(args).filter(isFunction).length;
    if (methodsCount > 1)
        return {
            message: 'there must be only one arg with typeof function',
            error: INVALID_VALUES,
        };
    var methodName = methodsCount
        ? Object.keys(args).find(function (key) { return isFunction(args[key]); })
        : isString(args.method) && args.method;
    if (!methodName)
        return { error: METHOD_NOT_FOUND };
    var _a = args, _b = methodName, passedMethod = _a[_b], remainingArgs = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
    var params = (args === null || args === void 0 ? void 0 : args.params) || __assign({}, remainingArgs);
    var method = passedMethod || engine[methodName] || getMethods$1()[methodName];
    if (!method)
        return logMethodNotFound({ methodName: methodName, params: params });
    return executeFunction(engine, method, params, methodName, 'ask');
}

var askEngine = (function () {
    var engine = {
        execute: function (args) { return askInvoke(engine, args); },
    };
    engineStart(engine, askInvoke);
    return engine;
})();

function executionQueue(engine, directives, rollbackOnError) {
    var e_1, _a, e_2, _b;
    if (!Array.isArray(directives))
        return { error: INVALID_VALUES, message: 'directives must be an array' };
    var methods = getMethods();
    var start = Date.now();
    var snapshot = rollbackOnError && makeDeepCopy(getTournamentRecords(), false, true);
    var results = [];
    try {
        for (var directives_1 = __values(directives), directives_1_1 = directives_1.next(); !directives_1_1.done; directives_1_1 = directives_1.next()) {
            var directive = directives_1_1.value;
            if (typeof directive !== 'object')
                return { error: INVALID_VALUES, message: 'directive must be an object' };
            var methodName = directive.method, _c = directive.params, params = _c === void 0 ? {} : _c, pipe = directive.pipe;
            if (!methods[methodName])
                return logMethodNotFound({ methodName: methodName, start: start, params: params });
            if (pipe) {
                var lastResult = results[results.length - 1];
                var pipeKeys = Object.keys(pipe);
                try {
                    for (var pipeKeys_1 = (e_2 = void 0, __values(pipeKeys)), pipeKeys_1_1 = pipeKeys_1.next(); !pipeKeys_1_1.done; pipeKeys_1_1 = pipeKeys_1.next()) {
                        var pipeKey = pipeKeys_1_1.value;
                        if (lastResult[pipeKey])
                            params[pipeKey] = lastResult[pipeKey];
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (pipeKeys_1_1 && !pipeKeys_1_1.done && (_b = pipeKeys_1.return)) _b.call(pipeKeys_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            var result = executeFunction(engine, methods[methodName], params, methodName, 'sync');
            if (result === null || result === void 0 ? void 0 : result.error) {
                if (snapshot)
                    setState$1(snapshot);
                return __assign(__assign({}, result), { rolledBack: !!snapshot });
            }
            results.push(__assign(__assign({}, result), { methodName: methodName }));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (directives_1_1 && !directives_1_1.done && (_a = directives_1.return)) _a.call(directives_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var timeStamp = Date.now();
    var mutationStatus = getMutationStatus({ timeStamp: timeStamp });
    notifySubscribers({ directives: directives, mutationStatus: mutationStatus, timeStamp: timeStamp });
    deleteNotices();
    var success = results.every(function (r) { return r.success; });
    return { success: success, results: results };
}

function engineInvoke(engine, args) {
    var _a;
    if (!isObject(args))
        return { error: INVALID_VALUES, message: 'args must be an object' };
    var methodsCount = Object.values(args).filter(isFunction).length;
    if (methodsCount > 1)
        return {
            message: 'there must be only one arg with typeof function',
            error: INVALID_VALUES,
        };
    var methodName = methodsCount
        ? Object.keys(args).find(function (key) { return isFunction(args[key]); })
        : isString(args.method) && args.method;
    if (!methodName)
        return { error: METHOD_NOT_FOUND };
    var _b = args, _c = methodName, passedMethod = _b[_c], remainingArgs = __rest(_b, [typeof _c === "symbol" ? _c : _c + ""]);
    var params = (args === null || args === void 0 ? void 0 : args.params) || __assign({}, remainingArgs);
    var snapshot = params.rollbackOnError && makeDeepCopy(getTournamentRecords(), false, true);
    var method = passedMethod || engine[methodName] || getMethods$1()[methodName];
    if (!method)
        return logMethodNotFound({ methodName: methodName, params: params });
    var result = (_a = executeFunction(engine, method, params, methodName, 'sync')) !== null && _a !== void 0 ? _a : {};
    if ((result === null || result === void 0 ? void 0 : result.error) && snapshot)
        setState$1(snapshot);
    var timeStamp = Date.now();
    var mutationStatus = getMutationStatus({ timeStamp: timeStamp });
    var notify = (result === null || result === void 0 ? void 0 : result.success) &&
        (params === null || params === void 0 ? void 0 : params.delayNotify) !== true &&
        (params === null || params === void 0 ? void 0 : params.doNotNotify) !== true;
    if (notify)
        notifySubscribers({
            directives: [{ method: method, params: params }],
            mutationStatus: mutationStatus,
            timeStamp: timeStamp,
        });
    if (notify || !(result === null || result === void 0 ? void 0 : result.success) || (params === null || params === void 0 ? void 0 : params.doNotNotify))
        deleteNotices();
    return result;
}

var engine = (function () {
    var engine = {
        executionQueue: function (directives, rollbackOnError) {
            return executionQueue(engine, directives, rollbackOnError);
        },
        execute: function (args) { return engineInvoke(engine, args); },
    };
    engineStart(engine, engineInvoke);
    return engine;
})();

var methods$1 = __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({}, competitionGovernor), participantGovernor), publishingGovernor), generationGovernor), tournamentGovernor), scheduleGovernor), policyGovernor), reportGovernor), eventGovernor), queryGovernor), scoreGovernor), venueGovernor);
engine.importMethods(methods$1);
var competitionEngine = engine;
var tournamentEngine = engine;

// TASK: add verify/validate structure as option in setState
var keyedMatchUps = {};
var matchUpId;
function setState(value, deepCopyOption) {
    var e_1, _a, e_2, _b;
    if (deepCopyOption === void 0) { deepCopyOption = true; }
    if (!value)
        return { error: MISSING_VALUE };
    if (typeof value !== 'object')
        return { error: INVALID_OBJECT };
    if (value.matchUpId) {
        matchUpId = value.matchUpId;
        keyedMatchUps[matchUpId] = deepCopyOption ? makeDeepCopy(value) : value;
    }
    else if (Array.isArray(value)) {
        try {
            for (var _c = __values(value.reverse()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var m = _d.value;
                if (m.matchUpId) {
                    keyedMatchUps[m.matchUpId] = deepCopyOption ? makeDeepCopy(m) : m;
                    if (!matchUpId)
                        matchUpId = m.matchUpId;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else {
        try {
            for (var _e = __values(Object.values(value)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var m = _f.value;
                if (m.matchUpId) {
                    keyedMatchUps[m.matchUpId] = deepCopyOption ? makeDeepCopy(m) : m;
                    if (!matchUpId)
                        matchUpId = m.matchUpId;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    return deepCopyOption ? makeDeepCopy(value) : value;
}
function getMatchUp() {
    return keyedMatchUps[matchUpId];
}
function getMatchUps() {
    return Object.values(keyedMatchUps);
}
function reset() {
    matchUpId = undefined;
    keyedMatchUps = {};
}
function getState(params) {
    return makeDeepCopy(keyedMatchUps[matchUpId], params === null || params === void 0 ? void 0 : params.convertExtensions, false, params === null || params === void 0 ? void 0 : params.removeExtensions);
}

var matchUpEngine = (function () {
    var engine = {
        getState: function (params) { return getState(params); },
        version: function () { return factoryVersion(); },
        reset: function () {
            reset();
            return __assign({}, SUCCESS);
        },
        drawId: undefined,
        error: undefined,
        success: false,
        devContext: function (contextCriteria) {
            setDevContext(contextCriteria);
            return engine;
        },
        setState: function (definition, deepCopyOption, deepCopyAttributes) {
            setDeepCopy(deepCopyOption, deepCopyAttributes);
            var result = setState(definition);
            return processResult(result);
        },
    };
    function processResult(result) {
        if (result === null || result === void 0 ? void 0 : result.error) {
            engine.error = result.error;
            engine.success = false;
        }
        else {
            engine.error = undefined;
            engine.success = true;
            engine.drawId = result.drawId;
        }
        return engine;
    }
    importGovernors([scoreGovernor]);
    return engine;
    function importGovernors(governors) {
        governors.forEach(function (governor) {
            Object.keys(governor).forEach(function (methodName) {
                engine[methodName] = function (params) {
                    if (getDevContext()) {
                        return invoke({ params: params, governor: governor, methodName: methodName });
                    }
                    else {
                        try {
                            return invoke({ params: params, governor: governor, methodName: methodName });
                        }
                        catch (err) {
                            handleCaughtError({
                                engineName: 'matchUpEngine',
                                methodName: methodName,
                                params: params,
                                err: err,
                            });
                        }
                    }
                };
            });
        });
    }
    function invoke(_a) {
        var params = _a.params, governor = _a.governor, methodName = _a.methodName;
        engine.error = undefined;
        engine.success = false;
        var matchUp = (params === null || params === void 0 ? void 0 : params.matchUp) || getMatchUp();
        var matchUps = (params === null || params === void 0 ? void 0 : params.matchUps) || getMatchUps();
        var snapshot = (params === null || params === void 0 ? void 0 : params.rollbackOnError) && makeDeepCopy(matchUp, false, true);
        params = __assign(__assign({}, params), { matchUpId: matchUp === null || matchUp === void 0 ? void 0 : matchUp.matchUpId, matchUps: matchUps, matchUp: matchUp });
        var result = governor[methodName](params);
        if (result === null || result === void 0 ? void 0 : result.error) {
            if (snapshot)
                setState(snapshot);
            return __assign(__assign({}, result), { rolledBack: !!snapshot });
        }
        var notify = (result === null || result === void 0 ? void 0 : result.success) &&
            (params === null || params === void 0 ? void 0 : params.delayNotify) !== true &&
            (params === null || params === void 0 ? void 0 : params.doNotNotify) !== true;
        if (notify)
            notifySubscribers();
        if (notify || !(result === null || result === void 0 ? void 0 : result.success) || (params === null || params === void 0 ? void 0 : params.doNotNotify))
            deleteNotices();
        return result;
    }
})();

var devContextSet = false;
var mocksEngine = (function () {
    var engine = {
        version: function () { return factoryVersion(); },
        setDeepCopy: function (deepCopyOption, deepCopyAttributes) {
            setDeepCopy(deepCopyOption, deepCopyAttributes);
            return engine;
        },
        devContext: function (isDev) {
            setDevContext(isDev);
            devContextSet = true;
            return engine;
        },
    };
    importGovernors([mocksGovernor]);
    return engine;
    // enable Middleware
    function engineInvoke(method, params) {
        var result = method(__assign({}, params));
        if (!(result === null || result === void 0 ? void 0 : result.error))
            notifySubscribers();
        deleteNotices();
        // cleanup if set on invocation
        if (devContextSet) {
            setDevContext(false);
            devContextSet = false;
        }
        return result;
    }
    function importGovernors(governors) {
        governors.forEach(function (governor) {
            Object.keys(governor).forEach(function (method) {
                engine[method] = function (params) {
                    try {
                        var invocationResult = engineInvoke(governor[method], params);
                        if (!(invocationResult === null || invocationResult === void 0 ? void 0 : invocationResult.error) && (params === null || params === void 0 ? void 0 : params.setState) && (invocationResult === null || invocationResult === void 0 ? void 0 : invocationResult.tournamentRecord)) {
                            setState$1(invocationResult.tournamentRecord);
                        }
                        return invocationResult;
                    }
                    catch (err) {
                        var error = void 0;
                        if (typeof err === 'string') {
                            error = err.toUpperCase();
                        }
                        else if (err instanceof Error) {
                            error = err.message;
                        }
                        console.log('ERROR', {
                            params: JSON.stringify(params),
                            method: method,
                            error: error,
                        });
                    }
                };
            });
        });
    }
})();

function getTargetElement(target, element) {
    return ((target && element && Array.isArray(element) && element[target - 1]) ||
        (typeof element === 'object' && element[target]));
}

function getAwardProfile(params) {
    var _a = params.participation, participation = _a === void 0 ? {} : _a, awardProfiles = params.awardProfiles, startDate = params.startDate, eventType = params.eventType, drawSize = params.drawSize, drawType = params.drawType, category = params.category, endDate = params.endDate, level = params.level;
    var participationOrder = participation.participationOrder, flightNumber = participation.flightNumber, rankingStage = participation.rankingStage;
    var isValidDateRange = function (profile) {
        if ((!startDate && !endDate) || !profile.dateRanges)
            return true;
        return profile.dateRanges.some(function (dateRange) {
            var validStartDate = !startDate ||
                !dateRange.startDate ||
                new Date(startDate) > new Date(dateRange.startDate);
            var validEndDate = !endDate ||
                !dateRange.endDate ||
                new Date(endDate) <= new Date(dateRange.endDate);
            return validStartDate && validEndDate;
        });
    };
    var awardProfile = awardProfiles.find(function (profile) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        return isValidDateRange(profile) &&
            (!profile.maxFlightNumber || flightNumber <= profile.maxFlightNumber) &&
            (!((_a = profile.drawTypes) === null || _a === void 0 ? void 0 : _a.length) || ((_b = profile.drawTypes) === null || _b === void 0 ? void 0 : _b.includes(drawType))) &&
            (!((_c = profile.drawSizes) === null || _c === void 0 ? void 0 : _c.length) || profile.drawSizes.includes(drawSize)) &&
            (!((_d = profile.stages) === null || _d === void 0 ? void 0 : _d.length) || profile.stages.includes(rankingStage)) &&
            (!((_e = profile.levels) === null || _e === void 0 ? void 0 : _e.length) || profile.levels.includes(level)) &&
            (!profile.maxDrawSize || drawSize <= profile.maxDrawSize) &&
            (!profile.drawSize || profile.drawSize === drawSize) &&
            (!profile.maxLevel || level <= profile.maxLevel) &&
            (!flightNumber ||
                !((_g = (_f = profile.flights) === null || _f === void 0 ? void 0 : _f.flightNumbers) === null || _g === void 0 ? void 0 : _g.length) ||
                profile.flights.flightNumbers.includes(flightNumber)) &&
            (!profile.participationOrder ||
                profile.participationOrder === participationOrder) &&
            (!((_h = profile.category) === null || _h === void 0 ? void 0 : _h.ageCategoryCodes) ||
                profile.category.ageCategoryCodes.includes(category === null || category === void 0 ? void 0 : category.ageCategoryCode)) &&
            (!((_j = profile.eventTypes) === null || _j === void 0 ? void 0 : _j.length) || ((_k = profile.eventTypes) === null || _k === void 0 ? void 0 : _k.includes(eventType)));
    });
    return { awardProfile: awardProfile };
}

function getAwardPoints(_a) {
    var _b, _c;
    var participantWon = _a.participantWon, flightNumber = _a.flightNumber, valueObj = _a.valueObj, drawSize = _a.drawSize, flights = _a.flights, level = _a.level;
    var getFlightValue = function (flightNumber, targetElement) {
        if (!flightNumber)
            return;
        if (Array.isArray(targetElement)) {
            var arrayMember = targetElement.find(function (m) { return m.flight === flightNumber || m.f === flightNumber; });
            return arrayMember.value || arrayMember.v;
        }
        if (typeof targetElement === 'object') {
            var flights_1 = targetElement.flights || targetElement.f;
            if (Array.isArray(flights_1))
                return flights_1[flightNumber - 1];
        }
    };
    var getValue = function (obj, flightNumber) {
        var objectValue = (obj === null || obj === void 0 ? void 0 : obj.value) || (obj === null || obj === void 0 ? void 0 : obj.v) || (isConvertableInteger(obj) ? obj : 0);
        var targetElement = getTargetElement(level, obj === null || obj === void 0 ? void 0 : obj.level);
        var flightValue = getFlightValue(flightNumber, targetElement);
        var value = flightValue ||
            (isConvertableInteger(targetElement) && targetElement) ||
            objectValue;
        return { value: value };
    };
    var awardPoints = 0;
    var requireWin;
    var s, t, d;
    var winAccessor = (participantWon && 'won') ||
        (participantWon === false && 'lost') ||
        undefined;
    if (Array.isArray(valueObj)) {
        var sizeDefined = valueObj.find(function (obj) { var _a; return obj.drawSize === drawSize || ((_a = obj.drawSizes) === null || _a === void 0 ? void 0 : _a.includes(drawSize)); });
        // threshold attribute allows a definition for e.g. drawSize: 16 to apply to all LARGER drawSizes
        var thresholdMatched = valueObj.find(function (obj) { return obj.drawSize && obj.threshold && drawSize > obj.drawSize; });
        // a default definition can be provided which has no drawSize or drawSizes
        var defaultDef = valueObj.find(function (obj) { var _a; return !obj.drawSize && !((_a = obj.drawSizes) === null || _a === void 0 ? void 0 : _a.length); });
        if (winAccessor !== undefined) {
            sizeDefined = sizeDefined === null || sizeDefined === void 0 ? void 0 : sizeDefined[winAccessor];
            thresholdMatched = thresholdMatched === null || thresholdMatched === void 0 ? void 0 : thresholdMatched[winAccessor];
            defaultDef = defaultDef === null || defaultDef === void 0 ? void 0 : defaultDef[winAccessor];
        }
        s = getValue(sizeDefined, flightNumber).value;
        t = getValue(thresholdMatched, flightNumber).value;
        d = getValue(defaultDef, flightNumber).value;
        awardPoints = s || t || d;
        requireWin =
            (s && sizeDefined.requireWin) ||
                (t && thresholdMatched.requireWin) ||
                (defaultDef === null || defaultDef === void 0 ? void 0 : defaultDef.requireWin);
    }
    else if (typeof valueObj === 'object') {
        var sizeDefined = (_b = valueObj === null || valueObj === void 0 ? void 0 : valueObj.drawSizes) === null || _b === void 0 ? void 0 : _b[drawSize];
        var defaultDef = valueObj;
        if (winAccessor !== undefined) {
            sizeDefined = sizeDefined === null || sizeDefined === void 0 ? void 0 : sizeDefined[winAccessor];
            defaultDef = defaultDef === null || defaultDef === void 0 ? void 0 : defaultDef[winAccessor];
        }
        s = getValue(sizeDefined, flightNumber).value;
        d = getValue(defaultDef, flightNumber).value;
        awardPoints = s || d;
        requireWin = s ? sizeDefined.requireWin : defaultDef === null || defaultDef === void 0 ? void 0 : defaultDef.requireWin;
    }
    else if (isConvertableInteger(valueObj) && winAccessor === undefined) {
        // when using participantWon non-objects are not valid
        awardPoints = valueObj;
    }
    if (flightNumber && ((_c = flights === null || flights === void 0 ? void 0 : flights.pct) === null || _c === void 0 ? void 0 : _c[flightNumber])) {
        awardPoints = Math.round(awardPoints * flights.pct[flightNumber]);
    }
    return { awardPoints: awardPoints, requireWin: requireWin };
}

function getTournamentPoints(_a) {
    var e_1, _b;
    var _c, _d;
    var participantFilters = _a.participantFilters, policyDefinitions = _a.policyDefinitions, tournamentRecord = _a.tournamentRecord, saveRankings = _a.saveRankings, level = _a.level;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    var attachedPolicies = getPolicyDefinitions({
        policyTypes: [POLICY_TYPE_RANKING_POINTS],
        tournamentRecord: tournamentRecord,
    }).policyDefinitions;
    var pointsPolicy = (_c = policyDefinitions === null || policyDefinitions === void 0 ? void 0 : policyDefinitions[POLICY_TYPE_RANKING_POINTS]) !== null && _c !== void 0 ? _c : attachedPolicies === null || attachedPolicies === void 0 ? void 0 : attachedPolicies[POLICY_TYPE_RANKING_POINTS];
    if (!pointsPolicy)
        return { error: MISSING_POLICY_DEFINITION };
    var awardProfiles = pointsPolicy.awardProfiles;
    var requireWinFirstRound = pointsPolicy.requireWinFirstRound;
    var requireWinForPoints = pointsPolicy.requireWinForPoints;
    var _e = getParticipants({
        withRankingProfile: true,
        participantFilters: participantFilters,
        tournamentRecord: tournamentRecord,
    }), participants = _e.participants, derivedEventInfo = _e.derivedEventInfo, derivedDrawInfo = _e.derivedDrawInfo, mappedMatchUps = _e.mappedMatchUps;
    var participantsWithOutcomes = participants === null || participants === void 0 ? void 0 : participants.filter(function (p) { var _a; return (_a = p.draws) === null || _a === void 0 ? void 0 : _a.length; });
    // keep track of points earned per person / per team
    var personPoints = {};
    var teamPoints = {};
    var pairPoints = {};
    var _loop_1 = function (participant) {
        var e_2, _h, e_3, _j;
        var participantType = participant.participantType, participantId = participant.participantId, person = participant.person, draws = participant.draws;
        try {
            for (var draws_1 = (e_2 = void 0, __values(draws)), draws_1_1 = draws_1.next(); !draws_1_1.done; draws_1_1 = draws_1.next()) {
                var draw = draws_1_1.value;
                var drawId = draw.drawId, structureParticipation = draw.structureParticipation, eventId = draw.eventId;
                var eventInfo = derivedEventInfo[eventId];
                var drawInfo = derivedDrawInfo[drawId];
                var drawType = drawInfo === null || drawInfo === void 0 ? void 0 : drawInfo.drawType;
                var _k = eventInfo || {}, category = _k.category, eventType = _k.eventType;
                var startDate = draw.startDate || eventInfo.startDate || tournamentRecord.startDate;
                var endDate = draw.endDate || eventInfo.endDate || tournamentRecord.endDate;
                // don't process INDIVIDUAL and PAIR participants in TEAM events
                // They are processed in the context of the TEAM in which they appear
                if (eventType === TEAM_EVENT && participantId !== TEAM_PARTICIPANT) {
                    continue;
                }
                var points = void 0;
                if (awardProfiles) {
                    var requireWin = requireWinForPoints;
                    var totalWinsCount = 0;
                    var positionPoints = 0;
                    var perWinPoints = 0;
                    var rangeAccessor = void 0;
                    var _loop_2 = function (participation) {
                        var _l, _m, e_4, _o, e_5, _p;
                        var finishingPositionRange = participation.finishingPositionRange, participationOrder = participation.participationOrder, participantWon = participation.participantWon, flightNumber = participation.flightNumber, rankingStage = participation.rankingStage, winCount = participation.winCount;
                        totalWinsCount += winCount || 0;
                        var drawSize = drawInfo === null || drawInfo === void 0 ? void 0 : drawInfo.drawSize;
                        var awardProfile = getAwardProfile({
                            awardProfiles: awardProfiles,
                            participation: participation,
                            eventType: eventType,
                            startDate: startDate,
                            category: category,
                            drawSize: drawSize,
                            drawType: drawType,
                            endDate: endDate,
                            level: level,
                        }).awardProfile;
                        if (awardProfile) {
                            // NOTE: for now drawSize: 0 indicates qualifying structure with no MAIN structure
                            // TODO: support for qualifying stage awardProfiles
                            if (!drawSize)
                                return "continue";
                            var accessor = Array.isArray(finishingPositionRange) && Math.max.apply(Math, __spreadArray([], __read(finishingPositionRange), false));
                            var dashRange = unique(finishingPositionRange || []).join('-');
                            var firstRound = accessor &&
                                rankingStage !== QUALIFYING &&
                                (finishingPositionRange === null || finishingPositionRange === void 0 ? void 0 : finishingPositionRange.includes(drawSize));
                            if (awardProfile.requireWinForPoints !== undefined)
                                requireWin = awardProfile.requireWinForPoints;
                            if (awardProfile.requireWinFirstRound !== undefined)
                                requireWinFirstRound = awardProfile.requireWinFirstRound;
                            var _q = awardProfile.finishingPositionPoints, finishingPositionPoints = _q === void 0 ? {} : _q, finishingPositionRanges = awardProfile.finishingPositionRanges, finishingRound = awardProfile.finishingRound, pointsPerWin = awardProfile.pointsPerWin, flights = awardProfile.flights;
                            var ppwProfile = Array.isArray(awardProfile.perWinPoints)
                                ? (_d = awardProfile.perWinPoints) === null || _d === void 0 ? void 0 : _d.find(function (pwp) { var _a; return (_a = pwp.participationOrders) === null || _a === void 0 ? void 0 : _a.includes(participationOrder); })
                                : awardProfile.perWinPoints;
                            var participationOrders = finishingPositionPoints.participationOrders;
                            var awardPoints = 0;
                            var winRequired = void 0;
                            var isValidOrder = !participationOrders ||
                                participationOrders.includes(participationOrder);
                            if (isValidOrder && finishingPositionRanges && accessor) {
                                var valueObj = finishingPositionRanges[accessor];
                                if (valueObj) {
                                    (_l = getAwardPoints({
                                        flightNumber: flightNumber,
                                        valueObj: valueObj,
                                        drawSize: drawSize,
                                        flights: flights,
                                        level: level,
                                    }), awardPoints = _l.awardPoints, winRequired = _l.requireWin);
                                }
                            }
                            if (!awardPoints &&
                                finishingRound &&
                                participationOrder === 1 &&
                                accessor) {
                                var valueObj = finishingRound[accessor];
                                if (valueObj) {
                                    (_m = getAwardPoints({
                                        participantWon: participantWon,
                                        flightNumber: flightNumber,
                                        valueObj: valueObj,
                                        drawSize: drawSize,
                                        flights: flights,
                                        level: level,
                                    }), awardPoints = _m.awardPoints, winRequired = _m.requireWin);
                                }
                            }
                            if (firstRound && requireWinFirstRound !== undefined) {
                                requireWin = requireWinFirstRound;
                            }
                            if (winRequired !== undefined)
                                requireWin = winRequired;
                            if (awardPoints > positionPoints && (!requireWin || winCount)) {
                                positionPoints = awardPoints;
                                rangeAccessor = accessor;
                            }
                            if (!awardPoints && pointsPerWin && winCount) {
                                perWinPoints += winCount * pointsPerWin;
                                rangeAccessor = dashRange;
                            }
                            if (!awardPoints && winCount && ppwProfile) {
                                var levelValue = getTargetElement(level, ppwProfile === null || ppwProfile === void 0 ? void 0 : ppwProfile.level);
                                if (levelValue) {
                                    perWinPoints += winCount * levelValue;
                                }
                                else if (ppwProfile.value) {
                                    perWinPoints += winCount * ppwProfile.value;
                                }
                            }
                        }
                        points = positionPoints + perWinPoints;
                        if (participantType === TEAM_PARTICIPANT) {
                            var teamStructureMatchUps = (participant.matchUps || []).filter(function (_a) {
                                var structureId = _a.structureId;
                                return structureId === participation.structureId;
                            });
                            try {
                                for (var teamStructureMatchUps_1 = (e_4 = void 0, __values(teamStructureMatchUps)), teamStructureMatchUps_1_1 = teamStructureMatchUps_1.next(); !teamStructureMatchUps_1_1.done; teamStructureMatchUps_1_1 = teamStructureMatchUps_1.next()) {
                                    var matchUpId = teamStructureMatchUps_1_1.value.matchUpId;
                                    var matchUp = mappedMatchUps[matchUpId];
                                    var sideNumber = matchUp.sides.find(function (side) { return side.participantId === participantId; }).sideNumber;
                                    // for now only supporting line position awards per team win
                                    if (matchUp.winningSice !== sideNumber) {
                                        continue;
                                    }
                                    try {
                                        for (var _r = (e_5 = void 0, __values(matchUp.tieMatchUps)), _s = _r.next(); !_s.done; _s = _r.next()) {
                                            var tieMatchUp = _s.value;
                                            // ingore matchUps with no winningSide
                                            if (!tieMatchUp.winningSide)
                                                continue;
                                        }
                                    }
                                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                                    finally {
                                        try {
                                            if (_s && !_s.done && (_p = _r.return)) _p.call(_r);
                                        }
                                        finally { if (e_5) throw e_5.error; }
                                    }
                                }
                            }
                            catch (e_4_1) { e_4 = { error: e_4_1 }; }
                            finally {
                                try {
                                    if (teamStructureMatchUps_1_1 && !teamStructureMatchUps_1_1.done && (_o = teamStructureMatchUps_1.return)) _o.call(teamStructureMatchUps_1);
                                }
                                finally { if (e_4) throw e_4.error; }
                            }
                        }
                    };
                    try {
                        for (var structureParticipation_1 = (e_3 = void 0, __values(structureParticipation)), structureParticipation_1_1 = structureParticipation_1.next(); !structureParticipation_1_1.done; structureParticipation_1_1 = structureParticipation_1.next()) {
                            var participation = structureParticipation_1_1.value;
                            _loop_2(participation);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (structureParticipation_1_1 && !structureParticipation_1_1.done && (_j = structureParticipation_1.return)) _j.call(structureParticipation_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                    if (perWinPoints || positionPoints) {
                        var award = {
                            winCount: totalWinsCount,
                            positionPoints: positionPoints,
                            rangeAccessor: rangeAccessor,
                            perWinPoints: perWinPoints,
                            eventType: eventType,
                            drawId: drawId,
                            points: points,
                        };
                        var personId = person === null || person === void 0 ? void 0 : person.personId;
                        if (personId) {
                            if (!personPoints[personId])
                                personPoints[personId] = [];
                            personPoints[personId].push(award);
                        }
                        else if (participantType === PAIR) {
                            if (!pairPoints[participantId])
                                pairPoints[participantId] = [];
                            pairPoints[participantId].push(award);
                        }
                        else if (participantType === TEAM_PARTICIPANT) {
                            if (!teamPoints[participantId])
                                teamPoints[participantId] = [];
                            teamPoints[participantId].push(award);
                        }
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (draws_1_1 && !draws_1_1.done && (_h = draws_1.return)) _h.call(draws_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    try {
        for (var _f = __values(participantsWithOutcomes !== null && participantsWithOutcomes !== void 0 ? participantsWithOutcomes : []), _g = _f.next(); !_g.done; _g = _f.next()) {
            var participant = _g.value;
            _loop_1(participant);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (saveRankings) {
        // possibly also ensure ranking policy is part of applied policies
        var extension = {
            name: RANKING_POINTS,
            value: { personPoints: personPoints, teamPoints: teamPoints, pairPoints: pairPoints },
        };
        addExtension({ element: tournamentRecord, extension: extension });
    }
    return __assign({ participantsWithOutcomes: participantsWithOutcomes, personPoints: personPoints, pairPoints: pairPoints, teamPoints: teamPoints }, SUCCESS);
}

var rankingsGovernor = {
    getTournamentPoints: getTournamentPoints,
};

// see footnote #3 here:
// http://fivethirtyeight.com/features/serena-williams-and-the-difference-between-all-time-great-and-greatest-of-all-time/
var k538 = function (countables) { return 250 / Math.pow(countables + 5, 0.4); };
var kDefault = function () { return 1; };
// win multipier is scaled by % countables won
// https://www.stat.berkeley.edu/~aldous/157/Old_Projects/huang.pdf
function kSet(maxCountables, counted) {
    if (maxCountables === void 0) { maxCountables = 3; }
    if (counted === void 0) { counted = 2; }
    var kset = maxCountables / counted;
    return isNaN(kset) ? eloConfig.kDefault() : kset;
}
var eloConfig = {
    nSpread: 400, // determines the 'spread' of the scale
    diffThreshold: 0.125,
    kCalc: k538, // use calculation defined by FiveThirtyEight.com
    kMultiplier: kSet, // change to kDefault for value of 1
    kDefault: kDefault,
};
function calculateNewRatings(params) {
    var winnerRating = params.winnerRating, loserRating = params.loserRating, ratingRange = params.ratingRange;
    var _a = params || {}, _b = _a.ratings, ratings = _b === void 0 ? ratingsParameters : _b, _c = _a.winnerCountables, winnerCountables = _c === void 0 ? 1 : _c, _d = _a.loserCountables, loserCountables = _d === void 0 ? 0 : _d, _e = _a.ratingType, ratingType = _e === void 0 ? ELO : _e, maxCountables = _a.maxCountables, countables = _a.countables;
    var ratingParameters = ratings === null || ratings === void 0 ? void 0 : ratings[ratingType];
    if (!ratingParameters)
        return { error: MISSING_VALUE };
    ratingRange = ratingParameters.range || ratingRange;
    winnerRating = winnerRating || ratingParameters.defaultInitialization;
    loserRating = loserRating || ratingParameters.defaultInitialization;
    var invertedScale = ratingRange[0] > ratingRange[1];
    var decimalPlaces = ratingParameters.decimalsCount || 0;
    var consideredRange = invertedScale
        ? ratingRange.slice().reverse()
        : ratingRange;
    var inRange = function (range, value) {
        return parseFloat(value) >= Math.min.apply(Math, __spreadArray([], __read(range), false)) &&
            parseFloat(value) <= Math.max.apply(Math, __spreadArray([], __read(range), false));
    };
    if (!inRange(ratingRange, winnerRating) ||
        !inRange(ratingRange, loserRating)) {
        if (!inRange(ratingRange, winnerRating))
            winnerRating = ratingParameters.defaultInitialization;
        if (!inRange(ratingRange, loserRating))
            loserRating = ratingParameters.defaultInitialization;
    }
    // convert one rating range to another rating range
    var convertRange = function (_a) {
        var value = _a.value, sourceRange = _a.sourceRange, targetRange = _a.targetRange;
        return ((value - sourceRange[0]) * (targetRange[1] - targetRange[0])) /
            (sourceRange[1] - sourceRange[0]) +
            targetRange[0];
    };
    // convert inbound ratings from ratingType into ELO
    var convertedWinnerRating = convertRange({
        targetRange: ratingsParameters[ELO].range,
        sourceRange: consideredRange,
        value: invertedScale ? ratingRange[0] - winnerRating : winnerRating,
    });
    var convertedLoserRating = convertRange({
        targetRange: ratingsParameters[ELO].range,
        sourceRange: consideredRange,
        value: invertedScale ? ratingRange[0] - loserRating : loserRating,
    });
    var getExpectation = function (playerRating, opponentRating) {
        return 1 / (1 + Math.pow(10, (opponentRating - playerRating) / eloConfig.nSpread));
    };
    var winnerExpectation = getExpectation(convertedWinnerRating, convertedLoserRating);
    var loserExpectation = getExpectation(convertedLoserRating, convertedWinnerRating);
    var winnerKValue = eloConfig.kCalc(winnerCountables);
    var loserKValue = eloConfig.kCalc(loserCountables);
    var k = eloConfig.kMultiplier(maxCountables, countables);
    var winnerUpdatedConvertedRating = convertedWinnerRating + k * winnerKValue * (1 - winnerExpectation);
    var loserUpdatedConvertedRating = convertedLoserRating + k * loserKValue * (0 - loserExpectation);
    // convert calculated new ratings from ELO into ratingType
    var convertedUpdatedWinnerRating = convertRange({
        sourceRange: ratingsParameters[ELO].range,
        value: winnerUpdatedConvertedRating,
        targetRange: consideredRange,
    });
    var convertedUpdatedLoserRating = convertRange({
        sourceRange: ratingsParameters[ELO].range,
        value: loserUpdatedConvertedRating,
        targetRange: consideredRange,
    });
    var updatedWinnerRating = invertedScale
        ? ratingRange[0] - convertedUpdatedWinnerRating
        : convertedUpdatedWinnerRating;
    var newWinnerRating = parseFloat(parseFloat(updatedWinnerRating).toFixed(decimalPlaces));
    var updatedLoserRating = invertedScale
        ? ratingRange[0] - convertedUpdatedLoserRating
        : convertedUpdatedLoserRating;
    var newLoserRating = parseFloat(parseFloat(updatedLoserRating).toFixed(decimalPlaces));
    //  if expected winner && percentageDifference > threshold don't change ratings
    var percentageDifference = Math.max.apply(Math, __spreadArray([], __read(ratingRange), false)) ? Math.abs(winnerRating - loserRating) / Math.max.apply(Math, __spreadArray([], __read(ratingRange), false))
        : 0;
    if ((convertedUpdatedWinnerRating > convertedUpdatedLoserRating &&
        percentageDifference > eloConfig.diffThreshold) ||
        newWinnerRating < 0 ||
        newLoserRating < 0) {
        newWinnerRating = winnerRating;
        newLoserRating = loserRating;
    }
    return { newWinnerRating: newWinnerRating, newLoserRating: newLoserRating };
}

var aggregateSets = function (sets) {
    return ((sets === null || sets === void 0 ? void 0 : sets.reduce(function (aggregate, set) {
        if (set.winningSide)
            aggregate[set.winningSide - 1] += 1;
        return aggregate;
    }, [0, 0])) || [0, 0]);
};

function generateDynamicRatings(_a) {
    var e_1, _b;
    var _c, _d, _e;
    var _f = _a.removePriorValues, removePriorValues = _f === void 0 ? true : _f, tournamentRecord = _a.tournamentRecord, _g = _a.ratingType, ratingType = _g === void 0 ? ELO : _g, considerGames = _a.considerGames, matchUpIds = _a.matchUpIds, asDynamic = _a.asDynamic;
    if (!tournamentRecord)
        return { error: MISSING_TOURNAMENT_RECORD };
    if (!Array.isArray(matchUpIds))
        return { error: MISSING_MATCHUPS };
    if (typeof ratingType !== 'string')
        return { error: INVALID_VALUES, ratingType: ratingType };
    if (!ratingsParameters[ratingType])
        return { error: INVALID_VALUES };
    var ratingParameter = ratingsParameters[ratingType];
    var accessor = ratingParameter.accessor;
    var modifiedScaleValues = {};
    var matchUps = (_c = allTournamentMatchUps({
        matchUpFilters: { matchUpIds: matchUpIds, matchUpStatuses: completedMatchUpStatuses },
        tournamentRecord: tournamentRecord,
        inContext: true,
    }).matchUps) !== null && _c !== void 0 ? _c : [];
    matchUps.sort(matchUpSort);
    var _loop_1 = function (matchUp) {
        var e_2, _h, e_3, _j, _k, _l;
        var endDate = matchUp.endDate, matchUpFormat = matchUp.matchUpFormat, score = matchUp.score, sides = matchUp.sides, winningSide = matchUp.winningSide;
        var matchUpType = matchUp.matchUpType;
        var scaleAttributes = {
            eventType: matchUpType,
            scaleName: ratingType,
            scaleType: RATING$1,
        };
        var dynamicScaleName = "".concat(ratingType, ".").concat(DYNAMIC);
        var dynamicScaleAttributes = {
            scaleName: dynamicScaleName,
            eventType: matchUpType,
            scaleType: RATING$1,
        };
        var sideParticipantIds = Object.assign.apply(Object, __spreadArray([{}], __read((sides !== null && sides !== void 0 ? sides : []).map(function (side) {
            var _a;
            var _b;
            var sideNumber = side.sideNumber, participant = side.participant;
            return (sideNumber && (_a = {},
                _a[sideNumber] = __spreadArray([
                    participant === null || participant === void 0 ? void 0 : participant.participantId
                ], __read(((_b = participant === null || participant === void 0 ? void 0 : participant.individualParticipantIds) !== null && _b !== void 0 ? _b : [])), false).filter(Boolean)
                    .flat(),
                _a));
        })), false));
        var outputScaleName = asDynamic ? dynamicScaleName : ratingType;
        var scaleItemMap = Object.assign.apply(Object, __spreadArray([{}], __read(Object.values(sideParticipantIds)
            .flat()
            .map(function (participantId) {
            var _a, _b;
            var _c;
            var dynamicScaleItem = getParticipantScaleItem({
                scaleAttributes: dynamicScaleAttributes,
                tournamentRecord: tournamentRecord,
                participantId: participantId,
            }).scaleItem;
            var scaleItem = getParticipantScaleItem({
                tournamentRecord: tournamentRecord,
                scaleAttributes: scaleAttributes,
                participantId: participantId,
            }).scaleItem;
            var scaleValue = accessor ? (_a = {}, _a[accessor] = undefined, _a) : undefined;
            return (participantId && (_b = {},
                _b[participantId] = (_c = dynamicScaleItem !== null && dynamicScaleItem !== void 0 ? dynamicScaleItem : scaleItem) !== null && _c !== void 0 ? _c : {
                    scaleName: outputScaleName,
                    eventType: matchUpType,
                    scaleDate: endDate,
                    scaleType: RATING$1,
                    scaleValue: scaleValue,
                },
                _b));
        })), false));
        var parsedFormat = matchUpFormat ? parse(matchUpFormat) : {};
        var bestOf = (parsedFormat === null || parsedFormat === void 0 ? void 0 : parsedFormat.bestOf) || 1;
        var setsTo = (parsedFormat === null || parsedFormat === void 0 ? void 0 : parsedFormat.setsTo) || 1;
        var maxCountables = considerGames ? bestOf & setsTo : bestOf;
        var countables = ((score === null || score === void 0 ? void 0 : score.sets) && aggregateSets(score.sets)) ||
            (winningSide === 1 && [1, 0]) || [0, 1];
        var winningSideParticipantIds = winningSide
            ? sideParticipantIds[winningSide]
            : [];
        var losingSideParticipantIds = winningSide
            ? sideParticipantIds[3 - winningSide]
            : [];
        try {
            for (var winningSideParticipantIds_1 = (e_2 = void 0, __values(winningSideParticipantIds)), winningSideParticipantIds_1_1 = winningSideParticipantIds_1.next(); !winningSideParticipantIds_1_1.done; winningSideParticipantIds_1_1 = winningSideParticipantIds_1.next()) {
                var winnerParticipantId = winningSideParticipantIds_1_1.value;
                var winnerScaleValue = (_d = scaleItemMap[winnerParticipantId]) === null || _d === void 0 ? void 0 : _d.scaleValue;
                var winnerRating = typeof winnerScaleValue === 'object'
                    ? winnerScaleValue[accessor]
                    : winnerScaleValue;
                try {
                    for (var losingSideParticipantIds_1 = (e_3 = void 0, __values(losingSideParticipantIds)), losingSideParticipantIds_1_1 = losingSideParticipantIds_1.next(); !losingSideParticipantIds_1_1.done; losingSideParticipantIds_1_1 = losingSideParticipantIds_1.next()) {
                        var loserParticipantId = losingSideParticipantIds_1_1.value;
                        var loserScaleValue = (_e = scaleItemMap[loserParticipantId]) === null || _e === void 0 ? void 0 : _e.scaleValue;
                        var loserRating = typeof loserScaleValue === 'object'
                            ? loserScaleValue[accessor]
                            : loserScaleValue;
                        var winnerCountables = winningSide ? countables[winningSide] : [0, 0];
                        var loserCountables = winningSide
                            ? countables[3 - winningSide]
                            : [0, 0];
                        var _m = calculateNewRatings({
                            winnerCountables: winnerCountables,
                            loserCountables: loserCountables,
                            maxCountables: maxCountables,
                            winnerRating: winnerRating,
                            loserRating: loserRating,
                            ratingType: ratingType,
                        }), newWinnerRating = _m.newWinnerRating, newLoserRating = _m.newLoserRating;
                        var newWinnerScaleValue = accessor
                            ? __assign(__assign({}, winnerScaleValue), (_k = {}, _k[accessor] = newWinnerRating, _k)) : newWinnerRating;
                        var newLoserScaleValue = accessor
                            ? __assign(__assign({}, loserScaleValue), (_l = {}, _l[accessor] = newLoserRating, _l)) : newLoserRating;
                        scaleItemMap[winnerParticipantId].scaleValue = newWinnerScaleValue;
                        scaleItemMap[loserParticipantId].scaleValue = newLoserScaleValue;
                        var result = setParticipantScaleItem({
                            participantId: winnerParticipantId,
                            removePriorValues: removePriorValues,
                            tournamentRecord: tournamentRecord,
                            scaleItem: __assign(__assign({}, scaleItemMap[winnerParticipantId]), { scaleName: outputScaleName }),
                        });
                        if (result.error)
                            return { value: result };
                        result = setParticipantScaleItem({
                            participantId: loserParticipantId,
                            removePriorValues: removePriorValues,
                            tournamentRecord: tournamentRecord,
                            scaleItem: __assign(__assign({}, scaleItemMap[loserParticipantId]), { scaleName: outputScaleName }),
                        });
                        if (result.error)
                            return { value: result };
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (losingSideParticipantIds_1_1 && !losingSideParticipantIds_1_1.done && (_j = losingSideParticipantIds_1.return)) _j.call(losingSideParticipantIds_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (winningSideParticipantIds_1_1 && !winningSideParticipantIds_1_1.done && (_h = winningSideParticipantIds_1.return)) _h.call(winningSideParticipantIds_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        Object.assign(modifiedScaleValues, scaleItemMap);
    };
    try {
        for (var matchUps_1 = __values(matchUps), matchUps_1_1 = matchUps_1.next(); !matchUps_1_1.done; matchUps_1_1 = matchUps_1.next()) {
            var matchUp = matchUps_1_1.value;
            var state_1 = _loop_1(matchUp);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (matchUps_1_1 && !matchUps_1_1.done && (_b = matchUps_1.return)) _b.call(matchUps_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var processedMatchUpIds = matchUps.map(function (_a) {
        var matchUpId = _a.matchUpId;
        return matchUpId;
    });
    return __assign(__assign({}, SUCCESS), { modifiedScaleValues: modifiedScaleValues, processedMatchUpIds: processedMatchUpIds });
}

var governor = {
    calculateNewRatings: calculateNewRatings,
    generateDynamicRatings: generateDynamicRatings,
};

var methods = __assign(__assign({}, rankingsGovernor), governor);
engine.importMethods(methods);
var scaleEngine = engine;

var _a$7;
var POLICY_AVOIDANCE_COUNTRY = (_a$7 = {},
    _a$7[POLICY_TYPE_AVOIDANCE] = {
        roundsToSeparate: undefined,
        policyName: 'Nationality Code',
        policyAttributes: [
            { key: 'person.nationalityCode' },
            { key: 'individualParticipants.person.nationalityCode' },
        ],
    },
    _a$7);

var _a$6;
var POLICY_POSITION_ACTIONS_UNRESTRICTED = (_a$6 = {},
    _a$6[POLICY_TYPE_POSITION_ACTIONS] = {
        policyName: 'positionActionsUnrestricted',
        // positionActions will be selectively enabled for structures matching { stages: [], stageSequences: [], structureTypes: [] }
        // enabledStructures: [] => all structures are enabled
        enabledStructures: [],
        // enables entries in other flights to be accessed as alternates
        otherFlightEntries: true,
        // enables entries with multiple qualifying roundTargets to be placed in any round
        disableRoundRestrictions: true,
        // enable specific actions even when there are active positions
        activePositionOverrides: [SEED_VALUE, REMOVE_SEED],
    },
    _a$6);

var _a$5;
var POLICY_POSITION_ACTIONS_NO_MOVEMENT = (_a$5 = {},
    _a$5[POLICY_TYPE_POSITION_ACTIONS] = {
        policyName: 'positionActionsNoMovement',
        // positionActions will be selectively enabled for structures matching { stages: [], stageSequences: [] }
        // enabledStructures: [] => all structures are enabled
        enabledStructures: [
            {
                stages: [], // stages: [] => applies to all stages
                stageSequences: [], // stageSequences: [] => applies to all stageSequences
                enabledActions: [SEED_VALUE, ADD_NICKNAME, ADD_PENALTY],
                disabledActions: [], // disabledActions: [] => no actions are disabled
            },
        ],
    },
    _a$5);

var _a$4;
var POLICY_POSITION_ACTIONS_DISABLED = (_a$4 = {},
    _a$4[POLICY_TYPE_POSITION_ACTIONS] = {
        policyName: 'positionActionsDisabled',
        // positionActions will be selectively enabled for structures matching { stages: [], stageSequences: [], structureTypes: [] }
        // enabledStructures: [] => all structures are enabled
        enabledStructures: false,
    },
    _a$4);

var _a$3;
var POLICY_PRIVACY_DEFAULT = (_a$3 = {},
    _a$3[POLICY_TYPE_PARTICIPANT] = {
        policyName: 'Participant Privacy Policy',
        participant: {
            contacts: false,
            individualParticipants: {
                onlineResources: false,
                participantName: true,
                participantOtherName: true,
                participantId: true,
                participantRole: true,
                participantStatus: true,
                penalties: false,
                representing: true,
                participantRoleResponsibilities: false,
                participantType: true,
                person: {
                    addresses: false,
                    biographicalInformation: false,
                    birthDate: false,
                    contacts: false,
                    nationalityCode: true,
                    nativeFamilyName: false,
                    nativeGivenName: false,
                    onlineResources: false,
                    otherNames: true,
                    parentOrganisationId: false,
                    passportFamilyName: false,
                    passportGivenName: false,
                    personId: false,
                    personOtherIds: false,
                    previousNames: false,
                    sex: false,
                    standardFamilyName: true,
                    standardGivenName: true,
                    status: false,
                    tennisId: false,
                    wheelchair: true,
                },
            },
            individualParticipantIds: true,
            onlineResources: false,
            participantName: true,
            participantOtherName: true,
            participantId: true,
            participantRole: true,
            participantStatus: true,
            penalties: false,
            representing: true,
            participantRoleResponsibilities: false,
            participantType: true,
            person: {
                addresses: false,
                biographicalInformation: false,
                birthDate: false,
                contacts: false,
                nationalityCode: true,
                nativeFamilyName: false,
                nativeGivenName: false,
                onlineResources: false,
                otherNames: true,
                parentOrganisationId: false,
                passportFamilyName: false,
                passportGivenName: false,
                personId: false,
                personOtherIds: false,
                previousNames: false,
                sex: false,
                standardFamilyName: true,
                standardGivenName: true,
                status: false,
                tennisId: false,
                wheelchair: true,
            },
        },
    },
    _a$3);

var _a$2, _b$1;
/**
 * without a SCORING_POLICY which sets { requireAllPositionsAssigned: false },  all stage:MAIN, stageSequence:1 drawPositions must be assigned **BEFORE** scoring is enabled,
 * scoring is enabled in consolation and compass/playoff structures when not all drawPositions have been filled
 */
var POLICY_SCORING_DEFAULT = (_a$2 = {},
    _a$2[POLICY_TYPE_SCORING] = {
        defaultMatchUpFormat: FORMAT_STANDARD,
        allowDeletionWithScoresPresent: {
            drawDefinitions: false,
            structures: false,
        },
        requireAllPositionsAssigned: false,
        processCodes: {
            incompleteAssignmentsOnDefault: ['RANKING.IGNORE'],
        },
        stage: (_b$1 = {},
            _b$1[MAIN] = {
                stageSequence: {
                    1: {
                        requireAllPositionsAssigned: true,
                    },
                },
            },
            _b$1),
    },
    _a$2);

var _a$1, _b;
var POLICY_SCORING_USTA = (_a$1 = {},
    _a$1[POLICY_TYPE_SCORING] = {
        requireAllPositionsAssigned: false,
        stage: (_b = {},
            _b[MAIN] = {
                stageSequence: {
                    1: {
                        requireAllPositionsAssigned: true,
                    },
                },
            },
            _b),
        defaultMatchUpFormat: FORMAT_STANDARD,
        matchUpFormats: [
            {
                description: 'Best of 3 tiebreak sets',
                matchUpFormat: FORMAT_STANDARD,
                categoryNames: [],
                categoryTypes: [],
            },
            {
                description: 'Two tiebreak sets, 7-point match tiebreak at one set all',
                matchUpFormat: 'SET3-S:6/TB7-F:TB7',
            },
            {
                description: 'Two tiebreak sets, 10-point match tiebreak at one set all',
                matchUpFormat: 'SET3-S:6/TB7-F:TB10',
            },
            {
                description: 'One standard tiebreak set to 6, 7-point tiebreak at 6 games all',
                matchUpFormat: 'SET1-S:6/TB7',
            },
            {
                description: 'Best of 3 sets to 4',
                matchUpFormat: 'SET3-S:4/TB7',
            },
            {
                description: 'Two out of three short sets to 4 with 5-point tiebreak at 3 games all',
                matchUpFormat: 'SET3-S:4/TB5@3',
            },
            {
                description: 'One short set to 4, 7-point tiebreak at 4 games all',
                matchUpFormat: 'SET1-S:4/TB7',
            },
            {
                description: 'One short set to 4, 5-point tiebreak at 3 games all',
                matchUpFormat: 'SET1-S:4/TB5@3',
            },
            {
                description: 'Two short sets to 4, 10-point match tiebreak at one set all',
                matchUpFormat: 'SET3-S:4/TB7-F:TB10',
            },
            {
                description: 'Two short sets to 4, 7-point match tiebreak at one set all',
                matchUpFormat: 'SET3-S:4/TB7-F:TB7',
            },
            {
                description: 'One no advantage set to 5, tiebreak to 9 at 4-4',
                matchUpFormat: 'SET1-S:5/TB9@4',
            },
            {
                description: 'One set to 6 with deciding game at 5 games all',
                matchUpFormat: 'SET1-S:6NOAD',
            },
            {
                description: 'One short set to 4, deciding game is played at 3 games all',
                matchUpFormat: 'SET1-S:4NOAD',
            },
            {
                description: 'Two short sets to 4 with deciding game at 3-3, 7-point match tiebreak at one set all',
                matchUpFormat: 'SET3-S:4NOAD-F:TB7',
            },
            {
                description: '8 game pro-set with 7 point tiebreak at 8 games all',
                matchUpFormat: 'SET1-S:8/TB7',
            },
            {
                description: '8 game pro-set with 7 point tiebreak at 7 games all',
                matchUpFormat: 'SET1-S:8/TB7@7',
            },
            {
                description: 'Best of 3 10-point tiebreak games',
                matchUpFormat: 'SET3-S:TB10',
            },
            {
                description: 'One 10-point tiebreak game',
                matchUpFormat: 'SET1-S:TB10',
            },
            {
                description: 'Timed 20 minute game - game based',
                matchUpFormat: 'SET1-S:T20',
            },
        ],
    },
    _a$1);

var _a;
var POLICY_SEEDING_ITF = (_a = {},
    _a[POLICY_TYPE_SEEDING] = {
        seedingProfile: { positioning: CLUSTER },
        validSeedPositions: { ignore: true },
        duplicateSeedNumbers: true,
        drawSizeProgression: true,
        policyName: 'ITF SEEDING',
        seedsCountThresholds: [
            { drawSize: 4, minimumParticipantCount: 3, seedsCount: 2 },
            { drawSize: 16, minimumParticipantCount: 12, seedsCount: 4 },
            { drawSize: 32, minimumParticipantCount: 24, seedsCount: 8 },
            { drawSize: 64, minimumParticipantCount: 48, seedsCount: 16 },
            { drawSize: 128, minimumParticipantCount: 97, seedsCount: 32 },
            { drawSize: 256, minimumParticipantCount: 192, seedsCount: 64 },
        ],
    },
    _a);

var policies = {
    POLICY_AVOIDANCE_COUNTRY: POLICY_AVOIDANCE_COUNTRY,
    POLICY_POSITION_ACTIONS_DEFAULT: POLICY_POSITION_ACTIONS_DEFAULT,
    POLICY_POSITION_ACTIONS_DISABLED: POLICY_POSITION_ACTIONS_DISABLED,
    POLICY_POSITION_ACTIONS_NO_MOVEMENT: POLICY_POSITION_ACTIONS_NO_MOVEMENT,
    POLICY_POSITION_ACTIONS_UNRESTRICTED: POLICY_POSITION_ACTIONS_UNRESTRICTED,
    POLICY_PRIVACY_DEFAULT: POLICY_PRIVACY_DEFAULT,
    POLICY_ROUND_NAMING_DEFAULT: POLICY_ROUND_NAMING_DEFAULT,
    POLICY_SCHEDULING_DEFAULT: POLICY_SCHEDULING_DEFAULT,
    POLICY_SCORING_DEFAULT: POLICY_SCORING_DEFAULT,
    POLICY_SCORING_USTA: POLICY_SCORING_USTA,
    POLICY_SEEDING_ITF: POLICY_SEEDING_ITF,
    POLICY_SEEDING_DEFAULT: POLICY_SEEDING_DEFAULT,
};

var fixtures = {
    ratingsParameters: ratingsParameters,
    matchUpFormats: matchUpFormats,
    countryToFlag: countryToFlag,
    tieFormats: tieFormats,
    countries: countries,
    policies: policies,
    flagIOC: flagIOC,
};

var COACHING = 'Coaching';
var BALL_ABUSE = 'Ball Abuse';
var RACKET_ABUSE = 'Racket Abuse';
var VERBAL_ABUSE = 'Verbal Abuse';
var INELIGIBILITY = 'INELIGIBILITY';
var PHYSICAL_ABUSE = 'Physical Abuse';
var UNSPORTSMANLIKE_CONDUCT = 'Unsportmanlike Conduct';
var DRESS_CODE_VIOLATION = 'Dress Code Violation';
var EQUIMENT_VIOLATION = 'Equipment Violation';
var LEAVING_THE_COURT = 'Leaving the court';
var FAILURE_TO_COMPLETE = 'Failure to complete';
var NO_SHOW = 'No Show';
var OTHER = 'Other';
var REFUSAL_TO_PLAY = 'REFUSAL_TO_PLAY';
var PROHIBITED_SUBSTANCE = 'PROHIBITED_SUBSTANCE';
var PUNCTUALITY = 'Puncuality';
var FAILUIRE_TO_SIGN_IN = 'Failure to sign in';
var penaltyConstants = {
    COACHING: COACHING,
    BALL_ABUSE: BALL_ABUSE,
    RACKET_ABUSE: RACKET_ABUSE,
    VERBAL_ABUSE: VERBAL_ABUSE,
    PHYSICAL_ABUSE: PHYSICAL_ABUSE,
    INELIGIBILITY: INELIGIBILITY,
    UNSPORTSMANLIKE_CONDUCT: UNSPORTSMANLIKE_CONDUCT,
    PROHIBITED_SUBSTANCE: PROHIBITED_SUBSTANCE,
    DRESS_CODE_VIOLATION: DRESS_CODE_VIOLATION,
    EQUIMENT_VIOLATION: EQUIMENT_VIOLATION,
    LEAVING_THE_COURT: LEAVING_THE_COURT,
    REFUSAL_TO_PLAY: REFUSAL_TO_PLAY,
    FAILURE_TO_COMPLETE: FAILURE_TO_COMPLETE,
    NO_SHOW: NO_SHOW,
    OTHER: OTHER,
    PUNCTUALITY: PUNCTUALITY,
    FAILUIRE_TO_SIGN_IN: FAILUIRE_TO_SIGN_IN,
};

var CLAY = 'CLAY';
var HARD = 'HARD';
var GRASS = 'GRASS';
var CARPET = 'CARPET';
var ARTIFICIAL = 'ARTIFICIAL';
var surfaceConstants = {
    CLAY: CLAY,
    HARD: HARD,
    GRASS: GRASS,
    CARPET: CARPET,
    ARTIFICIAL: ARTIFICIAL,
};

var INDOOR = 'INDOOR';
var OUTDOOR = 'OUTDOOR';
var venueConstants = {
    INDOOR: INDOOR,
    OUTDOOR: OUTDOOR,
};

var factoryConstants = {
    activeMatchUpStatuses: activeMatchUpStatuses,
    auditConstants: auditConstants,
    completedMatchUpStatuses: completedMatchUpStatuses,
    directingMatchUpStatuses: directingMatchUpStatuses,
    drawDefinitionConstants: drawDefinitionConstants,
    entryStatusConstants: entryStatusConstants,
    errorConditionConstants: errorConditionConstants,
    eventConstants: eventConstants,
    extensionConstants: extensionConstants,
    flightConstants: flightConstants,
    genderConstants: genderConstants,
    keyValueConstants: keyValueConstants,
    matchUpActionConstants: matchUpActionConstants,
    matchUpStatusConstants: matchUpStatusConstants,
    matchUpTypes: matchUpTypes,
    nonDirectingMatchUpStatuses: nonDirectingMatchUpStatuses,
    participantConstants: participantConstants,
    participantRoles: participantRoles,
    particicipantsRequiredMatchUpStatuses: particicipantsRequiredMatchUpStatuses,
    participantTypes: participantTypes,
    penaltyConstants: penaltyConstants,
    policyConstants: policyConstants,
    positionActionConstants: positionActionConstants,
    ratingConstants: ratingConstants,
    recoveryTimeRequiredMatchUpStatuses: recoveryTimeRequiredMatchUpStatuses,
    requestConstants: requestConstants,
    resultConstants: resultConstants,
    scaleConstants: scaleConstants,
    scheduleConstants: scheduleConstants,
    sortingConstants: sortingConstants,
    surfaceConstants: surfaceConstants,
    tieFormatConstants: tieFormatConstants,
    timeItemConstants: timeItemConstants,
    topicConstants: topicConstants,
    tournamentConstants: tournamentConstants,
    upcomingMatchUpStatuses: upcomingMatchUpStatuses,
    validMatchUpStatuses: validMatchUpStatuses,
    venueConstants: venueConstants,
};

exports.askEngine = askEngine;
exports.asyncEngine = asyncEngine;
exports.competitionEngine = competitionEngine;
exports.drawDefinitionConstants = drawDefinitionConstants;
exports.entryStatusConstants = entryStatusConstants;
exports.errorConditionConstants = errorConditionConstants;
exports.eventConstants = eventConstants;
exports.factoryConstants = factoryConstants;
exports.fixtures = fixtures;
exports.flightConstants = flightConstants;
exports.forge = forge;
exports.genderConstants = genderConstants;
exports.globalState = globalState$1;
exports.governors = governors;
exports.keyValueConstants = keyValueConstants;
exports.matchUpActionConstants = matchUpActionConstants;
exports.matchUpEngine = matchUpEngine;
exports.matchUpFormatCode = matchUpFormatCode;
exports.matchUpStatusConstants = matchUpStatusConstants;
exports.matchUpTypes = matchUpTypes;
exports.mocksEngine = mocksEngine;
exports.participantConstants = participantConstants;
exports.participantRoles = participantRoles;
exports.participantTypes = participantTypes;
exports.penaltyConstants = penaltyConstants;
exports.policyConstants = policyConstants;
exports.positionActionConstants = positionActionConstants;
exports.resultConstants = resultConstants;
exports.scaleConstants = scaleConstants;
exports.scaleEngine = scaleEngine;
exports.surfaceConstants = surfaceConstants;
exports.syncEngine = engine;
exports.timeItemConstants = timeItemConstants;
exports.tournamentEngine = tournamentEngine;
exports.utilities = utilities;
exports.venueConstants = venueConstants;
exports.version = factoryVersion;
//# sourceMappingURL=tods-competition-factory.development.cjs.js.map
