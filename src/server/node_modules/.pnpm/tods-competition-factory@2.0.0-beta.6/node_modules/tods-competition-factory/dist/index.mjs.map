{"version":3,"file":"index.mjs","sources":["../src/global/functions/factoryVersion.ts","../src/utilities/sorting.ts","../src/utilities/ensureInt.ts","../src/utilities/math.ts","../src/utilities/arrays.ts","../src/constants/resultConstants.ts","../src/constants/errorConditionConstants.ts","../src/global/state/syncGlobalState.ts","../src/global/state/globalState.ts","../src/utilities/definedAttributes.ts","../src/global/functions/decorateResult.ts","../src/constants/infoConstants.ts","../src/mutate/extensions/removeExtension.ts","../src/validators/isValidExtension.ts","../src/mutate/extensions/addExtension.ts","../src/acquire/findExtension.ts","../src/validators/regex.ts","../src/utilities/dateTime.ts","../src/utilities/makeDeepCopy.ts","../src/utilities/getAccessorValue.ts","../src/utilities/objects.ts","../src/constants/attributeConstants.ts","../src/parameters/checkRequiredParameters.ts","../src/constants/scaleConstants.ts","../src/query/participant/getScaleValues.ts","../src/utilities/attributeFilter.ts","../src/constants/policyConstants.ts","../src/acquire/findParticipant.ts","../src/mutate/extensions/addRemoveExtensions.ts","../src/constants/extensionConstants.ts","../src/query/tournaments/getTournamentIds.ts","../src/assemblies/governors/competitionGovernor/index.ts","../src/mutate/tournaments/tournamentLinks.ts","../src/global/functions/extractors.ts","../src/constants/matchUpStatusConstants.ts","../src/constants/drawDefinitionConstants.ts","../src/functions/sorters/structureSort.ts","../src/acquire/findStructure.ts","../src/query/drawDefinition/positionsGetter.ts","../src/constants/participantConstants.ts","../src/mutate/drawDefinitions/positionGovernor/avoidance/addParticipantGroupings.ts","../src/fixtures/countryData.ts","../src/mutate/participants/addNationalityCode.ts","../src/acquire/findTournamentParticipant.ts","../src/query/base/timeItems.ts","../src/constants/matchUpTypes.ts","../src/query/participants/getParticipantMap.ts","../src/mutate/participants/addIndividualParticipants.ts","../src/query/participants/hydrateParticipants.ts","../src/query/matchUps/reduceGroupedOrder.ts","../src/query/matchUps/getTargetMatchUp.ts","../src/query/drawDefinition/linkGetter.ts","../src/mutate/matchUps/drawPositions/positionTargets.ts","../src/query/matchUps/getNextRoundMatchUp.ts","../src/validators/validMatchUp.ts","../src/query/matchUps/getRoundMatchUps.ts","../src/mutate/drawDefinitions/matchUpGovernor/addUpcomingMatchUps.ts","../src/query/extensions/getAppliedPolicies.ts","../src/constants/statsConstants.ts","../src/fixtures/policies/POLICY_COMPETITIVE_BANDS_DEFAULT.ts","../src/query/hierarchical/getContextContent.ts","../src/query/drawDefinition/getExitProfile.ts","../src/query/matchUps/getMatchUpsMap.ts","../src/mutate/events/getCollectionPositionAssignments.ts","../src/query/participant/getPairedParticipant.ts","../src/mutate/drawDefinitions/getTeamLineUp.ts","../src/mutate/drawDefinitions/entryGovernor/modifyEntryProfile.ts","../src/query/drawDefinition/getEntryProfile.ts","../src/constants/entryStatusConstants.ts","../src/query/drawDefinition/stageGetter.ts","../src/query/structure/getStructureSeedAssignments.ts","../src/query/matchUp/scoreComponents.ts","../src/acquire/findPolicy.ts","../src/query/matchUp/getMatchUpCompetitiveProfile.ts","../src/query/matchUp/getMatchUpParticipantIds.ts","../src/constants/timeItemConstants.ts","../src/query/matchUp/getCheckedInParticipantIds.ts","../src/acquire/findMatchUpFormatTimes.ts","../src/acquire/findCategoryTiming.ts","../src/query/extensions/matchUpFormatTiming/getScheduleTiming.ts","../src/constants/eventConstants.ts","../src/constants/scheduleConstants.ts","../src/query/extensions/matchUpFormatTiming/getMatchUpFormatTiming.ts","../src/query/extensions/matchUpFormatTiming/getMatchUpFormatAverageTimes.ts","../src/query/extensions/matchUpFormatTiming/getMatchUpFormatRecoveryTimes.ts","../src/query/matchUp/latestVisibleTimeItemValue.ts","../src/query/matchUp/scheduledMatchUpTime.ts","../src/query/matchUp/scheduledMatchUpDate.ts","../src/query/matchUp/courtAllocations.ts","../src/query/matchUp/courtAssignment.ts","../src/query/matchUp/venueAssignment.ts","../src/query/tournaments/getLinkedTournamentIds.ts","../src/parameters/resolveTournamentRecords.ts","../src/utilities/UUID.ts","../src/constants/topicConstants.ts","../src/mutate/venues/addVenue.ts","../src/mutate/venues/findVenue.ts","../src/mutate/venues/findCourt.ts","../src/query/venues/getCourtInfo.ts","../src/query/venues/getVenueData.ts","../src/query/matchUp/timeModifiers.ts","../src/query/matchUp/matchUpDuration.ts","../src/query/event/getFlightProfile.ts","../src/acquire/findEvent.ts","../src/query/matchUp/getMatchUpScheduleDetails.ts","../src/query/matchUp/startTime.ts","../src/query/matchUp/endTime.ts","../src/query/matchUp/courtOrder.ts","../src/query/hierarchical/tieFormats/getObjectTieFormat.ts","../src/query/hierarchical/tieFormats/getItemTieFormat.ts","../src/query/hierarchical/tieFormats/resolveTieFormat.ts","../src/query/matchUps/getRangeString.ts","../src/constants/matchUpFormatConstants.ts","../src/assemblies/generators/matchUpFormatCode/parse.ts","../src/query/drawDefinition/isLucky.ts","../src/query/drawDefinition/isAdHoc.ts","../src/fixtures/policies/POLICY_ROUND_NAMING_DEFAULT.ts","../src/query/matchUp/getMatchUpType.ts","../src/query/filterMatchUps.ts","../src/query/matchUps/getSide.ts","../src/constants/genderConstants.ts","../src/query/matchUps/getAllStructureMatchUps.ts","../src/query/matchUps/getRoundContextProfile.ts","../src/query/matchUps/getSourceDrawPositionRanges.ts","../src/query/matchUps/getDrawPositionsRanges.ts","../src/query/matchUps/getCollectionPositionMatchUps.ts","../src/query/matchUps/getCollectionAssignment.ts","../src/query/matchUps/getOrderedDrawPositions.ts","../src/query/matchUp/checkMatchUpIsComplete.ts","../src/query/structure/getStructureMatchUps.ts","../src/query/matchUps/drawMatchUps.ts","../src/query/matchUps/getAllDrawMatchUps.ts","../src/query/structure/getStructureRoundProfile.ts","../src/mutate/drawDefinitions/structureGovernor/structureUtils.ts","../src/mutate/drawDefinitions/structureGovernor/getPositionsPlayedOff.ts","../src/mutate/drawDefinitions/structureGovernor/getSourceRounds.ts","../src/mutate/drawDefinitions/structureGovernor/getAvailablePlayoffProfiles.ts","../src/mutate/notifications/drawNotifications.ts","../src/mutate/drawDefinitions/positionGovernor/conditionallyDisableLinkPositioning.ts","../src/mutate/drawDefinitions/positionGovernor/addPositionActionTelemetry.ts","../src/query/drawDefinition/getContainedStructures.ts","../src/query/matchUp/checkScoreHasValue.ts","../src/mutate/drawDefinitions/matchUpGovernor/checkStatusType.ts","../src/tests/queries/matchUps/activeMatchUp.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/getIndividualParticipantIds.ts","../src/assemblies/generators/drawDefinitions/addFinishingRounds.ts","../src/mutate/drawDefinitions/matchUpGovernor/addGoesTo.ts","../src/query/matchUps/getAllEventMatchUps.ts","../src/query/matchUps/getAllTournamentMatchUps.ts","../src/query/matchUps/getAllCompetitionMatchUps.ts","../src/functions/sorters/matchUpSort.ts","../src/query/matchUps/getMatchUpDependencies.ts","../src/query/structure/getStructureDrawPositionProfiles.ts","../src/query/matchUps/getInitialRoundNumber.ts","../src/global/functions/logColors.ts","../src/global/functions/globalLog.ts","../src/mutate/matchUps/drawPositions/assignDrawPositionBye.ts","../src/mutate/matchUps/matchUpStatus/modifyRoundRobinMatchUpsStatus.ts","../src/mutate/matchUps/drawPositions/positionClear.ts","../src/query/drawDefinition/getAssignedParticipantIds.ts","../src/mutate/entries/refreshEntryPositions.ts","../src/query/entries/isUngrouped.ts","../src/mutate/entries/modifyEntriesStatus.ts","../src/mutate/participants/addScheduleItem.ts","../src/query/participant/participantScaleItem.ts","../src/query/event/getEventSeedAssignments.ts","../src/query/event/getEventPublishStatus.ts","../src/query/event/getDrawPublishStatus.ts","../src/query/events/getPublishState.ts","../src/query/participant/processEventEntry.ts","../src/functions/sorters/stringSort.ts","../src/mutate/participants/addStructureParticipation.ts","../src/query/matchUps/processSides.ts","../src/query/participants/filterParticipants.ts","../src/query/participants/getParticipants.ts","../src/query/participants/getParticipantEntries.ts","../src/query/drawDefinition/entryGetter.ts","../src/query/drawDefinition/getQualifiersCount.ts","../src/query/drawDefinition/getStageDrawPositions.ts","../src/query/drawDefinition/getValidStage.ts","../src/query/drawDefinition/getStageSpace.ts","../src/mutate/drawDefinitions/entryGovernor/addDrawEntries.ts","../src/mutate/drawDefinitions/addDrawEntries.ts","../src/mutate/entries/removeEventEntries.ts","../src/fixtures/policies/POLICY_MATCHUP_ACTIONS_DEFAULT.ts","../src/mutate/entries/addEventEntries.ts","../src/constants/participantRoles.ts","../src/mutate/participants/removeIndividualParticipantIds.ts","../src/mutate/participants/deleteParticipants.ts","../src/query/drawDefinition/getStageEntries.ts","../src/mutate/entries/destroyGroupEntry.ts","../src/mutate/entries/destroyPairEntry.ts","../src/mutate/drawDefinitions/removeDrawPositionAssignment.ts","../src/utilities/strings.ts","../src/assemblies/generators/templates/structureTemplate.ts","../src/mutate/drawDefinitions/addVoluntaryConsolationStructure.ts","../src/query/structure/getPositionAssignments.ts","../src/query/matchUps/scheduling/getUpdatedSchedulingProfile.ts","../src/validators/validateSchedulingProfile.ts","../src/query/venues/getInContextCourt.ts","../src/query/extensions/getDisabledStatus.ts","../src/query/venues/venuesAndCourtsGetter.ts","../src/query/tournaments/getEventIdsAndDrawIds.ts","../src/mutate/tournaments/schedulingProfile.ts","../src/mutate/timeItems/addTimeItem.ts","../src/mutate/events/modifyEventPublishStatus.ts","../src/query/tournaments/getTournamentInfo.ts","../src/query/structure/getStructureGroups.ts","../src/query/drawDefinition/getDrawData.ts","../src/query/event/getEventData.ts","../src/mutate/events/publishEvent.ts","../src/constants/auditConstants.ts","../src/mutate/events/deleteDrawDefinitions.ts","../src/query/matchUps/getMatchUpFromMatchUps.ts","../src/acquire/findDrawMatchUp.ts","../src/mutate/drawDefinitions/positionGovernor/getPairedPreviousMatchUpIsDoubleExit.ts","../src/mutate/drawDefinitions/positionGovernor/getPairedPreviousMatchup.ts","../src/mutate/drawDefinitions/matchUpGovernor/matchUpStatusCodes.ts","../src/mutate/drawDefinitions/matchUpGovernor/getExitWinningSide.ts","../src/mutate/matchUps/lineUps/updateSideLineUp.ts","../src/mutate/matchUps/drawPositions/assignMatchUpDrawPosition.ts","../src/mutate/drawDefinitions/matchUpGovernor/getUpdatedDrawPositions.ts","../src/assemblies/generators/drawDefinitions/drawTypes/roundRobin/roundRobinGroups.ts","../src/assemblies/generators/drawDefinitions/drawTypes/roundRobin/roundRobin.ts","../src/mutate/drawDefinitions/positionGovernor/getSeedBlocks.ts","../src/query/drawDefinition/getNumericSeedValue.ts","../src/assemblies/generators/drawDefinitions/generateBlockPattern.ts","../src/query/drawDefinition/seedGetter.ts","../src/mutate/drawDefinitions/entryGovernor/seedAssignment.ts","../src/mutate/drawDefinitions/positionGovernor/getTargetMatchUps.ts","../src/mutate/drawDefinitions/removeLineUpSubstitutions.ts","../src/utilities/mustBeAnArray.ts","../src/validators/validateTeamLineUp.ts","../src/mutate/drawDefinitions/updateTeamLineUp.ts","../src/mutate/matchUps/lineUps/resetLineUps.ts","../src/mutate/matchUps/drawPositions/positionAssignment.ts","../src/mutate/matchUps/drawPositions/positionParticipantAction.ts","../src/acquire/findMatchUp.ts","../src/parameters/resolveFromParameters.ts","../src/mutate/matchUps/timeItems/matchUpTimeItems.ts","../src/mutate/matchUps/timeItems/checkOutParticipant.ts","../src/mutate/matchUps/timeItems/checkInParticipant.ts","../src/mutate/matchUps/timeItems/toggleParticipantCheckInState.ts","../src/mutate/events/getTieMatchUpContext.ts","../src/mutate/participants/addParticipant.ts","../src/mutate/matchUps/lineUps/ensureSideLineUps.ts","../src/mutate/matchUps/lineUps/replaceTieMatchUpParticipant.ts","../src/mutate/events/removeCollectionAssignments.ts","../src/mutate/participants/addIndividualParticipantIds.ts","../src/mutate/participants/updateTeamEventEntries.ts","../src/mutate/participants/modifyParticipant.ts","../src/mutate/matchUps/lineUps/assignTieMatchUpParticipant.ts","../src/validators/validateCollectionValueProfiles.ts","../src/query/hierarchical/tieFormats/copyTieFormat.ts","../src/assemblies/generators/drawDefinitions/getGroupValueGroups.ts","../src/query/matchUp/calculateWinCriteria.ts","../src/query/hierarchical/tieFormats/getTieFormat.ts","../src/assemblies/generators/matchUpFormatCode/stringify.ts","../src/validators/isValidMatchUpFormat.ts","../src/validators/tieFormatGenderValidityCheck.ts","../src/query/event/getCategoryAgeDetails.ts","../src/validators/validateCategory.ts","../src/query/event/categoryCanContain.ts","../src/assemblies/governors/matchUpFormatGovernor/index.ts","../src/validators/validateCollectionDefinition.ts","../src/validators/validateTieFormat.ts","../src/assemblies/generators/drawDefinitions/tieMatchUps.ts","../src/query/hierarchical/tieFormats/getTieFormatDescription.ts","../src/query/hierarchical/tieFormats/compareTieFormats.ts","../src/validators/validUpdate.ts","../src/mutate/tieFormat/updateTieFormat.ts","../src/mutate/matchUps/tieFormat/tieFormatTelemetry.ts","../src/mutate/matchUps/tieFormat/modifyCollectionDefinition.ts","../src/mutate/matchUps/drawPositions/positionSwap.ts","../src/query/structure/structureGetter.ts","../src/query/drawDefinition/structureActions.ts","../src/query/drawDefinition/processAccessors.ts","../src/query/participants/getAttributeGrouping.ts","../src/mutate/drawDefinitions/positionGovernor/avoidance/getPositionedParticipants.ts","../src/mutate/drawDefinitions/positionGovernor/avoidance/analyzeDrawPositions.ts","../src/mutate/drawDefinitions/positionGovernor/avoidance/organizeDrawPositionOptions.ts","../src/mutate/drawDefinitions/positionGovernor/avoidance/getUnplacedParticipantIds.ts","../src/mutate/drawDefinitions/positionGovernor/avoidance/getParticipantPlacement.ts","../src/mutate/drawDefinitions/positionGovernor/avoidance/getUnfilledPositions.ts","../src/mutate/drawDefinitions/positionGovernor/avoidance/getNextParticipantId.ts","../src/mutate/drawDefinitions/positionGovernor/avoidance/getAvoidanceConflicts.ts","../src/mutate/drawDefinitions/positionGovernor/avoidance/getSwapOptions.ts","../src/mutate/drawDefinitions/positionGovernor/avoidance/generatePositioningCandidate.ts","../src/mutate/drawDefinitions/positionGovernor/avoidance/randomUnseededSeparation.ts","../src/mutate/matchUps/drawPositions/positionUnseededParticipants.ts","../src/mutate/matchUps/drawPositions/positionQualifiers.ts","../src/mutate/drawDefinitions/positionGovernor/byePositioning/getBlockSortedRandomDrawPositions.ts","../src/mutate/drawDefinitions/positionGovernor/byePositioning/getSeedOrderedByePositions.ts","../src/query/structure/getStructurePositionedSeeds.ts","../src/mutate/drawDefinitions/positionGovernor/byePositioning/positionByes.ts","../src/query/drawDefinition/getByesData.ts","../src/mutate/drawDefinitions/positionGovernor/byePositioning/getUnseededByePositions.ts","../src/mutate/matchUps/drawPositions/positionSeeds.ts","../src/mutate/drawDefinitions/automatedPositioning.ts","../src/mutate/drawDefinitions/automatedPlayoffPositioning.ts","../src/mutate/drawDefinitions/structureGovernor/resequenceStructures.ts","../src/mutate/drawDefinitions/attachQualifyingStructure.ts","../src/fixtures/scoring/matchUpFormats/index.ts","../src/query/matchUps/roundRobinTally/scoreCounters.ts","../src/query/matchUps/roundRobinTally/getParticipantResults.ts","../src/query/matchUps/roundRobinTally/calculatePercentages.ts","../src/query/matchUps/roundRobinTally/getGroups.ts","../src/query/matchUps/roundRobinTally/getGroupOrder.ts","../src/query/matchUps/roundRobinTally/roundRobinTally.ts","../src/query/matchUps/roundRobinTally/getTallyReport.ts","../src/assemblies/generators/tieMatchUpScore/evaluateCollectionResult.ts","../src/assemblies/generators/tieMatchUpScore/generateTieMatchUpScore.ts","../src/fixtures/scoring/outcomes/toBePlayed.ts","../src/mutate/matchUps/drawPositions/removeSubsequentRoundsParticipant.ts","../src/acquire/findTournamentId.ts","../src/mutate/drawDefinitions/matchUpGovernor/updateAssignmentParticipantResults.ts","../src/mutate/drawDefinitions/matchUpGovernor/createSubOrderMap.ts","../src/mutate/base/addRemoveNotes.ts","../src/mutate/matchUps/score/modifyMatchUpScore.ts","../src/mutate/matchUps/score/tieMatchUpScore.ts","../src/mutate/matchUps/drawPositions/removeDirectedParticipants.ts","../src/mutate/drawDefinitions/matchUpGovernor/includesMatchUpStatuses.ts","../src/mutate/drawDefinitions/positionGovernor/doubleExitAdvancement.ts","../src/mutate/drawDefinitions/matchUpGovernor/attemptToSetMatchUpStatus.ts","../src/mutate/matchUps/matchUpStatus/attemptToSetMatchUpStatusBYE.ts","../src/mutate/drawDefinitions/matchUpGovernor/checkConnectedStructures.ts","../src/mutate/drawDefinitions/matchUpGovernor/getAffectedTargetStructureIds.ts","../src/mutate/drawDefinitions/matchUpGovernor/attemptToModifyScore.ts","../src/mutate/matchUps/drawPositions/directParticipants.ts","../src/mutate/matchUps/drawPositions/directWinner.ts","../src/mutate/matchUps/drawPositions/directLoser.ts","../src/mutate/drawDefinitions/matchUpGovernor/isActiveDownstream.ts","../src/mutate/drawDefinitions/matchUpGovernor/attemptToSetWinningSide.ts","../src/mutate/drawDefinitions/matchUpGovernor/replaceQualifier.ts","../src/mutate/drawDefinitions/matchUpGovernor/placeQualifier.ts","../src/mutate/drawDefinitions/matchUpGovernor/removeDoubleExit.ts","../src/mutate/drawDefinitions/matchUpGovernor/noDownstreamDependencies.ts","../src/assemblies/generators/matchUpFormatCode/lastSetFormatisTimed.ts","../src/mutate/drawDefinitions/matchUpGovernor/removeQualifier.ts","../src/mutate/matchUps/schedule/allocateTeamMatchUpCourts.ts","../src/mutate/matchUps/schedule/assignMatchUpVenue.ts","../src/mutate/matchUps/schedule/assignMatchUpCourt.ts","../src/mutate/matchUps/schedule/scheduledTime.ts","../src/mutate/matchUps/schedule/scheduleItems.ts","../src/validators/validateScore.ts","../src/query/matchUp/analyzeScore.ts","../src/mutate/matchUps/matchUpStatus/setMatchUpState.ts","../src/mutate/drawDefinitions/matchUpGovernor/getProjectedDualWinningSide.ts","../src/mutate/matchUps/drawPositions/swapWinnerLoser.ts","../src/mutate/drawDefinitions/updateDrawIdsOrder.ts","../src/mutate/drawDefinitions/refreshEventDrawOrder.ts","../src/mutate/drawDefinitions/addDrawDefinitionTimeItem.ts","../src/mutate/drawDefinitions/entryGovernor/stageEntryCounts.ts","../src/mutate/matchUps/tieFormat/collectionGroupUpdate.ts","../src/query/hierarchical/tieFormats/getTargetTeamMatchUps.ts","../src/mutate/tieFormat/updateTargetTeamMatchUps.ts","../src/mutate/tieFormat/orderCollectionDefinitions.ts","../src/mutate/tieFormat/removeCollectionDefinition.ts","../src/assemblies/generators/drawDefinitions/links/generateQualifyingLink.ts","../src/assemblies/generators/drawDefinitions/generateMatchUpId.ts","../src/assemblies/generators/drawDefinitions/buildRound.ts","../src/assemblies/generators/drawDefinitions/drawTypes/eliminationTree.ts","../src/assemblies/generators/drawDefinitions/drawTypes/generateQualifyingStructure.ts","../src/mutate/matchUps/matchUpFormat/setMatchUpMatchUpFormat.ts","../src/assemblies/generators/drawDefinitions/buildFeedRound.ts","../src/assemblies/generators/drawDefinitions/feedInMatchUps.ts","../src/assemblies/generators/drawDefinitions/drawTypes/playoffStructures.ts","../src/assemblies/generators/drawDefinitions/drawTypes/firstRoundLoserConsolation.ts","../src/assemblies/generators/drawDefinitions/links/feedInLinks.ts","../src/assemblies/generators/drawDefinitions/drawTypes/curtisConsolation.ts","../src/assemblies/generators/drawDefinitions/drawTypes/feedInChamp.ts","../src/assemblies/generators/drawDefinitions/drawTypes/processPlayoffGroups.ts","../src/mutate/drawDefinitions/structureGovernor/getPositionRangeMap.ts","../src/assemblies/generators/drawDefinitions/generateAndPopulatePlayoffStructures.ts","../src/assemblies/generators/drawDefinitions/generateAndPopulateRRplayoffStructures.ts","../src/mutate/drawDefinitions/attachStructures.ts","../src/mutate/drawDefinitions/addPlayoffStructures.ts","../src/assemblies/generators/matchUps/generateScoreString.ts","../src/assemblies/generators/matchUps/matchUpScore.ts","../src/mutate/matchUps/matchUpStatus/setMatchUpStatus.ts","../src/mutate/tieFormat/addCollectionDefinition.ts","../src/mutate/extensions/policies/attachPolicies.ts","../src/mutate/drawDefinitions/modifyDrawName.ts","../src/mutate/events/bulkMatchUpStatusUpdate.ts","../src/query/tournaments/analyzeDraws.ts","../src/mutate/drawDefinitions/addDrawDefinition.ts","../src/mutate/participants/addParticipants.ts","../src/assemblies/generators/drawDefinitions/generateAdHocMatchUps.ts","../src/assemblies/generators/drawDefinitions/drawMatic/generateCandidate.ts","../src/assemblies/generators/drawDefinitions/drawMatic/getPairingsData.ts","../src/constants/ratingConstants.ts","../src/fixtures/ratings/ratingsParameters.ts","../src/assemblies/generators/drawDefinitions/drawMatic/getSideRatings.ts","../src/assemblies/generators/drawDefinitions/drawMatic/getPairings.ts","../src/assemblies/generators/drawDefinitions/drawMatic/getParticipantPairingValues.ts","../src/assemblies/generators/drawDefinitions/drawMatic/generateDrawMaticRound.ts","../src/assemblies/generators/drawDefinitions/drawMatic/getEncounters.ts","../src/assemblies/generators/drawDefinitions/drawMatic/drawMatic.ts","../src/mutate/structures/addAdHocMatchUps.ts","../src/mutate/events/attachFlightProfile.ts","../src/mutate/entries/removeScaleValues.ts","../src/mutate/participants/removeScaleItems.ts","../src/mutate/tieFormat/resetTieFormat.ts","../src/query/participants/getEliminationDrawSize.ts","../src/query/drawDefinition/getSeedsCount.ts","../src/query/entries/getEntriesAndSeedsCount.ts","../src/assemblies/generators/drawDefinitions/generateSeedingScaleItems.ts","../src/query/participant/getParticipantScaleItem.ts","../src/query/event/getScaledEntries.ts","../src/mutate/events/addFlight.ts","../src/constants/tieFormatConstants.ts","../src/assemblies/generators/templates/tieFormatDefaults.ts","../src/fixtures/scoring/tieFormats/index.ts","../src/mutate/events/addEvent.ts","../src/mutate/entries/promoteAlternate.ts","../src/mutate/entries/setEntryPositions.ts","../src/mutate/events/setEventDates.ts","../src/assemblies/governors/eventGovernor/index.ts","../src/mutate/matchUps/tieFormat/addCollectionGroup.ts","../src/mutate/entries/addEventEntryPairs.ts","../src/mutate/drawDefinitions/addQualifyingStructure.ts","../src/mutate/events/addVoluntaryConsolationStage.ts","../src/mutate/drawDefinitions/addVoluntaryConsolationStage.ts","../src/mutate/tieFormat/aggregateTieFormats.ts","../src/mutate/drawDefinitions/alternateDrawPositionAssignment.ts","../src/mutate/matchUps/drawPositions/positionAlternate.ts","../src/mutate/matchUps/lineUps/applyLineUps.ts","../src/mutate/drawDefinitions/assignDrawPosition.ts","../src/mutate/matchUps/drawPositions/assignMatchUpSideParticipant.ts","../src/mutate/events/assignSeedPositions.ts","../src/mutate/entries/autoSeeding.ts","../src/mutate/structures/deleteAdHocMatchUps.ts","../src/mutate/events/deleteEvent.ts","../src/mutate/drawDefinitions/deleteFlightAndFlightDraw.ts","../src/mutate/drawDefinitions/deleteFlightProfileAndFlightDraws.ts","../src/mutate/matchUps/extensions/disableTieAutoCalc.ts","../src/mutate/drawDefinitions/matchUpGovernor/enableTieAutoCalc.ts","../src/mutate/drawDefinitions/luckyLoserDrawPositionAssignment.ts","../src/mutate/matchUps/drawPositions/positionLuckyLoser.ts","../src/mutate/drawDefinitions/modifyDrawDefinition.ts","../src/mutate/events/modifyEvent.ts","../src/mutate/entries/modifyEventEntries.ts","../src/mutate/drawDefinitions/modifyPairAssignment.ts","../src/mutate/events/modifySeedAssignment.ts","../src/mutate/drawDefinitions/entryGovernor/modifySeedAssignment.ts","../src/mutate/matchUps/tieFormat/modifyTieFormat.ts","../src/mutate/drawDefinitions/pruneDrawDefinition.ts","../src/mutate/drawDefinitions/qualifierDrawPositionAssignment.ts","../src/mutate/matchUps/drawPositions/positionQualifier.ts","../src/mutate/matchUps/tieFormat/removeCollectionGroup.ts","../src/mutate/matchUps/extensions/removeDelegatedOutcome.ts","../src/mutate/drawDefinitions/removeDrawEntries.ts","../src/mutate/matchUps/sides/removeMatchUpSideParticipant.ts","../src/mutate/structures/removeRoundMatchUps.ts","../src/mutate/drawDefinitions/removeSeededParticipant.ts","../src/mutate/entries/removeSeeding.ts","../src/mutate/drawDefinitions/structureGovernor/removeStructure.ts","../src/mutate/matchUps/lineUps/removeTieMatchUpParticipant.ts","../src/mutate/drawDefinitions/structureGovernor/renameStructures.ts","../src/mutate/drawDefinitions/resetDrawDefinition.ts","../src/mutate/matchUps/lineUps/resetMatchUpLineUps.ts","../src/mutate/matchUps/resetScorecard.ts","../src/mutate/drawDefinitions/resetVoluntaryConsolationStructure.ts","../src/mutate/drawDefinitions/setDelegatedOutcome.ts","../src/mutate/drawDefinitions/matchUpGovernor/setDelegatedOutcome.ts","../src/mutate/drawDefinitions/setDrawParticipantRepresentativeIds.ts","../src/mutate/matchUps/matchUpFormat/setMatchUpFormat.ts","../src/mutate/drawDefinitions/setOrderOfFinish.ts","../src/mutate/drawDefinitions/matchUpGovernor/setOrderOfFinish.ts","../src/mutate/drawDefinitions/setPositionAssignments.ts","../src/mutate/drawDefinitions/positionGovernor/setPositionAssignments.ts","../src/mutate/drawDefinitions/structureGovernor/setStructureOrder.ts","../src/mutate/structures/setSubOrder.ts","../src/mutate/drawDefinitions/substituteParticipant.ts","../src/mutate/drawDefinitions/positionGovernor/substituteParticipant.ts","../src/mutate/drawDefinitions/swapDrawPositionAssignments.ts","../src/mutate/drawDefinitions/withdrawParticipantAtDrawPosition.ts","../src/assemblies/generators/drawDefinitions/drawTypes/generateQualifyingStructures.ts","../src/assemblies/generators/drawDefinitions/getDrawTypeCoercion.ts","../src/assemblies/generators/drawDefinitions/drawTypes/doubleEliminattion.ts","../src/assemblies/generators/drawDefinitions/links/doubleEliminationLinks.ts","../src/assemblies/generators/drawDefinitions/drawTypes/luckyDraw.ts","../src/assemblies/generators/drawDefinitions/getGenerators.ts","../src/assemblies/generators/drawDefinitions/drawTypes/roundRobin/generateRoundRobinWithPlayoff.ts","../src/assemblies/generators/drawDefinitions/generateDrawStructuresAndLinks.ts","../src/assemblies/generators/drawDefinitions/generateDrawTypeAndModifyDrawDefinition.ts","../src/query/tournaments/allowedTypes.ts","../src/validators/checkValidEntries.ts","../src/assemblies/generators/templates/drawDefinitionTemplate.ts","../src/assemblies/generators/drawDefinitions/prepareStage.ts","../src/mutate/drawDefinitions/positionGovernor/initializeSeedAssignments.ts","../src/fixtures/policies/POLICY_SEEDING_DEFAULT.ts","../src/assemblies/generators/drawDefinitions/generateDrawDefinition.ts","../src/assemblies/generators/drawDefinitions/newDrawDefinition.ts","../src/mutate/tieFormat/checkTieFormat.ts","../src/constants/flightConstants.ts","../src/constants/sortingConstants.ts","../src/assemblies/generators/participants/generateLineUps.ts","../src/query/venues/getCourtDateAvailability.ts","../src/assemblies/generators/scheduling/generateTimeSlots.ts","../src/query/venues/getCourtsAvailableAtPeriodStart.ts","../src/query/venues/getEnoughTime.ts","../src/assemblies/generators/scheduling/courtGenerator.ts","../src/mutate/matchUps/schedule/schedulers/utils/generateVirtualCourts.ts","../src/mutate/matchUps/schedule/schedulers/utils/calculatePeriodLength.ts","../src/mutate/matchUps/schedule/schedulers/utils/getTimeBoundary.ts","../src/query/venues/getScheduleTimes.ts","../src/query/venues/getFirstTimeSlotStartTime.ts","../src/assemblies/generators/scheduling/garman/garman.ts","../src/assemblies/governors/generationGovernor/index.ts","../src/assemblies/generators/venues/generateCourts.ts","../src/assemblies/generators/drawDefinitions/generateFlightProfile.ts","../src/assemblies/generators/drawDefinitions/drawTypes/generateVoluntaryConsolation.ts","../src/assemblies/generators/mocks/address.ts","../src/assemblies/generators/mocks/generatePersonData.ts","../src/assemblies/generators/mocks/generatePersons.ts","../src/assemblies/generators/mocks/generateAddress.ts","../src/assemblies/generators/mocks/nameMocks.ts","../src/query/matchUp/getComplement.ts","../src/utilities/parseScoreString.ts","../src/assemblies/generators/mocks/generateOutcomeFromScoreString.ts","../src/query/extensions/getMatchUpDailyLimits.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/checkDependenciesScheduled.ts","../src/acquire/findDrawDefinition.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/processNextMatchUps.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/checkParticipantProfileInitialization.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/updateTimeAfterRecovery.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/checkDependentTiming.ts","../src/constants/requestConstants.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/checkRequestConflicts.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/getIndividualParticipants.ts","../src/acquire/findMatchUpFormatTiming.ts","../src/query/matchUps/scheduling/getScheduledRoundsDetails.ts","../src/query/matchUps/scheduling/getGroupedRounds.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/modifyParticipantMatchUpsCount.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/hasSchedule.ts","../src/mutate/matchUps/schedule/schedulers/utils/processAlreadyScheduledMatchUps.ts","../src/mutate/matchUps/schedule/schedulers/utils/getMatchUpsToSchedule.ts","../src/mutate/matchUps/schedule/schedulers/utils/generateBookings.ts","../src/mutate/matchUps/schedule/schedulers/utils/generateScheduleTimes.ts","../src/query/matchUps/scheduling/getVenueSchedulingDetails.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/checkRecoveryTime.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/analyzeScheduleOverlap.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/checkDailyLimits.ts","../src/mutate/matchUps/schedule/bulkScheduleTournamentMatchUps.ts","../src/mutate/matchUps/schedule/bulkScheduleMatchUps.ts","../src/mutate/matchUps/schedule/schedulers/auditAutoScheduling.ts","../src/query/matchUps/scheduling/getPersonRequests.ts","../src/mutate/matchUps/schedule/schedulers/utils/getEarliestCourtTime.ts","../src/mutate/matchUps/schedule/clearScheduledMatchUps.ts","../src/mutate/matchUps/schedule/scheduleProfileRounds.ts","../src/mutate/matchUps/schedule/schedulers/v2Scheduler/v2Scheduler.ts","../src/mutate/matchUps/schedule/schedulers/jinnScheduler/jinnScheduler.ts","../src/assemblies/generators/tournamentRecords/newTournamentRecord.ts","../src/mutate/participants/createTeamsFromAttributes.ts","../src/assemblies/generators/mocks/genParticipantId.ts","../src/assemblies/generators/mocks/generateParticipants.ts","../src/assemblies/generators/mocks/processTieFormat.ts","../src/assemblies/generators/mocks/addTournamentParticipants.ts","../src/assemblies/generators/mocks/getParticipantsCount.ts","../src/assemblies/generators/templates/courtTemplate.ts","../src/validators/time.ts","../src/validators/validateDateAvailability.ts","../src/mutate/venues/addCourt.ts","../src/mutate/venues/generateVenues.ts","../src/query/drawDefinition/getStageParticipantsCount.ts","../src/query/drawDefinition/getStageParticipants.ts","../src/mutate/participants/addScaleItems.ts","../src/query/matchUp/getSetWinningSide.ts","../src/query/matchUp/analyzeSet.ts","../src/query/matchUp/analyzeMatchUp.ts","../src/assemblies/generators/mocks/generateOutcome.ts","../src/assemblies/generators/mocks/completeDrawMatchUps.ts","../src/assemblies/generators/mocks/generateFlightDrawDefinitions.ts","../src/assemblies/generators/mocks/generateEventParticipants.ts","../src/assemblies/generators/mocks/generateFlight.ts","../src/assemblies/generators/mocks/generateFlights.ts","../src/assemblies/generators/mocks/generateEventWithFlights.ts","../src/query/tournaments/getCompetitionDateRange.ts","../src/mutate/matchUps/schedule/addSchedulingProfileRound.ts","../src/assemblies/generators/mocks/generateEventWithDraw.ts","../src/assemblies/generators/mocks/generateTournamentRecord.ts","../src/fixtures/credits.ts","../src/assemblies/governors/mocksGovernor/index.ts","../src/assemblies/generators/tournamentRecords/anonymizeTournamentRecord.ts","../src/assemblies/generators/mocks/generateScheduledRounds.ts","../src/assemblies/generators/mocks/modifyTournamentRecord.ts","../src/assemblies/generators/participants/formatPersonName.ts","../src/assemblies/generators/participants/formatParticipantName.ts","../src/mutate/participants/penalties/removePenalty.ts","../src/assemblies/generators/templates/penaltyTemplate.ts","../src/mutate/participants/penalties/modifyPenalty.ts","../src/utilities/deepMerge.ts","../src/mutate/participants/penalties/addPenalty.ts","../src/assemblies/governors/participantGovernor/index.ts","../src/mutate/participants/addPersons.ts","../src/mutate/participants/createGroupParticipant.ts","../src/mutate/participants/mergeParticipants.ts","../src/mutate/participants/modifyIndividualParticipantIds.ts","../src/mutate/participants/modifyParticipantName.ts","../src/mutate/participants/modifyParticipantOtherName.ts","../src/mutate/participants/modifyParticipantsSignInStatus.ts","../src/mutate/participants/regenerateParticipantNames.ts","../src/mutate/participants/scaledTeamAssignment.ts","../src/mutate/extensions/policies/removePolicy.ts","../src/assemblies/governors/policyGovernor/index.ts","../src/mutate/timeItems/unPublishOrderOfPlay.ts","../src/mutate/timeItems/publishOrderOfPlay.ts","../src/assemblies/governors/publishingGovernor/index.ts","../src/query/event/getAllEventData.ts","../src/mutate/events/eventSeeding.ts","../src/mutate/events/setEventDisplay.ts","../src/mutate/events/unPublishEvent.ts","../src/query/extensions/getExtensionUpdate.ts","../src/fixtures/policies/POLICY_SCHEDULING_DEFAULT.ts","../src/query/extensions/matchUpFormatTiming/getModifiedMatchUpTiming.ts","../src/mutate/participants/penalties/getTournamentPenalties.ts","../src/functions/sorters/scheduledSortedMatchUps.ts","../src/assemblies/generators/scheduling/courtGridRows.ts","../src/query/matchUps/getEventMatchUps.ts","../src/query/matchUps/getTournamentMatchUps.ts","../src/query/matchUps/getCompetitionMatchUps.ts","../src/query/matchUps/competitionScheduleMatchUps.ts","../src/query/matchUps/getCompetitionPublishedDrawDetails.ts","../src/query/structure/getSourceStructureIdsAndRelevantLinks.ts","../src/constants/positionActionConstants.ts","../src/query/drawDefinition/positionActions/getValidAlternatesAction.ts","../src/query/drawDefinition/positionActions/participantAssignments.ts","../src/query/drawDefinition/positionActions/getValidSwapAction.ts","../src/fixtures/policies/POLICY_POSITION_ACTIONS_DEFAULT.ts","../src/query/drawDefinition/positionActions/actionPolicyUtils.ts","../src/constants/matchUpActionConstants.ts","../src/query/drawDefinition/matchUpActions/adHocMatchUpActions.ts","../src/query/drawDefinition/matchUpActions/getEventAlternateParticipantids.ts","../src/query/drawDefinition/matchUpActions/matchUpActions.ts","../src/query/drawDefinition/matchUpActions/collectionMatchUpActions.ts","../src/query/matchUps/getPredictiveAccuracy.ts","../src/query/tournaments/checkIsDual.ts","../src/query/matchUps/scheduling/schedulingUtils.ts","../src/mutate/matchUps/schedule/profileRounds.ts","../src/functions/sorters/roundSort.ts","../src/assemblies/governors/queryGovernor/index.ts","../src/query/tournaments/analyzeTournament.ts","../src/query/event/bulkUpdatePublishedEventIds.ts","../src/query/matchUps/getDrawMatchUps.ts","../src/acquire/publicFindParticipant.ts","../src/query/participants/getCompetitionParticipants.ts","../src/mutate/participants/penalties/getCompetitionPenalties.ts","../src/query/venues/getCourts.ts","../src/mutate/drawDefinitions/getDrawParticipantRepresentativeIds.ts","../src/query/drawDefinition/getEligibleVoluntaryConsolationParticipants.ts","../src/query/events/getEvent.ts","../src/query/extensions/matchUpFormatTiming/getEventMatchUpFormatTiming.ts","../src/query/event/getEventProperties.ts","../src/query/events/getEvents.ts","../src/query/extensions/getMatchUpDailyLimitsUpdate.ts","../src/query/hierarchical/getMatchUpFormat.ts","../src/query/extensions/matchUpFormatTiming/getMatchUpFormatTimingUpdate.ts","../src/query/matchUps/getMatchUpsStats.ts","../src/query/entries/getMaxEntryPosition.ts","../src/query/participants/getParticipantEventDetails.ts","../src/query/drawDefinition/finishingPositions.ts","../src/query/drawDefinition/participantIdMatchUps.ts","../src/query/participants/getParticipantMembership.ts","../src/query/participants/getParticipantSchedules.ts","../src/query/participant/signInStatus.ts","../src/query/matchUps/scheduling/getRounds.ts","../src/query/matchUps/scheduling/getSchedulingProfileIssues.ts","../src/query/hierarchical/getTieFormat.ts","../src/query/tournaments/getTournamentPersons.ts","../src/query/venues/venuesReport.ts","../src/mutate/drawDefinitions/isValidForQualifying.ts","../src/query/matchUps/participantScheduledMatchUps.ts","../src/query/drawDefinition/positionActions/positionActions.ts","../src/query/drawDefinition/positionActions/getValidQualifiersAction.ts","../src/query/drawDefinition/positionActions/getValidLuckyLoserAction.ts","../src/query/drawDefinition/positionActions/getValidModifyAssignedPairAction.ts","../src/query/matchUp/getMatchUpContextIds.ts","../src/query/scales/getDetailsWTN.ts","../src/query/scales/getAvgWTN.ts","../src/assemblies/governors/reportGovernor/index.ts","../src/query/structure/structureReport.ts","../src/query/entries/entryStatusReport.ts","../src/query/participant/getParticipantStats.ts","../src/utilities/timeCode.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/personRequests/mergePersonRequests.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/personRequests/savePersonRequests.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/calculateScheduleTimes.ts","../src/mutate/matchUps/extensions/modifyMatchUpFormatTiming.ts","../src/mutate/events/extensions/removeEventMatchUpFormatTiming.ts","../src/mutate/matchUps/schedule/bulkRescheduleMatchUps.ts","../src/assemblies/governors/scheduleGovernor/index.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/personRequests/addPersonRequests.ts","../src/mutate/matchUps/schedule/bulkUpdateCourtAssignments.ts","../src/mutate/matchUps/schedule/clearMatchUpSchedule.ts","../src/mutate/matchUps/schedule/matchUpScheduleChange.ts","../src/mutate/events/extensions/modifyEventMatchUpFormatTiming.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/personRequests/modifyPersonRequests.ts","../src/mutate/matchUps/schedule/schedulers/proScheduler/proAutoSchedule.ts","../src/mutate/matchUps/schedule/schedulers/proScheduler/proConflicts.ts","../src/mutate/matchUps/schedule/removeMatchUpCourtAssignment.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/personRequests/removePersonRequests.ts","../src/mutate/matchUps/schedule/reorderUpcomingMatchUps.ts","../src/mutate/matchUps/schedule/scheduleMatchUps/scheduleMatchUps.ts","../src/mutate/tournaments/setMatchUpDailyLimits.ts","../src/analyze/scoreParser/validPatterns.ts","../src/analyze/scoreParser/utilities.ts","../src/analyze/scoreParser/commonPatterns.ts","../src/analyze/scoreParser/setBuilder.ts","../src/analyze/scoreParser/parseSuper.ts","../src/analyze/scoreParser/handleNumeric.ts","../src/analyze/scoreParser/getWinningSide.ts","../src/analyze/scoreParser/transforms.ts","../src/analyze/scoreParser/punctuationAdjustments.ts","../src/analyze/scoreParser/correctContainerMismatch.ts","../src/analyze/scoreParser/joinFloatingTiebreak.ts","../src/analyze/scoreParser/handleBracketSpacing.ts","../src/analyze/scoreParser/matchKnownPatterns.ts","../src/analyze/scoreParser/properTiebreak.ts","../src/analyze/scoreParser/containedSets.ts","../src/analyze/scoreParser/sensibleSets.ts","../src/analyze/scoreParser/superSquare.ts","../src/analyze/scoreParser/scoreParser.ts","../src/mutate/score/keyValueScore/winningSide.ts","../src/mutate/score/keyValueScore/constants.ts","../src/mutate/score/keyValueScore/keyValueUtilities.ts","../src/mutate/score/keyValueScore/processOutcome.ts","../src/mutate/score/keyValueScore/scoreAnalysis.ts","../src/mutate/matchUps/score/history/getHistory.ts","../src/mutate/matchUps/score/history/saveHistory.ts","../src/mutate/matchUps/score/history/umo.ts","../src/assemblies/governors/scoreGovernor/index.ts","../src/mutate/score/keyValueScore/keyValueScore.ts","../src/mutate/score/keyValueScore/keyValueTimedSetScore.ts","../src/mutate/score/keyValueScore/processIncompleteSetScore.ts","../src/mutate/score/keyValueScore/processTiebreakSet.ts","../src/mutate/score/keyValueScore/keyValueSetScore.ts","../src/assemblies/generators/score/reverseScore.ts","../src/mutate/matchUps/score/history/calculateHistoryScore.ts","../src/mutate/matchUps/score/history/setServingSide.ts","../src/mutate/matchUps/score/history/clearHistory.ts","../src/mutate/matchUps/score/history/addPoint.ts","../src/mutate/matchUps/score/history/addGame.ts","../src/mutate/matchUps/score/history/addShot.ts","../src/mutate/matchUps/score/history/addSet.ts","../src/mutate/matchUps/score/history/redo.ts","../src/mutate/matchUps/score/history/undo.ts","../src/constants/tournamentConstants.ts","../src/mutate/tournaments/tournamentDates.ts","../src/mutate/venues/updateCourtAvailability.ts","../src/assemblies/governors/tournamentGovernor/index.ts","../src/mutate/base/addOnlineResource.ts","../src/mutate/tournaments/tournamentDetails.ts","../src/mutate/tournaments/setTournamentStatus.ts","../src/mutate/tournaments/dehydrate.ts","../src/utilities/json.ts","../src/assemblies/governors/utilitiesGovernor/index.ts","../src/tests/testHarness/testUtilities/visualizeScheduledMatchUps.ts","../src/query/venues/getScheduledCourtMatchUps.ts","../src/mutate/venues/courtAvailability.ts","../src/assemblies/generators/matchUps/deletionMessage.ts","../src/mutate/matchUps/schedule/removeCourtAssignment.ts","../src/mutate/venues/deleteVenue.ts","../src/mutate/venues/disableCourts.ts","../src/mutate/venues/disableVenues.ts","../src/mutate/venues/enableCourts.ts","../src/mutate/venues/deleteCourt.ts","../src/mutate/venues/modifyCourt.ts","../src/assemblies/generators/templates/venueTemplate.ts","../src/mutate/venues/modifyVenue.ts","../src/assemblies/governors/venueGovernor/index.ts","../src/mutate/venues/enableVenues.ts","../src/assemblies/governors/index.ts","../src/forge/index.ts","../src/global/state/notifySubscribers.ts","../src/mutate/tournaments/updateFactoryExtension.ts","../src/assemblies/engines/parts/getMutationStatus.ts","../src/global/functions/engineLogging.ts","../src/assemblies/engines/parts/logMethodNotFound.ts","../src/assemblies/engines/parts/executeMethod.ts","../src/assemblies/engines/parts/paramsMiddleware.ts","../src/assemblies/engines/parts/stateMethods.ts","../src/assemblies/engines/async/asyncEngineInvoke.ts","../src/assemblies/engines/parts/processResult.ts","../src/assemblies/engines/parts/engineStart.ts","../src/assemblies/engines/parts/importMethods.ts","../src/assemblies/engines/async/index.ts","../src/assemblies/engines/async/asyncExecutionQueue.ts","../src/assemblies/engines/ask/askInvoke.ts","../src/assemblies/engines/ask/index.ts","../src/assemblies/engines/sync/engineInvoke.ts","../src/assemblies/engines/sync/index.ts","../src/assemblies/engines/sync/executionQueue.ts","../src/tests/engines/syncEngine/index.ts","../src/assemblies/engines/matchUp/stateMethods.ts","../src/assemblies/engines/matchUp/index.ts","../src/assemblies/engines/mock/index.ts","../src/query/scales/getTargetElement.ts","../src/query/scales/getAwardProfile.ts","../src/query/scales/getAwardPoints.ts","../src/tests/engines/scaleEngine/governors/rankingsGovernor/index.ts","../src/query/scales/getTournamentPoints.ts","../src/mutate/scales/calculateNewRatings.ts","../src/tests/engines/scaleEngine/governors/ratingsGovernor/index.ts","../src/mutate/scales/generateDynamicRatings.ts","../src/mutate/scales/aggregators.ts","../src/tests/engines/scaleEngine/index.ts","../src/fixtures/index.ts","../src/fixtures/policies/index.ts","../src/fixtures/policies/POLICY_AVOIDANCE_COUNTRY.ts","../src/fixtures/policies/POLICY_POSITION_ACTIONS_DISABLED.ts","../src/fixtures/policies/POLICY_POSITION_ACTIONS_NO_MOVEMENT.ts","../src/fixtures/policies/POLICY_POSITION_ACTIONS_UNRESTRICTED.ts","../src/fixtures/policies/POLICY_PRIVACY_DEFAULT.ts","../src/fixtures/policies/POLICY_SCORING_DEFAULT.ts","../src/fixtures/policies/POLICY_SCORING_USTA.ts","../src/fixtures/policies/POLICY_SEEDING_ITF.ts","../src/constants/penaltyConstants.ts","../src/constants/surfaceConstants.ts","../src/constants/venueConstants.ts","../src/constants/index.ts"],"sourcesContent":["export function factoryVersion() {\n  return '@VERSION@';\n}\n","export function numericSort(a, b) {\n  return (a ?? 0) - (b ?? 0);\n}\n","export function ensureInt(val: string | number) {\n  if (typeof val === 'number') return parseInt(val.toString());\n  return parseInt(val);\n}\n","import { numericSort } from './sorting';\nimport { ensureInt } from './ensureInt';\n\nexport function isPowerOf2(n?) {\n  if (isNaN(n)) return false;\n  return n && (n & (n - 1)) === 0;\n}\n\nexport function median(arr: number[]): number | undefined {\n  if (!arr.length) return undefined;\n  const s = [...arr].sort(numericSort);\n  const mid = Math.floor(s.length / 2);\n  return s.length % 2 ? s[mid] : (s[mid - 1] + s[mid]) / 2;\n}\n\nexport function deriveExponent(n) {\n  if (!isPowerOf2(n)) return false;\n  let m = n;\n  let i = 1;\n  while (m !== 2) {\n    i += 1;\n    m = m / 2;\n  }\n  return i;\n}\n\nexport function coerceEven(n) {\n  return isNaN(n) ? 0 : (n % 2 && n + 1) || n;\n}\n\nexport function nearestPowerOf2(val) {\n  return Math.pow(2, Math.round(Math.log(val) / Math.log(2)));\n}\n\nexport function isNumeric(value) {\n  return !isNaN(parseFloat(value));\n}\n\nexport function isOdd(num) {\n  const numInt = ensureInt(num);\n  if (isNaN(numInt)) return undefined;\n  if (numInt === 0) return false;\n  return (numInt & -numInt) === 1;\n}\n\nexport function nextPowerOf2(n?) {\n  if (isNaN(n)) return false;\n  while (!isPowerOf2(n)) {\n    n++;\n  }\n  return n;\n}\n\nexport function randomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n// does accept e.e. '1.0'\nexport function isConvertableInteger(n) {\n  return Number.isSafeInteger(typeof n === 'string' ? +n : n);\n}\n\n// produces an approximated normal distribution between 0 and max\nexport function weightedRandom(max = 1, weight = 3, round = true) {\n  let num = 0;\n  for (let i = 0; i < weight; i++) {\n    num += Math.random() * (max / weight);\n  }\n  return round && max > 1 ? Math.round(num) : num;\n}\n\n// round to nearest step, e.g. 0.25\nfunction stepRound(value, step) {\n  step || (step = 1.0);\n  const inv = 1.0 / step;\n  return Math.round(value * inv) / inv;\n}\n\nexport function skewedDistribution(\n  min: number,\n  max: number,\n  skew: number,\n  step?,\n  significantDecimals = 2\n) {\n  const u = 1 - Math.random();\n  const v = 1 - Math.random();\n  let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n\n  num = num / 10.0 + 0.5;\n\n  if (num > 1 || num < 0) {\n    num = skewedDistribution(min, max, skew);\n  } else {\n    num = Math.pow(num, skew);\n    num *= max - min;\n    num += min;\n  }\n\n  if (step) num = stepRound(num, step);\n\n  return parseFloat(num.toFixed(significantDecimals));\n}\n","import { isConvertableInteger } from './math';\n\n// returns only unique values within an array\nexport function unique(arr) {\n  return arr?.filter((item, i, s) => s.lastIndexOf(item) === i);\n}\n\nexport function noNulls(arr) {\n  return arr?.map((item) => (item === null ? undefined : item));\n}\n\nexport function shuffleArray(arr) {\n  return arr\n    .map((a) => [Math.random(), a])\n    .sort((a, b) => a[0] - b[0])\n    .map((a) => a[1]);\n}\n\nexport function numericSortValue(v) {\n  return isConvertableInteger(v) ? v : Infinity;\n}\n\n// return an object whose attributes are values and whose values are counts for values\n// e.g. values=[1,2,2,3,4,4,5] produces { 1: 1, 2: 2, 3: 1, 4: 2, 5: 1}\nexport function instanceCount(values): { [key: number | string]: number } {\n  return values.reduce((a, c) => {\n    if (!a[c]) a[c] = 0;\n    a[c]++;\n    return a;\n  }, {});\n}\n\n// return an object whose attributes are value counts and values are arrays of values for each count\n// e.g. values=[1,2,2,3,4,4,5] produces { 1: [\"1\", \"3\", \"5\"], 2: [\"2\", \"4\"] }\nexport function countValues(values): { [key: number]: string[] } {\n  return groupValues(instanceCount(values));\n}\n\n// group the values of an object by attributes(keys) which produce those values\n// e.g. obj = { 1: 1, 2: 2, 3: 1, 4: 2, 5: 1} produces { 1: [\"1\", \"3\", \"5\"], 2: [\"2\", \"4\"] }\nexport function groupValues(obj) {\n  return Object.keys(obj).reduce((p, c) => {\n    const value = obj[c];\n    if (p[value]) {\n      p[value].push(c);\n    } else {\n      p[value] = [c];\n    }\n    return p;\n  }, {});\n}\n\nfunction onlyUnique(value, index, self) {\n  return self.indexOf(value) === index;\n}\nexport function uniqueValues(arr) {\n  return arr.filter(onlyUnique);\n}\nexport function randomPop(array) {\n  return Array.isArray(array) && array.length\n    ? array.splice(Math.floor(Math.random() * array.length), 1)[0]\n    : undefined;\n}\nexport function randomMember(arr) {\n  const index = Math.floor(Math.random() * arr.length);\n  return arr[index];\n}\n\nexport function generateRange(start, end) {\n  return Array.from({ length: end - start }, (_, k) => k + start);\n}\nexport function sizedRange(size, start) {\n  return Array.from(Array(size).keys()).map((i) => i + start);\n}\n\nexport function arrayIndices(val, arr) {\n  return arr.reduce((a, e, i) => {\n    if (e === val) a.push(i);\n    return a;\n  }, []);\n}\nexport function intersection(a, b) {\n  if (!Array.isArray(a) || !Array.isArray(b)) return [];\n  return a\n    .filter((n) => b.indexOf(n) !== -1)\n    .filter((e, i, c) => c.indexOf(e) === i);\n}\nexport function difference(a, b) {\n  if (!Array.isArray(a) || !Array.isArray(b)) return [];\n  return a.filter((x) => !b.includes(x));\n}\nexport function symmetricDifference(a, b) {\n  if (!Array.isArray(a) || !Array.isArray(b)) return [];\n  return a\n    .filter((x) => !b.includes(x))\n    .concat(b.filter((x) => !a.includes(x)));\n}\nexport function overlap(a, b) {\n  if (!Array.isArray(a) || !Array.isArray(b)) return false;\n  return a.some((e) => b.includes(e));\n}\nexport function occurrences(val, arr) {\n  return (\n    arr.reduce((r, val) => {\n      r[val] = 1 + r[val] || 1;\n      return r;\n    }, {})[val] || 0\n  );\n}\nexport function subSort(arr, i, n, sortFx) {\n  return [].concat(\n    ...arr.slice(0, i),\n    ...arr.slice(i, i + n).sort(sortFx),\n    ...arr.slice(i + n, arr.length)\n  );\n}\nexport function inPlaceSubSort(arr, i, n, sortFx) {\n  const newarray = [].concat(\n    ...arr.slice(0, i),\n    ...arr.slice(i, i + n).sort(sortFx),\n    ...arr.slice(i + n, arr.length)\n  );\n  arr.length = 0;\n  arr.push(...newarray); // use spread operator instead?\n  return arr;\n}\nexport function chunkArray(arr, chunksize) {\n  return arr.reduce((all, one, i) => {\n    const ch = Math.floor(i / chunksize);\n    all[ch] = [].concat(all[ch] || [], one);\n    return all;\n  }, []);\n}\n\n// will break an array of items into chunks following pattern [size1, size2, ...]\nexport function chunkSizeProfile(\n  arr: number[],\n  [size, ...otherSizes]: number[]\n) {\n  return arr.length\n    ? [\n        arr.slice(0, size),\n        ...chunkSizeProfile(arr.slice(size), [...otherSizes, size]),\n      ]\n    : [];\n}\nexport function groupConsecutiveNumbers(arr) {\n  return arr.reduce((result, num) => {\n    const finalGroup = result[result.length - 1];\n    if (!finalGroup || finalGroup[finalGroup.length - 1] !== num - 1) {\n      result.push([]);\n    }\n    result[result.length - 1].push(num);\n    return result;\n  }, []);\n}\n\nexport function allNumeric(arr) {\n  return arr.reduce((numeric, item) => !isNaN(parseInt(item)) && numeric, true);\n}\nexport function noNumeric(arr) {\n  return arr.reduce((numeric, item) => isNaN(parseInt(item)) && numeric, true);\n}\n\n/**\n * chunk an arbitrary array of elements by adding every Nth instance to chunksCount chunks\n *\n * e.g. given arr=[1,2,3,4,5,6,7,8,9,10,11,12]:\n *\n * chunkByNth(arr, 3)\n * [1, 4, 7, 10]\n * [2, 5, 8, 11]\n * [3, 6, 9, 12]\n * chunkByNth(arr, 4)\n * [1, 5, 9]\n * [2, 6, 10]\n * [3, 7, 11]\n * [4, 8, 12]\n *\n * When shuttle = true:\n * chunkByNth(arr, 3, true)\n * [1, 6, 7, 12]\n * [2, 5, 8, 11]\n * [3, 4, 9, 10]\n * chunkByNth(arr, 4, true)\n * [1, 8, 9]\n * [2, 7, 10]\n * [3, 6, 11]\n * [4, 5, 12]\n *\n * @param {any[]} arr - an array\n * @param {number} chunksCount - number of chunks to create\n * @param {boolean} shuttle - whether or not to \"shuttle\" as in the movment of a shuttle in a loom\n */\nexport function chunkByNth(arr: any[], chunksCount: number, shuttle?: boolean) {\n  return arr.reduce((chunks, entry, index) => {\n    const reverseDirection = shuttle\n      ? !!(Math.floor(index / chunksCount) % 2)\n      : false;\n    const chunkIndex = index % chunksCount;\n    const directionIndex = reverseDirection\n      ? chunksCount - 1 - chunkIndex\n      : chunkIndex;\n    if (!chunks[directionIndex]) chunks[directionIndex] = [];\n    chunks[directionIndex].push(entry);\n    return chunks;\n  }, []);\n}\n\n// group numbers by contiguous ranges\nexport function getRanges(array) {\n  return array\n    .map((e) => parseInt(e))\n    .filter((e) => !isNaN(e))\n    .reduce((ranges, a) => {\n      if (!ranges.some((range) => range.includes(a - 1) && range.push(a)))\n        ranges.push([a]);\n      return ranges;\n    }, []);\n}\n\nexport function getMissingSequenceNumbers(arr, start = 1) {\n  if (!Array.isArray(arr) || !arr.every(isConvertableInteger)) return [];\n  const min = Math.min(...arr, start);\n  const max = Math.max(...arr);\n  return generateRange(min, max + 1).filter((n) => !arr.includes(n));\n}\n","export const SUCCESS = { success: true };\nexport const ERROR = 'error';\n\nexport const resultConstants = {\n  SUCCESS,\n  ERROR,\n};\n","export type ErrorType = {\n  message: string;\n  info?: string;\n  code: string;\n};\n\nexport const ANACHRONISM = {\n  message: 'Chronological error; time violation.',\n  code: 'ANACHRONISM',\n};\nexport const CANNOT_REMOVE_MAIN_STRUCTURE = {\n  message: 'Cannot remove main structure',\n  code: 'ERR_CANNOT_REMOVE_MAIN_STRUCTURE',\n};\nexport const INVALID_RECORDS = {\n  message: 'records must be an object with tournamentId keys',\n  code: 'ERR_INVALID_TOURNAMENTS',\n};\nexport const MISSING_TOURNAMENT_RECORDS = {\n  message: 'Missing tournamentRecords',\n  code: 'ERR_MISSING_TOURNAMENTS',\n};\nexport const MISSING_TOURNAMENT_RECORD = {\n  message: 'Missing tournamentRecord',\n  code: 'ERR_MISSING_TOURNAMENT',\n};\nexport const INVALID_TOURNAMENT_RECORD = {\n  message: 'Invalid tournamentRecord',\n  code: 'ERR_INVALID_TOURNAMENT',\n};\nexport const MISSING_TOURNAMENT_ID = {\n  message: 'Missing tournamentId',\n  code: 'ERR_MISSING_TOURNAMENT_ID',\n};\n\nexport const INVALID_DRAW_DEFINITION = {\n  message: 'Invalid drawDefinition',\n  code: 'ERR_INVALID_DRAWDEF',\n};\nexport const MISSING_DRAW_DEFINITION = {\n  message: 'Missing drawDefinition',\n  code: 'ERR_MISSING_DRAWDEF',\n};\nexport const EXISTING_DRAW_DEFINITIONS = {\n  message: 'Existing drawDefinition(s)',\n  code: 'ERR_EXISTING_DRAWDEFS',\n};\nexport const DRAW_DEFINITION_NOT_FOUND = {\n  message: 'drawDefinition not found',\n  code: 'ERR_NOT_FOUND_DRAWDEF',\n};\nexport const INVALID_STRUCTURE = {\n  message: 'Invalid structure',\n  code: 'ERR_INVALID_STRUCTURE',\n};\nexport const INCOMPLETE_SOURCE_STRUCTURE = {\n  message: 'Incomplete source structure',\n  code: 'ERR_INCOMPLETE_STRUCTURE',\n};\n\nexport const INVALID_DRAW_POSITION_FOR_SEEDING = {\n  message: 'Invalid drawPosition for seedAssignment',\n  code: 'ERR_INVALID_SEEDING_POSITION',\n};\nexport const DRAW_POSITION_ASSIGNED = {\n  message: 'drawPosition already assigned',\n  code: 'ERR_EXISTING_POSITION_ASSIGNMENT',\n};\nexport const SCHEDULE_NOT_CLEARED = {\n  message: 'Schedule not cleared',\n  code: 'ERR_UNCHANGED_SCHEDULE_NOT_CLEARED',\n};\nexport const DRAW_POSITION_NOT_CLEARED = {\n  message: 'drawPosition not cleared',\n  code: 'ERR_FAILURE_POSITION_NOT_CLEARED',\n};\nexport const DRAW_POSITION_NOT_FOUND = {\n  message: 'drawPosition not found',\n  code: 'ERR_NOT_FOUND_DRAW_POSITION',\n};\nexport const UNRECOGNIZED_DRAW_TYPE = {\n  message: 'Unrecognized drawType',\n  code: 'ERR_UNRECOGNIZED_DRAW_TYPE',\n};\nexport const MISSING_DRAW_POSITIONS = {\n  message: 'Missing drawPositions',\n  code: 'ERR_MISSING_DRAW_POSITIONS',\n};\nexport const DRAW_POSITION_ACTIVE = {\n  message: 'drawPosition is active',\n  code: 'ERR_ACTIVE_DRAW_POSITION',\n};\nexport const INVALID_DRAW_POSITION = {\n  message: 'Invlid drawPosition',\n  code: 'ERR_INVALID_DRAW_POSITION',\n};\nexport const MISSING_DRAW_POSITION = {\n  message: 'Missing drawPosition',\n  code: 'ERR_MISSING_DRAW_POSITION',\n};\nexport const INVALID_DRAW_TYPE = {\n  message: 'Invalid drawType',\n  code: 'ERR_INVALID_DRAW_TYPE',\n};\nexport const INVALID_DRAW_SIZE = {\n  message: 'Invalid drawSize',\n  code: 'ERR_INVALID_DRAW_SIZE',\n};\nexport const DRAW_SIZE_MISMATCH = {\n  message: 'Cannot set drawSize to be less than existing entries',\n  code: 'ERR_INVALID_DRAW_SIZE_MISMATCH',\n};\nexport const MISSING_DRAW_SIZE = {\n  message: 'Missing drawSize',\n  code: 'ERR_MISSING_DRAW_SIZE',\n};\nexport const MISSING_DRAW_ID = {\n  message: 'Missing drawId',\n  code: 'ERR_MISSING_DRAW_ID',\n};\nexport const DRAW_ID_EXISTS = {\n  message: 'drawId exists',\n  code: 'ERR_EXISTING_DRAW_ID',\n};\nexport const INVALID_PARTICIPANT_SEEDING = {\n  message: 'participantId cannot be assigned to multiple seedNumbers',\n  code: 'INVALID_PARTICIPANT_SEEDING',\n};\nexport const SEEDSCOUNT_GREATER_THAN_DRAW_SIZE = {\n  message: 'seedsCount greater than drawSize',\n  code: 'ERR_INVALID_SEED_COUNT',\n};\nexport const MISSING_SEEDCOUNT_THRESHOLDS = {\n  message: 'Missing seedCountThresholds',\n  code: 'ERR_MISSING_SEED_COUNT_THRESHOLD',\n};\nexport const INVALID_ACTION = {\n  message: 'Invalid action',\n  code: 'ERR_INVALID_ACTION',\n};\nexport const INVALID_ASSIGNMENT = {\n  message: 'Invalid assignment',\n  code: 'ERR_INVALID_ASSIGNMENT',\n};\nexport const MISSING_SEED_ASSIGNMENTS = {\n  message: 'Missing seedAssignments',\n  code: 'ERR_MISSING_SEED_ASSIGNMENTS',\n};\nexport const INVALID_SEED_NUMBER = {\n  message: 'Invalid seedNumber',\n  code: 'ERR_INVALID_SEED_NUMBER',\n};\nexport const INVALID_SEED_POSITION = {\n  message: 'Invalid seedPosition',\n  code: 'ERR_INVALID_SEED_POSITION',\n};\n\nexport const MISSING_TARGET_LINK = {\n  message: 'Missing targetLink',\n  code: 'ERR_MISSING_LINK_TARGET',\n};\n\nexport const EXISTING_ROUND = {\n  message: 'Existing round',\n  code: 'ERR_EXISTING_ROUND',\n};\nexport const MISSING_ROUND_NUMBER = {\n  message: 'Missing roundNumber',\n  code: 'ERR_MISSING_ROUND_NUMBER',\n};\nexport const MISSING_STRUCTURE_ID = {\n  message: 'Missing structureId',\n  code: 'ERR_MISSING_STRUCTURE_ID',\n};\nexport const STRUCTURE_NOT_FOUND = {\n  message: 'structure not found',\n  code: 'ERR_NOT_FOUND_STRUCTURE',\n};\nexport const MISSING_STRUCTURES = {\n  message: 'Missing structures',\n  code: 'ERR_MISSING_STRUCTURES',\n};\nexport const MISSING_STRUCTURE = {\n  message: 'Missing structure',\n  code: 'ERR_MISSING_STRUCTURE',\n};\nexport const UNLINKED_STRUCTURES = {\n  message: 'drawDefinition contains unlinked structures',\n  code: 'ERR_MISSING_STRUCTURE_LINKS',\n};\n\nexport const INVALID_EVENT_TYPE = {\n  message: 'Invalid eventType',\n  code: 'ERR_INVALID_EVENT_TYPE',\n};\nexport const UNRECOGNIZED_EVENT_TYPE = {\n  message: 'Unrecognized eventType',\n  code: 'ERR_UNRECOGNIZED_EVENT_TYPE',\n};\nexport const MISSING_EVENT = {\n  message: 'Missing event / eventId',\n  code: 'ERR_MISSING_EVENT_ID',\n};\nexport const EVENT_NOT_FOUND = {\n  message: 'Event not found',\n  code: 'ERR_NOT_FOUND_EVENT',\n};\nexport const EVENT_EXISTS = {\n  message: 'Event exists',\n  code: 'ERR_EXISTING_EVENT',\n};\n\nexport const MISSING_ENTRIES = {\n  message: 'Missing entries',\n  code: 'ERR_MISSING_ENTRIES',\n};\nexport const INVALID_ENTRIES = {\n  message: 'Invalid entries',\n  code: 'ERR_INVALID_ENTRIES',\n};\nexport const MISSING_ASSIGNMENTS = {\n  message: 'Missing assignments',\n  code: 'ERR_MISSING_ASSIGNMENTS',\n};\n\nexport const MISSING_STAGE = {\n  message: 'Missing stage',\n  code: 'ERR_MISSING_STAGE',\n};\nexport const INVALID_STAGE = {\n  message: 'Invalid stage',\n  code: 'ERR_INVALID_STAGE',\n};\nexport const STAGE_SEQUENCE_LIMIT = {\n  message: 'stageSequence limit',\n  code: 'ERR_LIMIT_STAGE_SEQUENCE',\n};\nexport const MISSING_POSITION_ASSIGNMENTS = {\n  message: 'Missing positionAssignments',\n  code: 'ERR_MISSING_POSITION_ASSIGNMENTS',\n};\nexport const INVALID_MATCHUP_STATUS_BYE = {\n  message: 'Cannot Assign BYE status if no assignment: { bye: true }',\n  code: 'ERR_UNCHANGED_CANNOT_ASSIGN_BYE',\n};\nexport const UNRECOGNIZED_MATCHUP_STATUS = {\n  message: 'Unrecognized matchUpStatus',\n  code: 'ERR_UNRECOGNIZED_MATCHUP_STATUS',\n};\nexport const UNRECOGNIZED_MATCHUP_FORMAT = {\n  message: 'Unrecognized matchUpFormat',\n  code: 'ERR_UNRECOGNIZED_MATCHUP_FORMAT',\n};\nexport const INCOMPATIBLE_MATCHUP_STATUS = {\n  message: 'Incompatible matchUpStatus',\n  code: 'ERR_INCOMPATIBLE_MATCHUP_STATUS',\n};\nexport const INVALID_MATCHUP_STATUS = {\n  message: 'Invalid matchUpStatus',\n  code: 'ERR_INVALID_MATCHUP_STATUS',\n};\nexport const INVALID_TIE_FORMAT = {\n  message: 'Invalid tieFormat',\n  code: 'ERR_INVALID_TIE_FORMAT',\n};\nexport const INVALID_MATCHUP_FORMAT = {\n  message: 'Invalid matchUpFormat',\n  code: 'ERR_INVALID_MATCHUP_FORMAT',\n};\nexport const MISSING_MATCHUP_FORMAT = {\n  message: 'Missing matchUpFormat',\n  code: 'ERR_MISSING_MATCHUP_FORMAT',\n};\nexport const MISSING_COLLECTION_DEFINITION = {\n  message: 'Missing collectionDefinition',\n  code: 'ERR_MISSING_COLLECTION_DEFINITION',\n};\nexport const MISSING_TIE_FORMAT = {\n  message: 'Missing tieFormat',\n  code: 'ERR_MISSING_TIE_FORMAT',\n};\nexport const MISSING_MATCHUP_ID = {\n  message: 'Missing matchUpId',\n  code: 'ERR_MISSING_MATCHUP_ID',\n};\nexport const MISSING_MATCHUP_IDS = {\n  message: 'Missing matchUpIds',\n  code: 'ERR_MISSING_MATCHUP_IDS',\n};\nexport const MATCHUP_NOT_FOUND = {\n  message: 'matchUp not found',\n  code: 'ERR_NOT_FOUND_MATCHUP',\n};\nexport const MISSING_MATCHUPS = {\n  message: 'Missing matchUps',\n  code: 'ERR_MISSING_MATCHUPS',\n};\nexport const MISSING_MATCHUP = {\n  message: 'Missing matchUp',\n  code: 'ERR_MISSING_MATCHUP',\n};\nexport const INVALID_MATCHUP = {\n  message: 'Invalid matchUp',\n  code: 'ERR_INVALID_MATCHUP',\n};\n\nexport const MISSING_POLICY_TYPE = {\n  message: 'Missing policyType',\n  code: 'ERR_MISSING_POLICY_TYPE',\n};\nexport const MISSING_POLICY_DEFINITION = {\n  message: 'Missing policyDefinitions',\n  code: 'ERR_MISSING_POLICY_DEFINITIONS',\n};\nexport const MISSING_SEEDING_POLICY = {\n  message: 'Missing seeding policy',\n  code: 'ERR_MISSING_POLICY_SEEDING',\n};\nexport const MISSING_AVOIDANCE_POLICY = {\n  message: 'Missing avoidance policy',\n  code: 'ERR_MISSING_POLICY_AVOIDANCE',\n};\nexport const MISSING_POLICY_ATTRIBUTES = {\n  message: 'Missing policy attributes',\n  code: 'ERR_MISSING_POLICY_ATTRIBUTES',\n};\nexport const INVALID_POLICY_DEFINITION = {\n  message: 'Invalid policyDefinitions',\n  code: 'ERR_INVALID_POLICY_DEFINITIONS',\n};\nexport const EXISTING_POLICY_TYPE = {\n  message: 'existing policyType',\n  code: 'ERR_EXISTING_POLICY_TYPE',\n};\nexport const POLICY_NOT_ATTACHED = {\n  message: 'Policy not attached',\n  code: 'ERR_FAILURE_POLICY_NOT_ATTACHED',\n};\nexport const POLICY_NOT_FOUND = {\n  message: 'Policy not found',\n  code: 'ERR_NOT_FOUND_POLICY',\n};\nexport const MISSING_SCORING_POLICY = {\n  message: 'Missing scoring policy / matchUpFormats',\n  code: 'ERR_MISSING_POLICY_SCORING_MATCHUP_FORMATS',\n};\n\nexport const INVALID_SIDE_NUMBER = {\n  message: 'Invalid sideNumber',\n  code: 'ERR_INVALID_SIDE_NUMBER',\n};\nexport const INVALID_SET_NUMBER = {\n  message: 'Invalid setNumber',\n  code: 'ERR_INVALID_SET_NUMBER',\n};\nexport const MISSING_SET_OBJECT = {\n  message: 'Missing setObject',\n  code: 'ERR_MISSING_SET_ATTRIBUTE',\n};\nexport const MISSING_SET_NUMBER = {\n  message: 'Missing setNumber',\n  code: 'ERR_MISSING_SET_NUMBER',\n};\nexport const MISSING_SIDE_NUMBER = {\n  message: 'Missing sideNumber',\n  code: 'ERR_MISSING_SIDE_NUMBER',\n};\nexport const MISSING_COURT_ID = {\n  message: 'Missing courtId',\n  code: 'ERR_MISSING_COURT_ID',\n};\nexport const MISSING_VALUE = {\n  message: 'Missing value',\n  code: 'ERR_MISSING_VALUE',\n};\nexport const MISSING_DATE = {\n  message: 'Missing date',\n  code: 'ERR_MISSING_DATE',\n};\nexport const NO_VALID_DATES = {\n  message: 'No valid dates',\n  code: 'ERR_NO_VALID_DATES',\n};\n\nexport const INVALID_BOOKINGS = {\n  message: 'Invalid bookings',\n  code: 'ERR_INVALID_BOOKINGS',\n};\nexport const INVALID_DATE_AVAILABILITY = {\n  message: 'Invalid dateAvailability',\n  code: 'ERR_INVALID_DATE_AVAILABILITY',\n};\nexport const MISSING_DATE_AVAILABILITY = {\n  message: 'Missing dateAvailability',\n  code: 'ERR_MISSING_DATE_AVAILABILITY',\n};\n\n// Javascript constant for Date() function\nexport const INVALID_DATE = {\n  message: 'Invalid Date',\n  code: 'ERR_INVALID_DATE',\n};\nexport const INVALID_TIME = {\n  message: 'Invalid time',\n  code: 'ERR_INVALID_TIME',\n};\nexport const INVALID_TOURNAMENT_DATES = {\n  message: 'Invalid tournament dates',\n  code: 'ERR_INVALID_DATES_TOURNAMENT',\n};\nexport const INVALID_TIME_ZONE = {\n  message: 'Invalid Time Zone',\n  code: 'ERR_INVALID_TIME_ZONE',\n};\n\nexport const INVALID_GAME_SCORES = {\n  message: 'Invalid game scores',\n  code: 'ERR_INVALID_SCORES_GAME',\n};\nexport const INVALID_SCORE = {\n  message: 'Invalid score',\n  code: 'ERR_INVALID_SCORE',\n};\n\nexport const INVALID_WINNING_SIDE = {\n  message: 'Invalid winningSide',\n  code: 'ERR_INVALID_WINNING_SIDE',\n};\n\nexport const NO_PARTICIPANTS = {\n  message: 'Tournament has no participants',\n  code: 'ERR_NO_TOURNAMENT_PARTICIPANTS',\n};\nexport const NO_PARTICIPANTS_GENERATED = {\n  message: 'No participants generated',\n  code: 'ERR_NO_PARTICIPANTS_GENERATED',\n};\nexport const CANNOT_MODIFY_TIEFORMAT = {\n  message: 'Cannot modify tieFormat',\n  code: 'ERR_UNCHANGED_CANNOT_MODIFY_TIEFORMAT',\n};\nexport const CANNOT_MODIFY_PARTICIPANT_TYPE = {\n  message: 'Cannot modify participantType',\n  code: 'ERR_UNCHANGED_CANNOT_MODIFY_PARTICIPANT_TYPE',\n};\nexport const CANNOT_REMOVE_PARTICIPANTS = {\n  message: 'Cannot remove participants',\n  code: 'ERR_UNCHANGED_CANNOT_REMOVE_PARTICIPANTS',\n};\nexport const CANNOT_CHANGE_WINNING_SIDE = {\n  message: 'Cannot change winningSide',\n  code: 'ERR_UNCHANGED_CANNOT_CHANGE_WINNING_SIDE',\n};\nexport const INVALID_PARTICIPANT = {\n  message: 'Invalid participant',\n  code: 'ERR_INVALID_PARTICIPANT',\n};\nexport const INVALID_PARTICIPANT_ID = {\n  message: 'Invalid participantId',\n  code: 'ERR_INVALID_PARTICIPANT_ID',\n};\nexport const INVALID_PARTICIPANT_IDS = {\n  message: 'Invalid participantIds',\n  code: 'ERR_INVALID_PARTICIPANT_IDS',\n};\nexport const INVALID_PARTICIPANT_ROLE = {\n  message: 'Invalid participantRole',\n  code: 'ERR_INVALID_PARTICIPANT_ROLE',\n};\nexport const INVALID_PARTICIPANT_TYPE = {\n  message: 'Invalid participantType',\n  code: 'ERR_INVALID_PARTICIPANT_TYPE',\n};\nexport const MISSING_PARTICIPANT_ROLE = {\n  message: 'Missing participantRole',\n  code: 'ERR_MISSING_PARTICIPANT_ROLE',\n};\nexport const MISSING_PARTICIPANT = {\n  message: 'Missing participant',\n  code: 'ERR_MISSING_PARTICIPANT',\n};\nexport const MISSING_PARTICIPANTS = {\n  message: 'Missing participants',\n  code: 'ERR_MISSING_PARTICIPANTS',\n};\nexport const MISSING_PARTICIPANT_ID = {\n  message: 'Missing participantId',\n  code: 'ERR_MISSING_PARTICIPANT_ID',\n};\nexport const PARTICIPANT_NOT_FOUND = {\n  message: 'Participant Not Found',\n  code: 'ERR_NOT_FOUND_PARTICIPANT',\n};\nexport const PARTICIPANT_ID_EXISTS = {\n  message: 'participantId exists',\n  code: 'ERR_EXISTING_PARTICIPANT_ID',\n};\nexport const PARTICIPANT_PAIR_EXISTS = {\n  message: 'participant pair exists',\n  code: 'ERR_EXISTING_PARTICIPANT_PAIR',\n};\nexport const NO_PARTICIPANT_REMOVED = {\n  message: 'No participant removed',\n  code: 'ERR_UNCHANGED_NO_PARTICIPANT_REMOVED',\n};\nexport const MISSING_PARTICIPANT_IDS = {\n  message: 'Missing participantIds',\n  code: 'ERR_MISSING_PARTICIPANT_IDS',\n};\nexport const MISSING_PARTICIPANT_COUNT = {\n  message: 'Missing participantsCount',\n  code: 'ERR_MISSING_PARTICIPANT_COUNT',\n};\nexport const PARTICIPANT_NOT_CHECKED_IN = {\n  message: 'Participant not checked in',\n  code: 'ERR_UNCHANGED_PARTICIPANT_NOT_CHECKED_IN',\n};\n\nexport const MISSING_PERSON_DETAILS = {\n  message: 'Missing person details',\n  code: 'ERR_MISSING_PERSON_DETAILS',\n};\n\nexport const EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT = {\n  message: 'Existing participant drawPosition assignment',\n  code: 'ERR_EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT',\n};\nexport const EXISTING_PARTICIPANT = {\n  message: 'Existing participant',\n  code: 'ERR_EXISTING_PARTICIPANT',\n};\nexport const PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE = {\n  message: 'participantsCount exceeds drawSize',\n  code: 'ERR_INVALID_PARTICIPANT_COUNT',\n};\n\nexport const INVALID_ENTRY_STATUS = {\n  message: 'Invalid entry status',\n  code: 'ERR_INVALID_ENTRY_STATUS',\n};\nexport const PARTICIPANT_ENTRY_NOT_FOUND = {\n  message: 'Participant Entry Not Found',\n  code: 'ERR_NOT_FOUND_PARTICIPANT_ENTRY',\n};\nexport const PARTICIPANT_NOT_ENTERED_IN_STAGE = {\n  message: 'Participant not entered in stage',\n  code: 'ERR_UNCHANGED_PARTICIPANT_NOT_ENTERED',\n};\nexport const PARTICIPANT_NOT_FOUND_IN_STAGE = {\n  message: 'Participant not found in stageSequence',\n  code: 'ERR_NOT_FOUND_PARTICIPANT_IN_STAGE',\n};\nexport const ENTRY_STATUS_NOT_ALLOWED_IN_STAGE = {\n  message: 'entryStatus not allowed in stage',\n  code: 'ERR_INVALID_ENTRY_STATUS_IN_STAGE',\n};\nexport const ENTRY_STATUS_NOT_ALLOWED_FOR_EVENT = {\n  message: 'entryStatus not allowed for event',\n  code: 'ERR_INVALID_ENTRY_STATUS_IN_EVENT',\n};\nexport const NO_STAGE_SPACE_AVAILABLE_FOR_ENTRY_STATUS = {\n  message: 'No stage space available for entryStatus',\n  code: 'ERR_UNCHANGED_NO_AVAILABLE_STAGE_SPACE',\n};\n\nexport const NO_DRAW_POSITIONS_AVAILABLE_FOR_QUALIFIERS = {\n  message: 'Insufficient drawPositions to accommodate qualifiers',\n  code: 'ERR_UNCHANGED_NO_DRAW_POSITIONS_FOR_QUALIFIERS',\n};\nexport const INSUFFICIENT_DRAW_POSITIONS = {\n  message: 'Insufficient drawPositions to accommodate entries',\n  code: 'ERR_INSUFFICIENT_DRAW_POSITIONS',\n};\n\nexport const MISSING_PENALTY_TYPE = {\n  message: 'Missing penaltyType',\n  code: 'ERR_MISSING_PENALTY_TYPE',\n};\nexport const MISSING_PENALTY_ID = {\n  message: 'Missing penaltyId',\n  code: 'ERR_MISSING_PENALTY_ID',\n};\nexport const PENALTY_NOT_FOUND = {\n  message: 'Penalty not found',\n  code: 'ERR_NOT_FOUND_PENALTY',\n};\n\nexport const MISSING_COURTS_INFO = {\n  message: 'Missing courtsCount/courtNames',\n  code: 'ERR_MISSING_COURTS_INFO',\n};\nexport const COURT_NOT_FOUND = {\n  message: 'Court not found',\n  code: 'ERR_NOT_FOUND_COURT',\n};\nexport const COURT_EXISTS = {\n  message: 'Court exists',\n  code: 'ERR_EXISTING_COURT',\n};\n\nexport const VENUE_EXISTS = {\n  message: 'Venue exists',\n  code: 'ERR_EXISTING_VENUE',\n};\nexport const VENUE_NOT_FOUND = {\n  message: 'Venue not found',\n  code: 'ERR_NOT_FOUND_VENUE',\n};\nexport const MISSING_VENUE_ID = {\n  message: 'Missing venueId',\n  code: 'ERR_MISSING_VENUE_ID',\n};\n\nexport const INVALID_END_TIME = {\n  message: 'Invalid endTime',\n  code: 'ERR_INVALID_END_TIME',\n};\nexport const EXISTING_END_TIME = {\n  message: 'Existing endTime',\n  code: 'ERR_EXISTING_END_TIME',\n};\nexport const INVALID_STOP_TIME = {\n  message: 'Invalid stopTime',\n  code: 'ERR_INVALID_STOP_TIME',\n};\nexport const INVALID_START_TIME = {\n  message: 'Invalid startTime',\n  code: 'ERR_INVALID_START_TIME',\n};\nexport const INVALID_RESUME_TIME = {\n  message: 'Invalid resumeTime',\n  code: 'ERR_INVALID_RESUME_TIME',\n};\nexport const INVALID_TIME_ITEM = {\n  message: 'Invalid timeItem',\n  code: 'ERR_INVALID_TIME_ITEMS',\n};\nexport const MISSING_ASYNC_STATE_PROVIDER = {\n  message: 'Missing async state provider',\n  code: 'ERR_MISSING_ASYNC_STATE_PROVIDER',\n};\nexport const MISSING_TIME_ITEM = {\n  message: 'Missing timeItem',\n  code: 'ERR_MISSING_TIME_ITEM',\n};\nexport const MISSING_TIME_ITEMS = {\n  message: 'Missing timeItems',\n  code: 'ERR_MISSING_TIME_ITEMS',\n};\nexport const MISSING_CONTEXT = {\n  message: 'Missing context',\n  code: 'ERR_MISSING_CONTEXT',\n};\nexport const MISSING_SCHEDULE = {\n  message: 'Missing schedule',\n  code: 'ERR_MISSING_SCHEDULE',\n};\n\nexport const INVALID_SCALE_ITEM = {\n  message: 'Invalid scaleItem',\n  code: 'ERR_INVALID_SCALE_ITEM',\n};\n\nexport const MODIFICATIONS_FAILED = {\n  message: 'Modifications failed',\n  code: 'ERR_FAILURE_MODIFICATIONS',\n};\nexport const NO_MODIFICATIONS_APPLIED = {\n  message: 'No modifications applied',\n  code: 'ERR_UNCHANGED_NO_MODIFICATIONS_APPLIED',\n};\n\nexport const UNABLE_TO_ASSIGN_COURT = {\n  message: 'Unable to assign court',\n  code: 'ERR_UNCHANGED_COURT_NOT_ASSIGNED',\n};\n\nexport const NO_CANDIDATES = {\n  message: 'No Candidates',\n  code: 'ERR_UNCHANGED_NO_CANDIDATES',\n};\n\nexport const INVALID_CONFIGURATION = {\n  message: 'Invalid configuration',\n  code: 'ERR_INVALID_CONFIG',\n};\nexport const INVALID_COLLECTION_DEFINITION = {\n  message: 'Invalid collectionDefinition',\n  code: 'ERR_INVALID_COLLECTION_DEFINITION',\n};\nexport const INVALID_OBJECT = {\n  message: 'Invalid object',\n  code: 'ERR_INVALID_OBJECT',\n};\nexport const INVALID_GENDER = {\n  message: 'Invalid gender',\n  code: 'ERR_INVALID_GENDER',\n};\nexport const INVALID_CATEGORY = {\n  message: 'Invalid category',\n  code: 'ERR_INVALID_CATEGORY',\n};\nexport const INVALID_VALUES = {\n  message: 'Invalid values',\n  code: 'ERR_INVALID_VALUES',\n};\nexport const DUPLICATE_VALUE = {\n  message: 'Duplicate value',\n  code: 'ERR_DUPLICATE_VALUE',\n};\n\nexport const TEAM_NOT_FOUND = {\n  message: 'Team not found',\n  code: 'ERR_NOT_FOUND_TEAM',\n};\nexport const NO_VALID_ACTIONS = {\n  message: 'No valid actions',\n  code: 'ERR_NO_VALID_ACTIONS',\n};\nexport const NO_VALID_ATTRIBUTES = {\n  message: 'No valid attributes',\n  code: 'ERR_NO_VALID_ATTRIBUTES',\n};\n\nexport const VALUE_UNCHANGED = {\n  message: 'Value unchanged',\n  code: 'ABORT_UNCHANGED',\n};\nexport const NOT_FOUND = { message: 'Not found', code: 'ERR_NOT_FOUND' };\nexport const NOT_IMPLEMENTED = {\n  message: 'Not implemented',\n  code: 'ERR_NOT_IMPLEMENTED',\n};\n\nexport const EXISTING_FLIGHT = {\n  message: 'Existing flight',\n  code: 'ERR_EXISTING_FLIGHT',\n};\nexport const EXISTING_PROFILE = {\n  message: 'Existing flight profile',\n  code: 'ERR_EXISTING_FLIGHT_PROFILE',\n};\nexport const EXISTING_OUTCOME = {\n  message: 'Existing outcome',\n  code: 'ERR_EXISTING_OUTCOME',\n};\n\nexport const EXISTING_MATCHUP_ID = {\n  message: 'Existing matchUpId',\n  code: 'ERR_EXISTING_MATCHUP_ID',\n};\n\nexport const EXISTING_STAGE = {\n  message: 'Existing stage',\n  code: 'ERR_EXISTING_STAGE',\n};\n\nexport const EXISTING_STRUCTURE = {\n  message: 'Existing structure',\n  code: 'ERR_EXISTING_STRUCTURE',\n};\n\nexport const METHOD_NOT_FOUND = {\n  message: 'Method not found',\n  code: 'ERR_NOT_FOUND_METHOD',\n};\n\nexport const SCHEDULED_MATCHUPS = {\n  message: 'Scheduled matchUps',\n  code: 'ERR_SCHEDULED_MATCHUPS',\n};\n\nexport const SCORES_PRESENT = {\n  message: 'Scores present',\n  code: 'ERR_SCORES_PRESENT',\n};\n\nexport const errorConditionConstants = {\n  ANACHRONISM,\n  CANNOT_CHANGE_WINNING_SIDE,\n  CANNOT_MODIFY_TIEFORMAT,\n  CANNOT_MODIFY_PARTICIPANT_TYPE,\n  CANNOT_REMOVE_MAIN_STRUCTURE,\n  CANNOT_REMOVE_PARTICIPANTS,\n  COURT_EXISTS,\n  COURT_NOT_FOUND,\n  DRAW_DEFINITION_NOT_FOUND,\n  DRAW_ID_EXISTS,\n  DRAW_POSITION_ACTIVE,\n  DRAW_POSITION_ASSIGNED,\n  DRAW_POSITION_NOT_CLEARED,\n  DRAW_POSITION_NOT_FOUND,\n  DRAW_SIZE_MISMATCH,\n  DUPLICATE_VALUE,\n  ENTRY_STATUS_NOT_ALLOWED_FOR_EVENT,\n  ENTRY_STATUS_NOT_ALLOWED_IN_STAGE,\n  EVENT_EXISTS,\n  EVENT_NOT_FOUND,\n  EXISTING_DRAW_DEFINITIONS,\n  EXISTING_END_TIME,\n  EXISTING_FLIGHT,\n  EXISTING_MATCHUP_ID,\n  EXISTING_OUTCOME,\n  EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT,\n  EXISTING_PARTICIPANT,\n  EXISTING_POLICY_TYPE,\n  EXISTING_PROFILE,\n  EXISTING_ROUND,\n  EXISTING_STAGE,\n  EXISTING_STRUCTURE,\n  INCOMPATIBLE_MATCHUP_STATUS,\n  INCOMPLETE_SOURCE_STRUCTURE,\n  INSUFFICIENT_DRAW_POSITIONS,\n  INVALID_ACTION,\n  INVALID_ASSIGNMENT,\n  INVALID_BOOKINGS,\n  INVALID_CATEGORY,\n  INVALID_COLLECTION_DEFINITION,\n  INVALID_CONFIGURATION,\n  INVALID_DATE_AVAILABILITY,\n  INVALID_DATE,\n  INVALID_DRAW_DEFINITION,\n  INVALID_DRAW_POSITION_FOR_SEEDING,\n  INVALID_DRAW_POSITION,\n  INVALID_DRAW_SIZE,\n  INVALID_END_TIME,\n  INVALID_ENTRIES,\n  INVALID_EVENT_TYPE,\n  INVALID_GAME_SCORES,\n  INVALID_GENDER,\n  INVALID_MATCHUP_FORMAT,\n  INVALID_MATCHUP_STATUS,\n  INVALID_MATCHUP_STATUS_BYE,\n  INVALID_MATCHUP,\n  INVALID_OBJECT,\n  INVALID_PARTICIPANT_ID,\n  INVALID_PARTICIPANT_IDS,\n  INVALID_PARTICIPANT_ROLE,\n  INVALID_PARTICIPANT_SEEDING,\n  INVALID_PARTICIPANT_TYPE,\n  INVALID_PARTICIPANT,\n  INVALID_POLICY_DEFINITION,\n  INVALID_RECORDS,\n  INVALID_SCALE_ITEM,\n  INVALID_SEED_NUMBER,\n  INVALID_SEED_POSITION,\n  INVALID_SET_NUMBER,\n  INVALID_SIDE_NUMBER,\n  INVALID_SCORE,\n  INVALID_STAGE,\n  INVALID_START_TIME,\n  INVALID_STRUCTURE,\n  INVALID_STOP_TIME,\n  INVALID_TIE_FORMAT,\n  INVALID_TIME,\n  INVALID_TIME_ITEM,\n  INVALID_TOURNAMENT_DATES,\n  INVALID_TOURNAMENT_RECORD,\n  INVALID_VALUES,\n  INVALID_WINNING_SIDE,\n  MATCHUP_NOT_FOUND,\n  METHOD_NOT_FOUND,\n  MISSING_ASSIGNMENTS,\n  MISSING_ASYNC_STATE_PROVIDER,\n  MISSING_AVOIDANCE_POLICY,\n  MISSING_COLLECTION_DEFINITION,\n  MISSING_COURT_ID,\n  MISSING_COURTS_INFO,\n  MISSING_DATE_AVAILABILITY,\n  MISSING_DATE,\n  MISSING_DRAW_DEFINITION,\n  MISSING_DRAW_ID,\n  MISSING_DRAW_POSITION,\n  MISSING_DRAW_POSITIONS,\n  MISSING_DRAW_SIZE,\n  MISSING_ENTRIES,\n  MISSING_EVENT,\n  MISSING_MATCHUP_FORMAT,\n  MISSING_MATCHUP_ID,\n  MISSING_MATCHUP_IDS,\n  MISSING_MATCHUP,\n  MISSING_MATCHUPS,\n  MISSING_PARTICIPANT_COUNT,\n  MISSING_PARTICIPANT_ID,\n  MISSING_PARTICIPANT_IDS,\n  MISSING_PARTICIPANT_ROLE,\n  MISSING_PARTICIPANT,\n  MISSING_PARTICIPANTS,\n  MISSING_PENALTY_ID,\n  MISSING_PENALTY_TYPE,\n  MISSING_PERSON_DETAILS,\n  MISSING_POLICY_ATTRIBUTES,\n  MISSING_POLICY_DEFINITION,\n  MISSING_POLICY_TYPE,\n  MISSING_POSITION_ASSIGNMENTS,\n  MISSING_ROUND_NUMBER,\n  MISSING_SCHEDULE,\n  MISSING_SCORING_POLICY,\n  MISSING_SEED_ASSIGNMENTS,\n  MISSING_SEEDCOUNT_THRESHOLDS,\n  MISSING_SEEDING_POLICY,\n  MISSING_SET_NUMBER,\n  MISSING_SET_OBJECT,\n  MISSING_SIDE_NUMBER,\n  MISSING_STAGE,\n  MISSING_STRUCTURE_ID,\n  MISSING_STRUCTURE,\n  MISSING_STRUCTURES,\n  MISSING_TARGET_LINK,\n  MISSING_TIE_FORMAT,\n  MISSING_TIME_ITEM,\n  MISSING_TIME_ITEMS,\n  MISSING_TOURNAMENT_ID,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_TOURNAMENT_RECORDS,\n  MISSING_VALUE,\n  MISSING_VENUE_ID,\n  MODIFICATIONS_FAILED,\n  NO_CANDIDATES,\n  NO_DRAW_POSITIONS_AVAILABLE_FOR_QUALIFIERS,\n  NO_MODIFICATIONS_APPLIED,\n  NO_STAGE_SPACE_AVAILABLE_FOR_ENTRY_STATUS,\n  NO_PARTICIPANT_REMOVED,\n  NO_VALID_ACTIONS,\n  NO_VALID_ATTRIBUTES,\n  NO_VALID_DATES,\n  NOT_FOUND,\n  NOT_IMPLEMENTED,\n  PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE,\n  PARTICIPANT_ID_EXISTS,\n  PARTICIPANT_NOT_CHECKED_IN,\n  PARTICIPANT_NOT_FOUND,\n  PARTICIPANT_PAIR_EXISTS,\n  PENALTY_NOT_FOUND,\n  POLICY_NOT_ATTACHED,\n  POLICY_NOT_FOUND,\n  SCHEDULE_NOT_CLEARED,\n  SCHEDULED_MATCHUPS,\n  SCORES_PRESENT,\n  SEEDSCOUNT_GREATER_THAN_DRAW_SIZE,\n  STAGE_SEQUENCE_LIMIT,\n  STRUCTURE_NOT_FOUND,\n  TEAM_NOT_FOUND,\n  UNABLE_TO_ASSIGN_COURT,\n  UNLINKED_STRUCTURES,\n  UNRECOGNIZED_DRAW_TYPE,\n  UNRECOGNIZED_MATCHUP_FORMAT,\n  UNRECOGNIZED_MATCHUP_STATUS,\n  VALUE_UNCHANGED,\n  VENUE_EXISTS,\n};\n\nexport default errorConditionConstants;\n","import { Tournament } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  CallListenerArgs,\n  DeleteNoticeArgs,\n  GetNoticesArgs,\n  HandleCaughtErrorArgs,\n  ImplemtationGlobalStateTypes,\n  Notice,\n} from './globalState';\nimport {\n  INVALID_TOURNAMENT_RECORD,\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORD,\n  NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\nconst syncGlobalState: ImplemtationGlobalStateTypes = {\n  disableNotifications: false,\n  tournamentId: undefined,\n  tournamentRecords: {},\n  subscriptions: {},\n  modified: false,\n  methods: {},\n  notices: [],\n};\n\nexport default {\n  addNotice,\n  callListener,\n  cycleMutationStatus,\n  deleteNotice,\n  deleteNotices,\n  disableNotifications,\n  enableNotifications,\n  getMethods,\n  getNotices,\n  getTopics,\n  getTournamentId,\n  getTournamentRecord,\n  getTournamentRecords,\n  removeTournamentRecord,\n  setMethods,\n  setSubscriptions,\n  setTournamentId,\n  setTournamentRecord,\n  setTournamentRecords,\n  handleCaughtError,\n};\n\nexport function disableNotifications(): void {\n  syncGlobalState.disableNotifications = true;\n}\n\nexport function enableNotifications(): void {\n  syncGlobalState.disableNotifications = false;\n}\n\nexport function getTournamentId(): string | undefined {\n  return syncGlobalState.tournamentId;\n}\n\nexport function getTournamentRecord(tournamentId): Tournament {\n  return syncGlobalState.tournamentRecords[tournamentId];\n}\n\nexport function getTournamentRecords() {\n  return syncGlobalState.tournamentRecords;\n}\n\nexport function setTournamentRecord(tournamentRecord) {\n  const tournamentId = tournamentRecord?.tournamentId;\n  if (tournamentId) {\n    syncGlobalState.tournamentRecords[tournamentId] = tournamentRecord;\n    return { success: true };\n  } else {\n    return { error: INVALID_TOURNAMENT_RECORD };\n  }\n}\n\nexport function setTournamentId(tournamentId) {\n  if (!tournamentId) {\n    syncGlobalState.tournamentId = undefined;\n    return { success: true };\n  }\n  if (syncGlobalState.tournamentRecords[tournamentId]) {\n    syncGlobalState.tournamentId = tournamentId;\n    return { success: true };\n  } else {\n    return { error: MISSING_TOURNAMENT_RECORD };\n  }\n}\n\nexport function setTournamentRecords(tournamentRecords: {\n  [key: string]: Tournament;\n}): void {\n  syncGlobalState.tournamentRecords = tournamentRecords;\n  const tournamentIds = Object.keys(tournamentRecords);\n  if (tournamentIds.length === 1) {\n    syncGlobalState.tournamentId = tournamentIds[0];\n  } else if (!tournamentIds.length) {\n    syncGlobalState.tournamentId = undefined;\n  }\n}\n\nexport function removeTournamentRecord(tournamentId) {\n  if (typeof tournamentId !== 'string') return { error: INVALID_VALUES };\n  if (!syncGlobalState.tournamentRecords[tournamentId])\n    return { error: NOT_FOUND };\n\n  delete syncGlobalState.tournamentRecords[tournamentId];\n  const tournamentIds = Object.keys(syncGlobalState.tournamentRecords);\n  if (tournamentIds.length === 1) {\n    syncGlobalState.tournamentId = tournamentIds[0];\n  } else if (!tournamentIds.length) {\n    syncGlobalState.tournamentId = undefined;\n  }\n  return { success: true };\n}\n\nexport function setSubscriptions(params) {\n  if (typeof params.subscriptions !== 'object')\n    return { error: INVALID_VALUES };\n  Object.keys(params.subscriptions).forEach((subscription) => {\n    syncGlobalState.subscriptions[subscription] =\n      params.subscriptions[subscription];\n  });\n  return { ...SUCCESS };\n}\nexport function setMethods(params) {\n  Object.keys(params).forEach((methodName) => {\n    if (typeof params[methodName] !== 'function') return;\n    syncGlobalState.methods[methodName] = params[methodName];\n  });\n  return { ...SUCCESS };\n}\n\nexport function cycleMutationStatus() {\n  const status = syncGlobalState.modified;\n  syncGlobalState.modified = false;\n  return status;\n}\n\nexport function addNotice({ topic, payload, key }: Notice) {\n  if (typeof topic !== 'string' || typeof payload !== 'object') {\n    return;\n  }\n\n  if (!syncGlobalState.disableNotifications) syncGlobalState.modified = true;\n\n  if (\n    syncGlobalState.disableNotifications ||\n    !syncGlobalState.subscriptions[topic]\n  ) {\n    return;\n  }\n\n  if (key) {\n    syncGlobalState.notices = syncGlobalState.notices.filter(\n      (notice) => !(notice.topic === topic && notice.key === key)\n    );\n  }\n\n  syncGlobalState.notices.push({ topic, payload, key });\n\n  return { ...SUCCESS };\n}\n\nexport function getMethods() {\n  return syncGlobalState.methods ?? {};\n}\n\nexport function getNotices({ topic }: GetNoticesArgs) {\n  const notices = syncGlobalState.notices\n    .filter((notice) => notice.topic === topic)\n    .map((notice) => notice.payload);\n  return notices.length && notices;\n}\n\nexport function deleteNotices() {\n  syncGlobalState.notices = [];\n}\n\nexport function deleteNotice({ topic, key }: DeleteNoticeArgs) {\n  syncGlobalState.notices = syncGlobalState.notices.filter(\n    (notice) => (!topic || notice.topic === topic) && notice.key !== key\n  );\n}\n\nexport function getTopics(): { topics: string[] } {\n  const topics: string[] = Object.keys(syncGlobalState.subscriptions);\n  return { topics };\n}\n\nexport function callListener({ topic, notices }: CallListenerArgs) {\n  const method = syncGlobalState.subscriptions[topic];\n  if (method && typeof method === 'function') {\n    method(notices);\n  }\n}\n\nexport function handleCaughtError({\n  engineName,\n  methodName,\n  params,\n  err,\n}: HandleCaughtErrorArgs) {\n  let error;\n  if (typeof err === 'string') {\n    error = err.toUpperCase();\n  } else if (err instanceof Error) {\n    error = err.message;\n  }\n\n  console.log('ERROR', {\n    tournamentId: getTournamentId(),\n    params: JSON.stringify(params),\n    engine: engineName,\n    methodName,\n    error,\n  });\n\n  return { error };\n}\n","import { intersection } from '../../utilities/arrays';\nimport syncGlobalState from './syncGlobalState';\n\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport { ResultType } from '../functions/decorateResult';\nimport {\n  ErrorType,\n  INVALID_VALUES,\n  MISSING_ASYNC_STATE_PROVIDER,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\nexport type Notice = {\n  topic: string;\n  payload: any;\n  key?: string;\n};\n\ntype TimerType = {\n  elapsedTime: number;\n  startTime?: number;\n  state?: string;\n};\ntype timersType = {\n  [key: string]: TimerType;\n  default: TimerType;\n};\n\ntype DeepCopyType = {\n  threshold?: number;\n  modulate?: any;\n  stringify: string[];\n  ignore: any;\n  toJSON: string[];\n};\n\nexport type DevContextType =\n  | {\n      errors?: boolean | string[]; // log errors for all methods or specified methods\n      params?: boolean | string[]; // log params for all methods or specified methods\n      result?: boolean | string[]; // log result for all methods or specified methods\n      exclude?: string[]; // exclude logging for specified methods\n      [key: string]: any;\n    }\n  | boolean;\n\ntype GlobalStateTypes = {\n  tournamentFactoryVersion: string; // version of tournamentFactory\n  deepCopyAttributes: DeepCopyType;\n  devContext?: DevContextType; // devContext is used to control logging\n  timers: timersType; // timers are used to track elapsed time for methods\n  deepCopy: boolean;\n  globalLog?: any;\n};\n\nexport type ImplemtationGlobalStateTypes = {\n  tournamentRecords: TournamentRecords;\n  tournamentId?: string | undefined;\n  methods: { [key: string]: any };\n  disableNotifications: boolean;\n  subscriptions: any;\n  notices: Notice[];\n  modified: boolean;\n};\n\nconst globalState: GlobalStateTypes = {\n  tournamentFactoryVersion: '0.0.0',\n  timers: { default: { elapsedTime: 0 } },\n  deepCopyAttributes: {\n    stringify: [],\n    ignore: [],\n    toJSON: [],\n  },\n  deepCopy: true,\n};\n\nlet _globalStateProvider: any = syncGlobalState;\n\nconst requiredStateProviderMethods = [\n  'addNotice',\n  'callListener',\n  'cycleMutationStatus',\n  'deleteNotice',\n  'deleteNotices',\n  'disableNotifications',\n  'enableNotifications',\n  'getMethods',\n  'getNotices',\n  'getTopics',\n  'getTournamentId',\n  'getTournamentRecord',\n  'getTournamentRecords',\n  'removeTournamentRecord',\n  'setSubscriptions',\n  'setTournamentId',\n  'setTournamentRecord',\n  'setTournamentRecords',\n];\n\nexport function setStateProvider(globalStateProvider?: { [key: string]: any }) {\n  if (typeof globalStateProvider !== 'object') {\n    throw new Error(`Global state provider can not be undefined or null`);\n  } else {\n    const providerMethods = intersection(\n      Object.keys(globalStateProvider),\n      requiredStateProviderMethods\n    );\n    if (providerMethods.length !== requiredStateProviderMethods.length) {\n      throw new Error('Global state provider is missing required methods');\n    } else {\n      _globalStateProvider = globalStateProvider;\n      return { success: true };\n    }\n  }\n}\n\nexport function createInstanceState() {\n  //Only applicable for async\n  if (_globalStateProvider.createInstanceState) {\n    try {\n      _globalStateProvider.createInstanceState();\n    } catch (error) {\n      return { error };\n    }\n    return { success: true };\n  } else {\n    return { error: MISSING_ASYNC_STATE_PROVIDER };\n  }\n}\n\n/**\n * if contextCriteria, check whether all contextCriteria keys values are equivalent with globalState.devContext object\n */\nexport function getDevContext(contextCriteria?: {\n  [key: string]: any;\n}): DevContextType {\n  if (!contextCriteria || typeof contextCriteria !== 'object') {\n    return globalState.devContext ?? false;\n  } else {\n    if (typeof globalState.devContext !== 'object') return false;\n    return (\n      Object.keys(contextCriteria).every(\n        (key) => globalState.devContext?.[key] === contextCriteria[key]\n      ) && globalState.devContext\n    );\n  }\n}\n\nexport function timeKeeper(\n  action: string = 'reset',\n  timer: string = 'default'\n): any {\n  const timeNow = Date.now();\n\n  if (action === 'report') {\n    if (timer === 'allTimers') {\n      const timers = Object.keys(globalState.timers);\n      return timers\n        .filter(\n          (timer) => timer !== 'default' || globalState.timers[timer].startTime\n        )\n        .map((timer) => {\n          const currentTimer = globalState.timers[timer];\n          const elapsedPeriod =\n            currentTimer.state === 'stopped'\n              ? 0\n              : (timeNow - (currentTimer?.startTime ?? 0)) / 1000;\n\n          const elapsedTime = currentTimer.elapsedTime + elapsedPeriod;\n          return {\n            state: globalState.timers[timer].state,\n            elapsedTime: elapsedTime.toFixed(2),\n            timer,\n          };\n        });\n    } else {\n      const elapsedPeriod =\n        globalState.timers[timer].state === 'stopped'\n          ? 0\n          : (timeNow - (globalState.timers[timer]?.startTime ?? 0)) / 1000;\n\n      const elapsedTime = globalState.timers[timer].elapsedTime + elapsedPeriod;\n\n      return {\n        state: globalState.timers[timer].state,\n        elapsedTime: elapsedTime.toFixed(2),\n        timer,\n      };\n    }\n  }\n\n  if (!globalState.timers[timer] || action === 'reset') {\n    if (timer === 'allTimers') {\n      globalState.timers = { default: { elapsedTime: 0 } };\n      return true;\n    } else {\n      globalState.timers[timer] = {\n        startTime: timeNow,\n        state: 'active',\n        elapsedTime: 0,\n      };\n    }\n  }\n\n  if (!globalState.timers[timer].elapsedTime)\n    globalState.timers[timer].elapsedTime = 0;\n\n  action === 'stop' &&\n    globalState.timers[timer].state !== 'stopped' &&\n    (globalState.timers[timer].state = 'stopped') &&\n    (globalState.timers[timer].elapsedTime +=\n      (timeNow - (globalState.timers[timer]?.startTime ?? 0)) / 1000);\n  action === 'start' &&\n    (globalState.timers[timer].startTime = timeNow) &&\n    (globalState.timers[timer].state = 'active');\n\n  return globalState.timers[timer];\n}\n\nexport function setGlobalLog(loggingFx?: any) {\n  if (typeof loggingFx === 'function') {\n    globalState.globalLog = loggingFx;\n  } else {\n    delete globalState.globalLog;\n  }\n}\n\nexport function setDevContext(value?: DevContextType) {\n  globalState.devContext = value;\n}\n\nexport function disableNotifications() {\n  _globalStateProvider.disableNotifications();\n}\n\nexport function enableNotifications() {\n  _globalStateProvider.enableNotifications();\n}\n\nexport type DeepCopyAttributes = {\n  threshold?: number;\n  stringify?: string[];\n  ignore?: string[];\n  toJSON?: string[];\n};\n\nexport function setDeepCopy(value: boolean, attributes: DeepCopyAttributes) {\n  if (typeof value === 'boolean') {\n    globalState.deepCopy = value;\n  }\n  if (typeof attributes === 'object') {\n    if (Array.isArray(attributes.ignore))\n      globalState.deepCopyAttributes.ignore = attributes.ignore;\n    if (Array.isArray(attributes.toJSON))\n      globalState.deepCopyAttributes.toJSON = attributes.toJSON;\n    if (Array.isArray(attributes.stringify))\n      globalState.deepCopyAttributes.stringify = attributes.stringify;\n    if (attributes.threshold)\n      globalState.deepCopyAttributes.threshold = attributes.threshold;\n  }\n}\n\nexport function deepCopyEnabled() {\n  return {\n    enabled: globalState.deepCopy,\n    ...globalState.deepCopyAttributes,\n  };\n}\n\nexport function setSubscriptions(params: any) {\n  if (!params?.subscriptions)\n    return { error: MISSING_VALUE, info: 'missing subscriptions' };\n  return _globalStateProvider.setSubscriptions({\n    subscriptions: params.subscriptions,\n  });\n}\n\nexport function setMethods(params?: { [key: string]: any }) {\n  if (!params)\n    return { error: MISSING_VALUE, info: 'missing method declarations' };\n  if (typeof params !== 'object') return { error: INVALID_VALUES };\n  return _globalStateProvider.setMethods(params);\n}\n\nexport function cycleMutationStatus() {\n  return _globalStateProvider.cycleMutationStatus();\n}\n\nexport function addNotice(notice: Notice) {\n  return _globalStateProvider.addNotice(notice);\n}\n\nexport type GetNoticesArgs = {\n  topic: string;\n};\n\nexport function getMethods(): { [key: string]: any } {\n  return _globalStateProvider.getMethods();\n}\n\nexport function getNotices(params: GetNoticesArgs): string[] {\n  return _globalStateProvider.getNotices(params);\n}\n\nexport type DeleteNoticeArgs = {\n  topic?: string;\n  key: string;\n};\nexport function deleteNotice({ key, topic }: DeleteNoticeArgs) {\n  return _globalStateProvider.deleteNotice({ key, topic });\n}\n\nexport function deleteNotices() {\n  return _globalStateProvider.deleteNotices();\n}\n\nexport function getTopics() {\n  return _globalStateProvider.getTopics();\n}\n\nexport type CallListenerArgs = {\n  notices: Notice[];\n  topic: string;\n};\nexport async function callListener(payload) {\n  return _globalStateProvider.callListener(payload);\n}\n\nexport function getTournamentId() {\n  return _globalStateProvider.getTournamentId();\n}\n\nexport function getTournamentRecord(tournamentId: string) {\n  return _globalStateProvider.getTournamentRecord(tournamentId);\n}\n\nexport function getTournamentRecords() {\n  return _globalStateProvider.getTournamentRecords();\n}\n\nexport function setTournamentRecord(tournamentRecord: ResultType) {\n  return _globalStateProvider.setTournamentRecord(tournamentRecord);\n}\n\nexport function setTournamentRecords(tournamentRecords: any) {\n  return _globalStateProvider.setTournamentRecords(tournamentRecords);\n}\n\nexport function setTournamentId(tournamentId?: string): {\n  success?: boolean;\n  error?: ErrorType;\n} {\n  return _globalStateProvider.setTournamentId(tournamentId);\n}\n\nexport function removeTournamentRecord(tournamentId: string) {\n  return _globalStateProvider.removeTournamentRecord(tournamentId);\n}\n\nexport function getProvider() {\n  return _globalStateProvider;\n}\n\nexport type HandleCaughtErrorArgs = {\n  engineName?: string;\n  methodName: string;\n  params: any;\n  err: any;\n};\n\nexport function handleCaughtError({\n  engineName,\n  methodName,\n  params,\n  err,\n}: HandleCaughtErrorArgs) {\n  const caughtErrorHandler =\n    (typeof _globalStateProvider.handleCaughtError === 'function' &&\n      _globalStateProvider.handleCaughtError) ||\n    syncGlobalState.handleCaughtError;\n\n  return caughtErrorHandler({\n    engineName,\n    methodName,\n    params,\n    err,\n  });\n}\n\nexport function globalLog(engine: string, log: any) {\n  if (globalState.globalLog) {\n    try {\n      globalState.globalLog({ engine, log });\n    } catch (error) {\n      console.log('globalLog error', error);\n      console.log(engine, log);\n      setGlobalLog(); // delete failing custom globalLog\n    }\n  } else {\n    console.log(engine, log);\n  }\n}\n","import { deepCopyEnabled } from '../global/state/globalState';\n\nfunction getDefinedKeys(obj, ignoreValues, ignoreEmptyArrays) {\n  return Object.keys(obj).filter(\n    (key) =>\n      !ignoreValues.includes(obj[key]) &&\n      (!ignoreEmptyArrays || (Array.isArray(obj[key]) ? obj[key].length : true))\n  );\n}\n\nexport function definedAttributes(\n  obj: object,\n  ignoreFalse?: boolean,\n  ignoreEmptyArrays?: boolean,\n  shallow?: boolean\n) {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  const deepCopy = deepCopyEnabled();\n  if (!deepCopy?.enabled) shallow = true;\n\n  const ignoreValues: any[] = ['', undefined, null];\n  if (ignoreFalse) ignoreValues.push(false);\n\n  const definedKeys = getDefinedKeys(obj, ignoreValues, ignoreEmptyArrays);\n\n  return Object.assign(\n    {},\n    ...definedKeys.map((key) => {\n      return Array.isArray(obj[key])\n        ? {\n            [key]: shallow\n              ? obj[key]\n              : obj[key].map((m) => definedAttributes(m)),\n          } // doesn't filter out undefined array elements\n        : { [key]: shallow ? obj[key] : definedAttributes(obj[key]) };\n    })\n  );\n}\n","import { definedAttributes } from '../../utilities/definedAttributes';\n\nimport { ErrorType } from '../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\n\nexport type ResultType = {\n  context?: { [key: string]: any };\n  stack?: string | string[];\n  error?: ErrorType;\n  errors?: string[];\n  success?: boolean;\n  valid?: boolean;\n  info?: any;\n};\n\ntype DecorateResultArgs = {\n  context?: { [key: string]: any };\n  stack?: string | string[];\n  result: any;\n  info?: any;\n};\n\nexport function decorateResult({\n  context,\n  result,\n  stack,\n  info,\n}: DecorateResultArgs): ResultType {\n  if (result && !Array.isArray(result?.stack)) result.stack = [];\n  if (result && Array.isArray(result?.stack) && typeof stack === 'string') {\n    result.stack.push(stack);\n  }\n  if (result && info) {\n    result.info = info;\n  }\n  if (result && typeof context === 'object' && Object.keys(context).length) {\n    Object.assign(result, definedAttributes(context));\n  }\n\n  if (result && !result?.error && !result?.success) {\n    Object.assign(result, { ...SUCCESS });\n  }\n\n  return result ?? { success: true };\n}\n","export const ELEMENT_REQUIRED = 'element required';\nexport const MISSING_NAME = 'missing name';\n","import { decorateResult } from '../../global/functions/decorateResult';\n\nimport { ELEMENT_REQUIRED, MISSING_NAME } from '../../constants/infoConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ErrorType,\n  INVALID_VALUES,\n  MISSING_VALUE,\n  NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\ntype RemoveExtensionResult = {\n  success?: boolean;\n  error?: ErrorType;\n  info?: any;\n};\nexport function removeExtension(params?): RemoveExtensionResult {\n  if (!params || typeof params !== 'object') return { error: MISSING_VALUE };\n  if (params.element && typeof params?.element !== 'object')\n    return { error: INVALID_VALUES };\n  if (!params?.name) return { error: MISSING_VALUE, info: MISSING_NAME };\n  if (!params?.element) {\n    if (params.discover && params.tournamentRecords) {\n      for (const tournamentId of Object.keys(params.tournamentRecords)) {\n        const tournamentRecord = params.tournamentRecords[tournamentId];\n        const result = removeExtension({\n          element: tournamentRecord,\n          name: params.name,\n        });\n        if (result.error)\n          return decorateResult({ result, stack: 'removeExtension' });\n      }\n      return { ...SUCCESS };\n    }\n    return { error: MISSING_VALUE, info: ELEMENT_REQUIRED };\n  }\n  if (!params?.element.extensions) return { ...SUCCESS, info: NOT_FOUND };\n\n  params.element.extensions = params.element.extensions.filter(\n    (extension) => extension?.name !== params.name\n  );\n\n  return { ...SUCCESS };\n}\n","import { Extension } from '../types/tournamentTypes';\n\ntype IsValidExtensionArgs = {\n  requiredAttributes?: string[];\n  extension: Extension;\n};\nexport function isValidExtension({\n  requiredAttributes = ['name', 'value'],\n  extension,\n}: IsValidExtensionArgs) {\n  if (!extension || typeof extension !== 'object') return false;\n  if (typeof extension.name !== 'string') return false;\n  const extensionAttributes = Object.keys(extension);\n  return (\n    requiredAttributes.filter((attribute) =>\n      extensionAttributes.includes(attribute)\n    ).length === requiredAttributes.length\n  );\n}\n","import { isValidExtension } from '../../validators/isValidExtension';\nimport { decorateResult } from '../../global/functions/decorateResult';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ErrorType,\n  INVALID_VALUES,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport { Extension } from '../../types/tournamentTypes';\n\ntype AddExtensionArgs = {\n  tournamentRecords?: TournamentRecords;\n  activeTournamentId?: string;\n  creationTime?: boolean;\n  tournamentId?: string;\n  extension: Extension;\n  discover?: boolean;\n  element?: any;\n};\n\nexport function addExtension(params?: AddExtensionArgs): {\n  success?: boolean;\n  error?: ErrorType;\n} {\n  if (typeof params !== 'object') return { error: MISSING_VALUE };\n  const stack = 'addExtension';\n\n  if (params?.element && typeof params.element !== 'object')\n    return decorateResult({ result: { error: INVALID_VALUES }, stack });\n\n  if (!isValidExtension({ extension: params.extension }))\n    return decorateResult({\n      result: { error: INVALID_VALUES, info: 'invalid extension' },\n      stack,\n    });\n\n  if (!params.element) {\n    if (params.discover && !params.tournamentId && params.tournamentRecords) {\n      for (const tournamentRecord of Object.values(params.tournamentRecords)) {\n        const result = addExtension({\n          extension: params.extension,\n          element: tournamentRecord,\n        });\n        if (result.error) return decorateResult({ result, stack });\n      }\n      return { ...SUCCESS };\n    } else {\n      return decorateResult({ result: { error: MISSING_VALUE }, stack });\n    }\n  }\n\n  if (!params.element.extensions) params.element.extensions = [];\n\n  const creationTime = params?.creationTime ?? true;\n\n  if (creationTime) {\n    const createdAt = new Date().toISOString();\n    Object.assign(params.extension, { createdAt });\n  }\n\n  const existingExtension = params.element.extensions.find(\n    ({ name }) => name === params.extension.name\n  );\n  if (existingExtension) {\n    existingExtension.value = params.extension.value;\n  } else if (params.extension.value) {\n    params.element.extensions.push(params.extension);\n  }\n\n  return { ...SUCCESS };\n}\n","import { ResultType, decorateResult } from '../global/functions/decorateResult';\nimport { MISSING_VALUE, NOT_FOUND } from '../constants/errorConditionConstants';\nimport { Extension } from '../types/tournamentTypes';\nimport { TournamentRecords } from '../types/factoryTypes';\n\nconst stack = 'extensionQueries';\n\ntype FindExtensionType = {\n  tournamentRecords?: TournamentRecords;\n  params?: { [key: string]: any };\n  discover?: boolean | string[];\n  element?: any;\n  name: string;\n};\n\ntype ExtensionResult = ResultType & {\n  extension?: Extension;\n};\n\nexport function findExtension({\n  discover, // boolean or array of keys to discover extensions on specified params\n  element,\n  name,\n  ...params\n}: FindExtensionType): ExtensionResult {\n  if (!element || !name) {\n    if (discover && params) {\n      const attr = Object.keys(params)\n        .filter(\n          (key) =>\n            typeof discover === 'boolean' ||\n            (Array.isArray(discover) && discover.includes(key))\n        )\n        .find((key) => {\n          if (!Array.isArray(params[key]?.extensions)) return false;\n          return params[key].extensions.find(\n            (extension) => extension?.name === name\n          );\n        });\n\n      let element = attr && params[attr];\n\n      if (!element && params.tournamentRecords) {\n        element = Object.values(params.tournamentRecords).find(\n          (tournamentRecord) => tournamentRecord.extensions?.length\n        );\n      }\n\n      const extension = element?.extensions?.find(\n        (extension) => extension?.name === name\n      );\n      const info = !extension ? NOT_FOUND : undefined;\n\n      return { extension, info };\n    }\n    return decorateResult({ result: { error: MISSING_VALUE }, stack });\n  }\n\n  if (!Array.isArray(element.extensions)) return { info: 'no extensions' };\n\n  const extension = element.extensions.find(\n    (extension) => extension?.name === name\n  );\n\n  const info = !extension ? NOT_FOUND : undefined;\n\n  return { extension, info };\n}\n","export const validDateString =\n  /^[\\d]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][\\d]|3[0-1])$/;\nexport const validTimeString =\n  /^((0[\\d]|1[\\d]|2[0-3]):[0-5][\\d](:[0-5][\\d])?)([.,][0-9]{3})?$/;\nexport const dateValidation =\n  /^([\\d]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][\\d]|3[0-1]))([ T](0[\\d]|1[\\d]|2[0-3]):[0-5][\\d](:[0-5][\\d])?)?([.,][\\d]{3})?Z?$/;\nexport const timeValidation =\n  /^([\\d]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][\\d]|3[0-1]))?([ T]?(0[\\d]|1[\\d]|2[0-3]):[0-5][\\d](:[0-5][\\d])?)?([.,][\\d]{3})?Z?$/;\n","import { dateValidation, timeValidation, validDateString } from '../validators/regex';\n\nexport function getIsoDateString(schedule) {\n  let { scheduledDate } = schedule;\n  if (!scheduledDate && schedule.scheduledTime) scheduledDate = extractDate(schedule.scheduledTime);\n  if (!scheduledDate) return;\n\n  const extractedTime = extractTime(schedule.scheduledTime);\n  let isoDateString = extractDate(scheduledDate);\n  if (isoDateString && extractedTime) isoDateString += `T${extractedTime}`;\n  return isoDateString;\n}\n\nexport function isDateObject(value) {\n  if (typeof value !== 'object' || Array.isArray(value)) {\n    return false;\n  } else {\n    const datePrototype = Object.prototype.toString.call(value);\n    return datePrototype === '[object Date]';\n  }\n}\n\nexport function validTimeValue(value) {\n  const spaceSplit = typeof value === 'string' ? value?.split(' ') : [];\n  if (value && spaceSplit?.length > 1 && !['AM', 'PM'].includes(spaceSplit[1].toUpperCase())) return false;\n\n  return !!(!value || timeValidation.test(convertTime(value, true, true)));\n}\n\nexport function isValidDateString(scheduleDate) {\n  return isISODateString(scheduleDate) || validDateString.test(scheduleDate);\n}\n\nexport function DateHHMM(date) {\n  const dt = new Date(date);\n  const secs = dt.getSeconds() + 60 * dt.getMinutes() + 60 * 60 * dt.getHours();\n  return HHMMSS(secs, { displaySeconds: false });\n}\n\nexport function HHMMSS(s, format?) {\n  const secondNumber = parseInt(s, 10); // don't forget the second param\n  const hours = Math.floor(secondNumber / 3600);\n  const minutes = Math.floor((secondNumber - hours * 3600) / 60);\n  const seconds = secondNumber - hours * 3600 - minutes * 60;\n\n  const displaySeconds = !format || format?.displaySeconds;\n  const timeString = displaySeconds ? hours + ':' + minutes + ':' + seconds : hours + ':' + minutes;\n  return timeString.split(':').map(zeroPad).join(':');\n}\n\nexport const getUTCdateString = (date?) => {\n  const dateDate = isDate(date) || isISODateString(date) ? new Date(date) : new Date();\n  const monthNumber = dateDate.getUTCMonth() + 1;\n  const utcMonth = monthNumber < 10 ? `0${monthNumber}` : `${monthNumber}`;\n  return `${dateDate.getUTCFullYear()}-${zeroPad(utcMonth)}-${zeroPad(dateDate.getUTCDate())}`;\n};\n\nexport function timeUTC(date?) {\n  const dateDate = isDate(date) || isISODateString(date) ? new Date(date) : new Date();\n  return Date.UTC(dateDate.getFullYear(), dateDate.getMonth(), dateDate.getDate());\n}\n\nexport function localizeDate(submittedDate, dateLocalization, locale) {\n  const date = new Date(submittedDate);\n  if (!isDate(date)) return undefined;\n  const defaultLocalization = {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n  };\n  return date.toLocaleDateString(locale, dateLocalization || defaultLocalization);\n}\n\nexport function formatDate(date?, separator = '-', format = 'YMD') {\n  if (!date) return '';\n  if (typeof date === 'string' && date.indexOf('T') < 0) date = date + 'T00:00';\n\n  const d = new Date(date);\n  let month = '' + (d.getMonth() + 1);\n  let day = '' + d.getDate();\n  const year = d.getFullYear();\n\n  if (month.length < 2) month = '0' + month;\n  if (day.length < 2) day = '0' + day;\n\n  if (format === 'DMY') return [day, month, year].join(separator);\n  if (format === 'MDY') return [month, day, year].join(separator);\n  if (format === 'YDM') return [year, day, month].join(separator);\n  if (format === 'DYM') return [day, year, month].join(separator);\n  if (format === 'MYD') return [month, year, day].join(separator);\n  return [year, month, day].join(separator);\n}\n\nexport function offsetDate(date) {\n  const targetTime = date ? new Date(date) : new Date();\n  const tzDifference = targetTime.getTimezoneOffset();\n  return new Date(targetTime.getTime() - tzDifference * 60 * 1000);\n}\n\nexport function offsetTime(date?) {\n  return offsetDate(date).getTime();\n}\n\n// only returns true for valid date objects\n// dateArg = new Date('xxx') produces 'Invalid Date', which return false\nexport function isDate(dateArg) {\n  if (typeof dateArg == 'boolean') return false;\n  const t = (dateArg instanceof Date && dateArg) || (!isNaN(dateArg) && new Date(dateArg)) || false;\n  return t && !isNaN(t.valueOf());\n}\n\nexport function generateDateRange(startDt?, endDt?) {\n  if (!isValidDateString(startDt) || !isValidDateString(endDt)) return [];\n\n  const startDateString = extractDate(startDt) + 'T00:00';\n  const endDateString = extractDate(endDt) + 'T00:00';\n  const startDate = new Date(startDateString);\n  const endDate = new Date(endDateString);\n  const process = isDate(endDate) && isDate(startDate) && isValidDateRange(startDate, endDate);\n  const between: Date[] = [];\n  let iterations = 0;\n\n  if (process) {\n    const currentDate = startDate;\n    let dateSecs = currentDate.getTime();\n    while (dateSecs <= endDate.getTime() && iterations < 300) {\n      iterations += 1;\n      // must be a *new* Date otherwise it is an array of the same object\n      between.push(new Date(currentDate));\n      dateSecs = currentDate.setDate(currentDate.getDate() + 1);\n    }\n  }\n\n  return between.map((date) => formatDate(date));\n\n  function isValidDateRange(minDate, maxDate) {\n    return minDate <= maxDate;\n  }\n}\n\n// matches valid ISO date string\nconst re =\n  /^([+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([.,]\\d+(?!:))?)?(\\17[0-5]\\d([.,]\\d+)?)?([zZ]|([+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\nexport function isISODateString(dateString) {\n  if (typeof dateString !== 'string') return false;\n  return re.test(dateString);\n}\n\nexport function isTimeString(timeString) {\n  if (typeof timeString !== 'string') return false;\n  const noZ = timeString.split('Z')[0];\n  const parts: string[] = noZ.split(':');\n  const isNumeric = parts.every((part) => !isNaN(parseInt(part)));\n  const invalid = parts.length < 2 || !isNumeric || parseInt(parts[0]) > 23 || parseInt(parts[1]) > 60;\n  return !invalid;\n}\n\nexport function timeStringMinutes(timeString?) {\n  const validTimeString = extractTime(timeString);\n  if (!validTimeString) return 0;\n  const [hours, minutes] = validTimeString.split(':').map((value) => parseInt(value));\n  return hours * 60 + minutes;\n}\n\nexport function dayMinutesToTimeString(totalMinutes) {\n  let hours = Math.floor(totalMinutes / 60);\n  const minutes = totalMinutes - hours * 60;\n  if (hours > 23) hours = hours % 24;\n  return [zeroPad(hours), zeroPad(minutes)].join(':');\n}\n\nexport function tidyTime(timeString) {\n  return isTimeString(timeString) ? timeString.split(':').slice(0, 2).map(zeroPad).join(':') : undefined;\n}\n\nexport function extractTime(dateString) {\n  return isISODateString(dateString) && dateString.indexOf('T') > 0\n    ? tidyTime(dateString.split('T').reverse()[0])\n    : tidyTime(dateString);\n}\n\nexport function extractDate(dateString) {\n  return isISODateString(dateString) || dateValidation.test(dateString) ? dateString.split('T')[0] : undefined;\n}\n\nexport function dateStringDaysChange(dateString, daysChange) {\n  const date = new Date(dateString);\n  date.setDate(date.getDate() + daysChange);\n  return extractDate(date.toISOString());\n}\n\nexport function splitTime(value) {\n  value = typeof value !== 'string' ? '00:00' : value;\n  const o: any = {},\n    time: any = {};\n  ({ 0: o.time, 1: o.ampm } = value.split(' ') || []);\n  ({ 0: time.hours, 1: time.minutes } = o.time.split(':') || []);\n  time.ampm = o.ampm;\n\n  if (isNaN(time.hours) || isNaN(time.minutes) || (time.ampm && !['AM', 'PM'].includes(time.ampm.toUpperCase())))\n    return {};\n  return time;\n}\n\nexport function militaryTime(value?) {\n  const time = splitTime(value);\n  if (time.ampm && time.hours) {\n    if (time.ampm.toLowerCase() === 'pm' && parseInt(time.hours) < 12)\n      time.hours = ((time.hours && parseInt(time.hours)) || 0) + 12;\n    if (time.ampm.toLowerCase() === 'am' && time.hours === '12') time.hours = '00';\n  }\n  const timeString = `${time.hours || '12'}:${time.minutes || '00'}`;\n  return timeString.split(':').map(zeroPad).join(':');\n}\n\nexport function regularTime(value) {\n  const time = splitTime(value);\n  if (typeof time === 'object' && !Object.keys(time).length) return undefined;\n\n  if (time.ampm) return value;\n  if (time.hours > 12) {\n    time.hours -= 12;\n    time.ampm = 'PM';\n  } else if (time.hours === '12') {\n    time.ampm = 'PM';\n  } else if (time.hours === '00') {\n    time.hours = '12';\n    time.ampm = 'AM';\n  } else {\n    time.ampm = 'AM';\n  }\n  if (time.hours?.[0] === '0') {\n    time.hours = time.hours.slice(1);\n  }\n\n  return `${time.hours || '12'}:${time.minutes || '00'} ${time.ampm}`;\n}\n\nexport function convertTime(value, time24?, keepDate?) {\n  const hasDate = extractDate(value);\n  const timeString = extractTime(value);\n  const timeValue = hasDate ? timeString : value;\n\n  return !value\n    ? undefined\n    : (time24 && ((hasDate && keepDate && value) || militaryTime(timeValue))) || regularTime(timeValue);\n}\n\nexport function timeSort(a, b) {\n  const as = splitTime(a);\n  const bs = splitTime(b);\n  if (parseInt(as.hours) < parseInt(bs.hours)) return -1;\n  if (parseInt(as.hours) > parseInt(bs.hours)) return 1;\n  if (as.hours === bs.hours) {\n    if (parseInt(as.minutes) < parseInt(bs.minutes)) return -1;\n    if (parseInt(as.minutes) > parseInt(bs.minutes)) return 1;\n  }\n  return 0;\n}\n\nexport function weekDays(date: any = new Date(), firstDayOfWeek = 0) {\n  if (!isDate(date)) return [];\n  const dates = [0, 1, 2, 3, 4, 5, 6].map((i) => dayOfWeek(date, i + firstDayOfWeek));\n  return dates;\n\n  function dayOfWeek(date, index) {\n    const d = new Date(date);\n    const day = d.getDay();\n    const diff = index - day;\n\n    const nextDate = new Date(d.setDate(d.getDate() + diff));\n    return formatDate(nextDate);\n  }\n}\n\nexport function addDays(date, days = 7) {\n  const universalDate = extractDate(date) + 'T00:00';\n  const now = new Date(universalDate);\n  const adjustedDate = new Date(now.setDate(now.getDate() + days));\n  return formatDate(adjustedDate);\n}\nexport function addWeek(date) {\n  return addDays(date);\n}\nexport function subtractWeek(date, dateFormat?) {\n  const universalDate = extractDate(date) + 'T00:00';\n  const now = new Date(universalDate);\n  return formatDate(now.setDate(now.getDate() - 7), dateFormat);\n}\n\nexport function getDateByWeek(week, year, dateFormat, sunday = false) {\n  const date = new Date(year, 0, 1 + (week - 1) * 7);\n  const startValue = sunday ? 0 : 1;\n  date.setDate(date.getDate() + (startValue - date.getDay()));\n  return formatDate(date, dateFormat);\n}\n\nexport function dateFromDay(year, day, dateFormat?) {\n  const date = new Date(year, 0); // initialize a date in `year-01-01`\n  return formatDate(new Date(date.setDate(day)), dateFormat); // add the number of days\n}\n\nexport function timeToDate(timeString, date = undefined) {\n  const [hours, minutes] = (timeString || '00:00').split(':').map(zeroPad);\n  const milliseconds = offsetDate(date).setHours(hours, minutes, 0, 0);\n  return offsetDate(milliseconds);\n}\n\nexport function minutesDifference(date1, date2, absolute = true) {\n  const dt1 = new Date(date1);\n  const dt2 = new Date(date2);\n  const diff = (dt2.getTime() - dt1.getTime()) / 1000 / 60;\n  return absolute ? Math.abs(Math.round(diff)) : Math.round(diff);\n}\n\nexport function addMinutesToTimeString(timeString?, minutes?) {\n  const validTimeString = extractTime(timeString);\n  if (!validTimeString) return '00:00';\n  const minutesToAdd = isNaN(minutes) ? 0 : minutes;\n  return extractTime(addMinutes(timeToDate(validTimeString), minutesToAdd).toISOString());\n}\n\nexport function addMinutes(startDate, minutes) {\n  const date = new Date(startDate);\n  return new Date(date.getTime() + minutes * 60000);\n}\n\nexport function zeroPad(number) {\n  return number.toString()[1] ? number : '0' + number;\n}\n\nexport function sameDay(date1, date2) {\n  const d1 = new Date(date1);\n  const d2 = new Date(date2);\n  return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth() && d1.getDate() === d2.getDate();\n}\n\nexport const dateTime = {\n  addDays,\n  addWeek,\n  addMinutesToTimeString,\n  convertTime,\n  getIsoDateString,\n  getUTCdateString,\n  DateHHMM,\n  extractDate,\n  extractTime,\n  formatDate,\n  getDateByWeek,\n  isISODateString,\n  isDate,\n  isTimeString,\n  offsetDate,\n  offsetTime,\n  sameDay,\n  timeStringMinutes,\n  timeToDate,\n  timeUTC,\n  validTimeValue,\n  validDateString,\n  timeValidation,\n  dateValidation,\n};\n","import { deepCopyEnabled, getProvider } from '../global/state/globalState';\nimport { isDateObject } from './dateTime';\n\nexport function makeDeepCopy(\n  sourceObject, // arbitrary JSON object; functions will be stripped.\n  convertExtensions?, // optional - all extension objects converted to attributes ._key\n  internalUse?, // disregard deepCopy being disabled within the engine - necessary for query results\n  removeExtensions?, // optional - strip all extension attributes\n  iteration = 0 // escape hatch - check against iteration threshold\n) {\n  if (getProvider().makeDeepCopy)\n    return getProvider().makeDeepCopy(\n      sourceObject,\n      convertExtensions,\n      internalUse,\n      removeExtensions\n    );\n\n  const deepCopy = deepCopyEnabled();\n\n  const { stringify, toJSON, ignore, modulate } = deepCopy || {};\n\n  if (\n    (!deepCopy?.enabled && !internalUse) ||\n    typeof sourceObject !== 'object' ||\n    typeof sourceObject === 'function' ||\n    sourceObject === null ||\n    (typeof deepCopy?.threshold === 'number' && iteration >= deepCopy.threshold)\n  ) {\n    return sourceObject;\n  }\n\n  const targetObject = Array.isArray(sourceObject) ? [] : {};\n\n  const sourceObjectKeys = Object.keys(sourceObject).filter(\n    (key) =>\n      !internalUse ||\n      !ignore ||\n      (Array.isArray(ignore) && !ignore.includes(key)) ||\n      (typeof ignore === 'function' && !ignore(key))\n  );\n\n  const stringifyValue = (key, value) => {\n    targetObject[key] =\n      typeof value?.toString === 'function'\n        ? value.toString()\n        : JSON.stringify(value);\n  };\n\n  for (const key of sourceObjectKeys) {\n    const value = sourceObject[key];\n    const modulated =\n      typeof modulate === 'function' ? modulate(value) : undefined;\n    if (modulated !== undefined) {\n      targetObject[key] = modulated;\n    } else if (\n      convertExtensions &&\n      key === 'extensions' &&\n      Array.isArray(value)\n    ) {\n      const extensionConversions = extensionsToAttributes(value);\n      Object.assign(targetObject, ...extensionConversions);\n    } else if (removeExtensions && key === 'extensions') {\n      targetObject[key] = [];\n    } else if (Array.isArray(stringify) && stringify.includes(key)) {\n      stringifyValue(key, value);\n    } else if (\n      Array.isArray(toJSON) &&\n      toJSON.includes(key) &&\n      typeof value?.toJSON === 'function'\n    ) {\n      targetObject[key] = value.toJSON();\n    } else if (value === null) {\n      targetObject[key] = undefined;\n    } else if (isDateObject(value)) {\n      targetObject[key] = new Date(value).toISOString();\n    } else {\n      targetObject[key] = makeDeepCopy(\n        value,\n        convertExtensions,\n        internalUse,\n        removeExtensions,\n        iteration + 1\n      );\n    }\n  }\n\n  return targetObject;\n}\n\nexport function extensionsToAttributes(extensions) {\n  return extensions\n    ?.map((extension) => {\n      const { name, value } = extension;\n      return name && value && { [`_${name}`]: value };\n    })\n    .filter(Boolean);\n}\n","import { makeDeepCopy } from './makeDeepCopy';\n\ntype ProcessKeysArgs = {\n  significantCharacters?: boolean;\n  attributes: string[];\n  targetElement: any;\n};\n\nexport function getAccessorValue({ element, accessor }) {\n  if (typeof accessor !== 'string') return { values: [] };\n  const targetElement = makeDeepCopy(element);\n  const attributes = accessor.split('.');\n\n  const values: any[] = [];\n  let value;\n  processKeys({ targetElement, attributes });\n\n  const result: any = { value };\n  if (values.length) result.values = values;\n  return result;\n\n  function processKeys({\n    targetElement,\n    attributes = [],\n    significantCharacters,\n  }: ProcessKeysArgs) {\n    for (const [index, attribute] of attributes.entries()) {\n      if (targetElement?.[attribute]) {\n        const remainingKeys = attributes.slice(index + 1);\n        if (!remainingKeys.length) {\n          if (!value) value = targetElement[attribute];\n          if (!values.includes(targetElement[attribute])) {\n            values.push(targetElement[attribute]);\n          }\n        } else if (Array.isArray(targetElement[attribute])) {\n          const values = targetElement[attribute];\n          values.forEach((nestedTarget) =>\n            processKeys({\n              targetElement: nestedTarget,\n              attributes: remainingKeys,\n            })\n          );\n        } else {\n          targetElement = targetElement[attribute];\n          checkValue({ targetElement, index });\n        }\n      }\n    }\n\n    function checkValue({ targetElement, index }) {\n      if (\n        targetElement &&\n        index === attributes.length - 1 &&\n        ['string', 'number'].includes(typeof targetElement)\n      ) {\n        const extractedValue = significantCharacters\n          ? targetElement.slice(0, significantCharacters)\n          : targetElement;\n\n        if (value) {\n          if (!values.includes(extractedValue)) {\n            values.push(extractedValue);\n          }\n        } else {\n          value = extractedValue;\n          values.push(extractedValue);\n        }\n      }\n    }\n  }\n}\n","import { getAccessorValue } from './getAccessorValue';\n\nexport function isFunction(obj) {\n  return typeof obj === 'function';\n}\n\nexport function isString(obj) {\n  return typeof obj === 'string';\n}\n\nexport function isObject(obj) {\n  return obj !== null && typeof obj === 'object' && !Array.isArray(obj);\n}\n\nexport function objShallowEqual(o1, o2) {\n  if (!isObject(o1) || !isObject(o2)) return false;\n  const keys1 = Object.keys(o1);\n  const keys2 = Object.keys(o2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (const key of keys1) {\n    if (o1[key] !== o2[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function createMap(objectArray, attribute) {\n  if (!Array.isArray(objectArray)) return {};\n\n  return Object.assign(\n    {},\n    ...(objectArray ?? [])\n      .filter(isObject)\n      .map((obj) => {\n        return (\n          obj[attribute] && {\n            [obj[attribute]]: obj,\n          }\n        );\n      })\n      .filter(Boolean),\n  );\n}\n\n// e.g. result.find(hav({ attr: value })) -or- result.filter(hav({ attr: value }))\nexport const hasAttributeValues = (a) => (o) => Object.keys(a).every((key) => o[key] === a[key]);\nexport const hav = hasAttributeValues;\n\n// extracts targeted attributes\n// e.g. const byeAssignments = positionAssignments.filter(xa('bye')).map(xa('drawPosition'));\n// supports xa('string'), xa(['string', 'string']), xa({ attr1: true, attr2: true })\nexport const extractAttributes = (accessor) => (element) =>\n  !accessor || typeof element !== 'object'\n    ? undefined\n    : (Array.isArray(accessor) &&\n        accessor.map((a) => ({\n          [a]: getAccessorValue({ element, accessor: a })?.value,\n        }))) ||\n      (typeof accessor === 'object' &&\n        Object.keys(accessor).map((key) => ({\n          [key]: getAccessorValue({ element, accessor: key })?.value,\n        }))) ||\n      (typeof accessor === 'string' && getAccessorValue({ element, accessor }))?.value;\nexport const xa = extractAttributes;\n\n// useful in notifications where back end does not recognize undefined for updates\nexport function undefinedToNull(obj: object, shallow?: boolean) {\n  if (obj === undefined) return null;\n  if (typeof obj !== 'object' || obj === null) return obj;\n\n  const definedKeys = Object.keys(obj);\n  const notNull = (value) => (value === undefined ? null : value);\n\n  return Object.assign(\n    {},\n    ...definedKeys.map((key) => {\n      return Array.isArray(obj[key])\n        ? {\n            [key]: shallow ? obj[key] : obj[key].map((m) => undefinedToNull(m)),\n          }\n        : { [key]: shallow ? notNull(obj[key]) : undefinedToNull(obj[key]) };\n    }),\n  );\n}\n\nfunction countKeys(o) {\n  if (Array.isArray(o)) {\n    return o.length + o.map(countKeys).reduce((a, b) => a + b, 0);\n  } else if (typeof o === 'object' && o !== null) {\n    return (\n      Object.keys(o).length +\n      Object.keys(o)\n        .map((k) => countKeys(o[k]))\n        .reduce((a, b) => a + b, 0)\n    );\n  }\n  return 0;\n}\n\nexport function generateHashCode(o) {\n  if (o === null || typeof o !== 'object') return undefined;\n  const str = JSON.stringify(o);\n  const keyCount = countKeys(o);\n  const charSum = str.split('').reduce((a, b) => a + b.charCodeAt(0), 0);\n  return [str.length, keyCount, charSum].map((e) => e.toString(36)).join('');\n}\n","export const TOURNAMENT_RECORDS = 'tournamentRecords';\nexport const POLICY_DEFINITIONS = 'policyDefinitions';\nexport const TOURNAMENT_RECORD = 'tournamentRecord';\nexport const DRAW_DEFINITION = 'drawDefinition';\nexport const MATCHUP_FORMAT = 'matchUpFormat';\nexport const PARTICIPANT_ID = 'participantId';\nexport const SCHEDULE_DATES = 'scheduleDates';\nexport const TOURNAMENT_ID = 'tournamentId';\nexport const SCHEDULE_DATE = 'scheduleDate';\nexport const STRUCTURE_ID = 'structureId';\nexport const PARTICIPANT = 'participant';\nexport const MATCHUP_IDS = 'matchUpIds';\nexport const POLICY_TYPE = 'policyType';\nexport const STRUCTURES = 'structures';\nexport const MATCHUP_ID = 'matchUpId';\nexport const IN_CONTEXT = 'inContext';\nexport const STRUCTURE = 'structure';\nexport const COURT_IDS = 'courtIds';\nexport const PERSON_ID = 'personId';\nexport const VENUE_IDS = 'venueIds';\nexport const MATCHUPS = 'matchUps';\nexport const COURT_ID = 'courtId';\nexport const EVENT_ID = 'eventId';\nexport const MATCHUP = 'matchUp';\nexport const DRAW_ID = 'drawId';\nexport const ERROR = 'error';\nexport const EVENT = 'event';\nexport const PARAM = 'param';\nexport const UUIDS = 'uuids';\n\nexport const AVERAGE_MATCHUP_MINUTES = 'averageMatchUpMinutes';\nexport const RECOVERY_MINUTES = 'recoveryMinutes';\nexport const PERIOD_LENGTH = 'periodLength';\n\nexport const NUMBER = 'number';\nexport const STRING = 'string';\nexport const OBJECT = 'object';\nexport const ARRAY = 'array';\n\nexport const BYPASS_PARAM_CHECK = '_bypassParamCheck';\nexport const VALIDATE = 'validate';\nexport const INVALID = 'invalid';\nexport const OF_TYPE = '_ofType';\nexport const ANY_OF = '_anyOf';\nexport const ONE_OF = '_oneOf';\n","import { isFunction, isObject } from '../utilities/objects';\nimport { intersection } from '../utilities/arrays';\n\nimport { ResultType, decorateResult } from '../global/functions/decorateResult';\nimport {\n  EVENT_NOT_FOUND,\n  INVALID_VALUES,\n  MISSING_COURT_ID,\n  MISSING_DRAW_DEFINITION,\n  MISSING_DRAW_ID,\n  MISSING_EVENT,\n  MISSING_MATCHUP,\n  MISSING_MATCHUPS,\n  MISSING_MATCHUP_ID,\n  MISSING_MATCHUP_IDS,\n  MISSING_PARTICIPANT,\n  MISSING_PARTICIPANT_ID,\n  MISSING_POLICY_DEFINITION,\n  MISSING_STRUCTURE,\n  MISSING_STRUCTURES,\n  MISSING_STRUCTURE_ID,\n  MISSING_TOURNAMENT_ID,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_TOURNAMENT_RECORDS,\n  MISSING_VALUE,\n} from '../constants/errorConditionConstants';\nimport {\n  ARRAY,\n  COURT_ID,\n  COURT_IDS,\n  DRAW_DEFINITION,\n  DRAW_ID,\n  EVENT,\n  EVENT_ID,\n  MATCHUP,\n  MATCHUPS,\n  MATCHUP_ID,\n  MATCHUP_IDS,\n  OBJECT,\n  PARTICIPANT,\n  PARTICIPANT_ID,\n  POLICY_DEFINITIONS,\n  SCHEDULE_DATES,\n  STRUCTURE,\n  STRUCTURES,\n  STRUCTURE_ID,\n  TOURNAMENT_ID,\n  TOURNAMENT_RECORD,\n  TOURNAMENT_RECORDS,\n  UUIDS,\n  VENUE_IDS,\n} from '../constants/attributeConstants';\n\ntype Params = { [key: string]: any };\ntype RequiredParams = {\n  _anyOf?: { [key: string]: boolean };\n  _oneOf?: { [key: string]: boolean };\n  [key: string]: any;\n  _ofType?: string;\n  validate?: any;\n  resolve?: any;\n}[];\n\nconst errors = {\n  [TOURNAMENT_RECORDS]: MISSING_TOURNAMENT_RECORDS,\n  [TOURNAMENT_RECORD]: MISSING_TOURNAMENT_RECORD,\n  [POLICY_DEFINITIONS]: MISSING_POLICY_DEFINITION,\n  [DRAW_DEFINITION]: MISSING_DRAW_DEFINITION,\n  [PARTICIPANT_ID]: MISSING_PARTICIPANT_ID,\n  [TOURNAMENT_ID]: MISSING_TOURNAMENT_ID,\n  [STRUCTURE_ID]: MISSING_STRUCTURE_ID,\n  [MATCHUP_IDS]: MISSING_MATCHUP_IDS,\n  [PARTICIPANT]: MISSING_PARTICIPANT,\n  [STRUCTURES]: MISSING_STRUCTURES,\n  [MATCHUP_ID]: MISSING_MATCHUP_ID,\n  [STRUCTURE]: MISSING_STRUCTURE,\n  [COURT_ID]: MISSING_COURT_ID,\n  [MATCHUPS]: MISSING_MATCHUPS,\n  [MATCHUP]: MISSING_MATCHUP,\n  [COURT_IDS]: MISSING_VALUE,\n  [VENUE_IDS]: MISSING_VALUE,\n  [DRAW_ID]: MISSING_DRAW_ID,\n  [EVENT_ID]: MISSING_EVENT,\n  [EVENT]: EVENT_NOT_FOUND,\n};\n\nconst paramTypes = {\n  [TOURNAMENT_RECORDS]: OBJECT,\n  [POLICY_DEFINITIONS]: OBJECT,\n  [TOURNAMENT_RECORD]: OBJECT,\n  [DRAW_DEFINITION]: OBJECT,\n  [SCHEDULE_DATES]: ARRAY,\n  [PARTICIPANT]: OBJECT,\n  [MATCHUP_IDS]: ARRAY,\n  [STRUCTURES]: ARRAY,\n  [STRUCTURE]: OBJECT,\n  [COURT_IDS]: ARRAY,\n  [VENUE_IDS]: ARRAY,\n  [MATCHUPS]: ARRAY,\n  [MATCHUP]: OBJECT,\n  [EVENT]: OBJECT,\n  [UUIDS]: ARRAY,\n};\n\nexport function checkRequiredParameters(\n  params: Params,\n  requiredParams: RequiredParams,\n  stack?: string,\n): ResultType & {\n  valid?: boolean;\n} {\n  if (!params && !isObject(params)) return { error: INVALID_VALUES };\n  if (!requiredParams?.length || params?._bypassParamCheck) return { valid: true };\n\n  if (!Array.isArray(requiredParams)) return { error: INVALID_VALUES };\n\n  const { paramError, errorParam } = findParamError(params, requiredParams);\n  if (!paramError) return { valid: true };\n\n  const error =\n    params[errorParam] === undefined\n      ? errors[errorParam] || INVALID_VALUES\n      : (paramError.validate && paramError.invalid) || INVALID_VALUES;\n\n  return decorateResult({\n    info: { param: errorParam },\n    result: { error },\n    stack,\n  });\n}\n\nfunction getIntersection(params, constraint) {\n  const paramKeys = Object.keys(params);\n  const constraintKeys = Object.keys(constraint);\n  return intersection(paramKeys, constraintKeys);\n}\n\nfunction getOneOf(params, _oneOf) {\n  if (!_oneOf) return;\n  const overlap = getIntersection(params, _oneOf);\n  if (overlap.length !== 1) return { error: INVALID_VALUES };\n  return overlap.reduce((attr, param) => ({ ...attr, [param]: true }), {});\n}\n\nfunction getAnyOf(params, _anyOf) {\n  if (!_anyOf) return;\n  const overlap = getIntersection(params, _anyOf).filter((param) => params[param]);\n  if (overlap.length < 1) return { error: INVALID_VALUES };\n  return overlap.reduce((attr, param) => ({ ...attr, [param]: true }), {});\n}\n\nfunction findParamError(params, requiredParams) {\n  let errorParam;\n  const paramError = requiredParams.find(({ _ofType, _oneOf, _anyOf, validate, ...attrs }) => {\n    const oneOf = _oneOf && getOneOf(params, _oneOf);\n    if (oneOf?.error) return oneOf.error;\n    oneOf && Object.assign(attrs, oneOf);\n\n    const anyOf = _anyOf && getAnyOf(params, _anyOf);\n    if (anyOf?.error) return anyOf.error;\n    anyOf && Object.assign(attrs, anyOf);\n\n    const booleanParams = Object.keys(attrs).filter((key) => typeof attrs[key] === 'boolean');\n\n    const invalidParam = booleanParams.find((param) => {\n      const invalidValidationFunction = validate && !isFunction(validate); // validate is specified but not a function\n      const faliedTypeCheck = params[param] && !validate && invalidType(params, param, _ofType); // param is present, no validation function provided, and invalid type\n      const paramNotPresent = attrs[param] && !params[param]; // attrs[param] boolean value is true and param is not present\n      const invalid = invalidValidationFunction || faliedTypeCheck || paramNotPresent;\n\n      const hasError = invalid || (validate && params[param] && !checkValidation(params[param], validate));\n      if (hasError) errorParam = param;\n\n      return hasError;\n    });\n\n    return !booleanParams.length || invalidParam;\n  });\n  return { paramError, errorParam };\n}\n\nfunction invalidType(params, param, _ofType) {\n  _ofType = _ofType || paramTypes[param] || 'string';\n  if (_ofType === 'array') {\n    return !Array.isArray(params[param]);\n  }\n  return typeof params[param] !== _ofType;\n}\n\nfunction checkValidation(value, validate) {\n  if (isFunction(validate)) return validate(value);\n  return true;\n}\n","export const DYNAMIC = 'DYNAMIC';\nexport const RANKING = 'RANKING';\nexport const RATING = 'RATING';\nexport const SCALE = 'SCALE';\nexport const SEEDING = 'SEEDING';\n\nexport const scaleConstants = {\n  RANKING,\n  RATING,\n  SCALE,\n  SEEDING,\n};\n","import { checkRequiredParameters } from '../../parameters/checkRequiredParameters';\nimport { unique } from '../../utilities/arrays';\n\nimport { DOUBLES_EVENT, SINGLES_EVENT, TEAM_EVENT } from '../../constants/eventConstants';\nimport { RANKING, RATING, SCALE, SEEDING } from '../../constants/scaleConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { PARTICIPANT } from '../../constants/attributeConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\n\ntype ScaleType = {\n  scaleName: string;\n  scaleDate: string;\n  scaleValue: any;\n};\ntype ScalesType = {\n  [SINGLES_EVENT]?: ScaleType;\n  [DOUBLES_EVENT]?: ScaleType;\n  [TEAM_EVENT]?: ScaleType;\n};\n\ntype ScaleTypes = {\n  seedings: ScalesType;\n  rankings: ScalesType;\n  ratings: ScalesType;\n  success?: boolean;\n};\n\nexport function getScaleValues(params): ResultType & {\n  seedings?: ScalesType;\n  rankings?: ScalesType;\n  ratings?: ScalesType;\n} {\n  const paramCheck = checkRequiredParameters(params, [{ [PARTICIPANT]: true }]);\n  if (paramCheck.error) return paramCheck;\n\n  const scaleItems = params.participant.timeItems?.filter(\n    ({ itemType }) => itemType?.startsWith(SCALE) && [RANKING, RATING, SEEDING].includes(itemType.split('.')[1]),\n  );\n  const scales: ScaleTypes = { ratings: {}, rankings: {}, seedings: {} };\n\n  if (scaleItems?.length) {\n    const latestScaleItem = (scaleType) =>\n      scaleItems\n        .filter((timeItem) => timeItem?.itemType === scaleType)\n        .sort((a, b) => new Date(a.createdAt || undefined).getTime() - new Date(b.createdAt || undefined).getTime())\n        .pop();\n\n    const itemTypes = unique(scaleItems.map(({ itemType }) => itemType));\n\n    for (const itemType of itemTypes) {\n      const scaleItem = latestScaleItem(itemType);\n      if (scaleItem) {\n        const [, type, format, scaleName, modifier] = scaleItem.itemType.split('.');\n\n        const namedScale = modifier ? `${scaleName}.${modifier}` : scaleName;\n\n        const scaleType = (type === SEEDING && 'seedings') || (type === RANKING && 'rankings') || 'ratings';\n\n        if (!scales[scaleType][format]) scales[scaleType][format] = [];\n        scales[scaleType][format].push({\n          scaleValue: scaleItem.itemValue,\n          scaleDate: scaleItem.itemDate,\n          scaleName: namedScale,\n        });\n      }\n    }\n  }\n\n  return { ...SUCCESS, ...scales };\n}\n","// NOTE: type really does need to be any!\nexport function attributeFilter(params?: any): any {\n  if (params === null) return {};\n  const { source, template } = params || {};\n  if (!template) return source;\n\n  const target = {};\n  attributeCopy(source, template, target);\n\n  return target;\n\n  function attributeCopy(valuesObject, templateObject, outputObject) {\n    if (!valuesObject || !templateObject) return undefined;\n    const vKeys = Object.keys(valuesObject);\n    const oKeys = Object.keys(templateObject);\n\n    // the orMap allows spcification of { 'a||b': boolean } so that filter templates can apply to multiple attributes\n    const orMap = Object.assign(\n      {},\n      ...oKeys\n        .filter((key) => key.indexOf('||'))\n        .map((key) => key.split('||').map((or) => ({ [or]: key })))\n        .flat()\n    );\n    const allKeys = oKeys.concat(...Object.keys(orMap));\n    const wildcard = allKeys.includes('*');\n\n    for (const vKey of vKeys) {\n      if (allKeys.indexOf(vKey) >= 0 || wildcard) {\n        const templateKey = orMap[vKey] || vKey;\n        const tobj = templateObject[templateKey] || wildcard;\n        const vobj = valuesObject[vKey];\n\n        if (\n          typeof tobj === 'object' &&\n          typeof vobj !== 'function' &&\n          !Array.isArray(tobj)\n        ) {\n          if (Array.isArray(vobj)) {\n            const mappedElements = vobj\n              .map((arrayMember) => {\n                const target = {};\n                const result = attributeCopy(arrayMember, tobj, target);\n                return result !== false ? target : undefined;\n              })\n              .filter(Boolean);\n            outputObject[vKey] = mappedElements;\n          } else if (vobj) {\n            outputObject[vKey] = {};\n            attributeCopy(vobj, tobj, outputObject[vKey]);\n          }\n        } else {\n          const value = valuesObject[vKey];\n          const exclude = Array.isArray(tobj) && !tobj.includes(value);\n          if (exclude) return false;\n\n          if (\n            templateObject[vKey] ||\n            (wildcard && templateObject[vKey] !== false)\n          ) {\n            outputObject[vKey] = value;\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n}\n","export const POLICY_TYPE_VOLUNTARY_CONSOLATION = 'voluntaryConsolation';\nexport const POLICY_TYPE_COMPETITIVE_BANDS = 'competitiveBands';\nexport const POLICY_TYPE_ROUND_ROBIN_TALLY = 'roundRobinTally';\nexport const POLICY_TYPE_POSITION_ACTIONS = 'positionActions';\nexport const POLICY_TYPE_MATCHUP_ACTIONS = 'matchUpActions';\nexport const POLICY_TYPE_RANKING_POINTS = 'rankingPoints';\nexport const POLICY_TYPE_ROUND_NAMING = 'roundNaming';\nexport const POLICY_TYPE_PARTICIPANT = 'participant';\nexport const POLICY_TYPE_PROGRESSION = 'progression';\nexport const POLICY_TYPE_SCHEDULING = 'scheduling';\nexport const POLICY_TYPE_AVOIDANCE = 'avoidance';\nexport const POLICY_TYPE_DISPLAY = 'display'; // storage for client type displays, e.g. { public: {}, admin: {} }\nexport const POLICY_TYPE_SCORING = 'scoring';\nexport const POLICY_TYPE_SEEDING = 'seeding';\nexport const POLICY_TYPE_FEED_IN = 'feedIn';\nexport const POLICY_TYPE_AUDIT = 'audit';\nexport const POLICY_TYPE_DRAWS = 'draws';\n\nexport type ValidPolicyTypes =\n  | typeof POLICY_TYPE_VOLUNTARY_CONSOLATION\n  | typeof POLICY_TYPE_COMPETITIVE_BANDS\n  | typeof POLICY_TYPE_ROUND_ROBIN_TALLY\n  | typeof POLICY_TYPE_POSITION_ACTIONS\n  | typeof POLICY_TYPE_MATCHUP_ACTIONS\n  | typeof POLICY_TYPE_RANKING_POINTS\n  | typeof POLICY_TYPE_ROUND_NAMING\n  | typeof POLICY_TYPE_PARTICIPANT\n  | typeof POLICY_TYPE_PROGRESSION\n  | typeof POLICY_TYPE_SCHEDULING\n  | typeof POLICY_TYPE_AVOIDANCE\n  | typeof POLICY_TYPE_DISPLAY\n  | typeof POLICY_TYPE_FEED_IN\n  | typeof POLICY_TYPE_SCORING\n  | typeof POLICY_TYPE_SEEDING\n  | typeof POLICY_TYPE_AUDIT\n  | typeof POLICY_TYPE_DRAWS;\n\nexport const policyConstants = {\n  POLICY_TYPE_VOLUNTARY_CONSOLATION,\n  POLICY_TYPE_COMPETITIVE_BANDS,\n  POLICY_TYPE_ROUND_ROBIN_TALLY,\n  POLICY_TYPE_POSITION_ACTIONS,\n  POLICY_TYPE_MATCHUP_ACTIONS,\n  POLICY_TYPE_RANKING_POINTS,\n  POLICY_TYPE_ROUND_NAMING,\n  POLICY_TYPE_PARTICIPANT,\n  POLICY_TYPE_PROGRESSION,\n  POLICY_TYPE_SCHEDULING,\n  POLICY_TYPE_AVOIDANCE,\n  POLICY_TYPE_DISPLAY,\n  POLICY_TYPE_FEED_IN,\n  POLICY_TYPE_SCORING,\n  POLICY_TYPE_SEEDING,\n  POLICY_TYPE_AUDIT,\n  POLICY_TYPE_DRAWS,\n} as const;\n","import { getScaleValues } from '../query/participant/getScaleValues';\nimport { attributeFilter } from '../utilities/attributeFilter';\nimport { makeDeepCopy } from '../utilities/makeDeepCopy';\n\nimport { ContextProfile, PolicyDefinitions } from '../types/factoryTypes';\nimport { POLICY_TYPE_PARTICIPANT } from '../constants/policyConstants';\nimport { Participant } from '../types/tournamentTypes';\n\ntype HydratedParticipant = {\n  [key: string | number | symbol]: unknown;\n} & Participant;\n\ntype FindParticipantArgs = {\n  tournamentParticipants: Participant[];\n  policyDefinitions?: PolicyDefinitions;\n  contextProfile?: ContextProfile;\n  participantId?: string;\n  internalUse?: boolean;\n  personId?: string;\n};\n\nexport function findParticipant({\n  tournamentParticipants = [],\n  policyDefinitions = {},\n  contextProfile,\n  participantId,\n  internalUse,\n  personId,\n}: FindParticipantArgs): HydratedParticipant | undefined {\n  const foundParticipant = tournamentParticipants.find(\n    (candidate) =>\n      (participantId && candidate.participantId === participantId) ||\n      (personId && candidate.person && candidate.person.personId === personId)\n  );\n\n  const participant = makeDeepCopy(foundParticipant, false, internalUse);\n\n  if (participant) {\n    const participantAttributes = policyDefinitions?.[POLICY_TYPE_PARTICIPANT];\n\n    if (contextProfile?.withScaleValues) {\n      const { ratings, rankings } = getScaleValues({ participant });\n      participant.rankings = rankings;\n      participant.ratings = ratings;\n    }\n\n    if (participantAttributes?.participant) {\n      return attributeFilter({\n        template: participantAttributes.participant,\n        source: participant,\n      });\n    }\n  }\n\n  return participant;\n}\n","import { findParticipant } from '../../acquire/findParticipant';\nimport { removeExtension } from './removeExtension';\nimport { addExtension } from './addExtension';\n\nimport {\n  DRAW_DEFINITION_NOT_FOUND,\n  EVENT_NOT_FOUND,\n  ErrorType,\n  MISSING_PARTICIPANT_ID,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n  PARTICIPANT_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Extension,\n  Tournament,\n} from '../../types/tournamentTypes';\n\ntype AddExtensionArgs = {\n  tournamentRecord?: Tournament;\n  drawDefinition?: DrawDefinition;\n  participantId?: string;\n  creationTime?: boolean;\n  extension: Extension;\n  event?: Event;\n};\n\nexport function addTournamentExtension(params: AddExtensionArgs): {\n  success?: boolean;\n  error?: ErrorType;\n} {\n  if (!params || typeof params !== 'object') return { error: MISSING_VALUE };\n  if (!params.tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  return addExtension({\n    creationTime: params.creationTime,\n    element: params.tournamentRecord,\n    extension: params.extension,\n  });\n}\n\nexport function addDrawDefinitionExtension(params: AddExtensionArgs) {\n  if (!params || typeof params !== 'object') return { error: MISSING_VALUE };\n  if (!params.drawDefinition) return { error: DRAW_DEFINITION_NOT_FOUND };\n  return addExtension({\n    creationTime: params.creationTime,\n    element: params.drawDefinition,\n    extension: params.extension,\n  });\n}\n\nexport function addEventExtension(params: AddExtensionArgs) {\n  if (!params || typeof params !== 'object') return { error: MISSING_VALUE };\n  if (!params.event) return { error: EVENT_NOT_FOUND };\n  return addExtension({\n    creationTime: params.creationTime,\n    extension: params.extension,\n    element: params.event,\n  });\n}\n\nexport function addParticipantExtension(params?) {\n  if (!params || typeof params !== 'object') return { error: MISSING_VALUE };\n  if (!params.participantId) return { error: MISSING_PARTICIPANT_ID };\n  const tournamentParticipants = params.tournamentRecord?.participants || [];\n  const participant = findParticipant({\n    participantId: params.participantId,\n    tournamentParticipants,\n  });\n  if (!participant) return { error: PARTICIPANT_NOT_FOUND };\n  return addExtension({\n    creationTime: params.creationTime,\n    extension: params.extension,\n    element: participant,\n  });\n}\n\nexport function removeTournamentExtension(params): {\n  success?: boolean;\n  error?: ErrorType;\n  info?: any;\n} {\n  if (!params || typeof params !== 'object') return { error: MISSING_VALUE };\n  if (!params.tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  return removeExtension({\n    element: params.tournamentRecord,\n    name: params.name,\n  });\n}\n\nexport function removeDrawDefinitionExtension(params) {\n  if (!params || typeof params !== 'object') return { error: MISSING_VALUE };\n  if (!params.drawDefinition) return { error: DRAW_DEFINITION_NOT_FOUND };\n  return removeExtension({ element: params.drawDefinition, name: params.name });\n}\n\nexport function removeEventExtension(params) {\n  if (!params || typeof params !== 'object') return { error: MISSING_VALUE };\n  if (!params?.event) return { error: EVENT_NOT_FOUND };\n  return removeExtension({ element: params.event, name: params.name });\n}\n\nexport function removeParticipantExtension(params?) {\n  if (!params || typeof params !== 'object') return { error: MISSING_VALUE };\n  if (!params.participantId) return { error: MISSING_PARTICIPANT_ID };\n  const tournamentParticipants = params.tournamentRecord?.participants || [];\n  const participant = findParticipant({\n    participantId: params.participantId,\n    tournamentParticipants,\n  });\n\n  if (!participant) return { error: PARTICIPANT_NOT_FOUND };\n\n  return removeExtension({ element: participant, name: params.name });\n}\n","export const ACTIVE_SUSPENSION = 'activeSuspension';\nexport const APPLIED_POLICIES = 'appliedPolicies';\nexport const AUDIT_POSITION_ACTIONS = 'positionActions';\nexport const CONTEXT = 'context';\nexport const DELEGATED_OUTCOME = 'delegatedOutcome';\nexport const DISABLED = 'disabled';\nexport const DISABLE_LINKS = 'disableLinks';\nexport const DISABLE_AUTO_CALC = 'disableAutoCalc';\nexport const DRAW_DELETIONS = 'drawDeletions';\nexport const DRAW_PROFILE = 'drawProfile';\nexport const ENTRY_PROFILE = 'entryProfile';\nexport const EVENT_PROFILE = 'eventProfile';\nexport const EVENT_WITHDRAWAL_REQUESTS = 'eventWithdrawalRequests';\nexport const FACTORY = 'factory';\nexport const FLIGHT_PROFILE = 'flightProfile';\nexport const GROUPING_ATTRIBUTE = 'groupingAttribute';\nexport const LINEUPS = 'lineUps';\nexport const LINKED_TOURNAMENTS = 'linkedTournamentsIds';\nexport const MATCHUP_HISTORY = 'matchUpHistory';\nexport const PARTICIPANT_REPRESENTATIVES = 'participantRepresentatives';\nexport const PERSON_REQUESTS = 'personRequests';\nexport const RANKING_POINTS = 'rankingPoints';\nexport const REGISTRATION = 'registration';\nexport const ROUND_TARGET = 'roundTarget';\nexport const SCHEDULE_LIMITS = 'scheduleLimits';\nexport const SCHEDULE_TIMING = 'scheduleTiming';\nexport const SCHEDULING_PROFILE = 'schedulingProfile';\nexport const STATUS_DETAIL = 'statusDetail';\nexport const SUB_ORDER = 'subOrder';\nexport const TALLY = 'tally';\nexport const TIE_FORMAT_MODIFICATIONS = 'tieFormatModification';\n\nexport const extensionConstants = {\n  ACTIVE_SUSPENSION,\n  APPLIED_POLICIES,\n  AUDIT_POSITION_ACTIONS,\n  CONTEXT, // used to capture, e.g. context in which a venue was added\n  DELEGATED_OUTCOME,\n  DISABLED,\n  DISABLE_LINKS,\n  DISABLE_AUTO_CALC,\n  DRAW_DELETIONS,\n  DRAW_PROFILE,\n  ENTRY_PROFILE, // used for drawGeneration; not relevant for anonymized tournaments\n  EVENT_PROFILE,\n  EVENT_WITHDRAWAL_REQUESTS,\n  FLIGHT_PROFILE,\n  GROUPING_ATTRIBUTE, // for generating teams; not relevant for anonymized tournaments\n  LINEUPS,\n  LINKED_TOURNAMENTS,\n  MATCHUP_HISTORY,\n  PARTICIPANT_REPRESENTATIVES,\n  PERSON_REQUESTS,\n  RANKING_POINTS, // for attaching points awarded to tournamentRecord\n  ROUND_TARGET,\n  SCHEDULE_LIMITS,\n  SCHEDULE_TIMING,\n  SCHEDULING_PROFILE,\n  STATUS_DETAIL, // attached to event.entries\n  SUB_ORDER,\n  TALLY,\n  TIE_FORMAT_MODIFICATIONS, // for auditing, not important when anonymized\n  FACTORY, // used for capturing versioning of factory and other TODS document processors\n};\n\nexport const internalExtensions = [\n  DELEGATED_OUTCOME,\n  DISABLED,\n  DISABLE_LINKS,\n  FLIGHT_PROFILE,\n  LINEUPS,\n  MATCHUP_HISTORY,\n  PARTICIPANT_REPRESENTATIVES,\n  PERSON_REQUESTS,\n  ROUND_TARGET,\n  SCHEDULE_LIMITS,\n  SCHEDULE_TIMING,\n  SCHEDULING_PROFILE,\n  SUB_ORDER,\n  TALLY,\n];\n","import { SUCCESS } from '../../constants/resultConstants';\nimport { isObject } from '../../utilities/objects';\n\nexport function getTournamentIds({ tournamentRecords }) {\n  const tournamentIds = isObject(tournamentRecords)\n    ? Object.keys(tournamentRecords)\n    : [];\n  return { tournamentIds, ...SUCCESS };\n}\n","import {\n  linkTournaments,\n  unlinkTournament,\n  unlinkTournaments,\n} from '../../../mutate/tournaments/tournamentLinks';\n\nexport const competitionGovernor = {\n  linkTournaments,\n  unlinkTournament,\n  unlinkTournaments,\n};\n\nexport default competitionGovernor;\n","import { removeExtension } from '../extensions/removeExtension';\nimport { addExtension } from '../extensions/addExtension';\nimport { findExtension } from '../../acquire/findExtension';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\nimport {\n  addTournamentExtension,\n  removeTournamentExtension,\n} from '../extensions/addRemoveExtensions';\n\nimport { LINKED_TOURNAMENTS } from '../../constants/extensionConstants';\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_ID,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../constants/errorConditionConstants';\nimport { getTournamentIds } from '../../query/tournaments/getTournamentIds';\n\n/**\n * Links all tournaments which are currently loaded into competitionEngine state\n */\n\nexport function linkTournaments({\n  tournamentRecords,\n}: {\n  tournamentRecords: TournamentRecords;\n}): ResultType {\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const result = getTournamentIds({ tournamentRecords });\n  const { tournamentIds } = result;\n\n  if (tournamentIds?.length > 1) {\n    const extension = {\n      name: LINKED_TOURNAMENTS,\n      value: { tournamentIds },\n    };\n\n    return addExtension({\n      tournamentRecords,\n      discover: true,\n      extension,\n    });\n  }\n\n  return { ...SUCCESS };\n}\n\ntype UnlinkTournamentsArgs = {\n  tournamentRecords: TournamentRecords;\n};\nexport function unlinkTournaments({\n  tournamentRecords,\n}: UnlinkTournamentsArgs): ResultType {\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const result = removeExtension({\n    name: LINKED_TOURNAMENTS,\n    tournamentRecords,\n    discover: true,\n  });\n\n  // TODO: check the integrity of the venues attached to each tournment...\n  // get all competitionScheduleMatchUps and ensure that each tournamentRecord has all venues for scheduled matchUps\n\n  return decorateResult({ result, stack: 'unlinkTournaments' });\n}\n\ntype UnlinkTournamentArgs = {\n  tournamentRecords: TournamentRecords;\n  tournamentId: string;\n};\nexport function unlinkTournament({\n  tournamentRecords,\n  tournamentId,\n}: UnlinkTournamentArgs): ResultType {\n  if (typeof tournamentRecords !== 'object') return { error: INVALID_VALUES };\n  if (!tournamentId) return { error: MISSING_TOURNAMENT_ID };\n\n  const result = getTournamentIds({ tournamentRecords });\n  const { tournamentIds } = result;\n\n  if (!tournamentIds.includes(tournamentId))\n    return { error: MISSING_TOURNAMENT_ID };\n\n  // not using bulk update function here to handle scenario where\n  // tournamentRecords loaded into state are not all linked\n  let unlinkError;\n  tournamentIds.every((currentTournamentId) => {\n    const tournamentRecord = tournamentRecords[currentTournamentId];\n\n    const { extension } = findExtension({\n      element: tournamentRecord,\n      name: LINKED_TOURNAMENTS,\n    });\n\n    // if there is no extension return { ...SUCCESS } because no links exist\n    if (!extension) return true;\n\n    const linkedTournamentIds = extension?.value?.tournamentIds || [];\n\n    // if there are no tournamentIds\n    if (\n      !linkedTournamentIds?.length ||\n      (linkedTournamentIds.length === 1 &&\n        linkedTournamentIds.includes(tournamentId)) ||\n      currentTournamentId === tournamentId\n    ) {\n      const result = removeTournamentExtension({\n        name: LINKED_TOURNAMENTS,\n        tournamentRecord,\n      });\n      if (result.error) unlinkError = result.error;\n      return result.success;\n    }\n\n    const tournamentIds = linkedTournamentIds.filter(\n      (linkedTournamentId) => linkedTournamentId !== tournamentId\n    );\n    extension.value = { tournamentIds };\n\n    const result = addTournamentExtension({ tournamentRecord, extension });\n    if (result.error) unlinkError = result.error;\n    return result.success;\n  });\n\n  return unlinkError ? { error: unlinkError } : { ...SUCCESS };\n}\n","const extractor = (object) => (attr) => object[attr];\n\nexport const getMatchUpIds = (o = []) => o.map(getMatchUpId).filter(Boolean);\nexport const getParticipantIds = (o = []) =>\n  o.map(getParticipantId).filter(Boolean);\n\nexport const getParticipantId = (o = {}) => extractor(o)('participantId');\nexport const getDrawPosition = (o = {}) => extractor(o)('drawPosition');\nexport const getEntryStatus = (o = {}) => extractor(o)('entryStatus');\nexport const getMatchUpId = (o = {}) => extractor(o)('matchUpId');\n","export const ABANDONED: any = 'ABANDONED';\nexport const AWAITING_RESULT: any = 'AWAITING_RESULT';\nexport const BYE: any = 'BYE';\nexport const CANCELLED: any = 'CANCELLED';\nexport const COMPLETED: any = 'COMPLETED';\nexport const DEAD_RUBBER: any = 'DEAD_RUBBER';\nexport const DEFAULTED: any = 'DEFAULTED';\nexport const DOUBLE_DEFAULT: any = 'DOUBLE_DEFAULT';\nexport const DOUBLE_WALKOVER: any = 'DOUBLE_WALKOVER';\nexport const IN_PROGRESS: any = 'IN_PROGRESS';\nexport const INCOMPLETE: any = 'INCOMPLETE';\nexport const NOT_PLAYED: any = 'NOT_PLAYED';\nexport const RETIRED: any = 'RETIRED';\nexport const SUSPENDED: any = 'SUSPENDED';\nexport const TO_BE_PLAYED: any = 'TO_BE_PLAYED';\nexport const WALKOVER: any = 'WALKOVER';\n\nexport const recoveryTimeRequiredMatchUpStatuses = [\n  AWAITING_RESULT,\n  COMPLETED,\n  DEFAULTED,\n  IN_PROGRESS,\n  INCOMPLETE,\n  RETIRED,\n  SUSPENDED,\n];\n\nexport const particicipantsRequiredMatchUpStatuses = [\n  AWAITING_RESULT,\n  COMPLETED,\n  DEFAULTED,\n  DOUBLE_WALKOVER,\n  DOUBLE_DEFAULT,\n  IN_PROGRESS,\n  INCOMPLETE,\n  RETIRED,\n  SUSPENDED,\n  WALKOVER,\n];\n\nexport const validMatchUpStatuses = [\n  ABANDONED,\n  AWAITING_RESULT,\n  BYE,\n  CANCELLED,\n  COMPLETED,\n  DEAD_RUBBER,\n  DEFAULTED,\n  DOUBLE_WALKOVER,\n  DOUBLE_DEFAULT,\n  IN_PROGRESS,\n  INCOMPLETE,\n  NOT_PLAYED,\n  RETIRED,\n  SUSPENDED,\n  TO_BE_PLAYED,\n  WALKOVER,\n];\n\nexport const directingMatchUpStatuses = [\n  BYE,\n  DOUBLE_WALKOVER, // directing because of a produced WALKOVER\n  DOUBLE_DEFAULT, // directing because of a produced WALKOVER\n  COMPLETED,\n  DEFAULTED,\n  RETIRED,\n  WALKOVER,\n];\n\nexport const nonDirectingMatchUpStatuses = [\n  ABANDONED,\n  AWAITING_RESULT,\n  CANCELLED,\n  DEAD_RUBBER,\n  IN_PROGRESS,\n  INCOMPLETE,\n  NOT_PLAYED,\n  SUSPENDED,\n  TO_BE_PLAYED,\n  undefined,\n];\n\nexport const completedMatchUpStatuses = [\n  CANCELLED,\n  ABANDONED,\n  COMPLETED,\n  DEAD_RUBBER,\n  DEFAULTED,\n  DOUBLE_WALKOVER,\n  DOUBLE_DEFAULT,\n  RETIRED,\n  WALKOVER,\n];\n\nexport const activeMatchUpStatuses = [\n  ABANDONED,\n  COMPLETED,\n  DEFAULTED,\n  DOUBLE_WALKOVER,\n  DOUBLE_DEFAULT,\n  IN_PROGRESS,\n  RETIRED,\n  WALKOVER,\n];\n\nexport const upcomingMatchUpStatuses = [\n  IN_PROGRESS,\n  INCOMPLETE,\n  SUSPENDED,\n  TO_BE_PLAYED,\n];\n\nexport const matchUpStatusConstants = {\n  ABANDONED,\n  AWAITING_RESULT,\n  BYE,\n  CANCELLED,\n  COMPLETED,\n  DEAD_RUBBER,\n  DEFAULTED,\n  DOUBLE_WALKOVER,\n  DOUBLE_DEFAULT,\n  IN_PROGRESS,\n  INCOMPLETE,\n  NOT_PLAYED,\n  RETIRED,\n  SUSPENDED,\n  TO_BE_PLAYED,\n  WALKOVER,\n};\n","// stage types\nexport const MAIN = 'MAIN';\nexport const QUALIFYING = 'QUALIFYING';\nexport const CONSOLATION = 'CONSOLATION';\nexport const VOLUNTARY_CONSOLATION = 'VOLUNTARY_CONSOLATION';\nexport const PLAY_OFF = 'PLAY_OFF';\n\nexport const validStages = [\n  MAIN,\n  QUALIFYING,\n  CONSOLATION,\n  PLAY_OFF,\n  VOLUNTARY_CONSOLATION,\n];\n\nexport const stageOrder = {\n  [QUALIFYING]: 1,\n  [MAIN]: 2,\n  [PLAY_OFF]: 3,\n  [CONSOLATION]: 3,\n  [VOLUNTARY_CONSOLATION]: 4,\n};\n\nexport const FINISHING_POSITIONS = 'finishingPositions';\nexport const AGGREGATE_EVENT_STRUCTURES = 'aggregateEventStructures';\n\nexport const finishOrder = {\n  [MAIN]: 1,\n  [PLAY_OFF]: 2,\n  [CONSOLATION]: 3,\n  [QUALIFYING]: 4,\n  [VOLUNTARY_CONSOLATION]: 5,\n};\n\n// for aggregateOrder { stage: MAIN, stageSequence: 1 } is always first\nexport const aggregateOrder = {\n  [PLAY_OFF]: 1,\n  [MAIN]: 2,\n  [CONSOLATION]: 3,\n  [QUALIFYING]: 4,\n  [VOLUNTARY_CONSOLATION]: 5,\n};\n\n// seedingProfile.positioning\nexport const CLUSTER = 'CLUSTER';\nexport const SEPARATE = 'SEPARATE';\nexport const WATERFALL = 'WATERFALL';\n\n// structureType\nexport const ITEM = 'ITEM';\nexport const CONTAINER = 'CONTAINER';\n\n// positioningProfile\nexport const DRAW: any = 'DRAW';\nexport const RANDOM: any = 'RANDOM';\nexport const TOP_DOWN: any = 'TOP_DOWN';\nexport const BOTTOM_UP: any = 'BOTTOM_UP';\n\n// Match and Link types\nexport const POSITION: any = 'POSITION'; // participant advances based on their finishing position\nexport const WINNER: any = 'WINNER'; // participant advances based on winning a matchUp\nexport const LOSER: any = 'LOSER'; // partticipant advances based on losing a matchUp\nexport const FIRST_MATCHUP = 'FIRST_MATCHUP'; // condition for valididty of link\n\n// draw types\n// PLAY_OFF is also a stage type\nexport const AD_HOC = 'AD_HOC';\nexport const FLEX_ROUNDS = 'AD_HOC';\nexport const FEED_IN = 'FEED_IN';\nexport const COMPASS = 'COMPASS';\nexport const OLYMPIC = 'OLYMPIC';\nexport const KNOCKOUT = 'SINGLE_ELIMINATION';\nexport const ELIMINATION = 'SINGLE_ELIMINATION';\nexport const SINGLE_ELIMINATION = 'SINGLE_ELIMINATION';\nexport const DOUBLE_ELIMINATION = 'DOUBLE_ELIMINATION';\nexport const FIRST_MATCH_LOSER_CONSOLATION = 'FIRST_MATCH_LOSER_CONSOLATION';\nexport const FIRST_ROUND_LOSER_CONSOLATION = 'FIRST_ROUND_LOSER_CONSOLATION';\n\nexport const LUCKY_DRAW = 'LUCKY_DRAW';\nexport const CURTIS = 'CURTIS_CONSOLATION';\nexport const CURTIS_CONSOLATION = 'CURTIS_CONSOLATION';\n\nexport const FICSF = 'FEED_IN_CHAMPIONSHIP_TO_SF';\nexport const FEED_IN_CHAMPIONSHIP_TO_SF = 'FEED_IN_CHAMPIONSHIP_TO_SF';\nexport const FICQF = 'FEED_IN_CHAMPIONSHIP_TO_QF';\nexport const FEED_IN_CHAMPIONSHIP_TO_QF = 'FEED_IN_CHAMPIONSHIP_TO_QF';\nexport const FICR16 = 'FEED_IN_CHAMPIONSHIP_TO_R16';\nexport const FEED_IN_CHAMPIONSHIP_TO_R16 = 'FEED_IN_CHAMPIONSHIP_TO_R16';\nexport const MFIC = 'MODIFIED_FEED_IN_CHAMPIONSHIP';\nexport const MODIFIED_FEED_IN_CHAMPIONSHIP = 'MODIFIED_FEED_IN_CHAMPIONSHIP';\nexport const FEED_IN_CHAMPIONSHIP = 'FEED_IN_CHAMPIONSHIP';\n\nexport const ROUND_ROBIN = 'ROUND_ROBIN';\nexport const ROUND_ROBIN_WITH_PLAYOFF = 'ROUND_ROBIN_WITH_PLAYOFF';\n\n// structure naming\nexport const DECIDER = 'DECIDER';\nexport const BACKDRAW = 'BACKDRAW';\nexport const COMPASS_ATTRIBUTES = {\n  0: { name: 'East', abbreviation: 'E' },\n  '0-1': { name: 'West', abbreviation: 'W' },\n  '0-2': { name: 'North', abbreviation: 'N' },\n  '0-3': { name: 'Northeast', abbreviation: 'NE' },\n  '0-1-1': { name: 'South', abbreviation: 'S' },\n  '0-1-2': { name: 'Southwest', abbreviation: 'SW' },\n  '0-2-1': { name: 'Northwest', abbreviation: 'NW' },\n  '0-1-1-1': { name: 'Southeast', abbreviation: 'SE' },\n};\nexport const OLYMPIC_ATTRIBUTES = {\n  0: { name: 'East', abbreviation: 'E' },\n  '0-1': { name: 'West', abbreviation: 'W' },\n  '0-2': { name: 'North', abbreviation: 'N' },\n  '0-1-1': { name: 'South', abbreviation: 'S' },\n};\n\n// finishingPosition determination\nexport const WIN_RATIO = 'WIN_RATIO';\nexport const ROUND_OUTCOME = 'ROUND_OUTCOME';\n\nexport const MULTI_STRUCTURE_DRAWS = [\n  COMPASS,\n  CURTIS,\n  FEED_IN_CHAMPIONSHIP_TO_QF,\n  FEED_IN_CHAMPIONSHIP_TO_R16,\n  FEED_IN_CHAMPIONSHIP_TO_SF,\n  FEED_IN_CHAMPIONSHIP,\n  FICQF,\n  FICR16,\n  FICSF,\n  FIRST_MATCH_LOSER_CONSOLATION,\n  FIRST_ROUND_LOSER_CONSOLATION,\n  LUCKY_DRAW,\n  MODIFIED_FEED_IN_CHAMPIONSHIP,\n  OLYMPIC,\n  PLAY_OFF,\n  ROUND_ROBIN_WITH_PLAYOFF,\n];\n\nexport const generatedDrawTypes = [\n  AD_HOC,\n  COMPASS,\n  CURTIS,\n  DOUBLE_ELIMINATION,\n  FEED_IN_CHAMPIONSHIP_TO_QF,\n  FEED_IN_CHAMPIONSHIP_TO_R16,\n  FEED_IN_CHAMPIONSHIP_TO_SF,\n  FEED_IN_CHAMPIONSHIP,\n  FEED_IN,\n  FIRST_MATCH_LOSER_CONSOLATION,\n  FIRST_ROUND_LOSER_CONSOLATION,\n  LUCKY_DRAW,\n  MODIFIED_FEED_IN_CHAMPIONSHIP,\n  OLYMPIC,\n  PLAY_OFF,\n  ROUND_ROBIN,\n  ROUND_ROBIN_WITH_PLAYOFF,\n  SINGLE_ELIMINATION,\n];\n\nexport const drawDefinitionConstants = {\n  MAIN,\n  QUALIFYING,\n  CONSOLATION,\n\n  ITEM,\n  CONTAINER,\n\n  FIRST_MATCHUP,\n  WINNER,\n  LOSER,\n\n  AD_HOC,\n  FEED_IN,\n  FLEX_ROUNDS,\n  COMPASS,\n  PLAY_OFF,\n  OLYMPIC,\n  KNOCKOUT,\n  SINGLE_ELIMINATION,\n  DOUBLE_ELIMINATION,\n\n  CURTIS,\n  FICSF,\n  FICQF,\n  FICR16,\n  MFIC,\n\n  VOLUNTARY_CONSOLATION,\n  FIRST_MATCH_LOSER_CONSOLATION,\n  FIRST_ROUND_LOSER_CONSOLATION,\n  MODIFIED_FEED_IN_CHAMPIONSHIP,\n  FEED_IN_CHAMPIONSHIP_TO_R16,\n  FEED_IN_CHAMPIONSHIP_TO_QF,\n  FEED_IN_CHAMPIONSHIP_TO_SF,\n  FEED_IN_CHAMPIONSHIP,\n  LUCKY_DRAW,\n\n  ROUND_ROBIN_WITH_PLAYOFF,\n  ROUND_ROBIN,\n\n  DECIDER,\n  BACKDRAW,\n  COMPASS_ATTRIBUTES,\n  OLYMPIC_ATTRIBUTES,\n\n  DRAW,\n  RANDOM,\n  TOP_DOWN,\n  BOTTOM_UP,\n  WATERFALL,\n\n  WIN_RATIO,\n  ROUND_OUTCOME,\n\n  MULTI_STRUCTURE_DRAWS,\n  generatedDrawTypes,\n\n  stageOrder,\n  finishOrder,\n  AGGREGATE_EVENT_STRUCTURES,\n  FINISHING_POSITIONS,\n};\n\nexport default drawDefinitionConstants;\n","import { findExtension } from '../../acquire/findExtension';\n\nimport { completedMatchUpStatuses } from '../../constants/matchUpStatusConstants';\nimport { ROUND_TARGET } from '../../constants/extensionConstants';\nimport { Structure } from '../../types/tournamentTypes';\nimport {\n  aggregateOrder,\n  finishOrder,\n  stageOrder,\n  AGGREGATE_EVENT_STRUCTURES,\n  FINISHING_POSITIONS,\n  MAIN,\n} from '../../constants/drawDefinitionConstants';\n\nexport function structureSort(\n  a: Structure | undefined,\n  b: Structure | undefined,\n  config?\n): number {\n  const getRoundTarget = (element) =>\n    findExtension({ element, name: ROUND_TARGET })?.extension?.value;\n\n  const completed = config?.deprioritizeCompleted;\n  const aggregate =\n    config?.mode === AGGREGATE_EVENT_STRUCTURES && aggregateOrder;\n  const finish = config?.mode === FINISHING_POSITIONS && finishOrder;\n\n  const orderProtocol = finish || aggregate || stageOrder;\n\n  const isMain1 = (s) => s?.stage === MAIN && s?.stageSequence === 1;\n  const protocolSequence = (s): number =>\n    isMain1(s) ? -1 : orderProtocol[s?.stage];\n\n  const completedStructure = (s): number =>\n    s?.matchUps.every(({ matchUpStatus }) =>\n      completedMatchUpStatuses.includes(matchUpStatus) ? 1 : -1\n    );\n\n  return (\n    (completed && completedStructure(a) - completedStructure(b)) ||\n    (aggregate && protocolSequence(a) - protocolSequence(b)) ||\n    ((a?.stage && orderProtocol[a.stage]) || 0) -\n      ((b?.stage && orderProtocol[b.stage]) || 0) ||\n    (getRoundTarget(a) || 0) - (getRoundTarget(b) || 0) ||\n    (!finish &&\n      !aggregate &&\n      (b?.positionAssignments?.length ?? Infinity) -\n        (a?.positionAssignments?.length ?? Infinity)) ||\n    (a?.stageSequence ?? 0) - (b?.stageSequence ?? 0) ||\n    (getMinFinishingPositionRange(a) || 0) -\n      (getMinFinishingPositionRange(b) || 0)\n  );\n}\n\nexport function getMinFinishingPositionRange(structure): number {\n  return (structure?.matchUps || []).reduce((rangeSum, matchUp) => {\n    const sum = (matchUp.finishingPositionRange?.winner || []).reduce(\n      (a, b) => a + b,\n      0\n    );\n    return !rangeSum || sum < rangeSum ? sum : rangeSum;\n  }, undefined);\n}\n","import { findExtension } from './findExtension';\nimport { ResultType } from '../global/functions/decorateResult';\nimport { structureSort } from '../functions/sorters/structureSort';\n\nimport { DrawDefinition, Structure } from '../types/tournamentTypes';\nimport { ITEM, validStages } from '../constants/drawDefinitionConstants';\nimport { ROUND_TARGET } from '../constants/extensionConstants';\nimport { StructureSortConfig } from '../types/factoryTypes';\nimport {\n  MISSING_STRUCTURES,\n  STRUCTURE_NOT_FOUND,\n  MISSING_STRUCTURE_ID,\n  MISSING_DRAW_DEFINITION,\n} from '../constants/errorConditionConstants';\n\ntype FindStructureArgs = {\n  drawDefinition?: DrawDefinition;\n  structureId?: string;\n};\n\ntype FoundStructureResult = {\n  containingStructure?: Structure;\n  structure?: Structure;\n};\n\nexport function findStructure({\n  drawDefinition,\n  structureId,\n}: FindStructureArgs): ResultType & FoundStructureResult {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structureId) return { error: MISSING_STRUCTURE_ID };\n  const { structures } = getDrawStructures({ drawDefinition });\n  const allStructures = structures\n    ?.map((structure) => {\n      return structure.structures\n        ? [...structure.structures].concat(structure)\n        : structure;\n    })\n    .flat();\n\n  const structure = allStructures?.find(\n    (structure) => structure.structureId === structureId\n  );\n\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  const containingStructure =\n    structure.structureType === ITEM\n      ? allStructures?.find(\n          (s) => s.structures?.some((s) => s.structureId === structureId)\n        )\n      : undefined;\n\n  return { structure, containingStructure };\n}\n\ntype GetDrawStructuresArgs = {\n  sortConfig?: StructureSortConfig;\n  drawDefinition?: DrawDefinition;\n  withStageGrouping?: boolean;\n  stageSequences?: string[];\n  stageSequence?: number;\n  roundTarget?: number;\n  stages?: string[];\n  stage?: string;\n};\n\ntype FoundDrawStructure = {\n  stageStructures: { [key: string]: Structure[] };\n  structures: Structure[];\n};\n\nexport function getDrawStructures({\n  withStageGrouping,\n  drawDefinition,\n  stageSequences,\n  stageSequence,\n  roundTarget,\n  sortConfig,\n  stages,\n  stage,\n}: GetDrawStructuresArgs): ResultType & FoundDrawStructure {\n  const error =\n    (!drawDefinition && MISSING_DRAW_DEFINITION) ||\n    (!drawDefinition?.structures && MISSING_STRUCTURES) ||\n    undefined;\n\n  if (error) return { error, structures: [], stageStructures: {} };\n\n  const isRoundTarget = (structure) => {\n    const value = findExtension({\n      element: structure,\n      name: ROUND_TARGET,\n    })?.extension?.value;\n    return !roundTarget || roundTarget === value;\n  };\n\n  const structures =\n    drawDefinition?.structures\n      ?.filter(isStage)\n      .filter(isStageSequence)\n      .filter(isRoundTarget)\n      .sort((a, b) => structureSort(a, b, sortConfig)) ?? [];\n\n  const stageStructures = withStageGrouping\n    ? Object.assign(\n        {},\n        ...validStages\n          .map((stage) => {\n            const relevantStructures = structures?.filter(\n              (structure) => structure.stage === stage\n            );\n            return (\n              relevantStructures?.length && { [stage]: relevantStructures }\n            );\n          })\n          .filter(Boolean)\n      )\n    : {};\n\n  return { structures, stageStructures };\n\n  function isStage(structure) {\n    return (\n      (!stage && !Array.isArray(stages)) ||\n      (stage && structure.stage === stage) ||\n      (Array.isArray(stages) && stages.includes(structure.stage))\n    );\n  }\n  function isStageSequence(structure) {\n    return (\n      (!stageSequence && !Array.isArray(stageSequences)) ||\n      (stageSequence && structure.stageSequence === stageSequence) ||\n      (Array.isArray(stageSequences) &&\n        stageSequences.includes(structure.stageSequence))\n    );\n  }\n}\n","import { xa } from '../../utilities/objects';\nimport { findStructure } from '../../acquire/findStructure';\n\nimport { DrawDefinition, PositionAssignment, Structure } from '../../types/tournamentTypes';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport {\n  ErrorType,\n  MISSING_DRAW_DEFINITION,\n  MISSING_POSITION_ASSIGNMENTS,\n} from '../../constants/errorConditionConstants';\n\nexport function getAllPositionedParticipantIds({ drawDefinition }): ResultType & {\n  allPositionedParticipantIds?: string[];\n  stagePositionedParticipantIds?: { [key: string]: string[] };\n} {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  const stagePositionedParticipantIds = {};\n\n  const allPositionedParticipantIds = (drawDefinition.structures || [])\n    .map((structure) => {\n      const stage = structure.stage;\n      if (!stagePositionedParticipantIds[stage]) stagePositionedParticipantIds[stage] = [];\n      const { positionAssignments } = getPositionAssignments({ structure });\n      const particiapntIds = positionAssignments?.map(xa('participantId')).filter(Boolean) ?? [];\n      stagePositionedParticipantIds[stage].push(...particiapntIds);\n      return particiapntIds;\n    })\n    .flat();\n  return { allPositionedParticipantIds, stagePositionedParticipantIds };\n}\n\ntype GetPositionAssignmentsArgs = {\n  structureId?: string;\n  drawDefinition?: any;\n  structure?: any;\n};\n\nexport function getPositionAssignments({ drawDefinition, structureId, structure }: GetPositionAssignmentsArgs): {\n  positionAssignments: PositionAssignment[];\n  error?: ErrorType;\n} {\n  let error: any,\n    positionAssignments: PositionAssignment[] = [];\n  if (!structure) {\n    if (!drawDefinition) {\n      return { positionAssignments, error: MISSING_DRAW_DEFINITION };\n    }\n    ({ structure, error } = findStructure({ drawDefinition, structureId }));\n    if (error) return { positionAssignments, error };\n  }\n\n  if (structure.structures) {\n    positionAssignments = [].concat(\n      ...structure.structures.map((structure) => {\n        return getPositionAssignments({ structure }).positionAssignments;\n      }),\n    );\n  } else if (structure.positionAssignments) {\n    positionAssignments = structure.positionAssignments;\n  } else {\n    error = MISSING_POSITION_ASSIGNMENTS;\n  }\n\n  return { positionAssignments, error };\n}\n\ntype StructureAssignedDrawPositionsArgs = {\n  drawDefinition?: DrawDefinition;\n  structure?: Structure;\n  structureId?: string;\n};\nexport function structureAssignedDrawPositions({\n  drawDefinition,\n  structureId,\n  structure,\n}: StructureAssignedDrawPositionsArgs): {\n  positionAssignments: PositionAssignment[];\n  allPositionsAssigned?: boolean;\n  unassignedPositions;\n  assignedPositions;\n  qualifierPositions;\n  byePositions;\n} {\n  const positionAssignments =\n    getPositionAssignments({\n      drawDefinition,\n      structureId,\n      structure,\n    })?.positionAssignments || [];\n  const assignedPositions = positionAssignments?.filter((assignment) => {\n    return assignment.participantId ?? assignment.bye ?? assignment.qualifier;\n  });\n  const allPositionsAssigned = positionAssignments && positionAssignments?.length === assignedPositions?.length;\n  const unassignedPositions = positionAssignments?.filter((assignment) => {\n    return !assignment.participantId && !assignment.bye && !assignment.qualifier;\n  });\n  const byePositions = positionAssignments?.filter((assignment) => {\n    return !assignment.participantId && assignment.bye;\n  });\n  const qualifierPositions = positionAssignments?.filter((assignment) => {\n    return !assignment.participantId && assignment.qualifier;\n  });\n\n  return {\n    allPositionsAssigned,\n    positionAssignments,\n    unassignedPositions,\n    assignedPositions,\n    qualifierPositions,\n    byePositions,\n  };\n}\n","export type SignedInStatusUnion = typeof SIGNED_IN | typeof SIGNED_OUT;\nexport const SIGN_IN_STATUS = 'SIGN_IN_STATUS';\nexport const SIGNED_OUT = 'SIGNED_OUT';\nexport const SIGNED_IN = 'SIGNED_IN';\n\nexport const TEAM_PARTICIPANT = 'TEAM';\nexport const INDIVIDUAL = 'INDIVIDUAL';\nexport const GROUP = 'GROUP';\nexport const PAIR = 'PAIR';\nexport const TEAM = 'TEAM';\n\nexport const participantTypes = {\n  TEAM_PARTICIPANT,\n  INDIVIDUAL,\n  GROUP,\n  TEAM,\n  PAIR,\n};\n\nexport const participantConstants = {\n  INDIVIDUAL,\n  GROUP,\n  PAIR,\n  TEAM,\n\n  SIGN_IN_STATUS,\n  SIGNED_OUT,\n  SIGNED_IN,\n};\n","import { makeDeepCopy } from '../../../../utilities/makeDeepCopy';\n\nimport { ParticipantsProfile } from '../../../../types/factoryTypes';\nimport { Participant } from '../../../../types/tournamentTypes';\nimport {\n  GROUP,\n  INDIVIDUAL,\n  PAIR,\n  TEAM,\n} from '../../../../constants/participantConstants';\n\ntype AddParticipantGroupingsArgs = {\n  participantsProfile?: ParticipantsProfile;\n  participants?: Participant[];\n  deepCopy?: boolean;\n};\n\nexport function addParticipantGroupings({\n  participantsProfile,\n  participants = [],\n  deepCopy, // will skip deepCopy only if false\n}: AddParticipantGroupingsArgs) {\n  const groupMap = new Map<\n    string,\n    { participantId: string; participantName: string }\n  >();\n\n  const participantsWithGroupings =\n    deepCopy !== false\n      ? makeDeepCopy(participants, participantsProfile?.convertExtensions, true)\n      : participants;\n  const teamParticipants = participantsWithGroupings.filter(\n    (participant) => participant.participantType === TEAM\n  );\n  const groupParticipants = participantsWithGroupings.filter(\n    (participant) => participant.participantType === GROUP\n  );\n\n  // should pairParticipants only consider those that are in the same event as current draw?\n  // TODO: this requires access to the parent event which is not currently in scope\n  const pairParticipants = participantsWithGroupings.filter(\n    (participant) => participant.participantType === PAIR\n  );\n\n  participantsWithGroupings.forEach((participant) => {\n    if (participant.participantType === INDIVIDUAL) {\n      const { participantId } = participant;\n      participant.groupParticipantIds = [];\n      participant.teamParticipantIds = [];\n      participant.pairParticipantIds = [];\n      participant.groups = [];\n      participant.teams = [];\n\n      teamParticipants.forEach((team) => {\n        (team?.individualParticipantIds || []).forEach(\n          (individualParticipantId) => {\n            if (\n              individualParticipantId === participantId &&\n              !participant.teamParticipantIds?.includes(team.participantId)\n            ) {\n              participant.teamParticipantIds.push(team.participantId);\n              if (!groupMap.get(team.participantId))\n                groupMap.set(team.participantId, {\n                  participantName: team.participantName,\n                  participantId: team.participantId,\n                });\n              participant.teams.push({\n                participantRoleResponsibilities:\n                  team.participantRoleResponsibilities,\n                participantOtherName: team.participantOtherName,\n                participantName: team.participantName,\n                participantId: team.participantId,\n                teamId: team.teamId,\n              });\n            }\n          }\n        );\n      });\n      pairParticipants.forEach((pair) => {\n        (pair?.individualParticipantIds || []).forEach(\n          (individualParticipantId) => {\n            if (\n              individualParticipantId === participantId &&\n              !participant.pairParticipantIds.includes(pair.participantId)\n            ) {\n              participant.pairParticipantIds.push(pair.participantId);\n            }\n          }\n        );\n      });\n      groupParticipants.forEach((group) => {\n        (group?.individualParticipantIds || []).forEach(\n          (individualParticipantId) => {\n            if (\n              individualParticipantId === participantId &&\n              !participant.groupParticipantIds.includes(group.participantId)\n            ) {\n              participant.groupParticipantIds.push(group.participantId);\n              participant.groups.push({\n                participantRoleResponsibilities:\n                  group.participantRoleResponsibilities,\n                participantOtherName: group.participantOtherName,\n                participantName: group.participantName,\n                participantId: group.participantId,\n              });\n            }\n          }\n        );\n      });\n    }\n  });\n\n  return { participantsWithGroupings, groupInfo: Object.fromEntries(groupMap) };\n}\n","// ISO- 3166-1 alpha-2\n\nexport function countryToFlag(isoCode: string): string {\n  return isoCode && typeof String.fromCodePoint !== 'undefined'\n    ? isoCode\n        .toUpperCase()\n        .replace(/./g, (char) =>\n          String.fromCodePoint(char.charCodeAt(0) + 127397)\n        )\n    : isoCode;\n}\n\nexport function flagIOC(ioc: string): string {\n  const ioc2iso = Object.assign(\n    {},\n    ...countries.filter((c) => c.ioc).map((c) => ({ [c.ioc]: c.iso }))\n  );\n  return countryToFlag(ioc2iso[ioc]);\n}\n\nexport const countries = [\n  {\n    ioc: '',\n    iso2: '',\n    iso: '',\n    label: 'NONE',\n    phone: '',\n  },\n  {\n    ioc: 'AND',\n    iso2: 'AD',\n    iso: 'AND',\n    label: 'Andorra',\n    phone: '376',\n  },\n  {\n    ioc: 'UAE',\n    iso2: 'AE',\n    iso: 'ARE',\n    label: 'United Arab Emirates',\n    phone: '971',\n  },\n  {\n    ioc: 'AFG',\n    iso2: 'AF',\n    iso: 'AFG',\n    label: 'Afghanistan',\n    phone: '93',\n  },\n  {\n    ioc: 'ANT',\n    iso2: 'AG',\n    iso: 'ATG',\n    label: 'Antigua and Barbuda',\n    phone: '1-268',\n  },\n  {\n    ioc: 'AIA',\n    iso2: 'AI',\n    iso: 'AIA',\n    label: 'Anguilla',\n    phone: '1-264',\n  },\n  {\n    ioc: 'ALB',\n    iso2: 'AL',\n    iso: 'ALB',\n    label: 'Albania',\n    phone: '355',\n  },\n  {\n    ioc: 'ARM',\n    iso2: 'AM',\n    iso: 'ARM',\n    label: 'Armenia',\n    phone: '374',\n  },\n  {\n    ioc: 'ANG',\n    iso2: 'AO',\n    iso: 'AGO',\n    label: 'Angola',\n    phone: '244',\n  },\n  {\n    ioc: '',\n    iso2: 'AQ',\n    iso: 'ATA',\n    label: 'Antarctica',\n    phone: '672',\n  },\n  {\n    ioc: 'ARG',\n    iso2: 'AR',\n    iso: 'ARG',\n    label: 'Argentina',\n    phone: '54',\n  },\n  {\n    ioc: 'ASA',\n    iso2: 'AS',\n    iso: 'ASM',\n    label: 'American Samoa',\n    phone: '1-684',\n  },\n  {\n    ioc: 'AUT',\n    iso2: 'AT',\n    iso: 'AUT',\n    label: 'Austria',\n    phone: '43',\n  },\n  {\n    ioc: 'AUS',\n    iso2: 'AU',\n    iso: 'AUS',\n    label: 'Australia',\n    phone: '61',\n    suggested: true,\n  },\n  {\n    ioc: 'ARU',\n    iso2: 'AW',\n    iso: 'ABW',\n    label: 'Aruba',\n    phone: '297',\n  },\n  {\n    ioc: 'AZE',\n    iso2: 'AZ',\n    iso: 'AZE',\n    label: 'Azerbaijan',\n    phone: '994',\n  },\n  {\n    ioc: 'BIH',\n    iso2: 'BA',\n    iso: 'BIH',\n    label: 'Bosnia and Herzegovina',\n    phone: '387',\n  },\n  {\n    ioc: 'BAR',\n    iso2: 'BB',\n    iso: 'BRB',\n    label: 'Barbados',\n    phone: '1-246',\n  },\n  {\n    ioc: 'BAN',\n    iso2: 'BD',\n    iso: 'BGD',\n    label: 'Bangladesh',\n    phone: '880',\n  },\n  {\n    ioc: 'BEL',\n    iso2: 'BE',\n    iso: 'BEL',\n    label: 'Belgium',\n    phone: '32',\n  },\n  {\n    ioc: 'BUR',\n    iso2: 'BF',\n    iso: 'BFA',\n    label: 'Burkina Faso',\n    phone: '226',\n  },\n  {\n    ioc: 'BUL',\n    iso2: 'BG',\n    iso: 'BGR',\n    label: 'Bulgaria',\n    phone: '359',\n  },\n  {\n    ioc: 'BRN',\n    iso2: 'BH',\n    iso: 'BHR',\n    label: 'Bahrain',\n    phone: '973',\n  },\n  {\n    ioc: 'BDI',\n    iso2: 'BI',\n    iso: 'BDI',\n    label: 'Burundi',\n    phone: '257',\n  },\n  {\n    ioc: 'BEN',\n    iso2: 'BJ',\n    iso: 'BEN',\n    label: 'Benin',\n    phone: '229',\n  },\n  {\n    ioc: '',\n    iso2: 'BL',\n    iso: 'BLM',\n    label: 'Saint Barthelemy',\n    phone: '590',\n  },\n  {\n    ioc: 'BER',\n    iso2: 'BM',\n    iso: 'BMU',\n    label: 'Bermuda',\n    phone: '1-441',\n  },\n  {\n    ioc: 'BRU',\n    iso2: 'BN',\n    iso: 'BRN',\n    label: 'Brunei Darussalam',\n    phone: '673',\n  },\n  {\n    ioc: 'BOL',\n    iso2: 'BO',\n    iso: 'BOL',\n    label: 'Bolivia',\n    phone: '591',\n  },\n  {\n    ioc: 'BRA',\n    iso2: 'BR',\n    iso: 'BRA',\n    label: 'Brazil',\n    phone: '55',\n  },\n  {\n    ioc: 'BAH',\n    iso2: 'BS',\n    iso: 'BHS',\n    label: 'Bahamas',\n    phone: '1-242',\n  },\n  {\n    ioc: 'BHU',\n    iso2: 'BT',\n    iso: 'BTN',\n    label: 'Bhutan',\n    phone: '975',\n  },\n  {\n    ioc: '',\n    iso2: 'BV',\n    iso: 'BVT',\n    label: 'Bouvet Island',\n    phone: '47',\n  },\n  {\n    ioc: 'BOT',\n    iso2: 'BW',\n    iso: 'BWA',\n    label: 'Botswana',\n    phone: '267',\n  },\n  {\n    ioc: 'BLR',\n    iso2: 'BY',\n    iso: 'BLR',\n    label: 'Belarus',\n    phone: '375',\n  },\n  {\n    ioc: 'BIZ',\n    iso2: 'BZ',\n    iso: 'BLZ',\n    label: 'Belize',\n    phone: '501',\n  },\n  {\n    ioc: 'CAN',\n    iso2: 'CA',\n    iso: 'CAN',\n    label: 'Canada',\n    phone: '1',\n    suggested: true,\n  },\n  {\n    ioc: '',\n    iso2: 'CC',\n    iso: 'CCK',\n    label: 'Cocos (Keeling) Islands',\n    phone: '61',\n  },\n  {\n    ioc: 'CGO',\n    iso2: 'CD',\n    iso: 'COG',\n    label: 'Congo, Republic of the',\n    phone: '242',\n  },\n  {\n    ioc: 'CAF',\n    iso2: 'CF',\n    iso: 'CAF',\n    label: 'Central African Republic',\n    phone: '236',\n  },\n  {\n    ioc: 'COD',\n    iso2: 'CG',\n    iso: 'CGD',\n    label: 'Congo, Democratic Republic of the',\n    phone: '243',\n  },\n  {\n    ioc: 'SUI',\n    iso2: 'CH',\n    iso: 'CHE',\n    label: 'Switzerland',\n    phone: '41',\n  },\n  {\n    ioc: 'CIV',\n    iso2: 'CI',\n    iso: 'CIV',\n    label: \"Cote d'Ivoire\",\n    phone: '225',\n  },\n  {\n    ioc: 'COK',\n    iso2: 'CK',\n    iso: 'COK',\n    label: 'Cook Islands',\n    phone: '682',\n  },\n  {\n    ioc: 'CHI',\n    iso2: 'CL',\n    iso: 'CHL',\n    label: 'Chile',\n    phone: '56',\n  },\n  {\n    ioc: 'CMR',\n    iso2: 'CM',\n    iso: 'CMR',\n    label: 'Cameroon',\n    phone: '237',\n  },\n  {\n    ioc: 'CHN',\n    iso2: 'CN',\n    iso: 'CHN',\n    label: 'China',\n    phone: '86',\n  },\n  {\n    ioc: 'COL',\n    iso2: 'CO',\n    iso: 'COL',\n    label: 'Colombia',\n    phone: '57',\n  },\n  {\n    ioc: 'CRC',\n    iso2: 'CR',\n    iso: 'CRI',\n    label: 'Costa Rica',\n    phone: '506',\n  },\n  {\n    ioc: 'CUB',\n    iso2: 'CU',\n    iso: 'CUB',\n    label: 'Cuba',\n    phone: '53',\n  },\n  {\n    ioc: 'CPV',\n    iso2: 'CV',\n    iso: 'CPV',\n    label: 'Cape Verde',\n    phone: '238',\n  },\n  {\n    ioc: 'CUW',\n    iso2: 'CW',\n    iso: 'CUW',\n    label: 'Curacao',\n    phone: '599',\n  },\n  {\n    ioc: 'CXR',\n    iso2: 'CX',\n    iso: 'CXR',\n    label: 'Christmas Island',\n    phone: '61',\n  },\n  {\n    ioc: 'CYP',\n    iso2: 'CY',\n    iso: 'CYP',\n    label: 'Cyprus',\n    phone: '357',\n  },\n  {\n    ioc: 'CZE',\n    iso2: 'CZ',\n    iso: 'CZE',\n    label: 'Czech Republic',\n    phone: '420',\n  },\n  {\n    ioc: 'GER',\n    iso2: 'DE',\n    iso: 'DEU',\n    label: 'Germany',\n    phone: '49',\n    suggested: true,\n  },\n  {\n    ioc: 'DJI',\n    iso2: 'DJ',\n    iso: 'DJI',\n    label: 'Djibouti',\n    phone: '253',\n  },\n  {\n    ioc: 'DEN',\n    iso2: 'DK',\n    iso: 'DNK',\n    label: 'Denmark',\n    phone: '45',\n  },\n  {\n    ioc: 'DMA',\n    iso2: 'DM',\n    iso: 'DMA',\n    label: 'Dominica',\n    phone: '1-767',\n  },\n  {\n    ioc: 'DOM',\n    iso2: 'DO',\n    iso: 'DOM',\n    label: 'Dominican Republic',\n    phone: '1-809',\n  },\n  {\n    ioc: 'ALG',\n    iso2: 'DZ',\n    iso: 'DZA',\n    label: 'Algeria',\n    phone: '213',\n  },\n  {\n    ioc: 'ECU',\n    iso2: 'EC',\n    iso: 'ECU',\n    label: 'Ecuador',\n    phone: '593',\n  },\n  {\n    ioc: 'EST',\n    iso2: 'EE',\n    iso: 'ESE',\n    label: 'Estonia',\n    phone: '372',\n  },\n  {\n    ioc: 'EGY',\n    iso2: 'EG',\n    iso: 'EGY',\n    label: 'Egypt',\n    phone: '20',\n  },\n  {\n    ioc: '',\n    iso2: 'EH',\n    iso: 'ESH',\n    label: 'Western Sahara',\n    phone: '212',\n  },\n  {\n    ioc: 'ERI',\n    iso2: 'ER',\n    iso: 'ERI',\n    label: 'Eritrea',\n    phone: '291',\n  },\n  {\n    ioc: 'ESP',\n    iso2: 'ES',\n    iso: 'ESP',\n    label: 'Spain',\n    phone: '34',\n  },\n  {\n    ioc: 'ETH',\n    iso2: 'ET',\n    iso: 'ETH',\n    label: 'Ethiopia',\n    phone: '251',\n  },\n  {\n    ioc: 'FIN',\n    iso2: 'FI',\n    iso: 'FIN',\n    label: 'Finland',\n    phone: '358',\n  },\n  {\n    ioc: 'FIJ',\n    iso2: 'FJ',\n    iso: 'FJI',\n    label: 'Fiji',\n    phone: '679',\n  },\n  {\n    ioc: 'FLK',\n    iso2: 'FK',\n    iso: 'FLK',\n    label: 'Falkland Islands (Malvinas)',\n    phone: '500',\n  },\n  {\n    ioc: 'FSM',\n    iso2: 'FM',\n    iso: 'FSM',\n    label: 'Micronesia, Federated States of',\n    phone: '691',\n  },\n  {\n    ioc: 'FAR',\n    iso2: 'FO',\n    iso: 'FRO',\n    label: 'Faroe Islands',\n    phone: '298',\n  },\n  {\n    ioc: 'FRA',\n    iso2: 'FR',\n    iso: 'FRA',\n    label: 'France',\n    phone: '33',\n    suggested: true,\n  },\n  {\n    ioc: 'GAB',\n    iso2: 'GA',\n    iso: 'GAB',\n    label: 'Gabon',\n    phone: '241',\n  },\n  {\n    ioc: 'GBR',\n    iso2: 'GB',\n    iso: 'GBR',\n    label: 'United Kingdom',\n    phone: '44',\n  },\n  {\n    ioc: 'GRN',\n    iso2: 'GD',\n    iso: 'GRD',\n    label: 'Grenada',\n    phone: '1-473',\n  },\n  {\n    ioc: 'GEO',\n    iso2: 'GE',\n    iso: 'GEO',\n    label: 'Georgia',\n    phone: '995',\n  },\n  {\n    ioc: 'FGU',\n    iso2: 'GF',\n    iso: 'GUF',\n    label: 'French Guiana',\n    phone: '594',\n  },\n  {\n    ioc: '',\n    iso2: 'GG',\n    iso: 'GGY',\n    label: 'Guernsey',\n    phone: '44',\n  },\n  {\n    ioc: '',\n    iso2: 'GH',\n    iso: 'GHA',\n    label: 'Ghana',\n    phone: '233',\n  },\n  {\n    ioc: 'GIB',\n    iso2: 'GI',\n    iso: 'GIB',\n    label: 'Gibraltar',\n    phone: '350',\n  },\n  {\n    ioc: 'GRL',\n    iso2: 'GL',\n    iso: 'GRL',\n    label: 'Greenland',\n    phone: '299',\n  },\n  {\n    ioc: 'GAM',\n    iso2: 'GM',\n    iso: 'GMB',\n    label: 'Gambia',\n    phone: '220',\n  },\n  {\n    ioc: 'GUI',\n    iso2: 'GN',\n    iso: 'GIN',\n    label: 'Guinea',\n    phone: '224',\n  },\n  {\n    ioc: 'GUD',\n    iso2: 'GP',\n    iso: 'GLP',\n    label: 'Guadeloupe',\n    phone: '590',\n  },\n  {\n    ioc: 'GEQ',\n    iso2: 'GQ',\n    iso: 'GNQ',\n    label: 'Equatorial Guinea',\n    phone: '240',\n  },\n  {\n    ioc: 'GRE',\n    iso2: 'GR',\n    iso: 'GRC',\n    label: 'Greece',\n    phone: '30',\n  },\n  {\n    ioc: '',\n    iso2: 'GS',\n    iso: 'SGS',\n    label: 'South Georgia and the South Sandwich Islands',\n    phone: '500',\n  },\n  {\n    ioc: 'GUA',\n    iso2: 'GT',\n    iso: 'GTM',\n    label: 'Guatemala',\n    phone: '502',\n  },\n  {\n    ioc: 'GUM',\n    iso2: 'GU',\n    iso: 'GUM',\n    label: 'Guam',\n    phone: '1-671',\n  },\n  {\n    ioc: 'GBS',\n    iso2: 'GW',\n    iso: 'GNB',\n    label: 'Guinea-Bissau',\n    phone: '245',\n  },\n  {\n    ioc: 'GUY',\n    iso2: 'GY',\n    iso: 'GUY',\n    label: 'Guyana',\n    phone: '592',\n  },\n  {\n    ioc: 'HKG',\n    iso2: 'HK',\n    iso: 'HKG',\n    label: 'Hong Kong',\n    phone: '852',\n  },\n  {\n    ioc: '',\n    iso2: 'HM',\n    iso: 'HMD',\n    label: 'Heard Island and McDonald Islands',\n    phone: '672',\n  },\n  {\n    ioc: 'HON',\n    iso2: 'HN',\n    iso: 'HND',\n    label: 'Honduras',\n    phone: '504',\n  },\n  {\n    ioc: 'CRO',\n    iso2: 'HR',\n    iso: 'HRV',\n    label: 'Croatia',\n    phone: '385',\n  },\n  {\n    ioc: 'HAI',\n    iso2: 'HT',\n    iso: 'HTI',\n    label: 'Haiti',\n    phone: '509',\n  },\n  {\n    ioc: 'HUN',\n    iso2: 'HU',\n    iso: 'HUN',\n    label: 'Hungary',\n    phone: '36',\n  },\n  {\n    ioc: 'INA',\n    iso2: 'ID',\n    iso: 'IDN',\n    label: 'Indonesia',\n    phone: '62',\n  },\n  {\n    ioc: 'IRL',\n    iso2: 'IE',\n    iso: 'IRL',\n    label: 'Ireland',\n    phone: '353',\n  },\n  {\n    ioc: 'ISR',\n    iso2: 'IL',\n    iso: 'ISR',\n    label: 'Israel',\n    phone: '972',\n  },\n  {\n    ioc: '',\n    iso2: 'IM',\n    iso: 'IMN',\n    label: 'Isle of Man',\n    phone: '44',\n  },\n  {\n    ioc: 'IND',\n    iso2: 'IN',\n    iso: 'IND',\n    label: 'India',\n    phone: '91',\n  },\n  {\n    ioc: '',\n    iso2: 'IO',\n    iso: 'IOT',\n    label: 'British Indian Ocean Territory',\n    phone: '246',\n  },\n  {\n    ioc: 'IRQ',\n    iso2: 'IQ',\n    iso: 'IRQ',\n    label: 'Iraq',\n    phone: '964',\n  },\n  {\n    ioc: 'IRI',\n    iso2: 'IR',\n    iso: 'IRN',\n    label: 'Iran, Islamic Republic of',\n    phone: '98',\n  },\n  {\n    ioc: 'ISL',\n    iso2: 'IS',\n    iso: 'ISL',\n    label: 'Iceland',\n    phone: '354',\n  },\n  {\n    ioc: 'ITA',\n    iso2: 'IT',\n    iso: 'ITA',\n    label: 'Italy',\n    phone: '39',\n  },\n  {\n    ioc: '',\n    iso2: 'JE',\n    iso: 'JEY',\n    label: 'Jersey',\n    phone: '44',\n  },\n  {\n    ioc: 'JAM',\n    iso2: 'JM',\n    iso: 'JAM',\n    label: 'Jamaica',\n    phone: '1-876',\n  },\n  {\n    ioc: 'JOR',\n    iso2: 'JO',\n    iso: 'JOR',\n    label: 'Jordan',\n    phone: '962',\n  },\n  {\n    ioc: 'JPN',\n    iso2: 'JP',\n    iso: 'JPN',\n    label: 'Japan',\n    phone: '81',\n    suggested: true,\n  },\n  {\n    ioc: 'KEN',\n    iso2: 'KE',\n    iso: 'KEN',\n    label: 'Kenya',\n    phone: '254',\n  },\n  {\n    ioc: 'KGZ',\n    iso2: 'KG',\n    iso: 'KGZ',\n    label: 'Kyrgyzstan',\n    phone: '996',\n  },\n  {\n    ioc: 'CAM',\n    iso2: 'KH',\n    iso: 'KHM',\n    label: 'Cambodia',\n    phone: '855',\n  },\n  {\n    ioc: 'KIR',\n    iso2: 'KI',\n    iso: 'KIR',\n    label: 'Kiribati',\n    phone: '686',\n  },\n  {\n    ioc: 'COM',\n    iso2: 'KM',\n    iso: 'COM',\n    label: 'Comoros',\n    phone: '269',\n  },\n  {\n    ioc: 'SKN',\n    iso2: 'KN',\n    iso: 'KNA',\n    label: 'Saint Kitts and Nevis',\n    phone: '1-869',\n  },\n  {\n    ioc: 'KOR',\n    iso2: 'KP',\n    iso: 'KOR',\n    label: \"Korea, Democratic People's Republic of\",\n    phone: '850',\n  },\n  {\n    ioc: 'PRK',\n    iso2: 'KR',\n    iso: 'PRK',\n    label: 'Korea, Republic of',\n    phone: '82',\n  },\n  {\n    ioc: 'KUW',\n    iso2: 'KW',\n    iso: 'KWT',\n    label: 'Kuwait',\n    phone: '965',\n  },\n  {\n    ioc: 'CAY',\n    iso2: 'KY',\n    iso: 'CYM',\n    label: 'Cayman Islands',\n    phone: '1-345',\n  },\n  {\n    ioc: 'KAZ',\n    iso2: 'KZ',\n    iso: 'KAZ',\n    label: 'Kazakhstan',\n    phone: '7',\n  },\n  {\n    ioc: 'LAO',\n    iso2: 'LA',\n    iso: 'LAO',\n    label: \"Lao People's Democratic Republic\",\n    phone: '856',\n  },\n  {\n    ioc: 'LIB',\n    iso2: 'LB',\n    iso: 'LBN',\n    label: 'Lebanon',\n    phone: '961',\n  },\n  {\n    ioc: 'LCA',\n    iso2: 'LC',\n    iso: 'LCA',\n    label: 'Saint Lucia',\n    phone: '1-758',\n  },\n  {\n    ioc: 'LIE',\n    iso2: 'LI',\n    iso: 'LIE',\n    label: 'Liechtenstein',\n    phone: '423',\n  },\n  {\n    ioc: 'SRI',\n    iso2: 'LK',\n    iso: 'LKA',\n    label: 'Sri Lanka',\n    phone: '94',\n  },\n  {\n    ioc: 'LBR',\n    iso2: 'LR',\n    iso: 'LBR',\n    label: 'Liberia',\n    phone: '231',\n  },\n  {\n    ioc: 'LES',\n    iso2: 'LS',\n    iso: 'LSO',\n    label: 'Lesotho',\n    phone: '266',\n  },\n  {\n    ioc: 'LTU',\n    iso2: 'LT',\n    iso: 'LTU',\n    label: 'Lithuania',\n    phone: '370',\n  },\n  {\n    ioc: 'LUX',\n    iso2: 'LU',\n    iso: 'LUX',\n    label: 'Luxembourg',\n    phone: '352',\n  },\n  {\n    ioc: 'LAT',\n    iso2: 'LV',\n    iso: 'LVA',\n    label: 'Latvia',\n    phone: '371',\n  },\n  {\n    ioc: 'LBA',\n    iso2: 'LY',\n    iso: 'LBY',\n    label: 'Libya',\n    phone: '218',\n  },\n  {\n    ioc: 'MAR',\n    iso2: 'MA',\n    iso: 'MAR',\n    label: 'Morocco',\n    phone: '212',\n  },\n  {\n    ioc: 'MON',\n    iso2: 'MC',\n    iso: 'MCO',\n    label: 'Monaco',\n    phone: '377',\n  },\n  {\n    ioc: 'MDA',\n    iso2: 'MD',\n    iso: 'MDA',\n    label: 'Moldova, Republic of',\n    phone: '373',\n  },\n  {\n    ioc: 'MNE',\n    iso2: 'ME',\n    iso: 'MNE',\n    label: 'Montenegro',\n    phone: '382',\n  },\n  {\n    ioc: '',\n    iso2: 'MF',\n    iso: 'MAF',\n    label: 'Saint Martin (French part)',\n    phone: '590',\n  },\n  {\n    ioc: 'MAD',\n    iso2: 'MG',\n    iso: 'MDG',\n    label: 'Madagascar',\n    phone: '261',\n  },\n  {\n    ioc: 'MSH',\n    iso2: 'MH',\n    iso: 'MHL',\n    label: 'Marshall Islands',\n    phone: '692',\n  },\n  {\n    ioc: 'MKD',\n    iso2: 'MK',\n    iso: 'MKD',\n    label: 'Macedonia, the Former Yugoslav Republic of',\n    phone: '389',\n  },\n  {\n    ioc: 'MLI',\n    iso2: 'ML',\n    iso: 'MLI',\n    label: 'Mali',\n    phone: '223',\n  },\n  {\n    ioc: 'MYA',\n    iso2: 'MM',\n    iso: 'MMR',\n    label: 'Myanmar',\n    phone: '95',\n  },\n  {\n    ioc: 'MGL',\n    iso2: 'MN',\n    iso: 'MNG',\n    label: 'Mongolia',\n    phone: '976',\n  },\n  {\n    ioc: 'MAC',\n    iso2: 'MO',\n    iso: 'MAC',\n    label: 'Macao',\n    phone: '853',\n  },\n  {\n    ioc: 'NMA',\n    iso2: 'MP',\n    iso: 'NMP',\n    label: 'Northern Mariana Islands',\n    phone: '1-670',\n  },\n  {\n    ioc: 'MRT',\n    iso2: 'MQ',\n    iso: 'MTQ',\n    label: 'Martinique',\n    phone: '596',\n  },\n  {\n    ioc: 'MTN',\n    iso2: 'MR',\n    iso: 'MRT',\n    label: 'Mauritania',\n    phone: '222',\n  },\n  {\n    ioc: 'MNT',\n    iso2: 'MS',\n    iso: 'MSR',\n    label: 'Montserrat',\n    phone: '1-664',\n  },\n  {\n    ioc: 'MLT',\n    iso2: 'MT',\n    iso: 'MLT',\n    label: 'Malta',\n    phone: '356',\n  },\n  {\n    ioc: 'MRI',\n    iso2: 'MU',\n    iso: 'MUS',\n    label: 'Mauritius',\n    phone: '230',\n  },\n  {\n    ioc: 'MDV',\n    iso2: 'MV',\n    iso: 'MDV',\n    label: 'Maldives',\n    phone: '960',\n  },\n  {\n    ioc: 'MAW',\n    iso2: 'MW',\n    iso: 'MWI',\n    label: 'Malawi',\n    phone: '265',\n  },\n  {\n    ioc: 'MEX',\n    iso2: 'MX',\n    iso: 'MEX',\n    label: 'Mexico',\n    phone: '52',\n  },\n  {\n    ioc: 'MAS',\n    iso2: 'MY',\n    iso: 'MYS',\n    label: 'Malaysia',\n    phone: '60',\n  },\n  {\n    ioc: 'MOZ',\n    iso2: 'MZ',\n    iso: 'MOZ',\n    label: 'Mozambique',\n    phone: '258',\n  },\n  {\n    ioc: 'NAM',\n    iso2: 'NA',\n    iso: 'NAM',\n    label: 'Namibia',\n    phone: '264',\n  },\n  {\n    ioc: 'NCL',\n    iso2: 'NC',\n    iso: 'NCL',\n    label: 'New Caledonia',\n    phone: '687',\n  },\n  {\n    ioc: 'NIG',\n    iso2: 'NE',\n    iso: 'NER',\n    label: 'Niger',\n    phone: '227',\n  },\n  {\n    ioc: 'NFI',\n    iso2: 'NF',\n    iso: 'NFK',\n    label: 'Norfolk Island',\n    phone: '672',\n  },\n  {\n    ioc: 'NGR',\n    iso2: 'NG',\n    iso: 'NGA',\n    label: 'Nigeria',\n    phone: '234',\n  },\n  {\n    ioc: 'NCA',\n    iso2: 'NI',\n    iso: 'NIC',\n    label: 'Nicaragua',\n    phone: '505',\n  },\n  {\n    ioc: 'NED',\n    iso2: 'NL',\n    iso: 'NLD',\n    label: 'Netherlands',\n    phone: '31',\n  },\n  {\n    ioc: 'NOR',\n    iso2: 'NO',\n    iso: 'NOR',\n    label: 'Norway',\n    phone: '47',\n  },\n  {\n    ioc: 'NEP',\n    iso2: 'NP',\n    iso: 'NPL',\n    label: 'Nepal',\n    phone: '977',\n  },\n  {\n    ioc: 'NRU',\n    iso2: 'NR',\n    iso: 'NRU',\n    label: 'Nauru',\n    phone: '674',\n  },\n  {\n    ioc: 'NIU',\n    iso2: 'NU',\n    iso: 'NIU',\n    label: 'Niue',\n    phone: '683',\n  },\n  {\n    ioc: 'NZL',\n    iso2: 'NZ',\n    iso: 'NZL',\n    label: 'New Zealand',\n    phone: '64',\n  },\n  {\n    ioc: 'OMA',\n    iso2: 'OM',\n    iso: 'OMN',\n    label: 'Oman',\n    phone: '968',\n  },\n  {\n    ioc: 'PAN',\n    iso2: 'PA',\n    iso: 'PAN',\n    label: 'Panama',\n    phone: '507',\n  },\n  {\n    ioc: 'PER',\n    iso2: 'PE',\n    iso: 'PER',\n    label: 'Peru',\n    phone: '51',\n  },\n  {\n    ioc: 'FPO',\n    iso2: 'PF',\n    iso: 'PYF',\n    label: 'French Polynesia',\n    phone: '689',\n  },\n  {\n    ioc: 'PNG',\n    iso2: 'PG',\n    iso: 'PNG',\n    label: 'Papua New Guinea',\n    phone: '675',\n  },\n  {\n    ioc: 'PHI',\n    iso2: 'PH',\n    iso: 'PHL',\n    label: 'Philippines',\n    phone: '63',\n  },\n  {\n    ioc: 'PAK',\n    iso2: 'PK',\n    iso: 'PAK',\n    label: 'Pakistan',\n    phone: '92',\n  },\n  {\n    ioc: 'POL',\n    iso2: 'PL',\n    iso: 'POL',\n    label: 'Poland',\n    phone: '48',\n  },\n  {\n    ioc: 'SPM',\n    iso2: 'PM',\n    iso: 'SPM',\n    label: 'Saint Pierre and Miquelon',\n    phone: '508',\n  },\n  {\n    ioc: '',\n    iso2: 'PN',\n    iso: 'PCN',\n    label: 'Pitcairn',\n    phone: '870',\n  },\n  {\n    ioc: 'PUR',\n    iso2: 'PR',\n    iso: 'PRI',\n    label: 'Puerto Rico',\n    phone: '1',\n  },\n  {\n    ioc: 'PLE',\n    iso2: 'PS',\n    iso: 'PSE',\n    label: 'Palestine, State of',\n    phone: '970',\n  },\n  {\n    ioc: 'POR',\n    iso2: 'PT',\n    iso: 'PRT',\n    label: 'Portugal',\n    phone: '351',\n  },\n  {\n    ioc: 'PLW',\n    iso2: 'PW',\n    iso: 'PLW',\n    label: 'Palau',\n    phone: '680',\n  },\n  {\n    ioc: 'PAR',\n    iso2: 'PY',\n    iso: 'PRY',\n    label: 'Paraguay',\n    phone: '595',\n  },\n  {\n    ioc: 'QAT',\n    iso2: 'QA',\n    iso: 'QAT',\n    label: 'Qatar',\n    phone: '974',\n  },\n  {\n    ioc: 'REU',\n    iso2: 'RE',\n    iso: 'REU',\n    label: 'Reunion',\n    phone: '262',\n  },\n  {\n    ioc: 'ROU',\n    iso2: 'RO',\n    iso: 'ROU',\n    label: 'Romania',\n    phone: '40',\n  },\n  {\n    ioc: 'SRB',\n    iso2: 'RS',\n    iso: 'SRB',\n    label: 'Serbia',\n    phone: '381',\n  },\n  {\n    ioc: 'RUS',\n    iso2: 'RU',\n    iso: 'RUS',\n    label: 'Russia',\n    phone: '7',\n  },\n  {\n    ioc: 'RWA',\n    iso2: 'RW',\n    iso: 'RWA',\n    label: 'Rwanda',\n    phone: '250',\n  },\n  {\n    ioc: 'KSA',\n    iso2: 'SA',\n    iso: 'SAU',\n    label: 'Saudi Arabia',\n    phone: '966',\n  },\n  {\n    ioc: 'SOL',\n    iso2: 'SB',\n    iso: 'SLB',\n    label: 'Solomon Islands',\n    phone: '677',\n  },\n  {\n    ioc: 'SEY',\n    iso2: 'SC',\n    iso: 'SYC',\n    label: 'Seychelles',\n    phone: '248',\n  },\n  {\n    ioc: 'SUD',\n    iso2: 'SD',\n    iso: 'SDN',\n    label: 'Sudan',\n    phone: '249',\n  },\n  {\n    ioc: 'SWE',\n    iso2: 'SE',\n    iso: 'SWE',\n    label: 'Sweden',\n    phone: '46',\n  },\n  {\n    ioc: 'SIN',\n    iso2: 'SG',\n    iso: 'SGP',\n    label: 'Singapore',\n    phone: '65',\n  },\n  {\n    ioc: 'HEL',\n    iso2: 'SH',\n    iso: 'SHN',\n    label: 'Saint Helena',\n    phone: '290',\n  },\n  {\n    ioc: 'SLO',\n    iso2: 'SI',\n    iso: 'SVN',\n    label: 'Slovenia',\n    phone: '386',\n  },\n  {\n    ioc: '',\n    iso2: 'SJ',\n    iso: 'SJM',\n    label: 'Svalbard and Jan Mayen',\n    phone: '47',\n  },\n  {\n    ioc: 'SVK',\n    iso2: 'SK',\n    iso: 'SVK',\n    label: 'Slovakia',\n    phone: '421',\n  },\n  {\n    ioc: 'SLE',\n    iso2: 'SL',\n    iso: 'SLE',\n    label: 'Sierra Leone',\n    phone: '232',\n  },\n  {\n    ioc: 'SMR',\n    iso2: 'SM',\n    iso: 'SMR',\n    label: 'San Marino',\n    phone: '378',\n  },\n  {\n    ioc: 'SEN',\n    iso2: 'SN',\n    iso: 'SEN',\n    label: 'Senegal',\n    phone: '221',\n  },\n  {\n    ioc: 'SOM',\n    iso2: 'SO',\n    iso: 'SOM',\n    label: 'Somalia',\n    phone: '252',\n  },\n  {\n    ioc: 'SUR',\n    iso2: 'SR',\n    iso: 'SUR',\n    label: 'Suriname',\n    phone: '597',\n  },\n  {\n    ioc: '',\n    iso2: 'SS',\n    iso: 'SSD',\n    label: 'South Sudan',\n    phone: '211',\n  },\n  {\n    ioc: 'STP',\n    iso2: 'ST',\n    iso: 'STP',\n    label: 'Sao Tome and Principe',\n    phone: '239',\n  },\n  {\n    ioc: 'ESA',\n    iso2: 'SV',\n    iso: 'SLV',\n    label: 'El Salvador',\n    phone: '503',\n  },\n  {\n    ioc: '',\n    iso2: 'SX',\n    iso: 'SMX',\n    label: 'Sint Maarten',\n    phone: '1-721',\n  },\n  {\n    ioc: 'SYR',\n    iso2: 'SY',\n    iso: 'SYR',\n    label: 'Syria',\n    phone: '963',\n  },\n  {\n    ioc: '',\n    iso2: 'SZ',\n    iso: 'SWZ',\n    label: 'Swaziland',\n    phone: '268',\n  },\n  {\n    ioc: 'TKS',\n    iso2: 'TC',\n    iso: 'TCA',\n    label: 'Turks and Caicos Islands',\n    phone: '1-649',\n  },\n  {\n    ioc: 'CHA',\n    iso2: 'TD',\n    iso: 'TCD',\n    label: 'Chad',\n    phone: '235',\n  },\n  {\n    ioc: '',\n    iso2: 'TF',\n    iso: 'ATF',\n    label: 'French Southern Territories',\n    phone: '262',\n  },\n  {\n    ioc: 'TOG',\n    iso2: 'TG',\n    iso: 'TGO',\n    label: 'Togo',\n    phone: '228',\n  },\n  {\n    ioc: 'THA',\n    iso2: 'TH',\n    iso: 'THA',\n    label: 'Thailand',\n    phone: '66',\n  },\n  {\n    ioc: 'TJK',\n    iso2: 'TJ',\n    iso: 'TJK',\n    label: 'Tajikistan',\n    phone: '992',\n  },\n  {\n    ioc: '',\n    iso2: 'TK',\n    iso: 'TKL',\n    label: 'Tokelau',\n    phone: '690',\n  },\n  {\n    ioc: 'TLS',\n    iso2: 'TL',\n    iso: 'TLS',\n    label: 'Timor-Leste',\n    phone: '670',\n  },\n  {\n    ioc: 'TKM',\n    iso2: 'TM',\n    iso: 'TKM',\n    label: 'Turkmenistan',\n    phone: '993',\n  },\n  {\n    ioc: 'TUN',\n    iso2: 'TN',\n    iso: 'TUN',\n    label: 'Tunisia',\n    phone: '216',\n  },\n  {\n    ioc: 'TGA',\n    iso2: 'TO',\n    iso: 'TON',\n    label: 'Tonga',\n    phone: '676',\n  },\n  {\n    ioc: 'TUR',\n    iso2: 'TR',\n    iso: 'TUR',\n    label: 'Turkey',\n    phone: '90',\n  },\n  {\n    ioc: 'TTO',\n    iso2: 'TT',\n    iso: 'TTO',\n    label: 'Trinidad and Tobago',\n    phone: '1-868',\n  },\n  {\n    ioc: 'TUV',\n    iso2: 'TV',\n    iso: 'TUV',\n    label: 'Tuvalu',\n    phone: '688',\n  },\n  {\n    ioc: 'TPE',\n    iso2: 'TW',\n    iso: 'TWN',\n    label: 'Taiwan',\n    phone: '886',\n  },\n  {\n    ioc: 'TAN',\n    iso2: 'TZ',\n    iso: 'TZA',\n    label: 'United Republic of Tanzania',\n    phone: '255',\n  },\n  {\n    ioc: 'UKR',\n    iso2: 'UA',\n    iso: 'UKR',\n    label: 'Ukraine',\n    phone: '380',\n  },\n  {\n    ioc: 'UGA',\n    iso2: 'UG',\n    iso: 'UGA',\n    label: 'Uganda',\n    phone: '256',\n  },\n  {\n    ioc: 'USA',\n    iso2: 'US',\n    label: 'United States',\n    phone: '1',\n    suggested: true,\n    iso: 'USA',\n  },\n  {\n    ioc: 'URU',\n    iso2: 'UY',\n    iso: 'URY',\n    label: 'Uruguay',\n    phone: '598',\n  },\n  {\n    ioc: 'UZB',\n    iso2: 'UZ',\n    iso: 'UZB',\n    label: 'Uzbekistan',\n    phone: '998',\n  },\n  {\n    ioc: '',\n    iso2: 'VA',\n    iso: 'VAT',\n    label: 'Holy See (Vatican City State)',\n    phone: '379',\n  },\n  {\n    ioc: 'VIN',\n    iso2: 'VC',\n    iso: 'VCT',\n    label: 'Saint Vincent and the Grenadines',\n    phone: '1-784',\n  },\n  {\n    ioc: 'VEN',\n    iso2: 'VE',\n    iso: 'VEN',\n    label: 'Venezuela',\n    phone: '58',\n  },\n  {\n    ioc: 'IVB',\n    iso2: 'VG',\n    iso: 'VGB',\n    label: 'British Virgin Islands',\n    phone: '1-284',\n  },\n  {\n    ioc: 'ISV',\n    iso2: 'VI',\n    iso: 'VIR',\n    label: 'US Virgin Islands',\n    phone: '1-340',\n  },\n  {\n    ioc: 'VIE',\n    iso2: 'VN',\n    iso: 'VNM',\n    label: 'Vietnam',\n    phone: '84',\n  },\n  {\n    ioc: 'VAN',\n    iso2: 'VU',\n    iso: 'VUT',\n    label: 'Vanuatu',\n    phone: '678',\n  },\n  {\n    ioc: 'WAF',\n    iso2: 'WF',\n    iso: 'WLF',\n    label: 'Wallis and Futuna',\n    phone: '681',\n  },\n  {\n    ioc: 'SAM',\n    iso2: 'WS',\n    iso: 'WSM',\n    label: 'Samoa',\n    phone: '685',\n  },\n  {\n    ioc: 'KOS',\n    iso2: 'XK',\n    iso: 'KOS',\n    label: 'Kosovo',\n    phone: '383',\n  },\n  {\n    ioc: 'YEM',\n    iso2: 'YE',\n    iso: 'YEM',\n    label: 'Yemen',\n    phone: '967',\n  },\n  {\n    ioc: 'MAY',\n    iso2: 'YT',\n    iso: 'MYT',\n    label: 'Mayotte',\n    phone: '262',\n  },\n  {\n    ioc: 'RSA',\n    iso2: 'ZA',\n    iso: 'ZAF',\n    label: 'South Africa',\n    phone: '27',\n  },\n  {\n    ioc: 'ZAM',\n    iso2: 'ZM',\n    iso: 'ZMB',\n    label: 'Zambia',\n    phone: '260',\n  },\n  {\n    ioc: 'ZIM',\n    iso2: 'ZW',\n    iso: 'ZWE',\n    label: 'Zimbabwe',\n    phone: '263',\n  },\n];\n","import { countries } from '../../fixtures/countryData';\nimport { HydratedParticipant } from '../../types/hydrated';\n\ntype AddNationalityCodeArgs = {\n  participant: HydratedParticipant;\n  withISO2?: boolean;\n  withIOC?: boolean;\n};\nexport function addNationalityCode({\n  participant,\n  withISO2,\n  withIOC,\n}: AddNationalityCodeArgs) {\n  const { person, individualParticipants } = participant;\n  const persons = [person, individualParticipants?.map(({ person }) => person)]\n    .flat()\n    .filter(Boolean);\n\n  function annotatePerson(person) {\n    const { nationalityCode } = person || {};\n    if (nationalityCode) {\n      const country = countries.find(({ iso }) => iso === nationalityCode);\n      if (withIOC && country?.ioc && !person.iocNationalityCode)\n        person.iocNationalityCode = country.ioc;\n      if (withISO2 && country?.iso2 && !person.iso2NationalityCode)\n        person.iso2NationalityCode = country.iso2;\n\n      if (country?.label && !person.countryName)\n        person.countryName = country.label;\n    }\n  }\n\n  persons.forEach(annotatePerson);\n}\n","import { Participant, Tournament } from '../types/tournamentTypes';\nimport { TournamentRecords } from '../types/factoryTypes';\nimport {\n  ErrorType,\n  PARTICIPANT_NOT_FOUND,\n} from '../constants/errorConditionConstants';\n\ntype FindTournamentParticipantArgs = {\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  participantId: string;\n};\n\nexport function findTournamentParticipant(\n  params: FindTournamentParticipantArgs\n): {\n  participant?: Participant;\n  tournamentId?: string;\n  error?: ErrorType;\n} {\n  const { tournamentRecord, participantId } = params;\n\n  const tournamentRecords =\n    params.tournamentRecords ||\n    (tournamentRecord && {\n      [tournamentRecord.tournamentId]: tournamentRecord,\n    }) ||\n    {};\n\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const participant = tournamentRecord.participants?.find(\n      (participant) => participant.participantId === participantId\n    );\n    if (participant)\n      return { participant, tournamentId: tournamentRecord.tournamentId };\n  }\n\n  return { error: PARTICIPANT_NOT_FOUND };\n}\n","import { findTournamentParticipant } from '../../acquire/findTournamentParticipant';\n\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { ELEMENT_REQUIRED } from '../../constants/infoConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { Event, TimeItem, Tournament } from '../../types/tournamentTypes';\nimport {\n  INVALID_VALUES,\n  MISSING_DRAW_ID,\n  MISSING_EVENT,\n  MISSING_PARTICIPANT_ID,\n  MISSING_TIME_ITEMS,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n  NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\ntype TimeItemResult = {\n  timeItem?: TimeItem;\n  previousItems?: any;\n  success?: boolean;\n  code?: string;\n  info?: any;\n};\n\ntype TimeItemArgs = {\n  returnPreviousValues?: boolean;\n  itemSubTypes?: string[];\n  itemType: string;\n  element: any;\n};\n\nexport function getTimeItem({\n  returnPreviousValues,\n  itemSubTypes,\n  itemType,\n  element,\n}: TimeItemArgs): TimeItemResult & ResultType {\n  if (!element) return { error: MISSING_VALUE, info: ELEMENT_REQUIRED };\n  if (itemSubTypes && !Array.isArray(itemSubTypes))\n    return { error: INVALID_VALUES, context: { itemSubTypes } };\n  if (!Array.isArray(element.timeItems)) return { error: MISSING_TIME_ITEMS };\n\n  const filteredSorted = element.timeItems\n    .filter((timeItem) => timeItem?.itemType === itemType)\n    .filter(\n      (timeItem) =>\n        !itemSubTypes?.length ||\n        itemSubTypes.some(\n          (subType) => timeItem?.itemSubTypes?.includes(subType)\n        )\n    )\n    .sort((a, b) => {\n      const aDate = new Date(a.createdAt || undefined).getTime();\n      const bDate = new Date(b.createdAt || undefined).getTime();\n      return aDate - bDate;\n    });\n\n  const timeItem = filteredSorted.pop();\n\n  if (timeItem) {\n    const result = { timeItem, ...SUCCESS };\n    if (returnPreviousValues)\n      Object.assign(result, { previousItems: filteredSorted });\n    return result;\n  } else {\n    return { info: NOT_FOUND };\n  }\n}\n\nexport function getDrawDefinitionTimeItem({\n  returnPreviousValues,\n  drawDefinition,\n  itemSubTypes,\n  itemType,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_ID };\n  if (!drawDefinition.timeItems) return { info: NOT_FOUND };\n\n  const { timeItem, previousItems, info } = getTimeItem({\n    element: drawDefinition,\n    returnPreviousValues,\n    itemSubTypes,\n    itemType,\n  });\n  return (timeItem && { timeItem, previousItems }) || { info };\n}\n\ntype GetEventTimeItemArgs = {\n  returnPreviousValues?: boolean;\n  itemSubTypes?: string[];\n  itemType: string;\n  event: Event;\n};\nexport function getEventTimeItem({\n  returnPreviousValues,\n  itemSubTypes,\n  itemType,\n  event,\n}: GetEventTimeItemArgs) {\n  if (!event) return { error: MISSING_EVENT };\n  if (!event.timeItems) return { info: NOT_FOUND };\n\n  const { timeItem, previousItems, info } = getTimeItem({\n    returnPreviousValues,\n    element: event,\n    itemSubTypes,\n    itemType,\n  });\n  return (timeItem && { timeItem, previousItems }) || { info };\n}\n\ntype GetTournamentTimeItemArgs = {\n  returnPreviousValues?: boolean;\n  tournamentRecord: Tournament;\n  itemSubTypes?: string[];\n  itemType: string;\n};\nexport function getTournamentTimeItem({\n  returnPreviousValues,\n  tournamentRecord,\n  itemSubTypes,\n  itemType,\n}: GetTournamentTimeItemArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!tournamentRecord.timeItems) return { info: NOT_FOUND };\n\n  const { timeItem, previousItems, info } = getTimeItem({\n    element: tournamentRecord,\n    returnPreviousValues,\n    itemSubTypes,\n    itemType,\n  });\n  return (timeItem && { timeItem, previousItems }) || { info };\n}\n\nexport function getParticipantTimeItem({\n  returnPreviousValues,\n  tournamentRecord,\n  participantId,\n  itemSubTypes,\n  itemType,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!participantId) return { error: MISSING_PARTICIPANT_ID };\n\n  const result = findTournamentParticipant({ tournamentRecord, participantId });\n  if (result.error) return result;\n\n  const { participant } = result;\n  if (!participant?.timeItems) return { info: NOT_FOUND };\n\n  const { timeItem, previousItems, info } = getTimeItem({\n    element: result.participant,\n    returnPreviousValues,\n    itemSubTypes,\n    itemType,\n  });\n\n  return (timeItem && { timeItem, previousItems }) || { info };\n}\n","export const SINGLES_MATCHUP = 'SINGLES';\nexport const SINGLES = 'SINGLES';\nexport const DOUBLES_MATCHUP = 'DOUBLES';\nexport const DOUBLES = 'DOUBLES';\nexport const TEAM_MATCHUP = 'TEAM';\nexport const TEAM = 'TEAM';\n\nexport const matchUpTypes = {\n  SINGLES_MATCHUP,\n  SINGLES,\n  DOUBLES_MATCHUP,\n  DOUBLES,\n  TEAM_MATCHUP,\n  TEAM,\n};\n","import { addIndividualParticipants } from '../../mutate/participants/addIndividualParticipants';\nimport { addNationalityCode } from '../../mutate/participants/addNationalityCode';\nimport { getScaleValues } from '../participant/getScaleValues';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { isObject } from '../../utilities/objects';\nimport { getTimeItem } from '../base/timeItems';\n\nimport { DOUBLES, SINGLES } from '../../constants/matchUpTypes';\nimport { Tournament } from '../../types/tournamentTypes';\nimport { ParticipantMap } from '../../types/factoryTypes';\nimport {\n  GROUP,\n  PAIR,\n  SIGNED_IN,\n  SIGN_IN_STATUS,\n  TEAM,\n} from '../../constants/participantConstants';\n\nconst typeMap = {\n  [GROUP]: 'groupParticipantIds',\n  [PAIR]: 'pairParticipantIds',\n  [TEAM]: 'teamParticipantIds',\n};\nconst membershipMap = {\n  [GROUP]: 'groups',\n  [TEAM]: 'teams',\n};\n\n// build up an object with participantId keys which map to deepCopied participants\n// and which include all relevant groupings for each individualParticipant\n\ntype GetParticpantsMapArgs = {\n  withIndividualParticipants?: boolean | { [key: string]: any };\n  tournamentRecord: Tournament;\n  convertExtensions?: boolean;\n  withSignInStatus?: boolean;\n  withScaleValues?: boolean;\n  internalUse?: boolean;\n  withISO2?: boolean;\n  withIOC?: boolean;\n};\nexport function getParticipantMap({\n  withIndividualParticipants,\n  convertExtensions,\n  tournamentRecord,\n  withSignInStatus,\n  withScaleValues,\n  internalUse,\n  withISO2,\n  withIOC,\n}: GetParticpantsMapArgs): {\n  participantMap: ParticipantMap;\n} {\n  const participantMap: ParticipantMap = {};\n  // initialize all participants first, to preserve order\n  for (const participant of tournamentRecord.participants ?? []) {\n    const participantId = participant?.participantId;\n    participantId && initializeParticipantId({ participantMap, participantId });\n  }\n\n  for (const participant of tournamentRecord.participants ?? []) {\n    const participantCopy = makeDeepCopy(\n      participant,\n      convertExtensions,\n      internalUse\n    );\n\n    const { participantId, individualParticipantIds, participantType } =\n      participantCopy;\n\n    Object.assign(participantMap[participantId].participant, participantCopy);\n\n    if (individualParticipantIds) {\n      processIndividualParticipantIds({\n        individualParticipantIds,\n        participantCopy,\n        participantMap,\n        participantType,\n        participantId,\n      });\n    }\n\n    if (withSignInStatus) {\n      participantMap[participantId].participant.signedIn =\n        signedIn(participantCopy);\n    }\n\n    if (withScaleValues) {\n      const { ratings, rankings, seedings } = getScaleValues({\n        participant: participantCopy,\n      });\n      participantMap[participantId].participant.seedings = seedings;\n      participantMap[participantId].participant.rankings = rankings;\n      participantMap[participantId].participant.ratings = ratings;\n    }\n\n    if (withIOC || withISO2)\n      addNationalityCode({\n        participant: participantMap[participantId].participant,\n        withISO2,\n        withIOC,\n      });\n  }\n\n  if (withIndividualParticipants) {\n    const template = isObject(withIndividualParticipants)\n      ? withIndividualParticipants\n      : undefined;\n    addIndividualParticipants({ participantMap, template });\n  }\n\n  return { participantMap };\n}\n\nfunction signedIn(participant) {\n  const { timeItem } = getTimeItem({\n    itemType: SIGN_IN_STATUS,\n    element: participant,\n  });\n\n  return timeItem?.itemValue === SIGNED_IN;\n}\n\nfunction processIndividualParticipantIds({\n  individualParticipantIds,\n  participantCopy,\n  participantMap,\n  participantType,\n  participantId,\n}) {\n  for (const individualParticipantId of individualParticipantIds) {\n    const individualParticipant =\n      participantMap[individualParticipantId].participant;\n    individualParticipant[typeMap[participantType]].push(participantId);\n\n    if ([TEAM, GROUP].includes(participantType)) {\n      const {\n        participantRoleResponsibilities,\n        participantOtherName,\n        participantName,\n        participantId,\n        teamId,\n      } = participantCopy;\n      const membership = membershipMap[participantType];\n      individualParticipant[membership].push({\n        participantRoleResponsibilities,\n        participantOtherName,\n        participantName,\n        participantId,\n        teamId,\n      });\n    }\n\n    if (participantType === PAIR) {\n      const partnerParticipantId = individualParticipantIds.find(\n        (id) => id !== individualParticipantId\n      );\n      participantMap[individualParticipantId].pairIdMap[participantId] =\n        partnerParticipantId;\n      participantMap[individualParticipantId].pairIdMap[partnerParticipantId] =\n        participantId;\n    }\n  }\n}\n\nfunction initializeParticipantId({ participantMap, participantId }) {\n  // nothing to do if participantId is present\n  if (participantMap[participantId]) return;\n\n  const counters = {\n    walkoverWins: 0,\n    defaultWins: 0,\n    walkovers: 0,\n    defaults: 0,\n    losses: 0,\n    wins: 0,\n  };\n\n  participantMap[participantId] = {\n    structureParticipation: {},\n    potentialMatchUps: {},\n    scheduleConflicts: {},\n    scheduleItems: [],\n    participant: {\n      groupParticipantIds: [],\n      pairParticipantIds: [],\n      teamParticipantIds: [],\n      seedings: {},\n      rankings: {},\n      ratings: {},\n      groups: [],\n      teams: [],\n    },\n    statistics: {},\n    opponents: {},\n    pairIdMap: {},\n    matchUps: {},\n    events: {},\n    draws: {},\n    counters: {\n      [SINGLES]: { ...counters },\n      [DOUBLES]: { ...counters },\n      [TEAM]: { ...counters },\n      ...counters,\n    },\n  };\n}\n","import { attributeFilter } from '../../utilities/attributeFilter';\n\nimport { HydratedParticipant } from '../../types/hydrated';\n\nexport function addIndividualParticipants({ participantMap, template }) {\n  const participantObjects: any[] = Object.values(participantMap);\n  for (const participantObject of participantObjects) {\n    const participant = participantObject.participant as HydratedParticipant;\n    if (participant.individualParticipantIds?.length) {\n      participant.individualParticipants = [];\n      for (const participantId of participant.individualParticipantIds) {\n        const source = participantMap[participantId].participant;\n        participant.individualParticipants.push(\n          template ? attributeFilter({ template, source }) : source\n        );\n      }\n    }\n  }\n}\n","import { addParticipantGroupings } from '../../mutate/drawDefinitions/positionGovernor/avoidance/addParticipantGroupings';\nimport { addNationalityCode } from '../../mutate/participants/addNationalityCode';\nimport { getScaleValues } from '../participant/getScaleValues';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\n\nimport { getParticipantMap } from './getParticipantMap';\nimport { Tournament } from '../../types/tournamentTypes';\nimport { HydratedParticipant } from '../../types/hydrated';\nimport {\n  ContextProfile,\n  ParticipantsProfile,\n  PolicyDefinitions,\n} from '../../types/factoryTypes';\n\ntype HydrateParticipantsArgs = {\n  participantsProfile?: ParticipantsProfile;\n  policyDefinitions?: PolicyDefinitions;\n  contextProfile?: ContextProfile;\n  tournamentRecord: Tournament;\n  useParticipantMap?: boolean;\n  inContext?: boolean;\n};\nexport function hydrateParticipants({\n  participantsProfile,\n  useParticipantMap,\n  tournamentRecord,\n  contextProfile,\n  inContext,\n}: HydrateParticipantsArgs) {\n  if (useParticipantMap) {\n    const participantMap = getParticipantMap({\n      ...participantsProfile,\n      ...contextProfile,\n      tournamentRecord,\n    })?.participantMap;\n\n    return { participantMap };\n  }\n\n  let participants: HydratedParticipant[] =\n    makeDeepCopy(tournamentRecord.participants, false, true) || [];\n\n  if (participantsProfile?.withIOC || participantsProfile?.withISO2)\n    participants.forEach((participant) =>\n      addNationalityCode({ participant, ...participantsProfile })\n    );\n\n  let groupInfo;\n  if (\n    (inContext || participantsProfile?.withGroupings) &&\n    participants?.length\n  ) {\n    ({ participantsWithGroupings: participants, groupInfo } =\n      addParticipantGroupings({\n        participantsProfile,\n        deepCopy: false,\n        participants,\n      }));\n  }\n\n  if (participantsProfile?.withScaleValues && participants?.length) {\n    for (const participant of participants) {\n      const { ratings, rankings } = getScaleValues({ participant });\n      participant.rankings = rankings;\n      participant.ratings = ratings;\n    }\n  }\n\n  return { participants, groupInfo };\n}\n","import { numericSort } from '../../utilities/sorting';\nimport { chunkArray } from '../../utilities/arrays';\n\nexport function reduceGroupedOrder({ groupedOrder, roundPositionsCount }) {\n  if (!groupedOrder || groupedOrder?.length <= roundPositionsCount) {\n    return groupedOrder;\n  }\n\n  const groupChunks = chunkArray(groupedOrder, groupedOrder.length / roundPositionsCount);\n\n  const chunkValues = groupChunks.map((chunk) => chunk.reduce((a: number, b: number) => a + b));\n  const sortedChunks = chunkValues.slice().sort(numericSort); // make a copy of the values to avoid mutating the original\n\n  return chunkValues.map((chunkValue) => sortedChunks.indexOf(chunkValue) + 1);\n}\n","import { getPositionAssignments } from '../drawDefinition/positionsGetter';\nimport { chunkArray, generateRange } from '../../utilities/arrays';\nimport { getDevContext } from '../../global/state/globalState';\nimport { reduceGroupedOrder } from './reduceGroupedOrder';\nimport { findExtension } from '../../acquire/findExtension';\nimport { findStructure } from '../../acquire/findStructure';\n\nimport { DISABLE_LINKS } from '../../constants/extensionConstants';\nimport {\n  MISSING_TARGET_LINK,\n  NOT_IMPLEMENTED,\n} from '../../constants/errorConditionConstants';\nimport {\n  DRAW,\n  BOTTOM_UP,\n  RANDOM,\n  TOP_DOWN,\n} from '../../constants/drawDefinitionConstants';\n\nexport function getTargetMatchUp({\n  sourceRoundMatchUpCount,\n  inContextDrawMatchUps,\n  sourceRoundPosition,\n  drawDefinition,\n  targetLink,\n}) {\n  if (!targetLink) return { error: MISSING_TARGET_LINK };\n\n  const {\n    target: {\n      structureId,\n      feedProfile,\n      groupedOrder,\n      roundNumber,\n      positionInterleave,\n    },\n  } = targetLink;\n\n  const { structure: targetStructure } = findStructure({\n    drawDefinition,\n    structureId,\n  });\n\n  const { positionAssignments } = getPositionAssignments({\n    structure: targetStructure,\n  });\n\n  const structureMatchUps = inContextDrawMatchUps?.filter(\n    (matchUp) => matchUp.structureId === targetStructure?.structureId\n  );\n  const targetRoundMatchUps = structureMatchUps.filter(\n    (matchUp) => matchUp.roundNumber === roundNumber && !matchUp.matchUpTieId // exclude tieMatchUps\n  );\n  const targetRoundMatchUpCount = targetRoundMatchUps.length;\n  const roundPositions = generateRange(1, targetRoundMatchUpCount + 1);\n\n  const matchUpCountFactor = targetRoundMatchUpCount / sourceRoundMatchUpCount;\n\n  // usually target structures are half the size of source structures\n  // which means the calculatedRoundPosition for target matchUps is sourceRoundPosition * 0.5\n  let calculatedRoundPosition = Math.ceil(\n    matchUpCountFactor * sourceRoundPosition\n  );\n  let matchUpDrawPositionIndex = 1 - (sourceRoundPosition % 2);\n\n  // when more than one source structure or more than one source structure round feed the same round in the target structure\n  // then there is a positionInterleave attribute which specifies both an offset and an interleave\n  // the offset is the number of positions from the start\n  // the interleave indicates how many positions are fed in between each position fed by current source structure round\n  if (positionInterleave?.interleave && matchUpCountFactor !== 0.5) {\n    // the oofset here is a combination of the specified offset and the number of previous positions interleaved\n    const offset =\n      positionInterleave.offset +\n      (sourceRoundPosition - 1) * positionInterleave.interleave;\n    // the target drawPosition is relative because the actual drawPosition value is based on the number of subseqent round feed-in matchUps\n    const relativeRoundPosition = sourceRoundPosition + offset;\n    calculatedRoundPosition = Math.ceil(relativeRoundPosition / 2);\n    // the index in the target matchUp.drawPositions[] is recalculated based on calculated relative drawPosition\n    matchUpDrawPositionIndex = 1 - (relativeRoundPosition % 2);\n  }\n\n  let orderedPositions = roundPositions;\n  let targetedRoundPosition = roundPositions[calculatedRoundPosition - 1];\n\n  const sizedGroupOrder = reduceGroupedOrder({\n    groupedOrder,\n    roundPositionsCount: roundPositions.length,\n  });\n  const groupsCount = sizedGroupOrder?.length || 1;\n  if (groupsCount <= roundPositions.length) {\n    const groupSize = targetRoundMatchUpCount / groupsCount;\n    const groups = chunkArray(roundPositions, groupSize);\n    if (feedProfile === BOTTOM_UP) groups.forEach((group) => group.reverse());\n    orderedPositions =\n      (sizedGroupOrder?.length &&\n        sizedGroupOrder?.map((order) => groups[order - 1]).flat()) ||\n      orderedPositions;\n  }\n\n  if (feedProfile === TOP_DOWN) {\n    /*\n      TOP_DOWN feed profile implies that the roundPosition in the\n      target is equivalent to the roundPosition in the source\n    */\n    targetedRoundPosition = orderedPositions[calculatedRoundPosition - 1];\n  } else if (feedProfile === BOTTOM_UP) {\n    /*\n      BOTTOM_UP feed profile implies that the roundPosition in the\n      target is (# of matchUps in source/target round + 1) - roundPosition in the source\n    */\n    if (!sizedGroupOrder?.length || groupsCount > roundPositions.length) {\n      calculatedRoundPosition =\n        targetRoundMatchUps.length + 1 - calculatedRoundPosition;\n    }\n    targetedRoundPosition = orderedPositions[calculatedRoundPosition - 1];\n  } else if (feedProfile === RANDOM) {\n    /*\n      RANDOM feed profile selects a random position from available\n    */\n    if (getDevContext()) console.log(NOT_IMPLEMENTED, { feedProfile });\n  } else if (feedProfile === DRAW) {\n    /*\n      calculatedRoundPosition is undetermined for DRAW feedProfile\n    */\n  }\n\n  const matchUp =\n    targetedRoundPosition &&\n    targetRoundMatchUps.reduce((matchUp, current) => {\n      return current.roundPosition === targetedRoundPosition\n        ? current\n        : matchUp;\n    }, undefined);\n\n  // targetDrawPosition and matchUpDrawPositionIndex are only relevant\n  // when drawPositions need to be assigned in positionAssignments\n  // which means only when a targetMatchUp is in a different structure\n  let targetDrawPosition;\n  if (matchUp?.feedRound) {\n    // for fedDrawPositions in linked elimination structures...\n    // ...when roundNumber > 1 matchUpDrawPositionIndex should always be 0\n    // ...because fed drawPositions are always numerically smaller than advanced drawPositions\n    matchUpDrawPositionIndex = 0;\n    targetDrawPosition = Math.min(\n      ...(matchUp.drawPositions || []).filter(Boolean)\n    );\n  } else {\n    // when not a feedRound targetDrawPosition can only be determined when both drawPositions present\n    targetDrawPosition =\n      matchUp?.drawPositions?.length === 2 &&\n      matchUp?.drawPositions[matchUpDrawPositionIndex];\n  }\n\n  const relevantAssignment = positionAssignments?.find(\n    ({ drawPosition }) => drawPosition === targetDrawPosition\n  );\n  if (relevantAssignment) {\n    const { extension } = findExtension({\n      element: relevantAssignment,\n      name: DISABLE_LINKS,\n    });\n    if (extension?.value) {\n      return { disabledDrawPosition: targetDrawPosition };\n    }\n  }\n\n  return {\n    matchUp,\n    targetDrawPosition,\n    matchUpDrawPositionIndex,\n  };\n}\n","import { decorateResult } from '../../global/functions/decorateResult';\nimport { overlap } from '../../utilities/arrays';\n\nimport { LOSER, WINNER } from '../../constants/drawDefinitionConstants';\nimport {\n  MISSING_STRUCTURE_ID,\n  MISSING_DRAW_DEFINITION,\n  INVALID_VALUES,\n} from '../../constants/errorConditionConstants';\n\ntype GetRoundLinksArgs = {\n  roundNumber?: number;\n  structureId: string;\n  drawDefinition: any;\n};\n\n// Return links which govern movement for a given matchUp either as a source or a target\nexport function getRoundLinks({\n  drawDefinition, // passed automatically by drawEngine\n  roundNumber, // optional - filter for only links that apply to roundNumber\n  structureId, // structureId within which matchUp occurs\n}: GetRoundLinksArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structureId) return { error: MISSING_STRUCTURE_ID };\n\n  const { links } = getStructureLinks({ drawDefinition, structureId });\n\n  const source = links.source.reduce((source, link) => {\n    return !link.source.roundNumber || link.source.roundNumber === roundNumber\n      ? source.concat(link)\n      : source;\n  }, []);\n  const target = links.target.reduce((target, link) => {\n    return !link.target.roundNumber || link.target.roundNumber === roundNumber\n      ? target.concat(link)\n      : target;\n  }, []);\n  return { links: { source, target } };\n}\n\ntype GetTargetLinkArgs = {\n  finishingPositions?: any;\n  linkCondition?: string;\n  linkType?: string;\n  source: any[];\n};\n\nexport function getTargetLink({\n  finishingPositions,\n  linkCondition,\n  linkType,\n  source,\n}: GetTargetLinkArgs) {\n  const result = source.find((link) => {\n    const positionCondition =\n      !link.source?.finishingPositions ||\n      !finishingPositions ||\n      overlap(finishingPositions, link.source?.finishingPositions);\n    const condition = linkCondition === link.linkCondition;\n    return condition && positionCondition && link.linkType === linkType;\n  });\n\n  if (\n    [WINNER, LOSER].includes(result?.linkType) &&\n    !result?.source?.roundNumber\n  ) {\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      stack: 'getTargetLink',\n      context: result,\n    });\n  }\n  return result;\n}\n\ntype GetStructureLinksArgs = {\n  roundNumber?: number;\n  structureId: string;\n  drawDefinition: any;\n};\n\n// Returns all links for which a structure is either a source or a target; optionally filter by roundNumber\nexport function getStructureLinks({\n  drawDefinition, //passed automatically by drawEngine\n  structureId, // id of structure for which links are desired\n  roundNumber, // optional - filter for links to or from specific rounds\n}: GetStructureLinksArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structureId) return { error: MISSING_STRUCTURE_ID };\n  const links = drawDefinition.links || [];\n  const structureLinks = links.filter(Boolean).reduce(\n    (structureLinks, link) => {\n      if (\n        link.source?.structureId === structureId &&\n        (!roundNumber || link.source.roundNumber === roundNumber)\n      )\n        structureLinks.source = structureLinks.source.concat(link);\n      if (\n        link.target?.structureId === structureId &&\n        (!roundNumber || link.target.roundNumber === roundNumber)\n      )\n        structureLinks.target = structureLinks.target.concat(link);\n      return structureLinks;\n    },\n    { source: [], target: [] }\n  );\n  return { links: structureLinks };\n}\n","import { getNextRoundMatchUp } from '../../../query/matchUps/getNextRoundMatchUp';\nimport { getTargetMatchUp } from '../../../query/matchUps/getTargetMatchUp';\nimport {\n  getRoundLinks,\n  getTargetLink,\n} from '../../../query/drawDefinition/linkGetter';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { DrawDefinition } from '../../../types/tournamentTypes';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport { findStructure } from '../../../acquire/findStructure';\n\nimport {\n  LOSER,\n  WINNER,\n  ROUND_OUTCOME,\n  DRAW,\n  FIRST_MATCHUP,\n} from '../../../constants/drawDefinitionConstants';\n\n/**\n * @param {string=} matchUpId - matchUp identifier for sourceMatchUp\n * @param {object=} structure - structure within which matchUp occurs\n * @param {object=} drawDefinition - drawDefinition within which structure occurs\n * @param {object[]=} inContextDrawMatchUps - array of all draw matchUps (for optimiation)\n * @param {object=} inContextMatchUp - source matchUp with context\n * @param {boolean=} useTargetMatchUpIds - whether to use { loserMatchUpId, winnerMatchUpId } to find targets\n *\n * targetMatchUpIds are used for optimization when fetching targetMatchUps for the purpose of displaying upcoming scheduling information\n * (!!) when targetMatchUpIds are used targetDrawPositions are not retrieved (!!)\n * targetDrawPositions are necessary for participant movement logic\n */\n\ntype PositionTargetsArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  inContextMatchUp?: HydratedMatchUp;\n  useTargetMatchUpIds?: boolean;\n  drawDefinition: DrawDefinition;\n  matchUpId: string;\n};\n\nexport function positionTargets({\n  inContextDrawMatchUps = [],\n  useTargetMatchUpIds,\n  inContextMatchUp,\n  drawDefinition,\n  matchUpId,\n}: PositionTargetsArgs) {\n  let matchUp = inContextMatchUp;\n  if (inContextDrawMatchUps.length && !matchUp) {\n    matchUp = inContextDrawMatchUps.find((m) => m.matchUpId === matchUpId);\n  }\n\n  const { structure } = findStructure({\n    structureId: matchUp?.structureId,\n    drawDefinition,\n  });\n\n  const finishingPosition = structure?.finishingPosition;\n  if (finishingPosition === ROUND_OUTCOME) {\n    return targetByRoundOutcome({\n      inContextDrawMatchUps,\n      useTargetMatchUpIds,\n      drawDefinition,\n      structure,\n      matchUp,\n    });\n  } else {\n    return targetByWinRatio({ matchUp });\n  }\n}\n\nfunction targetByRoundOutcome({\n  inContextDrawMatchUps,\n  useTargetMatchUpIds,\n  drawDefinition,\n  structure,\n  matchUp,\n}) {\n  const { winnerMatchUpId, loserMatchUpId } = matchUp;\n  const { links } = getRoundLinks({\n    roundNumber: matchUp.roundNumber,\n    structureId: structure.structureId,\n    drawDefinition,\n  });\n  const source = links?.source;\n\n  const winnerTargetLink = getTargetLink({ source, linkType: WINNER });\n  const byeTargetLink = getTargetLink({\n    linkCondition: FIRST_MATCHUP,\n    linkType: LOSER,\n    source,\n  });\n  let loserTargetLink = getTargetLink({ source, linkType: LOSER });\n\n  const propagateByeFMLC = byeTargetLink && loserTargetLink;\n  if (!loserTargetLink) loserTargetLink = byeTargetLink;\n\n  const winnerFeedProfile = winnerTargetLink?.target?.feedProfile;\n  const loserFeedProfile = loserTargetLink?.target?.feedProfile;\n  const byeFeedProfile = byeTargetLink?.target?.feedProfile;\n\n  let byeMatchUp, byeTargetDrawPosition, byeMatchUpDrawPositionIndex;\n  let loserMatchUp, loserTargetDrawPosition, loserMatchUpDrawPositionIndex;\n  let winnerMatchUp, winnerTargetDrawPosition, winnerMatchUpDrawPositionIndex;\n  let structureMatchUps;\n\n  if (useTargetMatchUpIds && (winnerMatchUpId || loserMatchUpId)) {\n    winnerMatchUp =\n      winnerMatchUpId &&\n      winnerFeedProfile !== DRAW &&\n      inContextDrawMatchUps.find(\n        ({ matchUpId }) => matchUpId === winnerMatchUpId\n      );\n    loserMatchUp =\n      loserMatchUpId &&\n      loserFeedProfile !== DRAW &&\n      inContextDrawMatchUps.find(\n        ({ matchUpId }) => matchUpId === loserMatchUpId\n      );\n\n    if (winnerMatchUp || loserMatchUp) {\n      return {\n        matchUp,\n        targetLinks: { loserTargetLink, winnerTargetLink },\n        targetMatchUps: { loserMatchUp, winnerMatchUp },\n      };\n    }\n  }\n\n  const { roundPosition: sourceRoundPosition } = matchUp;\n  structureMatchUps =\n    structureMatchUps ||\n    inContextDrawMatchUps.filter(\n      (matchUp) => matchUp.structureId === structure.structureId\n    );\n  const sourceRoundMatchUpCount = structureMatchUps.reduce(\n    (count, currentMatchUp) => {\n      return currentMatchUp.roundNumber === matchUp.roundNumber &&\n        !currentMatchUp.matchUpTieId // exclude tieMatchUps\n        ? count + 1\n        : count;\n    },\n    0\n  );\n\n  if (loserTargetLink && !loserMatchUp && loserFeedProfile !== DRAW) {\n    ({\n      matchUpDrawPositionIndex: loserMatchUpDrawPositionIndex,\n      targetDrawPosition: loserTargetDrawPosition,\n      matchUp: loserMatchUp,\n    } = getTargetMatchUp({\n      targetLink: loserTargetLink,\n      sourceRoundMatchUpCount,\n      inContextDrawMatchUps,\n      sourceRoundPosition,\n      drawDefinition,\n    }));\n  }\n\n  if (propagateByeFMLC && byeFeedProfile !== DRAW) {\n    ({\n      matchUpDrawPositionIndex: byeMatchUpDrawPositionIndex,\n      targetDrawPosition: byeTargetDrawPosition,\n      matchUp: byeMatchUp,\n    } = getTargetMatchUp({\n      targetLink: byeTargetLink,\n      sourceRoundMatchUpCount,\n      inContextDrawMatchUps,\n      sourceRoundPosition,\n      drawDefinition,\n    }));\n  }\n\n  if (winnerTargetLink && !winnerMatchUp && winnerFeedProfile !== DRAW) {\n    ({\n      matchUpDrawPositionIndex: winnerMatchUpDrawPositionIndex,\n      targetDrawPosition: winnerTargetDrawPosition,\n      matchUp: winnerMatchUp,\n    } = getTargetMatchUp({\n      targetLink: winnerTargetLink,\n      sourceRoundMatchUpCount,\n      inContextDrawMatchUps,\n      sourceRoundPosition,\n      drawDefinition,\n    }));\n  }\n\n  if (!winnerMatchUp) {\n    // if there is no winnerTargetLink then find targetMatchUp in next round\n    structureMatchUps =\n      structureMatchUps ||\n      inContextDrawMatchUps.filter(\n        (matchUp) => matchUp.structureId === structure.structureId\n      );\n    ({ matchUp: winnerMatchUp } = getNextRoundMatchUp({\n      structureMatchUps,\n      matchUp,\n    }));\n  }\n\n  return definedAttributes({\n    matchUp,\n    targetLinks: { loserTargetLink, winnerTargetLink, byeTargetLink },\n    targetMatchUps: {\n      winnerMatchUpDrawPositionIndex,\n      loserMatchUpDrawPositionIndex,\n      byeMatchUpDrawPositionIndex,\n      winnerTargetDrawPosition,\n      loserTargetDrawPosition,\n      byeTargetDrawPosition,\n      winnerMatchUp,\n      loserMatchUp,\n      byeMatchUp,\n    },\n    targetMatchUpIds: !!(winnerMatchUpId || loserMatchUpId),\n  });\n}\n\nfunction targetByWinRatio({ matchUp }) {\n  return {\n    targetLinks: { loserTargetLink: undefined, winnerTargetLink: undefined }, // returned for testing\n    targetMatchUps: { loserMatchUp: undefined, winnerMatchUp: undefined },\n    matchUp,\n  };\n}\n","/*\n  returns the next round matchUp for winner of given matchUp\n  must exclude tieMatchUps as next round matchUp count may not be consistent\n*/\nexport function getNextRoundMatchUp({ structureMatchUps, matchUp }) {\n  const { roundNumber, roundPosition } = matchUp;\n  const currentRoundMatchUps = structureMatchUps.filter(\n    (matchUp) => matchUp.roundNumber === roundNumber && !matchUp.matchUpTieId\n  );\n  const nextRoundMatchUps = structureMatchUps.filter(\n    (matchUp) =>\n      matchUp.roundNumber === roundNumber + 1 && !matchUp.matchUpTieId\n  );\n\n  if (nextRoundMatchUps.length) {\n    let nextMatchUp;\n    if (nextRoundMatchUps.length === currentRoundMatchUps.length) {\n      nextMatchUp = nextRoundMatchUps.find(\n        (matchUp) => matchUp.roundPosition === roundPosition\n      );\n    } else if (nextRoundMatchUps.length === currentRoundMatchUps.length / 2) {\n      nextMatchUp = nextRoundMatchUps.find(\n        (matchUp) => matchUp.roundPosition === Math.ceil(roundPosition / 2)\n      );\n    }\n\n    return { matchUp: nextMatchUp };\n  }\n  return { message: 'no progression found' };\n}\n","import { isConvertableInteger } from '../utilities/math';\nimport { isObject } from '../utilities/objects';\n\nexport function validMatchUp(matchUp) {\n  if (!isObject(matchUp)) return false;\n  const { matchUpId, drawPositions } = matchUp;\n  const validMatchUpId = typeof matchUpId === 'string';\n  const validDrawPositions =\n    !drawPositions ||\n    (Array.isArray(drawPositions) &&\n      drawPositions.length <= 2 &&\n      drawPositions.every(\n        (dp) => isConvertableInteger(dp) || dp === undefined || dp === null\n      ));\n\n  return validMatchUpId && validDrawPositions;\n}\n\nexport function validMatchUps(matchUps) {\n  if (!Array.isArray(matchUps)) return false;\n  return matchUps.every(validMatchUp);\n}\n","import { completedMatchUpStatuses } from '../../constants/matchUpStatusConstants';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { validMatchUps } from '../../validators/validMatchUp';\nimport { numericSort } from '../../utilities/sorting';\nimport { ensureInt } from '../../utilities/ensureInt';\nimport { isPowerOf2 } from '../../utilities/math';\nimport { chunkArray, generateRange, intersection } from '../../utilities/arrays';\n\nimport { ErrorType, INVALID_VALUES } from '../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport { RoundProfile } from '../../types/factoryTypes';\nimport { TEAM } from '../../constants/matchUpTypes';\n\ntype GetRoundMatchUpsArgs = {\n  matchUps?: HydratedMatchUp[];\n  interpolate?: boolean;\n};\n\nexport type RoundMatchUpsResult = {\n  roundMatchUps?: { [roundNumber: number]: HydratedMatchUp[] };\n  hasNoRoundPositions?: boolean;\n  roundsNotPowerOf2?: boolean;\n  maxMatchUpsCount?: number;\n  roundProfile?: RoundProfile;\n  roundNumbers?: number[];\n  error?: ErrorType;\n};\n\nexport function getRoundMatchUps({ matchUps = [], interpolate }: GetRoundMatchUpsArgs): RoundMatchUpsResult {\n  if (!validMatchUps(matchUps)) return { roundMatchUps: [], error: INVALID_VALUES };\n\n  // create an array of arrays of matchUps grouped by roundNumber\n  const roundMatchUpsArray = matchUps\n    .reduce((roundNumbers: number[], matchUp) => {\n      const roundNumber =\n        typeof matchUp.roundNumber === 'string' ? ensureInt(matchUp.roundNumber) : (matchUp.roundNumber as number);\n      return !matchUp.roundNumber || roundNumbers.includes(roundNumber)\n        ? roundNumbers\n        : roundNumbers.concat(roundNumber);\n    }, [])\n    .sort(numericSort)\n    .map((roundNumber) => {\n      const roundMatchUps = matchUps.filter((matchUp) => matchUp.roundNumber === roundNumber);\n      const hasTeamMatchUps = roundMatchUps.find(({ matchUpType }) => matchUpType === TEAM);\n      // if there are TEAM matchUps then all other matchUpTypes must be removed\n      const consideredMatchUps = hasTeamMatchUps\n        ? roundMatchUps.filter(({ matchUpType }) => matchUpType === TEAM)\n        : roundMatchUps;\n      const getSorted = (items) => items.sort((a, b) => numericSort(a.roundPosition, b.roundPosition));\n      return {\n        [roundNumber]: getSorted(consideredMatchUps),\n      };\n    });\n\n  // calculate the finishing Round for each roundNumber\n  const finishingRoundMap = matchUps.reduce((mapping, matchUp) => {\n    const roundNumber =\n      typeof matchUp.roundNumber === 'string' ? ensureInt(matchUp.roundNumber) : (matchUp.roundNumber as number);\n    if (!mapping[roundNumber])\n      mapping[roundNumber] = definedAttributes({\n        abbreviatedRoundName: matchUp.abbreviatedRoundName,\n        finishingRound: matchUp.finishingRound,\n        roundName: matchUp.roundName,\n      });\n    return mapping;\n  }, {});\n\n  // convert roundMatchUpsArray into an object with roundNumber keys\n  const roundMatchUps = Object.assign({}, ...roundMatchUpsArray);\n\n  if (interpolate) {\n    const maxRoundNumber = Math.max(\n      ...Object.keys(roundMatchUps)\n        .map((key) => ensureInt(key))\n        .filter((f) => !isNaN(f)),\n    );\n    const maxRoundMatchUpsCount = roundMatchUps[maxRoundNumber]?.length;\n    // when considering a structue, if rounds do not progress to a final round which contains one matchUp\n    // and if the last provided round has power-of-two matchUpsCount, add details for the matchUps which are \"missing\"\n    if (maxRoundMatchUpsCount > 1 && isPowerOf2(maxRoundMatchUpsCount)) {\n      const nextRound = maxRoundNumber + 1;\n      const lastRound = nextRound + maxRoundMatchUpsCount / 2;\n      const roundsToInterpolate = generateRange(nextRound, lastRound);\n      roundsToInterpolate.forEach((roundNumber, i) => {\n        roundMatchUps[roundNumber] = generateRange(0, maxRoundMatchUpsCount / (2 + i * 2)).map(() => ({})); // add dummy objects for padding out the array\n      });\n    }\n  }\n\n  let maxMatchUpsCount = 0;\n\n  // create a profle object with roundNubmer keys\n  // provides details for each round, including:\n  //  - matchUpsCount: total number of matchUps\n  //  - preFeedRound: whether the round is followed by a feedRound\n  //  - feedRound: whether round matchUps have fed partitipants\n  //  - roundIndex & feedRoundIndex: index relative to round type\n  //  - finishingRound: reverse count of rounds. Final is finishingRound #1\n  const roundProfile: RoundProfile = Object.assign(\n    {},\n    ...Object.keys(roundMatchUps).map((roundNumber) => {\n      const matchUpsCount = roundMatchUps[roundNumber]?.length;\n      const inactiveCount = roundMatchUps[roundNumber]?.filter(\n        (matchUp) => !completedMatchUpStatuses.includes(matchUp.matchUpStatus) && !matchUp.score?.scoreStringSide1,\n      )?.length;\n      const inactiveRound = matchUpsCount && matchUpsCount === inactiveCount;\n\n      maxMatchUpsCount = Math.max(maxMatchUpsCount, matchUpsCount);\n      return { [roundNumber]: { matchUpsCount, inactiveCount, inactiveRound } };\n    }),\n  );\n\n  let roundIndex = 0;\n  let feedRoundIndex = 0;\n  const roundNumbers = Object.keys(roundMatchUps)\n    .map((key) => ensureInt(key))\n    .filter((f) => !isNaN(f));\n  roundNumbers.forEach((roundNumber) => {\n    const currentRoundMatchUps = roundMatchUps[roundNumber].sort((a, b) => a.roundPosition - b.roundPosition);\n    const currentRoundDrawPositions = currentRoundMatchUps.map((matchUp) => matchUp?.drawPositions || []).flat();\n\n    roundProfile[roundNumber].roundNumber = roundNumber; // convenience\n\n    // convenience for display calculations\n    roundProfile[roundNumber].roundFactor = roundProfile[roundNumber].matchUpsCount\n      ? maxMatchUpsCount / roundProfile[roundNumber].matchUpsCount\n      : 1;\n\n    roundProfile[roundNumber].finishingRound = finishingRoundMap[roundNumber]?.finishingRound;\n    roundProfile[roundNumber].roundName = finishingRoundMap[roundNumber]?.roundName;\n    roundProfile[roundNumber].abbreviatedRoundName = finishingRoundMap[roundNumber]?.abbreviatedRoundName;\n\n    roundProfile[roundNumber].finishingPositionRange = roundMatchUps[roundNumber]?.[0]?.finishingPositionRange;\n\n    if (roundNumber === 1 || !roundProfile[roundNumber - 1]) {\n      const orderedDrawPositions = currentRoundDrawPositions.sort(numericSort);\n      const pairedDrawPositions = chunkArray(orderedDrawPositions, 2);\n      roundProfile[roundNumber].drawPositions = orderedDrawPositions;\n      roundProfile[roundNumber].pairedDrawPositions = pairedDrawPositions;\n    } else {\n      const priorRound = roundProfile[roundNumber - 1];\n      const priorRoundDrawPositions = priorRound.drawPositions;\n      const chunkFactor = priorRound.matchUpsCount / roundProfile[roundNumber].matchUpsCount;\n      const priorRoundDrawPositionChunks = chunkArray(priorRoundDrawPositions, chunkFactor);\n\n      // ensures that drawPositions are returned in top to bottom order\n      const roundDrawPositions = currentRoundMatchUps.map((matchUp) => {\n        const { roundPosition } = matchUp;\n        const drawPositions = [...(matchUp.drawPositions || []), undefined, undefined].slice(0, 2); // accounts for empty array, should always have length 2\n\n        if (!roundPosition) return drawPositions;\n\n        const filteredDrawPositions = drawPositions?.filter(Boolean) || [];\n        if (!filteredDrawPositions?.length) return [undefined, undefined];\n\n        // { roundNumber: 2 } is the first possible feed round and the last time that a numeric sort is guaranteed to work\n        if (roundNumber < 3 && filteredDrawPositions?.length === 2) {\n          return drawPositions?.slice().sort(numericSort); // make a copy of the values to avoid mutating the original\n        }\n\n        const isFeedRound =\n          intersection(priorRoundDrawPositions, filteredDrawPositions).length !== filteredDrawPositions?.length;\n\n        // if the prior round does NOT include the one existing drawPosition then it is a feed round\n        // ... and fed positions are always { sideNumber: 1 }\n        if (filteredDrawPositions?.length && isFeedRound) {\n          if (filteredDrawPositions?.length === 1) {\n            return [filteredDrawPositions[0], undefined];\n          } else {\n            return drawPositions?.slice().sort(numericSort); // make a copy of the values to avoid mutating the original\n          }\n        }\n\n        // otherwise determine the order of the drawPositions by looking at the prior round\n        // this accounts for ADVANCED fed positions which are NOT guaranteed to be in numeric order\n        // ... because a lower number fed position may be in { sideNumber: 2 } while an drawPosition advanced\n        // from the first round may be in { sideNumber: 1 }\n        // const targetChunkIndex = (roundPosition - 1) * 2;\n        const targetChunkIndex = (roundPosition - 1) * 2;\n        const targetChunks = priorRoundDrawPositionChunks.slice(targetChunkIndex, targetChunkIndex + 2);\n\n        return targetChunks.map((chunk) => {\n          return filteredDrawPositions?.find((drawPosition) => chunk.includes(drawPosition));\n        });\n      });\n\n      roundProfile[roundNumber].drawPositions = roundDrawPositions?.flat();\n      roundProfile[roundNumber].pairedDrawPositions = roundDrawPositions;\n    }\n\n    if (\n      roundProfile[roundNumber + 1] &&\n      roundProfile[roundNumber + 1].matchUpsCount === roundProfile[roundNumber].matchUpsCount\n    ) {\n      roundProfile[roundNumber + 1].feedRound = true;\n      roundProfile[roundNumber + 1].feedRoundIndex = feedRoundIndex;\n      roundProfile[roundNumber].preFeedRound = true;\n      feedRoundIndex += 1;\n    }\n    if (roundProfile[roundNumber] && !roundProfile[roundNumber].feedRound) {\n      roundProfile[roundNumber].roundIndex = roundIndex;\n      roundIndex += 1;\n    }\n  });\n\n  const roundsNotPowerOf2 = !!Object.values(roundProfile).find(({ matchUpsCount }) => !isPowerOf2(matchUpsCount));\n\n  const hasNoRoundPositions = matchUps.some((matchUp) => !matchUp.roundPosition);\n\n  return {\n    hasNoRoundPositions,\n    roundsNotPowerOf2,\n    maxMatchUpsCount,\n    roundMatchUps,\n    roundNumbers,\n    roundProfile,\n    ...SUCCESS,\n  };\n}\n","import { positionTargets } from '../../matchUps/drawPositions/positionTargets';\nimport { getRoundMatchUps } from '../../../query/matchUps/getRoundMatchUps';\nimport { getParticipantIds } from '../../../global/functions/extractors';\nimport { timeStringMinutes } from '../../../utilities/dateTime';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { numericSort } from '../../../utilities/sorting';\nimport { ensureInt } from '../../../utilities/ensureInt';\n\nimport { FIRST_MATCHUP, WIN_RATIO } from '../../../constants/drawDefinitionConstants';\nimport { BYE, TO_BE_PLAYED } from '../../../constants/matchUpStatusConstants';\n\nexport function addUpcomingMatchUps({ drawDefinition, inContextDrawMatchUps }) {\n  const scheduleConflictMatchUpIds = {};\n\n  inContextDrawMatchUps.forEach((inContextMatchUp) => {\n    const { matchUpId, structureId, drawPositions = [] } = inContextMatchUp;\n    const { structure } = findStructure({ drawDefinition, structureId });\n    if (structure?.finishingPosition === WIN_RATIO) {\n      const { roundNumber } = inContextMatchUp;\n      const nextRoundNumber = roundNumber && ensureInt(roundNumber) + 1;\n      const matchUps = structure.matchUps ?? [];\n      const { roundMatchUps } = getRoundMatchUps({ matchUps });\n\n      // if this is a round robin then we have sidesTo information, not winnerTo and loserTo\n      if (nextRoundNumber && roundMatchUps?.[nextRoundNumber]) {\n        const sidesTo = [...drawPositions] // spread to avoid mutating the original\n          .sort(numericSort)\n          .map((drawPosition, index) => {\n            const nextRoundMatchUp = roundMatchUps[nextRoundNumber].find(\n              (matchUp) => matchUp.drawPositions?.includes(drawPosition),\n            );\n            return {\n              matchUpId: nextRoundMatchUp?.matchUpId,\n              roundNumber: nextRoundNumber,\n              schedule: nextRoundMatchUp?.schedule,\n              sideNumber: index + 1,\n              structureName: structure.structureName,\n            };\n          });\n        Object.assign(inContextMatchUp, { sidesTo });\n      }\n    } else {\n      const targetData = positionTargets({\n        useTargetMatchUpIds: true,\n        inContextDrawMatchUps,\n        inContextMatchUp,\n        drawDefinition,\n        matchUpId,\n      });\n      let { winnerMatchUp } = targetData.targetMatchUps;\n      const { loserMatchUp } = targetData.targetMatchUps;\n\n      if (!inContextMatchUp.winnerMatchUpId && winnerMatchUp) {\n        inContextMatchUp.winnerMatchUpId = winnerMatchUp.matchUpId;\n      }\n      if (!inContextMatchUp.loserMatchUpId && loserMatchUp) {\n        inContextMatchUp.loserMatchUpId = loserMatchUp.matchUpId;\n      }\n\n      const winnerTo = getUpcomingInfo({ upcomingMatchUp: winnerMatchUp });\n      let loserTo = getUpcomingInfo({ upcomingMatchUp: loserMatchUp });\n\n      if (inContextMatchUp.matchUpStatus !== BYE && loserMatchUp?.matchUpStatus === BYE) {\n        const { matchUp: nextMatchUp } =\n          getNextToBePlayedMatchUp({\n            matchUp: loserMatchUp,\n            drawDefinition,\n            inContextDrawMatchUps,\n          }) || {};\n        loserTo = (nextMatchUp && getUpcomingInfo({ upcomingMatchUp: nextMatchUp })) || loserTo;\n      }\n\n      // scheduleConflict in the following only applies to conflicts between subsequent matchUps WITHIN the same draw\n      const timeAfterRecovery = inContextMatchUp.schedule?.timeAfterRecovery;\n      if (timeAfterRecovery) {\n        if (winnerTo?.schedule?.scheduledTime) {\n          const scheduleConflict =\n            timeStringMinutes(winnerTo.schedule.scheduledTime) < timeStringMinutes(timeAfterRecovery);\n          if (scheduleConflict) {\n            scheduleConflictMatchUpIds[winnerTo.matchUpId] = inContextMatchUp.matchUpId;\n            winnerTo.schedule.scheduleConflict = inContextMatchUp.matchUpId;\n          }\n        }\n        if (loserTo?.schedule?.scheduledTime) {\n          const scheduleConflict =\n            timeStringMinutes(loserTo.schedule.scheduledTime) < timeStringMinutes(timeAfterRecovery);\n          if (scheduleConflict) {\n            scheduleConflictMatchUpIds[loserTo.matchUpId] = inContextMatchUp.matchUpId;\n            loserTo.schedule.scheduleConflict = inContextMatchUp.matchUpId;\n          }\n        }\n      }\n      Object.assign(inContextMatchUp, { winnerTo, loserTo });\n\n      if (inContextMatchUp.drawPositions?.filter(Boolean).length) {\n        const loserTargetLink = targetData.targetLinks?.loserTargetLink;\n        const firstMatchUp = loserTargetLink?.linkCondition === FIRST_MATCHUP;\n\n        const participants = getMatchUpParticipants(inContextMatchUp);\n        if (participants.length) {\n          const winnerParticipantIds = getParticipantIds(winnerMatchUp?.sides);\n          const loserParticipantIds = getParticipantIds(loserMatchUp?.sides);\n          const winnerDetermined = participants.find(({ participantId }) =>\n            winnerParticipantIds.includes(participantId),\n          );\n          const winnerPotentials = !winnerDetermined ? participants : [];\n          const loserDetermined = participants.find(({ participantId }) => loserParticipantIds.includes(participantId));\n          const loserPotentials = !loserDetermined ? participants : [];\n          if (loserMatchUp && firstMatchUp && loserPotentials.length < 2) {\n            loserPotentials.push({ bye: true, tbd: true }); // tbd: true indiciates that for FMLC, WO/DEF could propagate a player\n          }\n          if (winnerPotentials?.length && winnerMatchUp) {\n            // -----------------------------------------------------\n            // when targetMatchUpIds are not present in source data\n            // winnerMatchUp / loserMatchUp are not original objects\n            if (!targetData.targetMatchUpIds && winnerMatchUp) {\n              winnerMatchUp = inContextDrawMatchUps.find(({ matchUpId }) => matchUpId === winnerMatchUp.matchUpId);\n            }\n            // -----------------------------------------------------\n\n            if (!winnerMatchUp.potentialParticipants) winnerMatchUp.potentialParticipants = [];\n            winnerMatchUp.potentialParticipants.push(winnerPotentials);\n          }\n          if (loserPotentials?.length && loserMatchUp) {\n            // -----------------------------------------------------\n            // when targetMatchUpIds are not present in source data\n            // winnerMatchUp / loserMatchUp are not original objects\n            if (!targetData.targetMatchUpIds) {\n              winnerMatchUp = inContextDrawMatchUps.find(({ matchUpId }) => matchUpId === loserMatchUp.matchUpId);\n            }\n            // -----------------------------------------------------\n\n            if (!loserMatchUp.potentialParticipants) {\n              loserMatchUp.potentialParticipants = [];\n            }\n\n            loserMatchUp.potentialParticipants.push(loserPotentials);\n          }\n        }\n      }\n    }\n  });\n\n  if (Object.keys(scheduleConflictMatchUpIds).length) {\n    inContextDrawMatchUps.forEach((inContextMatchUp) => {\n      if (Object.keys(scheduleConflictMatchUpIds).includes(inContextMatchUp.matchUpId))\n        inContextMatchUp.schedule.scheduleConflict = scheduleConflictMatchUpIds[inContextMatchUp.matchUpId];\n    });\n  }\n\n  return { scheduleConflictMatchUpIds };\n}\n\nfunction getMatchUpParticipants(matchUp) {\n  return (\n    matchUp?.sides\n      ?.map(\n        ({ participant, participantId, qualifier }) =>\n          participant || (participantId && { participantId }) || (qualifier && { qualifier }),\n      )\n      .filter(Boolean) || []\n  );\n}\n\nfunction getNextToBePlayedMatchUp({ matchUp, drawDefinition, inContextDrawMatchUps }) {\n  const { matchUpId, matchUpStatus, structureId } = matchUp || {};\n  if (!matchUp || !structureId || matchUp?.matchUpStatus === TO_BE_PLAYED) return { matchUp };\n  if (matchUpStatus === BYE) {\n    let winnerMatchUp;\n\n    if (matchUp.winnerMatchUpId) {\n      winnerMatchUp = inContextDrawMatchUps.find(({ matchUpId }) => matchUpId === matchUp.winnerMatchUpId);\n    } else {\n      const targetData = positionTargets({\n        inContextDrawMatchUps,\n        drawDefinition,\n        matchUpId,\n      });\n      ({ winnerMatchUp } = targetData?.targetMatchUps || {});\n    }\n\n    return getNextToBePlayedMatchUp({\n      matchUp: winnerMatchUp,\n      drawDefinition,\n      inContextDrawMatchUps,\n    });\n  }\n  return { matchUp: undefined };\n}\n\nfunction getUpcomingInfo(params) {\n  if (!params?.upcomingMatchUp) return;\n  return (({ matchUpId, structureId, schedule, roundNumber, roundPosition, structureName }) => ({\n    matchUpId,\n    structureId,\n    schedule,\n    roundNumber,\n    roundPosition,\n    structureName,\n  }))(params.upcomingMatchUp);\n}\n","import { makeDeepCopy } from '../../utilities/makeDeepCopy';\n\nimport { APPLIED_POLICIES } from '../../constants/extensionConstants';\nimport { PolicyDefinitions } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ErrorType,\n  MISSING_POLICY_TYPE,\n  POLICY_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Structure,\n  Tournament,\n} from '../../types/tournamentTypes';\n\ntype GetAppliedPoliciesArgs = {\n  onlySpecifiedPolicyTypes?: boolean;\n  tournamentRecord?: Tournament;\n  drawDefinition?: DrawDefinition;\n  policyTypes?: string[];\n  structure?: Structure;\n  event?: Event;\n};\n\nexport function getAppliedPolicies({\n  onlySpecifiedPolicyTypes = false,\n  policyTypes = [],\n  tournamentRecord,\n  drawDefinition,\n  structure,\n  event,\n}: GetAppliedPoliciesArgs): {\n  appliedPolicies?: PolicyDefinitions;\n  error?: ErrorType;\n} {\n  if (!Array.isArray(policyTypes)) return { error: MISSING_POLICY_TYPE };\n  const appliedPolicies = {};\n\n  if (tournamentRecord) extractAppliedPolicies(tournamentRecord);\n  if (event) extractAppliedPolicies(event);\n  if (drawDefinition) extractAppliedPolicies(drawDefinition);\n  if (structure) extractAppliedPolicies(structure);\n\n  return { appliedPolicies, ...SUCCESS };\n\n  function extractAppliedPolicies(params) {\n    const extensions = params?.extensions;\n    const extensionPolicies = extensions?.find(\n      (extension) => extension.name === APPLIED_POLICIES\n    )?.value;\n    if (extensionPolicies) {\n      for (const key of Object.keys(extensionPolicies))\n        if (\n          onlySpecifiedPolicyTypes\n            ? policyTypes.includes(key)\n            : !policyTypes.length || policyTypes.includes(key)\n        ) {\n          appliedPolicies[key] = makeDeepCopy(\n            extensionPolicies[key],\n            false,\n            true\n          );\n        }\n    }\n  }\n}\n\ntype GetPolicyDefinitionsArgs = {\n  tournamentRecord?: Tournament;\n  drawDefinition?: DrawDefinition;\n  policyTypes?: string[];\n  structure?: Structure;\n  event?: Event;\n};\nexport function getPolicyDefinitions({\n  policyTypes = [],\n  tournamentRecord,\n  drawDefinition,\n  structure,\n  event,\n}: GetPolicyDefinitionsArgs): {\n  policyDefinitions?: PolicyDefinitions;\n  error?: ErrorType;\n  info?: string;\n} {\n  if (!Array.isArray(policyTypes)) return { error: MISSING_POLICY_TYPE };\n\n  const { appliedPolicies } = getAppliedPolicies({\n    tournamentRecord,\n    drawDefinition,\n    structure,\n    event,\n  });\n\n  const policyDefinitions: PolicyDefinitions = {};\n\n  for (const policyType of policyTypes) {\n    const policy = appliedPolicies?.[policyType];\n    if (policy) policyDefinitions[policyType] = policy;\n  }\n\n  return Object.keys(policyDefinitions).length\n    ? { policyDefinitions }\n    : { info: POLICY_NOT_FOUND.message };\n}\n","export const WALKOVER = 'WALKOVER';\nexport const RETIRED = 'RETIRED';\nexport const COMPETITIVE = 'COMPETITIVE';\nexport const ROUTINE = 'ROUTINE';\nexport const DECISIVE = 'DECISIVE';\nexport const WIN_RATIO = 'winRatio';\n","import { POLICY_TYPE_COMPETITIVE_BANDS } from '../../constants/policyConstants';\n\nimport { DECISIVE, ROUTINE } from '../../constants/statsConstants';\n\nexport const POLICY_COMPETITIVE_BANDS_DEFAULT = {\n  [POLICY_TYPE_COMPETITIVE_BANDS]: {\n    policyName: 'Competitive Bands Default',\n    profileBands: {\n      [DECISIVE]: 20,\n      [ROUTINE]: 50,\n    },\n  },\n};\n\nexport default POLICY_COMPETITIVE_BANDS_DEFAULT;\n","import { getPolicyDefinitions } from '../extensions/getAppliedPolicies';\n\nimport POLICY_COMPETITIVE_BANDS_DEFAULT from '../../fixtures/policies/POLICY_COMPETITIVE_BANDS_DEFAULT';\nimport { POLICY_TYPE_COMPETITIVE_BANDS } from '../../constants/policyConstants';\nimport { ContextProfile, PolicyDefinitions } from '../../types/factoryTypes';\nimport { DrawDefinition, Event, Tournament } from '../../types/tournamentTypes';\n\ntype GetContextContentArgs = {\n  policyDefinitions?: PolicyDefinitions;\n  tournamentRecord?: Tournament;\n  drawDefinition?: DrawDefinition;\n  contextProfile?: ContextProfile;\n  event?: Event;\n};\nexport function getContextContent({\n  policyDefinitions,\n  tournamentRecord,\n  contextProfile,\n  drawDefinition,\n  event,\n}: GetContextContentArgs) {\n  const contextContent = { policies: {} };\n\n  if (!contextProfile) return contextContent;\n\n  const policies = getPolicyDefinitions({\n    tournamentRecord,\n    drawDefinition,\n    event,\n  }).policyDefinitions;\n\n  if (contextProfile.withCompetitiveness) {\n    const policy =\n      policyDefinitions?.[POLICY_TYPE_COMPETITIVE_BANDS] ??\n      policies?.[POLICY_TYPE_COMPETITIVE_BANDS] ??\n      POLICY_COMPETITIVE_BANDS_DEFAULT[POLICY_TYPE_COMPETITIVE_BANDS];\n\n    contextContent.policies[POLICY_TYPE_COMPETITIVE_BANDS] = policy;\n  }\n\n  return contextContent;\n}\n","import { INVALID_DRAW_DEFINITION } from '../../constants/errorConditionConstants';\nimport { CONSOLATION, PLAY_OFF } from '../../constants/drawDefinitionConstants';\n\nexport function getExitProfiles({ drawDefinition }) {\n  if (typeof drawDefinition !== 'object')\n    return { error: INVALID_DRAW_DEFINITION };\n\n  const exitProfiles = {};\n  const { structures = [], links = [] } = drawDefinition || {};\n\n  const stageStructures = structures.reduce((stageStructures, structure) => {\n    const { stage } = structure;\n    if (!stageStructures[stage]) {\n      stageStructures[stage] = [structure];\n    } else {\n      stageStructures[stage].push(structure);\n    }\n    return stageStructures;\n  }, {});\n\n  for (const stage of Object.keys(stageStructures)) {\n    // there can only be one structure per stage with stageSequence 1\n    const initialStructure = stageStructures[stage].find(\n      ({ stageSequence }) => stageSequence === 1\n    );\n\n    if (!initialStructure) continue;\n\n    // initial structure of each stage has exitProfile of '0'\n    const { structureId } = initialStructure;\n    // each structure can **potentially** have more than one exitProfile\n    // a DOUBLE_ELIMINATION initialStructure is also referred to by the CONSOLATION final exitProfile\n    // a CONSOLATION structure with multiple feed rounds will have multiple exitProfiles referring to it\n    const exitProfile = '0';\n\n    addExitProfiles({\n      aggregator: {},\n      targetRound: 0,\n      exitProfiles,\n      exitProfile,\n      structureId,\n      stage,\n    });\n  }\n\n  return { exitProfiles };\n\n  function addExitProfiles({\n    exitProfiles,\n    exitProfile,\n    structureId,\n    targetRound,\n    aggregator,\n    stage,\n  }) {\n    if (!exitProfiles[structureId]) exitProfiles[structureId] = [];\n\n    // initialStructure of CONSOLATION and PLAY_OFF do not need to be captured\n    if (!(exitProfile === '0' && [CONSOLATION, PLAY_OFF].includes(stage)))\n      exitProfiles[structureId].push(exitProfile);\n    const relevantLinks = links.filter(\n      (link) =>\n        link.source.structureId === structureId &&\n        link.source.roundNumber >= targetRound // this doesn't work for ROUND_ROBIN. Will need to use roundProfile to determine final roundNumber.\n    );\n\n    for (const link of relevantLinks) {\n      const exitRound = link.source.roundNumber;\n      const targetRound = link.target.roundNumber;\n      const targetStructureId = link.target.structureId;\n      const stage = structures.find(\n        (structure) => structure.structureId === targetStructureId\n      ).stage;\n\n      const fp = [stage, targetStructureId, targetRound, exitRound].join('|');\n      if (aggregator[fp]) return;\n      aggregator[fp] = true;\n\n      addExitProfiles({\n        exitProfile: `${exitProfile}-${exitRound}`,\n        structureId: targetStructureId,\n        exitProfiles,\n        targetRound,\n        aggregator,\n        stage,\n      });\n    }\n  }\n}\n","import { makeDeepCopy } from '../../utilities/makeDeepCopy';\n\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport {\n  DrawDefinition,\n  MatchUp,\n  Structure,\n} from '../../types/tournamentTypes';\n\nexport type MappedMatchUps = {\n  [key: string]: {\n    matchUps: HydratedMatchUp[] | MatchUp[] | undefined;\n    itemStructureIds: string[];\n    structureName?: string;\n  };\n};\n\nexport type MatchUpsMap = {\n  mappedMatchUps: MappedMatchUps;\n  drawMatchUps: MatchUp[];\n};\n\ntype GetMatchUpsMapArgs = {\n  drawDefinition?: DrawDefinition;\n  structure?: Structure;\n};\n\nexport function getMatchUpsMap({\n  drawDefinition,\n  structure,\n}: GetMatchUpsMapArgs): MatchUpsMap {\n  const mappedMatchUps: MappedMatchUps = {};\n  const drawMatchUps: MatchUp[] = [];\n\n  (drawDefinition?.structures ?? [structure])\n    .filter((structure) => structure && typeof structure === 'object')\n    .forEach((structure) => {\n      if (!structure) return;\n      const { structureId, matchUps, structures } = structure;\n      const isRoundRobin = Array.isArray(structures);\n      if (!isRoundRobin) {\n        const filteredMatchUps = matchUps;\n        mappedMatchUps[structureId] = {\n          matchUps: filteredMatchUps,\n          itemStructureIds: [],\n        };\n        filteredMatchUps?.forEach((matchUp) => {\n          drawMatchUps.push(matchUp);\n          if (matchUp.tieMatchUps) drawMatchUps.push(...matchUp.tieMatchUps);\n        });\n      } else if (isRoundRobin) {\n        structures.forEach((itemStructure) => {\n          const { structureName } = itemStructure;\n          const filteredMatchUps = itemStructure.matchUps;\n\n          mappedMatchUps[itemStructure.structureId] = {\n            matchUps: filteredMatchUps,\n            itemStructureIds: [],\n            structureName,\n          };\n          if (filteredMatchUps) {\n            drawMatchUps.push(...filteredMatchUps);\n            filteredMatchUps.forEach((matchUp) => {\n              if (matchUp.tieMatchUps)\n                drawMatchUps.push(...matchUp.tieMatchUps);\n            });\n          }\n          if (!mappedMatchUps[structureId])\n            mappedMatchUps[structureId] = {\n              itemStructureIds: [],\n              matchUps: [],\n            };\n          if (!mappedMatchUps[structureId].itemStructureIds)\n            mappedMatchUps[structureId].itemStructureIds = [];\n          mappedMatchUps[structureId].itemStructureIds.push(\n            itemStructure.structureId\n          );\n        });\n      }\n    });\n\n  return { mappedMatchUps, drawMatchUps };\n}\n\ntype GetMappedStructureMatchUpsArgs = {\n  matchUpsMap?: MatchUpsMap;\n  mappedMatchUps?: any;\n  structureId: string;\n  inContext?: boolean;\n};\nexport function getMappedStructureMatchUps({\n  mappedMatchUps,\n  matchUpsMap,\n  structureId,\n  inContext,\n}: GetMappedStructureMatchUpsArgs) {\n  mappedMatchUps = matchUpsMap?.mappedMatchUps ?? mappedMatchUps;\n  const structureMatchUpsMap = mappedMatchUps[structureId];\n  const itemStructureMatchUps = (structureMatchUpsMap?.itemStructureIds || [])\n    .map((itemStructureId) => {\n      const { matchUps, structureName } = mappedMatchUps[itemStructureId];\n      if (inContext) {\n        return matchUps.map((matchUp) => {\n          return Object.assign(makeDeepCopy(matchUp, true, true), {\n            containerStructureId: structureId,\n            structureId: itemStructureId,\n            structureName,\n          });\n        });\n      } else {\n        return matchUps;\n      }\n    })\n    .flat();\n\n  return (structureMatchUpsMap?.matchUps || []).concat(\n    ...itemStructureMatchUps\n  );\n}\n","import { Substitution } from '../../types/factoryTypes';\n\nexport function getCollectionPositionAssignments({\n  collectionPosition,\n  collectionId,\n  lineUp,\n}) {\n  let assignedParticipantIds: string[] = [];\n  const substitutions: Substitution[] = [];\n\n  if (lineUp) {\n    const getOrderValue = (order) => (order === undefined ? -1 : order);\n    const competitorAssignments = lineUp\n      .map((teamCompetitor) => {\n        const { collectionAssignments, participantId } = teamCompetitor;\n        const assignment = collectionAssignments?.find(\n          (assignment) =>\n            assignment.collectionPosition === collectionPosition &&\n            assignment.collectionId === collectionId\n        );\n        return assignment && { participantId, ...assignment };\n      })\n      .filter(Boolean)\n      .sort(\n        (a, b) =>\n          getOrderValue(a.substitutionOrder) -\n          getOrderValue(b.substitutionOrder)\n      );\n\n    for (const competitorAssignment of competitorAssignments) {\n      const { participantId, previousParticipantId, substitutionOrder } =\n        competitorAssignment;\n      if (assignedParticipantIds.includes(participantId)) continue;\n      if (previousParticipantId)\n        substitutions.push({\n          previousParticipantId,\n          substitutionOrder,\n          participantId,\n        });\n      assignedParticipantIds = assignedParticipantIds.filter(\n        (id) => id !== previousParticipantId\n      );\n      assignedParticipantIds.push(participantId);\n    }\n  }\n\n  return { assignedParticipantIds, substitutions };\n}\n","import { decorateResult } from '../../global/functions/decorateResult';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { intersection } from '../../utilities/arrays';\n\nimport { Participant, Tournament } from '../../types/tournamentTypes';\nimport { PAIR } from '../../constants/participantConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ErrorType,\n  INVALID_PARTICIPANT_IDS,\n  MISSING_PARTICIPANT_IDS,\n  MISSING_TOURNAMENT_RECORD,\n  PARTICIPANT_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\ntype GetPairedParticipantArgs = {\n  tournamentParticipants?: any[];\n  tournamentRecord?: Tournament;\n  participantIds: string[];\n};\n\nexport function getPairedParticipant({\n  tournamentParticipants,\n  tournamentRecord,\n  participantIds,\n}: GetPairedParticipantArgs): {\n  duplicatedPairParticipants?: any[];\n  participant?: Participant;\n  error?: ErrorType;\n  success?: boolean;\n} {\n  const stack = 'getPairedParticipant';\n\n  if (!tournamentParticipants && !tournamentRecord)\n    return { error: MISSING_TOURNAMENT_RECORD };\n  if (!Array.isArray(participantIds) || participantIds.length > 2)\n    return { error: INVALID_PARTICIPANT_IDS };\n  if (!participantIds.length)\n    return decorateResult({\n      result: { error: MISSING_PARTICIPANT_IDS },\n      stack,\n    });\n\n  tournamentParticipants =\n    tournamentParticipants ?? tournamentRecord?.participants ?? [];\n\n  const existingPairedParticipants = tournamentParticipants.filter(\n    (participant) =>\n      participant.participantType === PAIR &&\n      intersection(participantIds, participant.individualParticipantIds)\n        .length === participantIds.length &&\n      participant.individualParticipantIds.length === participantIds.length\n  );\n  const existingPairedParticipant = existingPairedParticipants[0];\n  if (!existingPairedParticipant) {\n    return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack });\n  }\n\n  const duplicatedPairParticipants = makeDeepCopy(\n    existingPairedParticipants.slice(1),\n    false,\n    true\n  );\n\n  return {\n    participant: makeDeepCopy(existingPairedParticipant),\n    duplicatedPairParticipants,\n    ...SUCCESS,\n  };\n}\n","import { findExtension } from '../../acquire/findExtension';\n\nimport { LINEUPS } from '../../constants/extensionConstants';\nimport {\n  MISSING_DRAW_DEFINITION,\n  MISSING_PARTICIPANT_ID,\n} from '../../constants/errorConditionConstants';\n\nexport function getTeamLineUp({ drawDefinition, participantId }) {\n  if (typeof drawDefinition !== 'object')\n    return { error: MISSING_DRAW_DEFINITION };\n  if (typeof participantId !== 'string')\n    return { error: MISSING_PARTICIPANT_ID };\n\n  const { extension } = findExtension({\n    element: drawDefinition,\n    name: LINEUPS,\n  });\n\n  const lineUps = extension?.value || {};\n  const lineUp = lineUps[participantId];\n\n  return { lineUp };\n}\n","import { addDrawDefinitionExtension } from '../../extensions/addRemoveExtensions';\nimport { findExtension } from '../../../acquire/findExtension';\n\nimport { ENTRY_PROFILE } from '../../../constants/extensionConstants';\nimport { DrawDefinition } from '../../../types/tournamentTypes';\n\ntype ModifyEntryProfileArgs = {\n  drawDefinition: DrawDefinition;\n  attributes: any[];\n};\nexport function modifyEntryProfile({\n  drawDefinition,\n  attributes,\n}: ModifyEntryProfileArgs) {\n  let { extension } = findExtension({\n    element: drawDefinition,\n    name: ENTRY_PROFILE,\n  });\n  const entryProfile = extension?.value || {};\n\n  attributes.forEach((attribute) => {\n    Object.keys(attribute).forEach((key) => {\n      if (!entryProfile[key]) {\n        entryProfile[key] = attribute[key];\n      } else {\n        Object.assign(entryProfile[key], attribute[key]);\n      }\n    });\n  });\n\n  extension = {\n    name: ENTRY_PROFILE,\n    value: entryProfile,\n  };\n  addDrawDefinitionExtension({ drawDefinition, extension });\n  return { entryProfile };\n}\n","import { findExtension } from '../../acquire/findExtension';\n\nimport { ENTRY_PROFILE } from '../../constants/extensionConstants';\nimport { DrawDefinition } from '../../types/tournamentTypes';\n\ntype GetEntryProfileArgs = {\n  drawDefinition: DrawDefinition;\n};\nexport function getEntryProfile({ drawDefinition }: GetEntryProfileArgs) {\n  const { extension } = findExtension({\n    element: drawDefinition,\n    name: ENTRY_PROFILE,\n  });\n  const entryProfile = extension?.value || {};\n  return { entryProfile };\n}\n","export const ALTERNATE = 'ALTERNATE';\nexport const CONFIRMED = 'CONFIRMED';\nexport const DIRECT_ACCEPTANCE = 'DIRECT_ACCEPTANCE';\nexport const FEED_IN = 'FEED_IN';\nexport const JUNIOR_EXEMPT = 'JUNIOR_EXEMPT';\nexport const LUCKY_LOSER = 'LUCKY_LOSER';\nexport const ORGANISER_ACCEPTANCE = 'ORGANISER_ACCEPTANCE';\nexport const QUALIFIER = 'QUALIFIER';\nexport const REGISTERED = 'REGISTERED';\nexport const SPECIAL_EXEMPT = 'SPECIAL_EXEMPT';\nexport const UNGROUPED = 'UNGROUPED';\nexport const UNPAIRED = 'UNPAIRED';\nexport const WILDCARD = 'WILDCARD';\nexport const WITHDRAWN = 'WITHDRAWN';\n\nexport const EQUIVALENT_ACCEPTANCE_STATUSES: any = [\n  CONFIRMED,\n  DIRECT_ACCEPTANCE,\n  JUNIOR_EXEMPT,\n  ORGANISER_ACCEPTANCE,\n  SPECIAL_EXEMPT,\n];\nexport const DRAW_SPECIFIC_STATUSES: any = [FEED_IN, LUCKY_LOSER, QUALIFIER];\n\nexport const DIRECT_ENTRY_STATUSES: any = [\n  CONFIRMED,\n  DIRECT_ACCEPTANCE,\n  FEED_IN,\n  JUNIOR_EXEMPT,\n  ORGANISER_ACCEPTANCE,\n  SPECIAL_EXEMPT,\n  WILDCARD,\n];\n\nexport const STRUCTURE_SELECTED_STATUSES: any = [\n  CONFIRMED,\n  DIRECT_ACCEPTANCE,\n  JUNIOR_EXEMPT,\n  LUCKY_LOSER,\n  QUALIFIER,\n  ORGANISER_ACCEPTANCE,\n  SPECIAL_EXEMPT,\n  WILDCARD,\n];\n\nexport const VALID_ENTRY_STATUSES: any = [\n  ALTERNATE,\n  CONFIRMED,\n  DIRECT_ACCEPTANCE,\n  FEED_IN,\n  JUNIOR_EXEMPT,\n  LUCKY_LOSER,\n  ORGANISER_ACCEPTANCE,\n  QUALIFIER,\n  REGISTERED,\n  SPECIAL_EXEMPT,\n  UNGROUPED,\n  UNPAIRED,\n  WILDCARD,\n  WITHDRAWN,\n];\n\nexport const entryStatusConstants: any = {\n  ALTERNATE,\n  CONFIRMED,\n  DIRECT_ACCEPTANCE,\n  DIRECT_ENTRY_STATUSES,\n  DRAW_SPECIFIC_STATUSES,\n  EQUIVALENT_ACCEPTANCE_STATUSES,\n  FEED_IN,\n  JUNIOR_EXEMPT,\n  LUCKY_LOSER,\n  ORGANISER_ACCEPTANCE,\n  QUALIFIER,\n  SPECIAL_EXEMPT,\n  STRUCTURE_SELECTED_STATUSES,\n  UNGROUPED,\n  UNPAIRED,\n  VALID_ENTRY_STATUSES,\n  WILDCARD,\n  WITHDRAWN,\n};\n","import { modifyEntryProfile } from '../../mutate/drawDefinitions/entryGovernor/modifyEntryProfile';\nimport { findExtension } from '../../acquire/findExtension';\nimport { findStructure } from '../../acquire/findStructure';\nimport { numericSort } from '../../utilities/sorting';\nimport { getEntryProfile } from './getEntryProfile';\n\nimport { ROUND_TARGET, TALLY } from '../../constants/extensionConstants';\nimport { ErrorType } from '../../constants/errorConditionConstants';\nimport { POSITION, CONTAINER, PLAY_OFF, validStages } from '../../constants/drawDefinitionConstants';\nimport { ALTERNATE, FEED_IN, WILDCARD, DIRECT_ENTRY_STATUSES } from '../../constants/entryStatusConstants';\nimport { DrawDefinition, DrawLink, EntryStatusUnion } from '../../types/tournamentTypes';\n\nexport function stageExists({ stage, drawDefinition }) {\n  const { entryProfile } = getEntryProfile({ drawDefinition });\n  const exists = Object.keys(entryProfile).includes(stage);\n  if (!exists && validStages.includes(stage)) {\n    const attributes = [\n      {\n        [stage]: {\n          drawSize: undefined,\n          alternates: true,\n        },\n      },\n    ];\n    modifyEntryProfile({ drawDefinition, attributes });\n    return true;\n  }\n  return exists;\n}\n\nexport function stageStructures({ stage, drawDefinition, stageSequence }) {\n  return (\n    drawDefinition &&\n    stage &&\n    drawDefinition.structures &&\n    drawDefinition.structures.filter((structure) => {\n      return structure.stage === stage && structure.stageSequence === stageSequence;\n    })\n  );\n}\n\nexport function stageAlternatesCount({ stage, drawDefinition }) {\n  const { entryProfile } = getEntryProfile({ drawDefinition });\n  return entryProfile[stage]?.alternates || 0;\n}\nexport function getStageWildcardsCount({ stage, drawDefinition }) {\n  const { entryProfile } = getEntryProfile({ drawDefinition });\n  return entryProfile[stage]?.wildcardsCount || 0;\n}\nexport function getStageEntryTypeCount({ stage, drawDefinition, entryStatus }) {\n  return drawDefinition.entries.reduce(\n    (p, c) => (c.entryStage === stage && c.entryStatus === entryStatus ? p + 1 : p),\n    0,\n  );\n}\nexport function stageSeededEntries({ stage, drawDefinition }) {\n  return drawDefinition.entries.reduce((p, c) => (c.entryStage === stage && c.seed ? p.concat(c) : p), []);\n}\n\ntype GetStageEntriesArgs = {\n  entryStatuses?: EntryStatusUnion[];\n  provisionalPositioning?: boolean;\n  drawDefinition: DrawDefinition;\n  placementGroup?: number;\n  stageSequence?: number;\n  structureId?: string;\n  roundTarget?: number;\n  stages?: string[];\n  stage?: string;\n};\n\nexport function getStageEntries({\n  provisionalPositioning,\n  placementGroup,\n  drawDefinition,\n  stageSequence,\n  entryStatuses,\n  structureId,\n  roundTarget,\n  stages,\n  stage,\n}: GetStageEntriesArgs) {\n  const entries =\n    drawDefinition.entries?.reduce((entries: any[], entry) => {\n      const entryRoundTarget = findExtension({\n        name: ROUND_TARGET,\n        element: entry,\n      })?.extension?.value;\n      const stageTarget =\n        (stage && entry.entryStage === stage) ||\n        (stages?.length && entry.entryStage && stages.includes(entry.entryStage));\n      const matchesEntryType = !entryStatuses || (entry.entryStatus && entryStatuses.includes(entry.entryStatus));\n      const entryStageSequence = entry.entryStageSequence ?? 1; // default to 1 if not present\n      const sameStageSequence = !stageSequence || entryStageSequence === stageSequence;\n      const targetMatch = !roundTarget || !entryRoundTarget || roundTarget === entryRoundTarget;\n\n      return stageTarget && sameStageSequence && matchesEntryType && targetMatch ? entries.concat(entry) : entries;\n    }, []) ?? [];\n\n  // handle POSITION entries\n  if (structureId && stage === PLAY_OFF) {\n    const { playoffEntries, error } = getPlayoffEntries({\n      provisionalPositioning,\n      drawDefinition,\n      structureId,\n    });\n    if (error) {\n      console.log('playoff entries error'); // TODO: bubble this up...\n    }\n    return (playoffEntries?.length ? playoffEntries : entries).filter(\n      (entry) => !placementGroup || entry.placementGroup === placementGroup,\n    );\n  }\n  return entries;\n}\n\ntype GetPlayoffEntriesArgs = {\n  provisionalPositioning?: boolean;\n  drawDefinition: DrawDefinition;\n  structureId: string;\n};\nfunction getPlayoffEntries({ provisionalPositioning, drawDefinition, structureId }: GetPlayoffEntriesArgs): {\n  playoffEntries?: any[];\n  error?: ErrorType;\n} {\n  const playoffEntries: any[] = [];\n  const inboundLink: DrawLink | undefined = (drawDefinition.links ?? []).find(\n    (link) => link.linkType === POSITION && link.target.structureId === structureId,\n  );\n  if (inboundLink) {\n    // links from round robins include an array of finishing positions\n    // which qualify participants to travel across a link to a playoff structure\n    const { finishingPositions, structureId } = inboundLink.source;\n\n    const { structure: sourceStructure } = findStructure({\n      drawDefinition,\n      structureId,\n    });\n\n    // for group participant results to be tallied,\n    // the source structure must be a container of other structures\n    if (sourceStructure?.structureType === CONTAINER) {\n      const playoffStructures = sourceStructure.structures ?? [];\n      playoffStructures.forEach((structure) => {\n        const positionAssignments = structure.positionAssignments ?? [];\n        const { structureId: playoffStructureId } = structure;\n        const groupingValue = playoffStructureId;\n\n        const results = Object.assign(\n          {},\n          ...positionAssignments\n            .map((assignment) => {\n              const { participantId } = assignment;\n              const results = findExtension({\n                element: assignment,\n                name: TALLY,\n              }).extension?.value;\n\n              return results && participantId ? { [participantId]: results } : undefined;\n            })\n            .filter(Boolean),\n        );\n\n        // TODO: ignore structures where finishingPositions are not unique\n        const uniqueFinishingPositions = Object.keys(results).reduce((unique: any, key) => {\n          const result = results[key];\n          const finishingPosition = result.groupOrder || (provisionalPositioning && result.provisionalOrder);\n          if (!unique.includes(finishingPosition)) {\n            unique.push(finishingPosition);\n          }\n          return unique;\n        }, []);\n\n        const finishingPositionsAreUnique = uniqueFinishingPositions.length === Object.keys(results).length;\n\n        const participantIds = Object.keys(results).filter((key) => {\n          const result = results[key];\n          const finishingPosition = result.groupOrder || (provisionalPositioning && result.provisionalOrder);\n          return finishingPositions?.includes(finishingPosition);\n        });\n\n        if (!provisionalPositioning || finishingPositionsAreUnique) {\n          participantIds.forEach((participantId) => {\n            const participantResult = results[participantId];\n            const { groupOrder, provisionalOrder, GEMscore } = participantResult;\n            const finishingPosition = groupOrder || (provisionalPositioning && provisionalOrder);\n\n            // spread to avoid immutable client data\n            const placementGroup = [...(finishingPositions ?? [])].sort(numericSort).indexOf(finishingPosition) + 1;\n\n            playoffEntries.push({\n              entryStage: PLAY_OFF,\n              entryStatus: FEED_IN,\n              placementGroup,\n              groupingValue,\n              participantId,\n              GEMscore,\n            });\n          });\n        }\n      });\n    }\n  }\n\n  return { playoffEntries };\n}\n\nexport function getStageDirectEntriesCount({ stage, drawDefinition }) {\n  return DIRECT_ENTRY_STATUSES.reduce((count, entryStatus) => {\n    const statusCount = getStageEntryTypeCount({\n      drawDefinition,\n      entryStatus,\n      stage,\n    });\n    return (statusCount || 0) + count;\n  }, 0);\n}\nexport function getStageWildcardEntriesCount({ stage, drawDefinition }) {\n  return getStageEntryTypeCount({\n    entryStatus: WILDCARD,\n    drawDefinition,\n    stage,\n  });\n}\nexport function stageAlternateEntries({ stage, drawDefinition }) {\n  return getStageEntryTypeCount({\n    entryStatus: ALTERNATE,\n    drawDefinition,\n    stage,\n  });\n}\n","import { getPositionAssignments } from '../drawDefinition/positionsGetter';\nimport { getStageEntries } from '../drawDefinition/stageGetter';\nimport { findStructure } from '../../acquire/findStructure';\n\nimport { PLAY_OFF } from '../../constants/drawDefinitionConstants';\nimport {\n  ErrorType,\n  MISSING_SEED_ASSIGNMENTS,\n  STRUCTURE_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  SeedAssignment,\n  StageTypeUnion,\n  Structure,\n} from '../../types/tournamentTypes';\n\ntype GetStructureSeedAssignmentsArgs = {\n  provisionalPositioning?: boolean;\n  drawDefinition?: DrawDefinition;\n  returnAllProxies?: boolean;\n  structure?: Structure;\n  structureId?: string;\n};\n\nexport function getStructureSeedAssignments({\n  provisionalPositioning,\n  returnAllProxies,\n  drawDefinition,\n  structureId,\n  structure,\n}: GetStructureSeedAssignmentsArgs): {\n  seedAssignments?: SeedAssignment[];\n  stageSequence?: number;\n  stage?: StageTypeUnion;\n  seedLimit?: number;\n  error?: ErrorType;\n} {\n  let error,\n    seedAssignments: SeedAssignment[] = [];\n\n  if (!structure) {\n    ({ structure, error } = findStructure({ drawDefinition, structureId }));\n  }\n\n  const positionAssignments = getPositionAssignments({\n    structure,\n  }).positionAssignments;\n\n  if (error || !structure)\n    return { seedAssignments: [], error: STRUCTURE_NOT_FOUND };\n\n  if (!structureId) structureId = structure.structureId;\n\n  const { stage, stageSequence } = structure;\n\n  const isPlayoffStructure = stage === PLAY_OFF;\n  const entries =\n    isPlayoffStructure &&\n    drawDefinition &&\n    getStageEntries({\n      provisionalPositioning,\n      drawDefinition,\n      stageSequence,\n      structureId,\n      stage,\n    });\n\n  const proxiedEntries = entries\n    ? entries\n        .filter((entry) => entry.placementGroup === 1)\n        .sort((a, b) => {\n          // GEMscore is used here because headToHead encounters are not relevant\n          // when the participants are derived from more than one RR group\n          return (\n            (a.GEMscore < b.GEMscore && 1) ||\n            (a.GEMscore > b.GEMscore && -1) ||\n            0\n          );\n        })\n        .map((entry, index) => {\n          const seedNumber = index + 1;\n          return {\n            participantId: entry.participantId,\n            seedValue: seedNumber,\n            seedProxy: true, // flag so that proxy seeding information doesn't get used externally\n            seedNumber,\n          };\n        })\n    : [];\n\n  const seedProxies = proxiedEntries?.slice(\n    0,\n    returnAllProxies ? proxiedEntries.length : positionAssignments.length / 2\n  );\n\n  if (seedProxies.length) {\n    // seedProxies are only found in PLAY_OFF when ROUND_ROBIN is MAIN stage\n    seedAssignments = seedProxies;\n  } else if (structure.seedAssignments) {\n    seedAssignments = structure.seedAssignments;\n  } else {\n    error = MISSING_SEED_ASSIGNMENTS;\n  }\n\n  const seedLimit =\n    structure.seedLimit ?? structure?.positionAssignments?.length;\n\n  return {\n    seedAssignments,\n    stageSequence,\n    seedLimit,\n    stage,\n    error,\n  };\n}\n","import {\n  COMPETITIVE,\n  DECISIVE,\n  ROUTINE,\n  WALKOVER,\n} from '../../constants/statsConstants';\n\nconst add = (a, b) => (a || 0) + (b || 0);\n\nexport function getBand(\n  spread: number | [number],\n  bandProfiles: { [key: string]: number }\n) {\n  const spreadValue = Array.isArray(spread) ? spread[0] : spread;\n  return (\n    (isNaN(spreadValue) && WALKOVER) ||\n    (spreadValue <= bandProfiles[DECISIVE] && DECISIVE) ||\n    (spreadValue <= bandProfiles[ROUTINE] && ROUTINE) ||\n    COMPETITIVE\n  );\n}\n\nexport function getScoreComponents({ score }) {\n  const sets = score?.sets || [];\n\n  const games = sets.reduce(\n    (p, c) => {\n      p[0] += c.side1Score || 0;\n      p[1] += c.side2Score || 0;\n      return p;\n    },\n    [0, 0]\n  );\n  const stb = sets.reduce(\n    (p, c) => {\n      p[0] += c.side1TiebreakScore || 0;\n      p[1] += c.side2TiebreakScore || 0;\n      return p;\n    },\n    [0, 0]\n  );\n\n  // add an extra game to the winner of tiebreak\n  if (stb.reduce(add)) {\n    games[stb[0] > stb[1] ? 0 : 1] += 1;\n  }\n\n  return { sets, games, score };\n}\n\nfunction gamesPercent(scoreComponents) {\n  const minGames = Math.min(...scoreComponents.games);\n  const maxGames = Math.max(...scoreComponents.games);\n  return Math.round((minGames / maxGames) * 100);\n}\n\nexport function pctSpread(pcts) {\n  return pcts\n    .map(gamesPercent)\n    .sort()\n    .map((p) => parseFloat(p.toFixed(2)));\n}\n","import { getAppliedPolicies } from '../query/extensions/getAppliedPolicies';\n\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORD,\n  POLICY_NOT_FOUND,\n} from '../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Structure,\n  Tournament,\n} from '../types/tournamentTypes';\n\ntype FindPolicyArgs = {\n  drawDefinition?: DrawDefinition;\n  tournamentRecord?: Tournament;\n  structure?: Structure;\n  policyType: string;\n  event?: Event;\n};\n\nexport function findPolicy({\n  tournamentRecord,\n  drawDefinition,\n  policyType,\n  structure,\n  event,\n}: FindPolicyArgs): { policy?: any; error?: ErrorType; info?: string } {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const { appliedPolicies } = getAppliedPolicies({\n    tournamentRecord,\n    drawDefinition,\n    structure,\n    event,\n  });\n\n  return appliedPolicies?.[policyType]\n    ? { policy: appliedPolicies[policyType] }\n    : { info: POLICY_NOT_FOUND?.message };\n}\n","import { getBand, getScoreComponents, pctSpread } from './scoreComponents';\nimport { findPolicy } from '../../acquire/findPolicy';\n\nimport POLICY_COMPETITIVE_BANDS_DEFAULT from '../../fixtures/policies/POLICY_COMPETITIVE_BANDS_DEFAULT';\nimport { POLICY_TYPE_COMPETITIVE_BANDS } from '../../constants/policyConstants';\nimport { MatchUp, Tournament } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ErrorType,\n  INVALID_VALUES,\n  MISSING_MATCHUP,\n} from '../../constants/errorConditionConstants';\n\ntype GetMatchUpCompetitivenessArgs = {\n  tournamentRecord?: Tournament;\n  profileBands?: any;\n  matchUp: MatchUp;\n};\n\nexport function getMatchUpCompetitiveProfile({\n  tournamentRecord,\n  profileBands,\n  matchUp,\n}: GetMatchUpCompetitivenessArgs): {\n  competitiveness?: any;\n  pctSpread?: number;\n  success?: boolean;\n  error?: ErrorType;\n} {\n  if (!matchUp) return { error: MISSING_MATCHUP };\n  const { score, winningSide } = matchUp;\n\n  if (!winningSide) return { error: INVALID_VALUES };\n\n  const policy =\n    !profileBands &&\n    tournamentRecord &&\n    findPolicy({\n      policyType: POLICY_TYPE_COMPETITIVE_BANDS,\n      tournamentRecord,\n    }).policy;\n\n  const bandProfiles =\n    profileBands ||\n    policy?.profileBands ||\n    POLICY_COMPETITIVE_BANDS_DEFAULT[POLICY_TYPE_COMPETITIVE_BANDS]\n      .profileBands;\n\n  const scoreComponents = getScoreComponents({ score });\n  const spread = pctSpread([scoreComponents]);\n  const competitiveness = getBand(spread, bandProfiles);\n  const pctSpreadValue = Array.isArray(spread) ? spread[0] : spread;\n\n  return { ...SUCCESS, competitiveness, pctSpread: pctSpreadValue };\n}\n","import { unique } from '../../utilities/arrays';\n\nimport { HydratedMatchUp, HydratedSide } from '../../types/hydrated';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { INDIVIDUAL } from '../../constants/participantConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_CONTEXT,\n  MISSING_MATCHUP,\n  INVALID_MATCHUP,\n} from '../../constants/errorConditionConstants';\n\n// Does NOT include potential participandIds\n\ntype GetMatchUpParticipantIdsArgs = {\n  matchUp: HydratedMatchUp;\n};\nexport function getMatchUpParticipantIds({\n  matchUp,\n}: GetMatchUpParticipantIdsArgs): ResultType & {\n  nestedIndividualParticipantIds?: string[][];\n  allRelevantParticipantIds?: string[];\n  individualParticipantIds?: string[];\n  sideParticipantIds?: string[];\n} {\n  if (!matchUp) return { error: MISSING_MATCHUP };\n  if (matchUp && !matchUp.sides) return { error: INVALID_MATCHUP };\n  if (matchUp && !matchUp.hasContext) return { error: MISSING_CONTEXT };\n\n  const sideParticipantIds: string[] = (matchUp.sides ?? [])\n    ?.map((side) => side?.participantId)\n    .filter(Boolean) as string[];\n\n  const sideIndividualParticipantIds =\n    matchUp.sides\n      ?.filter((side) => side.participant?.participantType === INDIVIDUAL)\n      .map((participant) => participant.participantId)\n      .filter(Boolean) ?? [];\n\n  const nestedIndividualParticipants =\n    ((matchUp.sides as HydratedSide[]) ?? [])\n      ?.map((side) => side.participant?.individualParticipants)\n      .filter(Boolean) ?? [];\n\n  const nestedIndividualParticipantIds = nestedIndividualParticipants.map(\n    (participants) =>\n      (participants ?? [])\n        .map((participant) => participant?.participantId)\n        .filter(Boolean)\n  );\n\n  const individualParticipantIds =\n    ([\n      ...sideIndividualParticipantIds,\n      ...nestedIndividualParticipantIds.flat(),\n    ].filter(Boolean) as string[]) ?? [];\n\n  const allRelevantParticipantIds: string[] =\n    unique(individualParticipantIds.concat(sideParticipantIds)).filter(\n      Boolean\n    ) ?? [];\n\n  return {\n    nestedIndividualParticipantIds,\n    allRelevantParticipantIds,\n    individualParticipantIds,\n    sideParticipantIds,\n    ...SUCCESS,\n  };\n}\n","export const CHECK_IN = 'CHECK_IN';\nexport const CHECK_OUT = 'CHECK_OUT';\n\nexport const SCHEDULE = 'SCHEDULE';\nexport const ASSIGN_VENUE = 'SCHEDULE.ASSIGNMENT.VENUE';\nexport const ALLOCATE_COURTS = 'SCHEDULE.ALLOCATION.COURTS';\nexport const ASSIGN_COURT = 'SCHEDULE.ASSIGNMENT.COURT';\nexport const COURT_ORDER = 'SCHEDULE.COURT.ORDER';\n\nexport const SCHEDULED_DATE = 'SCHEDULE.DATE';\nexport const COMPLETED_DATE = 'COMPLETED.DATE'; // considering adding this timeItem on completed score entry provided date is between tournament startDate/endDate\n\nexport const ASSIGN_OFFICIAL = 'SCHEDULE.ASSIGN.OFFICIAL';\nexport const SCHEDULED_TIME = 'SCHEDULE.TIME.SCHEDULED';\nexport const START_TIME = 'SCHEDULE.TIME.START';\nexport const STOP_TIME = 'SCHEDULE.TIME.STOP';\nexport const RESUME_TIME = 'SCHEDULE.TIME.RESUME';\nexport const END_TIME = 'SCHEDULE.TIME.END';\n\nexport const TIME_MODIFIERS = 'SCHEDULE.TIME.MODIFIERS';\nexport const TO_BE_ANNOUNCED = 'TO_BE_ANNOUNCED';\nexport const NEXT_AVAILABLE = 'NEXT_AVAILABLE';\nexport const FOLLOWED_BY = 'FOLLOWED_BY';\nexport const AFTER_REST = 'AFTER_REST';\nexport const RAIN_DELAY = 'RAIN_DELAY';\nexport const NOT_BEFORE = 'NOT_BEFORE';\n\nexport const MUTUALLY_EXCLUSIVE_TIME_MODIFIERS = [\n  TO_BE_ANNOUNCED,\n  NEXT_AVAILABLE,\n  FOLLOWED_BY,\n  AFTER_REST,\n  RAIN_DELAY,\n];\n\nexport const ELIGIBILITY = 'ELIGIBILITY';\nexport const REGISTRATION = 'REGISTRATION';\nexport const SUSPENSION = 'SUSPENSION';\nexport const MEDICAL = 'MEDICAL';\nexport const PENALTY = 'PENALTY';\n\nexport const SCALE = 'SCALE';\nexport const RATING = 'RATING'; // 'SCALE.RATING'\nexport const RANKING = 'RANKING'; // 'SCALE.RANKING'\nexport const SEEDING = 'SEEDING'; // 'SCALE.SEEDING'\n\nexport const PUBLISH = 'PUBLISH';\nexport const PUBLIC = 'PUBLIC';\nexport const STATUS = 'STATUS';\n\nexport const MODIFICATION = 'MODIFICATION';\nexport const RETRIEVAL = 'RETRIEVAL';\nexport const OTHER = 'other';\n\nexport const timeItemConstants = {\n  MUTUALLY_EXCLUSIVE_TIME_MODIFIERS,\n  AFTER_REST,\n  ALLOCATE_COURTS,\n  ASSIGN_COURT,\n  ASSIGN_OFFICIAL,\n  ASSIGN_VENUE,\n  CHECK_IN,\n  CHECK_OUT,\n  COMPLETED_DATE,\n  COURT_ORDER,\n  ELIGIBILITY,\n  END_TIME,\n  FOLLOWED_BY,\n  MEDICAL,\n  MODIFICATION,\n  NEXT_AVAILABLE,\n  NOT_BEFORE,\n  OTHER,\n  PENALTY,\n  PUBLIC,\n  PUBLISH,\n  RANKING,\n  RATING,\n  RAIN_DELAY,\n  REGISTRATION,\n  RESUME_TIME,\n  RETRIEVAL,\n  SCALE,\n  SCHEDULE,\n  SCHEDULED_DATE,\n  SCHEDULED_TIME,\n  SEEDING,\n  START_TIME,\n  STATUS,\n  STOP_TIME,\n  SUSPENSION,\n  TIME_MODIFIERS,\n  TO_BE_ANNOUNCED,\n};\n","import { getMatchUpParticipantIds } from './getMatchUpParticipantIds';\n\nimport { CHECK_IN, CHECK_OUT } from '../../constants/timeItemConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport { TimeItem } from '../../types/tournamentTypes';\nimport {\n  INVALID_MATCHUP,\n  MISSING_CONTEXT,\n  MISSING_MATCHUP,\n} from '../../constants/errorConditionConstants';\n\n/*\n  takes a matchUpWithContext\n  returns all participaantIds which have current checkedIn status\n    - if sideParticipant is participantType TEAM or PAIR then\n      sideParticipant is considered checkedIn if all individualParticipants are checkedIn\n    - if sideParticipant is participantType TEAM or PAIR and is checkedIn then\n      all individualParticipants are considered checkedIn\n*/\nexport function getCheckedInParticipantIds({\n  matchUp,\n}: {\n  matchUp: HydratedMatchUp;\n}): ResultType & {\n  allRelevantParticipantIds?: string[];\n  allParticipantsCheckedIn?: boolean;\n  checkedInParticipantIds?: string[];\n} {\n  if (!matchUp) return { error: MISSING_MATCHUP };\n  if (!matchUp.hasContext) {\n    return { error: MISSING_CONTEXT };\n  }\n\n  if (!matchUp.sides || matchUp.sides.filter(Boolean).length !== 2) {\n    return { error: INVALID_MATCHUP };\n  }\n\n  const {\n    nestedIndividualParticipantIds,\n    allRelevantParticipantIds,\n    sideParticipantIds,\n  } = getMatchUpParticipantIds({ matchUp });\n\n  const timeItems = matchUp.timeItems ?? [];\n  const checkInItems: TimeItem[] = timeItems\n    .filter(\n      (timeItem) =>\n        timeItem?.itemType && [CHECK_IN, CHECK_OUT].includes(timeItem.itemType)\n    )\n    .sort(\n      (a, b) =>\n        (a.createdAt ? new Date(a.createdAt).getTime() : 0) -\n        (b.createdAt ? new Date(b.createdAt).getTime() : 0)\n    );\n  const timeItemParticipantIds = checkInItems.map(\n    (timeItem) => timeItem.itemValue\n  );\n\n  // first determine whether each timeItemParticipantId is checkedIn\n  const checkedInParticipantIds = timeItemParticipantIds.filter(\n    (participantId) => {\n      return (\n        checkInItems\n          .filter((timeItem) => timeItem?.itemValue === participantId)\n          .reverse()[0].itemType === CHECK_IN\n      );\n    }\n  );\n\n  // if all individuals on one side are checked in then side is checked in\n  nestedIndividualParticipantIds?.forEach(\n    (sideIndividualParticipantIds, sideIndex) => {\n      const sideParticipantId = sideParticipantIds?.[sideIndex];\n      const allIndividualsCheckedIn =\n        sideIndividualParticipantIds?.length &&\n        sideIndividualParticipantIds.every((participantId) =>\n          checkedInParticipantIds.includes(participantId)\n        );\n\n      if (\n        sideParticipantId &&\n        allIndividualsCheckedIn &&\n        !checkedInParticipantIds.includes(sideParticipantId)\n      ) {\n        checkedInParticipantIds.push(sideParticipantId);\n      }\n    }\n  );\n\n  // if side is checked in then all individuals on that side are checked in\n  sideParticipantIds?.forEach((sideParticipantId: string, sideIndex) => {\n    if (checkedInParticipantIds.includes(sideParticipantId)) {\n      (nestedIndividualParticipantIds?.[sideIndex] ?? []).forEach(\n        (participantId) => {\n          if (\n            participantId &&\n            !checkedInParticipantIds.includes(participantId)\n          ) {\n            checkedInParticipantIds.push(participantId);\n          }\n        }\n      );\n    }\n  });\n\n  const allParticipantsCheckedIn = sideParticipantIds?.reduce(\n    (checkedIn, participantId) => {\n      return checkedInParticipantIds.includes(participantId) && checkedIn;\n    },\n    true\n  );\n\n  return {\n    allRelevantParticipantIds,\n    allParticipantsCheckedIn,\n    checkedInParticipantIds,\n    ...SUCCESS,\n  };\n}\n","export function findMatchupFormatAverageTimes(params) {\n  const { matchUpAverageTimes, matchUpFormat } = params || {};\n  // first find all matchUpAverageTime definitions which include matchUpFormats...\n  // ... that either exactly match or start with the target matchUpFormat.\n  const codeMatches =\n    matchUpAverageTimes\n      ?.map(({ matchUpFormatCodes }) => {\n        return matchUpFormatCodes?.filter((code) => code === matchUpFormat);\n      })\n      .flat()\n      .filter(Boolean)\n      // sort by length; shortest first; prioritize first match\n      .sort((a, b) => (a?.length || 0) - (b?.length || 0)) || [];\n\n  // determine if there is an exact match\n  const exactCodeMatch = codeMatches.includes(matchUpFormat);\n  // select the exact match or the shortest code which matches\n  const targetCode = exactCodeMatch ? matchUpFormat : codeMatches[0];\n  const targetDefinition = matchUpAverageTimes?.find(\n    ({ matchUpFormatCodes, averageTimes }) =>\n      matchUpFormatCodes?.find((code) => targetCode === code) && averageTimes\n  );\n  return targetDefinition?.averageTimes;\n}\n\nexport function findMatchupFormatRecoveryTimes(params) {\n  const { matchUpRecoveryTimes, averageMinutes, matchUpFormat } = params || {};\n  return matchUpRecoveryTimes?.find(\n    ({ matchUpFormatCodes, averageTimes, recoveryTimes }) => {\n      if (averageTimes && averageMinutes) {\n        const { greaterThan = 0, lessThan = 360 } = averageTimes;\n        if (averageMinutes > greaterThan && averageMinutes < lessThan)\n          return true;\n      }\n      return (\n        matchUpFormatCodes?.find((code) => code === matchUpFormat) &&\n        recoveryTimes\n      );\n    }\n  )?.recoveryTimes;\n}\n","export function findCategoryTiming({\n  timesBlockArray,\n  categoryName,\n  categoryType,\n}) {\n  return timesBlockArray\n    .filter((f) => Array.isArray(f))\n    .map((times) =>\n      times\n        .sort(\n          (a, b) =>\n            (b.categoryNames?.length || 0) - (a.categoryNames?.length || 0)\n        )\n        .find(\n          ({ categoryTypes, categoryNames }) =>\n            (!categoryNames?.length && !categoryTypes?.length) ||\n            categoryNames?.includes(categoryName) ||\n            categoryTypes?.includes(categoryType)\n        )\n    )\n    .find(Boolean);\n}\n","import { findExtension } from '../../../acquire/findExtension';\nimport { findPolicy } from '../../../acquire/findPolicy';\n\nimport { POLICY_TYPE_SCHEDULING } from '../../../constants/policyConstants';\nimport { SCHEDULE_TIMING } from '../../../constants/extensionConstants';\nimport { Event, Tournament } from '../../../types/tournamentTypes';\n\ntype GetScheduleTimingArgs = {\n  tournamentRecord?: Tournament;\n  categoryName?: string;\n  categoryType?: string;\n  event?: Event;\n};\nexport function getScheduleTiming({\n  tournamentRecord,\n  categoryName,\n  categoryType,\n  event,\n}: GetScheduleTimingArgs) {\n  categoryName =\n    categoryName ??\n    event?.category?.categoryName ??\n    event?.category?.ageCategoryCode;\n\n  categoryType =\n    categoryType ?? event?.category?.categoryType ?? event?.category?.subType;\n\n  const { policy } = findPolicy({\n    policyType: POLICY_TYPE_SCHEDULING,\n    tournamentRecord,\n    event,\n  });\n\n  const tournamentExtension = tournamentRecord\n    ? findExtension({\n        element: tournamentRecord,\n        name: SCHEDULE_TIMING,\n      }).extension\n    : undefined;\n  const tournamentScheduling = tournamentExtension?.value;\n\n  const eventExtension =\n    event &&\n    findExtension({\n      name: SCHEDULE_TIMING,\n      element: event,\n    }).extension;\n  const eventScheduling = eventExtension?.value;\n\n  const scheduleTiming = {\n    tournamentScheduling,\n    eventScheduling,\n    categoryName,\n    categoryType,\n    policy,\n  };\n\n  return { scheduleTiming };\n}\n","export const SINGLES = 'SINGLES';\nexport const SINGLES_EVENT = 'SINGLES';\nexport const DOUBLES = 'DOUBLES';\nexport const DOUBLES_EVENT = 'DOUBLES';\nexport const TEAM = 'TEAM';\nexport const TEAM_EVENT = 'TEAM';\nexport const AGE = 'AGE';\nexport const RATING = 'RATING';\nexport const BOTH = 'BOTH';\n\nexport const eventConstants = {\n  AGE,\n  BOTH,\n  DOUBLES,\n  DOUBLES_EVENT,\n  RATING,\n  SINGLES,\n  SINGLES_EVENT,\n  TEAM_EVENT,\n  TEAM,\n};\n","export const DOUBLES_SINGLES = 'DOUBLES_SINGLES';\nexport const SINGLES_DOUBLES = 'SINGLES_DOUBLES';\nexport const TOTAL = 'total';\n\nexport const CONFLICT_PARTICIPANTS = 'participantConflict';\nexport const CONFLICT_MATCHUP_ORDER = 'matchUpConflict';\nexport const SCHEDULE_ISSUE_IDS = 'ISSUE_IDS';\nexport const SCHEDULE_CONFLICT = 'CONFLICT';\nexport const SCHEDULE_WARNING = 'WARNING';\nexport const SCHEDULE_ERROR = 'ERROR';\nexport const SCHEDULE_ISSUE = 'ISSUE';\nexport const SCHEDULE_STATE = 'STATE';\n\nexport const scheduleConstants = {\n  SINGLES_DOUBLES,\n  DOUBLES_SINGLES,\n  TOTAL,\n\n  CONFLICT_MATCHUP_ORDER,\n  CONFLICT_PARTICIPANTS,\n  SCHEDULE_ISSUE_IDS,\n  SCHEDULE_CONFLICT,\n  SCHEDULE_WARNING,\n  SCHEDULE_ERROR,\n  SCHEDULE_ISSUE,\n  SCHEDULE_STATE,\n};\n","import { getMatchUpFormatRecoveryTimes } from './getMatchUpFormatRecoveryTimes';\nimport { getMatchUpFormatAverageTimes } from './getMatchUpFormatAverageTimes';\nimport { getScheduleTiming } from './getScheduleTiming';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../../constants/errorConditionConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { SINGLES_EVENT } from '../../../constants/eventConstants';\nimport {\n  DOUBLES_SINGLES,\n  SINGLES_DOUBLES,\n} from '../../../constants/scheduleConstants';\nimport {\n  Event,\n  Tournament,\n  EventTypeUnion,\n} from '../../../types/tournamentTypes';\n\ntype GetMatchUpFormatTimingArgs = {\n  defaultRecoveryMinutes?: number;\n  defaultAverageMinutes?: number;\n  tournamentRecord: Tournament;\n  matchUpFormat: string;\n  categoryName?: string;\n  categoryType?: string;\n  eventType?: EventTypeUnion;\n  event?: Event;\n};\n\nexport function getMatchUpFormatTiming({\n  defaultAverageMinutes = 90,\n  defaultRecoveryMinutes = 0,\n  tournamentRecord,\n  matchUpFormat,\n  categoryName,\n  categoryType,\n  eventType,\n  event,\n}: GetMatchUpFormatTimingArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  // event is optional, so eventType can also be passed in directly\n  eventType = eventType ?? event?.eventType ?? SINGLES_EVENT;\n  const defaultTiming = {\n    averageTimes: [{ minutes: { default: defaultAverageMinutes } }],\n    recoveryTimes: [{ minutes: { default: defaultRecoveryMinutes } }],\n  };\n\n  const { scheduleTiming } = getScheduleTiming({\n    tournamentRecord,\n    categoryName,\n    categoryType,\n    event,\n  });\n\n  const timingDetails = {\n    ...scheduleTiming,\n    matchUpFormat,\n    categoryType,\n    defaultTiming,\n  };\n\n  return matchUpFormatTimes({ eventType, timingDetails });\n}\n\ntype MatchUpFormatTimesArgs = {\n  eventType: EventTypeUnion;\n  timingDetails: any;\n};\nexport function matchUpFormatTimes({\n  timingDetails,\n  eventType,\n}: MatchUpFormatTimesArgs): ResultType & {\n  typeChangeRecoveryMinutes?: number;\n  recoveryMinutes?: number;\n  averageMinutes?: number;\n} {\n  const averageTimes = getMatchUpFormatAverageTimes(timingDetails);\n  const averageKeys = Object.keys(averageTimes?.minutes || {});\n\n  const averageMinutes =\n    averageTimes?.minutes &&\n    ((averageKeys?.includes(eventType) && averageTimes.minutes[eventType]) ||\n      averageTimes.minutes.default);\n\n  const recoveryTimes = getMatchUpFormatRecoveryTimes({\n    ...timingDetails,\n    averageMinutes,\n  });\n\n  const recoveryKeys = Object.keys(recoveryTimes?.minutes || {});\n  const recoveryMinutes =\n    recoveryTimes?.minutes &&\n    ((recoveryKeys?.includes(eventType) && recoveryTimes.minutes[eventType]) ||\n      recoveryTimes.minutes.default);\n\n  const formatChangeKey =\n    eventType === SINGLES_EVENT ? SINGLES_DOUBLES : DOUBLES_SINGLES;\n\n  const typeChangeRecoveryMinutes =\n    recoveryTimes?.minutes &&\n    ((recoveryKeys?.includes(formatChangeKey) &&\n      recoveryTimes.minutes[formatChangeKey]) ||\n      recoveryMinutes);\n\n  return { averageMinutes, recoveryMinutes, typeChangeRecoveryMinutes };\n}\n","import { findMatchupFormatAverageTimes } from '../../../acquire/findMatchUpFormatTimes';\nimport { findCategoryTiming } from '../../../acquire/findCategoryTiming';\n\nexport function getMatchUpFormatAverageTimes({\n  matchUpFormat,\n  categoryName,\n  categoryType,\n\n  defaultTiming,\n  tournamentScheduling,\n  eventScheduling,\n  policy,\n}) {\n  const eventAverageTimes =\n    eventScheduling?.matchUpAverageTimes &&\n    findMatchupFormatAverageTimes({\n      ...eventScheduling,\n      matchUpFormat,\n    });\n\n  const tournamentAverageTimes =\n    tournamentScheduling?.matchUpAverageTimes &&\n    findMatchupFormatAverageTimes({\n      ...tournamentScheduling,\n      matchUpFormat,\n    });\n\n  const policyAverageTimes =\n    policy?.matchUpAverageTimes &&\n    findMatchupFormatAverageTimes({\n      ...policy,\n      matchUpFormat,\n    });\n\n  const timesBlockArray = [\n    eventAverageTimes,\n    tournamentAverageTimes,\n    policyAverageTimes,\n    policy?.defaultTimes?.averageTimes,\n    defaultTiming?.averageTimes,\n  ];\n\n  return findCategoryTiming({\n    categoryName,\n    categoryType,\n    timesBlockArray,\n  });\n}\n","import { findMatchupFormatRecoveryTimes } from '../../../acquire/findMatchUpFormatTimes';\nimport { findCategoryTiming } from '../../../acquire/findCategoryTiming';\n\nexport function getMatchUpFormatRecoveryTimes({\n  tournamentScheduling,\n  eventScheduling,\n  averageMinutes,\n  defaultTiming,\n  matchUpFormat,\n  categoryName,\n  categoryType,\n  policy,\n}) {\n  const eventRecoveryTimes =\n    eventScheduling?.matchUpRecoveryTimes &&\n    findMatchupFormatRecoveryTimes({\n      ...eventScheduling,\n      averageMinutes,\n      matchUpFormat,\n    });\n\n  const tournamentRecoveryTimes =\n    tournamentScheduling?.matchUpRecoveryTimes &&\n    findMatchupFormatRecoveryTimes({\n      ...tournamentScheduling,\n      averageMinutes,\n      matchUpFormat,\n    });\n\n  const policyRecoveryTimes =\n    policy?.matchUpRecoveryTimes &&\n    findMatchupFormatRecoveryTimes({\n      ...policy,\n      averageMinutes,\n      matchUpFormat,\n    });\n\n  const timesBlockArray = [\n    eventRecoveryTimes,\n    tournamentRecoveryTimes,\n    policyRecoveryTimes,\n    policy?.defaultTimes?.recoveryTimes,\n    defaultTiming?.recoveryTimes,\n  ];\n\n  return findCategoryTiming({\n    categoryName,\n    categoryType,\n    timesBlockArray,\n  });\n}\n","import { SCHEDULE } from '../../constants/timeItemConstants';\nimport { TimeItem } from '../../types/tournamentTypes';\n\nfunction getTimeStamp(item) {\n  return !item.createdAt ? 0 : new Date(item.createdAt).getTime();\n}\n\ntype LastVisibleTimeItemValueArgs = {\n  visibilityThreshold?: string;\n  timeItems: TimeItem[];\n  itemType: string;\n};\nexport function latestVisibleTimeItemValue({\n  visibilityThreshold,\n  timeItems,\n  itemType,\n}: LastVisibleTimeItemValueArgs) {\n  // TODO: should visibilityThreshold be combination of scheduled date/time\n\n  const latestVisible = timeItems\n    .filter(\n      (timeItem) =>\n        timeItem &&\n        timeItem.itemType === itemType &&\n        (!visibilityThreshold ||\n          getTimeStamp(timeItem) < new Date(visibilityThreshold).getTime())\n    )\n    .sort((a, b) => getTimeStamp(a) - getTimeStamp(b))\n    .pop();\n\n  const timeStamp = latestVisible && getTimeStamp(latestVisible);\n\n  return { itemValue: latestVisible?.itemValue, timeStamp };\n}\n\nexport function lastVisibleSchedule(timeItems, visibilityThreshold) {\n  const item = timeItems\n    .filter(\n      (timeItem) =>\n        timeItem &&\n        timeItem.itemType === SCHEDULE &&\n        (!visibilityThreshold || getTimeStamp(timeItem) < visibilityThreshold)\n    )\n    .sort((a, b) => getTimeStamp(a) - getTimeStamp(b))\n    .pop();\n\n  const timeStamp = item && getTimeStamp(item);\n\n  return { schedule: item?.value, timeStamp };\n}\n","import { latestVisibleTimeItemValue } from './latestVisibleTimeItemValue';\n\nimport { SCHEDULED_TIME } from '../../constants/timeItemConstants';\nimport { ScheduledMatchUpArgs } from './scheduledMatchUpArgs';\n\nexport function scheduledMatchUpTime({\n  visibilityThreshold,\n  timeStamp,\n  schedule,\n  matchUp,\n}: ScheduledMatchUpArgs) {\n  const { itemValue: scheduledTime, timeStamp: itemTimeStamp } =\n    latestVisibleTimeItemValue({\n      timeItems: matchUp?.timeItems || [],\n      itemType: SCHEDULED_TIME,\n      visibilityThreshold,\n    });\n\n  return !schedule ||\n    (itemTimeStamp &&\n      timeStamp &&\n      new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())\n    ? { scheduledTime }\n    : schedule;\n}\n","import { latestVisibleTimeItemValue } from './latestVisibleTimeItemValue';\n\nimport { SCHEDULED_DATE } from '../../constants/timeItemConstants';\nimport { ScheduledMatchUpArgs } from './scheduledMatchUpArgs';\n\nexport function scheduledMatchUpDate({\n  visibilityThreshold,\n  timeStamp,\n  schedule,\n  matchUp,\n}: ScheduledMatchUpArgs) {\n  const { itemValue: scheduledDate, timeStamp: itemTimeStamp } =\n    latestVisibleTimeItemValue({\n      timeItems: matchUp?.timeItems || [],\n      itemType: SCHEDULED_DATE,\n      visibilityThreshold,\n    });\n\n  return !schedule ||\n    (itemTimeStamp &&\n      timeStamp &&\n      new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())\n    ? { scheduledDate }\n    : schedule;\n}\n","import { latestVisibleTimeItemValue } from './latestVisibleTimeItemValue';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\n\nimport { ALLOCATE_COURTS } from '../../constants/timeItemConstants';\nimport { ScheduledMatchUpArgs } from './scheduledMatchUpArgs';\n\nexport function matchUpAllocatedCourts({\n  visibilityThreshold,\n  timeStamp,\n  schedule,\n  matchUp,\n}: ScheduledMatchUpArgs) {\n  const { itemValue: allocatedCourts, timeStamp: itemTimeStamp } =\n    latestVisibleTimeItemValue({\n      timeItems: matchUp?.timeItems || [],\n      itemType: ALLOCATE_COURTS,\n      visibilityThreshold,\n    });\n\n  return !schedule ||\n    (itemTimeStamp &&\n      timeStamp &&\n      new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())\n    ? { allocatedCourts: makeDeepCopy(allocatedCourts, false, true) }\n    : schedule;\n}\n","import { latestVisibleTimeItemValue } from './latestVisibleTimeItemValue';\n\nimport { ASSIGN_COURT } from '../../constants/timeItemConstants';\nimport { ScheduledMatchUpArgs } from './scheduledMatchUpArgs';\n\nexport function matchUpAssignedCourtId({\n  visibilityThreshold,\n  timeStamp,\n  schedule,\n  matchUp,\n}: ScheduledMatchUpArgs) {\n  const { itemValue: courtId, timeStamp: itemTimeStamp } =\n    latestVisibleTimeItemValue({\n      timeItems: matchUp?.timeItems || [],\n      itemType: ASSIGN_COURT,\n      visibilityThreshold,\n    });\n\n  return !schedule ||\n    (itemTimeStamp &&\n      timeStamp &&\n      new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())\n    ? { courtId }\n    : schedule;\n}\n","import { latestVisibleTimeItemValue } from './latestVisibleTimeItemValue';\n\nimport { ASSIGN_VENUE } from '../../constants/timeItemConstants';\n\nexport function matchUpAssignedVenueId({\n  visibilityThreshold,\n  timeStamp,\n  schedule,\n  matchUp,\n}: import('./scheduledMatchUpArgs').ScheduledMatchUpArgs) {\n  const { itemValue: venueId, timeStamp: itemTimeStamp } =\n    latestVisibleTimeItemValue({\n      timeItems: matchUp?.timeItems || [],\n      itemType: ASSIGN_VENUE,\n      visibilityThreshold,\n    });\n\n  return !schedule ||\n    (itemTimeStamp &&\n      timeStamp &&\n      new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())\n    ? { venueId }\n    : schedule;\n}\n","import { findExtension } from '../../acquire/findExtension';\n\nimport { MISSING_TOURNAMENT_RECORDS } from '../../constants/errorConditionConstants';\nimport { LINKED_TOURNAMENTS } from '../../constants/extensionConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { TournamentRecords } from '../../types/factoryTypes';\n\nexport function getLinkedTournamentIds({\n  tournamentRecords,\n}: {\n  tournamentRecords: TournamentRecords;\n}): ResultType & { linkedTournamentIds?: string[] } {\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const linkedTournamentIds = Object.assign(\n    {},\n    ...Object.keys(tournamentRecords).map((tournamentId) => {\n      const tournamentRecord = tournamentRecords[tournamentId];\n      const touranmentId = tournamentRecord?.tournamentId;\n\n      const { extension } = findExtension({\n        element: tournamentRecord,\n        name: LINKED_TOURNAMENTS,\n      });\n\n      const tournamentIds = (extension?.value?.tournamentIds || []).filter(\n        (currentTournamentId) => currentTournamentId !== touranmentId\n      );\n\n      return { [tournamentId]: tournamentIds };\n    })\n  );\n\n  return { linkedTournamentIds };\n}\n","import { TournamentRecords } from '../types/factoryTypes';\n\nexport function resolveTournamentRecords(params?): TournamentRecords {\n  return (\n    params?.tournamentRecords ??\n    (params?.tournamentRecord && {\n      [params.tournamentRecord.tournamentId]: params.tournamentRecord,\n    }) ??\n    {}\n  );\n}\n","/*\n  based on an answer provided by Jeff Ward on StackOverflow; November 2019\n  https://stackoverflow.com/users/1026023/jeff-ward\n  https://stackoverflow.com/questions/105034/how-to-create-guid-uuid?rq=1\n*/\n\nimport { generateRange } from './arrays';\n\n/**\n * generate a given number of UUIDs\n *\n * @param {number} count - number of UUIDs to generate\n */\nexport function UUIDS(count = 1) {\n  return generateRange(0, count).map(UUID);\n}\n\nexport function UUID() {\n  const lut: string[] = [];\n\n  for (let i = 0; i < 256; i++) {\n    lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n  }\n\n  const d0 = (Math.random() * 0xffffffff) | 0;\n  const d1 = (Math.random() * 0xffffffff) | 0;\n  const d2 = (Math.random() * 0xffffffff) | 0;\n  const d3 = (Math.random() * 0xffffffff) | 0;\n  // eslint-disable-next-line no-mixed-operators\n  return (\n    lut[d0 & 0xff] +\n    lut[(d0 >> 8) & 0xff] +\n    lut[(d0 >> 16) & 0xff] +\n    lut[(d0 >> 24) & 0xff] +\n    '-' +\n    // eslint-disable-next-line no-mixed-operators\n    lut[d1 & 0xff] +\n    lut[(d1 >> 8) & 0xff] +\n    '-' +\n    lut[((d1 >> 16) & 0x0f) | 0x40] +\n    lut[(d1 >> 24) & 0xff] +\n    '-' +\n    // eslint-disable-next-line no-mixed-operators\n    lut[(d2 & 0x3f) | 0x80] +\n    lut[(d2 >> 8) & 0xff] +\n    '-' +\n    lut[(d2 >> 16) & 0xff] +\n    lut[(d2 >> 24) & 0xff] +\n    // eslint-disable-next-line no-mixed-operators\n    lut[d3 & 0xff] +\n    lut[(d3 >> 8) & 0xff] +\n    lut[(d3 >> 16) & 0xff] +\n    lut[(d3 >> 24) & 0xff]\n  );\n}\n\n/**\n * UUID prepended with 'u_' which is safe for html attribute ids\n */\nexport function safeUUID() {\n  return `u_${UUID()}`;\n}\n","export const ADD_DRAW_DEFINITION = 'addDrawDefinition';\nexport const ADD_MATCHUPS = 'addMatchUps';\nexport const ADD_PARTICIPANTS = 'addParticipants';\nexport const ADD_SCALE_ITEMS = 'addScaleItems';\nexport const ADD_VENUE = 'addVenue';\nexport const AUDIT = 'audit';\nexport const DELETE_PARTICIPANTS = 'deleteParticipants';\nexport const DELETE_VENUE = 'deleteVenue';\nexport const DELETED_DRAW_IDS = 'deletedDrawIds';\nexport const DELETED_MATCHUP_IDS = 'deletedMatchUpIds';\nexport const MODIFY_DRAW_DEFINITION = 'modifyDrawDefinition';\nexport const MODIFY_DRAW_ENTRIES = 'modifyDrawEntries';\nexport const MODIFY_EVENT_ENTRIES = 'modifyEventEntries';\nexport const MODIFY_MATCHUP = 'modifyMatchUp';\nexport const MODIFY_PARTICIPANTS = 'modifyParticipants';\nexport const MODIFY_POSITION_ASSIGNMENTS = 'modifyPositionAssignments';\nexport const MODIFY_SEED_ASSIGNMENTS = 'modifySeedAssignments';\nexport const MODIFY_TOURNAMENT_DETAIL = 'modifyTournamentDetail';\nexport const MODIFY_VENUE = 'modifyVenue';\nexport const MUTATIONS = 'mutations';\nexport const PUBLISH_EVENT = 'publishEvent';\nexport const PUBLISH_EVENT_SEEDING = 'publishEventSeeding';\nexport const PUBLISH_ORDER_OF_PLAY = 'publishOrderOfPlay';\nexport const UNPUBLISH_EVENT = 'unPublishEvent';\nexport const UNPUBLISH_EVENT_SEEDING = 'unPublishEventSeeding';\nexport const UNPUBLISH_ORDER_OF_PLAY = 'unPublishOrderOfPlay';\nexport const UPDATE_INCONTEXT_MATCHUP = 'updateInContextMatchUp';\n\nexport const topicConstants = {\n  ADD_DRAW_DEFINITION,\n  ADD_MATCHUPS,\n  ADD_PARTICIPANTS,\n  ADD_SCALE_ITEMS,\n  ADD_VENUE,\n  AUDIT,\n  DELETE_PARTICIPANTS,\n  DELETE_VENUE,\n  DELETED_DRAW_IDS,\n  DELETED_MATCHUP_IDS,\n  MODIFY_DRAW_DEFINITION,\n  MODIFY_DRAW_ENTRIES, // TODO\n  MODIFY_EVENT_ENTRIES, // TODO\n  MODIFY_MATCHUP,\n  MODIFY_PARTICIPANTS,\n  MODIFY_POSITION_ASSIGNMENTS,\n  MODIFY_SEED_ASSIGNMENTS,\n  MODIFY_TOURNAMENT_DETAIL,\n  MODIFY_VENUE,\n  MUTATIONS,\n  PUBLISH_EVENT_SEEDING,\n  PUBLISH_EVENT,\n  PUBLISH_ORDER_OF_PLAY,\n  UNPUBLISH_EVENT_SEEDING,\n  UNPUBLISH_EVENT,\n  UNPUBLISH_ORDER_OF_PLAY,\n  UPDATE_INCONTEXT_MATCHUP,\n};\n","import { resolveTournamentRecords } from '../../parameters/resolveTournamentRecords';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { addNotice } from '../../global/state/globalState';\nimport { addExtension } from '../extensions/addExtension';\nimport { UUID } from '../../utilities/UUID';\n\nimport { CONTEXT } from '../../constants/extensionConstants';\nimport { ADD_VENUE } from '../../constants/topicConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { Venue } from '../../types/tournamentTypes';\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n  VENUE_EXISTS,\n  INVALID_VALUES,\n} from '../../constants/errorConditionConstants';\n\nexport function addVenue(params) {\n  const { disableNotice, venue, context } = params;\n  if (typeof venue !== 'object') return { error: INVALID_VALUES };\n  const tournamentRecords = resolveTournamentRecords(params);\n  if (!venue.venueId) venue.venueId = UUID();\n\n  let addedVenue;\n\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const result = venueAdd({\n      disableNotice: true,\n      tournamentRecord,\n      context,\n      venue,\n    });\n    if (result?.error) return result;\n    addedVenue = result.venue;\n  }\n\n  if (!disableNotice) {\n    addNotice({ topic: ADD_VENUE, payload: { venue } });\n  }\n\n  return definedAttributes({ ...SUCCESS, venue: addedVenue });\n}\n\ntype AddVenueArgs = {\n  context?: { [key: string]: any };\n  disableNotice?: boolean;\n  tournamentRecord: any;\n  venue: Venue;\n};\n\nfunction venueAdd({\n  tournamentRecord,\n  disableNotice,\n  context,\n  venue,\n}: AddVenueArgs): {\n  success?: boolean;\n  error?: ErrorType;\n  venue?: Venue;\n  info?: string;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!venue) return { error: MISSING_VALUE, info: 'missing venue' };\n\n  if (!tournamentRecord.venues) tournamentRecord.venues = [];\n  if (!venue.venueId) venue.venueId = UUID();\n\n  const venueExists = tournamentRecord.venues.reduce(\n    (exists: any, existingVenue) => {\n      return exists || existingVenue.venueId === venue.venueId;\n    },\n    undefined\n  );\n\n  if (!venueExists) {\n    if (context) {\n      const extension = {\n        value: context,\n        name: CONTEXT,\n      };\n      addExtension({ element: venue, extension });\n    }\n\n    tournamentRecord.venues.push(venue);\n\n    if (!disableNotice) {\n      addNotice({\n        payload: { venue, tournamentId: tournamentRecord.tournamentId },\n        topic: ADD_VENUE,\n      });\n    }\n\n    return { ...SUCCESS, venue: makeDeepCopy(venue) };\n  } else {\n    return { error: VENUE_EXISTS };\n  }\n}\n","import { getLinkedTournamentIds } from '../../query/tournaments/getLinkedTournamentIds';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { addVenue } from './addVenue';\n\nimport { Tournament, Venue } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VENUE_ID,\n  VENUE_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\ntype FindVenueArgs = {\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  venueId: string;\n};\n\nexport function findVenue({\n  tournamentRecords,\n  tournamentRecord,\n  venueId,\n}: FindVenueArgs): { success?: boolean; venue?: Venue; error?: ErrorType } {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!venueId) return { error: MISSING_VENUE_ID };\n\n  const venues = tournamentRecord.venues ?? [];\n  const venue = venues.reduce((venue: any, venueRecord) => {\n    return venueRecord.venueId === venueId ? venueRecord : venue;\n  }, undefined);\n\n  if (!venue && tournamentRecords) {\n    const linkedTournamentIds =\n      getLinkedTournamentIds({\n        tournamentRecords,\n      }).linkedTournamentIds ?? [];\n\n    const relevantIds = linkedTournamentIds[tournamentRecord.tournamentId];\n\n    // if there are linked tournaments search for court in all linked tournaments\n    for (const tournamentId of relevantIds) {\n      const record = tournamentRecords[tournamentId];\n      const result = findVenue({ tournamentRecord: record, venueId });\n      // if venue is found in linked tournamentRecords, add venue to original tournamentRecord\n      if (result.success && result.venue) {\n        addVenue({ tournamentRecord, venue: result.venue });\n        return { ...SUCCESS, venue };\n      }\n    }\n  }\n\n  if (!venue) {\n    return { error: VENUE_NOT_FOUND };\n  } else {\n    return { ...SUCCESS, venue };\n  }\n}\n\nexport function publicFindVenue({ convertExtensions, ...params }) {\n  const { tournamentRecords, tournamentRecord, venueId } = params;\n  const result = findVenue({ tournamentRecords, tournamentRecord, venueId });\n  return makeDeepCopy(result, convertExtensions, true);\n}\n","import { getLinkedTournamentIds } from '../../query/tournaments/getLinkedTournamentIds';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { addVenue } from './addVenue';\n\nimport { Court, Tournament, Venue } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  COURT_NOT_FOUND,\n  ErrorType,\n  MISSING_COURT_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\ntype FindCourtArgs = {\n  tournamentRecords?: { [key: string]: Tournament };\n  tournamentRecord?: Tournament;\n  courtId: string;\n};\nexport function findCourt({\n  tournamentRecords,\n  tournamentRecord,\n  courtId,\n}: FindCourtArgs): {\n  success?: boolean;\n  error?: ErrorType;\n  court?: Court;\n  venue?: Venue;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!courtId) return { error: MISSING_COURT_ID };\n\n  const stack = 'findCourt';\n\n  let court, venue;\n\n  (tournamentRecord.venues ?? []).forEach((venueRecord) => {\n    (venueRecord.courts ?? []).forEach((courtRecord) => {\n      if (courtRecord.courtId === courtId) {\n        court = courtRecord;\n        venue = venueRecord;\n      }\n    });\n  });\n\n  if (court) {\n    return { ...SUCCESS, court, venue };\n  } else if (tournamentRecords) {\n    // if tournamentRecords is provided then call is from competitionEngine\n    const linkedTournamentIds =\n      getLinkedTournamentIds({\n        tournamentRecords,\n      }).linkedTournamentIds ?? [];\n\n    const relevantIds = linkedTournamentIds[tournamentRecord.tournamentId];\n\n    // if there are linked tournaments search for court in all linked tournaments\n    for (const tournamentId of relevantIds) {\n      const record = tournamentRecords[tournamentId];\n      const result = findCourt({ tournamentRecord: record, courtId });\n      // if court is found in linked tournamentRecords, add venue to original tournamentRecord\n      if (result.success) {\n        result.venue && addVenue({ tournamentRecord, venue: result.venue });\n        return { ...SUCCESS, court, venue };\n      }\n    }\n  }\n\n  // fall through to error condition\n  return decorateResult({ result: { error: COURT_NOT_FOUND }, stack });\n}\n\nexport function publicFindCourt(params) {\n  return makeDeepCopy(findCourt(params), false, true);\n}\n","import { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { findCourt } from '../../mutate/venues/findCourt';\n\nimport { Tournament } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ErrorType,\n  MISSING_COURT_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\ntype GetCourtInfoArgs = {\n  tournamentRecord: Tournament;\n  internalUse?: boolean;\n  courtId: string;\n};\nexport function getCourtInfo({\n  tournamentRecord,\n  internalUse,\n  courtId,\n}: GetCourtInfoArgs): {\n  error?: ErrorType;\n  success?: boolean;\n  courtInfo?: any;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!courtId) return { error: MISSING_COURT_ID };\n\n  const result = findCourt({ tournamentRecord, courtId });\n  if (result.error) return result;\n\n  const courtInfo =\n    result.court &&\n    (({\n      altitude,\n      courtId,\n      courtName,\n      courtDimensions,\n      latitude,\n      longitude,\n      surfaceCategory,\n      surfaceType,\n      surfacedDate,\n      pace,\n      notes,\n    }) => ({\n      altitude,\n      courtId,\n      courtName,\n      courtDimensions,\n      latitude,\n      longitude,\n      surfaceCategory,\n      surfaceType,\n      surfacedDate,\n      pace,\n      notes,\n    }))(result.court);\n\n  return { ...SUCCESS, courtInfo: makeDeepCopy(courtInfo, false, internalUse) };\n}\n","import { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { findVenue } from '../../mutate/venues/findVenue';\nimport { getCourtInfo } from './getCourtInfo';\n\nimport { Tournament } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VENUE_ID,\n} from '../../constants/errorConditionConstants';\n\n// The only difference from finding a venue is that information is filtered from both venue and courts\n// e.g. dataAvailability objects are not returned.\n\ntype GetVenueDataArgs = {\n  tournamentRecord: Tournament;\n  venueId: string;\n};\nexport function getVenueData({ tournamentRecord, venueId }: GetVenueDataArgs): {\n  success?: boolean;\n  error?: ErrorType;\n  venueData?: any;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!venueId) return { error: MISSING_VENUE_ID };\n\n  const result = findVenue({ tournamentRecord, venueId });\n  if (result.error) return result;\n\n  const courts = result.venue?.courts ?? [];\n  const courtsInfo = courts.map((court) =>\n    (({ courtInfo }) => ({\n      ...courtInfo,\n    }))(\n      getCourtInfo({\n        courtId: court.courtId,\n        internalUse: true,\n        tournamentRecord,\n      })\n    )\n  );\n\n  const venueInfo =\n    result.venue &&\n    (({ venueId, venueName, venueAbbreviation }) => ({\n      venueAbbreviation,\n      venueName,\n      venueId,\n    }))(result.venue);\n\n  const venueData = venueInfo && { ...venueInfo, courtsInfo };\n\n  return { ...SUCCESS, venueData: makeDeepCopy(venueData, false, true) };\n}\n","import { latestVisibleTimeItemValue } from './latestVisibleTimeItemValue';\n\nimport { TIME_MODIFIERS } from '../../constants/timeItemConstants';\nimport { ScheduledMatchUpArgs } from './scheduledMatchUpArgs';\n\nexport function matchUpTimeModifiers({\n  visibilityThreshold,\n  timeStamp,\n  schedule,\n  matchUp,\n}: ScheduledMatchUpArgs) {\n  const { itemValue: timeModifiers, timeStamp: itemTimeStamp } =\n    latestVisibleTimeItemValue({\n      timeItems: matchUp?.timeItems || [],\n      itemType: TIME_MODIFIERS,\n      visibilityThreshold,\n    });\n\n  return !schedule ||\n    (itemTimeStamp &&\n      timeStamp &&\n      new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())\n    ? { timeModifiers }\n    : schedule;\n}\n","import { validTimeString } from '../../validators/regex';\nimport { getUTCdateString } from '../../utilities/dateTime';\n\nimport {\n  MISSING_MATCHUP,\n  MISSING_TIME_ITEMS,\n} from '../../constants/errorConditionConstants';\nimport {\n  START_TIME,\n  STOP_TIME,\n  RESUME_TIME,\n  END_TIME,\n} from '../../constants/timeItemConstants';\n\nfunction timeDate(value) {\n  if (validTimeString.test(value)) {\n    const dateString = getUTCdateString();\n    return new Date(`${dateString}T${value}`);\n  } else {\n    return new Date(value);\n  }\n}\n\nexport function matchUpDuration({ matchUp }) {\n  if (!matchUp) return { error: MISSING_MATCHUP };\n  if (!matchUp.timeItems) return { error: MISSING_TIME_ITEMS };\n\n  const relevantTimeItems = matchUp.timeItems\n    .filter((timeItem) =>\n      [START_TIME, STOP_TIME, RESUME_TIME, END_TIME].includes(\n        timeItem?.itemType\n      )\n    )\n    .sort(\n      (a, b) =>\n        timeDate(a.itemValue).getTime() - timeDate(b.itemValue).getTime()\n    );\n\n  const elapsed = relevantTimeItems.reduce(\n    (elapsed, timeItem) => {\n      let milliseconds;\n      const itemTypeComponents = timeItem?.itemType?.split('.');\n      const timeType =\n        timeItem?.itemType?.startsWith('SCHEDULE.TIME') &&\n        itemTypeComponents[2];\n      const scheduleType = `SCHEDULE.TIME.${timeType}`;\n      switch (scheduleType) {\n        case START_TIME:\n          milliseconds = 0;\n          break;\n        case END_TIME:\n          if (\n            elapsed.lastValue &&\n            [START_TIME, RESUME_TIME].includes(elapsed.lastType)\n          ) {\n            const interval =\n              timeDate(timeItem.itemValue).getTime() -\n              timeDate(elapsed.lastValue).getTime();\n            milliseconds = elapsed.milliseconds + interval;\n          } else {\n            milliseconds = elapsed.milliseconds;\n          }\n          break;\n        case STOP_TIME:\n          if ([START_TIME, 'SCHECULE.TIME.RESUME'].includes(elapsed.lastType)) {\n            const interval =\n              timeDate(timeItem.itemValue).getTime() -\n              timeDate(elapsed.lastValue).getTime();\n            milliseconds = elapsed.milliseconds + interval;\n          } else {\n            milliseconds = elapsed.milliseconds;\n          }\n          break;\n        default:\n          milliseconds = elapsed.milliseconds;\n          break;\n      }\n      return {\n        milliseconds,\n        lastType: scheduleType,\n        lastValue: timeItem.itemValue,\n      };\n    },\n    { milliseconds: 0, lastType: undefined, lastValue: undefined }\n  );\n\n  if ([START_TIME, RESUME_TIME].includes(elapsed.lastType)) {\n    const interval =\n      new Date().getTime() - timeDate(elapsed.lastValue).getTime();\n    elapsed.milliseconds += interval;\n  }\n\n  return {\n    milliseconds: elapsed.milliseconds,\n    time: msToTime(elapsed.milliseconds),\n    relevantTimeItems,\n  };\n}\n\nfunction msToTime(s) {\n  const pad = (n, z = 2) => ('00' + n).slice(-z);\n  return (\n    pad((s / 3.6e6) | 0) +\n    ':' +\n    pad(((s % 3.6e6) / 6e4) | 0) +\n    ':' +\n    pad(((s % 6e4) / 1000) | 0)\n  );\n}\n","import { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { findExtension } from '../../acquire/findExtension';\n\nimport { MISSING_EVENT } from '../../constants/errorConditionConstants';\nimport { FLIGHT_PROFILE } from '../../constants/extensionConstants';\nimport { Event } from '../../types/tournamentTypes';\n\ntype GetFlightProfileArgs = {\n  eventId?: string;\n  event: Event;\n};\nexport function getFlightProfile({ event, eventId }: GetFlightProfileArgs) {\n  if (!event) return { error: MISSING_EVENT };\n\n  const result = findExtension({\n    name: FLIGHT_PROFILE,\n    element: event,\n  });\n\n  const extension = result?.extension;\n\n  // eventId indicates that `getFlightProfile()` has been called via `tournamentEngine`\n  // a deep copy is made and drawDefinitions are attached for client convenience\n  const flightProfile = eventId\n    ? makeDeepCopy(extension?.value, false, true)\n    : extension?.value;\n\n  if (eventId) {\n    event.drawDefinitions?.forEach((drawDefinition) => {\n      flightProfile?.flights?.forEach((flight) => {\n        if (flight.drawId === drawDefinition.drawId) {\n          Object.assign(flight, { drawDefinition });\n        }\n      });\n    });\n  }\n\n  return { flightProfile };\n}\n","import { ResultType, decorateResult } from '../global/functions/decorateResult';\nimport { getFlightProfile } from '../query/event/getFlightProfile';\n\nimport { DrawDefinition, Tournament, Event } from '../types/tournamentTypes';\nimport { TournamentRecords } from '../types/factoryTypes';\nimport {\n  DRAW_DEFINITION_NOT_FOUND,\n  EVENT_NOT_FOUND,\n} from '../constants/errorConditionConstants';\n\ntype FindEventArgs = {\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  eventId?: string;\n  drawId?: string;\n};\nexport function findEvent(params: FindEventArgs): ResultType & {\n  drawDefinition?: DrawDefinition;\n  tournamentId?: string;\n  event?: Event;\n} {\n  const { tournamentRecord, eventId, drawId } = params;\n\n  const stack = 'findEvent';\n  const eventIdsMap = {};\n  const tournamentRecords =\n    params.tournamentRecords ??\n    (tournamentRecord && {\n      [tournamentRecord.tournamentId]: tournamentRecord,\n    }) ??\n    {};\n\n  const events = Object.values(tournamentRecords)\n    .map(({ events, tournamentId }) => {\n      if (events) {\n        events.forEach((event) => {\n          eventIdsMap[event.eventId] = { tournamentId };\n        });\n      }\n      return events ?? [];\n    })\n    .flat();\n\n  let tournamentId;\n\n  if (drawId) {\n    let drawDefinition;\n    const event = events.find((event) => {\n      const drawDefinitions = event?.drawDefinitions ?? [];\n      const targetDrawDefinition = drawDefinitions.find(\n        (drawDefinition) => drawDefinition.drawId === drawId\n      );\n      if (targetDrawDefinition) {\n        drawDefinition = targetDrawDefinition;\n        tournamentId = eventIdsMap[event.eventId].tournamentId;\n      } else {\n        const flightProfile =\n          event && getFlightProfile({ event })?.flightProfile;\n\n        const flight = flightProfile?.flights?.find(\n          (flight) => flight.drawId === drawId\n        );\n\n        if (flight) {\n          tournamentId = eventIdsMap[event.eventId].tournamentId;\n          return {\n            entries: flight.drawEntries,\n            drawName: flight.drawName,\n            tournamentId,\n            drawId,\n          };\n        }\n      }\n      return targetDrawDefinition;\n    });\n\n    if (event) return { event, drawDefinition, tournamentId };\n  }\n\n  if (eventId) {\n    const event = events.find((event) => event?.eventId === eventId);\n    if (!event) {\n      return {\n        event: undefined,\n        drawDefinition: undefined,\n        ...decorateResult({ result: { error: EVENT_NOT_FOUND }, stack }),\n      };\n    } else {\n      tournamentId = eventIdsMap[event.eventId].tournamentId;\n    }\n    return { event, drawDefinition: undefined, tournamentId };\n  }\n\n  return {\n    event: undefined,\n    drawDefinition: undefined,\n    ...decorateResult({\n      result: { error: DRAW_DEFINITION_NOT_FOUND },\n      context: { drawId, eventId },\n      stack,\n    }),\n  };\n}\n","import { matchUpFormatTimes } from '../extensions/matchUpFormatTiming/getMatchUpFormatTiming';\nimport { completedMatchUpStatuses } from '../../constants/matchUpStatusConstants';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { attributeFilter } from '../../utilities/attributeFilter';\nimport { scheduledMatchUpTime } from './scheduledMatchUpTime';\nimport { scheduledMatchUpDate } from './scheduledMatchUpDate';\nimport { matchUpAllocatedCourts } from './courtAllocations';\nimport { matchUpAssignedCourtId } from './courtAssignment';\nimport { matchUpAssignedVenueId } from './venueAssignment';\nimport { getVenueData } from '../venues/getVenueData';\nimport { matchUpTimeModifiers } from './timeModifiers';\nimport { matchUpDuration } from './matchUpDuration';\nimport { findEvent } from '../../acquire/findEvent';\nimport { matchUpCourtOrder } from './courtOrder';\nimport { matchUpStartTime } from './startTime';\nimport { matchUpEndTime } from './endTime';\nimport {\n  addMinutesToTimeString,\n  extractDate,\n  extractTime,\n  getIsoDateString,\n} from '../../utilities/dateTime';\n\nimport { Event, Tournament, EventTypeUnion } from '../../types/tournamentTypes';\nimport { MISSING_MATCHUP } from '../../constants/errorConditionConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport { TEAM } from '../../constants/eventConstants';\nimport {\n  ScheduleTiming,\n  ScheduleVisibilityFilters,\n} from '../../types/factoryTypes';\n\ntype GetMatchUpScheduleDetailsArgs = {\n  scheduleVisibilityFilters?: ScheduleVisibilityFilters;\n  scheduleTiming?: ScheduleTiming;\n  tournamentRecord?: Tournament;\n  matchUpType?: EventTypeUnion;\n  afterRecoveryTimes?: boolean;\n  usePublishState?: boolean;\n  matchUp: HydratedMatchUp;\n  matchUpFormat?: string;\n  publishStatus?: any;\n  event?: Event;\n};\nexport function getMatchUpScheduleDetails(\n  params: GetMatchUpScheduleDetailsArgs\n) {\n  let event = params.event;\n  let matchUpType: any = params.matchUpType;\n  const {\n    scheduleVisibilityFilters,\n    afterRecoveryTimes,\n    tournamentRecord,\n    usePublishState,\n    scheduleTiming,\n    matchUpFormat,\n    publishStatus,\n    matchUp,\n  } = params;\n\n  if (!matchUp) return { error: MISSING_MATCHUP };\n\n  // matchUpType is required to derive averageMatchUpMinutes and recoveryMinutes.\n  /// If matchUpType is not provided or is not present on matchUp...\n  // ...attempt to derive by interrogating structure, draw, and event\n  if (\n    afterRecoveryTimes &&\n    !matchUp.matchUpType &&\n    !params.matchUpType &&\n    (event || tournamentRecord) &&\n    matchUp.drawId\n  ) {\n    let drawDefinition = event?.drawDefinitions?.find(\n      (drawDefinition) => drawDefinition.drawId === matchUp.drawId\n    );\n\n    if (!drawDefinition && tournamentRecord) {\n      ({ drawDefinition, event } = findEvent({\n        tournamentRecord,\n        drawId: matchUp.drawId,\n      }));\n    }\n\n    const structure =\n      matchUp.structureId &&\n      drawDefinition?.structures?.find(\n        ({ structureId }) => structureId === matchUp.structureId\n      );\n\n    matchUpType =\n      params.matchUpType ||\n      structure?.matchUpType ||\n      drawDefinition?.matchUpType ||\n      (event?.eventType !== TEAM && event?.eventType);\n  }\n\n  const { milliseconds, time } = matchUpDuration({ matchUp });\n  const { startTime } = matchUpStartTime({ matchUp });\n  const { endTime } = matchUpEndTime({ matchUp });\n\n  let schedule;\n  const { visibilityThreshold, eventIds, drawIds } =\n    scheduleVisibilityFilters ?? {};\n\n  if (\n    (!eventIds || eventIds.includes(matchUp.eventId)) &&\n    (!drawIds || drawIds.includes(matchUp.drawId))\n  ) {\n    const scheduleSource = { matchUp, visibilityThreshold };\n    const { allocatedCourts } = matchUpAllocatedCourts(scheduleSource);\n    const { scheduledTime } = scheduledMatchUpTime(scheduleSource);\n    let { scheduledDate } = scheduledMatchUpDate(scheduleSource);\n    const { venueId } = matchUpAssignedVenueId(scheduleSource);\n    const { courtId } = matchUpAssignedCourtId(scheduleSource);\n    const { courtOrder } = matchUpCourtOrder(scheduleSource);\n    const { timeModifiers } = matchUpTimeModifiers(scheduleSource);\n\n    let timeAfterRecovery,\n      averageMinutes,\n      recoveryMinutes,\n      typeChangeRecoveryMinutes,\n      typeChangeTimeAfterRecovery;\n\n    const eventType = matchUp.matchUpType ?? matchUpType;\n    if (scheduleTiming && scheduledTime && afterRecoveryTimes && eventType) {\n      const timingDetails = {\n        matchUpFormat: matchUp.matchUpFormat ?? matchUpFormat,\n        ...scheduleTiming,\n      };\n      ({\n        averageMinutes = 0,\n        recoveryMinutes = 0,\n        typeChangeRecoveryMinutes = 0,\n      } = matchUpFormatTimes({\n        timingDetails,\n        eventType,\n      }));\n\n      if (averageMinutes || recoveryMinutes) {\n        timeAfterRecovery = endTime\n          ? addMinutesToTimeString(extractTime(endTime), recoveryMinutes)\n          : addMinutesToTimeString(\n              scheduledTime,\n              averageMinutes + recoveryMinutes\n            );\n      }\n      if (typeChangeRecoveryMinutes) {\n        typeChangeTimeAfterRecovery = endTime\n          ? addMinutesToTimeString(\n              extractTime(endTime),\n              typeChangeRecoveryMinutes\n            )\n          : addMinutesToTimeString(\n              scheduledTime,\n              averageMinutes + typeChangeRecoveryMinutes\n            );\n      }\n    }\n\n    if (!scheduledDate && scheduledTime)\n      scheduledDate = extractDate(scheduledTime);\n\n    const isoDateString = getIsoDateString({ scheduledDate, scheduledTime });\n\n    const venueDataMap = {};\n    const venueData =\n      (\n        tournamentRecord &&\n        venueId &&\n        getVenueData({ tournamentRecord, venueId })\n      )?.venueData || {};\n\n    if (venueId) venueDataMap[venueId] = venueData;\n    const { venueName, venueAbbreviation, courtsInfo } = venueData;\n\n    const courtInfo =\n      courtId && courtsInfo?.find((courtInfo) => courtInfo.courtId === courtId);\n    const courtName = courtInfo?.courtName;\n\n    for (const allocatedCourt of allocatedCourts || []) {\n      if (!tournamentRecord) break;\n      if (allocatedCourt.venueId && !venueDataMap[allocatedCourt.venueid]) {\n        venueDataMap[allocatedCourt.venueId] = getVenueData({\n          venueId: allocatedCourt.venueId,\n          tournamentRecord,\n        })?.venueData;\n      }\n      const vData = venueDataMap[allocatedCourt.venueId];\n      allocatedCourt.venueName = vData?.venueName;\n      const courtInfo = vData?.courtsInfo?.find(\n        (courtInfo) => courtInfo.courtId === allocatedCourt.courtId\n      );\n      allocatedCourt.courtName = courtInfo?.courtName;\n    }\n\n    schedule = definedAttributes({\n      typeChangeTimeAfterRecovery,\n      timeAfterRecovery,\n      scheduledDate,\n      scheduledTime,\n      isoDateString,\n\n      allocatedCourts,\n      timeModifiers,\n      venueAbbreviation,\n      venueName,\n      venueId,\n      courtOrder,\n      courtName,\n      courtId,\n\n      typeChangeRecoveryMinutes,\n      recoveryMinutes,\n      averageMinutes,\n      milliseconds,\n      startTime,\n      endTime,\n      time,\n    });\n  } else {\n    schedule = definedAttributes({\n      milliseconds,\n      startTime,\n      endTime,\n      time,\n    });\n  }\n\n  const { scheduledDate } = scheduledMatchUpDate({ matchUp });\n  const { scheduledTime } = scheduledMatchUpTime({ matchUp });\n\n  if (usePublishState && publishStatus?.displaySettings?.draws) {\n    const drawSettings = publishStatus.displaySettings.draws;\n    const scheduleDetails = (\n      drawSettings?.[matchUp.drawId] ?? drawSettings?.default\n    )?.scheduleDetails;\n    if (scheduleDetails) {\n      const scheduleAttributes = (\n        scheduleDetails.find(\n          (details) => scheduledDate && details.dates?.includes(scheduledDate)\n        ) ?? scheduleDetails.find((details) => !details.dates?.length)\n      )?.attributes;\n\n      if (scheduleAttributes) {\n        // set all attributes to true\n        const template = Object.assign(\n          {},\n          ...Object.keys(schedule).map((key) => ({ [key]: true })),\n          // overwrite with publishStatus attributes\n          scheduleAttributes\n        );\n        schedule = attributeFilter({\n          source: schedule,\n          template,\n        });\n      }\n    }\n  }\n\n  const hasCompletedStatus =\n    matchUp.matchUpStatus &&\n    completedMatchUpStatuses.includes(matchUp.matchUpStatus);\n\n  const endDate =\n    (hasCompletedStatus &&\n      (extractDate(endTime) ||\n        extractDate(scheduledDate) ||\n        extractDate(scheduledTime))) ||\n    undefined;\n\n  return { schedule, endDate };\n}\n","import { START_TIME } from '../../constants/timeItemConstants';\n\nexport function matchUpStartTime({ matchUp }) {\n  const timeItems = matchUp?.timeItems || [];\n  const getTimeStamp = (item) =>\n    !item.createdAt ? 0 : new Date(item.createdAt).getTime();\n  const startTimeItem = timeItems.reduce((startTimeItem, timeItem) => {\n    const startTimeCandidate = timeItem.itemType === START_TIME && timeItem;\n    const earlierStartTimeItem =\n      startTimeCandidate &&\n      (!startTimeItem ||\n        getTimeStamp(startTimeCandidate) < getTimeStamp(startTimeItem));\n    return earlierStartTimeItem ? startTimeCandidate : startTimeItem;\n  }, undefined);\n\n  const startTime = startTimeItem?.itemValue;\n\n  return { startTime };\n}\n","import { END_TIME } from '../../constants/timeItemConstants';\n\nexport function matchUpEndTime({ matchUp }) {\n  const timeItems = matchUp?.timeItems || [];\n  const getTimeStamp = (item) =>\n    !item.createdAt ? 0 : new Date(item.createdAt).getTime();\n  const endTimeItem = timeItems.reduce((endTimeItem, timeItem) => {\n    const endTimeCandidate = timeItem.itemType === END_TIME && timeItem;\n    const earlierStartTimeItem =\n      endTimeCandidate &&\n      (!endTimeItem ||\n        getTimeStamp(endTimeCandidate) > getTimeStamp(endTimeItem));\n    return earlierStartTimeItem ? endTimeCandidate : endTimeItem;\n  }, undefined);\n\n  const endTime = endTimeItem?.itemValue;\n\n  return { endTime };\n}\n","import { latestVisibleTimeItemValue } from './latestVisibleTimeItemValue';\n\nimport { COURT_ORDER } from '../../constants/timeItemConstants';\nimport { ScheduledMatchUpArgs } from './scheduledMatchUpArgs';\n\nexport function matchUpCourtOrder({\n  visibilityThreshold,\n  timeStamp,\n  schedule,\n  matchUp,\n}: ScheduledMatchUpArgs) {\n  const { itemValue: courtOrder, timeStamp: itemTimeStamp } =\n    latestVisibleTimeItemValue({\n      timeItems: matchUp?.timeItems || [],\n      itemType: COURT_ORDER,\n      visibilityThreshold,\n    });\n\n  return !schedule ||\n    (itemTimeStamp &&\n      timeStamp &&\n      new Date(itemTimeStamp).getTime() > new Date(timeStamp).getTime())\n    ? { courtOrder }\n    : schedule;\n}\n","export function getObjectTieFormat(obj) {\n  if (!obj) return;\n  const { tieFormatId, tieFormats } = obj;\n  if (obj.tieFormat) {\n    return obj.tieFormat;\n  } else if (tieFormatId && Array.isArray(tieFormats)) {\n    return tieFormats.find((tf) => tf.tieFormatId === tieFormatId);\n  }\n}\n","export function getItemTieFormat({ item, drawDefinition, structure, event }) {\n  if (!item) return;\n  if (item.tieFormat) return item.tieFormat;\n\n  // if there is a tieFormatId, only possible to look for referenced tieFormat in tieFormats on drawDefinition and event\n  if (item.tieFormatId) {\n    if (drawDefinition.tieFormat) return drawDefinition.tieFormat;\n    const tieFormat = drawDefinition.tieFormats?.find(\n      (tf) => item.tieFormatId === tf.tieFormatId\n    );\n    if (tieFormat) return tieFormat;\n\n    if (event.tieFormat) return event.tieFormat;\n    return event.tieFormats?.find((tf) => item.tieFormatId === tf.tieFormatId);\n  }\n  if (structure.tieFormat) return structure.tieFormat;\n  if (structure.tieFormatId) {\n    const structureTieFormat = drawDefinition.tieFormats?.find(\n      (tf) => structure.tieFormatId === tf.tieFormatId\n    );\n    if (structureTieFormat) return structureTieFormat;\n  }\n}\n","import { getObjectTieFormat } from './getObjectTieFormat';\nimport { getItemTieFormat } from './getItemTieFormat';\nimport {\n  DrawDefinition,\n  Structure,\n  Event,\n} from '../../../types/tournamentTypes';\n\n// use with resolved objects, not uuid references to objects\n\ntype ResolveTieFormatArgs = {\n  drawDefinition?: DrawDefinition;\n  structure?: Structure;\n  matchUp?: object;\n  event?: Event;\n};\n\nexport function resolveTieFormat({\n  drawDefinition,\n  structure,\n  matchUp,\n  event,\n}: ResolveTieFormatArgs) {\n  return {\n    tieFormat:\n      getItemTieFormat({\n        item: matchUp,\n        drawDefinition,\n        structure,\n        event,\n      }) ||\n      getItemTieFormat({\n        item: structure,\n        drawDefinition,\n        structure,\n        event,\n      }) ||\n      getObjectTieFormat(drawDefinition) ||\n      getObjectTieFormat(event),\n  };\n}\n","import { isNumeric } from '../../utilities/math';\nimport { unique } from '../../utilities/arrays';\n\nexport function getRangeString(arr) {\n  if (!Array.isArray(arr)) return '';\n  const numericArray = arr.filter(isNumeric);\n  if (!numericArray.length) return '';\n  const range = unique([Math.min(...numericArray), Math.max(...numericArray)]);\n  return range.join('-');\n}\n","export const NORMAL = 'normal';\nexport const TIMED = 'timed';\nexport const FINAL = 'final';\nexport const NOAD = 'NOAD';\nexport const SET = 'SET';\nexport const setTypes = {\n  S: NORMAL,\n  F: FINAL,\n};\n","import { definedAttributes } from '../../../utilities/definedAttributes';\nimport { isConvertableInteger } from '../../../utilities/math';\n\nimport {\n  SET,\n  NOAD,\n  TIMED,\n  setTypes,\n} from '../../../constants/matchUpFormatConstants';\n\ntype TiebreakFormat = {\n  tiebreakTo: number;\n  modifier?: string;\n  NoAD?: boolean;\n  invalid?: boolean;\n};\n\ntype SetFormat = {\n  tiebreakFormat?: TiebreakFormat;\n  tiebreakSet?: TiebreakFormat;\n  tiebreakAt?: string | number;\n  noTiebreak?: boolean;\n  modifier?: string;\n  minutes?: number;\n  timed?: boolean;\n  based?: string;\n  NoAD?: boolean;\n  setTo?: number;\n};\n\nexport type ParsedFormat = {\n  finalSetFormat?: any;\n  simplified?: boolean;\n  exactly?: number;\n  setFormat?: any;\n  bestOf?: number;\n};\n\nexport function parse(matchUpFormatCode: string): ParsedFormat | undefined {\n  if (typeof matchUpFormatCode === 'string') {\n    const type =\n      (matchUpFormatCode.startsWith('T') && TIMED) ||\n      (matchUpFormatCode.startsWith(SET) && SET) ||\n      '';\n\n    if (type === TIMED) {\n      const setFormat = parseTimedSet(matchUpFormatCode);\n      const parsedFormat = {\n        simplified: true,\n        setFormat,\n        bestOf: 1,\n      };\n      if (setFormat) return parsedFormat;\n    }\n    if (type === SET) return setsMatch(matchUpFormatCode);\n  }\n\n  return undefined;\n}\n\nfunction setsMatch(formatstring: string): any {\n  const parts = formatstring.split('-');\n\n  const setsCount = getNumber(parts[0].slice(3));\n  const bestOf = setsCount === 1 || setsCount % 2 !== 0 ? setsCount : undefined;\n  const exactly =\n    setsCount !== 1 && setsCount % 2 === 0 ? setsCount : undefined;\n  const setFormat = parts && parseSetFormat(parts[1]);\n  const finalSetFormat = parts && parseSetFormat(parts[2]);\n  const timed =\n    (setFormat && setFormat.timed) || (finalSetFormat && finalSetFormat.timed);\n  const validSetsCount = (bestOf && bestOf < 6) || (timed && exactly);\n  const validFinalSet = !parts[2] || finalSetFormat;\n  const validSetsFormat = setFormat;\n\n  const result: ParsedFormat = definedAttributes({\n    setFormat,\n    exactly,\n    bestOf,\n  });\n  if (finalSetFormat) result.finalSetFormat = finalSetFormat;\n  if (validSetsCount && validSetsFormat && validFinalSet) return result;\n}\n\nfunction parseSetFormat(formatstring: string): SetFormat | undefined | false {\n  if (formatstring?.[1] === ':') {\n    const parts = formatstring.split(':');\n    const setType = setTypes[parts[0]];\n    const setFormatString = parts[1];\n    if (setType && setFormatString) {\n      const isTiebreakSet = setFormatString.startsWith('TB');\n      if (isTiebreakSet) {\n        const tiebreakSet = parseTiebreakFormat(setFormatString);\n        if (tiebreakSet === false) return false;\n        return typeof tiebreakSet === 'object' ? { tiebreakSet } : undefined;\n      }\n      const timedSet = setFormatString.startsWith('T');\n      if (timedSet) return parseTimedSet(setFormatString);\n\n      const parts = formatstring.match(/^[FS]:(\\d+)([A-Za-z]*)/);\n      const NoAD = (parts && isNoAD(parts[2])) || false;\n      const validNoAD = !parts?.[2] || NoAD;\n      const setTo = parts ? getNumber(parts[1]) : undefined;\n      const tiebreakAtValue = parseTiebreakAt(setFormatString);\n      const validTiebreakAt = tiebreakAtValue !== false;\n      const tiebreakAt = (validTiebreakAt && tiebreakAtValue) || setTo;\n      const tiebreakFormat = parseTiebreakFormat(setFormatString.split('/')[1]);\n      const validTiebreak = tiebreakFormat !== false;\n      const result: SetFormat = { setTo };\n      if (NoAD) result.NoAD = true;\n      if (tiebreakFormat) {\n        result.tiebreakFormat = tiebreakFormat;\n        result.tiebreakAt = tiebreakAt;\n      } else {\n        result.noTiebreak = true;\n      }\n\n      return (\n        (setTo && validNoAD && validTiebreak && validTiebreakAt && result) ||\n        false\n      );\n    }\n  }\n\n  return undefined;\n}\n\nfunction parseTiebreakAt(\n  setFormatString: string,\n  expectNumber: boolean = true\n) {\n  const tiebreakAtValue =\n    setFormatString?.indexOf('@') > 0 && setFormatString.split('@');\n  if (tiebreakAtValue) {\n    const tiebreakAt = expectNumber\n      ? getNumber(tiebreakAtValue[1])\n      : tiebreakAtValue[1];\n    return tiebreakAt || false;\n  }\n\n  return undefined;\n}\n\nfunction parseTiebreakFormat(\n  formatstring: string\n): TiebreakFormat | undefined | false {\n  if (formatstring) {\n    if (formatstring.startsWith('TB')) {\n      const modifier = parseTiebreakAt(formatstring, false);\n      const parts = formatstring.match(/^TB(\\d+)([A-Za-z]*)/);\n      const tiebreakToString = parts?.[1];\n      const NoAD = parts && isNoAD(parts[2]);\n      const validNoAD = !parts?.[2] || NoAD;\n      const tiebreakTo = getNumber(tiebreakToString);\n      if (tiebreakTo && validNoAD) {\n        const result: TiebreakFormat = { tiebreakTo };\n        // modifiers cannot be numeric\n        if (\n          modifier &&\n          typeof modifier === 'string' &&\n          !isConvertableInteger(modifier)\n        ) {\n          result.modifier = modifier;\n        }\n        if (NoAD) result.NoAD = true;\n        return result;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  return undefined;\n}\n\nfunction parseTimedSet(formatstring: string): SetFormat | undefined {\n  const timestring = formatstring.slice(1);\n  const parts = timestring.match(/^(\\d+)(@?[A-Za-z]*)/);\n  const minutes = getNumber(parts?.[1]);\n  if (!minutes) return;\n  const setFormat: SetFormat = { timed: true, minutes };\n  const based = parts?.[2];\n  const validModifier = [undefined, 'P', 'G'].includes(based);\n  if (based && !validModifier) {\n    const modifier = timestring.match(/^(\\d+)(@)([A-Za-z]+)$/)?.[3];\n    if (modifier) {\n      setFormat.modifier = modifier;\n      return setFormat;\n    }\n    return;\n  }\n  if (based) setFormat.based = parts[2];\n  return setFormat;\n}\n\nfunction isNoAD(formatstring) {\n  return formatstring && formatstring.indexOf(NOAD) >= 0;\n}\n\nfunction getNumber(formatstring) {\n  return !isNaN(Number(formatstring)) ? Number(formatstring) : 0;\n}\n","import { getRoundMatchUps } from '../matchUps/getRoundMatchUps';\n\nimport { DrawDefinition, Structure } from '../../types/tournamentTypes';\nimport { LUCKY_DRAW } from '../../constants/drawDefinitionConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\n\ntype IsLuckyArgs = {\n  drawDefinition?: DrawDefinition;\n  matchUps?: HydratedMatchUp[];\n  roundsNotPowerOf2?: boolean;\n  structure?: Structure;\n};\nexport function isLucky({\n  roundsNotPowerOf2,\n  drawDefinition,\n  structure,\n  matchUps,\n}: IsLuckyArgs) {\n  if (!structure) return false;\n\n  matchUps = matchUps ?? structure.matchUps ?? [];\n  roundsNotPowerOf2 =\n    roundsNotPowerOf2 ?? getRoundMatchUps({ matchUps }).roundsNotPowerOf2;\n\n  const hasDrawPositions =\n    !!structure.positionAssignments?.find(({ drawPosition }) => drawPosition) ||\n    !!matchUps?.find(({ drawPositions }) => drawPositions?.length);\n\n  return (\n    (!drawDefinition?.drawType || drawDefinition.drawType !== LUCKY_DRAW) &&\n    !structure?.structures &&\n    roundsNotPowerOf2 &&\n    hasDrawPositions\n  );\n}\n","import { DrawDefinition } from '../../types/tournamentTypes';\nimport {\n  AD_HOC,\n  VOLUNTARY_CONSOLATION,\n} from '../../constants/drawDefinitionConstants';\n\ntype IsAdHocArgs = {\n  drawDefinition?: DrawDefinition;\n  structure?: any; // in this case support hydrated structures as well\n};\nexport function isAdHoc({ drawDefinition, structure }: IsAdHocArgs): boolean {\n  if (!structure) return false;\n\n  const matchUps =\n    structure.matchUps ||\n    (structure.roundMatchUps && Object.values(structure.roundMatchUps).flat());\n\n  const hasRoundPosition = matchUps?.find((matchUp) => matchUp?.roundPosition);\n  const hasDrawPosition = matchUps?.find(\n    (matchUp) => matchUp?.drawPositions?.length\n  );\n\n  return (\n    !structure?.structures &&\n    structure?.stage !== VOLUNTARY_CONSOLATION &&\n    !(drawDefinition?.drawType && drawDefinition.drawType !== AD_HOC) &&\n    !hasRoundPosition &&\n    !hasDrawPosition\n  );\n}\n","import { POLICY_TYPE_ROUND_NAMING } from '../../constants/policyConstants';\nimport {\n  MAIN,\n  PLAY_OFF,\n  CONSOLATION,\n  QUALIFYING,\n} from '../../constants/drawDefinitionConstants';\n\nexport const POLICY_ROUND_NAMING_DEFAULT = {\n  [POLICY_TYPE_ROUND_NAMING]: {\n    policyName: 'Round Naming Default',\n    namingConventions: {\n      round: 'Round',\n      pre: 'Pre',\n    },\n    qualifyingFinishMap: {\n      1: 'Final',\n    },\n    abbreviatedRoundNamingMap: {\n      // key is matchUpsCount for the round\n      1: 'F',\n      2: 'SF',\n      4: 'QF',\n    },\n    roundNamingMap: {\n      1: 'Final',\n      2: 'Semifinal',\n      4: 'Quarterfinal',\n    },\n    affixes: {\n      roundNumber: 'R',\n      preFeedRound: 'Q',\n      preQualifying: 'P',\n    },\n    stageConstants: {\n      [MAIN]: '',\n      [PLAY_OFF]: 'P',\n      [QUALIFYING]: 'Q',\n      [CONSOLATION]: 'C',\n    },\n  },\n};\n\nexport default POLICY_ROUND_NAMING_DEFAULT;\n","import { checkRequiredParameters } from '../../parameters/checkRequiredParameters';\n\nimport { TEAM, INDIVIDUAL, PAIR } from '../../constants/participantConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { SINGLES, DOUBLES } from '../../constants/matchUpTypes';\nimport { MATCHUP } from '../../constants/attributeConstants';\n\n// derive matchUpType from participants when not defined on matchUp\nexport function getMatchUpType(params: {\n  matchUp: {\n    sides?: { participant?: { participantType?: string } }[];\n    matchUpType?: string;\n  };\n}): ResultType & { matchUpType?: string } {\n  const paramCheck = checkRequiredParameters(params, [{ [MATCHUP]: true }]);\n  if (paramCheck.error) return paramCheck;\n\n  const matchUp = params?.matchUp;\n  let matchUpType = matchUp?.matchUpType as string | undefined;\n\n  if (!matchUpType && matchUp?.sides?.length) {\n    const side = matchUp.sides.find(({ participant }) => participant);\n    const participant = side?.participant;\n    const participantType = participant?.participantType;\n    matchUpType =\n      (participantType === INDIVIDUAL && SINGLES) ||\n      (participantType === PAIR && DOUBLES) ||\n      (participantType === TEAM && TEAM) ||\n      undefined;\n  }\n\n  return { matchUpType };\n}\n","import { scheduledMatchUpTime } from './matchUp/scheduledMatchUpTime';\nimport { scheduledMatchUpDate } from './matchUp/scheduledMatchUpDate';\nimport { matchUpAllocatedCourts } from './matchUp/courtAllocations';\nimport { matchUpAssignedCourtId } from './matchUp/courtAssignment';\nimport { matchUpAssignedVenueId } from './matchUp/venueAssignment';\nimport { extractDate, sameDay } from '../utilities/dateTime';\n\nimport { TEAM_MATCHUP } from '../constants/matchUpTypes';\nimport { MatchUpFilters } from '../types/factoryTypes';\nimport { HydratedMatchUp } from '../types/hydrated';\n\ntype FilterMatchUpsArgs = MatchUpFilters & {\n  matchUps: HydratedMatchUp[];\n};\n\nexport function filterMatchUps(params: FilterMatchUpsArgs) {\n  const {\n    matchUps,\n\n    isCollectionMatchUp,\n    excludeMatchUpStatuses,\n    matchUpStatuses,\n    hasWinningSide,\n    matchUpFormats,\n    roundPositions,\n    matchUpFormat,\n    collectionIds,\n    isMatchUpTie,\n    roundNumbers,\n    matchUpIds,\n    roundNames,\n\n    // only applies to inContext matchUps and only when processContext boolean is true\n    stageSequences,\n    scheduledDates,\n    scheduledDate,\n    participantIds,\n    processContext,\n    tournamentIds,\n    matchUpTypes,\n    structureIds,\n    readyToScore,\n    courtIds,\n    eventIds,\n    venueIds,\n    drawIds,\n    stages,\n\n    filterMatchUpIds = true,\n    filterMatchUpTypes = true,\n  } = params;\n\n  const targetParticipantIds = Array.isArray(participantIds) ? participantIds.filter(Boolean) : [];\n  const targetMatchUpStatuses = Array.isArray(matchUpStatuses) ? matchUpStatuses.filter(Boolean) : [];\n  const excludeTargetMatchUpStatuses = Array.isArray(excludeMatchUpStatuses)\n    ? excludeMatchUpStatuses.filter(Boolean)\n    : [];\n\n  const targetStages = Array.isArray(stages) ? stages.filter(Boolean) : [];\n  const targetStageSequences = Array.isArray(stageSequences) ? stageSequences.filter(Boolean) : [];\n  const targetCollectionIds = Array.isArray(collectionIds) ? collectionIds.filter(Boolean) : [];\n  const targetRoundNames = Array.isArray(roundNames) ? roundNames.filter(Boolean) : [];\n  const targetRoundNumbers = Array.isArray(roundNumbers) ? roundNumbers.filter(Boolean) : [];\n  const targetRoundPositions = Array.isArray(roundPositions) ? roundPositions.filter(Boolean) : [];\n\n  const targetMatchUpIds = Array.isArray(matchUpIds) && filterMatchUpIds ? matchUpIds.filter(Boolean) : [];\n  const targetMatchUpTypes = Array.isArray(matchUpTypes) && filterMatchUpTypes ? matchUpTypes.filter(Boolean) : [];\n  const targetCourtIds = Array.isArray(courtIds) ? courtIds.filter(Boolean) : [];\n  const targetVenueIds = Array.isArray(venueIds) ? venueIds.filter(Boolean) : [];\n  const targetMatchUpFormats =\n    (Array.isArray(matchUpFormats) && matchUpFormats.filter(Boolean)) ||\n    (typeof matchUpFormat === 'string' && [matchUpFormat]) ||\n    [];\n  const targetScheduledDates =\n    (Array.isArray(scheduledDates) && scheduledDates.filter(Boolean)) ||\n    (typeof scheduledDate === 'string' && scheduledDate.length && [scheduledDate]) ||\n    [];\n\n  const targetTournamentIds = Array.isArray(tournamentIds) ? tournamentIds.filter(Boolean) : [];\n  const targetEventIds = Array.isArray(eventIds) ? eventIds.filter(Boolean) : [];\n  const targetDrawIds = Array.isArray(drawIds) ? drawIds.filter(Boolean) : [];\n  const targetStructureIds = Array.isArray(structureIds) ? structureIds.filter(Boolean) : [];\n\n  return matchUps.filter((matchUp) => {\n    if (readyToScore && matchUp.matchUpType !== TEAM_MATCHUP && !matchUp.readyToScore) return false;\n    if (matchUp.winningSide && hasWinningSide && ![1, 2].includes(matchUp.winningSide)) return false;\n    if (isMatchUpTie !== undefined) {\n      if (isMatchUpTie && !matchUp.tieMatchUps) {\n        return false;\n      }\n      if (!isMatchUpTie && matchUp.tieMatchUps) {\n        return false;\n      }\n    }\n    if (isCollectionMatchUp !== undefined) {\n      if (isCollectionMatchUp && !matchUp.collectionId) {\n        return false;\n      }\n      if (!isCollectionMatchUp && matchUp.collectionId) {\n        return false;\n      }\n    }\n\n    if (targetStages.length && !targetStages.includes(matchUp.stage)) {\n      return false;\n    }\n    if (targetStageSequences.length && !targetStageSequences.includes(matchUp.stageSequence)) {\n      return false;\n    }\n    if (targetCollectionIds.length && (!matchUp.collectionId || !targetCollectionIds.includes(matchUp.collectionId))) {\n      return false;\n    }\n    if (targetRoundNames.length && (!matchUp.roundName || !targetRoundNames.includes(matchUp.roundName))) {\n      return false;\n    }\n    if (targetRoundNumbers.length && (!matchUp.roundNumber || !targetRoundNumbers.includes(matchUp.roundNumber))) {\n      return false;\n    }\n    if (\n      targetRoundPositions.length &&\n      (!matchUp.roundPosition || !targetRoundPositions.includes(matchUp.roundPosition))\n    ) {\n      return false;\n    }\n    if (\n      targetMatchUpStatuses.length &&\n      (!matchUp.matchUpStatus || !targetMatchUpStatuses.includes(matchUp.matchUpStatus))\n    ) {\n      return false;\n    }\n    if (\n      excludeTargetMatchUpStatuses.length &&\n      matchUp.matchUpStatus &&\n      excludeTargetMatchUpStatuses.includes(matchUp.matchUpStatus)\n    ) {\n      return false;\n    }\n    if (targetMatchUpIds.length && !targetMatchUpIds.includes(matchUp.matchUpId)) {\n      return false;\n    }\n    if (targetMatchUpTypes.length && (!matchUp.matchUpType || !targetMatchUpTypes.includes(matchUp.matchUpType))) {\n      return false;\n    }\n    if (\n      targetMatchUpFormats.length &&\n      (!matchUp.matchUpFormat || !targetMatchUpFormats.includes(matchUp.matchUpFormat))\n    ) {\n      return false;\n    }\n\n    if (targetScheduledDates?.length) {\n      const { scheduledTime } = scheduledMatchUpTime({ matchUp });\n      const { scheduledDate: matchUpDate } = scheduledMatchUpDate({ matchUp });\n      const scheduledTimeDate = extractDate(scheduledTime);\n      const comparisonDate = scheduledTimeDate || matchUpDate;\n\n      if (!targetScheduledDates.find((scheduledDate) => sameDay(scheduledDate, comparisonDate))) return false;\n    }\n\n    if (targetCourtIds.length) {\n      const { courtId } = matchUpAssignedCourtId({ matchUp });\n      const { allocatedCourts } = matchUpAllocatedCourts({ matchUp });\n      const allocatedCourtIds = allocatedCourts?.map(({ courtId }) => courtId);\n      if (!targetCourtIds.filter(Boolean).includes(courtId) || allocatedCourtIds?.includes(courtId)) {\n        return false;\n      }\n    }\n\n    if (targetVenueIds.length) {\n      const { venueId } = matchUpAssignedVenueId({ matchUp });\n      if (!targetVenueIds.filter(Boolean).includes(venueId)) {\n        return false;\n      }\n    }\n\n    if (processContext) {\n      if (targetTournamentIds.length && !targetTournamentIds.includes(matchUp.tournamentId)) {\n        return false;\n      }\n\n      if (targetEventIds.length && !targetEventIds.includes(matchUp.eventId)) {\n        return false;\n      }\n\n      if (targetDrawIds.length && !targetDrawIds.includes(matchUp.drawId)) {\n        return false;\n      }\n\n      if (targetStructureIds.length && !targetStructureIds.includes(matchUp.structureId)) {\n        return false;\n      }\n\n      if (targetParticipantIds.length) {\n        const matchUpParticipantIds = matchUp.sides?.map(({ participantId }) => participantId).filter(Boolean) ?? [];\n        const containsTargetedParticipantId = targetParticipantIds.some((participantId) =>\n          matchUpParticipantIds.includes(participantId),\n        );\n        if (!containsTargetedParticipantId) return false;\n      }\n    }\n\n    return true;\n  });\n}\n","import { PositionAssignment, SeedAssignment } from '../../types/tournamentTypes';\n\nexport function getSide({\n  drawPositionCollectionAssignment,\n  sideNumberCollectionAssignment,\n  positionAssignments,\n  displaySideNumber,\n  seedAssignments,\n  drawPosition,\n  isFeedRound,\n  sideNumber,\n}: {\n  positionAssignments: PositionAssignment[];\n  drawPositionCollectionAssignment?: any;\n  sideNumberCollectionAssignment?: any;\n  seedAssignments?: SeedAssignment[];\n  displaySideNumber: number;\n  drawPosition?: number;\n  isFeedRound: boolean;\n  sideNumber: number;\n}) {\n  const assignment = positionAssignments.find(\n    (assignment) => assignment.drawPosition && assignment.drawPosition === drawPosition,\n  );\n  const dpc = drawPosition && drawPositionCollectionAssignment;\n  const snc = sideNumber && sideNumberCollectionAssignment;\n  const participantId = dpc ? dpc[drawPosition]?.participantId : assignment?.participantId;\n\n  const sideValue = assignment\n    ? getSideValue({\n        displaySideNumber,\n        seedAssignments,\n        participantId,\n        assignment,\n        sideNumber,\n      })\n    : { ...snc?.[sideNumber] };\n\n  if (isFeedRound) {\n    if (sideNumber === 1) {\n      Object.assign(sideValue, { participantFed: true });\n    } else {\n      Object.assign(sideValue, { participantAdvanced: true });\n    }\n  }\n\n  if (drawPosition && dpc) {\n    const teamParticipant = dpc[drawPosition]?.teamParticipant;\n    const participant = dpc[drawPosition]?.participant;\n    const substitutions = dpc[drawPosition]?.substitutions;\n    if (participant) sideValue.participant = participant;\n    if (substitutions) sideValue.substitutions = substitutions;\n    if (teamParticipant) sideValue.teamParticipant = teamParticipant;\n  }\n\n  return sideValue;\n}\n\nfunction getSideValue({ displaySideNumber, seedAssignments, participantId, assignment, sideNumber }) {\n  const side = {\n    drawPosition: assignment.drawPosition,\n    displaySideNumber,\n    sideNumber,\n  };\n  if (participantId) {\n    const seeding = getSeeding({ seedAssignments, participantId });\n    Object.assign(side, seeding, { participantId });\n  } else if (assignment.bye) {\n    Object.assign(side, { bye: true });\n  }\n\n  if (assignment.qualifier) {\n    Object.assign(side, { qualifier: true });\n  }\n\n  return side;\n}\n\nfunction getSeeding({ seedAssignments, participantId }) {\n  return seedAssignments?.find((assignment) => !assignment.seedProxy && assignment.participantId === participantId);\n}\n","export const ANY: any = 'ANY';\nexport const MALE: any = 'MALE';\nexport const MIXED: any = 'MIXED';\nexport const OTHER: any = 'OTHER';\nexport const FEMALE: any = 'FEMALE';\n\nexport const genderConstants = {\n  ANY,\n  MALE,\n  FEMALE,\n  MIXED,\n  OTHER,\n};\n","import { getMatchUpsMap, getMappedStructureMatchUps, MatchUpsMap } from './getMatchUpsMap';\nimport { getCollectionAssignment } from './getCollectionAssignment';\nimport { getStructureSeedAssignments } from '../structure/getStructureSeedAssignments';\nimport { getMatchUpCompetitiveProfile } from '../matchUp/getMatchUpCompetitiveProfile';\nimport { getCheckedInParticipantIds } from '../matchUp/getCheckedInParticipantIds';\nimport { structureAssignedDrawPositions } from '../drawDefinition/positionsGetter';\nimport { getMatchUpScheduleDetails } from '../matchUp/getMatchUpScheduleDetails';\nimport { getCollectionPositionMatchUps } from './getCollectionPositionMatchUps';\nimport { resolveTieFormat } from '../hierarchical/tieFormats/resolveTieFormat';\nimport { getSourceDrawPositionRanges } from './getSourceDrawPositionRanges';\nimport { parse } from '../../assemblies/generators/matchUpFormatCode/parse';\nimport { getAppliedPolicies } from '../extensions/getAppliedPolicies';\nimport { getContextContent } from '../hierarchical/getContextContent';\nimport { getOrderedDrawPositions } from './getOrderedDrawPositions';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { getDrawPositionsRanges } from './getDrawPositionsRanges';\nimport { attributeFilter } from '../../utilities/attributeFilter';\nimport { getRoundContextProfile } from './getRoundContextProfile';\nimport { getExitProfiles } from '../drawDefinition/getExitProfile';\nimport { findParticipant } from '../../acquire/findParticipant';\nimport { isConvertableInteger } from '../../utilities/math';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { getMatchUpType } from '../matchUp/getMatchUpType';\nimport { getRoundMatchUps } from './getRoundMatchUps';\nimport { filterMatchUps } from '../filterMatchUps';\nimport { unique } from '../../utilities/arrays';\nimport { getSide } from './getSide';\n\nimport { Participant, Tournament, Event, Structure, DrawDefinition, SeedAssignment } from '../../types/tournamentTypes';\nimport { POLICY_TYPE_PARTICIPANT, POLICY_TYPE_ROUND_NAMING } from '../../constants/policyConstants';\nimport { MISSING_STRUCTURE } from '../../constants/errorConditionConstants';\nimport { QUALIFYING } from '../../constants/drawDefinitionConstants';\nimport { BYE } from '../../constants/matchUpStatusConstants';\nimport { MIXED } from '../../constants/genderConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport { SINGLES } from '../../constants/matchUpTypes';\nimport { TEAM } from '../../constants/eventConstants';\nimport {\n  ContextContent,\n  ContextProfile,\n  ExitProfiles,\n  MatchUpFilters,\n  ParticipantMap,\n  PolicyDefinitions,\n  ScheduleTiming,\n  ScheduleVisibilityFilters,\n} from '../../types/factoryTypes';\n\n/*\n  return all matchUps within a structure and its child structures\n  context is used to pass in additional parameters to be assigned to each matchUp\n*/\n\ntype GetAllStructureMatchUps = {\n  scheduleVisibilityFilters?: ScheduleVisibilityFilters;\n  tournamentAppliedPolicies?: PolicyDefinitions;\n  tournamentParticipants?: Participant[];\n  policyDefinitions?: PolicyDefinitions;\n  seedAssignments?: SeedAssignment[];\n  provisionalPositioning?: boolean;\n  context?: { [key: string]: any };\n  contextContent?: ContextContent;\n  contextFilters?: MatchUpFilters;\n  matchUpFilters?: MatchUpFilters;\n  participantMap?: ParticipantMap;\n  scheduleTiming?: ScheduleTiming;\n  drawDefinition?: DrawDefinition;\n  contextProfile?: ContextProfile;\n  tournamentRecord?: Tournament;\n  afterRecoveryTimes?: boolean;\n  usePublishState?: boolean;\n  exitProfiles?: ExitProfiles;\n  matchUpsMap?: MatchUpsMap;\n  structure?: Structure;\n  publishStatus?: any;\n  inContext?: boolean;\n  event?: Event;\n};\n\nexport function getAllStructureMatchUps({\n  scheduleVisibilityFilters,\n  tournamentAppliedPolicies,\n  provisionalPositioning,\n  tournamentParticipants,\n  afterRecoveryTimes,\n  policyDefinitions,\n  tournamentRecord,\n  seedAssignments,\n  usePublishState,\n  contextFilters,\n  contextContent,\n  matchUpFilters,\n  participantMap,\n  scheduleTiming,\n  contextProfile,\n  drawDefinition,\n  publishStatus,\n  context = {},\n  exitProfiles,\n  matchUpsMap,\n  structure,\n  inContext,\n  event,\n}: GetAllStructureMatchUps) {\n  let collectionPositionMatchUps = {},\n    roundMatchUps = {};\n\n  tournamentParticipants = tournamentParticipants ?? tournamentRecord?.participants;\n\n  if (!structure) {\n    return {\n      collectionPositionMatchUps,\n      error: MISSING_STRUCTURE,\n      roundMatchUps,\n      matchUps: [],\n    };\n  }\n\n  const selectedEventIds = Array.isArray(matchUpFilters?.eventIds) ? matchUpFilters?.eventIds.filter(Boolean) : [];\n\n  const selectedStructureIds = Array.isArray(matchUpFilters?.structureIds)\n    ? matchUpFilters?.structureIds.filter(Boolean)\n    : [];\n\n  const selectedDrawIds = Array.isArray(matchUpFilters?.drawIds) ? matchUpFilters?.drawIds.filter(Boolean) : [];\n\n  const targetEvent =\n    !context?.eventId ||\n    (!selectedEventIds?.length && !contextFilters?.eventIds?.filter(Boolean).length) ||\n    selectedEventIds?.includes(context.eventId) ||\n    contextFilters?.eventIds?.includes(context.eventId);\n  const targetStructure = !selectedStructureIds?.length || selectedStructureIds.includes(structure.structureId);\n  const targetDraw = !drawDefinition || !selectedDrawIds?.length || selectedDrawIds.includes(drawDefinition.drawId);\n\n  // don't process this structure if filters and filters don't include eventId, drawId or structureId\n  if (!targetEvent || !targetStructure || !targetDraw) {\n    return {\n      collectionPositionMatchUps,\n      roundMatchUps,\n      matchUps: [],\n    };\n  }\n\n  if (contextProfile && !contextContent) {\n    contextContent = getContextContent({\n      tournamentRecord,\n      contextProfile,\n      drawDefinition,\n    });\n  }\n\n  // TODO: code is shared with matchUpActions.js\n  // TODO: extend testing to restrict for MAIN while leaving consolation unrestricted\n  const { appliedPolicies: drawAppliedPolicies } = getAppliedPolicies({\n    drawDefinition,\n  });\n  const appliedPolicies = {\n    ...tournamentAppliedPolicies,\n    ...drawAppliedPolicies,\n    ...policyDefinitions,\n  };\n\n  const structureScoringPolicies = appliedPolicies?.scoring?.structures;\n  const stageSpecificPolicies =\n    structure.stage && structureScoringPolicies?.stage && structureScoringPolicies?.stage[structure.stage];\n  const sequenceSpecificPolicies =\n    structure.stageSequence &&\n    stageSpecificPolicies?.stageSequence &&\n    stageSpecificPolicies.stageSequence[structure.stageSequence];\n  const requireAllPositionsAssigned =\n    appliedPolicies?.scoring?.requireAllPositionsAssigned ||\n    stageSpecificPolicies?.requireAllPositionsAssigned ||\n    sequenceSpecificPolicies?.requireAllPositionsAssigned;\n\n  if (!matchUpsMap) {\n    matchUpsMap = getMatchUpsMap({ drawDefinition, structure });\n  }\n\n  const { positionAssignments, allPositionsAssigned } = structureAssignedDrawPositions({ structure });\n  const scoringActive = !requireAllPositionsAssigned || allPositionsAssigned;\n  const { seedAssignments: structureSeedAssignments } = getStructureSeedAssignments({\n    provisionalPositioning,\n    drawDefinition,\n    structure,\n  });\n\n  // enables passing in seedAssignments rather than using structureSeedAssignments\n  seedAssignments = seedAssignments ?? structureSeedAssignments;\n\n  const { roundOffset, structureId, structureName, stage, stageSequence } = structure;\n  const { drawId, drawName, drawType } = drawDefinition ?? {};\n\n  exitProfiles = exitProfiles || (drawDefinition && getExitProfiles({ drawDefinition }).exitProfiles);\n  const exitProfile = exitProfiles?.[structureId];\n  const initialRoundOfPlay =\n    exitProfile?.length &&\n    (exitProfile[0]\n      .split('-')\n      .map((x) => parseInt(x))\n      .reduce((a, b) => a + b) ||\n      0);\n\n  const isRoundRobin = !!structure.structures;\n\n  let matchUps = getMappedStructureMatchUps({\n    matchUpsMap,\n    structureId,\n    inContext,\n  });\n\n  const roundNamingPolicy = appliedPolicies?.[POLICY_TYPE_ROUND_NAMING];\n  const result = getRoundContextProfile({\n    roundNamingPolicy,\n    drawDefinition,\n    structure,\n    matchUps,\n  });\n  const { roundNamingProfile, roundProfile } = result;\n  roundMatchUps = result?.roundMatchUps ?? [];\n\n  // must make a pass before hydration and addition of tieMatchUps\n  if (matchUpFilters) {\n    matchUps = filterMatchUps({\n      matchUps,\n      ...matchUpFilters,\n      filterMatchUpTypes: false,\n      filterMatchUpIds: false,\n    });\n  }\n\n  if (inContext) {\n    const { sourceDrawPositionRanges } = getSourceDrawPositionRanges({\n      drawDefinition,\n      matchUpsMap,\n      structureId,\n    });\n    const drawPositionsRanges = drawDefinition\n      ? getDrawPositionsRanges({\n          drawDefinition,\n          roundProfile,\n          matchUpsMap,\n          structureId,\n        }).drawPositionsRanges\n      : undefined;\n\n    matchUps = matchUps.map((matchUp) => {\n      return addMatchUpContext({\n        scheduleVisibilityFilters,\n        sourceDrawPositionRanges,\n        drawPositionsRanges,\n        roundNamingProfile,\n        initialRoundOfPlay,\n        appliedPolicies,\n        usePublishState,\n        publishStatus,\n        isRoundRobin,\n        roundProfile,\n        matchUp,\n        event,\n      });\n    });\n\n    const matchUpTies = matchUps?.filter((matchUp) => Array.isArray(matchUp.tieMatchUps));\n    matchUpTies.forEach((matchUpTie) => {\n      const tieMatchUps = matchUpTie.tieMatchUps;\n      matchUps = matchUps.concat(...tieMatchUps);\n    });\n\n    if (contextFilters) {\n      matchUps = filterMatchUps({\n        processContext: true,\n        ...contextFilters,\n        matchUps,\n      });\n    }\n  } else {\n    const matchUpTies = matchUps?.filter((matchUp) => Array.isArray(matchUp.tieMatchUps));\n    matchUpTies.forEach((matchUpTie) => {\n      const tieMatchUps = matchUpTie.tieMatchUps;\n      matchUps = matchUps.concat(...tieMatchUps);\n    });\n  }\n\n  // must make a pass after tieMatchUps have been added\n  if (matchUpFilters) {\n    matchUps = filterMatchUps({\n      matchUps,\n      ...matchUpFilters,\n      filterMatchUpTypes: false,\n      filterMatchUpIds: false,\n    });\n  }\n  // now filter again if there are any matchUpTypes or matchUpIds\n  if (matchUpFilters?.matchUpTypes || matchUpFilters?.matchUpIds) {\n    matchUps = filterMatchUps({\n      matchUpTypes: matchUpFilters.matchUpTypes,\n      matchUpIds: matchUpFilters.matchUpIds,\n      matchUps,\n    });\n  }\n\n  if (matchUpFilters?.matchUpTypes || matchUpFilters?.matchUpIds || inContext) {\n    roundMatchUps = getRoundMatchUps({ matchUps }).roundMatchUps ?? [];\n  }\n\n  if (resolveTieFormat({ drawDefinition, structure, event })?.tieFormat) {\n    ({ collectionPositionMatchUps } = getCollectionPositionMatchUps({\n      matchUps,\n    }));\n  }\n\n  return {\n    collectionPositionMatchUps,\n    roundMatchUps,\n    roundProfile,\n    matchUpsMap,\n    matchUps,\n  };\n\n  // isCollectionBye is an attempt to embed BYE status in matchUp.tieMatchUps\n  type AddMatchUpContextArgs = {\n    scheduleVisibilityFilters?: ScheduleVisibilityFilters;\n    additionalContext?: { [key: string]: any };\n    appliedPolicies?: PolicyDefinitions;\n    sourceDrawPositionRanges?: any;\n    initialRoundOfPlay?: number;\n    tieDrawPositions?: number[];\n    drawPositionsRanges?: any;\n    isCollectionBye?: boolean;\n    usePublishState?: boolean;\n    matchUp: HydratedMatchUp;\n    roundNamingProfile?: any;\n    isRoundRobin?: boolean;\n    matchUpTieId?: string;\n    publishStatus?: any;\n    sideLineUps?: any[];\n    roundProfile?: any;\n    event?: Event;\n  };\n\n  function addMatchUpContext({\n    scheduleVisibilityFilters,\n    sourceDrawPositionRanges,\n    drawPositionsRanges,\n    initialRoundOfPlay,\n    additionalContext,\n    roundNamingProfile,\n    tieDrawPositions,\n    appliedPolicies,\n    isCollectionBye,\n    usePublishState,\n    publishStatus,\n    matchUpTieId,\n    isRoundRobin,\n    roundProfile,\n    sideLineUps,\n    matchUp,\n    event,\n  }: AddMatchUpContextArgs) {\n    additionalContext = additionalContext ?? {};\n    const tieFormat = resolveTieFormat({\n      drawDefinition,\n      structure,\n      matchUp,\n      event,\n    })?.tieFormat;\n\n    const collectionDefinitions = tieFormat?.collectionDefinitions;\n    const collectionDefinition =\n      matchUp.collectionId &&\n      collectionDefinitions?.find((definition) => definition.collectionId === matchUp.collectionId);\n\n    const matchUpFormat = matchUp.collectionId\n      ? collectionDefinition?.matchUpFormat\n      : matchUp.matchUpFormat ?? structure?.matchUpFormat ?? drawDefinition?.matchUpFormat ?? event?.matchUpFormat;\n\n    const matchUpType =\n      matchUp.matchUpType ||\n      collectionDefinition?.matchUpType ||\n      structure?.matchUpType ||\n      drawDefinition?.matchUpType ||\n      (event?.eventType !== TEAM && event?.eventType);\n\n    const matchUpStatus = isCollectionBye ? BYE : matchUp.matchUpStatus;\n    const { schedule, endDate } = getMatchUpScheduleDetails({\n      scheduleVisibilityFilters,\n      afterRecoveryTimes,\n      tournamentRecord,\n      usePublishState,\n      scheduleTiming,\n      matchUpFormat,\n      publishStatus,\n      matchUpType,\n      matchUp,\n      event,\n    });\n    const drawPositions: number[] = tieDrawPositions ?? matchUp.drawPositions ?? [];\n    const { collectionPosition, collectionId, roundPosition } = matchUp;\n    const roundNumber = matchUp.roundNumber ?? additionalContext.roundNumber;\n\n    const collectionAssignmentDetail = collectionId\n      ? getCollectionAssignment({\n          tournamentParticipants,\n          positionAssignments,\n          collectionPosition,\n          drawDefinition,\n          participantMap,\n          drawPositions,\n          collectionId,\n          sideLineUps,\n          matchUpType,\n        })\n      : undefined;\n\n    const roundName = roundNamingProfile?.[roundNumber]?.roundName || additionalContext.roundName;\n    const abbreviatedRoundName =\n      roundNamingProfile?.[roundNumber]?.abbreviatedRoundName || additionalContext.abbreviatedRoundName;\n    const feedRound = roundProfile?.[roundNumber]?.feedRound;\n    const preFeedRound = roundProfile?.[roundNumber]?.preFeedRound;\n    const roundFactor = roundProfile?.[roundNumber]?.roundFactor;\n\n    const drawPositionsRoundRanges = drawPositionsRanges?.[roundNumber];\n    const drawPositionsRange = roundPosition ? drawPositionsRoundRanges?.[roundPosition] : undefined;\n    const sourceDrawPositionRoundRanges = sourceDrawPositionRanges?.[roundNumber];\n\n    // if part of a tie matchUp and collectionDefinition has a category definition, prioritize\n    const matchUpCategory = collectionDefinition?.category\n      ? {\n          ...(context?.category || {}),\n          ...collectionDefinition.category,\n        }\n      : context?.category ?? event?.category;\n\n    const processCodes =\n      (matchUp.processCodes?.length && matchUp.processCodes) ||\n      (collectionDefinition?.processCodes?.length && collectionDefinition?.processCodes) ||\n      (structure?.processCodes?.length && structure?.processCodes) ||\n      (drawDefinition?.processCodes?.length && drawDefinition?.processCodes) ||\n      (event?.processCodes?.length && event?.processCodes) ||\n      tournamentRecord?.processCodes;\n\n    const competitiveProfile =\n      contextProfile?.withCompetitiveness && getMatchUpCompetitiveProfile({ ...contextContent, matchUp });\n\n    // necessry for SINGLES/DOUBLES matchUps that are part of TEAM tournaments\n    const finishingPositionRange = matchUp.finishingPositionRange ?? additionalContext.finishingPositionRange;\n\n    // order is important here as Round Robin matchUps already have inContext structureId\n    const onlyDefined = (obj) => definedAttributes(obj, undefined, true);\n    const matchUpWithContext = {\n      ...onlyDefined(context),\n      ...onlyDefined({\n        matchUpFormat: matchUp.matchUpType === TEAM ? undefined : matchUpFormat,\n        tieFormat: matchUp.matchUpType !== TEAM ? undefined : tieFormat,\n        gender: collectionDefinition?.gender ?? event?.gender,\n        roundOfPlay:\n          stage !== QUALIFYING && isConvertableInteger(initialRoundOfPlay) && initialRoundOfPlay + (roundNumber || 0),\n        endDate: matchUp.endDate ?? endDate,\n        discipline: event?.discipline,\n        category: matchUpCategory,\n        finishingPositionRange,\n        abbreviatedRoundName,\n        drawPositionsRange,\n        competitiveProfile,\n        structureName,\n        stageSequence,\n        drawPositions,\n        matchUpStatus,\n        processCodes,\n        isRoundRobin,\n        matchUpTieId,\n        preFeedRound,\n        matchUpType,\n        roundFactor,\n        roundOffset,\n        structureId,\n        roundNumber,\n        feedRound,\n        roundName,\n        drawName,\n        drawType,\n        schedule,\n        drawId,\n        stage,\n      }),\n      ...makeDeepCopy(onlyDefined(matchUp), true, true),\n    };\n\n    if (matchUpFormat && matchUp.score?.scoreStringSide1) {\n      const parsedFormat = parse(matchUpFormat);\n      const { bestOf, finalSetFormat, setFormat } = parsedFormat ?? {};\n      if (finalSetFormat?.tiebreakSet || setFormat?.tiebreakSet || setFormat?.timed) {\n        matchUpWithContext.score.sets = matchUpWithContext.score.sets\n          .sort((a, b) => a.setNumber - b.setNumber)\n          .map((set, i) => {\n            const setNumber = i + 1;\n            if (setNumber === bestOf) {\n              if (finalSetFormat?.tiebreakSet || finalSetFormat?.timed) set.tiebreakSet = true;\n            } else if (setFormat?.tiebreakSet || setFormat?.timed) {\n              set.tiebreakSet = true;\n            }\n            return set;\n          });\n      }\n    }\n\n    if (Array.isArray(drawPositions)) {\n      const { orderedDrawPositions, displayOrder } = getOrderedDrawPositions({\n        drawPositions,\n        roundProfile,\n        roundNumber,\n      });\n\n      const isFeedRound = roundProfile?.[roundNumber]?.feedRound;\n      const reversedDisplayOrder = displayOrder[0] !== orderedDrawPositions[0];\n\n      // ensure there are two sides generated\n      const sideDrawPositions = orderedDrawPositions.concat(undefined, undefined).slice(0, 2);\n\n      const sides = sideDrawPositions.map((drawPosition, index) => {\n        const sideNumber = index + 1;\n        const displaySideNumber = reversedDisplayOrder ? 3 - sideNumber : sideNumber;\n\n        const side = getSide({\n          ...collectionAssignmentDetail,\n          positionAssignments,\n          displaySideNumber,\n          seedAssignments,\n          drawPosition,\n          isFeedRound,\n          sideNumber,\n        });\n\n        const existingSide = matchUp.sides?.find((existing) => existing.sideNumber === sideNumber);\n\n        // drawPositions for consolation structures are offset by the number of fed positions in subsequent rounds\n        // columnPosition gives an ordered position value relative to a single column\n        const columnPosition = roundPosition ? (roundPosition - 1) * 2 + index + 1 : undefined;\n        const sourceDrawPositionRange = columnPosition ? sourceDrawPositionRoundRanges?.[columnPosition] : undefined;\n\n        return onlyDefined({\n          sourceDrawPositionRange,\n          ...existingSide,\n          ...side,\n        });\n      });\n\n      Object.assign(matchUpWithContext, makeDeepCopy({ sides }, true, true));\n    }\n\n    if (tournamentParticipants && matchUpWithContext.sides) {\n      const participantAttributes = appliedPolicies?.[POLICY_TYPE_PARTICIPANT];\n      const getMappedParticipant = (participantId) => {\n        const participant = participantMap?.[participantId]?.participant;\n        return (\n          participant &&\n          attributeFilter({\n            template: participantAttributes?.participant,\n            source: participant,\n          })\n        );\n      };\n      matchUpWithContext.sides.filter(Boolean).forEach((side) => {\n        if (side.participantId) {\n          const participant = makeDeepCopy(\n            getMappedParticipant(side.participantId) ||\n              (tournamentParticipants &&\n                findParticipant({\n                  policyDefinitions: appliedPolicies,\n                  participantId: side.participantId,\n                  tournamentParticipants,\n                  internalUse: true,\n                  contextProfile,\n                })),\n            undefined,\n            true,\n          );\n          if (participant) {\n            if (drawDefinition?.entries) {\n              const entry = drawDefinition.entries.find((entry) => entry.participantId === side.participantId);\n              if (entry?.entryStatus) {\n                participant.entryStatus = entry.entryStatus;\n              }\n              if (entry?.entryStage) {\n                participant.entryStage = entry.entryStage;\n              }\n            }\n            Object.assign(side, { participant });\n          }\n        }\n\n        if (side?.participant?.individualParticipantIds?.length && !side.participant.individualParticipants?.length) {\n          const individualParticipants = side.participant.individualParticipantIds.map((participantId) => {\n            return (\n              getMappedParticipant(participantId) ||\n              (tournamentParticipants &&\n                findParticipant({\n                  policyDefinitions: appliedPolicies,\n                  tournamentParticipants,\n                  internalUse: true,\n                  contextProfile,\n                  participantId,\n                }))\n            );\n          });\n          Object.assign(side.participant, { individualParticipants });\n        }\n      });\n\n      if (!matchUpWithContext.matchUpType) {\n        const { matchUpType } = getMatchUpType({ matchUp: matchUpWithContext });\n        if (matchUpType) Object.assign(matchUpWithContext, { matchUpType });\n      }\n\n      const inferGender =\n        contextProfile?.inferGender &&\n        (!matchUpWithContext.gender || matchUpWithContext.gender === MIXED) &&\n        matchUpWithContext.sides?.length === 2 &&\n        matchUpWithContext.matchUpType !== TEAM;\n\n      if (inferGender) {\n        const sideGenders = matchUpWithContext.sides.map((side) => {\n          if (matchUpWithContext.matchUpType === SINGLES) return side.participant?.person?.sex;\n\n          if (side.participant?.individualParticipants?.length === 2) {\n            const pairGenders = unique(\n              side.participant.individualParticipants.map((participant) => participant.person?.sex),\n            ).filter(Boolean);\n            if (pairGenders.length === 1) return pairGenders[0];\n          }\n        });\n        if (sideGenders.filter(Boolean).length === 2 && unique(sideGenders).length === 1) {\n          const inferredGender = sideGenders[0];\n          matchUpWithContext.inferredGender = inferredGender;\n        }\n      }\n    }\n\n    if (matchUpWithContext.tieMatchUps) {\n      const isCollectionBye = matchUpWithContext.matchUpStatus === BYE;\n      const lineUps = matchUpWithContext.sides?.map(({ participant, drawPosition, sideNumber, lineUp }) => {\n        const teamParticipant = participant?.participantType === TEAM && participant;\n        const teamParticipantValues =\n          teamParticipant &&\n          definedAttributes({\n            participantRoleResponsibilities: teamParticipant.participantRoleResponsibilities,\n            participantOtherName: teamParticipant.participanOthertName,\n            participantName: teamParticipant.participantName,\n            participantId: teamParticipant.participantId,\n            teamId: teamParticipant.teamId,\n          });\n\n        return {\n          teamParticipant: teamParticipantValues,\n          drawPosition,\n          sideNumber,\n          lineUp,\n        };\n      });\n\n      matchUpWithContext.tieMatchUps = matchUpWithContext.tieMatchUps.map((matchUp) => {\n        const matchUpTieId = matchUpWithContext.matchUpId;\n        const finishingPositionRange = matchUpWithContext.finishingPositionRange;\n        const additionalContext = {\n          finishingPositionRange,\n          abbreviatedRoundName,\n          roundNumber,\n          roundName,\n        };\n\n        return addMatchUpContext({\n          tieDrawPositions: drawPositions,\n          scheduleVisibilityFilters,\n          sourceDrawPositionRanges,\n          sideLineUps: lineUps,\n          drawPositionsRanges,\n          initialRoundOfPlay,\n          roundNamingProfile,\n          additionalContext,\n          appliedPolicies,\n          isCollectionBye,\n          usePublishState,\n          publishStatus,\n          matchUpTieId,\n          isRoundRobin,\n          roundProfile,\n          matchUp,\n          event,\n        });\n      });\n    }\n\n    const hasParticipants =\n      matchUpWithContext.sides && matchUpWithContext.sides.filter((side) => side?.participantId).length === 2;\n    const hasNoWinner = !matchUpWithContext.winningSide;\n    const readyToScore = scoringActive && hasParticipants && hasNoWinner;\n    Object.assign(matchUpWithContext, { readyToScore, hasContext: true });\n\n    if (hasParticipants) {\n      const { allParticipantsCheckedIn, checkedInParticipantIds } = getCheckedInParticipantIds({\n        matchUp: matchUpWithContext,\n      });\n\n      Object.assign(matchUpWithContext, {\n        allParticipantsCheckedIn,\n        checkedInParticipantIds,\n      });\n    }\n\n    if (Array.isArray(contextProfile?.exclude)) {\n      // loop through all attributes and delete them from matchUpWithContext\n      contextProfile?.exclude.forEach((attribute) => delete matchUpWithContext[attribute]);\n    }\n\n    return matchUpWithContext;\n  }\n}\n","import { getRoundMatchUps } from './getRoundMatchUps';\nimport { isLucky } from '../drawDefinition/isLucky';\nimport { isAdHoc } from '../drawDefinition/isAdHoc';\n\nimport { POLICY_ROUND_NAMING_DEFAULT } from '../../fixtures/policies/POLICY_ROUND_NAMING_DEFAULT';\nimport { DrawDefinition, Structure } from '../../types/tournamentTypes';\nimport { POLICY_TYPE_ROUND_NAMING } from '../../constants/policyConstants';\nimport { MAIN, QUALIFYING } from '../../constants/drawDefinitionConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport { RoundProfile } from '../../types/factoryTypes';\n\ntype GetRoundContextProfileArgs = {\n  drawDefinition?: DrawDefinition;\n  matchUps: HydratedMatchUp[];\n  roundNamingPolicy: any;\n  structure: Structure;\n};\nexport function getRoundContextProfile({\n  roundNamingPolicy,\n  drawDefinition,\n  structure,\n  matchUps,\n}: GetRoundContextProfileArgs): ResultType & {\n  roundNamingProfile?: {\n    [key: string]: { roundName: string; abbreviatedRoundName: string };\n  };\n  roundMatchUps?: { [roundNumber: string]: HydratedMatchUp[] };\n  roundProfile?: RoundProfile;\n} {\n  const { roundProfile, roundMatchUps } = getRoundMatchUps({ matchUps });\n  const { structureAbbreviation, stage } = structure;\n\n  const isAdHocStructure = isAdHoc({ structure });\n  const isLuckyStructure = isLucky({ structure });\n\n  const isRoundRobin = structure.structures;\n  const roundNamingProfile = {};\n\n  const defaultRoundNamingPolicy =\n    POLICY_ROUND_NAMING_DEFAULT[POLICY_TYPE_ROUND_NAMING];\n\n  const isQualifying = structure.stage === QUALIFYING;\n  const qualifyingStageSequences: number = isQualifying\n    ? Math.max(\n        ...(drawDefinition?.structures ?? [])\n          .filter((structure) => structure.stage === QUALIFYING)\n          .map(({ stageSequence }) => stageSequence ?? 1),\n        0\n      )\n    : 0;\n\n  const preQualifyingSequence =\n    (structure.stageSequence ?? 1) < qualifyingStageSequences\n      ? structure.stageSequence ?? 1\n      : '';\n\n  const preQualifyingAffix = preQualifyingSequence\n    ? roundNamingPolicy?.affixes?.preQualifying ||\n      defaultRoundNamingPolicy.affixes.preQualifying ||\n      ''\n    : '';\n\n  const roundNamingMap =\n    roundNamingPolicy?.roundNamingMap ||\n    defaultRoundNamingPolicy.roundNamingMap ||\n    {};\n\n  const abbreviatedRoundNamingMap =\n    roundNamingPolicy?.abbreviatedRoundNamingMap ||\n    defaultRoundNamingPolicy.abbreviatedRoundNamingMap ||\n    {};\n\n  const preFeedAffix =\n    roundNamingPolicy?.affixes?.preFeedRound ||\n    defaultRoundNamingPolicy.affixes.preFeedRound;\n\n  const roundNumberAffix =\n    roundNamingPolicy?.affixes?.roundNumber ||\n    defaultRoundNamingPolicy.affixes.roundNumber;\n\n  const namingConventions =\n    roundNamingPolicy?.namingConventions ||\n    defaultRoundNamingPolicy.namingConventions;\n  const roundNameFallback = namingConventions.round;\n\n  const stageInitial = stage && stage !== MAIN ? stage[0] : '';\n  const stageConstants =\n    roundNamingPolicy?.stageConstants ||\n    defaultRoundNamingPolicy.stageConstants;\n  const stageIndicator = (stage && stageConstants?.[stage]) || stageInitial;\n  const stageConstant = `${preQualifyingAffix}${stageIndicator}${preQualifyingSequence}`;\n\n  const roundProfileKeys = roundProfile ? Object.keys(roundProfile) : [];\n  const qualifyingAffix =\n    isQualifying && stageConstants?.[QUALIFYING]\n      ? `${stageConstants?.[QUALIFYING]}-`\n      : '';\n\n  if (isRoundRobin || isAdHocStructure || isLuckyStructure) {\n    Object.assign(\n      roundNamingProfile,\n      ...roundProfileKeys.map((key) => {\n        const roundName = `${qualifyingAffix}${roundNameFallback} ${key}`;\n        const abbreviatedRoundName = `${roundNumberAffix}${key}`;\n        return { [key]: { roundName, abbreviatedRoundName } };\n      })\n    );\n  } else {\n    const qualifyingFinishgMap =\n      isQualifying &&\n      (roundNamingPolicy?.qualifyingFinishMap ||\n        defaultRoundNamingPolicy?.qualifyingFinishMap ||\n        {});\n\n    Object.assign(\n      roundNamingProfile,\n      ...roundProfileKeys.map((round) => {\n        if (!roundProfile?.[round]) return;\n        const { matchUpsCount, preFeedRound } = roundProfile[round];\n        const participantsCount = matchUpsCount * 2;\n\n        const sizedRoundName =\n          qualifyingFinishgMap?.[roundProfile?.[round].finishingRound] ||\n          (qualifyingFinishgMap && `${roundNumberAffix}${participantsCount}`) ||\n          roundNamingMap[matchUpsCount] ||\n          `${roundNumberAffix}${participantsCount}`;\n\n        const suffix = preFeedRound ? `-${preFeedAffix}` : '';\n        const profileRoundName = `${sizedRoundName}${suffix}`;\n\n        const roundName = [\n          stageConstant,\n          structureAbbreviation,\n          profileRoundName,\n        ]\n          .filter(Boolean)\n          .join('-');\n\n        const sizedAbbreviation =\n          abbreviatedRoundNamingMap[matchUpsCount] ||\n          `${roundNumberAffix}${participantsCount}`;\n        const profileAbbreviation = `${sizedAbbreviation}${suffix}`;\n        const abbreviatedRoundName = [\n          stageConstant,\n          structureAbbreviation,\n          profileAbbreviation,\n        ]\n          .filter(Boolean)\n          .join('-');\n\n        return { [round]: { abbreviatedRoundName, roundName } };\n      })\n    );\n  }\n\n  return { roundNamingProfile, roundProfile, roundMatchUps };\n}\n","import { chunkArray, generateRange } from '../../utilities/arrays';\nimport { getMappedStructureMatchUps } from './getMatchUpsMap';\nimport { reduceGroupedOrder } from './reduceGroupedOrder';\nimport { findStructure } from '../../acquire/findStructure';\nimport { getRoundMatchUps } from './getRoundMatchUps';\nimport { getRangeString } from './getRangeString';\n\nimport {\n  BOTTOM_UP,\n  CONSOLATION,\n} from '../../constants/drawDefinitionConstants';\nimport {\n  INVALID_STAGE,\n  MISSING_DRAW_DEFINITION,\n  MISSING_STRUCTURE_ID,\n} from '../../constants/errorConditionConstants';\n\nexport function getSourceDrawPositionRanges({\n  drawDefinition,\n  structureId,\n  matchUpsMap,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structureId) return { error: MISSING_STRUCTURE_ID };\n\n  const { structure } = findStructure({ drawDefinition, structureId });\n  if (structure?.stage !== CONSOLATION)\n    return { error: INVALID_STAGE, info: 'Structure is not CONSOLATION stage' };\n\n  const { links } = drawDefinition;\n  const relevantLinks =\n    links?.filter((link) => link.target.structureId === structureId) || [];\n  const sourceStructureIds =\n    relevantLinks?.reduce((sourceStructureIds, link) => {\n      const { structureId: sourceStructureId } = link.source;\n      return sourceStructureIds.includes(sourceStructureId)\n        ? sourceStructureIds\n        : sourceStructureIds.concat(sourceStructureId);\n    }, []) || [];\n  const sourceStructureProfiles = Object.assign(\n    {},\n    ...sourceStructureIds.map((sourceStructureId) => {\n      const structureMatchUps = getMappedStructureMatchUps({\n        structureId: sourceStructureId,\n        matchUpsMap,\n      });\n      const roundMatchUpsResult = getRoundMatchUps({\n        matchUps: structureMatchUps,\n      });\n\n      const roundProfile = roundMatchUpsResult.roundProfile;\n      return { [sourceStructureId]: roundProfile };\n    })\n  );\n\n  const structureMatchUps = getMappedStructureMatchUps({\n    matchUpsMap,\n    structureId,\n  });\n  const { roundProfile: targetStructureProfile } = getRoundMatchUps({\n    matchUps: structureMatchUps,\n  });\n\n  const sourceDrawPositionRanges = {};\n  relevantLinks?.forEach((link) => {\n    const { structureId: sourceStructureId, roundNumber: sourceRoundNumber } =\n      link.source;\n    const {\n      feedProfile,\n      groupedOrder,\n      positionInterleave,\n      roundNumber: targetRoundNumber,\n    } = link.target;\n    const sourceStructureProfile = sourceStructureProfiles[sourceStructureId];\n    const firstRoundDrawPositions = sourceStructureProfile[1]?.drawPositions;\n    const sourceRoundProfile = sourceStructureProfile[sourceRoundNumber];\n    const sourceRoundMatchUpsCount = sourceRoundProfile?.matchUpsCount;\n    if (!sourceRoundMatchUpsCount) return;\n\n    const chunkSize = sourceRoundMatchUpsCount\n      ? firstRoundDrawPositions.length / sourceRoundMatchUpsCount\n      : 0;\n    const targetRoundMatchUpsCount = firstRoundDrawPositions.length / chunkSize;\n    let orderedPositions = firstRoundDrawPositions.slice();\n\n    const sizedGroupOrder = reduceGroupedOrder({\n      roundPositionsCount: orderedPositions.length,\n      groupedOrder,\n    });\n    const groupsCount = sizedGroupOrder?.length || 1;\n    if (groupsCount <= targetRoundMatchUpsCount) {\n      const groupSize = firstRoundDrawPositions.length / groupsCount;\n      const groups = chunkArray(orderedPositions, groupSize);\n      if (feedProfile === BOTTOM_UP) groups.forEach((group) => group.reverse());\n      orderedPositions =\n        (sizedGroupOrder?.length &&\n          sizedGroupOrder?.map((order) => groups[order - 1]).flat()) ||\n        orderedPositions;\n    }\n\n    let drawPositionBlocks = chunkArray(orderedPositions, chunkSize);\n\n    if (!sizedGroupOrder?.length && feedProfile === BOTTOM_UP)\n      drawPositionBlocks.reverse();\n\n    // positionInterleave describes how positions are fed from source to target\n    // In double elimination, for instance:\n    //  - roundNumber: 1 has positions fed top down from source roundNumber: 1\n    //  - roundNumber: 1 has positions fed bottom up from source roundNumber: 2\n    // These TOP_DOWN and BOTTOM_UP feeds are interleaved, e.g. T1, B3, T2, B2, T3, B1\n    // The BOTTOM_UP feed in this example is offset (shifted down) by 1 and reversed\n    if (positionInterleave) {\n      // an array of undefined items\n      const interleave = generateRange(0, positionInterleave.interleave).map(\n        () => undefined\n      );\n      // an array of undefined items. NOTE: new Array(#) does not work in this instance\n      const offset = generateRange(0, positionInterleave.offset).map(\n        () => undefined\n      );\n      drawPositionBlocks = drawPositionBlocks.map((block) => [\n        block,\n        ...interleave,\n      ]);\n      drawPositionBlocks.unshift(offset);\n      drawPositionBlocks = drawPositionBlocks.flat(1);\n      const targetLength =\n        drawPositionBlocks.length - positionInterleave.offset;\n      drawPositionBlocks = drawPositionBlocks.slice(0, targetLength);\n    }\n\n    // build an object with keys [targetRoundnumber][roundPosition]\n    if (!sourceDrawPositionRanges[targetRoundNumber])\n      sourceDrawPositionRanges[targetRoundNumber] = {};\n\n    // drawPositions for consolation structures are offset by the number of fed positions in subsequent rounds\n    // columnPosition gives an ordered position value relative to a single column\n    // when the number of drawPositions is greater than the number of drawPositionBlocks for a given roundNumber\n    // then sourceDrawPositionRanges are being added to a feedRound\n    // targetStructureProfile also has the boolean attribute .feedRound to flag this case\n    const targetRoundProfile = targetStructureProfile?.[targetRoundNumber];\n    const increment = targetRoundProfile?.feedRound ? 2 : 1;\n\n    drawPositionBlocks.forEach((block, index) => {\n      // fed drawPositions are always sideNumber: 1, so when the increment is 2 the columnPosition is always an odd number\n      // because sideNumber: 1 maps to index: 0 in matchUp.drawPositions\n      const columnPosition = 1 + index * increment;\n      if (!sourceDrawPositionRanges[targetRoundNumber][columnPosition]) {\n        sourceDrawPositionRanges[targetRoundNumber][columnPosition] =\n          getRangeString(block);\n      }\n    });\n  });\n\n  return { sourceDrawPositionRanges };\n}\n\n/*\n * function getRangeString(arr) {\n *   if (!Array.isArray(arr)) return '';\n *   const numericArray = arr.filter(isNumeric);\n *   if (!numericArray.length) return '';\n *   const range = unique([Math.min(...numericArray), Math.max(...numericArray)]);\n *   return range.join('-');\n * }\n */\n","import { MatchUpsMap, getMappedStructureMatchUps } from './getMatchUpsMap';\nimport { getRoundMatchUps } from './getRoundMatchUps';\nimport { numericSort } from '../../utilities/sorting';\nimport { getRangeString } from './getRangeString';\nimport {\n  chunkArray,\n  generateRange,\n  groupConsecutiveNumbers,\n  unique,\n} from '../../utilities/arrays';\n\nimport { DrawDefinition } from '../../types/tournamentTypes';\nimport { RoundProfile } from '../../types/factoryTypes';\nimport {\n  MISSING_DRAW_DEFINITION,\n  MISSING_STRUCTURE_ID,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\ntype GetDrawPositionRangesArgs = {\n  drawDefinition: DrawDefinition;\n  roundProfile?: RoundProfile;\n  matchUpsMap: MatchUpsMap;\n  structureId: string;\n};\nexport function getDrawPositionsRanges({\n  drawDefinition,\n  roundProfile,\n  structureId,\n  matchUpsMap,\n}: GetDrawPositionRangesArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structureId) return { error: MISSING_STRUCTURE_ID };\n\n  if (!roundProfile) {\n    const structureMatchUps = getMappedStructureMatchUps({\n      matchUpsMap,\n      structureId,\n    });\n    ({ roundProfile } = getRoundMatchUps({\n      matchUps: structureMatchUps,\n    }));\n\n    if (!roundProfile) return { error: MISSING_VALUE };\n  }\n\n  const firstRoundFirstDrawPosition = Math.min(\n    ...(roundProfile?.[1]?.drawPositions ?? [])\n  );\n  const firstRoundFirstDrawPositionOffset =\n    (firstRoundFirstDrawPosition || 1) - 1;\n\n  const roundNumbers = Object.keys(roundProfile);\n  const drawPositionsRanges = Object.assign(\n    {},\n    ...(roundNumbers || []).map((roundNumber) => {\n      const matchUpsCount = roundProfile?.[roundNumber]?.matchUpsCount;\n      const firstRoundDrawPositions = roundProfile?.[1]?.drawPositions ?? [];\n      const firstRoundDrawPositionsChunks = chunkArray(\n        firstRoundDrawPositions,\n        firstRoundDrawPositions.length / matchUpsCount\n      );\n      const firstRoundDrawPositionsRanges =\n        firstRoundDrawPositionsChunks.map(getRangeString);\n      const firstRoundOffsetDrawPositionsRanges = firstRoundDrawPositionsChunks\n        .map((drawPositions) => {\n          return drawPositions.map(\n            (drawPosition) => drawPosition - firstRoundFirstDrawPositionOffset\n          );\n        })\n        .map(getRangeString);\n\n      const currentRoundDrawPositionChunks = roundNumbers\n        .map((value) => {\n          if (value > roundNumber) return undefined;\n          const drawPositions = roundProfile?.[value]?.drawPositions ?? [];\n          return chunkArray(\n            drawPositions,\n            drawPositions.length / matchUpsCount\n          );\n        })\n        .filter(Boolean);\n\n      const possibleDrawPositions = generateRange(0, matchUpsCount)\n        .map((index) => {\n          return currentRoundDrawPositionChunks\n            .map((chunk) => chunk[index])\n            .flat()\n            .filter(Boolean)\n            .sort(numericSort);\n        })\n        .map((possible) => unique(possible));\n\n      const drawPositionsRanges = possibleDrawPositions.map((possible) => {\n        return groupConsecutiveNumbers(possible).map(getRangeString).join(', ');\n      });\n\n      const roundPositionsMap = Object.assign(\n        {},\n        ...generateRange(0, matchUpsCount).map((index) => {\n          const roundPosition = index + 1;\n          return {\n            [roundPosition]: {\n              firstRoundDrawPositionsRange:\n                firstRoundDrawPositionsRanges[index],\n              firstRoundOffsetDrawPositionsRange:\n                firstRoundOffsetDrawPositionsRanges[index],\n              possibleDrawPositions: possibleDrawPositions[index],\n              drawPositionsRange: drawPositionsRanges[index],\n            },\n          };\n        })\n      );\n\n      return { [roundNumber]: roundPositionsMap };\n    })\n  );\n\n  return { drawPositionsRanges };\n}\n","export function getCollectionPositionMatchUps({ matchUps }) {\n  const collectionPositionMatchUpsArray = matchUps\n    .reduce((collectionPositions, matchUp) => {\n      return !matchUp.collectionPosition ||\n        collectionPositions.includes(matchUp.collectionPosition)\n        ? collectionPositions\n        : collectionPositions.concat(matchUp.collectionPosition);\n    }, [])\n    .map((collectionPosition) => {\n      return {\n        [collectionPosition]: matchUps.filter(\n          (matchUp) => matchUp.collectionPosition === collectionPosition\n        ),\n      };\n    });\n\n  const collectionPositionMatchUps = Object.assign(\n    {},\n    ...collectionPositionMatchUpsArray\n  );\n  return { collectionPositionMatchUps };\n}\n","import { getCollectionPositionAssignments } from '../../mutate/events/getCollectionPositionAssignments';\nimport { getPairedParticipant } from '../participant/getPairedParticipant';\nimport { getTeamLineUp } from '../../mutate/drawDefinitions/getTeamLineUp';\n\nimport { DrawDefinition, Participant, PositionAssignment } from '../../types/tournamentTypes';\nimport { ParticipantMap, Substitution } from '../../types/factoryTypes';\nimport { DOUBLES } from '../../constants/matchUpTypes';\n\ntype GetDrawPositionCollectionAssignmentArgs = {\n  positionAssignments: PositionAssignment[];\n  tournamentParticipants?: Participant[];\n  participantMap?: ParticipantMap;\n  drawDefinition?: DrawDefinition;\n  collectionPosition?: number;\n  drawPositions?: number[];\n  collectionId: string;\n  matchUpType?: string;\n  sideLineUps?: any;\n};\n\ntype TeamCollectionAssignment = {\n  [key: string]: {\n    substitutions: Substitution[];\n    teamParticipant: Participant;\n    participantId?: string;\n  };\n};\n\nexport function getCollectionAssignment({\n  tournamentParticipants,\n  positionAssignments,\n  collectionPosition,\n  drawPositions = [],\n  participantMap,\n  drawDefinition,\n  collectionId,\n  sideLineUps,\n  matchUpType,\n}: GetDrawPositionCollectionAssignmentArgs): {\n  drawPositionCollectionAssignment?: TeamCollectionAssignment;\n  sideNumberCollectionAssignment?: TeamCollectionAssignment;\n} {\n  if (!collectionId || !collectionPosition) return {};\n\n  const getAssignment = ({ attribute, lineUp, teamParticipant }) => {\n    const { assignedParticipantIds, substitutions } = getCollectionPositionAssignments({\n      collectionPosition,\n      collectionId,\n      lineUp,\n    });\n    if (matchUpType === DOUBLES) {\n      if (assignedParticipantIds?.length <= 2) {\n        const pairedParticipantId = participantMap?.[assignedParticipantIds[0]]?.pairIdMap?.[assignedParticipantIds[1]];\n        const pairedParticipant = pairedParticipantId && participantMap[pairedParticipantId]?.participant;\n        const participant =\n          pairedParticipant ||\n          // resort to brute force\n          getPairedParticipant({\n            participantIds: assignedParticipantIds,\n            tournamentParticipants,\n          }).participant;\n\n        const participantId = participant?.participantId;\n        return {\n          [attribute]: { participantId, teamParticipant, substitutions },\n        };\n      } else if (assignedParticipantIds?.length > 2) {\n        return { [attribute]: { teamParticipant, substitutions } };\n      }\n    } else {\n      const participantId = assignedParticipantIds?.[0];\n\n      return (\n        participantId && {\n          [attribute]: { participantId, teamParticipant, substitutions },\n        }\n      );\n    }\n    return undefined;\n  };\n\n  if (!drawPositions?.length) {\n    const sideNumberCollectionAssignment =\n      sideLineUps\n        ?.map((side) => {\n          const { teamParticipant, sideNumber } = side;\n          const lineUp =\n            side.lineUp || getTeamLineUp({ participantId: teamParticipant.teamParticipantId, drawDefinition })?.lineUp;\n\n          return getAssignment({ attribute: sideNumber, lineUp, teamParticipant });\n        })\n        .filter(Boolean) || {};\n    return { sideNumberCollectionAssignment: Object.assign({}, ...sideNumberCollectionAssignment) };\n  }\n\n  const drawPositionCollectionAssignment: any =\n    drawPositions\n      ?.map((drawPosition) => {\n        const teamParticipantId = positionAssignments.find((assignment) => assignment.drawPosition === drawPosition)\n          ?.participantId;\n\n        const side = sideLineUps?.find((lineUp) => lineUp?.drawPosition === drawPosition);\n\n        const teamParticipant =\n          side?.teamParticipant ||\n          (teamParticipantId && participantMap?.[teamParticipantId]?.participant) ||\n          tournamentParticipants?.find(({ participantId }) => participantId === teamParticipantId);\n\n        const lineUp =\n          side?.lineUp ||\n          getTeamLineUp({\n            participantId: teamParticipantId,\n            drawDefinition,\n          })?.lineUp;\n        return getAssignment({ attribute: drawPosition, lineUp, teamParticipant });\n      })\n      .filter(Boolean) || {};\n\n  return { drawPositionCollectionAssignment: Object.assign({}, ...drawPositionCollectionAssignment) };\n}\n","import { allNumeric, noNumeric, overlap } from '../../utilities/arrays';\nimport { ensureInt } from '../../utilities/ensureInt';\nimport { numericSort } from '../../utilities/sorting';\n\nimport { RoundProfile } from '../../types/factoryTypes';\n\ntype GetOrderedDrawPositionsArgs = {\n  roundProfile: RoundProfile;\n  drawPositions: number[];\n  roundNumber: number;\n};\nexport function getOrderedDrawPositions({ drawPositions, roundProfile, roundNumber }: GetOrderedDrawPositionsArgs) {\n  const unassignedDrawPositions = [undefined, undefined];\n\n  if (noNumeric(drawPositions)) {\n    return {\n      orderedDrawPositions: unassignedDrawPositions,\n      displayOrder: unassignedDrawPositions,\n    };\n  }\n\n  const targetRoundProfile = roundProfile?.[roundNumber];\n  const pairedDrawPositions = targetRoundProfile?.pairedDrawPositions;\n  const displayOrder =\n    pairedDrawPositions?.find((pair) => overlap(pair || [], drawPositions.filter(Boolean))) ?? unassignedDrawPositions;\n\n  // ############# IMPORTANT DO NOT CHANGE #################\n  // when both present, drawPositions are always sorted numerically\n  // this holds true even when fed positions encounter each other in later rounds\n  // { sideNumber: 1 } always goes to the lower drawPosition\n  // displayOrder for feedRounds follows this rule...\n  // ...but displayOrder for non-fed rounds must look back to the previous round\n  // previous round lookback is provided by the roundProfile\n  const isFeedRound = targetRoundProfile?.feedRound;\n  if (allNumeric(drawPositions)) {\n    const orderedDrawPositions = [...drawPositions].sort(numericSort); // spread to avoid immutable client data\n\n    return {\n      orderedDrawPositions: orderedDrawPositions.length === 2 ? orderedDrawPositions : displayOrder,\n      displayOrder: isFeedRound ? orderedDrawPositions : displayOrder,\n    };\n  }\n\n  // ############# IMPORTANT DO NOT CHANGE #################\n  // when only one side is present in a feedRound, it is the fed position\n  // and fed positions are always { sideNumber: 1 }\n  if (isFeedRound) {\n    const drawPosition = drawPositions.find((drawPosition) => !isNaN(ensureInt(drawPosition)));\n    const orderedDrawPositions = [drawPosition, undefined];\n    return { orderedDrawPositions, displayOrder: orderedDrawPositions };\n  }\n\n  return { orderedDrawPositions: displayOrder, displayOrder };\n}\n","import { completedMatchUpStatuses } from '../../constants/matchUpStatusConstants';\n\nexport function checkMatchUpIsComplete({ matchUp }) {\n  if (!matchUp) return false;\n  return (\n    completedMatchUpStatuses.includes(matchUp?.matchUpStatus) ||\n    matchUp?.winningSide\n  );\n}\n","import { structureAssignedDrawPositions } from '../drawDefinition/positionsGetter';\nimport { getAllStructureMatchUps } from '../matchUps/getAllStructureMatchUps';\nimport { checkMatchUpIsComplete } from '../matchUp/checkMatchUpIsComplete';\nimport { findStructure } from '../../acquire/findStructure';\n\nimport { DrawDefinition, Event, Participant, Structure, Tournament } from '../../types/tournamentTypes';\nimport { ABANDONED, upcomingMatchUpStatuses } from '../../constants/matchUpStatusConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { MatchUpsMap } from '../matchUps/getMatchUpsMap';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport { TEAM } from '../../constants/matchUpTypes';\nimport {\n  ContextContent,\n  ContextProfile,\n  ExitProfiles,\n  MatchUpFilters,\n  ParticipantMap,\n  PolicyDefinitions,\n  ScheduleTiming,\n  ScheduleVisibilityFilters,\n} from '../../types/factoryTypes';\n\n/*\n  completedMatchUps are those matchUps where a winningSide is defined\n  upcomingMatchUps are those matchUps where both drawPositions are defined\n  ===> If requireParticipants then upcmoingMatchUps require drawPositions to be assigned\n  pendingMatchUps are those matchUps where a drawPosition is undefined\n  *AND* where both drawPositions map to assigned participantIds\n*/\n\ntype GroupsMatchUpsResult = {\n  abandonedMatchUps?: HydratedMatchUp[];\n  completedMatchUps?: HydratedMatchUp[];\n  upcomingMatchUps?: HydratedMatchUp[];\n  pendingMatchUps?: HydratedMatchUp[];\n  byeMatchUps?: HydratedMatchUp[];\n  includesTeamMatchUps?: boolean;\n  structure?: Structure;\n};\n\ntype GetStructureMatchUpsArgs = {\n  scheduleVisibilityFilters?: ScheduleVisibilityFilters;\n  tournamentAppliedPolicies?: PolicyDefinitions;\n  tournamentParticipants?: Participant[];\n  policyDefinitions?: PolicyDefinitions;\n  context?: { [key: string]: any };\n  matchUpFilters?: MatchUpFilters;\n  contextFilters?: MatchUpFilters;\n  contextContent?: ContextContent;\n  participantMap?: ParticipantMap;\n  scheduleTiming?: ScheduleTiming;\n  requireParticipants?: boolean;\n  tournamentRecord?: Tournament;\n  contextProfile?: ContextProfile;\n  drawDefinition?: DrawDefinition;\n  afterRecoveryTimes?: boolean;\n  usePublishState?: boolean;\n  exitProfiles?: ExitProfiles;\n  matchUpsMap?: MatchUpsMap;\n  structure?: Structure;\n  structureId?: string;\n  inContext?: boolean;\n  publishStatus?: any;\n  event?: Event;\n};\n\nexport function getStructureMatchUps({\n  requireParticipants = true,\n  scheduleVisibilityFilters,\n  tournamentAppliedPolicies,\n  tournamentParticipants,\n  afterRecoveryTimes,\n  policyDefinitions,\n  tournamentRecord,\n  usePublishState,\n  matchUpFilters,\n  contextFilters,\n  contextContent,\n  participantMap,\n  scheduleTiming,\n  publishStatus,\n  contextProfile,\n  drawDefinition,\n  exitProfiles,\n  matchUpsMap,\n  structureId,\n  inContext,\n  structure,\n  context,\n  event,\n}: GetStructureMatchUpsArgs): ResultType & GroupsMatchUpsResult {\n  if (!structure && structureId) {\n    ({ structure } = findStructure({ drawDefinition, structureId }));\n  }\n\n  const result = getAllStructureMatchUps({\n    tournamentAppliedPolicies,\n    scheduleVisibilityFilters,\n    tournamentParticipants,\n    afterRecoveryTimes,\n    policyDefinitions,\n    tournamentRecord,\n    usePublishState,\n    matchUpFilters,\n    contextFilters,\n    contextContent,\n    participantMap,\n    scheduleTiming,\n    publishStatus,\n    contextProfile,\n    drawDefinition,\n    exitProfiles,\n    matchUpsMap,\n    structure,\n    inContext,\n    context,\n    event,\n  });\n\n  const abandonedMatchUps: HydratedMatchUp[] = [];\n  const completedMatchUps: HydratedMatchUp[] = [];\n  const upcomingMatchUps: HydratedMatchUp[] = [];\n  const pendingMatchUps: HydratedMatchUp[] = [];\n  const byeMatchUps: HydratedMatchUp[] = [];\n\n  if (result.error) return result;\n  const { matchUps } = result;\n\n  const { assignedPositions } = structureAssignedDrawPositions({ structure });\n  const participantAssignedDrawPositions = assignedPositions\n    ?.filter((assignment) => assignment.participantId)\n    .map((assignment) => assignment.drawPosition);\n\n  let includesTeamMatchUps;\n\n  matchUps\n    .filter((matchUp) => {\n      const teamsMatchUpsOnly = matchUpFilters?.matchUpTypes?.length === 1 && matchUpFilters.matchUpTypes[0] === TEAM;\n      return !(matchUp.matchUpType !== TEAM && teamsMatchUpsOnly);\n    })\n    .forEach((matchUp) => {\n      if (matchUp.matchUpStatus === ABANDONED) {\n        abandonedMatchUps.push(matchUp);\n        return;\n      }\n\n      if (matchUp.matchUpType === TEAM) includesTeamMatchUps = true;\n\n      const isCollectionMatchUp = matchUp.collectionId;\n      const collectionSidesAssigned = isCollectionMatchUp && matchUp.sides?.every((side) => side.participantId);\n\n      const drawPositionsFilled = !isCollectionMatchUp && matchUp.drawPositions?.filter(Boolean).length === 2;\n      const drawPositionsAssigned =\n        !isCollectionMatchUp &&\n        matchUp.drawPositions?.every((drawPosition) => participantAssignedDrawPositions?.includes(drawPosition));\n\n      const byeAssignedDrawPositions = assignedPositions\n        ?.filter((assignment) => assignment.bye)\n        .map((assignment) => assignment.drawPosition);\n\n      const isByeMatchUp =\n        !isCollectionMatchUp &&\n        matchUp.drawPositions?.find((drawPosition) => byeAssignedDrawPositions?.includes(drawPosition));\n\n      const validUpcomingMatchUpStatus = upcomingMatchUpStatuses.includes(matchUp.matchUpStatus);\n      const isUpcomingMatchUp =\n        validUpcomingMatchUpStatus &&\n        (collectionSidesAssigned || (drawPositionsFilled && (!requireParticipants || drawPositionsAssigned)));\n\n      if (isByeMatchUp) return byeMatchUps.push(matchUp);\n      if (checkMatchUpIsComplete({ matchUp })) return completedMatchUps.push(matchUp);\n      if (isUpcomingMatchUp) return upcomingMatchUps.push(matchUp);\n      return pendingMatchUps.push(matchUp);\n    });\n\n  return {\n    includesTeamMatchUps,\n    abandonedMatchUps,\n    completedMatchUps,\n    upcomingMatchUps,\n    pendingMatchUps,\n    byeMatchUps,\n    structure,\n  };\n}\n","import { addParticipantGroupings } from '../../mutate/drawDefinitions/positionGovernor/avoidance/addParticipantGroupings';\nimport { addUpcomingMatchUps } from '../../mutate/drawDefinitions/matchUpGovernor/addUpcomingMatchUps';\nimport { getContextContent } from '../hierarchical/getContextContent';\nimport { getExitProfiles } from '../drawDefinition/getExitProfile';\nimport { MatchUpsMap, getMatchUpsMap } from './getMatchUpsMap';\nimport { getStructureMatchUps } from '../structure/getStructureMatchUps';\nimport { getDrawStructures } from '../../acquire/findStructure';\nimport { filterMatchUps } from '../filterMatchUps';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\n\nimport { GroupsMatchUpsResult } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport {\n  MISSING_DRAW_DEFINITION,\n  STRUCTURE_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\n/*\n  return ALL matchUps within a drawDefinition, regardless of state\n*/\nexport function getAllDrawMatchUps(params): ResultType & {\n  matchUps?: HydratedMatchUp[];\n  matchUpsMap?: MatchUpsMap;\n} {\n  const stack = 'getAllDrawMatchUps';\n  Object.assign(params, { requireParticipants: false });\n\n  const result = getDrawMatchUps(params);\n\n  if (result.error) return decorateResult({ result, stack });\n\n  const {\n    abandonedMatchUps,\n    completedMatchUps,\n    upcomingMatchUps,\n    pendingMatchUps,\n    byeMatchUps,\n    matchUpsMap,\n  } = result;\n\n  const matchUps: HydratedMatchUp[] = (abandonedMatchUps ?? []).concat(\n    ...(completedMatchUps ?? []),\n    ...(upcomingMatchUps ?? []),\n    ...(pendingMatchUps ?? []),\n    ...(byeMatchUps ?? [])\n  );\n\n  return { matchUps, matchUpsMap };\n}\n\nexport function getDrawMatchUps(params): GroupsMatchUpsResult {\n  if (!params?.drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  let { tournamentParticipants, contextContent, matchUpsMap } = params;\n  const {\n    scheduleVisibilityFilters,\n    tournamentAppliedPolicies,\n    requireParticipants,\n    participantsProfile,\n    afterRecoveryTimes,\n    policyDefinitions,\n    tournamentRecord,\n    usePublishState,\n    contextFilters,\n    matchUpFilters,\n    scheduleTiming,\n    participantMap,\n    publishStatus,\n    contextProfile,\n    drawDefinition,\n    nextMatchUps,\n    inContext,\n    context,\n    event,\n  } = params;\n\n  let allAbandonedMatchUps: HydratedMatchUp[] = [];\n  let allCompletedMatchUps: HydratedMatchUp[] = [];\n  let allUpcomingMatchUps: HydratedMatchUp[] = [];\n  let allPendingMatchUps: HydratedMatchUp[] = [];\n  let allByeMatchUps: HydratedMatchUp[] = [];\n\n  if (contextProfile && !contextContent) {\n    contextContent = getContextContent({\n      policyDefinitions,\n      tournamentRecord,\n      contextProfile,\n      event,\n    });\n  }\n\n  // getParticipants() calls allEventMatchUps()\n  // ...so participants must be sourced directly from tournamentRecord\n  // ...and groupings must be added independent of that\n\n  let groupInfo;\n  if (!tournamentParticipants?.length && tournamentRecord) {\n    tournamentParticipants = tournamentRecord?.participants;\n\n    if (\n      (inContext || participantsProfile?.withGroupings) &&\n      tournamentParticipants?.length\n    ) {\n      ({ participantsWithGroupings: tournamentParticipants, groupInfo } =\n        addParticipantGroupings({\n          participants: tournamentParticipants,\n          participantsProfile,\n        }));\n    }\n  }\n\n  const { structures } = getDrawStructures({ drawDefinition });\n  if (!structures) return { error: STRUCTURE_NOT_FOUND };\n\n  if (!matchUpsMap) {\n    matchUpsMap = getMatchUpsMap({ drawDefinition });\n  }\n\n  // TODO: get QUALIFYING/MAIN { stageSequence: 1 } seedAssignments\n  // ...optionally pass these seedAssignments to other stage structures\n\n  const exitProfiles =\n    drawDefinition && getExitProfiles({ drawDefinition }).exitProfiles;\n\n  structures.forEach((structure) => {\n    const {\n      byeMatchUps = [],\n      pendingMatchUps = [],\n      upcomingMatchUps = [],\n      completedMatchUps = [],\n      abandonedMatchUps = [],\n    } = getStructureMatchUps({\n      // if nextMatchUps then the filters can't be applied at this level\n      matchUpFilters: !nextMatchUps ? matchUpFilters : undefined,\n      contextFilters: !nextMatchUps ? contextFilters : undefined,\n      inContext: inContext || nextMatchUps || contextFilters,\n      tournamentAppliedPolicies,\n      scheduleVisibilityFilters,\n      tournamentParticipants,\n      requireParticipants,\n      afterRecoveryTimes,\n      policyDefinitions,\n      tournamentRecord,\n      usePublishState,\n      contextContent,\n      participantMap,\n      scheduleTiming,\n      publishStatus,\n      contextProfile,\n      drawDefinition,\n      exitProfiles,\n      matchUpsMap,\n      structure,\n      context,\n      event,\n    });\n\n    allAbandonedMatchUps = allAbandonedMatchUps.concat(...abandonedMatchUps);\n    allCompletedMatchUps = allCompletedMatchUps.concat(...completedMatchUps);\n    allUpcomingMatchUps = allUpcomingMatchUps.concat(...upcomingMatchUps);\n    allPendingMatchUps = allPendingMatchUps.concat(...pendingMatchUps);\n    allByeMatchUps = allByeMatchUps.concat(...byeMatchUps);\n  });\n\n  // only apply this filter if filters haven't already been applied\n  const applyFilter = (matchUps) => {\n    if (!matchUpFilters && !nextMatchUps && !contextFilters) return matchUps;\n    if (matchUpFilters) {\n      matchUps = filterMatchUps({ matchUps, ...matchUpFilters });\n    }\n    if (contextFilters) {\n      matchUps = filterMatchUps({\n        matchUps,\n        ...contextFilters,\n        processContext: true,\n      });\n    }\n    return matchUps;\n  };\n\n  const drawMatchUpsResult = {\n    abandonedMatchUps: applyFilter(allAbandonedMatchUps),\n    completedMatchUps: applyFilter(allCompletedMatchUps),\n    upcomingMatchUps: applyFilter(allUpcomingMatchUps),\n    pendingMatchUps: applyFilter(allPendingMatchUps),\n    byeMatchUps: applyFilter(allByeMatchUps),\n    matchUpsMap,\n    ...SUCCESS,\n    groupInfo,\n  };\n\n  if (nextMatchUps) {\n    const nextFilter: any = typeof nextMatchUps === 'object' || {\n      abandoned: true,\n      completed: true,\n      upcoming: true,\n      pending: true,\n      bye: true,\n    };\n    const { abandoned, completed, upcoming, pending, bye } = nextFilter;\n    const matchUps = [].concat(\n      ...((abandoned && allAbandonedMatchUps) || []),\n      ...((completed && allCompletedMatchUps) || []),\n      ...((upcoming && allUpcomingMatchUps) || []),\n      ...((pending && allPendingMatchUps) || []),\n      ...((bye && allByeMatchUps) || [])\n    );\n    addUpcomingMatchUps({\n      inContextDrawMatchUps: matchUps,\n      drawDefinition,\n    });\n  }\n\n  return drawMatchUpsResult;\n}\n","import { hydrateParticipants } from '../participants/hydrateParticipants';\nimport { getAllDrawMatchUps } from './drawMatchUps';\nimport { getContextContent } from '../hierarchical/getContextContent';\n\nimport { GetMatchUpsArgs } from '../../types/factoryTypes';\n\nexport function allDrawMatchUps(params: GetMatchUpsArgs) {\n  let {\n    participants: tournamentParticipants,\n    participantMap,\n    contextContent,\n  } = params;\n\n  const {\n    scheduleVisibilityFilters,\n    tournamentAppliedPolicies,\n    participantsProfile,\n    afterRecoveryTimes,\n    policyDefinitions,\n    useParticipantMap,\n    tournamentRecord,\n    contextFilters,\n    contextProfile,\n    drawDefinition,\n    matchUpFilters,\n    nextMatchUps,\n    inContext,\n    context,\n    event,\n  } = params;\n\n  const { eventId, eventName, eventType, category, gender, matchUpFormat } =\n    event ?? {};\n  const additionalContext = {\n    ...context,\n    eventId,\n    eventType,\n    eventName,\n    category,\n    gender,\n    matchUpFormat,\n    indoorOutDoor: event?.indoorOutdoor ?? tournamentRecord?.indoorOutdoor,\n    surfaceCategory:\n      event?.surfaceCategory ?? tournamentRecord?.surfaceCategory,\n    endDate: event?.endDate,\n  };\n\n  let groupInfo;\n  if (!tournamentParticipants?.length && !participantMap && tournamentRecord) {\n    ({\n      participants: tournamentParticipants = [],\n      participantMap,\n      groupInfo,\n    } = hydrateParticipants({\n      participantsProfile,\n      useParticipantMap,\n      policyDefinitions,\n      tournamentRecord,\n      contextProfile,\n      inContext,\n    }));\n  }\n\n  if (contextProfile && !contextContent) {\n    contextContent = getContextContent({\n      policyDefinitions,\n      tournamentRecord,\n      contextProfile,\n      drawDefinition,\n      event,\n    });\n  }\n\n  const allDrawMatchUpsResult = getAllDrawMatchUps({\n    context: additionalContext,\n    tournamentAppliedPolicies,\n    scheduleVisibilityFilters,\n    tournamentParticipants,\n    participantsProfile,\n    afterRecoveryTimes,\n    policyDefinitions,\n    tournamentRecord,\n    drawDefinition,\n    contextContent,\n    contextFilters,\n    contextProfile,\n    matchUpFilters,\n    participantMap,\n    nextMatchUps,\n    inContext,\n    event,\n  });\n\n  return { ...allDrawMatchUpsResult, groupInfo };\n}\n","import { decorateResult } from '../../global/functions/decorateResult';\nimport { getAllStructureMatchUps } from '../matchUps/getAllStructureMatchUps';\nimport { DrawDefinition, MatchUp } from '../../types/tournamentTypes';\nimport { findStructure } from '../../acquire/findStructure';\n\nimport { MatchUpsMap } from '../matchUps/getMatchUpsMap';\nimport {\n  RoundMatchUpsResult,\n  getRoundMatchUps,\n} from '../matchUps/getRoundMatchUps';\n\ntype GetStructureRoundProfileArgs = {\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  structureId: string;\n};\n\nexport function getStructureRoundProfile({\n  drawDefinition,\n  matchUpsMap,\n  structureId,\n}: GetStructureRoundProfileArgs): RoundMatchUpsResult & {\n  matchUps?: MatchUp[];\n  matchUpsMap?: any;\n} {\n  const result = findStructure({\n    drawDefinition,\n    structureId,\n  });\n  if (result.error) return decorateResult({ result });\n\n  // DEV-NOTE cannot pass drawDefinition parameter in this scenario; callstack error\n  const { matchUps } = getAllStructureMatchUps({\n    structure: result.structure,\n    matchUpsMap,\n  });\n\n  return { ...getRoundMatchUps({ matchUps }), matchUps, matchUpsMap };\n}\n","import { getStructureRoundProfile } from '../../../query/structure/getStructureRoundProfile';\nimport { generateRange, unique } from '../../../utilities/arrays';\n\nexport function getFinishingPositionSourceRoundsMap({\n  finishingPositions,\n  drawDefinition,\n  structureId,\n}) {\n  const { roundProfile } = getStructureRoundProfile({\n    drawDefinition,\n    structureId,\n  });\n\n  const roundNumbers = roundProfile && Object.keys(roundProfile);\n  return roundNumbers?.reduce((sourceRounds, roundNumber) => {\n    const rangeDefinitions = roundValues(roundProfile?.[roundNumber]);\n    rangeDefinitions.forEach((rangeDefinition) => {\n      finishingPositions.forEach((position) => {\n        if (positionIsInRange({ position, rangeDefinition })) {\n          sourceRounds[position] = { roundNumber };\n        }\n      });\n    });\n    return sourceRounds;\n  }, {});\n}\n\nexport function positionIsInRange({ position, rangeDefinition }) {\n  if (!Array.isArray(rangeDefinition)) return false;\n  if (\n    rangeDefinition.reduce(\n      (includesNonInteger, i) => includesNonInteger || isNaN(i),\n      false\n    )\n  )\n    return false;\n  const [min, max] = rangeDefinition;\n  const positionsInRange = generateRange(min, (max || min) + 1);\n  return positionsInRange.includes(position);\n}\n\n// extracts winner and loser rangeDefinitions\nexport function roundValues(values) {\n  return [\n    unique(values?.finishingPositionRange?.loser || []),\n    unique(values?.finishingPositionRange?.winner || []),\n  ];\n}\n\nexport function roundValueRanges(values) {\n  return roundValues(values).map((arr) =>\n    generateRange(arr[0], (arr[1] && arr[1] + 1) || arr[0] + 1)\n  );\n}\n","import { getStructureRoundProfile } from '../../../query/structure/getStructureRoundProfile';\nimport { numericSort } from '../../../utilities/sorting';\nimport { roundValueRanges } from './structureUtils';\nimport { unique } from '../../../utilities/arrays';\n\nimport { MatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { QUALIFYING } from '../../../constants/drawDefinitionConstants';\nimport { DrawDefinition } from '../../../types/tournamentTypes';\nimport {\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n} from '../../../constants/errorConditionConstants';\n\n// NOTE: positionsNotPlayedOff may not be accurate when structureIds are are provided\ntype GetPositionsPlayedOff = {\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  structureIds?: string[];\n};\nexport function getPositionsPlayedOff({\n  drawDefinition,\n  structureIds,\n  matchUpsMap,\n}: GetPositionsPlayedOff) {\n  if (structureIds && !Array.isArray(structureIds))\n    return { error: INVALID_VALUES, context: { structureIds } };\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  structureIds =\n    structureIds ??\n    (drawDefinition.structures ?? [])\n      .filter((structure) => structure.stage !== QUALIFYING)\n      .map(({ structureId }) => structureId);\n\n  const allFinishingPositionRanges = structureIds\n    .map((structureId) => {\n      const { roundProfile } = getStructureRoundProfile({\n        drawDefinition,\n        matchUpsMap,\n        structureId,\n      });\n      const values = roundProfile && Object.values(roundProfile);\n      return values?.map(roundValueRanges).flat();\n    })\n    .flat();\n\n  const positionsPlayedOff = allFinishingPositionRanges\n    .filter((positionRange) => positionRange?.length === 1)\n    .sort(numericSort)\n    .flat();\n\n  const allRangeValues = unique(allFinishingPositionRanges.flat());\n  const positionsNotPlayedOff = allRangeValues.filter(\n    (position) => !positionsPlayedOff.includes(position)\n  );\n\n  return {\n    positionsNotPlayedOff,\n    positionsPlayedOff,\n  };\n}\n","import { getStructureRoundProfile } from '../../../query/structure/getStructureRoundProfile';\nimport { getFinishingPositionSourceRoundsMap } from './structureUtils';\nimport { getPositionsPlayedOff } from './getPositionsPlayedOff';\nimport { generateRange } from '../../../utilities/arrays';\nimport { numericSort } from '../../../utilities/sorting';\nimport { ensureInt } from '../../../utilities/ensureInt';\n\nimport { DrawDefinition } from '../../../types/tournamentTypes';\nimport { RoundProfile } from '../../../types/factoryTypes';\nimport {\n  ErrorType,\n  MISSING_DRAW_DEFINITION,\n  MISSING_STRUCTURE_ID,\n  MISSING_VALUE,\n} from '../../../constants/errorConditionConstants';\n\ntype GetSourceRoundsArgs = {\n  excludeRoundNumbers?: number[];\n  drawDefinition: DrawDefinition;\n  playoffPositions?: number[];\n  structureId: string;\n};\n\ntype SourceRoundsResult = {\n  playoffPositionsReturned?: number[];\n  playedOffSourceRounds?: number[];\n  playoffSourceRounds?: number[];\n  playoffRoundsRanges?: any;\n  roundProfile?: RoundProfile;\n  sourceRounds?: number[];\n  error?: ErrorType;\n  info?: string;\n};\n\nexport function getSourceRounds({\n  excludeRoundNumbers = [],\n  playoffPositions = [],\n  drawDefinition,\n  structureId,\n}: GetSourceRoundsArgs): SourceRoundsResult {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structureId) return { error: MISSING_STRUCTURE_ID };\n  if (!playoffPositions) return { error: MISSING_VALUE, info: 'missing playoffPositions' };\n\n  // NOTE: in this instance do not pass in structureIds\n  const result = getPositionsPlayedOff({ drawDefinition });\n\n  if (result.error) return result;\n  const positionsPlayedOff = result.positionsPlayedOff;\n\n  // filter out playoff positions which are already being played off\n  const relevantPlayoffPositions = playoffPositions.filter((position) => !positionsPlayedOff.includes(position));\n\n  // get a map of which rounds produce which finishingPositions for positions\n  // which are relevant, e.g. aren't already playedoff positions in current structure\n  const playoffPositionSourceRoundsMap: any = getFinishingPositionSourceRoundsMap({\n    finishingPositions: relevantPlayoffPositions,\n    drawDefinition,\n    structureId,\n  });\n\n  // reduce the sourceRoundsMap to roundNumbers, not including excludedRoundNumbers\n  const keys: any[] = Object.values(playoffPositionSourceRoundsMap);\n  const relevantPlayoffSourceRounds: any = keys\n    .reduce((rounds: any[], round: any) => {\n      return rounds.includes(round.roundNumber) ? rounds : rounds.concat(round.roundNumber);\n    }, [])\n    .map((roundNumber) => ensureInt(roundNumber))\n    .filter((roundNumber) => !excludeRoundNumbers.includes(roundNumber));\n\n  // generate a map of finishingPosition: { roundNumber }\n  const playedOffRoundsMap = getFinishingPositionSourceRoundsMap({\n    finishingPositions: positionsPlayedOff,\n    drawDefinition,\n    structureId,\n  });\n\n  // determine which rounds produced played off positions\n  const roundsMapValues: any[] = playedOffRoundsMap ? Object.values(playedOffRoundsMap) : [];\n  const playedOffSourceRounds = playedOffRoundsMap\n    ? roundsMapValues\n        .reduce((rounds: any[], round: any) => {\n          return rounds.includes(round.roundNumber) ? rounds : rounds.concat(round.roundNumber);\n        }, [])\n        .map((round) => ensureInt(round))\n    : [];\n\n  // available playoffSourceRounds are those relevantPlayoffSourceRounds which are not included in playoffSourceRounds\n  const playoffSourceRounds = relevantPlayoffSourceRounds\n    .filter((roundNumber) => !playedOffSourceRounds.includes(roundNumber))\n    .sort(numericSort);\n\n  const { roundProfile } = getStructureRoundProfile({\n    drawDefinition,\n    structureId,\n  });\n\n  const playoffPositionsReturned = playoffSourceRounds\n    .map((round) => {\n      const rangeDefinition = roundProfile?.[round].finishingPositionRange.loser;\n      const [min, max] = rangeDefinition ?? [0, 0];\n      return generateRange(min, (max || min) + 1);\n    })\n    .flat()\n    .sort(numericSort);\n\n  const { playoffRoundsRanges } = getPlayoffRoundsRanges({\n    playoffSourceRounds,\n    roundProfile,\n  });\n\n  const sourceRounds = [...playoffSourceRounds, ...playedOffSourceRounds];\n\n  return {\n    playoffPositionsReturned,\n    playedOffSourceRounds,\n    playoffRoundsRanges,\n    playoffSourceRounds,\n    sourceRounds,\n    roundProfile,\n  };\n}\n\nexport function getPlayoffRoundsRanges({ playoffSourceRounds, roundProfile }) {\n  const playoffRoundsRanges = playoffSourceRounds.map((roundNumber) => {\n    const rangeDefinition = roundProfile[roundNumber].finishingPositionRange.loser;\n    const [min, max] = rangeDefinition;\n    const finishingPositions = generateRange(min, (max || min) + 1);\n    return {\n      finishingPositionRange: rangeDefinition.join('-'),\n      finishingPositions,\n      roundNumber,\n    };\n  });\n  return { playoffRoundsRanges };\n}\n","import { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { allDrawMatchUps } from '../../../query/matchUps/getAllDrawMatchUps';\nimport { getStructureLinks } from '../../../query/drawDefinition/linkGetter';\nimport { chunkArray, generateRange } from '../../../utilities/arrays';\nimport { getDrawStructures } from '../../../acquire/findStructure';\nimport { getPositionsPlayedOff } from './getPositionsPlayedOff';\nimport { numericSort } from '../../../utilities/sorting';\nimport { getSourceRounds } from './getSourceRounds';\n\nimport { MISSING_DRAW_DEFINITION } from '../../../constants/errorConditionConstants';\nimport { DrawDefinition } from '../../../types/tournamentTypes';\nimport { CONTAINER, FIRST_MATCHUP, VOLUNTARY_CONSOLATION } from '../../../constants/drawDefinitionConstants';\n\ntype GetAvailablePlayoffProfileArgs = {\n  drawDefinition: DrawDefinition;\n  structureId?: string;\n};\n\nexport function getAvailablePlayoffProfiles({ drawDefinition, structureId }: GetAvailablePlayoffProfileArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const { matchUps, matchUpsMap } = allDrawMatchUps({\n    inContext: true,\n    drawDefinition,\n  });\n\n  // positions which are being played off by existing structure(s)\n  const { positionsNotPlayedOff, positionsPlayedOff } = getPositionsPlayedOff({\n    drawDefinition,\n    matchUpsMap,\n  });\n\n  const { structures } = getDrawStructures({ drawDefinition });\n  const filteredStructures = structures.filter(\n    (structure) => (!structureId && structure.stage !== VOLUNTARY_CONSOLATION) || structure.structureId === structureId,\n  );\n\n  const available = {};\n\n  for (const structure of filteredStructures) {\n    const structureId = structure?.structureId;\n    const result = availablePlayoffProfiles({\n      playoffPositions: positionsNotPlayedOff,\n      drawDefinition,\n      structure,\n      matchUps,\n    });\n    const { error, ...values } = result;\n    if (error) return result;\n\n    available[structureId] = {\n      structureId,\n      ...values,\n    };\n  }\n\n  if (structureId) {\n    return { positionsPlayedOff, ...available[structureId] };\n  } else {\n    return {\n      availablePlayoffProfiles: Object.values(available),\n      availablePlayoffRounds: Object.values(available), // to be deprecated\n      positionsPlayedOff,\n    };\n  }\n}\n\nfunction availablePlayoffProfiles({ playoffPositions, drawDefinition, structure, matchUps }) {\n  const structureId = structure?.structureId;\n  const { links } = getStructureLinks({ drawDefinition, structureId });\n\n  if (structure.structureType === CONTAINER || structure.structures) {\n    const positionsCount = getPositionAssignments({ structure })?.positionAssignments?.length;\n\n    const groupCount = structure.structures.length;\n    const groupSize = (positionsCount ?? 0) / groupCount;\n    const finishingPositionsPlayedOff = links.source?.flatMap(({ source }) => source?.finishingPositions || []) || [];\n    const finishingPositionsAvailable = generateRange(1, groupSize + 1).filter(\n      (n) => !finishingPositionsPlayedOff.includes(n),\n    );\n    const positionRange = matchUps.find((m) => m.containerStructureId === structureId && m.finishingPositionRange)\n      ?.finishingPositionRange?.winner || [0, 1];\n    const targetStructureIds = links?.source.map(({ target }) => target.structureId);\n    const { positionsPlayedOff, positionsNotPlayedOff } = getPositionsPlayedOff({\n      structureIds: targetStructureIds,\n      drawDefinition,\n    });\n    const positionsInTargetStructures = [...(positionsPlayedOff ?? []), ...positionsNotPlayedOff];\n    const availablePlayoffPositions = generateRange(positionRange[0], positionRange[1] + 1).filter(\n      (position) => !positionsInTargetStructures.includes(position),\n    );\n\n    const positionChunks = chunkArray(\n      availablePlayoffPositions,\n      availablePlayoffPositions.length / finishingPositionsAvailable.length,\n    );\n\n    const playoffFinishingPositionRanges = finishingPositionsAvailable.map((finishingPosition, i) => {\n      const finishingPositions = positionChunks[i];\n      const finishingPositionRange = [\n        Math.min(...(finishingPositions || [])),\n        Math.max(...(finishingPositions || [])),\n      ].join('-');\n      return {\n        finishingPosition,\n        finishingPositions,\n        finishingPositionRange,\n      };\n    });\n\n    return {\n      // positionNotPlayefOff cannot include positions not playedOff by existing playoff structures which branch from source ROUND_ROBIN\n      // e.g. if finishingPosition: 1 of each RR group already feeds a playoff structure, all the position which feed that structure are\n      // not available to be played off from the source ROUND_ROBIN structure.\n      positionsNotPlayedOff: availablePlayoffPositions,\n      playoffFinishingPositionRanges,\n      finishingPositionsAvailable,\n      finishingPositionsPlayedOff,\n      positionsPlayedOff,\n      groupCount,\n      groupSize,\n    };\n  }\n\n  const linkSourceRoundNumbers =\n    links?.source?.filter((link) => link.linkCondition !== FIRST_MATCHUP).map((link) => link.source?.roundNumber) || [];\n  const potentialFirstMatchUpRounds =\n    links?.source?.filter((link) => link.linkCondition === FIRST_MATCHUP).map((link) => link.source?.roundNumber) || [];\n\n  const sourceRoundsResult: any = getSourceRounds({\n    excludeRoundNumbers: linkSourceRoundNumbers,\n    playoffPositions,\n    drawDefinition,\n    structureId,\n  });\n\n  const playoffRounds = sourceRoundsResult?.playoffSourceRounds\n    ? [...(sourceRoundsResult?.playoffSourceRounds || [])]\n    : undefined;\n  const playoffRoundsRanges = [...(sourceRoundsResult?.playoffRoundsRanges || [])];\n\n  const { roundProfile, error } = sourceRoundsResult;\n  for (const roundNumber of potentialFirstMatchUpRounds) {\n    // sourceRounds will only include roundNumbers in the case of FMLC\n    // because it should still be possible to generate 3-4 playoffs even if 2nd round losers lost in the 1st round\n    // but 3-4 playoffs should not be possible to generate if there are not at least 2 matchUps where players COULD progress\n    const link = links?.source.find((link) => link.source.roundNumber === roundNumber);\n    const targetRoundNumber = link?.target.roundNumber;\n    const targetStructureId = link?.target.structureId;\n    const targetRoundMatchUps = matchUps.filter(\n      ({ roundNumber, structureId }) => structureId === targetStructureId && roundNumber === targetRoundNumber,\n    );\n    const availableToProgress = targetRoundMatchUps.filter(({ sides }) =>\n      sides.find((side) => side.participantFed && !side.participantId),\n    ).length;\n\n    if (playoffRounds && availableToProgress === targetRoundMatchUps.length) {\n      playoffRounds.push(roundNumber);\n      const loser = roundProfile?.[roundNumber]?.finishingPositionRange?.loser;\n      if (loser) {\n        const minFinishingPosition = Math.min(...loser);\n        const maxFinishingPosition = minFinishingPosition + availableToProgress;\n        const finishingPositions = generateRange(minFinishingPosition, maxFinishingPosition);\n        const roundsRange = {\n          finishingPositionRange: [minFinishingPosition, maxFinishingPosition - 1].join('-'),\n          finishingPositions,\n          roundNumber,\n        };\n        playoffRoundsRanges.push(roundsRange);\n      }\n    }\n  }\n\n  if (playoffRounds) playoffRounds.sort(numericSort);\n  playoffRoundsRanges.sort((a, b) => a.roundNumber - b.roundNumber);\n\n  return { playoffRounds, playoffRoundsRanges, error };\n}\n","import { addNotice, deleteNotice } from '../../global/state/globalState';\nimport { getPositionAssignments } from '../../query/drawDefinition/positionsGetter';\n\nimport { DrawDefinition, MatchUp } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ADD_DRAW_DEFINITION,\n  ADD_MATCHUPS,\n  DELETED_DRAW_IDS,\n  DELETED_MATCHUP_IDS,\n  MODIFY_DRAW_DEFINITION,\n  MODIFY_MATCHUP,\n  MODIFY_POSITION_ASSIGNMENTS,\n  MODIFY_SEED_ASSIGNMENTS,\n  UPDATE_INCONTEXT_MATCHUP,\n} from '../../constants/topicConstants';\nimport {\n  ErrorType,\n  MISSING_DRAW_DEFINITION,\n  MISSING_MATCHUP,\n  MISSING_STRUCTURE,\n} from '../../constants/errorConditionConstants';\n\nfunction drawUpdatedAt(\n  drawDefinition: DrawDefinition,\n  structureIds?: string[]\n) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  let timeStamp = Date.now();\n  if (\n    drawDefinition.updatedAt &&\n    timeStamp === new Date(drawDefinition.updatedAt).getTime()\n  )\n    timeStamp += 1;\n  const updatedAt = new Date(timeStamp).toISOString();\n\n  const relevantStructureIds = structureIds?.filter(Boolean);\n\n  drawDefinition.updatedAt = updatedAt;\n  drawDefinition.structures?.filter(Boolean).forEach((structure) => {\n    if (\n      !relevantStructureIds?.length ||\n      relevantStructureIds?.includes(structure.structureId)\n    ) {\n      structure.updatedAt = updatedAt;\n    }\n  });\n\n  return { ...SUCCESS };\n}\n\ntype AddMatchUpsNoticeArgs = {\n  drawDefinition?: DrawDefinition;\n  tournamentId?: string;\n  matchUps: MatchUp[];\n  eventId?: string;\n};\nexport function addMatchUpsNotice({\n  drawDefinition,\n  tournamentId,\n  matchUps,\n  eventId,\n}: AddMatchUpsNoticeArgs) {\n  if (drawDefinition) drawUpdatedAt(drawDefinition);\n  addNotice({\n    payload: { matchUps, tournamentId, eventId },\n    topic: ADD_MATCHUPS,\n  });\n\n  return { ...SUCCESS };\n}\n\ntype DeleteMatchUpsNoticeArga = {\n  drawDefinition?: DrawDefinition;\n  tournamentId?: string;\n  matchUpIds: string[];\n  eventId?: string;\n  action?: any;\n};\nexport function deleteMatchUpsNotice({\n  drawDefinition,\n  tournamentId,\n  matchUpIds,\n  eventId,\n  action,\n}: DeleteMatchUpsNoticeArga) {\n  if (drawDefinition) drawUpdatedAt(drawDefinition);\n  addNotice({\n    topic: DELETED_MATCHUP_IDS,\n    payload: {\n      tournamentId,\n      matchUpIds,\n      eventId,\n      action,\n    },\n  });\n  for (const matchUpId of matchUpIds) {\n    deleteNotice({ key: matchUpId });\n  }\n\n  return { ...SUCCESS };\n}\n\ntype ModifyMatchUpNoticeArgs = {\n  drawDefinition?: DrawDefinition;\n  tournamentId?: string;\n  structureId?: string;\n  matchUp: MatchUp;\n  eventId?: string;\n  context?: any;\n};\n\nexport function modifyMatchUpNotice({\n  drawDefinition,\n  tournamentId,\n  structureId,\n  context,\n  eventId,\n  matchUp,\n}: ModifyMatchUpNoticeArgs) {\n  if (!matchUp) {\n    console.log(MISSING_MATCHUP);\n    return { error: MISSING_MATCHUP };\n  }\n  if (drawDefinition) {\n    const structureIds = structureId ? [structureId] : undefined;\n    modifyDrawNotice({\n      drawDefinition,\n      structureIds,\n      tournamentId,\n      eventId,\n    });\n  }\n  addNotice({\n    topic: MODIFY_MATCHUP,\n    payload: { matchUp, tournamentId, context },\n    key: matchUp.matchUpId,\n  });\n\n  return { ...SUCCESS };\n}\n\nexport function updateInContextMatchUp({ tournamentId, inContextMatchUp }) {\n  if (!inContextMatchUp) {\n    return { error: MISSING_MATCHUP };\n  }\n  addNotice({\n    payload: { inContextMatchUp, tournamentId },\n    topic: UPDATE_INCONTEXT_MATCHUP,\n    key: inContextMatchUp.matchUpId,\n  });\n\n  return { ...SUCCESS };\n}\n\ntype AddDrawNoticeArgs = {\n  drawDefinition?: DrawDefinition;\n  tournamentId?: string;\n  eventId?: string;\n};\nexport function addDrawNotice({\n  tournamentId,\n  eventId,\n  drawDefinition,\n}: AddDrawNoticeArgs): { success?: boolean; error?: ErrorType } {\n  if (!drawDefinition) {\n    console.log(MISSING_DRAW_DEFINITION);\n    return { error: MISSING_DRAW_DEFINITION };\n  }\n  drawUpdatedAt(drawDefinition);\n  addNotice({\n    payload: { drawDefinition, tournamentId, eventId },\n    topic: ADD_DRAW_DEFINITION,\n    key: drawDefinition.drawId,\n  });\n\n  return { ...SUCCESS };\n}\n\ntype DeleteDrawNoticeArgs = {\n  tournamentId?: string;\n  eventId?: string;\n  drawId: string;\n};\nexport function deleteDrawNotice({\n  tournamentId,\n  eventId,\n  drawId,\n}: DeleteDrawNoticeArgs) {\n  addNotice({\n    payload: { drawId, tournamentId, eventId },\n    topic: DELETED_DRAW_IDS,\n    key: drawId,\n  });\n  deleteNotice({ key: drawId });\n\n  return { ...SUCCESS };\n}\n\ntype ModifyDrawNoticeArgs = {\n  drawDefinition: DrawDefinition;\n  structureIds?: string[];\n  tournamentId?: string;\n  eventId?: string;\n};\nexport function modifyDrawNotice({\n  drawDefinition,\n  tournamentId,\n  structureIds,\n  eventId,\n}: ModifyDrawNoticeArgs) {\n  if (!drawDefinition) {\n    return { error: MISSING_DRAW_DEFINITION };\n  }\n  drawUpdatedAt(drawDefinition, structureIds);\n  addNotice({\n    payload: { tournamentId, eventId, drawDefinition },\n    topic: MODIFY_DRAW_DEFINITION,\n    key: drawDefinition.drawId,\n  });\n\n  return { ...SUCCESS };\n}\n\nexport function modifySeedAssignmentsNotice({\n  drawDefinition,\n  tournamentId,\n  structure,\n  eventId,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structure) return { error: MISSING_STRUCTURE };\n\n  const seedAssignments = structure.seedAssignments;\n  const structureId = structure.structureId;\n  const drawId = drawDefinition.drawId;\n\n  addNotice({\n    payload: { tournamentId, eventId, drawId, structureId, seedAssignments },\n    topic: MODIFY_SEED_ASSIGNMENTS,\n    key: drawDefinition.drawId,\n  });\n  modifyDrawNotice({\n    structureIds: [structureId],\n    drawDefinition,\n    tournamentId,\n    eventId,\n  });\n\n  return { ...SUCCESS };\n}\n\nexport function modifyPositionAssignmentsNotice({\n  drawDefinition,\n  tournamentId,\n  structure,\n  event,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structure) return { error: MISSING_STRUCTURE };\n\n  const positionAssignments = getPositionAssignments({ structure });\n  const structureId = structure.structureId;\n  const drawId = drawDefinition.drawId;\n  const eventId = event?.eventId;\n\n  addNotice({\n    topic: MODIFY_POSITION_ASSIGNMENTS,\n    payload: {\n      positionAssignments,\n      tournamentId,\n      structureId,\n      eventId,\n      drawId,\n    },\n    key: structureId,\n  });\n\n  modifyDrawNotice({\n    structureIds: [structureId],\n    drawDefinition,\n    tournamentId,\n    eventId,\n  });\n\n  return { ...SUCCESS };\n}\n","import { addExtension } from '../../extensions/addExtension';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\n\nimport { MAIN, QUALIFYING } from '../../../constants/drawDefinitionConstants';\nimport { DISABLE_LINKS } from '../../../constants/extensionConstants';\n\nexport function conditionallyDisableLinkPositioning({\n  drawPositions,\n  structure,\n}) {\n  if (\n    [QUALIFYING, MAIN].includes(structure.stage) &&\n    structure.stageSequence === 1\n  ) {\n    // positionActions are not disabled for first stage QUALIFYING and MAIN structures\n    return;\n  }\n  const { positionAssignments } = getPositionAssignments({ structure });\n  const relevantAssignments = positionAssignments?.filter(\n    ({ drawPosition }) => drawPositions?.includes(drawPosition)\n  );\n  relevantAssignments?.forEach((assignment) => {\n    const extension = {\n      name: DISABLE_LINKS,\n      value: true,\n    };\n    addExtension({ element: assignment, extension });\n  });\n}\n\n// NOTE: NOT READY TO USE.\n// Would only be possible to remove disabling extension if the position is unassigned..\n// ...AND the source position has not yet attempted participant traversal\n/*\nexport function reEnableDrawPositionLinks({ drawPosition, structure }) {\n  const { positionAssignments } = getPositionAssignments({ structure });\n  const assignment = positionAssignments.find(\n    (assignment) => assignment.drawPosition === drawPosition\n  );\n\n  const { participantId, bye, qualifier } = assignment || {};\n  if (!participantId && !bye && !qualifier) {\n    removeExtension({ element: assignment, name: DISABLE_LINKS });\n  }\n}\n*/\n","import { addExtension } from '../../extensions/addExtension';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { findExtension } from '../../../acquire/findExtension';\n\nimport { AUDIT_POSITION_ACTIONS } from '../../../constants/extensionConstants';\nimport { MAIN } from '../../../constants/drawDefinitionConstants';\n\n// updates 'positionActions' extension to keep track of positionActions by end-user\n// TODO: consider adding timestamp attribute to positionAction object\nexport function addPositionActionTelemetry({ drawDefinition, positionAction }) {\n  const { extension } = findExtension({\n    name: AUDIT_POSITION_ACTIONS,\n    element: drawDefinition,\n  });\n\n  const existingValue = Array.isArray(extension?.value)\n    ? extension?.value ?? []\n    : [];\n\n  if (!existingValue?.length) {\n    const mainStructure = drawDefinition.structures.find(\n      (structure) => structure.stage === MAIN\n    );\n    if (mainStructure) {\n      const initialAssignments = getPositionAssignments({\n        structure: mainStructure,\n      }).positionAssignments?.map(\n        ({ drawPosition, participantId, bye, qualifier }) => ({\n          drawPosition,\n          participantId,\n          qualifier,\n          bye,\n        })\n      );\n\n      existingValue.push({\n        name: 'initialMainAssignments',\n        initialAssignments,\n      });\n    }\n  }\n\n  const updatedExtension = {\n    name: AUDIT_POSITION_ACTIONS,\n    value: existingValue.concat(positionAction),\n  };\n\n  addExtension({ element: drawDefinition, extension: updatedExtension });\n}\n","import { DrawDefinition, Event, Tournament } from '../../types/tournamentTypes';\n\n/**\n * Finds all container structures within a tournament object and returns a mapping of container structureIds to arrays of contained structureIds\n */\ntype GetContainedStructuresArgs = {\n  tournamentRecord?: Tournament;\n  drawDefinition?: DrawDefinition;\n  event?: Event;\n};\nexport function getContainedStructures({\n  tournamentRecord,\n  drawDefinition,\n  event,\n}: GetContainedStructuresArgs) {\n  const events = tournamentRecord?.events || (event && [event]);\n  const drawDefinitions =\n    events\n      ?.map((event) => event?.drawDefinitions)\n      .flat()\n      .filter(Boolean) ||\n    (drawDefinition && [drawDefinition]) ||\n    [];\n\n  const containedStructures = {};\n  const containerStructures = {};\n\n  const structureContainers = drawDefinitions\n    .map((dd) => dd?.structures?.filter((structure) => structure?.structures))\n    .flat()\n    .filter(Boolean);\n\n  for (const structureContainer of structureContainers) {\n    const { structures, structureId } = structureContainer ?? {};\n    structures &&\n      structureId &&\n      (containedStructures[structureId] = structures?.map(\n        (structure) => structure.structureId\n      )) &&\n      structures.forEach(\n        (structure) =>\n          (containerStructures[structure.structureId] =\n            structureContainer?.structureId)\n      );\n  }\n\n  return { containedStructures, containerStructures };\n}\n","export function checkScoreHasValue(params) {\n  const matchUp = params?.matchUp;\n  const score = params?.score || matchUp?.score;\n\n  const firstSet = score?.sets?.[0];\n  const {\n    side1Score,\n    side2Score,\n    side1TiebreakScore,\n    side2TiebreakScore,\n    side1PointScore,\n    side2PointScore,\n  } = firstSet || {};\n  const firstSetScore =\n    side1Score ||\n    side2Score ||\n    side1TiebreakScore ||\n    side2TiebreakScore ||\n    side1PointScore ||\n    side2PointScore;\n  const hasValue = score?.sets?.length > 1 || firstSetScore;\n\n  return !!hasValue;\n}\n","import { MatchUpStatusUnion } from '../../../types/tournamentTypes';\nimport {\n  nonDirectingMatchUpStatuses,\n  directingMatchUpStatuses,\n  activeMatchUpStatuses,\n} from '../../../constants/matchUpStatusConstants';\n\nexport function isDirectingMatchUpStatus({ matchUpStatus }) {\n  return directingMatchUpStatuses.includes(matchUpStatus);\n}\n\nexport function isActiveMatchUpStatus({ matchUpStatus }) {\n  return activeMatchUpStatuses.includes(matchUpStatus);\n}\n\ntype IsNonDirectingArgs = {\n  matchUpStatus: MatchUpStatusUnion;\n};\nexport function isNonDirectingMatchUpStatus({\n  matchUpStatus,\n}: IsNonDirectingArgs) {\n  return nonDirectingMatchUpStatuses.includes(matchUpStatus);\n}\n","import { checkScoreHasValue } from '../../../query/matchUp/checkScoreHasValue';\nimport { isActiveMatchUpStatus } from '../../../mutate/drawDefinitions/matchUpGovernor/checkStatusType';\n\nimport {\n  DEFAULTED,\n  IN_PROGRESS,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\n\nimport { Score } from '../../../types/tournamentTypes';\n\n// an active matchUp is one that has a winningSide, more than one set, or a single set with any score value greater than zero\n// when { matchUpType: TEAM } the child tieMatchUps must be checked as well\n// scoreStrings are not reliable because TEAM matchUps can have scoreString '0-0'\n\ntype IsActiveMatchUpArgs = {\n  matchUpStatus?: string;\n  winningSide?: number;\n  tieMatchUps?: any[];\n  sides?: any[];\n  score?: Score;\n};\nexport function isActiveMatchUp({\n  matchUpStatus,\n  winningSide,\n  tieMatchUps,\n  sides,\n  score,\n}: IsActiveMatchUpArgs) {\n  const participantAssigned = sides?.find(({ participantId }) => participantId);\n  const activeTieMatchUps = tieMatchUps?.filter(isActiveMatchUp)?.length;\n  const scoreExists = checkScoreHasValue({ score });\n\n  return (\n    scoreExists ||\n    activeTieMatchUps ||\n    (winningSide && participantAssigned) || // if winningSide and no participant assigned => \"produced\" WALKOVER\n    // must exclude IN_PROGRESS as this is automatically set by updateTieMatchUpScore\n    // must exclude WALKOVER and DEFAULTED as \"produced\" scenarios do not imply a winningSide\n    (matchUpStatus &&\n      isActiveMatchUpStatus({ matchUpStatus }) &&\n      ![DEFAULTED, WALKOVER, IN_PROGRESS].includes(matchUpStatus))\n  );\n}\n","import { DOUBLES } from '../../../../constants/matchUpTypes';\n\nexport function getIndividualParticipantIds(matchUp) {\n  const { sides, matchUpType } = matchUp || {};\n  const potentialIndividualParticipantIds = matchUp.potentialParticipants\n    ?.length\n    ? matchUp.potentialParticipants\n        .flat()\n        .map((participant) => {\n          return matchUpType === DOUBLES\n            ? participant?.individualParticipantIds || []\n            : participant.participantId;\n        })\n        .flat()\n    : [];\n  const enteredIndividualParticipantIds = (sides || [])\n    .map((side) => {\n      return (\n        (matchUpType === DOUBLES &&\n          (side?.participant?.individualParticipantIds || [])) ||\n        (side?.participantId && [side.participantId]) ||\n        []\n      );\n    })\n    .flat();\n\n  const individualParticipantIds = enteredIndividualParticipantIds\n    .concat(potentialIndividualParticipantIds)\n    .flat();\n\n  return {\n    individualParticipantIds,\n    enteredIndividualParticipantIds,\n    potentialIndividualParticipantIds,\n  };\n}\n","import { getRoundMatchUps } from '../../../query/matchUps/getRoundMatchUps';\nimport { getDevContext } from '../../../global/state/globalState';\nimport { validMatchUps } from '../../../validators/validMatchUp';\nimport { xa } from '../../../utilities/objects';\nimport { generateRange } from '../../../utilities/arrays';\n\nimport { MatchUp } from '../../../types/tournamentTypes';\n\ntype AddFinishingRoundsArgs = {\n  finishingPositionOffset?: number;\n  finishingPositionLimit?: number;\n  positionsFed?: number;\n  roundsCount?: number;\n  roundLimit?: number;\n  matchUps: MatchUp[];\n  lucky?: boolean;\n  fmlc?: boolean;\n};\n\nexport function addFinishingRounds({\n  finishingPositionOffset = 0,\n  finishingPositionLimit,\n  positionsFed,\n  roundsCount,\n  roundLimit,\n  matchUps,\n  lucky,\n  fmlc,\n}: AddFinishingRoundsArgs): MatchUp[] {\n  if (!validMatchUps(matchUps)) return [];\n\n  const { roundProfile, roundNumbers = [] } = getRoundMatchUps({\n    interpolate: true, // for structures which do not contain a final round of one matchUps (structure winner)\n    matchUps,\n  });\n\n  roundsCount = roundsCount ?? Math.max(...roundNumbers, 0);\n\n  // for qualifying, offset the final round so that qualifyinground is finishingRound\n  const finishingRoundOffset = roundLimit ? roundsCount - roundLimit : 0;\n\n  // for QUALIFYING draws the best finishingPosition is equal to the number of matchUps in the final round of the structure\n  const minQualifyingPosition =\n    finishingRoundOffset && roundProfile?.[roundsCount - finishingRoundOffset]?.matchUpsCount;\n\n  const roundMatchUpsCountArray = roundProfile && Object.values(roundProfile).map(xa('matchUpsCount'));\n\n  // returns a range for array of possible finishing drawPositions\n  const finishingRange = (positionRange, winner?) => {\n    let minFinishingPosition = Math.min(...positionRange);\n\n    // only modify for qualifying when the minFinishingPosition is 1\n    // and when the finishingRange is being calculated for a matchUp winner\n    if (minQualifyingPosition && winner && minFinishingPosition === 1) {\n      minFinishingPosition = minQualifyingPosition;\n    }\n    let maxFinishingPosition = Math.max(...positionRange);\n    if (finishingPositionLimit && maxFinishingPosition > finishingPositionLimit)\n      maxFinishingPosition = finishingPositionLimit;\n    return [minFinishingPosition, maxFinishingPosition];\n  };\n\n  const roundFinishingData =\n    roundProfile &&\n    Object.assign(\n      {},\n      ...roundNumbers.map((roundNumber) => {\n        const finishingRound = (roundsCount ?? 0) + 1 - roundNumber - finishingRoundOffset;\n        const matchUpsCount = roundProfile[roundNumber].matchUpsCount;\n        const finishingData = {\n          finishingPositionRange: {},\n          finishingRound,\n        };\n\n        const upcomingMatchUps = roundMatchUpsCountArray?.slice(roundNumber - 1).reduce((a, b) => a + (b || 0), 0);\n        // in the case of FMLC the finishingPositionRange in consolation is not modified after first fed round\n        const fmlcException = fmlc && roundNumber !== 1;\n        const rangeOffset = 1 + finishingPositionOffset + (fmlcException ? positionsFed ?? 0 : 0);\n        const finalPosition = 1;\n        const positionRange = generateRange(\n          rangeOffset,\n          lucky ? rangeOffset + matchUpsCount * 2 : upcomingMatchUps + rangeOffset + finalPosition,\n        );\n        const slicer = upcomingMatchUps + finalPosition - matchUpsCount;\n        const loser = finishingRange(positionRange.slice(slicer));\n        const winner = finishingRange(positionRange.slice(0, slicer), true);\n        finishingData.finishingPositionRange = { loser, winner };\n\n        return { [roundNumber]: finishingData };\n      }),\n    );\n\n  const devContext = getDevContext({ finishingRound: true });\n  matchUps.filter(Boolean).forEach((matchUp) => {\n    const roundData = matchUp.roundNumber && roundFinishingData[matchUp.roundNumber];\n    if (devContext && !roundData) console.log({ roundFinishingData, matchUp });\n    matchUp.finishingRound = roundData?.finishingRound;\n    matchUp.finishingPositionRange = roundData?.finishingPositionRange;\n  });\n\n  return matchUps;\n}\n","import { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { addFinishingRounds } from '../../../assemblies/generators/drawDefinitions/addFinishingRounds';\nimport { positionTargets } from '../../matchUps/drawPositions/positionTargets';\nimport {\n  MatchUpsMap,\n  getMappedStructureMatchUps,\n} from '../../../query/matchUps/getMatchUpsMap';\n\nimport { MISSING_DRAW_DEFINITION } from '../../../constants/errorConditionConstants';\nimport { DrawDefinition } from '../../../types/tournamentTypes';\nimport { HydratedMatchUp } from '../../../types/hydrated';\n\ntype AddGoesToArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n};\nexport function addGoesTo({\n  inContextDrawMatchUps,\n  drawDefinition,\n  matchUpsMap,\n}: AddGoesToArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const goesToMap = { loserMatchUpIds: {}, winnerMatchUpIds: {} };\n\n  if (!inContextDrawMatchUps) {\n    ({ matchUps: inContextDrawMatchUps, matchUpsMap } = getAllDrawMatchUps({\n      inContext: true,\n      drawDefinition,\n      matchUpsMap,\n    }));\n  }\n\n  const hasFinishingPositionRanges = matchUpsMap?.drawMatchUps.some(\n    (m) => m.finishingPositionRange\n  );\n\n  // NOTE: handles drawDefinitions in TODS files not generated by the factory\n  // IF: there is only one structure present... as is the case with tods-xls-converter\n  // TODO: make a more sophisticated version which can use .links to addFinishingRounds for all structures\n  if (\n    !hasFinishingPositionRanges &&\n    drawDefinition?.structures?.length === 1 &&\n    !drawDefinition?.structures[0].structures\n  ) {\n    const matchUps = matchUpsMap?.drawMatchUps ?? [];\n    addFinishingRounds({ matchUps });\n  }\n\n  (inContextDrawMatchUps ?? [])\n    .filter(({ collectionId }) => !collectionId)\n    .forEach((inContextMatchUp) => {\n      const { matchUpId, structureId } = inContextMatchUp;\n      const targetData = positionTargets({\n        inContextDrawMatchUps,\n        drawDefinition,\n        matchUpId,\n      });\n      const { winnerMatchUp, loserMatchUp } = targetData.targetMatchUps;\n      const winnerMatchUpId = winnerMatchUp?.matchUpId;\n      const loserMatchUpId = loserMatchUp?.matchUpId;\n\n      const matchUps = getMappedStructureMatchUps({\n        matchUpsMap,\n        structureId,\n      });\n      const matchUp = matchUps.find(\n        (matchUp) => matchUp.matchUpId === matchUpId\n      );\n\n      if (matchUp) {\n        if (winnerMatchUpId) {\n          goesToMap.winnerMatchUpIds[matchUp.matchUpId] = winnerMatchUpId;\n          Object.assign(matchUp, { winnerMatchUpId });\n          Object.assign(inContextMatchUp, { winnerMatchUpId });\n        }\n        if (loserMatchUpId) {\n          goesToMap.loserMatchUpIds[matchUp.matchUpId] = loserMatchUpId;\n          inContextMatchUp.loserMatchUpId = loserMatchUpId;\n          matchUp.loserMatchUpId = loserMatchUpId;\n\n          if (inContextMatchUp.finishingPositionRange) {\n            const loserRange = loserMatchUp.finishingPositionRange && [\n              ...inContextMatchUp.finishingPositionRange.loser,\n              ...loserMatchUp.finishingPositionRange.loser,\n            ];\n            const loser = loserRange && [\n              Math.min(...loserRange),\n              Math.max(...loserRange),\n            ];\n            inContextMatchUp.finishingPositionRange.loser = loser;\n            matchUp.finishingPositionRange.loser = loser;\n          }\n        }\n      }\n    });\n\n  return { inContextDrawMatchUps, goesToMap };\n}\n","import { getScheduleTiming } from '../extensions/matchUpFormatTiming/getScheduleTiming';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { hydrateParticipants } from '../participants/hydrateParticipants';\nimport { getContextContent } from '../hierarchical/getContextContent';\nimport { getAllDrawMatchUps } from './drawMatchUps';\n\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport { GetMatchUpsArgs } from '../../types/factoryTypes';\nimport { MISSING_EVENT } from '../../constants/errorConditionConstants';\n\nexport function allEventMatchUps(params: GetMatchUpsArgs) {\n  let { participants = [], contextContent, participantMap } = params;\n  const {\n    scheduleVisibilityFilters,\n    tournamentAppliedPolicies,\n    participantsProfile,\n    afterRecoveryTimes,\n    policyDefinitions,\n    useParticipantMap,\n    tournamentRecord,\n    contextFilters,\n    contextProfile,\n    matchUpFilters,\n    nextMatchUps,\n    inContext,\n    context,\n    event,\n  } = params;\n  if (!event) return { error: MISSING_EVENT };\n  const { eventId, eventName, endDate, category, gender, matchUpFormat } =\n    event;\n\n  const additionalContext = {\n    ...context,\n    ...definedAttributes({\n      indoorOutDoor: event.indoorOutdoor ?? tournamentRecord?.indoorOutdoor,\n      surfaceCategory:\n        event.surfaceCategory ?? tournamentRecord?.surfaceCategory,\n      endDate: event.endDate ?? tournamentRecord?.endDate,\n      tournamentId: tournamentRecord?.tournamentId,\n      matchUpFormat,\n      eventName,\n      category,\n      gender,\n      eventId,\n    }),\n  };\n  if (endDate) additionalContext.endDate = endDate;\n\n  if (contextProfile && !contextContent) {\n    contextContent = getContextContent({\n      policyDefinitions,\n      tournamentRecord,\n      contextProfile,\n      event,\n    });\n  }\n\n  let groupInfo;\n  if (!participants?.length && !participantMap && tournamentRecord) {\n    const hydratedParticipantResult = hydrateParticipants({\n      participantsProfile,\n      useParticipantMap,\n      policyDefinitions,\n      tournamentRecord,\n      contextProfile,\n      inContext,\n    });\n    participantMap = hydratedParticipantResult.participantMap;\n    participants = hydratedParticipantResult.participants ?? [];\n    groupInfo = hydratedParticipantResult.groupInfo;\n  }\n\n  const drawDefinitions = event.drawDefinitions ?? [];\n  const scheduleTiming = getScheduleTiming({\n    tournamentRecord,\n    event,\n  }).scheduleTiming;\n\n  const matchUps: HydratedMatchUp[] = drawDefinitions.flatMap(\n    (drawDefinition) => {\n      const { matchUps } = getAllDrawMatchUps({\n        tournamentParticipants: participants,\n        tournamentAppliedPolicies,\n        scheduleVisibilityFilters,\n        context: additionalContext,\n        participantsProfile,\n        afterRecoveryTimes,\n        policyDefinitions,\n        tournamentRecord,\n        contextFilters,\n        contextProfile,\n        drawDefinition,\n        contextContent,\n        matchUpFilters,\n        participantMap,\n        scheduleTiming,\n        nextMatchUps,\n        inContext,\n        event,\n      });\n\n      return matchUps ?? [];\n    }\n  );\n\n  return { matchUps, groupInfo };\n}\n","import { getAppliedPolicies } from '../extensions/getAppliedPolicies';\nimport { hydrateParticipants } from '../participants/hydrateParticipants';\nimport { getContextContent } from '../hierarchical/getContextContent';\nimport { allEventMatchUps } from './getAllEventMatchUps';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport { GetMatchUpsArgs } from '../../types/factoryTypes';\n\nexport function allTournamentMatchUps(params?: GetMatchUpsArgs): ResultType & {\n  matchUps?: HydratedMatchUp[];\n} {\n  if (!params?.tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  let { participantMap, participants } = params;\n  const {\n    scheduleVisibilityFilters,\n    participantsProfile,\n    afterRecoveryTimes,\n    useParticipantMap, // will default to true in future release\n    policyDefinitions,\n    tournamentRecord,\n    inContext = true,\n    contextProfile,\n    matchUpFilters,\n    contextFilters,\n    nextMatchUps,\n    context,\n  } = params;\n\n  const tournamentId = params.tournamentId ?? tournamentRecord.tournamentId;\n  const events = tournamentRecord?.events ?? [];\n\n  if (!participants) {\n    ({ participants, participantMap } = hydrateParticipants({\n      participantsProfile,\n      useParticipantMap,\n      policyDefinitions,\n      tournamentRecord,\n      contextProfile,\n      inContext,\n    }));\n  }\n\n  const { appliedPolicies: tournamentAppliedPolicies } = getAppliedPolicies({\n    tournamentRecord,\n  });\n\n  const additionalContext: { [key: string]: any } = {\n    ...context,\n    tournamentId,\n    indoorOutDoor: tournamentRecord.indoorOutdoor,\n    surfaceCategory: tournamentRecord.surfaceCategory,\n    endDate: tournamentRecord.endDate,\n  };\n\n  const contextContent = getContextContent({\n    policyDefinitions,\n    tournamentRecord,\n    contextProfile,\n  });\n\n  const matchUps = events\n    .flatMap((event) => {\n      additionalContext.eventDrawsCount = event.drawDefinitions?.length ?? 0;\n\n      return (\n        allEventMatchUps({\n          context: additionalContext,\n          scheduleVisibilityFilters,\n          tournamentAppliedPolicies,\n          participantsProfile,\n          afterRecoveryTimes,\n          policyDefinitions,\n          tournamentRecord,\n          contextContent,\n          contextFilters,\n          contextProfile,\n          matchUpFilters,\n          participantMap,\n          nextMatchUps,\n          participants,\n          inContext,\n          event,\n        }).matchUps ?? []\n      );\n    })\n    // TODO: tournamentRecord.matchUps must be hydrated with participants\n    // NOTE: matchUps on the tournamentRecord have no drawPositions; all data apart from participant context must be present\n    .concat(...(tournamentRecord.matchUps ?? []));\n\n  return { matchUps };\n}\n","import { allTournamentMatchUps } from './getAllTournamentMatchUps';\n\nimport { ErrorType, MISSING_TOURNAMENT_RECORDS } from '../../constants/errorConditionConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport {\n  MatchUpFilters,\n  ParticipantsProfile,\n  PolicyDefinitions,\n  ScheduleVisibilityFilters,\n  TournamentRecords,\n} from '../../types/factoryTypes';\n\ntype CompetitionMatchUpsArgs = {\n  scheduleVisibilityFilters?: ScheduleVisibilityFilters;\n  participantsProfile?: ParticipantsProfile;\n  tournamentRecords: TournamentRecords;\n  policyDefinitions?: PolicyDefinitions;\n  matchUpFilters?: MatchUpFilters;\n  contextFilters?: MatchUpFilters;\n  afterRecoveryTimes?: boolean;\n  usePublishState?: boolean;\n  nextMatchUps?: boolean;\n  inContext?: boolean;\n};\n\nexport function allCompetitionMatchUps({\n  scheduleVisibilityFilters,\n  afterRecoveryTimes,\n  participantsProfile,\n  tournamentRecords,\n  policyDefinitions,\n  matchUpFilters,\n  contextFilters,\n  nextMatchUps,\n  inContext,\n}: CompetitionMatchUpsArgs): {\n  matchUps?: HydratedMatchUp[];\n  error?: ErrorType;\n} {\n  if (typeof tournamentRecords !== 'object' || !Object.keys(tournamentRecords).length)\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const tournamentIds = Object.keys(tournamentRecords);\n  const competitionMatchUps: HydratedMatchUp[] = tournamentIds\n    .map((tournamentId) => {\n      const tournamentRecord = tournamentRecords[tournamentId];\n      return (\n        allTournamentMatchUps({\n          scheduleVisibilityFilters,\n          afterRecoveryTimes,\n          participantsProfile,\n          policyDefinitions,\n          tournamentRecord,\n          matchUpFilters,\n          contextFilters,\n          nextMatchUps,\n          inContext,\n        }).matchUps ?? []\n      );\n    })\n    .flat();\n\n  return { matchUps: competitionMatchUps };\n}\n","import { stageOrder } from '../../constants/drawDefinitionConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\n\n/**\n * Sorting function to arrange matchUps by stage, stageSequence, roundNumber, roundPosition (where applicable)\n * - Useful for automatically scoring all matchUps in connected draw structures\n * - Useful for visualizing the progression of drawPositions through rounds\n *\n * @param {object} a - matchUp object\n * @param {object} b - matchUp object\n *\n */\nexport function matchUpSort(a: HydratedMatchUp, b: HydratedMatchUp): number {\n  return (\n    stageDifference(a, b) ||\n    (a?.stageSequence || 0) - (b?.stageSequence || 0) ||\n    (a?.roundNumber && b.roundNumber && a?.roundNumber - b?.roundNumber) ||\n    (a?.roundPosition ?? 0) - (b?.roundPosition ?? 0)\n  );\n}\n\nfunction stageDifference(a, b) {\n  return (stageOrder[a?.stage] || 0) - (stageOrder[b?.stage] || 0);\n}\n","/**\n * Builds up an exhaustive map of all matchUpIds on which a matchUpId is depdendent\n * Optionally builds up an exhaustive map of all potential participantIds for each matchUpId\n */\n\nimport { getIndividualParticipantIds } from '../../mutate/matchUps/schedule/scheduleMatchUps/getIndividualParticipantIds';\nimport { resolveTournamentRecords } from '../../parameters/resolveTournamentRecords';\nimport { addGoesTo } from '../../mutate/drawDefinitions/matchUpGovernor/addGoesTo';\nimport { allCompetitionMatchUps } from './getAllCompetitionMatchUps';\nimport { matchUpSort } from '../../functions/sorters/matchUpSort';\nimport { allDrawMatchUps } from './getAllDrawMatchUps';\nimport { findEvent } from '../../acquire/findEvent';\n\nimport { POSITION } from '../../constants/drawDefinitionConstants';\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport {\n  ErrorType,\n  MISSING_DRAW_ID,\n  MISSING_MATCHUPS,\n  MISSING_MATCHUP_IDS,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  DrawLink,\n  Tournament,\n} from '../../types/tournamentTypes';\n\ntype GetMatchUpDependenciesArgs = {\n  includeParticipantDependencies?: boolean;\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  drawDefinition?: DrawDefinition;\n  matchUps?: HydratedMatchUp[]; // requires matchUps { inContext: true }\n  matchUpIds?: string[]; // will restrict dependency checking if prior matchUpIds are not included\n  drawIds?: string[];\n};\n\nexport function getMatchUpDependencies(params: GetMatchUpDependenciesArgs): {\n  sourceMatchUpIds?: { [key: string]: any[] };\n  matchUps?: HydratedMatchUp[];\n  positionDependencies?: any;\n  matchUpDependencies?: any;\n  error?: ErrorType;\n  success?: boolean;\n} {\n  let tournamentRecords = resolveTournamentRecords(params);\n  const targetMatchUps = params.matchUps ?? []; // requires matchUps { inContext: true }\n  let drawIds = params.drawIds ?? [];\n\n  const { includeParticipantDependencies, tournamentRecord, drawDefinition } =\n    params;\n\n  if (!Array.isArray(targetMatchUps)) return { error: MISSING_MATCHUPS };\n  if (!Array.isArray(drawIds)) return { error: MISSING_DRAW_ID };\n\n  const matchUpIds = params.matchUpIds?.length\n    ? params.matchUpIds\n    : targetMatchUps.map((matchUp) => matchUp.matchUpId);\n  if (!Array.isArray(matchUpIds)) return { error: MISSING_MATCHUP_IDS };\n\n  const positionDependencies = {};\n  const matchUpDependencies = {};\n  const sourceStructureIdMap = {};\n  const sourceMatchUpIds = {};\n\n  if (tournamentRecord && !Object.keys(tournamentRecords).length)\n    tournamentRecords = { [tournamentRecord.tournamentId]: tournamentRecord };\n\n  const allTournamentRecords: Tournament[] = Object.values(tournamentRecords);\n\n  const allLinks: DrawLink[] = allTournamentRecords.reduce(\n    (allLinks: any[], tournamentRecord) => {\n      return allLinks\n        .concat(tournamentRecord.events ?? [])\n        .map((event) =>\n          (event.drawDefinitions || []).map(\n            (drawDefinition) => drawDefinition.links || []\n          )\n        )\n        .flat(Infinity);\n    },\n    []\n  );\n\n  const positionLinks = allLinks.filter(\n    ({ linkType }) => linkType === POSITION\n  );\n\n  let matchUps: HydratedMatchUp[] | undefined = targetMatchUps;\n\n  if (positionLinks.length) {\n    matchUps = allCompetitionMatchUps({\n      nextMatchUps: true,\n      tournamentRecords,\n    }).matchUps;\n\n    // sourceStructureIdMap returns the sourceStructureId for a given targetStructureId\n    const sourceStructureIds = positionLinks.reduce(\n      (structureIds: string[], link) => {\n        const sourceStructureId = link.source?.structureId;\n        const targetStructureId = link.target?.structureId;\n        if (sourceStructureId && targetStructureId)\n          sourceStructureIdMap[targetStructureId] = sourceStructureId;\n        if (sourceStructureId && !structureIds.includes(sourceStructureId))\n          structureIds.push(sourceStructureId);\n        return structureIds;\n      },\n      []\n    );\n\n    // positionDependencies map a sourceStructureId to the matchUpIds which it contains\n    for (const sourceStructureId of sourceStructureIds) {\n      positionDependencies[sourceStructureId] = [];\n    }\n    for (const matchUp of matchUps ?? []) {\n      // pertains to Round Robins and e.g. Swiss rounds; Round Robins require hoisting to containing structure\n      const sourceStructureId =\n        matchUp.containerStructureId || matchUp.structureId;\n      if (sourceStructureIds.includes(sourceStructureId)) {\n        positionDependencies[sourceStructureId].push(matchUp.matchUpId);\n      }\n    }\n  }\n\n  const initializeMatchUpId = (matchUpId) => {\n    if (!matchUpDependencies[matchUpId]) {\n      matchUpDependencies[matchUpId] = {\n        dependentMatchUpIds: [],\n        participantIds: [],\n        matchUpIds: [],\n        sources: [],\n      };\n      sourceMatchUpIds[matchUpId] = [];\n    }\n  };\n\n  const propagateDependencies = (matchUpId, targetMatchUpId) => {\n    const propagatedMatchUpIds = matchUpDependencies[matchUpId].matchUpIds;\n\n    // push all existing dependents onto target dependents\n    propagatedMatchUpIds.forEach((matchUpIdDependency) => {\n      matchUpDependencies[targetMatchUpId].matchUpIds.push(matchUpIdDependency);\n    });\n\n    matchUpDependencies[targetMatchUpId].matchUpIds.push(matchUpId);\n    matchUpDependencies[matchUpId].dependentMatchUpIds.push(targetMatchUpId);\n\n    if (includeParticipantDependencies) {\n      matchUpDependencies[matchUpId].participantIds.forEach(\n        (participantIdDependency) =>\n          matchUpDependencies[targetMatchUpId].participantIds.push(\n            participantIdDependency\n          )\n      );\n    }\n  };\n\n  const processMatchUps = (matchUpsToProcess) => {\n    const processSourceStructures = Object.keys(positionDependencies).length;\n\n    for (const matchUp of matchUpsToProcess || []) {\n      const { matchUpId, winnerMatchUpId, loserMatchUpId } = matchUp;\n\n      // only process specified matchUps\n      if (!matchUpIds.length || matchUpIds.includes(matchUpId)) {\n        initializeMatchUpId(matchUpId);\n\n        if (includeParticipantDependencies) {\n          const { individualParticipantIds } =\n            getIndividualParticipantIds(matchUp);\n          matchUpDependencies[matchUpId].participantIds =\n            individualParticipantIds;\n        }\n\n        if (winnerMatchUpId) {\n          initializeMatchUpId(winnerMatchUpId);\n          propagateDependencies(matchUpId, winnerMatchUpId);\n          sourceMatchUpIds[winnerMatchUpId].push(matchUpId);\n        }\n        if (loserMatchUpId) {\n          initializeMatchUpId(loserMatchUpId);\n          propagateDependencies(matchUpId, loserMatchUpId);\n          sourceMatchUpIds[loserMatchUpId].push(matchUpId);\n        }\n\n        matchUpDependencies[matchUpId].sources.push(\n          sourceMatchUpIds[matchUpId]\n        );\n        const s1 = sourceMatchUpIds[matchUpId]\n          .map((id) => matchUpDependencies[id].sources[0])\n          .flat();\n        const s2 = sourceMatchUpIds[matchUpId]\n          .map((id) => matchUpDependencies[id].sources[1])\n          .flat();\n        matchUpDependencies[matchUpId].sources.push(...[s1, s2]);\n\n        if (processSourceStructures) {\n          const relevantStructureId =\n            matchUp.containerStructureId || matchUp.structureId;\n          const sourceStructureId = sourceStructureIdMap[relevantStructureId];\n          if (positionDependencies[sourceStructureId]) {\n            for (const matchUpDependency of positionDependencies[\n              sourceStructureId\n            ]) {\n              initializeMatchUpId(matchUpDependency);\n              propagateDependencies(matchUpDependency, matchUpId);\n              sourceMatchUpIds[matchUpDependency].push(matchUpId);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  if (drawDefinition) {\n    addGoesTo({ drawDefinition });\n    if (!matchUps?.length) {\n      matchUps = allDrawMatchUps({ drawDefinition }).matchUps;\n    }\n    processMatchUps(matchUps);\n  } else {\n    if (!matchUps?.length) {\n      matchUps = allCompetitionMatchUps({\n        nextMatchUps: true,\n        tournamentRecords,\n      }).matchUps;\n    }\n\n    if (!drawIds.length) {\n      const allDrawIds = allTournamentRecords?.length\n        ? allTournamentRecords\n            .map(({ events = [] }) =>\n              events.map(({ drawDefinitions = [] }) =>\n                drawDefinitions.map(({ drawId }) => drawId)\n              )\n            )\n            .flat(Infinity)\n        : [];\n      if (allDrawIds) drawIds = allDrawIds as string[];\n    }\n\n    for (const drawId of drawIds) {\n      const drawMatchUps = matchUps\n        // first get all matchUps for the draw\n        ?.filter((matchUp) => matchUp.drawId === drawId)\n        // sort by stage/stageSequence/roundNumber/roundPosition\n        .sort(matchUpSort);\n\n      const isRoundRobin = drawMatchUps?.find(\n        ({ roundPosition }) => !roundPosition\n      );\n      // skip this if Round Robin because there is no \"Goes To\"\n      if (!isRoundRobin) {\n        const hasTournamentId = drawMatchUps?.find(\n          ({ tournamentId }) => tournamentId\n        );\n        const { drawDefinition } = findEvent({\n          tournamentRecord: tournamentRecords[hasTournamentId?.tournamentId],\n          drawId,\n        });\n        if (drawDefinition) addGoesTo({ drawDefinition });\n      }\n\n      processMatchUps(drawMatchUps);\n    }\n  }\n\n  return {\n    positionDependencies,\n    matchUpDependencies,\n    sourceMatchUpIds,\n    matchUps,\n    ...SUCCESS,\n  };\n}\n","import { getContainedStructures } from '../drawDefinition/getContainedStructures';\nimport { isActiveMatchUp } from '../../tests/queries/matchUps/activeMatchUp';\nimport { getMatchUpDependencies } from '../matchUps/getMatchUpDependencies';\nimport { getPositionAssignments } from '../drawDefinition/positionsGetter';\nimport { getAllDrawMatchUps } from '../matchUps/drawMatchUps';\nimport { findStructure } from '../../acquire/findStructure';\nimport { numericSort } from '../../utilities/sorting';\nimport { isAdHoc } from '../drawDefinition/isAdHoc';\nimport { unique } from '../../utilities/arrays';\n\nimport { INVALID_DRAW_POSITION } from '../../constants/errorConditionConstants';\nimport { DrawDefinition, Event, Structure } from '../../types/tournamentTypes';\n\n// active drawPositions occur in activeMatchUps...\n// ...which have a winningSide, a scoreString, or a completed matchUpStatus\n\ntype GetStructureDrawPositionProfilesArgs = {\n  drawDefinition: DrawDefinition;\n  findContainer?: boolean;\n  structure?: Structure;\n  structureId?: string;\n  event?: Event;\n};\nexport function getStructureDrawPositionProfiles(\n  params: GetStructureDrawPositionProfilesArgs\n): { [key: string]: any } {\n  const { drawDefinition, findContainer, structureId, event } = params;\n  let structure = params.structure;\n\n  const matchUpFilters = { isCollectionMatchUp: false };\n  const { containedStructures } = getContainedStructures({ drawDefinition });\n  const containedStructureIds = structureId\n    ? containedStructures[structureId] || []\n    : [];\n\n  if (!structure) {\n    const result = findStructure({ drawDefinition, structureId });\n    if (result.error) return result;\n\n    structure = findContainer\n      ? result.containingStructure ?? result.structure\n      : result.structure;\n  }\n\n  if (isAdHoc({ drawDefinition, structure })) {\n    return { structure, isAdHoc: true, error: INVALID_DRAW_POSITION };\n  }\n\n  // must use all draw matchUps to get active matchUps across all connected structures\n  const { matchUps: inContextDrawMatchUps } = getAllDrawMatchUps({\n    inContext: true,\n    matchUpFilters,\n    drawDefinition,\n    event,\n  });\n\n  const inContextStructureMatchUps = inContextDrawMatchUps?.filter(\n    (matchUp) =>\n      matchUp.structureId === structureId ||\n      containedStructureIds.includes(matchUp.structureId)\n  );\n\n  // get a mapping of all matchUpIds to dependent matchUpIds\n  const { matchUpDependencies } = getMatchUpDependencies({\n    drawIds: [drawDefinition.drawId],\n    matchUps: inContextDrawMatchUps,\n    drawDefinition,\n  });\n\n  const activeDependentMatchUpIdsCollection: string[] = [];\n  const drawPositionsCollection: number[] = [];\n  const drawPositionInitialRounds = {};\n  const activeMatchUps: any[] = [];\n\n  for (const matchUp of inContextDrawMatchUps ?? []) {\n    if (\n      matchUp.structureId === structureId ||\n      containedStructureIds.includes(matchUp.structureId)\n    ) {\n      drawPositionsCollection.push(...(matchUp.drawPositions ?? []));\n\n      const roundNumber = matchUp.roundNumber;\n      for (const drawPosition of (matchUp.drawPositions ?? []).filter(\n        Boolean\n      )) {\n        if (\n          !drawPositionInitialRounds[drawPosition] ||\n          (roundNumber && drawPositionInitialRounds[drawPosition] > roundNumber)\n        ) {\n          drawPositionInitialRounds[drawPosition] = roundNumber;\n        }\n      }\n    }\n\n    if (isActiveMatchUp(matchUp)) {\n      activeMatchUps.push(matchUp);\n      activeDependentMatchUpIdsCollection.push(\n        matchUp.matchUpId,\n        ...(matchUpDependencies?.[matchUp?.matchUpId]?.matchUpIds || [])\n      );\n    }\n  }\n\n  // sorted drawPositions for the structure\n  const drawPositions = unique(drawPositionsCollection.filter(Boolean)).sort(\n    numericSort\n  );\n\n  const activeDependentMatchUpIds = unique(activeDependentMatchUpIdsCollection);\n\n  const activeDrawPositions = unique(\n    inContextStructureMatchUps\n      ?.map(({ matchUpId, drawPositions }) =>\n        activeDependentMatchUpIds.includes(matchUpId) ? drawPositions : []\n      )\n      .flat()\n      .filter(Boolean)\n  ).sort(numericSort);\n\n  const { positionAssignments } = getPositionAssignments({\n    drawDefinition,\n    structure,\n  });\n\n  // determine which positions are BYEs\n  const byeDrawPositions = positionAssignments\n    ?.filter((assignment) => assignment.bye)\n    .map((assignment) => assignment.drawPosition);\n\n  // determine which positions are Qualifiers\n  const qualifyingDrawPositions = positionAssignments\n    ?.filter((assignment) => assignment.qualifier)\n    .map((assignment) => assignment.drawPosition);\n\n  const inactiveDrawPositions =\n    drawPositions?.filter(\n      (drawPosition) => !activeDrawPositions.includes(drawPosition)\n    ) || [];\n\n  return {\n    allDrawPositions: drawPositions,\n    inContextStructureMatchUps,\n    drawPositionInitialRounds,\n    activeDependentMatchUpIds,\n    qualifyingDrawPositions,\n    inactiveDrawPositions,\n    positionAssignments,\n    activeDrawPositions,\n    byeDrawPositions,\n    activeMatchUps,\n    structure,\n  };\n}\n","import { numericSort } from '../../utilities/sorting';\n\nimport { HydratedMatchUp } from '../../types/hydrated';\n\ntype GetInitialRoundNumberArgs = {\n  matchUps?: HydratedMatchUp[];\n  drawPosition: number;\n};\nexport function getInitialRoundNumber({\n  drawPosition,\n  matchUps = [],\n}: GetInitialRoundNumberArgs) {\n  // determine the initial round where drawPosition appears\n  // drawPosition cannot be removed from its initial round\n  const initialRoundNumber = matchUps\n    .filter(\n      ({ drawPositions }) =>\n        drawPosition && drawPositions?.includes(drawPosition)\n    )\n    .map(({ roundNumber }) => roundNumber)\n    .sort(numericSort)[0];\n  return { initialRoundNumber };\n}\n","export const logColors = {\n  reset: '\\x1b[0m',\n  bright: '\\x1b[1m',\n  dim: '\\x1b[2m',\n\n  red: '\\x1b[31m',\n  brightred: '\\x1b[91m',\n  green: '\\x1b[32m',\n  brightgreen: '\\x1b[92m',\n  yellow: '\\x1b[33m',\n  brightyellow: '\\x1b[93m',\n  blue: '\\x1b[34m',\n  brightblue: '\\x1b[94m',\n  lightblue: '\\x1b[105m',\n  magenta: '\\x1b[35m',\n  brightmagenta: '\\x1b[95m',\n  cyan: '\\x1b[36m',\n  brightcyan: '\\x1b[96m',\n  white: '\\x1b[37m',\n  brightwhite: '\\x1b[97m',\n};\n\nexport const rgbColors = {\n  gold: [255, 215, 0],\n  pink: [233, 36, 116],\n  lime: [0, 255, 0],\n  orange: [255, 140, 0],\n  springGreen: [0, 255, 127],\n  tomato: [255, 99, 71],\n};\n\nexport const rgbToHex = (rgb) =>\n  rgb.reduce((accum, colorVal) => {\n    accum += colorVal.toString(16);\n    return accum;\n  }, '');\n","import { getDevContext } from '../state/globalState';\nimport { logColors } from './logColors';\n\nconst globalLog: any[] = [];\n\nexport function pushGlobalLog(value: any, devContextOverride?) {\n  if (typeof value === 'string') value = { method: value };\n  if (devContextOverride || getDevContext()) globalLog.push(value);\n}\n\nexport function popGlobalLog() {\n  return globalLog.pop();\n}\n\nexport function getGlobalLog(purge) {\n  const globalLogCopy = globalLog.slice();\n  if (purge) {\n    globalLog.length = 0;\n  }\n  return globalLogCopy;\n}\n\nexport function printGlobalLog(purge?) {\n  const globalLogCopy = getGlobalLog(purge);\n  const modifiedText = globalLogCopy.map((line) => {\n    const { color, keyColors, method, newline } = line;\n    const methodColor = Object.keys(logColors).includes(color)\n      ? logColors[color]\n      : logColors.cyan;\n    const bodyKeys = Object.keys(line).filter(\n      (key) => !['color', 'keyColors', 'method', 'newline'].includes(key)\n    );\n    const body = bodyKeys\n      .map((key) => {\n        const keyColor =\n          keyColors &&\n          Object.keys(keyColors).includes(key) &&\n          logColors[keyColors[key]]\n            ? logColors[keyColors[key]]\n            : logColors.brightwhite;\n        return `${logColors.white}${key}: ${keyColor}${line[key]}`;\n      })\n      .join(', ');\n    const tabs = method?.length < 15 ? `\\t\\t` : '\\t';\n    return [\n      newline ? '\\n' : '',\n      methodColor,\n      method,\n      tabs,\n      logColors.white,\n      body,\n      logColors.reset,\n      '\\n',\n    ].join('');\n  });\n  if (modifiedText?.length) console.log(...modifiedText);\n}\n\nexport function purgeGlobalLog() {\n  globalLog.length = 0;\n}\n","import { getStructureDrawPositionProfiles } from '../../../query/structure/getStructureDrawPositionProfiles';\nimport { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { getRoundMatchUps } from '../../../query/matchUps/getRoundMatchUps';\nimport { getInitialRoundNumber } from '../../../query/matchUps/getInitialRoundNumber';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { addPositionActionTelemetry } from '../../drawDefinitions/positionGovernor/addPositionActionTelemetry';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { pushGlobalLog } from '../../../global/functions/globalLog';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { numericSort } from '../../../utilities/sorting';\nimport { positionTargets } from './positionTargets';\nimport {\n  modifyMatchUpNotice,\n  modifyPositionAssignmentsNotice,\n} from '../../notifications/drawNotifications';\n\nimport { BYE, TO_BE_PLAYED } from '../../../constants/matchUpStatusConstants';\nimport { CONTAINER } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  MatchUpsMap,\n  getMatchUpsMap,\n} from '../../../query/matchUps/getMatchUpsMap';\nimport {\n  DRAW_POSITION_ACTIVE,\n  INVALID_DRAW_POSITION,\n  DRAW_POSITION_ASSIGNED,\n  MISSING_DRAW_DEFINITION,\n  STRUCTURE_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  MatchUp,\n  Structure,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\n/*\n  assignDrawPositionBye\n\n  supporting functions:\n  - drawPositionFilled\n  - setMatchUpStatusBYE\n  - assignRoundRobinBYE\n  - advanceDrawPosition\n\n  PSEUDOCODE:\n  *. Requires allDrawMatchUps inContext\n  *. Requires structureMatchUps\n \n  => assignDrawPositionBye\n  1. Modifies structure positionAssignments to assign BYE to position\n     - if structure is part of ROUND ROBIN then return { ...SUCCESS }\n  2. Finds the furthest advancement of the drawPosition to determine the matchUp where BYE-advancement needs to occur\n  3. Set the matchUpStatus to BYE\n  4. Check whether there is a position to Advance\n\n  If so...\n  => advancePosition\n  5a. Use links to find winnerMatchUp and loserMatchUp\n\n  6. If winnerMatchUp is part of same structure...\n  6a. Add drawPosition to target matchUp \n  6b. Check for further advancement and if so, go back to step #5\n  6b. If no further positions to advance check for FMLC Consolation BYE assignment\n\n  7. If loserMatchUp is part of different structure... return to step #1\n */\n\ntype AssignDrawPositionByeArgs = {\n  provisionalPositioning?: boolean;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  isPositionAction?: boolean;\n  matchUpsMap?: MatchUpsMap;\n  structure?: Structure;\n  drawPosition: number;\n  structureId?: string;\n  event?: Event;\n};\n\nexport function assignDrawPositionBye({\n  provisionalPositioning,\n  isPositionAction,\n  tournamentRecord,\n  drawDefinition,\n  drawPosition,\n  matchUpsMap,\n  structureId,\n  structure,\n  event,\n}: AssignDrawPositionByeArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structure)\n    ({ structure } = findStructure({ drawDefinition, structureId }));\n\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n  if (!structureId) ({ structureId } = structure);\n\n  const stack = 'assignDrawPositionBye';\n  pushGlobalLog({ method: stack, color: 'cyan', drawPosition });\n\n  if (!matchUpsMap) {\n    matchUpsMap = getMatchUpsMap({ drawDefinition });\n  }\n  const { positionAssignments } = getPositionAssignments({ structure });\n  const { activeDrawPositions } = getStructureDrawPositionProfiles({\n    drawDefinition,\n    structureId,\n  });\n\n  const currentAssignment = positionAssignments?.find(\n    (assignment) => assignment.drawPosition === drawPosition\n  );\n\n  if (currentAssignment?.bye) {\n    return { ...SUCCESS };\n  }\n\n  // ################### Check error conditions ######################\n  const drawPositionIsActive = activeDrawPositions?.includes(drawPosition);\n  if (drawPositionIsActive) {\n    return { error: DRAW_POSITION_ACTIVE };\n  }\n\n  const positionAssignment = positionAssignments?.find(\n    (assignment) => assignment.drawPosition === drawPosition\n  );\n  if (!positionAssignment) return { error: INVALID_DRAW_POSITION };\n\n  const { filled, containsBye, assignedParticipantId } =\n    drawPositionFilled(positionAssignment);\n  if (containsBye) return { ...SUCCESS }; // nothing to be done\n\n  if (filled && !containsBye) {\n    return decorateResult({ result: { error: DRAW_POSITION_ASSIGNED }, stack });\n  }\n\n  // ########## gather reusable data for performance optimization ###########\n  const inContextDrawMatchUps =\n    getAllDrawMatchUps({\n      inContext: true,\n      drawDefinition,\n      matchUpsMap,\n    }).matchUps ?? [];\n\n  const matchUpFilters = { isCollectionMatchUp: false };\n  const { matchUps } = getAllStructureMatchUps({\n    provisionalPositioning,\n    drawDefinition,\n    matchUpFilters,\n    matchUpsMap,\n    structure,\n  });\n\n  // modifies the structure's positionAssignments\n  // applies to both ELIMINATION and ROUND_ROBIN structures\n  positionAssignments?.forEach((assignment) => {\n    if (assignment.drawPosition === drawPosition) {\n      assignment.bye = true;\n    }\n  });\n\n  if (structure.structureType === CONTAINER) {\n    assignRoundRobinBYE({\n      tournamentRecord,\n      drawDefinition,\n      drawPosition,\n      matchUps,\n    });\n\n    modifyPositionAssignmentsNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      drawDefinition,\n      structure,\n      event,\n    });\n\n    return successNotice({\n      assignedParticipantId,\n      isPositionAction,\n      drawDefinition,\n      drawPosition,\n      structureId,\n      stack,\n    });\n  }\n\n  // ############ Get furthest advancement of drawPosition ############\n  const { roundProfile, roundMatchUps } = getRoundMatchUps({ matchUps });\n\n  // search from final rounds towards first rounds to find furthest advancement\n  const roundNumbers =\n    roundProfile &&\n    Object.keys(roundProfile)\n      .map((roundNumber) => parseInt(roundNumber))\n      .reverse();\n  const roundNumber = roundNumbers?.find((roundNumber) => {\n    return roundProfile?.[roundNumber].drawPositions?.includes(drawPosition);\n  });\n\n  // matchUp where BYE-advancement needs to occur\n  const matchUp = roundNumber\n    ? roundMatchUps?.[roundNumber].find(\n        ({ drawPositions }) => drawPositions?.includes(drawPosition)\n      )\n    : undefined;\n\n  matchUp &&\n    setMatchUpStatusBYE({ tournamentRecord, drawDefinition, matchUp, event });\n\n  const drawPositionToAdvance = matchUp?.drawPositions?.find(\n    (position) => position !== drawPosition\n  );\n\n  if (matchUp && drawPositionToAdvance) {\n    const result = advanceDrawPosition({\n      sourceDrawPositions: matchUp.drawPositions,\n      matchUpId: matchUp.matchUpId,\n      inContextDrawMatchUps,\n      drawPositionToAdvance,\n      tournamentRecord,\n      drawDefinition,\n      matchUpsMap,\n    });\n    if (result.error) return result;\n  }\n\n  modifyPositionAssignmentsNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    drawDefinition,\n    structure,\n    event,\n  });\n\n  return successNotice({\n    assignedParticipantId,\n    isPositionAction,\n    drawDefinition,\n    drawPosition,\n    structureId,\n    stack,\n  });\n}\n\nfunction successNotice({\n  assignedParticipantId,\n  isPositionAction,\n  drawDefinition,\n  drawPosition,\n  structureId,\n  stack,\n}) {\n  if (isPositionAction) {\n    const positionAction = {\n      removedParticipantId: assignedParticipantId,\n      drawPosition,\n      structureId,\n      name: stack,\n    };\n    addPositionActionTelemetry({ drawDefinition, positionAction });\n  }\n\n  return decorateResult({ result: { ...SUCCESS }, stack });\n}\n\nfunction drawPositionFilled(positionAssignment) {\n  const containsBye = positionAssignment.bye;\n  const containsQualifier = positionAssignment.qualifier;\n  const assignedParticipantId = positionAssignment.participantId;\n  const filled = containsBye || containsQualifier || assignedParticipantId;\n  return { containsBye, containsQualifier, assignedParticipantId, filled };\n}\n\ntype SetMatchUpStatusByeArgs = {\n  tournamentRecord?: Tournament;\n  drawDefinition?: DrawDefinition;\n  eventId?: string;\n  matchUp: MatchUp;\n  event?: Event;\n};\nfunction setMatchUpStatusBYE({\n  tournamentRecord,\n  drawDefinition,\n  eventId,\n  matchUp,\n  event,\n}: SetMatchUpStatusByeArgs) {\n  Object.assign(matchUp, {\n    matchUpStatus: BYE,\n    score: undefined,\n    winningSide: undefined,\n  });\n\n  modifyMatchUpNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    eventId: eventId ?? event?.eventId,\n    context: 'setMatchUpStatusBye',\n    drawDefinition,\n    matchUp,\n  });\n}\n\ntype AssignRoundRobinByeArgs = {\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  drawPosition: number;\n  matchUps: MatchUp[];\n  event?: Event;\n};\n\nfunction assignRoundRobinBYE({\n  tournamentRecord,\n  drawDefinition,\n  drawPosition,\n  matchUps,\n  event,\n}: AssignRoundRobinByeArgs) {\n  matchUps.forEach((matchUp) => {\n    if (matchUp.drawPositions?.includes(drawPosition)) {\n      setMatchUpStatusBYE({\n        eventId: event?.eventId,\n        tournamentRecord,\n        drawDefinition,\n        matchUp,\n      });\n    }\n  });\n}\n\n// Looks to see whether a given matchUp has a winnerMatchup or a loserMatchUp\n// and if so advances the appropriate drawPosition into the targetMatchUp\ntype AdvanceDrawPositionType = {\n  inContextDrawMatchUps: HydratedMatchUp[];\n  sourceDrawPositions?: number[];\n  drawPositionToAdvance: number;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpsMap: MatchUpsMap;\n  matchUpId: string;\n  event?: Event;\n};\nexport function advanceDrawPosition({\n  drawPositionToAdvance,\n  inContextDrawMatchUps,\n  sourceDrawPositions,\n  tournamentRecord,\n  drawDefinition,\n  matchUpsMap,\n  matchUpId,\n  event,\n}: AdvanceDrawPositionType) {\n  const stack = 'advanceDrawPosition';\n  pushGlobalLog({ method: stack, color: 'cyan', drawPositionToAdvance });\n\n  const matchUp = matchUpsMap.drawMatchUps.find(\n    (matchUp) => matchUp.matchUpId === matchUpId\n  );\n  const inContextMatchUp = inContextDrawMatchUps.find(\n    (matchUp) => matchUp.matchUpId === matchUpId\n  );\n  const structureId = inContextMatchUp?.structureId;\n  const { structure } = findStructure({ drawDefinition, structureId });\n  const { positionAssignments } = getPositionAssignments({\n    structure,\n  });\n\n  const byeAssignedDrawPositions = positionAssignments\n    ?.filter((assignment) => assignment.bye)\n    .map((assignment) => assignment.drawPosition);\n\n  const losingDrawPosition = matchUp?.drawPositions?.find(\n    (drawPosition) => drawPosition !== drawPositionToAdvance\n  );\n  const losingDrawPosiitonIsBye =\n    losingDrawPosition &&\n    byeAssignedDrawPositions?.includes(losingDrawPosition);\n\n  const {\n    targetLinks: { loserTargetLink },\n    targetMatchUps: { loserMatchUp, winnerMatchUp, loserTargetDrawPosition },\n  } = positionTargets({\n    inContextDrawMatchUps,\n    drawDefinition,\n    matchUpId,\n  });\n\n  // only handling situation where winningMatchUp is in same structure\n  if (winnerMatchUp && winnerMatchUp.structureId === structure?.structureId) {\n    // NOTE: error conditions are ignored\n    advanceWinner({\n      drawPositionToAdvance,\n      inContextDrawMatchUps,\n      sourceDrawPositions,\n      tournamentRecord,\n      drawDefinition,\n      winnerMatchUp,\n      matchUpsMap,\n      event,\n    });\n  }\n\n  // only handling situation where a BYE is being placed in linked structure\n  // and linked structure is NOT the same structure\n  if (\n    loserMatchUp &&\n    losingDrawPosiitonIsBye &&\n    loserMatchUp.structureId !== structure?.structureId\n  ) {\n    const { roundNumber } = loserMatchUp;\n\n    if (roundNumber === 1) {\n      const result = assignDrawPositionBye({\n        structureId: loserTargetLink.target.structureId,\n        drawPosition: loserTargetDrawPosition,\n        tournamentRecord,\n        drawDefinition,\n        event,\n      });\n      if (result.error) return result;\n    } else {\n      assignFedDrawPositionBye({\n        loserTargetDrawPosition,\n        tournamentRecord,\n        loserTargetLink,\n        drawDefinition,\n        loserMatchUp,\n        matchUpsMap,\n        event,\n      });\n    }\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction advanceWinner({\n  drawPositionToAdvance,\n  inContextDrawMatchUps,\n  sourceDrawPositions,\n  tournamentRecord,\n  drawDefinition,\n  winnerMatchUp,\n  matchUpsMap,\n  event,\n}) {\n  const stack = 'advanceWinner';\n  const noContextWinnerMatchUp = matchUpsMap.drawMatchUps.find(\n    (matchUp) => matchUp.matchUpId === winnerMatchUp.matchUpId\n  );\n  const inContextMatchUp = inContextDrawMatchUps.find(\n    (matchUp) => matchUp.matchUpId === winnerMatchUp.matchUpId\n  );\n  const structureId = inContextMatchUp?.structureId;\n  const { structure } = findStructure({ drawDefinition, structureId });\n  const { positionAssignments } = getPositionAssignments({ structure });\n  const drawPositionToAdvanceAssigment = positionAssignments?.find(\n    ({ drawPosition }) => drawPosition === drawPositionToAdvance\n  );\n  const drawPositionToAdvanceIsBye = drawPositionToAdvanceAssigment?.bye;\n  const existingDrawPositions =\n    noContextWinnerMatchUp.drawPositions?.filter(Boolean);\n  const existingAssignments = positionAssignments?.filter(\n    (assignment) => existingDrawPositions?.includes(assignment.drawPosition)\n  );\n\n  const advancingAssignmentIsBye = positionAssignments?.find(\n    ({ drawPosition }) => drawPosition === drawPositionToAdvance\n  );\n\n  /// ????????????????????????????????????????\n  // This may be unnecessary....\n  const priorPair = sourceDrawPositions?.find(\n    (drawPosition) => drawPosition !== drawPositionToAdvance\n  );\n  const priorPairAssignment =\n    priorPair &&\n    existingAssignments?.find(({ drawPosition }) => drawPosition === priorPair);\n  const priorPairIsBye = priorPairAssignment?.bye;\n  const isByeAdvancedBye = drawPositionToAdvanceIsBye && priorPairIsBye;\n  if (isByeAdvancedBye) console.log({ isByeAdvancedBye });\n  /// ????????????????????????????????????????\n\n  if (\n    existingDrawPositions?.length > 1 &&\n    drawPositionToAdvanceIsBye &&\n    !priorPairIsBye\n  ) {\n    return decorateResult({ result: { error: DRAW_POSITION_ASSIGNED }, stack });\n  }\n  const pairedDrawPosition = existingDrawPositions?.find(\n    (drawPosition) => drawPosition !== drawPositionToAdvance\n  );\n\n  let drawPositionAssigned = isByeAdvancedBye;\n  // always ensure there are two drawPositions to iterate over\n  const twoDrawPositions = [\n    ...(noContextWinnerMatchUp.drawPositions || []).filter(Boolean),\n    undefined,\n    undefined,\n  ].slice(0, 2);\n\n  const drawPositions = twoDrawPositions\n    .map((position) => {\n      if (\n        (!position && !drawPositionAssigned) ||\n        position === drawPositionToAdvance\n      ) {\n        drawPositionAssigned = true;\n        return drawPositionToAdvance;\n      } else {\n        return position;\n      }\n    })\n    .sort(numericSort);\n\n  if (!drawPositionAssigned) {\n    console.log('@@@@@@@', {\n      advancingAssignmentIsBye,\n      drawPositionToAdvance,\n      existingAssignments,\n    });\n    return decorateResult({ result: { error: DRAW_POSITION_ASSIGNED }, stack });\n  }\n\n  const pairedDrawPositionIsBye = positionAssignments?.find(\n    ({ drawPosition }) => drawPosition === pairedDrawPosition\n  )?.bye;\n  const drawPositionIsBye = positionAssignments?.find(\n    ({ drawPosition }) => drawPosition === drawPositionToAdvance\n  )?.bye;\n\n  const matchUpStatus =\n    drawPositionIsBye || pairedDrawPositionIsBye ? BYE : TO_BE_PLAYED;\n\n  Object.assign(noContextWinnerMatchUp, {\n    matchUpStatus,\n    score: undefined,\n    winningSide: undefined,\n    drawPositions,\n  });\n\n  const changedDrawPosition = noContextWinnerMatchUp.drawPositions.find(\n    (position) => !twoDrawPositions.includes(position)\n  );\n\n  pushGlobalLog({\n    method: stack,\n    color: 'brightyellow',\n    changedDrawPosition,\n    pairedDrawPositionIsBye,\n    drawPositionIsBye,\n  });\n\n  modifyMatchUpNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    matchUp: noContextWinnerMatchUp,\n    eventId: event?.eventId,\n    context: stack,\n    drawDefinition,\n  });\n\n  const {\n    targetLinks: { loserTargetLink },\n    targetMatchUps: { loserMatchUp, loserTargetDrawPosition },\n  } = positionTargets({\n    matchUpId: winnerMatchUp.matchUpId,\n    inContextDrawMatchUps,\n    drawDefinition,\n  });\n\n  if (pairedDrawPositionIsBye || drawPositionIsBye) {\n    const advancingDrawPosition = pairedDrawPositionIsBye\n      ? drawPositionToAdvance\n      : pairedDrawPosition;\n\n    if (advancingDrawPosition) {\n      advanceDrawPosition({\n        drawPositionToAdvance: advancingDrawPosition,\n        matchUpId: winnerMatchUp.matchUpId,\n        inContextDrawMatchUps,\n        tournamentRecord,\n        drawDefinition,\n        matchUpsMap,\n      });\n    } else if (drawPositionIsBye && loserTargetLink && loserMatchUp) {\n      if (loserMatchUp.feedRound) {\n        assignFedDrawPositionBye({\n          loserTargetDrawPosition,\n          tournamentRecord,\n          loserTargetLink,\n          drawDefinition,\n          loserMatchUp,\n          matchUpsMap,\n        });\n      } else {\n        const sourceStructureRoundPosition = winnerMatchUp.roundPosition;\n        // loser drawPosition in target structure is determined bye even/odd\n        const targetDrawPositionIndex = 1 - (sourceStructureRoundPosition % 2);\n        const targetDrawPosition =\n          loserMatchUp.drawPositions[targetDrawPositionIndex];\n\n        const result = assignDrawPositionBye({\n          structureId: loserTargetLink.target.structureId,\n          drawPosition: targetDrawPosition,\n          tournamentRecord,\n          drawDefinition,\n          event,\n        });\n        if (result.error) return result;\n      }\n    }\n  }\n}\n\ntype AssignFedDrawPositionByeType = {\n  loserTargetDrawPosition: number;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  loserMatchUp: HydratedMatchUp;\n  matchUpsMap: MatchUpsMap;\n  loserTargetLink: any;\n  event?: Event;\n};\n\nfunction assignFedDrawPositionBye({\n  loserTargetDrawPosition,\n  tournamentRecord,\n  loserTargetLink,\n  drawDefinition,\n  loserMatchUp,\n  matchUpsMap,\n  event,\n}: AssignFedDrawPositionByeType) {\n  const { roundNumber } = loserMatchUp;\n\n  const stack = 'assignFedDrawPositionBye';\n  pushGlobalLog({ method: stack, color: 'cyan', loserTargetDrawPosition });\n\n  const mappedMatchUps = matchUpsMap?.mappedMatchUps || {};\n  const loserStructureMatchUps =\n    mappedMatchUps[loserMatchUp.structureId].matchUps;\n  const { initialRoundNumber } = getInitialRoundNumber({\n    drawPosition: loserTargetDrawPosition,\n    matchUps: loserStructureMatchUps,\n  });\n  if (initialRoundNumber === roundNumber) {\n    const result = assignDrawPositionBye({\n      structureId: loserTargetLink.target.structureId,\n      drawPosition: loserTargetDrawPosition,\n      tournamentRecord,\n      drawDefinition,\n      event,\n    });\n    if (result.error) return result;\n  }\n}\n","import { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\n\nimport { BYE, TO_BE_PLAYED } from '../../../constants/matchUpStatusConstants';\nimport { MatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport {\n  DrawDefinition,\n  Event,\n  PositionAssignment,\n  Structure,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype ModifyRoundRobinMatchUpStatusArgs = {\n  positionAssignments: PositionAssignment[];\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  structure: Structure;\n  event?: Event;\n};\nexport function modifyRoundRobinMatchUpsStatus({\n  positionAssignments,\n  tournamentRecord,\n  drawDefinition,\n  matchUpsMap,\n  structure,\n  event,\n}: ModifyRoundRobinMatchUpStatusArgs) {\n  const { matchUps } = getAllStructureMatchUps({\n    drawDefinition,\n    matchUpsMap,\n    structure,\n    event,\n  });\n\n  matchUps.forEach((matchUp) => {\n    const matchUpAssignments = positionAssignments.filter(\n      ({ drawPosition }) => matchUp.drawPositions?.includes(drawPosition)\n    );\n    const matchUpContainsBye = matchUpAssignments.filter(\n      (assignment) => assignment.bye\n    ).length;\n\n    if (!matchUp.winningSide) {\n      const matchUpStatus = matchUpContainsBye ? BYE : TO_BE_PLAYED;\n\n      Object.assign(matchUp, { matchUpStatus });\n      modifyMatchUpNotice({\n        tournamentId: tournamentRecord?.tournamentId,\n        context: 'modifyRoundRobinMatchUpsStatus',\n        eventId: event?.eventId,\n        drawDefinition,\n        matchUp,\n      });\n    }\n  });\n}\n","import { getStructureDrawPositionProfiles } from '../../../query/structure/getStructureDrawPositionProfiles';\nimport { modifyRoundRobinMatchUpsStatus } from '../matchUpStatus/modifyRoundRobinMatchUpsStatus';\nimport { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { getInitialRoundNumber } from '../../../query/matchUps/getInitialRoundNumber';\nimport { getRoundMatchUps } from '../../../query/matchUps/getRoundMatchUps';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { pushGlobalLog } from '../../../global/functions/globalLog';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { ensureInt } from '../../../utilities/ensureInt';\nimport { positionTargets } from './positionTargets';\nimport { overlap } from '../../../utilities/arrays';\nimport {\n  getPositionAssignments,\n  structureAssignedDrawPositions,\n} from '../../../query/drawDefinition/positionsGetter';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../../global/functions/decorateResult';\nimport {\n  MatchUpsMap,\n  getMatchUpsMap,\n} from '../../../query/matchUps/getMatchUpsMap';\nimport {\n  modifyPositionAssignmentsNotice,\n  modifyMatchUpNotice,\n} from '../../notifications/drawNotifications';\n\nimport { CONTAINER, DRAW } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport { TEAM } from '../../../constants/matchUpTypes';\nimport {\n  BYE,\n  DEFAULTED,\n  TO_BE_PLAYED,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\n\nimport {\n  DRAW_POSITION_ACTIVE,\n  MISSING_DRAW_POSITION,\n  DRAW_POSITION_NOT_CLEARED,\n  ErrorType,\n  STRUCTURE_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  PositionAssignment,\n  Structure,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype ClearDrawPositionArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  participantId?: string;\n  drawPosition?: number;\n  structureId: string;\n  event?: Event;\n};\nexport function clearDrawPosition(\n  params: ClearDrawPositionArgs\n): ResultType & { participantId?: string } {\n  let { inContextDrawMatchUps, participantId, drawPosition } = params;\n  const { tournamentRecord, drawDefinition, structureId, matchUpsMap, event } =\n    params;\n  const { structure } = findStructure({ drawDefinition, structureId });\n  const positionAssignments =\n    structureAssignedDrawPositions({\n      drawDefinition,\n      structure,\n    }).positionAssignments || [];\n\n  const existingAssignment = positionAssignments.find(\n    (assignment) =>\n      (participantId && assignment.participantId === participantId) ||\n      (drawPosition && assignment.drawPosition === drawPosition)\n  );\n\n  if (existingAssignment && participantId && !drawPosition) {\n    drawPosition = existingAssignment?.drawPosition;\n  }\n  if (!drawPosition) return { error: MISSING_DRAW_POSITION };\n  if (!participantId) participantId = existingAssignment?.participantId;\n\n  const { activeDrawPositions } = getStructureDrawPositionProfiles({\n    drawDefinition,\n    structureId,\n  });\n  const drawPositionIsActive = activeDrawPositions.includes(drawPosition);\n\n  // drawPosition may not be cleared if:\n  // 1. drawPosition has been advanced by winning a matchUp\n  // 2. drawPosition is paired with another drawPosition which has been advanced by winning a matchUp\n  if (drawPositionIsActive) {\n    return { error: DRAW_POSITION_ACTIVE };\n  }\n\n  if (!inContextDrawMatchUps) {\n    ({ matchUps: inContextDrawMatchUps } = getAllDrawMatchUps({\n      inContext: true,\n      drawDefinition,\n      matchUpsMap,\n    }));\n  }\n\n  const result = drawPositionRemovals({\n    inContextDrawMatchUps,\n    tournamentRecord,\n    drawDefinition,\n    structureId,\n    drawPosition,\n    matchUpsMap,\n    event,\n  });\n\n  if (!result.drawPositionCleared) return { error: DRAW_POSITION_NOT_CLEARED };\n\n  modifyPositionAssignmentsNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    drawDefinition,\n    structure,\n    event,\n  });\n\n  return { ...SUCCESS, participantId };\n}\n\ntype DrawPositionRemovalsArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  drawPosition: number;\n  structureId: string;\n  event?: Event;\n};\nexport function drawPositionRemovals({\n  inContextDrawMatchUps,\n  tournamentRecord,\n  drawDefinition,\n  drawPosition,\n  matchUpsMap,\n  structureId,\n  event,\n}: DrawPositionRemovalsArgs) {\n  const { structure } = findStructure({ drawDefinition, structureId });\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n  const positionAssignments =\n    structureAssignedDrawPositions({\n      drawDefinition,\n      structure,\n    }).positionAssignments || [];\n\n  const drawPositionCleared = positionAssignments.some((assignment) => {\n    if (assignment.drawPosition === drawPosition) {\n      delete assignment.participantId;\n      delete assignment.qualifier;\n      delete assignment.bye;\n      return true;\n    }\n    return undefined;\n  });\n\n  if (structure.structureType === CONTAINER) {\n    modifyRoundRobinMatchUpsStatus({\n      positionAssignments,\n      tournamentRecord,\n      drawDefinition,\n      matchUpsMap,\n      structure,\n    });\n    return { drawPositionCleared, ...SUCCESS };\n  }\n\n  const matchUpFilters = { isCollectionMatchUp: false };\n  const { matchUps: structureMatchUps } = getAllStructureMatchUps({\n    drawDefinition,\n    matchUpFilters,\n    matchUpsMap,\n    structure,\n    event,\n  });\n  const { roundProfile, roundMatchUps } = getRoundMatchUps({\n    matchUps: structureMatchUps,\n  });\n  const profileKeys = roundProfile && Object.keys(roundProfile);\n  const roundNumbers = profileKeys?.map((roundNumber) =>\n    ensureInt(roundNumber)\n  );\n\n  let targetDrawPosition: any = drawPosition;\n  const pairingDetails = roundNumbers\n    ?.map((roundNumber) => {\n      // find the pair of drawPositions which includes the targetDrawPosition\n      const profile = roundProfile?.[roundNumber];\n      const relevantPair = profile?.pairedDrawPositions?.find((drawPositions) =>\n        drawPositions.includes(targetDrawPosition)\n      );\n      // find the drawPosition which is paired with the targetDrawPosition\n      const pairedDrawPosition: any = relevantPair?.find(\n        (currentDrawPosition) => currentDrawPosition !== targetDrawPosition\n      );\n      // find the assignment for the paired drawPosition\n      const pairedDrawPositionAssignment = positionAssignments.find(\n        (assignment) => assignment.drawPosition === pairedDrawPosition\n      );\n      const nextRoundProfile = roundProfile?.[roundNumber + 1];\n      // whether or not the pairedDrawPosition is a BYE\n      const pairedDrawPositionIsBye = pairedDrawPositionAssignment?.bye;\n      // whether or not the pairedDrawPosition is present in the next round\n      const pairedDrawPositionInNextRound =\n        nextRoundProfile?.pairedDrawPositions?.find((pairedPositions: any) =>\n          pairedPositions.includes(pairedDrawPosition)\n        );\n      // pairedDrawPosition is a transitiveBye if it is a BYE and if it is present in next round\n      const isTransitiveBye =\n        pairedDrawPositionIsBye &&\n        pairedDrawPositionInNextRound &&\n        nextRoundProfile &&\n        nextRoundProfile.drawPositions?.includes(pairedDrawPosition);\n      const pairedDrawPositionByeAdvancedPair =\n        !isTransitiveBye && pairedDrawPositionInNextRound;\n\n      const result = relevantPair && {\n        pairedDrawPositionByeAdvancedPair,\n        pairedDrawPosition,\n        targetDrawPosition,\n        relevantPair,\n        roundNumber,\n      };\n\n      // if the pairedDrawPosition is a BYE, continue search with pairedDrawPoaition as targetDrawPosition\n      if (isTransitiveBye) targetDrawPosition = pairedDrawPosition;\n\n      return result;\n    })\n    .filter((f) => f?.targetDrawPosition);\n\n  const tasks: any = pairingDetails?.reduce((tasks, pairingDetail: any) => {\n    const {\n      roundNumber,\n      relevantPair,\n      targetDrawPosition,\n      pairedDrawPosition,\n      pairedDrawPositionByeAdvancedPair,\n    } = pairingDetail;\n    const roundRemoval = { roundNumber, targetDrawPosition, relevantPair };\n    const byeAdvancedRemoval = pairedDrawPositionByeAdvancedPair && {\n      roundNumber: roundNumber + 1,\n      targetDrawPosition: pairedDrawPosition,\n      relevantPair: pairedDrawPositionByeAdvancedPair,\n      subsequentRoundRemoval: true,\n    };\n    const newTasks = [roundRemoval, byeAdvancedRemoval].filter(Boolean);\n    return tasks.concat(...newTasks);\n  }, []);\n\n  tasks?.forEach(({ roundNumber, targetDrawPosition, relevantPair }) => {\n    const targetMatchUp = roundMatchUps?.[roundNumber].find((matchUp) =>\n      overlap(\n        matchUp.drawPositions?.filter(Boolean),\n        relevantPair.filter(Boolean)\n      )\n    );\n    if (!targetMatchUp) {\n      return;\n    }\n\n    removeSubsequentRoundsParticipant({\n      inContextDrawMatchUps,\n      targetDrawPosition,\n      tournamentRecord,\n      drawDefinition,\n      structureId,\n      roundNumber,\n      matchUpsMap,\n    });\n\n    removeDrawPosition({\n      inContextDrawMatchUps,\n      positionAssignments,\n      tournamentRecord,\n      drawDefinition,\n      targetMatchUp,\n      drawPosition,\n      matchUpsMap,\n      structure,\n      event,\n    });\n  });\n\n  return { tasks, drawPositionCleared, positionAssignments };\n}\n\nfunction removeSubsequentRoundsParticipant({\n  inContextDrawMatchUps,\n  targetDrawPosition,\n  tournamentRecord,\n  drawDefinition,\n  matchUpsMap,\n  roundNumber,\n  structureId,\n}) {\n  const { structure } = findStructure({ drawDefinition, structureId });\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n  if (structure.structureType === CONTAINER) return;\n\n  matchUpsMap = matchUpsMap || getMatchUpsMap({ drawDefinition });\n  const mappedMatchUps = matchUpsMap?.mappedMatchUps || {};\n  const matchUps = mappedMatchUps[structureId].matchUps;\n\n  const { initialRoundNumber } = getInitialRoundNumber({\n    drawPosition: targetDrawPosition,\n    matchUps,\n  });\n\n  const relevantMatchUps = matchUps?.filter(\n    (matchUp) =>\n      matchUp.roundNumber >= roundNumber &&\n      matchUp.roundNumber !== initialRoundNumber &&\n      matchUp.drawPositions?.includes(targetDrawPosition)\n  );\n\n  const positionAssignments =\n    getPositionAssignments({\n      drawDefinition,\n      structureId,\n    }).positionAssignments ?? [];\n\n  relevantMatchUps?.forEach((matchUp) =>\n    removeDrawPosition({\n      drawPosition: targetDrawPosition,\n      targetMatchUp: matchUp,\n      inContextDrawMatchUps,\n      positionAssignments,\n      tournamentRecord,\n      drawDefinition,\n      matchUpsMap,\n      structure,\n    })\n  );\n  return { ...SUCCESS };\n}\n\ntype RemoveDrawPositionArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  positionAssignments: PositionAssignment[];\n  targetMatchUp: HydratedMatchUp;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  drawPosition: number;\n  structure: Structure;\n  event?: Event;\n};\nfunction removeDrawPosition({\n  inContextDrawMatchUps,\n  positionAssignments,\n  tournamentRecord,\n  drawDefinition,\n  targetMatchUp,\n  drawPosition,\n  matchUpsMap,\n  structure,\n  event,\n}: RemoveDrawPositionArgs) {\n  const stack = 'removeDrawPosition';\n  const initialDrawPositions = targetMatchUp.drawPositions?.slice();\n  const initialMatchUpStatus = targetMatchUp.matchUpStatus;\n  const initialWinningSide = targetMatchUp.winningSide;\n\n  matchUpsMap = matchUpsMap ?? getMatchUpsMap({ drawDefinition });\n  const mappedMatchUps = matchUpsMap.mappedMatchUps;\n  const matchUps = mappedMatchUps[structure.structureId].matchUps;\n  const { initialRoundNumber } = getInitialRoundNumber({\n    drawPosition,\n    matchUps,\n  });\n\n  if (\n    targetMatchUp.roundNumber &&\n    initialRoundNumber &&\n    targetMatchUp.roundNumber > initialRoundNumber\n  ) {\n    const drawPositions: any[] = (targetMatchUp.drawPositions ?? []).map(\n      (currentDrawPosition) =>\n        currentDrawPosition === drawPosition ? undefined : currentDrawPosition\n    );\n    targetMatchUp.drawPositions = drawPositions as number[];\n  }\n\n  if (targetMatchUp.matchUpType === TEAM) {\n    const inContextTargetMatchUp = inContextDrawMatchUps?.find(\n      (matchUp) => matchUp.matchUpId === targetMatchUp.matchUpId\n    );\n    const sides: any[] = inContextTargetMatchUp?.sides ?? [];\n    const drawPositionSideIndex = sides.reduce(\n      (index, side, i) => (side.drawPosition === drawPosition ? i : index),\n      undefined\n    );\n\n    if (\n      drawPositionSideIndex !== undefined &&\n      targetMatchUp.sides?.[drawPositionSideIndex]?.lineUp\n    ) {\n      delete targetMatchUp.sides?.[drawPositionSideIndex].lineUp;\n\n      modifyMatchUpNotice({\n        tournamentId: tournamentRecord?.tournamentId,\n        context: `${stack}-TEAM`,\n        eventId: event?.eventId,\n        matchUp: targetMatchUp,\n        drawDefinition,\n      });\n    }\n  }\n\n  const targetData = positionTargets({\n    matchUpId: targetMatchUp.matchUpId,\n    inContextDrawMatchUps,\n    drawDefinition,\n  });\n\n  const {\n    targetLinks: { winnerTargetLink },\n    targetMatchUps: {\n      loserMatchUp,\n      winnerMatchUp,\n      loserMatchUpDrawPositionIndex,\n      // winnerMatchUpDrawPositionIndex,\n    },\n  } = targetData;\n\n  const matchUpAssignments = positionAssignments.filter(\n    ({ drawPosition }) => targetMatchUp.drawPositions?.includes(drawPosition)\n  );\n  const matchUpContainsBye = matchUpAssignments.filter(\n    (assignment) => assignment.bye\n  ).length;\n\n  const newMatchUpStatus =\n    (matchUpContainsBye && BYE) ||\n    (targetMatchUp.matchUpStatus &&\n      [DEFAULTED, WALKOVER].includes(targetMatchUp.matchUpStatus) &&\n      targetMatchUp.matcHUpStatus) ||\n    (targetMatchUp.drawPositions?.length === 2 && TO_BE_PLAYED) ||\n    undefined;\n\n  targetMatchUp.matchUpStatus = newMatchUpStatus;\n\n  // if the matchUpStatus is WALKOVER then it is DOUBLE_WALKOVER produced\n  // if the matchUpStatus is DEFAULTED then it is DOUBLE_DEFAULT produced\n  // ... and the winningSide must be removed\n  if (\n    targetMatchUp.matchUpStatus &&\n    [WALKOVER, DEFAULTED].includes(targetMatchUp.matchUpStatus)\n  )\n    targetMatchUp.winningSide = undefined;\n\n  const removedDrawPosition = initialDrawPositions?.find(\n    (position) => !targetMatchUp.drawPositions?.includes(position)\n  );\n  const noChange =\n    initialDrawPositions?.includes(drawPosition) &&\n    initialMatchUpStatus === targetMatchUp.matchUpStatus &&\n    initialWinningSide === targetMatchUp.winningSide;\n\n  if (!noChange) {\n    if (removedDrawPosition) {\n      pushGlobalLog({\n        method: stack,\n        color: 'brightyellow',\n        removedDrawPosition,\n      });\n    }\n\n    modifyMatchUpNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      eventId: event?.eventId,\n      matchUp: targetMatchUp,\n      context: `${stack}-${drawPosition}`,\n      drawDefinition,\n    });\n  }\n\n  if (\n    loserMatchUp &&\n    loserMatchUp.structureId !== targetData.matchUp.structureId &&\n    !matchUpContainsBye\n  ) {\n    const { drawPositions, roundNumber } = loserMatchUp;\n\n    if (roundNumber === 1) {\n      const loserMatchUpDrawPosition =\n        drawPositions[loserMatchUpDrawPositionIndex];\n\n      drawPositionRemovals({\n        structureId: loserMatchUp.structureId,\n        drawPosition: loserMatchUpDrawPosition,\n        inContextDrawMatchUps,\n        tournamentRecord,\n        drawDefinition,\n        matchUpsMap,\n      });\n    } else {\n      // for fed rounds the loserMatchUpDrawPosiiton is always the fed drawPosition\n      // which is always the lowest numerical drawPosition\n      const loserMatchUpDrawPosition = Math.min(\n        ...drawPositions.filter(Boolean)\n      );\n\n      const result = consolationCleanup({\n        loserMatchUpDrawPosition,\n        inContextDrawMatchUps,\n        tournamentRecord,\n        drawDefinition,\n        loserMatchUp,\n        matchUpsMap,\n        event,\n      });\n      if (result.error) return decorateResult({ result, stack });\n\n      const mappedMatchUps = matchUpsMap?.mappedMatchUps || {};\n      const loserStructureMatchUps =\n        mappedMatchUps[loserMatchUp.structureId].matchUps;\n\n      const { initialRoundNumber } = getInitialRoundNumber({\n        drawPosition: loserMatchUpDrawPosition,\n        matchUps: loserStructureMatchUps,\n      });\n\n      // if clearing a drawPosition from a feed round the initialRoundNumber for the drawPosition must be { roundNumber: 1 }\n      if (initialRoundNumber === 1) {\n        pushGlobalLog({\n          method: stack,\n          color: 'brightyellow',\n          loserMatchUpDrawPosition,\n        });\n\n        drawPositionRemovals({\n          structureId: loserMatchUp.structureId,\n          drawPosition: loserMatchUpDrawPosition,\n          inContextDrawMatchUps,\n          tournamentRecord,\n          drawDefinition,\n          matchUpsMap,\n        });\n      }\n    }\n  }\n\n  if (\n    winnerMatchUp &&\n    winnerMatchUp.structureId !== targetData.matchUp.structureId &&\n    // does not apply to traversals that are based on QUALIFYING\n    winnerTargetLink.target.feedProfile !== DRAW\n  ) {\n    /*\n    const { structure } = findStructure({\n      structureId: targetData.matchUp.structureId,\n      drawDefinition,\n    });\n\n    if (/* is not a qualifying structure *?)\n      console.log('linked structure winnerMatchUp removal', {\n        winnerMatchUpDrawPositionIndex,\n        winnerTargetLink,\n      });\n      */\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction consolationCleanup({\n  loserMatchUpDrawPosition,\n  inContextDrawMatchUps,\n  tournamentRecord,\n  drawDefinition,\n  loserMatchUp,\n  matchUpsMap,\n  event,\n}): { error?: ErrorType; success?: boolean } {\n  const { structure } = findStructure({\n    structureId: loserMatchUp.structureId,\n    drawDefinition,\n  });\n  const { positionAssignments } = getPositionAssignments({ structure });\n  const assignment = positionAssignments?.find(\n    (assignment) => assignment.drawPosition === loserMatchUpDrawPosition\n  );\n\n  if (assignment?.bye) {\n    const result = clearDrawPosition({\n      drawPosition: loserMatchUpDrawPosition,\n      structureId: loserMatchUp.structureId,\n      inContextDrawMatchUps,\n      tournamentRecord,\n      drawDefinition,\n      matchUpsMap,\n      event,\n    });\n    if (result.error) return result;\n  }\n\n  return { ...SUCCESS };\n}\n","import { xa } from '../../utilities/objects';\nimport { getPositionAssignments } from './positionsGetter';\nimport { unique } from '../../utilities/arrays';\n\nimport { MISSING_DRAW_DEFINITION } from '../../constants/errorConditionConstants';\nimport { DrawDefinition, StageTypeUnion } from '../../types/tournamentTypes';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { SUCCESS } from '../../constants/resultConstants';\n\n// build up an array of participantIds which are assigned positions in structures\n// optionally filter to included only specified stages\n\ntype GetAssignedParticipantIdsArgs = {\n  drawDefinition: DrawDefinition;\n  stages?: StageTypeUnion[];\n};\n\nexport function getAssignedParticipantIds({ drawDefinition, stages }: GetAssignedParticipantIdsArgs): ResultType & {\n  assignedParticipantIds?: string[];\n} {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  const stageStructures = (drawDefinition?.structures ?? []).filter(\n    (structure) => !stages?.length || (structure.stage && stages.includes(structure.stage)),\n  );\n  const assignedParticipantIds = unique(\n    stageStructures\n      .map((structure) => {\n        const { positionAssignments } = getPositionAssignments({\n          structure,\n        });\n        return positionAssignments ? positionAssignments.map(xa('participantId')) : [];\n      })\n      .flat()\n      .filter(Boolean),\n  );\n\n  return { ...SUCCESS, assignedParticipantIds };\n}\n","import { MAIN } from '../../constants/drawDefinitionConstants';\n\n/**\n *\n * @param {object[]} entries - array of entry objects\n * @returns entries - with updated entryPosition values\n */\nexport function refreshEntryPositions(params) {\n  const stagedEntries = (params?.entries ?? [])\n    .filter(Boolean)\n    .reduce((stages, entry) => {\n      const { entryStage, entryStatus } = entry;\n      const entryHash = `_${entryStage || MAIN}${entryStatus || ''}`;\n      if (!stages[entryHash]) stages[entryHash] = [];\n      stages[entryHash].push(entry);\n      return stages;\n    }, {});\n\n  const validEntryPosition = (entryPosition) =>\n    !isNaN(entryPosition) ? entryPosition : Infinity;\n\n  return Object.keys(stagedEntries)\n    .map((entryHash) => {\n      return stagedEntries[entryHash]\n        .sort(\n          (a, b) =>\n            validEntryPosition(a.entryPosition) -\n            validEntryPosition(b.entryPosition)\n        )\n        .map((entry, index) => {\n          const entryPosition = index + 1;\n          return { ...entry, entryPosition };\n        });\n    })\n    .flat();\n}\n","import { UNGROUPED, UNPAIRED } from '../../constants/entryStatusConstants';\n\nexport function isUngrouped(entryStatus) {\n  return [UNPAIRED, UNGROUPED].includes(entryStatus);\n}\n","import { getAssignedParticipantIds } from '../../query/drawDefinition/getAssignedParticipantIds';\nimport { refreshEntryPositions } from './refreshEntryPositions';\nimport { findParticipant } from '../../acquire/findParticipant';\nimport { modifyDrawNotice } from '../notifications/drawNotifications';\nimport { removeExtension } from '../extensions/removeExtension';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { isValidExtension } from '../../validators/isValidExtension';\nimport { addExtension } from '../extensions/addExtension';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { isUngrouped } from '../../query/entries/isUngrouped';\n\nimport { validStages } from '../../constants/drawDefinitionConstants';\nimport { DOUBLES, TEAM_EVENT } from '../../constants/eventConstants';\nimport {\n  INDIVIDUAL,\n  PAIR,\n  TEAM_PARTICIPANT,\n} from '../../constants/participantConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ENTRY_STATUS_NOT_ALLOWED_FOR_EVENT,\n  INVALID_ENTRY_STATUS,\n  INVALID_PARTICIPANT_ID,\n  MISSING_EVENT,\n  EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT,\n  MISSING_VALUE,\n  INVALID_VALUES,\n  INVALID_STAGE,\n} from '../../constants/errorConditionConstants';\nimport {\n  ALTERNATE,\n  DRAW_SPECIFIC_STATUSES,\n  EQUIVALENT_ACCEPTANCE_STATUSES,\n  VALID_ENTRY_STATUSES,\n  WITHDRAWN,\n} from '../../constants/entryStatusConstants';\n\nimport {\n  DrawDefinition,\n  Entry,\n  EntryStatusUnion,\n  Event,\n  Extension,\n  StageTypeUnion,\n  Tournament,\n} from '../../types/tournamentTypes';\n\n// disallow changing entryStatus to WITHDRAWN or UNGROUPED for assignedParticipants\ntype ModifyEntriesStatusArgs = {\n  drawDefinition?: DrawDefinition;\n  autoEntryPositions?: boolean;\n  tournamentRecord: Tournament;\n  entryStatus?: EntryStatusUnion;\n  ignoreAssignment?: boolean;\n  entryStage?: StageTypeUnion;\n  participantIds: string[];\n  extension?: Extension;\n  eventSync?: boolean;\n  drawId: string;\n  stage?: StageTypeUnion;\n  event?: Event;\n};\nexport function modifyEntriesStatus({\n  autoEntryPositions = true,\n  ignoreAssignment, // override check for existing assignments\n  tournamentRecord,\n  drawDefinition,\n  participantIds,\n  entryStatus,\n  entryStage,\n  extension, // modify the specified extension (remove if value undefined)\n  eventSync,\n  drawId,\n  stage,\n  event,\n}: ModifyEntriesStatusArgs) {\n  if (!participantIds || !Array.isArray(participantIds))\n    return {\n      error: INVALID_PARTICIPANT_ID,\n      method: 'modifyEntriesStatus',\n      participantIds,\n    };\n\n  if (!drawDefinition && !event) return { error: MISSING_EVENT };\n  if (entryStatus && !VALID_ENTRY_STATUSES.includes(entryStatus))\n    return { error: INVALID_ENTRY_STATUS };\n\n  if (entryStage && !validStages.includes(entryStage))\n    return { error: INVALID_STAGE };\n\n  const stack = 'modifyEntriesStatus';\n  const modifiedDrawIds: string[] = [];\n\n  if (!entryStatus && !extension)\n    return decorateResult({\n      result: { error: MISSING_VALUE },\n      info: 'Missing entryStatus',\n      stack,\n    });\n\n  if (\n    extension &&\n    !isValidExtension({ extension, requiredAttributes: ['name'] })\n  )\n    // valid without value (will remove extension)\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      info: 'Invalid extension',\n      context: { extension },\n      stack,\n    });\n\n  // build up an array of participantIds which are assigned positions in structures\n  const assignedParticipantIds: string[] = [];\n  event?.drawDefinitions?.forEach((drawDefinition) => {\n    const participantIds =\n      getAssignedParticipantIds({\n        stages: stage && [stage],\n        drawDefinition,\n      }).assignedParticipantIds ?? [];\n    assignedParticipantIds.push(...participantIds);\n  });\n\n  const tournamentParticipants = tournamentRecord?.participants ?? [];\n\n  const validEntryStatusForAllParticipantIds = participantIds.every(\n    (participantId) => {\n      const participantType = findParticipant({\n        tournamentParticipants,\n        participantId,\n      })?.participantType;\n      return (\n        !(\n          participantType &&\n          [PAIR, TEAM_PARTICIPANT].includes(participantType) &&\n          isUngrouped(entryStatus)\n        ) &&\n        !(\n          entryStatus &&\n          event?.eventType &&\n          participantType === INDIVIDUAL &&\n          [DOUBLES, TEAM_EVENT].includes(event.eventType) &&\n          [ALTERNATE, ...EQUIVALENT_ACCEPTANCE_STATUSES].includes(entryStatus)\n        )\n      );\n    }\n  );\n\n  if (!validEntryStatusForAllParticipantIds)\n    return { error: INVALID_ENTRY_STATUS };\n\n  const flightProfile = event && getFlightProfile({ event }).flightProfile;\n  const flight = flightProfile?.flights?.find(\n    (flight) => flight.drawId === drawId\n  );\n\n  // ------------------------------------------------------------------------\n  // reusable functions\n  const updateEntryStatus = (entries?) => {\n    const filteredEntries = (entries || [])\n      // filter out entries by stage (if specified)\n      .filter((entry: Entry) => {\n        return !stage || !entry.entryStage || stage === entry.entryStage;\n      })\n      // filter by specified participantIds\n      .filter(({ participantId }) => participantIds.includes(participantId));\n\n    const isAssigned = (entry) =>\n      entryStatus &&\n      assignedParticipantIds.includes(entry.participantId) &&\n      !(\n        EQUIVALENT_ACCEPTANCE_STATUSES.includes(entry.entryStatus) &&\n        EQUIVALENT_ACCEPTANCE_STATUSES.includes(entryStatus)\n      );\n\n    const success = filteredEntries.every((entry: Entry) => {\n      if (isAssigned(entry) && !ignoreAssignment) return false;\n      if (entryStatus) {\n        entry.entryStatus = entryStatus;\n        // since entryStatus has changed remove current entryPosition\n        delete entry.entryPosition;\n      }\n      if (entryStage) {\n        entry.entryStage = entryStage;\n        // since entryStage has changed remove current entryPosition\n        delete entry.entryPosition;\n      }\n      if (extension) {\n        if (extension.value) {\n          addExtension({ element: entry, extension });\n        } else {\n          removeExtension({ element: entry, name: extension.name });\n        }\n      }\n      return true;\n    });\n\n    return success\n      ? { ...SUCCESS }\n      : { error: EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT };\n  };\n\n  const autoPosition = ({ flight, drawDefinition }) => {\n    if (event) {\n      event.entries = refreshEntryPositions({\n        entries: event.entries ?? [],\n      });\n    }\n    if (flight) {\n      flight.drawEntries = refreshEntryPositions({\n        entries: flight.drawEntries,\n      });\n    }\n    if (drawDefinition) {\n      drawDefinition.entries = refreshEntryPositions({\n        entries: drawDefinition.entries,\n      });\n    }\n  };\n  const updateDrawEntries = (params) => {\n    const { flight, drawDefinition } = params;\n    const stack = 'updateDrawEntries';\n    if (flight) {\n      const result = updateEntryStatus(flight.drawEntries);\n      if (result.error) return decorateResult({ result, stack });\n    }\n    if (drawDefinition) {\n      const result = updateEntryStatus(drawDefinition.entries);\n      if (result.error) return decorateResult({ result, stack });\n\n      if (!modifiedDrawIds.includes(drawDefinition.drawId))\n        modifiedDrawIds.push(drawDefinition.drawId);\n    }\n    return { ...SUCCESS };\n  };\n\n  // ------------------------------------------------------------------------\n  // before modifying, if autoEntryPositions: true, pre-assign entryPositions\n  const entryPositionsExist =\n    event?.entries?.find(({ entryPosition }) => entryPosition) ??\n    (flight?.drawEntries?.find(({ entryPosition }) => entryPosition) ||\n      drawDefinition?.entries?.find(({ entryPosition }) => entryPosition));\n\n  if (autoEntryPositions && !entryPositionsExist)\n    autoPosition({ flight, drawDefinition });\n\n  // ------------------------------------------------------------------------\n  // if flight or drawDefinition scope modifications\n  if (flight || drawDefinition) {\n    const result = updateDrawEntries({ flight, drawDefinition });\n    if (result.error) return decorateResult({ result, stack });\n  }\n\n  // ------------------------------------------------------------------------\n  // update any flights which have no draw generated to keep entries in sync\n  const generatedDrawIds =\n    event?.drawDefinitions?.map(({ drawId }) => drawId) ?? [];\n  const flightsNoDraw =\n    flightProfile?.flights?.filter(\n      (flight) => !generatedDrawIds.includes(flight.drawId)\n    ) || [];\n\n  for (const flight of flightsNoDraw) {\n    const result = flight && updateDrawEntries({ flight });\n    if (result?.error) return decorateResult({ result, stack });\n  }\n\n  // ------------------------------------------------------------------------\n  const singleDraw =\n    flightProfile?.flights?.length === 1 &&\n    (event?.drawDefinitions?.length ?? 0) <= flightProfile?.flights?.length;\n\n  if (\n    !flight &&\n    !drawDefinition &&\n    entryStatus &&\n    DRAW_SPECIFIC_STATUSES.includes(entryStatus)\n  ) {\n    return { error: ENTRY_STATUS_NOT_ALLOWED_FOR_EVENT };\n  }\n\n  if (\n    (!flight && !drawDefinition) ||\n    entryStatus === WITHDRAWN ||\n    (eventSync && singleDraw) // if there is only one draw keep event entries in sync\n  ) {\n    // if entryStatus is WITHDRAWN then participantIds appearing in ANY flight or drawDefinition must be removed\n\n    const result = updateEntryStatus(event?.entries);\n    if (result?.error) return decorateResult({ result, stack });\n\n    let error;\n    if (entryStatus === WITHDRAWN) {\n      flightProfile?.flights?.every((flight) => {\n        const result = updateEntryStatus(flight.drawEntries);\n        if (result.error) {\n          error = result.error;\n          return false;\n        }\n        flight.drawEntries = flight.drawEntries.filter(\n          ({ participantId }) => !participantIds.includes(participantId)\n        );\n        return true;\n      });\n\n      event?.drawDefinitions?.every((drawDefinition) => {\n        const result = updateEntryStatus(drawDefinition.entries);\n        if (result.error) {\n          error = result.error;\n          return false;\n        }\n        drawDefinition.entries = drawDefinition.entries?.filter(\n          ({ participantId }) => !participantIds.includes(participantId)\n        );\n        return true;\n      });\n    }\n    if (error) return decorateResult({ result: { error }, stack });\n  }\n\n  if (autoEntryPositions) autoPosition({ flight, drawDefinition });\n\n  for (const drawDefinition of event?.drawDefinitions ?? []) {\n    if (\n      modifiedDrawIds.length &&\n      !modifiedDrawIds.includes(drawDefinition.drawId)\n    )\n      continue;\n\n    modifyDrawNotice({\n      tournamentId: tournamentRecord.tournamentId,\n      eventId: event?.eventId,\n      drawDefinition,\n    });\n  }\n\n  return { ...SUCCESS };\n}\n","import { checkScoreHasValue } from '../../query/matchUp/checkScoreHasValue';\nimport { extractDate, extractTime } from '../../utilities/dateTime';\n\nimport { BYE } from '../../constants/matchUpStatusConstants';\n\nexport function addScheduleItem(params) {\n  const {\n    participantMap,\n    participantId,\n    matchUpStatus,\n    roundPosition,\n    structureId,\n    matchUpType,\n    roundNumber,\n    matchUpId,\n    potential,\n    schedule,\n    drawId,\n    score,\n  } = params;\n  if (!schedule || !Object.keys(schedule).length) return;\n\n  const ignoreMatchUp = matchUpStatus === BYE;\n  if (!ignoreMatchUp) {\n    participantMap[participantId].scheduleItems.push({\n      ...schedule,\n      scheduledDate: extractDate(schedule?.scheduledDate),\n      scheduledTime: extractTime(schedule?.scheduledTime),\n      checkScoreHasValue: checkScoreHasValue({ score }),\n      matchUpStatus,\n      roundPosition,\n      structureId,\n      matchUpType,\n      roundNumber,\n      matchUpId,\n      potential,\n      drawId,\n    });\n  }\n}\n","import { getAccessorValue } from '../../utilities/getAccessorValue';\n\nimport type { Participant, EventTypeUnion } from '../../types/tournamentTypes';\nimport { ScaleAttributes, ScaleItem } from '../../types/factoryTypes';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { SCALE } from '../../constants/scaleConstants';\nimport { isObject } from '../../utilities/objects';\nimport {\n  INVALID_SCALE_ITEM,\n  INVALID_VALUES,\n  MISSING_PARTICIPANT,\n} from '../../constants/errorConditionConstants';\n\nexport interface ParticipantScaleItemArgs {\n  scaleAttributes: ScaleAttributes;\n  requireTimeStamp?: boolean;\n  participant: Participant;\n}\n\nexport function participantScaleItem({\n  requireTimeStamp,\n  scaleAttributes,\n  participant,\n}: ParticipantScaleItemArgs): ResultType & { scaleItem?: ScaleItem } {\n  if (!participant) return { error: MISSING_PARTICIPANT };\n  if (!isObject(scaleAttributes)) return { error: INVALID_VALUES };\n\n  if (!participant.timeItems) participant.timeItems = [];\n  if (Array.isArray(participant.timeItems)) {\n    const { accessor, scaleType, eventType, scaleName } = scaleAttributes;\n    const filterType = [SCALE, scaleType, eventType, scaleName].join('.');\n    const filteredTimeItems = participant.timeItems\n      .filter((timeItem) => timeItem?.itemType === filterType)\n      .filter((timeItem) => !requireTimeStamp || timeItem?.itemDate)\n      .sort(\n        (a, b) =>\n          (a.createdAt ? new Date(a.createdAt).getTime() : 0) -\n          (b.createdAt ? new Date(b.createdAt).getTime() : 0)\n      );\n\n    const timeItem = filteredTimeItems.pop();\n\n    if (timeItem) {\n      const [itemSubject, scaleType, eventType, scaleName] =\n        timeItem.itemType?.split('.') ?? [];\n\n      if (itemSubject !== SCALE) return { error: INVALID_SCALE_ITEM };\n\n      const accessorValue: any =\n        accessor && getAccessorValue({ element: timeItem.itemValue, accessor });\n      const scaleValue = accessorValue?.value || timeItem.itemValue;\n\n      const scaleItem = {\n        eventType: eventType as EventTypeUnion,\n        scaleDate: timeItem.itemDate,\n        scaleValue,\n        scaleName,\n        scaleType,\n      };\n      return { ...SUCCESS, scaleItem };\n    }\n  }\n\n  return { ...SUCCESS, scaleItem: undefined };\n}\n","import { participantScaleItem } from '../participant/participantScaleItem';\nimport { intersection } from '../../utilities/arrays';\n\nimport { SCALE, SEEDING } from '../../constants/scaleConstants';\n\nexport function getEventSeedAssignments({\n  publishedSeeding,\n  usePublishState,\n  withSeeding,\n  participant,\n  event,\n}) {\n  const eventSeedAssignments: any = {};\n\n  const getScaleAccessor = (scaleName) =>\n    [SCALE, SEEDING, event.eventType, scaleName].join('.');\n\n  const seedingScales = Object.assign(\n    {},\n    ...(participant.timeItems || [])\n      .filter(({ itemType }) => itemType.split('.')[1] === SEEDING)\n      .map(({ itemType: seedingScaleName, itemValue: seedValue }) => ({\n        [seedingScaleName]: seedValue,\n      }))\n  );\n\n  const eventSeedingScaleNames = (\n    (publishedSeeding?.stageSeedingScaleNames &&\n      Object.values(publishedSeeding?.stageSeedingScaleNames)) ||\n    (Array.isArray(publishedSeeding?.seedingScaleNames) &&\n      publishedSeeding.seedingScaleNames) ||\n    []\n  ).map(getScaleAccessor);\n\n  const publishedEventSeedingScaleNames = intersection(\n    Object.keys(seedingScales),\n    eventSeedingScaleNames\n  );\n\n  const eventSeedingPublished = !!(\n    !usePublishState ||\n    (!Object.keys(seedingScales).length &&\n      !publishedSeeding?.drawIds?.length) ||\n    publishedEventSeedingScaleNames.length\n  );\n\n  if (eventSeedingPublished && publishedEventSeedingScaleNames.length) {\n    if (publishedSeeding?.stageSeedingScaleNames) {\n      const scaleValues = Object.keys(publishedSeeding.stageSeedingScaleNames)\n        .map((key) => {\n          const accessor = getScaleAccessor(\n            publishedSeeding.stageSeedingScaleNames[key]\n          );\n          const scaleValue = seedingScales[accessor];\n          return [key, scaleValue];\n        })\n        .filter((pair) => pair[1])\n        .map((pair) => ({ [pair[0]]: { seedValue: pair[1] } }));\n      const seedAssignments = Object.assign({}, ...scaleValues);\n\n      eventSeedAssignments.seedAssignments = seedAssignments;\n    } else if (publishedEventSeedingScaleNames) {\n      const seedValues = publishedEventSeedingScaleNames.map(\n        (scaleName) => seedingScales[scaleName]\n      );\n      eventSeedAssignments.seedValue = seedValues.pop();\n    }\n  } else if (!usePublishState && typeof withSeeding === 'object') {\n    const scaleValues = Object.keys(withSeeding)\n      .map((key) => {\n        const accessor = getScaleAccessor(withSeeding[key]);\n        const scaleValue = seedingScales[accessor];\n        return [key, scaleValue];\n      })\n      .filter((pair) => pair[1])\n      .map((pair) => ({ [pair[0]]: { seedValue: pair[1] } }));\n    const seedAssignments = Object.assign({}, ...scaleValues);\n\n    eventSeedAssignments.seedAssignments = seedAssignments;\n  } else {\n    const { categoryName, ageCategoryCode } = event.category || {};\n\n    const scaleNames = [ageCategoryCode, event.eventId, categoryName].filter(\n      Boolean\n    );\n\n    let scaleItem;\n    for (const scaleName of scaleNames) {\n      const scaleAttributes = {\n        eventType: event.eventType,\n        scaleType: SEEDING,\n        scaleName,\n      };\n      const result = participantScaleItem({\n        scaleAttributes,\n        participant,\n      });\n\n      if (result.scaleItem) {\n        scaleItem = result.scaleItem;\n        break;\n      }\n    }\n\n    if (scaleItem) {\n      const seedingPublished =\n        !usePublishState ||\n        (publishedSeeding?.published &&\n          // if drawIds have been specified then don't attach event seeding here\n          // defer to seedValue that is in seedAssignments for draw in which participant appears\n          !publishedSeeding?.published?.drawIds?.length);\n\n      if (seedingPublished) {\n        const seedValue = scaleItem.scaleValue;\n        eventSeedAssignments.seedValue = seedValue;\n      }\n    }\n  }\n\n  return eventSeedAssignments;\n}\n","import { getEventTimeItem } from '../base/timeItems';\n\nimport { PUBLIC, PUBLISH, STATUS } from '../../constants/timeItemConstants';\n\nexport function getEventPublishStatus({ event, status = PUBLIC }) {\n  const itemType = `${PUBLISH}.${STATUS}`;\n  return getEventTimeItem({\n    itemType,\n    event,\n  })?.timeItem?.itemValue?.[status];\n}\n","export function getDrawPublishStatus({ drawDetails, drawId }) {\n  // TODO: check details.embargo\n  const details = drawDetails?.[drawId]?.publishingDetail;\n  return details?.published;\n}\n","import { getEventPublishStatus } from '../event/getEventPublishStatus';\nimport { getDrawPublishStatus } from '../event/getDrawPublishStatus';\n\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { Event, Tournament } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { isString } from '../../utilities/objects';\nimport { findEvent } from '../../acquire/findEvent';\nimport { EVENT_NOT_FOUND, INVALID_VALUES } from '../../constants/errorConditionConstants';\n\ntype GetPublishStateArgs = {\n  tournamentRecord?: Tournament;\n  eventIds?: string[];\n  drawIds?: string[];\n  drawId?: string;\n  event: Event;\n};\n\nexport function getPublishState({\n  tournamentRecord,\n  eventIds,\n  drawIds,\n  drawId,\n  event,\n}: GetPublishStateArgs): ResultType & {\n  publishState?: any;\n} {\n  if (Array.isArray(eventIds) && eventIds?.length) {\n    const publishState: any = {};\n    for (const eventId of eventIds) {\n      if (!isString(eventId)) return { error: INVALID_VALUES };\n      const event = findEvent({ tournamentRecord, eventId });\n      if (!event) return { error: EVENT_NOT_FOUND };\n      const pubStatus: any = getPubStatus({ event });\n      if (pubStatus.error) return pubStatus;\n      publishState[eventId] = pubStatus;\n    }\n    return { ...SUCCESS, publishState };\n  } else if (!event && tournamentRecord?.events && Array.isArray(drawIds) && drawIds.length) {\n    const publishState: any = {};\n    for (const event of tournamentRecord.events) {\n      const pubStatus: any = getPubStatus({ event });\n      if (pubStatus.error) return pubStatus;\n      for (const drawId of drawIds) {\n        if (!isString(drawId)) return { error: INVALID_VALUES };\n        const published = pubStatus.publishState.publishedDrawIds.includes(drawId);\n        if (published) publishState[drawId] = { published };\n      }\n    }\n    return { ...SUCCESS, publishState };\n  } else if (event) {\n    const pubStatus: any = getPubStatus({ event });\n    if (pubStatus.error) return pubStatus;\n    if (drawId) {\n      return {\n        publishState: {\n          published: pubStatus.publishState.publishedDrawIds.includes(drawId),\n          ...SUCCESS,\n        },\n      };\n    } else if (Array.isArray(drawIds) && drawIds?.length) {\n      const publishState: any = {};\n      for (const drawId of drawIds) {\n        if (!isString(drawId)) return { error: INVALID_VALUES };\n        publishState[drawId] = {\n          published: pubStatus.publishState.publishedDrawIds.includes(drawId),\n        };\n        return { ...SUCCESS, publishState };\n      }\n    } else {\n      return pubStatus;\n    }\n  }\n\n  return { error: INVALID_VALUES };\n}\n\nfunction getPubStatus({ event }): any {\n  const eventPubStatus = getEventPublishStatus({ event });\n  if (!eventPubStatus) return { error: EVENT_NOT_FOUND };\n\n  const publishedSeeding = {\n    published: undefined, // seeding can be present for all entries in an event when no flights have been defined\n    seedingScaleNames: [],\n    drawIds: [], // seeding can be specific to drawIds\n  };\n\n  if (eventPubStatus.seeding) {\n    Object.assign(publishedSeeding, eventPubStatus.seeding);\n  }\n\n  const { drawDetails } = eventPubStatus;\n\n  const publishedDrawIds =\n    (drawDetails && Object.keys(drawDetails).filter((drawId) => getDrawPublishStatus({ drawDetails, drawId }))) ||\n    eventPubStatus.drawIds ||\n    [];\n\n  return {\n    publishState: {\n      published: publishedDrawIds.length > 0,\n      publishedDrawIds,\n      publishedSeeding,\n      drawDetails,\n    },\n    ...SUCCESS,\n  };\n}\n","import { extensionsToAttributes } from '../../utilities/makeDeepCopy';\nimport { definedAttributes } from '../../utilities/definedAttributes';\n\nexport function processEventEntry({\n  convertExtensions,\n  seedAssignments,\n  participant,\n  withSeeding,\n  seedValue,\n  eventId,\n  ranking,\n  entry,\n}) {\n  const { entryStatus, entryStage, entryPosition, extensions } = entry;\n\n  const entryExtensions =\n    extensions?.length && convertExtensions\n      ? Object.assign({}, ...extensionsToAttributes(extensions))\n      : {};\n\n  const attributes = Object.assign(entryExtensions, {\n    entryPosition,\n    entryStatus,\n    entryStage,\n    ranking,\n    eventId,\n  });\n  participant.events[eventId] = definedAttributes(\n    attributes,\n    false,\n    false,\n    true\n  );\n\n  if (withSeeding) {\n    if (seedAssignments)\n      participant.events[eventId].seedAssignments = seedAssignments;\n    if (seedValue) participant.events[eventId].seedValue = seedValue;\n  }\n}\n","export function stringSort(a, b) {\n  return (a || '').localeCompare(b || '');\n}\n","import { DEFAULTED, WALKOVER } from '../../constants/matchUpStatusConstants';\n\nexport function addStructureParticipation({\n  finishingPositionRange: matchUpFinishingPositionRanges = {},\n  participantMap,\n  finishingRound,\n  participantWon,\n  matchUpStatus,\n  participantId,\n  stageSequence,\n  roundNumber,\n  structureId,\n  matchUpId,\n  drawId,\n  stage,\n}) {\n  const participantAggregator = participantMap[participantId];\n  const diff = (range) => Math.abs(range[0] - range[1]);\n\n  if (!participantAggregator.structureParticipation[structureId]) {\n    participantAggregator.structureParticipation[structureId] = {\n      rankingStage: stage,\n      walkoverWinCount: 0,\n      defaultWinCount: 0,\n      stageSequence,\n      winCount: 0,\n      structureId,\n      drawId,\n    };\n  }\n\n  const structureParticipation =\n    participantAggregator.structureParticipation[structureId];\n\n  const { winner, loser } = matchUpFinishingPositionRanges as any;\n  const finishingPositionRange = participantWon ? winner : loser;\n  if (participantWon) {\n    structureParticipation.winCount += 1;\n    if (matchUpStatus === WALKOVER) {\n      structureParticipation.walkoverWinCount += 1;\n    }\n    if (matchUpStatus === DEFAULTED) {\n      structureParticipation.defaultWinCount += 1;\n    }\n  }\n\n  if (\n    finishingPositionRange &&\n    (!structureParticipation.finishingPositionRange ||\n      diff(finishingPositionRange) <\n        diff(structureParticipation.finishingPositionRange))\n  ) {\n    structureParticipation.finishingPositionRange = finishingPositionRange;\n  }\n\n  if (finishingRound) {\n    if (\n      !structureParticipation.finishingRound ||\n      finishingRound < structureParticipation.finishingRound\n    ) {\n      structureParticipation.finishingMatchUpId = matchUpId;\n      structureParticipation.finishingRound = finishingRound;\n      structureParticipation.roundNumber = roundNumber;\n    }\n    if (finishingRound === 1) {\n      // participant won the structure\n      structureParticipation.participantWon = participantWon;\n    }\n  }\n}\n","import { addStructureParticipation } from '../../mutate/participants/addStructureParticipation';\nimport { addScheduleItem } from '../../mutate/participants/addScheduleItem';\n\nimport { DEFAULTED, WALKOVER } from '../../constants/matchUpStatusConstants';\nimport { TEAM } from '../../constants/matchUpTypes';\nimport { PAIR, TEAM_PARTICIPANT } from '../../constants/participantConstants';\n\nexport function processSides(params) {\n  const {\n    withScheduleItems,\n    scheduleAnalysis,\n    withTeamMatchUps,\n    participantMap,\n    withOpponents,\n    withMatchUps,\n    withEvents,\n    withDraws,\n\n    finishingPositionRange,\n    finishingRound,\n    matchUpStatus,\n    stageSequence,\n    roundNumber,\n    structureId,\n    score,\n    stage,\n\n    withRankingProfile,\n    tieWinningSide,\n    roundPosition,\n    matchUpTieId,\n    matchUpSides,\n    collectionId,\n    matchUpType,\n    winningSide,\n    matchUpId,\n    schedule,\n    eventId,\n    drawId,\n    sides,\n  } = params;\n  const opponents =\n    withOpponents &&\n    sides?.length === 2 &&\n    Object.assign(\n      {},\n      ...sides\n        .map(({ sideNumber }, i) => {\n          const opponentParticipantId = sides[1 - i].participantId;\n          return (\n            sideNumber && {\n              [sideNumber]: opponentParticipantId,\n            }\n          );\n        })\n        .filter(Boolean)\n    );\n\n  for (const side of sides) {\n    const { participantId, sideNumber, bye } = side;\n    if (bye) continue;\n\n    const participantWon = winningSide === sideNumber;\n\n    const getOpponentInfo = (opponentParticipantId) => {\n      const opponent = participantMap[opponentParticipantId]?.participant;\n      const participantType = opponent?.participantType;\n      const info = [\n        {\n          participantId: opponentParticipantId,\n          participantType,\n        },\n      ];\n\n      if (participantType !== TEAM_PARTICIPANT) {\n        for (const participantId of opponent?.individualParticipantIds || []) {\n          const participant = participantMap[participantId]?.participant;\n          info.push({\n            participantType: participant?.participantType,\n            participantId,\n          });\n        }\n      }\n\n      return info;\n    };\n\n    const addMatchUp = (participantId, opponentParticipantId) => {\n      if (withMatchUps) {\n        participantMap[participantId].matchUps[matchUpId] = {\n          participantWon,\n          matchUpType,\n          structureId,\n          sideNumber,\n          matchUpId,\n          eventId,\n          drawId,\n          stage,\n        };\n        if (withOpponents) {\n          const opponentParticipantInfo = getOpponentInfo(\n            opponentParticipantId\n          );\n          participantMap[participantId].matchUps[\n            matchUpId\n          ].opponentParticipantInfo = opponentParticipantInfo;\n        }\n        if (collectionId) {\n          participantMap[participantId].matchUps[matchUpId].collectionId =\n            collectionId;\n        }\n      }\n\n      if (withOpponents && opponentParticipantId) {\n        participantMap[participantId].opponents[opponentParticipantId] = {\n          participantId: opponentParticipantId,\n          matchUpId,\n          eventId,\n          drawId,\n        };\n      }\n\n      if (withRankingProfile) {\n        addStructureParticipation({\n          finishingPositionRange,\n          participantMap,\n          participantWon,\n          finishingRound,\n          matchUpStatus,\n          participantId,\n          stageSequence,\n          roundNumber,\n          structureId,\n          matchUpId,\n          drawId,\n          stage,\n        });\n      }\n\n      if (scheduleAnalysis || withScheduleItems) {\n        addScheduleItem({\n          participantMap,\n          participantId,\n          matchUpStatus,\n          roundPosition,\n          matchUpType,\n          roundNumber,\n          structureId,\n          matchUpId,\n          schedule,\n          drawId,\n          score,\n        });\n      }\n    };\n\n    const addPartner = ({ participant, partnerParticipantId }) => {\n      const addPartnerParticiapntId = (element, partnerParticipantId) => {\n        if (element) {\n          if (!element.partnerParticipantIds)\n            element.partnerParticipantIds = [];\n          if (!element.partnerParticipantIds.includes(partnerParticipantId))\n            element.partnerParticipantIds.push(partnerParticipantId);\n        }\n      };\n\n      if (withDraws)\n        addPartnerParticiapntId(\n          participant?.draws?.[drawId],\n          partnerParticipantId\n        );\n      if (withEvents) {\n        addPartnerParticiapntId(\n          participant?.events?.[eventId],\n          partnerParticipantId\n        );\n      }\n      if (withMatchUps) {\n        addPartnerParticiapntId(\n          participant?.matchUps?.[matchUpId],\n          partnerParticipantId\n        );\n      }\n    };\n\n    if (participantId && participantMap[participantId]) {\n      const opponentParticipantId = opponents?.[sideNumber];\n\n      addMatchUp(participantId, opponentParticipantId);\n\n      const isPair =\n        participantMap[participantId]?.participant.participantType === PAIR;\n      const individualParticipantIds =\n        participantMap[participantId]?.participant.individualParticipantIds ||\n        [];\n\n      if (matchUpTieId) {\n        if (withTeamMatchUps) {\n          const addTeamMatchUp = (participantId) =>\n            (participantMap[participantId].matchUps[matchUpTieId] = {\n              participantWon: tieWinningSide === sideNumber,\n              matchUpId: matchUpTieId,\n              matchUpType: TEAM,\n              sideNumber,\n            });\n          addTeamMatchUp(participantId);\n          individualParticipantIds.forEach(addTeamMatchUp);\n        }\n\n        if (withDraws && !participantMap[participantId].draws[drawId]) {\n          const teamParticipantId = matchUpSides.find(\n            (s) => s.sideNumber === sideNumber\n          )?.participant?.participantId;\n          const teamEntryStatus =\n            participantMap[teamParticipantId]?.draws?.[drawId]?.entryStatus;\n\n          const addDrawData = (participantId) =>\n            (participantMap[participantId].draws[drawId] = {\n              entryStatus: teamEntryStatus,\n              // add positions played in lineUp collections\n              eventId,\n              drawId,\n            });\n          addDrawData(participantId);\n          individualParticipantIds.forEach(addDrawData);\n        }\n      }\n\n      if (isPair) {\n        individualParticipantIds.forEach(\n          (participantId) =>\n            participantMap[participantId] &&\n            addMatchUp(participantId, opponentParticipantId)\n        );\n        individualParticipantIds.forEach((participantId, i) => {\n          const partnerParticipantId = individualParticipantIds[1 - i];\n          const participant = participantMap[participantId];\n          participant && addPartner({ participant, partnerParticipantId });\n        });\n\n        // in TEAM events PAIR participants do not appear in entries\n        if (withEvents && matchUpSides) {\n          const teamParticipantId = matchUpSides.find(\n            (s) => s.sideNumber === sideNumber\n          )?.participant?.participantId;\n          if (teamParticipantId) {\n            const teamEntry =\n              participantMap[teamParticipantId]?.events[eventId];\n\n            if (teamEntry) {\n              participantMap[participantId].events[eventId] = { ...teamEntry };\n              individualParticipantIds.forEach(\n                (individualParticiapntId) =>\n                  (participantMap[individualParticiapntId].events[eventId] = {\n                    ...teamEntry,\n                  })\n              );\n            } else {\n              console.log('Missing teamEntry', { eventId, teamParticipantId });\n            }\n          }\n        }\n      }\n\n      if (winningSide) {\n        const processParticipantId = (id) => {\n          if (participantWon) {\n            participantMap[id].counters[matchUpType].wins += 1;\n            participantMap[id].counters.wins += 1;\n            if (matchUpStatus === WALKOVER) {\n              participantMap[id].counters[matchUpType].walkoverWins += 1;\n              participantMap[id].counters.walkoverWins += 1;\n            }\n            if (matchUpStatus === DEFAULTED) {\n              participantMap[id].counters[matchUpType].defaultWins += 1;\n              participantMap[id].counters.defaultWins += 1;\n            }\n          } else {\n            participantMap[id].counters[matchUpType].losses += 1;\n            participantMap[id].counters.losses += 1;\n            if (matchUpStatus === WALKOVER) {\n              participantMap[id].counters[matchUpType].walkovers += 1;\n              participantMap[id].counters.walkovers += 1;\n            }\n            if (matchUpStatus === DEFAULTED) {\n              participantMap[id].counters[matchUpType].defaults += 1;\n              participantMap[id].counters.defaults += 1;\n            }\n          }\n        };\n        processParticipantId(participantId);\n        individualParticipantIds.forEach(processParticipantId);\n      }\n    }\n  }\n}\n","import { getAllPositionedParticipantIds } from '../drawDefinition/positionsGetter';\nimport { getParticipantId } from '../../global/functions/extractors';\nimport { getAccessorValue } from '../../utilities/getAccessorValue';\nimport { getFlightProfile } from '../event/getFlightProfile';\nimport { getTimeItem } from '../base/timeItems';\nimport { unique } from '../../utilities/arrays';\n\nimport { SIGN_IN_STATUS } from '../../constants/participantConstants';\nimport { SINGLES } from '../../constants/eventConstants';\n\nimport type { Tournament } from '../../types/tournamentTypes';\nimport { ParticipantFilters } from '../../types/factoryTypes';\nimport { HydratedParticipant } from '../../types/hydrated';\n\ntype FilterParticipantsArgs = {\n  participantFilters: ParticipantFilters;\n  participants: HydratedParticipant[];\n  tournamentRecord: Tournament;\n};\n\nexport function filterParticipants({\n  participantFilters = {},\n  tournamentRecord,\n  participants = [],\n}: FilterParticipantsArgs): HydratedParticipant[] {\n  if (!Object.keys(participantFilters).length) {\n    return participants;\n  }\n\n  const {\n    accessorValues,\n    drawEntryStatuses, // {string[]} participantIds that are in draw.entries or flightProfile.flights[].drawEnteredParticipantIds with entryStatuses\n    positionedParticipants, // boolean - participantIds that are included in any structure.positionAssignments\n    eventEntryStatuses, // {string[]} participantIds that are in entry.entries with entryStatuses\n    participantRoles,\n    participantRoleResponsibilities,\n    participantTypes,\n    participantIds,\n    signInStatus,\n    enableOrFiltering,\n    eventIds,\n    genders,\n  } = participantFilters;\n\n  const tournamentEvents =\n    (isValidFilterArray(eventIds) &&\n      tournamentRecord?.events?.filter(\n        (event) => eventIds?.includes(event.eventId)\n      )) ||\n    tournamentRecord?.events ||\n    [];\n\n  const drawEnteredParticipantIds =\n    drawEntryStatuses &&\n    getDrawEntries({ drawEntryStatuses, tournamentEvents });\n\n  const eventEnteredParticipantIds =\n    eventEntryStatuses &&\n    getEventEntries({ eventEntryStatuses, tournamentEvents });\n\n  const positionedParticipantIds =\n    positionedParticipants !== undefined &&\n    [true, false].includes(positionedParticipants) &&\n    tournamentEvents.reduce((participantIds, event) => {\n      return participantIds.concat(\n        ...(event.drawDefinitions || [])\n          .map(\n            (drawDefinition) =>\n              getAllPositionedParticipantIds({ drawDefinition })\n                .allPositionedParticipantIds\n          )\n          .filter(Boolean)\n      );\n    }, []);\n\n  const participantHasAccessorValues = (participant) => {\n    return accessorValues?.reduce((hasValues, keyValue) => {\n      const { accessor, value } = keyValue;\n      const { values } = getAccessorValue({\n        element: participant,\n        accessor,\n      });\n      return hasValues && values?.includes(value);\n    }, true);\n  };\n\n  participants = participants?.filter((participant) => {\n    const participantSignInStatus = getTimeItem({\n      element: participant,\n      itemType: SIGN_IN_STATUS,\n    } as any)?.timeItem?.itemValue;\n    const {\n      participantRoleResponsibilities: responsibilities,\n      participantType,\n      participantRole,\n      participantId,\n      person,\n    } = participant;\n\n    const hasGender =\n      Array.isArray(genders) &&\n      genders?.length &&\n      person?.sex &&\n      genders.includes(person.sex);\n\n    if (enableOrFiltering) {\n      return (\n        (genders && hasGender) ||\n        (positionedParticipants &&\n          positionedParticipantIds.includes(participantId)) ||\n        (positionedParticipants === false &&\n          !positionedParticipantIds.includes(participantId)) ||\n        drawEnteredParticipantIds?.includes(participantId) ||\n        eventEnteredParticipantIds?.includes(participantId) ||\n        participantIds?.includes(participantId) ||\n        (signInStatus && participantSignInStatus === signInStatus) ||\n        (participantTypes &&\n          participantType &&\n          isValidFilterArray(participantTypes) &&\n          participantTypes.includes(participantType)) ||\n        (participantRoles &&\n          participantRole &&\n          isValidFilterArray(participantRoles) &&\n          participantRoles.includes(participantRole)) ||\n        (participantRoleResponsibilities &&\n          isValidFilterArray(responsibilities) &&\n          isValidFilterArray(participantRoleResponsibilities) &&\n          participantRoleResponsibilities.find(\n            (roleResponsbility) => responsibilities?.includes(roleResponsbility)\n          )) ||\n        (accessorValues?.length &&\n          isValidFilterArray(accessorValues) &&\n          participantHasAccessorValues(participant))\n      );\n    } else {\n      return (\n        (!genders || hasGender) &&\n        (positionedParticipants === undefined ||\n          (positionedParticipants &&\n            positionedParticipantIds.includes(participantId)) ||\n          (positionedParticipants === false &&\n            !positionedParticipantIds.includes(participantId))) &&\n        (!drawEnteredParticipantIds ||\n          drawEnteredParticipantIds.includes(participantId)) &&\n        (!eventEnteredParticipantIds ||\n          eventEnteredParticipantIds.includes(participantId)) &&\n        (!participantIds || participantIds.includes(participantId)) &&\n        (!signInStatus || participantSignInStatus === signInStatus) &&\n        (!participantTypes ||\n          (participantType &&\n            isValidFilterArray(participantTypes) &&\n            participantTypes.includes(participantType))) &&\n        (!participantRoles ||\n          (participantRole &&\n            isValidFilterArray(participantRoles) &&\n            participantRoles.includes(participantRole))) &&\n        (!participantRoleResponsibilities ||\n          (isValidFilterArray(responsibilities) &&\n            isValidFilterArray(participantRoleResponsibilities) &&\n            participantRoleResponsibilities.find(\n              (roleResponsbility) =>\n                responsibilities?.includes(roleResponsbility)\n            ))) &&\n        (!accessorValues?.length ||\n          (isValidFilterArray(accessorValues) &&\n            participantHasAccessorValues(participant)))\n      );\n    }\n  });\n\n  if (tournamentEvents.length && eventIds) {\n    const participantIds = tournamentEvents\n      .filter((event) => eventIds.includes(event.eventId))\n      .map((event) => {\n        const enteredParticipantIds = (event.entries || []).map(\n          (entry) => entry.participantId\n        );\n        if (event.eventType === SINGLES) return enteredParticipantIds;\n        const individualParticipantIds = (tournamentRecord?.participants ?? [])\n          .filter((participant) =>\n            enteredParticipantIds.includes(participant.participantId)\n          )\n          .map((participant) => participant.individualParticipantIds)\n          .flat(1);\n        return enteredParticipantIds.concat(...individualParticipantIds);\n      })\n      .flat(1);\n    participants = participants?.filter((participant) =>\n      participantIds.includes(participant.participantId)\n    );\n  }\n\n  return participants;\n}\n\nfunction isValidFilterArray(filter) {\n  return filter && Array.isArray(filter) && filter.length;\n}\n\nfunction getDrawEntries({ drawEntryStatuses, tournamentEvents }) {\n  const statusFilter = ({ entryStatus }) =>\n    !Array.isArray(drawEntryStatuses)\n      ? true\n      : drawEntryStatuses.includes(entryStatus);\n\n  return unique(\n    tournamentEvents.reduce((entries, event) => {\n      const { flightProfile } = getFlightProfile({ event } as any);\n      const flightEntries =\n        flightProfile?.flights\n          ?.map(({ drawEntries }) =>\n            Array.isArray(drawEntries)\n              ? drawEntries.filter(statusFilter).map(getParticipantId)\n              : []\n          )\n          .flat() || [];\n\n      const drawEnteredParticipantIds =\n        event.drawDefinitions?.map(({ entries }) =>\n          entries ? entries.filter(statusFilter).map(getParticipantId) : []\n        ) || [];\n\n      return entries.concat(...flightEntries, ...drawEnteredParticipantIds);\n    }, [])\n  );\n}\n\nfunction getEventEntries({ eventEntryStatuses, tournamentEvents }) {\n  return unique(\n    tournamentEvents.reduce((entries, event) => {\n      const eventEntries = (event.entries || [])\n        .filter(({ entryStatus }) =>\n          !Array.isArray(eventEntryStatuses)\n            ? true\n            : eventEntryStatuses.includes(entryStatus)\n        )\n        .map(getParticipantId);\n\n      return entries.concat(...eventEntries);\n    }, [])\n  );\n}\n","import { getMatchUpDependencies } from '../matchUps/getMatchUpDependencies';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { attributeFilter } from '../../utilities/attributeFilter';\nimport { getParticipantEntries } from './getParticipantEntries';\nimport { filterParticipants } from './filterParticipants';\nimport { getParticipantMap } from './getParticipantMap';\nimport { isObject } from '../../utilities/objects';\n\nimport { POLICY_TYPE_PARTICIPANT } from '../../constants/policyConstants';\nimport { MatchUp, Tournament } from '../../types/tournamentTypes';\nimport { HydratedParticipant } from '../../types/hydrated';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ContextProfile,\n  ParticipantFilters,\n  PolicyDefinitions,\n  ScheduleAnalysis,\n  ParticipantMap,\n} from '../../types/factoryTypes';\nimport {\n  MISSING_TOURNAMENT_RECORD,\n  ErrorType,\n} from '../../constants/errorConditionConstants';\n\ntype GetParticipantsArgs = {\n  withIndividualParticipants?: boolean | { [key: string]: any };\n  participantFilters?: ParticipantFilters;\n  scheduleAnalysis?: ScheduleAnalysis;\n  policyDefinitions?: PolicyDefinitions;\n  withPotentialMatchUps?: boolean;\n  contextProfile?: ContextProfile;\n  tournamentRecord: Tournament;\n  withRankingProfile?: boolean;\n  convertExtensions?: boolean;\n  withScheduleItems?: boolean;\n  withSignInStatus?: boolean;\n  withTeamMatchUps?: boolean;\n  withScaleValues?: boolean;\n  usePublishState?: boolean;\n  withStatistics?: boolean;\n  withOpponents?: boolean;\n  withMatchUps?: boolean;\n  internalUse?: boolean;\n  withSeeding?: boolean;\n  withEvents?: boolean;\n  withDraws?: boolean;\n  withISO2?: boolean;\n  withIOC?: boolean;\n};\nexport function getParticipants(params: GetParticipantsArgs): {\n  eventsPublishStatuses?: { [key: string]: any };\n  participantIdsWithConflicts?: string[];\n  participants?: HydratedParticipant[];\n  participantMap?: ParticipantMap;\n  derivedEventInfo?: any;\n  derivedDrawInfo?: any;\n  matchUps?: MatchUp[];\n  mappedMatchUps?: any;\n  error?: ErrorType;\n  success?: boolean;\n} {\n  const {\n    withIndividualParticipants,\n    participantFilters = {},\n    withPotentialMatchUps,\n    withRankingProfile,\n    convertExtensions,\n    policyDefinitions,\n    withScheduleItems,\n    tournamentRecord,\n    scheduleAnalysis,\n    withSignInStatus,\n    withTeamMatchUps,\n    withScaleValues,\n    usePublishState,\n    contextProfile,\n    withStatistics,\n    withOpponents,\n    withMatchUps,\n    internalUse,\n    withSeeding,\n    withEvents,\n    withDraws,\n    withISO2,\n    withIOC,\n  } = params;\n\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  if (withMatchUps || withRankingProfile) {\n    getMatchUpDependencies({ tournamentRecord }); // ensure goesTos are present\n  }\n\n  let { participantMap } = getParticipantMap({\n    convertExtensions,\n    tournamentRecord,\n    withSignInStatus,\n    withScaleValues,\n    internalUse,\n    withISO2,\n    withIOC,\n  });\n\n  const entriesResult = getParticipantEntries({\n    withMatchUps: withMatchUps ?? withRankingProfile,\n    withEvents: withEvents ?? withRankingProfile,\n    withDraws: withDraws ?? withRankingProfile,\n    withPotentialMatchUps,\n    participantFilters,\n    withRankingProfile,\n    convertExtensions,\n    withScheduleItems,\n    policyDefinitions,\n    tournamentRecord,\n    scheduleAnalysis,\n    withTeamMatchUps,\n    usePublishState,\n    withStatistics,\n    participantMap,\n    withOpponents,\n    contextProfile,\n    withSeeding,\n  });\n\n  const {\n    participantIdsWithConflicts,\n    eventsPublishStatuses,\n    derivedEventInfo,\n    derivedDrawInfo,\n    mappedMatchUps,\n  } = entriesResult;\n\n  const matchUps: any[] = entriesResult.matchUps;\n\n  participantMap = entriesResult.participantMap;\n\n  const nextMatchUps = scheduleAnalysis ?? withPotentialMatchUps;\n\n  const processParticipant = ({\n    potentialMatchUps,\n    scheduleConflicts,\n    scheduleItems,\n    participant,\n    statistics,\n    opponents,\n    matchUps,\n    events,\n    draws,\n  }): HydratedParticipant => {\n    const participantDraws: any[] = Object.values(draws);\n    const participantOpponents = Object.values(opponents);\n    if (withOpponents) {\n      participantDraws?.forEach((draw) => {\n        draw.opponents = participantOpponents.filter(\n          (opponent: any) => opponent.drawId === draw.drawId\n        );\n      });\n    }\n\n    return definedAttributes(\n      {\n        ...participant,\n        scheduleConflicts: scheduleAnalysis\n          ? Object.values(scheduleConflicts)\n          : undefined,\n        draws: withDraws || withRankingProfile ? participantDraws : undefined,\n        events:\n          withEvents || withRankingProfile ? Object.values(events) : undefined,\n        matchUps:\n          withMatchUps || withRankingProfile\n            ? Object.values(matchUps)\n            : undefined,\n        opponents: withOpponents ? participantOpponents : undefined,\n        potentialMatchUps: nextMatchUps\n          ? Object.values(potentialMatchUps)\n          : undefined,\n        statistics: withStatistics ? Object.values(statistics) : undefined,\n        scheduleItems: withScheduleItems ? scheduleItems : undefined,\n      },\n      false,\n      false,\n      true\n    );\n  };\n\n  const ppMap = new Map<string, HydratedParticipant>();\n  for (const participantId of Object.keys(participantMap)) {\n    ppMap.set(participantId, processParticipant(participantMap[participantId]));\n  }\n\n  const processedParticipants: HydratedParticipant[] = [...ppMap.values()];\n\n  const participantAttributes = policyDefinitions?.[POLICY_TYPE_PARTICIPANT];\n  const template = participantAttributes?.participant;\n\n  // filter must be last so attributes can be used for reporting & etc.\n  const filteredParticipants = filterParticipants({\n    participants: processedParticipants,\n    participantFilters,\n    tournamentRecord,\n  });\n\n  if (withIndividualParticipants) {\n    const template = isObject(withIndividualParticipants)\n      ? withIndividualParticipants\n      : undefined;\n    for (const participant of filteredParticipants) {\n      for (const individualParticipantId of participant.individualParticipantIds ??\n        []) {\n        if (!participant.individualParticipants)\n          participant.individualParticipants = [];\n        const source = ppMap.get(individualParticipantId);\n        participant.individualParticipants.push(\n          template ? attributeFilter({ template, source }) : source\n        );\n      }\n    }\n  }\n\n  const participants: HydratedParticipant[] = template\n    ? filteredParticipants.map((source) =>\n        attributeFilter({ source, template })\n      )\n    : filteredParticipants;\n\n  // IDEA: optimizePayload derive array of matchUpIds required for filteredParticipants\n  // filter mappedMatchUps and matchUps to reduce over-the-wire payloads\n\n  return {\n    participantIdsWithConflicts,\n    eventsPublishStatuses,\n    derivedEventInfo,\n    derivedDrawInfo,\n    mappedMatchUps,\n    participantMap,\n    participants,\n    ...SUCCESS,\n    matchUps,\n  };\n}\n","import { xa, isObject } from '../../utilities/objects';\nimport { addScheduleItem } from '../../mutate/participants/addScheduleItem';\nimport { getEventSeedAssignments } from '../event/getEventSeedAssignments';\nimport { getPublishState } from '../events/getPublishState';\nimport { getPositionAssignments } from '../drawDefinition/positionsGetter';\nimport { timeSort, timeStringMinutes } from '../../utilities/dateTime';\nimport { structureSort } from '../../functions/sorters/structureSort';\nimport { extensionsToAttributes } from '../../utilities/makeDeepCopy';\nimport { processEventEntry } from '../participant/processEventEntry';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { allEventMatchUps } from '../matchUps/getAllEventMatchUps';\nimport { stringSort } from '../../functions/sorters/stringSort';\nimport { getFlightProfile } from '../event/getFlightProfile';\nimport { processSides } from '../matchUps/processSides';\n\nimport { DEFAULTED, WALKOVER } from '../../constants/matchUpStatusConstants';\nimport { UNGROUPED, UNPAIRED } from '../../constants/entryStatusConstants';\nimport { MAIN, QUALIFYING } from '../../constants/drawDefinitionConstants';\nimport { DOUBLES, SINGLES } from '../../constants/matchUpTypes';\nimport { WIN_RATIO } from '../../constants/statsConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport { unique } from '../../utilities/arrays';\n\nexport function getParticipantEntries(params) {\n  const {\n    participantFilters,\n    convertExtensions,\n    policyDefinitions,\n    tournamentRecord,\n    usePublishState,\n    contextProfile,\n    participantMap,\n\n    withPotentialMatchUps,\n    withRankingProfile,\n    withScheduleItems,\n    scheduleAnalysis,\n    withTeamMatchUps,\n    withStatistics,\n    withOpponents,\n    withMatchUps,\n    withSeeding,\n    withEvents,\n    withDraws,\n  } = params;\n\n  const targetParticipantIds = participantFilters?.participantIds;\n  const getRelevantParticipantIds = (participantId) => {\n    const relevantParticipantIds = [participantId];\n    participantMap[participantId]?.participant.individualParticipantIds?.forEach((individualParticiapntId) =>\n      relevantParticipantIds.push(individualParticiapntId),\n    );\n\n    return relevantParticipantIds.some((id) => !targetParticipantIds?.length || targetParticipantIds.includes(id))\n      ? relevantParticipantIds\n      : [];\n  };\n\n  const withOpts = {\n    withMatchUps: withMatchUps || withRankingProfile,\n    withEvents: withEvents || withRankingProfile,\n    withDraws: withDraws || withRankingProfile,\n    withPotentialMatchUps,\n    withRankingProfile,\n    withScheduleItems,\n    scheduleAnalysis,\n    withTeamMatchUps,\n    withStatistics,\n    participantMap,\n    withOpponents,\n    withSeeding,\n  };\n\n  const participantIdsWithConflicts: string[] = [];\n  const mappedMatchUps: { [key: string]: HydratedMatchUp } = {};\n  const matchUps: HydratedMatchUp[] = [];\n  const eventsPublishStatuses = {};\n  const derivedEventInfo: any = {};\n  const derivedDrawInfo: any = {};\n\n  const getRanking = ({ eventType, scaleNames, participantId }) =>\n    participantMap[participantId].participant?.rankings?.[eventType]?.find((ranking) =>\n      scaleNames.includes(ranking.scaleName),\n    )?.scaleValue;\n\n  for (const event of tournamentRecord?.events || []) {\n    if (participantFilters?.eventIds && !participantFilters.eventIds.includes(event.eventId)) continue;\n\n    const { drawDefinitions = [], extensions = [], eventType, eventName, category, entries, eventId, gender } = event;\n\n    const { flightProfile } = getFlightProfile({ event });\n    const flights = flightProfile?.flights ?? [];\n\n    const publishStatuses = getPublishState({ event }).publishState;\n    if (publishStatuses) eventsPublishStatuses[eventId] = publishStatuses;\n    const publishedSeeding = publishStatuses?.publishedSeeding;\n\n    if (withEvents || withSeeding || withRankingProfile) {\n      const extensionConversions = convertExtensions ? Object.assign({}, ...extensionsToAttributes(extensions)) : {};\n\n      derivedEventInfo[eventId] = {\n        ...extensionConversions,\n        eventName,\n        eventType,\n        category,\n        eventId,\n        gender,\n      };\n\n      const scaleNames = [category?.categoryName, category?.ageCategoryCode].filter(Boolean);\n\n      for (const entry of entries) {\n        const { participantId } = entry;\n        if (!participantId || !participantMap[participantId]) continue; // handle bad data\n\n        // get event ranking; this is the same for pairs, teams and all individual participants\n        const ranking = getRanking({ eventType, scaleNames, participantId });\n\n        let seedAssignments, seedValue;\n        if (withSeeding) {\n          const participant = participantMap[participantId].participant;\n          ({ seedAssignments, seedValue } = getEventSeedAssignments({\n            publishedSeeding,\n            usePublishState,\n            withSeeding,\n            participant,\n            event,\n          }));\n        }\n        // IMPORTANT NOTE!\n        // id is the pair, team or individual participant currently being processed\n        // whereas participantId is the id of the entry into the event\n        const addEventEntry = (id: string) => {\n          if (participantMap[id]?.events?.[eventId]) return;\n          const participant = participantMap[id];\n\n          processEventEntry({\n            convertExtensions,\n            seedAssignments,\n            participant,\n            withSeeding,\n            seedValue,\n            eventId,\n            ranking,\n            entry,\n          });\n        };\n\n        addEventEntry(participantId);\n\n        // add details for individualParticipantIds for TEAM/PAIR events\n        const individualParticipantIds = participantMap[participantId].participant.individualParticipantIds || [];\n        individualParticipantIds.forEach(addEventEntry);\n      }\n    }\n    const eventPublishedSeeding = eventsPublishStatuses?.[eventId]?.publishedSeeding;\n\n    if (withDraws || withRankingProfile || withSeeding) {\n      const getSeedingMap = (assignments) =>\n        assignments\n          ? Object.assign(\n              {},\n              ...assignments.map(({ participantId, seedValue, seedNumber }) => ({\n                [participantId]: { seedValue, seedNumber },\n              })),\n            )\n          : undefined;\n\n      const drawIds = unique([...drawDefinitions.map(xa('drawId')), ...flights.map(xa('drawId'))]);\n\n      for (const drawId of drawIds) {\n        const drawDefinition = drawDefinitions.find((drawDefinition) => drawDefinition.drawId === drawId);\n        const flight = flights?.find((flight) => flight.drawId === drawId);\n\n        const entries = drawDefinition?.entries || flight?.drawEntries;\n\n        const { structures = [], drawOrder, drawName, drawType } = drawDefinition ?? {};\n\n        const flightNumber = flight?.flightNumber;\n\n        const scaleNames = [category?.categoryName, category?.ageCategoryCode].filter(Boolean);\n\n        // used in rankings pipeline.\n        // the structures in which a particpant particpates are ordered\n        // to enable differentiation for Points-per-round and points-per-win\n        const orderedStructureIds = (drawDefinition?.structures || [])\n          .sort((a, b) => structureSort(a, b))\n          .map(({ structureId, structures }) => {\n            return [structureId, ...(structures || []).map(({ structureId }) => structureId)];\n          })\n          .flat(Infinity);\n\n        let qualifyingPositionAssignments,\n          qualifyingSeedAssignments,\n          mainPositionAssignments,\n          mainSeedAssignments,\n          drawSize = 0;\n\n        // build up assignedParticipantIds array\n        // to ensure that only assignedParticipants are included\n        const assignedParticipantIds = structures\n          .filter(({ stage, stageSequence }) => (stage === MAIN && stageSequence === 1) || stage === QUALIFYING)\n          .flatMap((structure) => {\n            const { seedAssignments, stageSequence, stage } = structure;\n            const { positionAssignments } = getPositionAssignments({\n              structure,\n            });\n\n            if (stage === MAIN) {\n              drawSize = positionAssignments?.length ?? 0;\n              mainPositionAssignments = positionAssignments;\n              mainSeedAssignments = seedAssignments;\n            } else if (stageSequence === 1) {\n              qualifyingPositionAssignments = positionAssignments;\n              qualifyingSeedAssignments = seedAssignments;\n            }\n            return positionAssignments;\n          })\n          .map(({ participantId }) => participantId)\n          .filter(Boolean);\n\n        const mainSeedingMap = getSeedingMap(mainSeedAssignments);\n        const qualifyingSeedingMap = getSeedingMap(qualifyingSeedAssignments);\n\n        const relevantEntries = !drawDefinition\n          ? entries\n          : entries.filter(({ participantId }) => assignedParticipantIds.includes(participantId));\n\n        const seedingPublished =\n          !usePublishState ||\n          (eventPublishedSeeding?.published &&\n            (eventPublishedSeeding?.drawIds?.length === 0 || eventPublishedSeeding?.drawIds?.includes(drawId)));\n\n        for (const entry of relevantEntries) {\n          const { entryStatus, entryStage, entryPosition, participantId } = entry;\n\n          // get event ranking\n          const ranking = getRanking({\n            participantId,\n            scaleNames,\n            eventType,\n          });\n\n          // IMPORTANT NOTE!\n          // id is the pair, team or individual participant currently being processed\n          // whereas participantId is the id of the entry into the draw\n          const addDrawEntry = (id) => {\n            if (participantMap[id].draws?.[drawId]) return;\n\n            const includeSeeding = withSeeding && seedingPublished;\n\n            const seedAssignments = includeSeeding ? {} : undefined;\n            const mainSeeding = includeSeeding\n              ? mainSeedingMap?.[participantId]?.seedValue || mainSeedingMap?.[participantId]?.seedNumber\n              : undefined;\n            const mainSeedingAssignments = mainSeeding ? mainSeedingMap?.[participantId] : undefined;\n            const qualifyingSeeding = includeSeeding\n              ? qualifyingSeedingMap?.[participantId]?.seedValue || qualifyingSeedingMap?.[participantId]?.seedNumber\n              : undefined;\n            const qualifyingSeedingAssignments = qualifyingSeeding ? qualifyingSeedingMap?.[participantId] : undefined;\n\n            if (seedAssignments && mainSeeding) seedAssignments[MAIN] = mainSeedingAssignments;\n            if (seedAssignments && qualifyingSeeding) seedAssignments[QUALIFYING] = qualifyingSeedingAssignments;\n\n            const seedValue = mainSeeding || qualifyingSeeding;\n            if (seedValue) {\n              if (!participantMap[id].participant.seedings[eventType])\n                participantMap[id].participant.seedings[eventType] = [];\n\n              if (mainSeedingAssignments) {\n                participantMap[id].participant.seedings[eventType].push({\n                  ...mainSeedingAssignments,\n                  scaleName: drawId,\n                });\n              }\n              if (qualifyingSeedingAssignments) {\n                participantMap[id].participant.seedings[eventType].push({\n                  ...qualifyingSeedingAssignments,\n                  scaleName: drawId,\n                });\n              }\n\n              if (seedAssignments) {\n                if (!participantMap[id].events[eventId].seedAssignments)\n                  participantMap[id].events[eventId].seedAssignments = {};\n\n                Object.keys(seedAssignments).forEach(\n                  (stage) => (participantMap[id].events[eventId].seedAssignments[stage] = seedAssignments[stage]),\n                );\n              }\n            }\n\n            if (withDraws || withRankingProfile) {\n              participantMap[id].draws[drawId] = definedAttributes(\n                {\n                  seedAssignments,\n                  entryPosition,\n                  entryStatus,\n                  entryStage,\n                  seedValue,\n                  eventId,\n                  ranking,\n                  drawId,\n                },\n                false,\n                false,\n                true,\n              );\n            }\n          };\n\n          if (![UNGROUPED, UNPAIRED].includes(entryStatus)) {\n            addDrawEntry(participantId);\n\n            const individualParticipantIds = participantMap[participantId].participant.individualParticipantIds || [];\n\n            // add for individualParticipantIds when participantType is TEAM/PAIR\n            individualParticipantIds?.forEach(addDrawEntry);\n          }\n        }\n\n        const stages = (drawDefinition?.structures ?? []).reduce((stages, structure) => {\n          if (!stages.includes(structure.stage)) stages.push(structure.stage);\n          return stages;\n        }, []);\n\n        const linksCount = (drawDefinition?.links ?? []).length;\n\n        derivedDrawInfo[drawId] = {\n          qualifyingPositionAssignments,\n          qualifyingSeedAssignments,\n          mainPositionAssignments,\n          qualifyingSeedingMap,\n          mainSeedAssignments,\n          orderedStructureIds,\n          mainSeedingMap,\n          flightNumber,\n          linksCount,\n          drawOrder,\n          drawName,\n          drawType,\n          drawSize,\n          drawId,\n          stages,\n          // qualifyingDrawSize,\n        };\n      }\n    }\n\n    if (\n      withRankingProfile ||\n      scheduleAnalysis ||\n      withTeamMatchUps ||\n      withStatistics ||\n      withOpponents ||\n      withMatchUps ||\n      withDraws\n    ) {\n      const nextMatchUps = !!scheduleAnalysis || withPotentialMatchUps;\n      const eventMatchUps =\n        allEventMatchUps({\n          afterRecoveryTimes: !!scheduleAnalysis,\n          policyDefinitions,\n          tournamentRecord,\n          inContext: true,\n          contextProfile,\n          participantMap,\n          nextMatchUps,\n          event,\n        })?.matchUps ?? [];\n\n      for (const matchUp of eventMatchUps) {\n        const {\n          finishingPositionRange,\n          potentialParticipants,\n          tieMatchUps = [],\n          sides = [],\n          winningSide,\n          matchUpType,\n          matchUpId,\n          eventId,\n          drawId,\n          collectionId,\n          stageSequence,\n          finishingRound,\n          matchUpStatus,\n          roundPosition,\n          roundNumber,\n          structureId,\n          schedule,\n          score,\n          stage,\n        } = matchUp;\n\n        mappedMatchUps[matchUpId] = matchUp;\n\n        const baseAttrs = {\n          finishingPositionRange,\n          finishingRound,\n          stageSequence,\n          roundPosition,\n          collectionId,\n          roundNumber,\n          structureId,\n          schedule,\n          eventId,\n          drawId,\n          score,\n          stage,\n        };\n\n        processSides({\n          ...baseAttrs,\n          ...withOpts,\n          matchUpStatus,\n          winningSide,\n          matchUpType,\n          matchUpId,\n          sides,\n        });\n\n        for (const tieMatchUp of tieMatchUps) {\n          const {\n            winningSide: tieMatchUpWinningSide,\n            sides: tieMatchUpSides = [],\n            matchUpId: tieMatchUpId,\n            matchUpStatus,\n            matchUpType,\n          } = tieMatchUp;\n          processSides({\n            ...baseAttrs,\n            ...withOpts,\n            winningSide: tieMatchUpWinningSide,\n            tieWinningSide: winningSide,\n            matchUpTieId: matchUpId,\n            matchUpId: tieMatchUpId,\n            sides: tieMatchUpSides,\n            matchUpSides: sides,\n            matchUpStatus,\n            matchUpType,\n          });\n        }\n\n        if (Array.isArray(potentialParticipants) && (nextMatchUps || !!scheduleAnalysis || withScheduleItems)) {\n          const potentialParticipantIds = potentialParticipants.flat().map(xa('participantId')).filter(Boolean);\n          potentialParticipantIds?.forEach((participantId) => {\n            const relevantParticipantIds = getRelevantParticipantIds(participantId);\n\n            relevantParticipantIds?.forEach((relevantParticipantId) => {\n              if (!participantMap[relevantParticipantId]) {\n                return;\n              }\n              participantMap[relevantParticipantId].potentialMatchUps[matchUpId] = definedAttributes({\n                tournamentId: tournamentRecord?.tournamentId,\n                matchUpId,\n                eventId,\n                drawId,\n              });\n            });\n\n            if (!!scheduleAnalysis || withScheduleItems) {\n              addScheduleItem({\n                potential: true,\n                participantMap,\n                participantId,\n                matchUpStatus,\n                roundPosition,\n                structureId,\n                matchUpType,\n                roundNumber,\n                matchUpId,\n                schedule,\n                drawId,\n                score,\n              });\n            }\n          });\n        }\n      }\n\n      matchUps.push(...eventMatchUps);\n    }\n  }\n\n  if (withStatistics || withRankingProfile || !!scheduleAnalysis) {\n    const aggregators: any[] = Object.values(participantMap);\n    for (const participantAggregator of aggregators) {\n      const {\n        wins,\n        losses,\n        [SINGLES]: { wins: singlesWins, losses: singlesLosses },\n        [DOUBLES]: { wins: doublesWins, losses: doublesLosses },\n      } = participantAggregator.counters;\n\n      const addStatValue = (statCode, wins, losses) => {\n        const denominator = wins + losses;\n        const numerator = wins;\n\n        const statValue = denominator && numerator / denominator;\n\n        participantAggregator.statistics[statCode] = {\n          denominator,\n          numerator,\n          statValue,\n          statCode,\n        };\n      };\n\n      if (withStatistics) {\n        addStatValue(WIN_RATIO, wins, losses);\n        addStatValue(`${WIN_RATIO}.${SINGLES}`, singlesWins, singlesLosses);\n        addStatValue(`${WIN_RATIO}.${DOUBLES}`, doublesWins, doublesLosses);\n      }\n\n      if (withRankingProfile) {\n        const diff = (range = []) => Math.abs(range[0] - range[1]);\n        for (const drawId of Object.keys(participantAggregator.draws)) {\n          const { orderedStructureIds = [], flightNumber } = derivedDrawInfo[drawId] || {};\n          if (participantAggregator.structureParticipation && orderedStructureIds.length) {\n            let finishingPositionRange;\n            let nonQualifyingOrder = 0;\n\n            // structures in which a participant participants/exits\n            const orderedParticipation = orderedStructureIds\n              .map((structureId) => {\n                const participation = participantAggregator.structureParticipation[structureId];\n                if (!participation) return;\n\n                if (!finishingPositionRange) finishingPositionRange = participation?.finishingPositionRange;\n                if (diff(finishingPositionRange) > diff(participation?.finishingPositionRange))\n                  finishingPositionRange = participation?.finishingPositionRange;\n\n                const notQualifying = participation.stage !== QUALIFYING;\n                if (notQualifying) nonQualifyingOrder += 1;\n\n                const participationOrder = notQualifying ? nonQualifyingOrder : undefined;\n\n                return definedAttributes({\n                  ...participation,\n                  participationOrder,\n                  flightNumber,\n                });\n              })\n              .filter(Boolean);\n\n            if (participantAggregator.draws[drawId]) {\n              participantAggregator.draws[drawId].finishingPositionRange = finishingPositionRange;\n              participantAggregator.draws[drawId].structureParticipation = orderedParticipation;\n            }\n          }\n        }\n      }\n\n      if (scheduleAnalysis) {\n        const scheduledMinutesDifference = isObject(scheduleAnalysis) ? scheduleAnalysis.scheduledMinutesDifference : 0;\n\n        // iterate through participantAggregator.scheduleItems\n        const scheduleItems = participantAggregator.scheduleItems || [];\n        const potentialMatchUps = participantAggregator.potentialMatchUps || {};\n        const dateItems = scheduleItems.reduce((dateItems, scheduleItem) => {\n          const { scheduledDate, scheduledTime } = scheduleItem;\n          if (!dateItems[scheduledDate]) dateItems[scheduledDate] = [];\n          if (scheduledTime) dateItems[scheduledDate].push(scheduleItem);\n\n          return dateItems;\n        }, {});\n\n        // sort scheduleItems for each date\n        Object.values(dateItems).forEach((items: any) => items.sort(timeSort));\n\n        for (const scheduleItem of scheduleItems) {\n          const { typeChangeTimeAfterRecovery, timeAfterRecovery, scheduledDate, scheduledTime } = scheduleItem;\n\n          const scheduleItemsToConsider = dateItems[scheduledDate];\n          const scheduledMinutes = timeStringMinutes(scheduledTime);\n\n          for (const consideredItem of scheduleItemsToConsider) {\n            const ignoreItem =\n              consideredItem.matchUpId === scheduleItem.matchUpId ||\n              ([WALKOVER, DEFAULTED].includes(consideredItem.matchUpStatus) && !consideredItem.checkScoreHasValue);\n            if (ignoreItem) continue;\n\n            // if there is a matchType change (SINGLES => DOUBLES or vice versa) then there is potentially a different timeAfterRecovery\n            const typeChange = scheduleItem.matchUpType !== consideredItem.matchUpType;\n\n            const notBeforeTime = typeChange ? typeChangeTimeAfterRecovery || timeAfterRecovery : timeAfterRecovery;\n\n            // if two matchUps are both potentials and both part of the same draw they cannot be considered in conflict\n            const sameDraw = scheduleItem.drawId === consideredItem.drawId;\n\n            const bothPotential =\n              potentialMatchUps[scheduleItem.matchUpId] && potentialMatchUps[consideredItem.matchUpId];\n\n            const consideredMinutes = timeStringMinutes(consideredItem.scheduledTime);\n            const minutesDifference = Math.abs(consideredMinutes - scheduledMinutes);\n            const itemIsPrior = consideredMinutes >= scheduledMinutes;\n\n            // Conflicts can be determined in two ways:\n            // 1. scheduledMinutesDifference - the minutes difference between two scheduledTimes\n            // 2. A scheduledTime occurring before a prior matchUps notBeforeTime (timeAfterRecovery)\n            const timeOverlap =\n              scheduledMinutesDifference && !isNaN(scheduledMinutesDifference)\n                ? minutesDifference <= scheduledMinutesDifference\n                : itemIsPrior && timeStringMinutes(consideredItem.scheduledTime) < timeStringMinutes(notBeforeTime);\n\n            // if there is a time overlap capture both the prior matchUpId and the conflicted matchUpId\n            if (timeOverlap && !(bothPotential && sameDraw) && itemIsPrior) {\n              const key = [scheduleItem.matchUpId, consideredItem.matchUpId].sort(stringSort).join('|');\n              participantAggregator.scheduleConflicts[key] = {\n                priorScheduledMatchUpId: scheduleItem.matchUpId,\n                matchUpIdWithConflict: consideredItem.matchUpId,\n              };\n            }\n          }\n        }\n\n        const pid = participantAggregator.participant.participantId;\n        if (Object.keys(participantAggregator.scheduleConflicts).length) {\n          participantIdsWithConflicts.push(pid);\n        }\n\n        participantMap[pid].scheduleConflicts = participantAggregator.scheduleConflicts;\n      }\n    }\n  }\n\n  return {\n    participantIdsWithConflicts,\n    eventsPublishStatuses,\n    derivedEventInfo,\n    derivedDrawInfo,\n    mappedMatchUps,\n    participantMap,\n    matchUps,\n  };\n}\n","import { MISSING_DRAW_DEFINITION } from '../../constants/errorConditionConstants';\nimport { DrawDefinition } from '../../types/tournamentTypes';\n\ntype ParticipantInEntriesArgs = {\n  drawDefinition: DrawDefinition;\n  participantId: string;\n  entryStatus?: string;\n  entryStage?: string;\n};\nexport function participantInEntries({\n  participantId,\n  drawDefinition,\n  entryStatus,\n  entryStage,\n}: ParticipantInEntriesArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const inEntries = drawDefinition.entries?.find(\n    (entry) =>\n      entry.participantId === participantId &&\n      (!entryStatus || entryStatus === entry.entryStatus) &&\n      (!entryStage || entryStage === entry.entryStage)\n  );\n  return participantId && inEntries;\n}\n","import { getAllStructureMatchUps } from '../matchUps/getAllStructureMatchUps';\nimport { getEntryProfile } from './getEntryProfile';\nimport { findStructure } from '../../acquire/findStructure';\n\nimport { MISSING_DRAW_DEFINITION } from '../../constants/errorConditionConstants';\nimport { CONTAINER, QUALIFYING } from '../../constants/drawDefinitionConstants';\nimport { DrawDefinition } from '../../types/tournamentTypes';\n\ntype GetQualifiersCountArgs = {\n  provisionalPositioning?: boolean;\n  drawDefinition: DrawDefinition;\n  stageSequence?: number;\n  structureId?: string;\n  stage?: string;\n};\nexport function getQualifiersCount(params: GetQualifiersCountArgs) {\n  const {\n    provisionalPositioning,\n    drawDefinition,\n    stageSequence,\n    structureId,\n    stage,\n  } = params;\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const { entryProfile } = getEntryProfile({ drawDefinition });\n  const profileQualifiersCount =\n    (stage &&\n      stageSequence &&\n      entryProfile?.[stage]?.stageSequence?.[stageSequence]?.qualifiersCount) ||\n    (stage && entryProfile?.[stage]?.qualifiersCount) ||\n    0;\n\n  const roundQualifiersCounts = {};\n\n  if (!structureId)\n    return { qualifiersCount: profileQualifiersCount, roundQualifiersCounts };\n\n  const { structure } = findStructure({ drawDefinition, structureId });\n  const relevantLinks = drawDefinition.links?.filter(\n    (link) => link?.target?.structureId === structure?.structureId\n  );\n\n  let qualifiersCount = 0;\n\n  // if structureId is provided and there is a relevant link...\n  if (relevantLinks?.length) {\n    for (const relevantLink of relevantLinks) {\n      const sourceStructure = findStructure({\n        structureId: relevantLink.source.structureId,\n        drawDefinition,\n      })?.structure;\n\n      if (sourceStructure?.stage === QUALIFYING) {\n        const sourceRoundNumber: number = relevantLink.source\n          .roundNumber as number;\n        const roundTarget = relevantLink.target.roundNumber;\n        let count = 0;\n\n        if (sourceStructure.structureType === CONTAINER) {\n          // for Round Robin qualifying the number of qualifiers needs to be derived from:\n          // the number of groups (substructures) * the length of source.finishingPositions[]\n          const groupCount = sourceStructure.structures?.length ?? 0;\n          const finishingPositionsCount =\n            relevantLink.source.finishingPositions?.length ?? 0;\n\n          count = groupCount * finishingPositionsCount;\n        } else {\n          // return source structure qualifying round matchUps count\n          const matchUps = getAllStructureMatchUps({\n            matchUpFilters: { roundNumbers: [sourceRoundNumber] },\n            structure: sourceStructure,\n            afterRecoveryTimes: false,\n            provisionalPositioning,\n            inContext: false,\n          }).matchUps;\n\n          count = matchUps?.length || 0;\n        }\n\n        if (!roundQualifiersCounts[roundTarget])\n          roundQualifiersCounts[roundTarget] = 0;\n        roundQualifiersCounts[roundTarget] += count;\n\n        qualifiersCount += count;\n      }\n    }\n  }\n\n  // allow profileQualifiersCount to override if and only if there is only one qualifying roundTarget\n  const qualifyingRounds = Object.keys(roundQualifiersCounts);\n  if (qualifyingRounds.length <= 1) {\n    const qualifyingRound = qualifyingRounds[0] || 1;\n    roundQualifiersCounts[qualifyingRound] = Math.max(\n      roundQualifiersCounts[qualifyingRound] || 0,\n      profileQualifiersCount\n    );\n  }\n\n  qualifiersCount = Math.max(qualifiersCount, profileQualifiersCount);\n\n  return { qualifiersCount, roundQualifiersCounts };\n}\n","import { getQualifiersCount } from './getQualifiersCount';\nimport { getEntryProfile } from './getEntryProfile';\n\nexport function getStageDrawPositionsCount({ stage, drawDefinition }) {\n  const { entryProfile } = getEntryProfile({ drawDefinition });\n  return entryProfile?.[stage]?.drawSize || 0;\n}\n\n// drawSize - qualifyingPositions\nexport function getStageDrawPositionsAvailable(params) {\n  const { provisionalPositioning, drawDefinition, stageSequence, stage } =\n    params;\n  const drawSize = getStageDrawPositionsCount({ stage, drawDefinition });\n\n  const { qualifiersCount } = getQualifiersCount({\n    provisionalPositioning,\n    drawDefinition,\n    stageSequence,\n    stage,\n  });\n  return drawSize && drawSize - qualifiersCount;\n}\n","import { getStageDrawPositionsCount } from './getStageDrawPositions';\nimport { stageExists } from './stageGetter';\n\nimport { VOLUNTARY_CONSOLATION } from '../../constants/drawDefinitionConstants';\n\nexport function getValidStage({ stage, drawDefinition }) {\n  return Boolean(\n    stage === VOLUNTARY_CONSOLATION ||\n      (stageExists({ stage, drawDefinition }) &&\n        getStageDrawPositionsCount({ stage, drawDefinition }))\n  );\n}\n","import { getStageDrawPositionsAvailable } from './getStageDrawPositions';\nimport {\n  getStageEntryTypeCount,\n  getStageWildcardsCount,\n  stageAlternatesCount,\n} from './stageGetter';\n\nimport { VOLUNTARY_CONSOLATION } from '../../constants/drawDefinitionConstants';\nimport { DrawDefinition } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ENTRY_STATUS_NOT_ALLOWED_IN_STAGE,\n  ErrorType,\n  NO_STAGE_SPACE_AVAILABLE_FOR_ENTRY_STATUS,\n} from '../../constants/errorConditionConstants';\nimport {\n  ALTERNATE,\n  DIRECT_ACCEPTANCE,\n  WILDCARD,\n} from '../../constants/entryStatusConstants';\n\ntype GetStageSpaceArgs = {\n  drawDefinition: DrawDefinition;\n  stageSequence?: number;\n  entryStatus?: string;\n  stage: string;\n};\n\nexport function getStageSpace({\n  entryStatus = DIRECT_ACCEPTANCE,\n  drawDefinition,\n  stageSequence,\n  stage,\n}: GetStageSpaceArgs): {\n  positionsAvailable?: number;\n  success?: boolean;\n  error?: ErrorType;\n} {\n  if (entryStatus === ALTERNATE) {\n    if (stageAlternatesCount({ stage, drawDefinition })) {\n      return { positionsAvailable: Infinity, ...SUCCESS };\n    } else {\n      return { error: ENTRY_STATUS_NOT_ALLOWED_IN_STAGE };\n    }\n  }\n\n  const stageDrawPositionsAvailable = getStageDrawPositionsAvailable({\n    drawDefinition,\n    stageSequence,\n    stage,\n  });\n  const wildcardPositions = getStageWildcardsCount({\n    drawDefinition,\n    stage,\n  });\n  const wildcardEntriesCount = getStageEntryTypeCount({\n    entryStatus: WILDCARD,\n    drawDefinition,\n    stage,\n  });\n  const directEntriesCount = getStageEntryTypeCount({\n    entryStatus: DIRECT_ACCEPTANCE,\n    drawDefinition,\n    stage,\n  });\n  const totalEntriesCount = wildcardEntriesCount + directEntriesCount;\n  const stageFull = totalEntriesCount >= stageDrawPositionsAvailable;\n  const positionsAvailable = stageDrawPositionsAvailable - totalEntriesCount;\n\n  if (stage !== VOLUNTARY_CONSOLATION && stageFull) {\n    return { error: NO_STAGE_SPACE_AVAILABLE_FOR_ENTRY_STATUS };\n  }\n\n  if (entryStatus === WILDCARD) {\n    if (wildcardEntriesCount < wildcardPositions) return { ...SUCCESS };\n    return { error: NO_STAGE_SPACE_AVAILABLE_FOR_ENTRY_STATUS };\n  }\n\n  return { positionsAvailable, ...SUCCESS };\n}\n","import { refreshEntryPositions } from '../../entries/refreshEntryPositions';\nimport { addExtension } from '../../extensions/addExtension';\nimport { isValidExtension } from '../../../validators/isValidExtension';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { modifyDrawNotice } from '../../notifications/drawNotifications';\nimport { participantInEntries } from '../../../query/drawDefinition/entryGetter';\nimport { getValidStage } from '../../../query/drawDefinition/getValidStage';\nimport { getStageSpace } from '../../../query/drawDefinition/getStageSpace';\n\nimport { ROUND_TARGET } from '../../../constants/extensionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_STAGE,\n  MISSING_STAGE,\n  EXISTING_PARTICIPANT,\n  MISSING_DRAW_DEFINITION,\n  INVALID_PARTICIPANT_IDS,\n  MISSING_PARTICIPANT_ID,\n  PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE,\n  INVALID_VALUES,\n} from '../../../constants/errorConditionConstants';\nimport {\n  AD_HOC,\n  MAIN,\n  VOLUNTARY_CONSOLATION,\n} from '../../../constants/drawDefinitionConstants';\nimport {\n  DrawDefinition,\n  Entry,\n  EntryStatusUnion,\n  Extension,\n  Participant,\n  StageTypeUnion,\n} from '../../../types/tournamentTypes';\nimport {\n  DIRECT_ACCEPTANCE,\n  LUCKY_LOSER,\n} from '../../../constants/entryStatusConstants';\n\ntype AddDrawEntryArgs = {\n  entryStatus?: EntryStatusUnion;\n  drawDefinition: DrawDefinition;\n  entryStageSequence?: number;\n  ignoreStageSpace?: boolean;\n  entryStage?: StageTypeUnion;\n  participant?: Participant;\n  extensions?: Extension[];\n  entryPosition?: number;\n  extension?: Extension;\n  participantId: string;\n  roundTarget?: number;\n  drawType?: string;\n};\n\nexport function addDrawEntry(params: AddDrawEntryArgs) {\n  const {\n    entryStatus = DIRECT_ACCEPTANCE,\n    entryStageSequence,\n    entryStage = MAIN,\n    ignoreStageSpace,\n    drawDefinition,\n    entryPosition,\n    participant,\n    roundTarget,\n    extensions,\n    extension,\n    drawType,\n  } = params;\n\n  const stack = 'addDrawEntry';\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!entryStage) return { error: MISSING_STAGE };\n  if (\n    drawType !== AD_HOC &&\n    !getValidStage({ stage: entryStage, drawDefinition })\n  ) {\n    return decorateResult({ result: { error: INVALID_STAGE }, stack });\n  }\n  const spaceAvailable = getStageSpace({\n    stageSequence: entryStageSequence,\n    stage: entryStage,\n    drawDefinition,\n    entryStatus,\n  });\n  if (!ignoreStageSpace && !spaceAvailable.success) {\n    return { error: spaceAvailable.error };\n  }\n\n  if (extension && !isValidExtension({ extension }))\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      info: 'Invalid extension',\n      context: { extension },\n      stack,\n    });\n\n  const participantId = params.participantId || participant?.participantId;\n  if (!participantId)\n    return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack });\n\n  const invalidLuckyLoser =\n    entryStatus === LUCKY_LOSER &&\n    participantInEntries({ participantId, drawDefinition, entryStatus });\n  const invalidVoluntaryConsolation =\n    entryStage === VOLUNTARY_CONSOLATION &&\n    participantInEntries({\n      participantId,\n      drawDefinition,\n      entryStage,\n    });\n  const invalidEntry =\n    entryStatus !== LUCKY_LOSER &&\n    entryStage !== VOLUNTARY_CONSOLATION &&\n    participantInEntries({ drawDefinition, participantId });\n\n  if (invalidEntry || invalidLuckyLoser || invalidVoluntaryConsolation) {\n    return decorateResult({\n      context: { invalidEntry, invalidLuckyLoser, invalidVoluntaryConsolation },\n      result: { error: EXISTING_PARTICIPANT },\n      stack,\n    });\n  }\n\n  const entry = definedAttributes({\n    entryStageSequence,\n    participantId,\n    entryPosition,\n    entryStatus,\n    entryStage,\n    extensions,\n  });\n\n  if (extension) {\n    addExtension({ element: entry, extension });\n  }\n\n  if (roundTarget) {\n    addExtension({\n      extension: { name: 'roundEntry', value: roundTarget },\n      element: entry,\n    });\n  }\n\n  if (!drawDefinition.entries) drawDefinition.entries = [];\n  drawDefinition.entries.push(entry);\n  modifyDrawNotice({ drawDefinition });\n\n  return { ...SUCCESS };\n}\n\ntype AddDrawEntriesArgs = {\n  entryStatus?: EntryStatusUnion;\n  drawDefinition: DrawDefinition;\n  autoEntryPositions?: boolean;\n  ignoreStageSpace?: boolean;\n  participantIds: string[];\n  stageSequence?: number;\n  extension?: Extension;\n  stage?: StageTypeUnion;\n  roundTarget?: number;\n};\n\nexport function addDrawEntries(params: AddDrawEntriesArgs) {\n  const stack = 'addDrawEntries';\n  const {\n    entryStatus = DIRECT_ACCEPTANCE,\n    stage = MAIN,\n    autoEntryPositions = true,\n    ignoreStageSpace,\n    drawDefinition,\n    participantIds,\n    stageSequence,\n    roundTarget,\n    extension,\n  } = params;\n\n  if (!stage) return { error: MISSING_STAGE };\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!Array.isArray(participantIds)) return { error: INVALID_PARTICIPANT_IDS };\n  if (!getValidStage({ stage, drawDefinition })) {\n    return { error: INVALID_STAGE };\n  }\n\n  if (extension && !isValidExtension({ extension })) {\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      info: 'Invalid extension',\n      context: { extension },\n      stack,\n    });\n  }\n\n  const spaceAvailable = getStageSpace({\n    drawDefinition,\n    stageSequence,\n    entryStatus,\n    stage,\n  });\n  if (!ignoreStageSpace && !spaceAvailable.success) {\n    return { error: spaceAvailable.error };\n  }\n  const positionsAvailable = spaceAvailable.positionsAvailable ?? 0;\n  if (\n    !ignoreStageSpace &&\n    stage !== VOLUNTARY_CONSOLATION &&\n    positionsAvailable < participantIds.length\n  )\n    return { error: PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE };\n\n  const participantIdsNotAdded = participantIds.reduce(\n    (notAdded: string[], participantId) => {\n      const invalidLuckyLoser =\n        entryStatus === LUCKY_LOSER &&\n        participantInEntries({ participantId, drawDefinition, entryStatus });\n      const invalidVoluntaryConsolation =\n        stage === VOLUNTARY_CONSOLATION &&\n        participantInEntries({\n          entryStage: stage,\n          drawDefinition,\n          participantId,\n        });\n      const invalidEntry =\n        entryStatus !== LUCKY_LOSER &&\n        stage !== VOLUNTARY_CONSOLATION &&\n        participantInEntries({ drawDefinition, participantId });\n\n      if (invalidEntry || invalidLuckyLoser || invalidVoluntaryConsolation) {\n        return notAdded.concat(participantId);\n      }\n      return notAdded;\n    },\n    []\n  );\n\n  participantIds\n    .filter(\n      (participantId) =>\n        participantId && !participantIdsNotAdded.includes(participantId)\n    )\n    .forEach((participantId) => {\n      const entry: Entry = {\n        entryStageSequence: stageSequence,\n        entryStage: stage,\n        participantId,\n        entryStatus,\n      };\n      if (extension) {\n        addExtension({ element: entry, extension });\n      }\n      if (roundTarget) {\n        addExtension({\n          extension: { name: ROUND_TARGET, value: roundTarget },\n          element: entry,\n        });\n      }\n      if (!drawDefinition.entries) drawDefinition.entries = [];\n      drawDefinition.entries.push(entry);\n    });\n\n  if (autoEntryPositions) {\n    drawDefinition.entries = refreshEntryPositions({\n      entries: drawDefinition.entries,\n    });\n  }\n\n  modifyDrawNotice({ drawDefinition });\n\n  return participantIdsNotAdded?.length\n    ? {\n        info: 'some participantIds could not be added',\n        participantIdsNotAdded,\n        ...SUCCESS,\n      }\n    : { ...SUCCESS };\n}\n","import { addDrawEntries as addEntries } from './entryGovernor/addDrawEntries';\nimport { refreshEntryPositions } from '../entries/refreshEntryPositions';\nimport { getParticipantId } from '../../global/functions/extractors';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\n\nimport { VOLUNTARY_CONSOLATION } from '../../constants/drawDefinitionConstants';\nimport { LUCKY_LOSER } from '../../constants/entryStatusConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  EVENT_NOT_FOUND,\n  MISSING_DRAW_ID,\n  MISSING_ENTRIES,\n  MISSING_PARTICIPANT_IDS,\n} from '../../constants/errorConditionConstants';\nimport { EntryStatusUnion } from '../../types/tournamentTypes';\n\nexport function addDrawEntries({\n  autoEntryPositions = true,\n  entryStageSequence,\n  ignoreStageSpace,\n  drawDefinition,\n  participantIds,\n  entryStatus,\n  roundTarget,\n  entryStage,\n  extension,\n  drawId,\n  event,\n}) {\n  if (!participantIds?.length) return { error: MISSING_PARTICIPANT_IDS };\n  if (!event) return { error: EVENT_NOT_FOUND };\n  if (!drawId) return { error: MISSING_DRAW_ID };\n\n  const eventEnteredParticipantIds = (event.entries || []).map(\n    getParticipantId\n  );\n  const missingEventEntries = participantIds.filter(\n    (participantId) => !eventEnteredParticipantIds.includes(participantId)\n  );\n  if (missingEventEntries.length) return { error: MISSING_ENTRIES };\n\n  if (drawDefinition) {\n    const result = addEntries({\n      stageSequence: entryStageSequence,\n      autoEntryPositions,\n      stage: entryStage,\n      ignoreStageSpace,\n      drawDefinition,\n      participantIds,\n      entryStatus,\n      roundTarget,\n      extension,\n    });\n    if (result.error) return result;\n  }\n\n  const { flightProfile } = getFlightProfile({ event });\n  const flight = flightProfile?.flights.find(\n    (flight) => flight.drawId === drawId\n  );\n\n  if (flight?.drawEntries) {\n    participantIds.forEach((participantId) => {\n      const invalidLuckyLoser =\n        entryStatus === LUCKY_LOSER &&\n        participantInFlightEntries({\n          participantId,\n          entryStatus,\n          flight,\n        });\n      const invalidVoluntaryConsolation =\n        entryStage === VOLUNTARY_CONSOLATION &&\n        participantInFlightEntries({\n          participantId,\n          entryStage,\n          flight,\n        });\n      const invalidEntry =\n        entryStatus !== LUCKY_LOSER &&\n        entryStage !== VOLUNTARY_CONSOLATION &&\n        participantInFlightEntries({ flight, participantId });\n\n      if (!invalidEntry && !invalidLuckyLoser && !invalidVoluntaryConsolation) {\n        flight.drawEntries.push({\n          participantId,\n          entryStatus,\n          entryStage,\n        });\n      }\n    });\n\n    if (autoEntryPositions) {\n      flight.drawEntries = refreshEntryPositions({\n        entries: flight.drawEntries,\n      });\n    }\n  }\n\n  return { ...SUCCESS };\n}\n\ntype ParticipantInFlightEntriesArgs = {\n  entryStatus?: EntryStatusUnion;\n  participantId: string;\n  entryStage?: string;\n  flight: any;\n};\nfunction participantInFlightEntries({\n  participantId,\n  entryStatus,\n  entryStage,\n  flight,\n}: ParticipantInFlightEntriesArgs) {\n  const inEntries = flight.drawEntries?.find(\n    (entry) =>\n      entry.participantId === participantId &&\n      (!entryStatus || entryStatus === entry.entryStatus) &&\n      (!entryStage || entryStage === entry.entryStage)\n  );\n  return participantId && inEntries;\n}\n","import { getAssignedParticipantIds } from '../../query/drawDefinition/getAssignedParticipantIds';\nimport { refreshEntryPositions } from './refreshEntryPositions';\nimport { xa, isString } from '../../utilities/objects';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { intersection } from '../../utilities/arrays';\n\nimport { HydratedParticipant } from '../../types/hydrated';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_EVENT,\n  EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT,\n  ErrorType,\n  INVALID_PARTICIPANT_ID,\n} from '../../constants/errorConditionConstants';\nimport { EntryStatusUnion, Event, StageTypeUnion, Tournament } from '../../types/tournamentTypes';\n\ntype RemoveEventEntriesArgs = {\n  tournamentParticipants?: HydratedParticipant[];\n  entryStatuses?: EntryStatusUnion[];\n  tournamentRecord?: Tournament;\n  autoEntryPositions?: boolean;\n  participantIds: string[];\n  stage?: StageTypeUnion;\n  event: Event;\n};\nexport function removeEventEntries({\n  autoEntryPositions = true,\n  participantIds = [],\n  entryStatuses,\n  stage,\n  event,\n}: RemoveEventEntriesArgs): {\n  participantIdsRemoved?: string[];\n  success?: boolean;\n  error?: ErrorType;\n} {\n  const stack = 'removeEventEntries';\n  if (!event?.eventId) return { error: MISSING_EVENT };\n\n  if (!Array.isArray(participantIds) || participantIds.some((participantId) => !isString(participantId))) {\n    return decorateResult({ result: { error: INVALID_PARTICIPANT_ID }, stack });\n  }\n\n  // do not filter by stages; must kmow all participantIds assigned to any stage!\n  const assignedParticipantIds = (event.drawDefinitions ?? []).flatMap(\n    (drawDefinition) => getAssignedParticipantIds({ drawDefinition }).assignedParticipantIds ?? [],\n  );\n\n  const statusParticipantIds = (\n    (entryStatuses?.length &&\n      event.entries?.filter((entry) => entry.entryStatus && entryStatuses.includes(entry.entryStatus))) ||\n    []\n  )\n    .map(xa('participantId'))\n    .filter((participantId) => !assignedParticipantIds.includes(participantId));\n\n  const stageParticipantIds = (\n    (stage && event.entries?.filter((entry) => entry.entryStage && entry.entryStage === stage)) ||\n    []\n  )\n    .map(xa('participantId'))\n    .filter((participantId) => !assignedParticipantIds.includes(participantId));\n\n  if (participantIds.length) {\n    participantIds = participantIds.filter(\n      (participantId) =>\n        (!entryStatuses?.length || statusParticipantIds.includes(participantId)) &&\n        (!stage || stageParticipantIds.includes(participantId)),\n    );\n  } else if (statusParticipantIds.length && stageParticipantIds.length) {\n    participantIds = intersection(statusParticipantIds, stageParticipantIds);\n  } else if (statusParticipantIds.length) {\n    participantIds = statusParticipantIds;\n  } else if (stageParticipantIds.length) {\n    participantIds = stageParticipantIds;\n  }\n\n  if (\n    participantIds?.length &&\n    assignedParticipantIds.some((participantId) => participantIds.includes(participantId))\n  ) {\n    return decorateResult({\n      result: { error: EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT },\n      stack,\n    });\n  }\n\n  if (!participantIds?.length) return { ...SUCCESS, participantIdsRemoved: [] };\n\n  const participantIdsRemoved: string[] = [];\n\n  event.entries = (event.entries ?? []).filter((entry) => {\n    const keepEntry = !participantIds.includes(entry?.participantId);\n    if (!keepEntry) participantIdsRemoved.push(entry.participantId);\n    return keepEntry;\n  });\n\n  if (autoEntryPositions) {\n    event.entries = refreshEntryPositions({\n      entries: event.entries,\n    });\n  }\n\n  // also remove entry from all flights and drawDefinitions\n  const { flightProfile } = getFlightProfile({ event });\n  flightProfile?.flights?.forEach((flight) => {\n    flight.drawEntries = (flight.drawEntries || []).filter((entry) => !participantIds.includes(entry.participantId));\n  });\n\n  event.drawDefinitions?.forEach((drawDefinition) => {\n    drawDefinition.entries = (drawDefinition.entries ?? []).filter(\n      (entry) => !participantIds.includes(entry.participantId),\n    );\n  });\n\n  return { ...SUCCESS, participantIdsRemoved };\n}\n","import { POLICY_TYPE_MATCHUP_ACTIONS } from '../../constants/policyConstants';\n\nexport const POLICY_MATCHUP_ACTIONS_DEFAULT = {\n  [POLICY_TYPE_MATCHUP_ACTIONS]: {\n    policyName: 'matchUpActionsDefault',\n\n    // matchUpActions will be selectively enabled for structures matching { stages: [], stageSequences: [] }\n    // enabledStructures: [] => all structures are enabled\n    enabledStructures: [\n      {\n        stages: [], // stages: [] => applies to all stages\n        stageSequences: [], // stageSequences: [] => applies to all stageSequences\n        enabledActions: [],\n        disabledActions: [], // disabledActions: [] => no actions are disabled\n      },\n    ],\n\n    participants: {\n      enforceCategory: true, // validate collectionDefinition.category against event.category\n      enforceGender: true, // disallow placing FEMALEs in MALE events and vice versa\n    },\n\n    processCodes: {\n      substitution: ['RANKING.IGNORE', 'RATING.IGNORE'],\n    },\n\n    substituteAfterCompleted: false,\n    substituteWithoutScore: false,\n  },\n};\n\nexport default POLICY_MATCHUP_ACTIONS_DEFAULT;\n","import { refreshEntryPositions } from './refreshEntryPositions';\nimport { getAppliedPolicies } from '../../query/extensions/getAppliedPolicies';\nimport { addExtension } from '../extensions/addExtension';\nimport { isValidExtension } from '../../validators/isValidExtension';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { isUngrouped } from '../../query/entries/isUngrouped';\nimport { addDrawEntries } from '../drawDefinitions/addDrawEntries';\nimport { removeEventEntries } from './removeEventEntries';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\n\nimport POLICY_MATCHUP_ACTIONS_DEFAULT from '../../fixtures/policies/POLICY_MATCHUP_ACTIONS_DEFAULT';\nimport { POLICY_TYPE_MATCHUP_ACTIONS } from '../../constants/policyConstants';\nimport { DIRECT_ACCEPTANCE } from '../../constants/entryStatusConstants';\nimport { ROUND_TARGET } from '../../constants/extensionConstants';\nimport { DOUBLES, SINGLES } from '../../constants/matchUpTypes';\nimport { MAIN } from '../../constants/drawDefinitionConstants';\nimport { ANY, MIXED } from '../../constants/genderConstants';\nimport { PolicyDefinitions } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  EVENT_NOT_FOUND,\n  INVALID_PARTICIPANT_IDS,\n  INVALID_VALUES,\n  MISSING_EVENT,\n  MISSING_PARTICIPANT_IDS,\n} from '../../constants/errorConditionConstants';\nimport { INDIVIDUAL, PAIR, TEAM } from '../../constants/participantConstants';\nimport {\n  DrawDefinition,\n  EntryStatusUnion,\n  Event,\n  Extension,\n  StageTypeUnion,\n  Tournament,\n} from '../../types/tournamentTypes';\nimport { DOUBLES_EVENT, TEAM_EVENT } from '../../constants/eventConstants';\n\n/**\n * Add entries into an event; optionally add to specified drawDefinition/flightProfile, if possible.\n */\n\ntype AddEventEntriesArgs = {\n  policyDefinitions?: PolicyDefinitions;\n  drawDefinition?: DrawDefinition;\n  entryStatus?: EntryStatusUnion;\n  autoEntryPositions?: boolean;\n  tournamentRecord: Tournament;\n  entryStageSequence?: number;\n  ignoreStageSpace?: boolean;\n  entryStage?: StageTypeUnion;\n  participantIds?: string[];\n  extensions?: Extension[];\n  enforceGender?: boolean;\n  extension?: Extension;\n  roundTarget?: number;\n  drawId?: string;\n  event: Event;\n};\n\nexport function addEventEntries(params: AddEventEntriesArgs): ResultType {\n  const {\n    entryStatus = DIRECT_ACCEPTANCE,\n    autoEntryPositions = true,\n    enforceGender = true,\n    participantIds = [],\n    entryStageSequence,\n    policyDefinitions,\n    entryStage = MAIN,\n    tournamentRecord,\n    ignoreStageSpace,\n    drawDefinition,\n    roundTarget,\n    extensions,\n    extension,\n    drawId,\n    event,\n  } = params;\n\n  const stack = 'addEventEntries';\n\n  if (!event) return { error: MISSING_EVENT };\n  if (!participantIds?.length) {\n    return decorateResult({\n      result: { error: MISSING_PARTICIPANT_IDS },\n      stack,\n    });\n  }\n\n  if (!event?.eventId) return { error: EVENT_NOT_FOUND };\n\n  const appliedPolicies =\n    getAppliedPolicies({ tournamentRecord, event }).appliedPolicies ?? {};\n\n  const matchUpActionsPolicy =\n    policyDefinitions?.[POLICY_TYPE_MATCHUP_ACTIONS] ??\n    appliedPolicies?.[POLICY_TYPE_MATCHUP_ACTIONS] ??\n    POLICY_MATCHUP_ACTIONS_DEFAULT[POLICY_TYPE_MATCHUP_ACTIONS];\n\n  const genderEnforced =\n    (enforceGender ?? matchUpActionsPolicy?.participants?.enforceGender) !==\n    false;\n\n  const addedParticipantIdEntries: string[] = [];\n  const removedEntries: any[] = [];\n\n  if (\n    (extensions &&\n      (!Array.isArray(extensions) ||\n        !extensions.every((extension) => isValidExtension({ extension })))) ||\n    (extension && !isValidExtension({ extension }))\n  ) {\n    return decorateResult({\n      context: definedAttributes({ extension, extensions }),\n      result: { error: INVALID_VALUES },\n      info: 'Invalid extension(s)',\n      stack,\n    });\n  }\n\n  const checkTypedParticipants = !!tournamentRecord;\n  const mismatchedGender: any[] = [];\n  let info;\n\n  const typedParticipantIds =\n    tournamentRecord?.participants\n      ?.filter((participant) => {\n        if (!participantIds.includes(participant.participantId)) return false;\n\n        const validSingles =\n          event.eventType === SINGLES &&\n          participant.participantType === INDIVIDUAL &&\n          !isUngrouped(entryStatus);\n\n        const validDoubles =\n          event.eventType === DOUBLES && participant.participantType === PAIR;\n\n        if (\n          validSingles &&\n          (!event.gender ||\n            !genderEnforced ||\n            [MIXED, ANY].includes(event.gender) ||\n            (event.gender as string) === participant.person?.sex)\n        ) {\n          return true;\n        }\n\n        if (validDoubles && !isUngrouped(entryStatus)) {\n          return true;\n        }\n\n        if (\n          event.eventType === DOUBLES &&\n          participant.participantType === INDIVIDUAL &&\n          isUngrouped(entryStatus)\n        ) {\n          return true;\n        }\n\n        if (\n          validSingles &&\n          event.gender &&\n          genderEnforced &&\n          ![MIXED, ANY].includes(event.gender) &&\n          (event.gender as string) !== participant.person?.sex\n        ) {\n          mismatchedGender.push({\n            participantId: participant.participantId,\n            sex: participant.person?.sex,\n          });\n          return false;\n        }\n\n        return (\n          (event.eventType as string) === TEAM &&\n          (participant.participantType === TEAM ||\n            (isUngrouped(entryStatus) &&\n              participant.participantType === INDIVIDUAL))\n        );\n      })\n      .map((participant) => participant.participantId) ?? [];\n\n  const validParticipantIds = participantIds.filter(\n    (participantId) =>\n      !checkTypedParticipants || typedParticipantIds.includes(participantId)\n  );\n\n  if (!event.entries) event.entries = [];\n  const existingIds = event.entries.map(\n    (e: any) => e.participantId || e.participant?.participantId\n  );\n\n  validParticipantIds.forEach((participantId) => {\n    if (!existingIds.includes(participantId)) {\n      const entry = definedAttributes({\n        participantId,\n        entryStatus,\n        entryStage,\n        extensions,\n      });\n\n      if (extension) {\n        addExtension({ element: entry, extension });\n      }\n\n      if (roundTarget) {\n        addExtension({\n          extension: { name: ROUND_TARGET, value: roundTarget },\n          element: entry,\n        });\n      }\n      if (entryStageSequence) entry.entryStageSequence = entryStageSequence;\n      addedParticipantIdEntries.push(entry.participantId);\n      event.entries?.push(entry);\n    }\n  });\n\n  if (drawId && !isUngrouped(entryStage)) {\n    const result = addDrawEntries({\n      participantIds: validParticipantIds,\n      autoEntryPositions,\n      entryStageSequence,\n      ignoreStageSpace,\n      drawDefinition,\n      entryStatus,\n      roundTarget,\n      entryStage,\n      extension,\n      drawId,\n      event,\n    });\n\n    // Ignore error if drawId is included but entry can't be added to drawDefinition/flightProfile\n    // return error as info to client\n    if (result.error) {\n      info = result.error;\n    }\n  }\n\n  // now remove any ungrouped participantIds which exist as part of added grouped participants\n  if (\n    event.eventType &&\n    [DOUBLES_EVENT, TEAM_EVENT].includes(event.eventType)\n  ) {\n    const enteredParticipantIds = (event.entries || []).map(\n      (entry) => entry.participantId\n    );\n    const ungroupedIndividualParticipantIds = (event.entries || [])\n      .filter((entry) => isUngrouped(entry.entryStatus))\n      .map((entry) => entry.participantId);\n    const tournamentParticipants = tournamentRecord?.participants ?? [];\n    const groupedIndividualParticipantIds = tournamentParticipants\n      .filter(\n        (participant) =>\n          enteredParticipantIds.includes(participant.participantId) &&\n          participant.participantType &&\n          [PAIR, TEAM].includes(participant.participantType)\n      )\n      .map((participant) => participant.individualParticipantIds)\n      .flat(Infinity);\n    const ungroupedParticipantIdsToRemove =\n      ungroupedIndividualParticipantIds.filter((participantId) =>\n        groupedIndividualParticipantIds.includes(participantId)\n      );\n    if (ungroupedParticipantIdsToRemove.length) {\n      removedEntries.push(...ungroupedParticipantIdsToRemove);\n      removeEventEntries({\n        participantIds: ungroupedParticipantIdsToRemove,\n        autoEntryPositions: false, // because the method will be called below if necessary\n        event,\n      });\n    }\n  }\n\n  const invalidParticipantIds =\n    validParticipantIds.length !== participantIds.length;\n\n  if (invalidParticipantIds)\n    return decorateResult({\n      context: { mismatchedGender, gender: event.gender },\n      result: { error: INVALID_PARTICIPANT_IDS },\n      stack,\n    });\n\n  if (autoEntryPositions) {\n    event.entries = refreshEntryPositions({\n      entries: event.entries || [],\n    });\n  }\n\n  const addedEntriesCount =\n    addedParticipantIdEntries.length - removedEntries.length;\n\n  return decorateResult({\n    result: { ...SUCCESS, addedEntriesCount },\n    stack,\n    info,\n  });\n}\n","export const ADMINISTRATION: any = 'ADMINISTRATION';\nexport const CAPTAIN: any = 'CAPTAIN';\nexport const COACH: any = 'COACH';\nexport const COMPETITOR: any = 'COMPETITOR';\nexport const MEDIA: any = 'MEDIA';\nexport const MEDICAL: any = 'MEDICAL';\nexport const OFFICIAL: any = 'OFFICIAL';\nexport const OTHER: any = 'OTHER';\nexport const SECURITY: any = 'SECURITY';\n\nexport const participantRoles = {\n  ADMINISTRATION,\n  CAPTAIN,\n  COACH,\n  COMPETITOR,\n  MEDIA,\n  MEDICAL,\n  OFFICIAL,\n  OTHER,\n  SECURITY,\n};\n","import { checkScoreHasValue } from '../../query/matchUp/checkScoreHasValue';\nimport { addExtension } from '../extensions/addExtension';\nimport { getParticipants } from '../../query/participants/getParticipants';\nimport { addEventEntries } from '../entries/addEventEntries';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { findExtension } from '../../acquire/findExtension';\nimport { allDrawMatchUps } from '../../query/matchUps/getAllDrawMatchUps';\nimport { addNotice } from '../../global/state/globalState';\nimport {\n  addDrawNotice,\n  modifyMatchUpNotice,\n} from '../notifications/drawNotifications';\n\nimport { MappedMatchUps } from '../../query/matchUps/getMatchUpsMap';\nimport { MODIFY_PARTICIPANTS } from '../../constants/topicConstants';\nimport { UNGROUPED } from '../../constants/entryStatusConstants';\nimport { COMPETITOR } from '../../constants/participantRoles';\nimport { LINEUPS } from '../../constants/extensionConstants';\nimport { HydratedParticipant } from '../../types/hydrated';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  CANNOT_REMOVE_PARTICIPANTS,\n  ErrorType,\n  INVALID_PARTICIPANT_TYPE,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n  NO_PARTICIPANT_REMOVED,\n  PARTICIPANT_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\nimport {\n  GROUP,\n  TEAM,\n  TEAM_PARTICIPANT,\n} from '../../constants/participantConstants';\nimport {\n  Participant,\n  ParticipantRoleUnion,\n  Tournament,\n} from '../../types/tournamentTypes';\n\ntype RemoveIndividualParticipantIdsArgs = {\n  addIndividualParticipantsToEvents?: boolean;\n  individualParticipantIds: string[];\n  groupingParticipantId: string;\n  tournamentRecord: Tournament;\n  suppressErrors?: boolean;\n};\nexport function removeIndividualParticipantIds({\n  addIndividualParticipantsToEvents,\n  individualParticipantIds,\n  groupingParticipantId,\n  tournamentRecord,\n  suppressErrors,\n}: RemoveIndividualParticipantIdsArgs) {\n  const stack = 'removeIndividualParticipantIds';\n  if (!tournamentRecord)\n    return decorateResult({\n      result: { error: MISSING_TOURNAMENT_RECORD },\n      stack,\n    });\n  if (!groupingParticipantId || !individualParticipantIds)\n    return decorateResult({ result: { error: MISSING_VALUE }, stack });\n\n  const tournamentParticipants = tournamentRecord.participants ?? [];\n\n  const groupingParticipant: any = tournamentParticipants.find(\n    (participant) => {\n      return participant.participantId === groupingParticipantId;\n    }\n  );\n  if (!groupingParticipant)\n    return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack });\n\n  if (![TEAM, GROUP].includes(groupingParticipant.participantType)) {\n    return decorateResult({\n      result: {\n        participantType: groupingParticipant.participantType,\n        error: INVALID_PARTICIPANT_TYPE,\n      },\n      stack,\n    });\n  }\n\n  const result = removeParticipantIdsFromGroupingParticipant({\n    individualParticipantIds,\n    groupingParticipant,\n    tournamentRecord,\n    suppressErrors,\n  });\n  const { removed, error } = result;\n\n  if (error) return decorateResult({ result, stack });\n\n  if (addIndividualParticipantsToEvents) {\n    for (const event of tournamentRecord.events ?? []) {\n      const enteredIds = (event.entries ?? [])\n        .map(({ participantId }) => participantId)\n        .filter(Boolean);\n\n      if (enteredIds.includes(groupingParticipantId)) {\n        const participantIdsToEnter = removed?.filter(\n          (participantId) => !enteredIds.includes(participantId)\n        );\n        addEventEntries({\n          participantIds: participantIdsToEnter,\n          entryStatus: UNGROUPED,\n          tournamentRecord,\n          event,\n        });\n      }\n    }\n  }\n\n  if (removed) {\n    addNotice({\n      topic: MODIFY_PARTICIPANTS,\n      payload: {\n        tournamentId: tournamentRecord.tournamentId,\n        participants: [groupingParticipant],\n      },\n    });\n  }\n\n  return { ...SUCCESS, ...result };\n}\n\ntype RemoveFromGroupingParticipantArgs = {\n  participants?: HydratedParticipant[];\n  individualParticipantIds?: string[];\n  groupingParticipant: Participant;\n  mappedMatchUps?: MappedMatchUps;\n  tournamentRecord: Tournament;\n  suppressErrors?: boolean;\n};\nfunction removeParticipantIdsFromGroupingParticipant({\n  individualParticipantIds = [],\n  groupingParticipant,\n  tournamentRecord,\n  suppressErrors,\n  mappedMatchUps,\n  participants,\n}: RemoveFromGroupingParticipantArgs): {\n  groupingParticipantId?: string;\n  cannotRemove?: string[];\n  notRemoved?: string[];\n  removed?: string[];\n  error?: ErrorType;\n} {\n  const removed: string[] = [];\n  if (!groupingParticipant) return { removed };\n  const notRemoved: string[] = [];\n  const cannotRemove: string[] = [];\n\n  if (!participants) {\n    ({ participants, mappedMatchUps } = getParticipants({\n      withMatchUps: true,\n      tournamentRecord,\n      withEvents: true,\n    }));\n  }\n\n  const inContextGroupingParticipant: any = participants?.find(\n    ({ participantId }) => participantId === groupingParticipant.participantId\n  );\n\n  const groupingParticipantEventIds = inContextGroupingParticipant?.events?.map(\n    ({ eventId }) => eventId\n  );\n\n  const updatedIndividualParticipantIds = (\n    groupingParticipant.individualParticipantIds ?? []\n  ).filter((participantId) => {\n    const targetParticipant = individualParticipantIds?.includes(participantId);\n    const scoredParticipantGroupingMatchUps =\n      targetParticipant &&\n      participants\n        ?.find((participant) => participant.participantId === participantId)\n        ?.matchUps.filter(({ eventId }) =>\n          groupingParticipantEventIds.includes(eventId)\n        )\n        .map(({ matchUpId }) => mappedMatchUps?.[matchUpId])\n        .filter(\n          ({ winningSide, score }) =>\n            winningSide || checkScoreHasValue({ score })\n        );\n\n    const removeParticipant =\n      targetParticipant && !scoredParticipantGroupingMatchUps?.length;\n\n    if (targetParticipant && !removeParticipant) {\n      cannotRemove.push(participantId);\n    }\n\n    if (removeParticipant) {\n      removed.push(participantId);\n\n      for (const event of tournamentRecord.events ?? []) {\n        for (const drawDefinition of event.drawDefinitions ?? []) {\n          const { extension } = findExtension({\n            element: drawDefinition,\n            name: LINEUPS,\n          });\n          const lineUp = extension?.value[groupingParticipant.participantId];\n          if (extension && lineUp) {\n            extension.value[groupingParticipant.participantId] = lineUp.filter(\n              (assignment) => assignment.participantId !== participantId\n            );\n            addExtension({ element: drawDefinition, extension });\n            addDrawNotice({ drawDefinition });\n          }\n\n          const matchUps =\n            allDrawMatchUps({ drawDefinition, inContext: false }).matchUps ??\n            [];\n\n          for (const matchUp of matchUps) {\n            const sides = matchUp.sides ?? [];\n            for (const side of sides) {\n              const lineUp = side.lineUp ?? [];\n              const containsParticipant = lineUp.find(\n                (assignment) => assignment.participantId === participantId\n              );\n              if (containsParticipant) {\n                side.lineUp = lineUp.filter(\n                  (assignment) => assignment.participantId !== participantId\n                );\n                modifyMatchUpNotice({\n                  tournamentId: tournamentRecord?.tournamentId,\n                  drawDefinition,\n                  matchUp,\n                });\n              }\n            }\n          }\n        }\n      }\n    } else {\n      notRemoved.push(participantId);\n    }\n    return !removeParticipant;\n  });\n\n  groupingParticipant.individualParticipantIds =\n    updatedIndividualParticipantIds;\n\n  const result = {\n    groupingParticipantId: groupingParticipant.participantId,\n    cannotRemove,\n    notRemoved,\n    removed,\n  };\n\n  return (\n    (cannotRemove.length &&\n      !suppressErrors && {\n        ...result,\n        cannotRemove,\n        error: CANNOT_REMOVE_PARTICIPANTS,\n      }) ||\n    result\n  );\n}\n\ntype RemoveParticipantIdsFromAllTeamsArgs = {\n  participantRole?: ParticipantRoleUnion;\n  individualParticipantIds?: string[];\n  tournamentRecord: Tournament;\n  groupingTypes?: string[];\n};\nexport function removeParticipantIdsFromAllTeams({\n  participantRole = COMPETITOR,\n  individualParticipantIds = [],\n  groupingTypes = [TEAM_PARTICIPANT, GROUP],\n  tournamentRecord,\n}: RemoveParticipantIdsFromAllTeamsArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  const tournamentParticipants = tournamentRecord.participants ?? [];\n\n  const { participants, mappedMatchUps } = getParticipants({\n    withMatchUps: true,\n    tournamentRecord,\n    withEvents: true,\n  });\n\n  let modifications = 0;\n  tournamentParticipants\n    .filter((participant) => {\n      return (\n        (participant.participantRole === participantRole ||\n          !participant.participantRole) &&\n        participant.participantType &&\n        groupingTypes.includes(participant.participantType)\n      );\n    })\n    .forEach((grouping) => {\n      const { removed } = removeParticipantIdsFromGroupingParticipant({\n        groupingParticipant: grouping,\n        individualParticipantIds,\n        tournamentRecord,\n        mappedMatchUps,\n        participants,\n      });\n      if (removed) modifications++;\n    });\n\n  return modifications ? SUCCESS : { error: NO_PARTICIPANT_REMOVED };\n}\n","import { allTournamentMatchUps } from '../../query/matchUps/getAllTournamentMatchUps';\nimport { removeParticipantIdsFromAllTeams } from './removeIndividualParticipantIds';\nimport { getParticipants } from '../../query/participants/getParticipants';\nimport { removeEventEntries } from '../entries/removeEventEntries';\nimport { addEventEntries } from '../entries/addEventEntries';\nimport { addNotice } from '../../global/state/globalState';\nimport { intersection } from '../../utilities/arrays';\n\nimport { DELETE_PARTICIPANTS } from '../../constants/topicConstants';\nimport { UNGROUPED } from '../../constants/entryStatusConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { DOUBLES } from '../../constants/matchUpTypes';\nimport { TEAM } from '../../constants/eventConstants';\nimport {\n  CANNOT_REMOVE_PARTICIPANTS,\n  MISSING_PARTICIPANT_IDS,\n  MISSING_TOURNAMENT_RECORD,\n  EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT,\n  ErrorType,\n} from '../../constants/errorConditionConstants';\nimport {\n  PAIR,\n  TEAM as participantTeam,\n} from '../../constants/participantConstants';\n\n/**\n *\n * @param {boolean=} addIndividualParticipantsToEvents\n * @param {object} tournamentRecord\n * @param {string[]} participantIds\n * @returns {object}\n */\n\nexport function deleteParticipants(params): {\n  participantsRemovedCount?: number;\n  success?: boolean;\n  error?: ErrorType;\n} {\n  if (!params?.tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!params?.participantIds?.length)\n    return { error: MISSING_PARTICIPANT_IDS };\n  const {\n    addIndividualParticipantsToEvents,\n    tournamentRecord,\n    participantIds,\n  } = params;\n\n  const participantsCount = tournamentRecord.participants?.length || 0;\n  if (!participantsCount) return { ...SUCCESS };\n\n  const teamDrawIds = (tournamentRecord.events || [])\n    ?.filter(({ eventType }) => eventType === TEAM)\n    .map((event) => event?.drawDefinitions?.map(({ drawId }) => drawId))\n    .flat(Infinity);\n\n  // cannot use getParticipants() because event objects don't have drawIds array\n  const tournamentParticipants =\n    getParticipants({\n      participantFilters: { participantIds },\n      tournamentRecord,\n      withDraws: true,\n    }).participants ?? [];\n\n  const getPlacedPairParticipantIds = () => {\n    const matchUps =\n      allTournamentMatchUps({\n        matchUpFilters: { drawIds: teamDrawIds, matchUpTypes: [DOUBLES] },\n        tournamentRecord,\n      }).matchUps ?? [];\n\n    const placedPairParticipantIds = matchUps\n      .map(({ sides }) => sides?.map(({ participantId }) => participantId))\n      .flat()\n      .filter(Boolean);\n\n    return intersection(placedPairParticipantIds, participantIds);\n  };\n\n  // for team draws it is necessary to check matchUps for pair participantIds \"discovered\" in collectionAssignments\n  const placedPairParticipantIds =\n    teamDrawIds?.length && getPlacedPairParticipantIds();\n\n  const participantsInDraws = tournamentParticipants.filter(\n    (participant) =>\n      participant.draws?.filter(\n        (drawInfo) =>\n          (!teamDrawIds?.length || !teamDrawIds?.includes(drawInfo.drawId)) &&\n          drawInfo.positionAssignments\n      ).length\n  );\n\n  if (placedPairParticipantIds?.length || participantsInDraws.length) {\n    return { error: EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT };\n  }\n\n  const eventParticipantIdsRemoved = {};\n  const mappedIndividualParticipantIdsToAdd = {};\n\n  // If not active in draws, remove participantIds from all entries\n  for (const event of tournamentRecord.events || []) {\n    const result = removeEventEntries({\n      participantIds,\n      event,\n    });\n    if (result.error) return result;\n    eventParticipantIdsRemoved[event.eventId] = result.participantIdsRemoved;\n  }\n\n  tournamentRecord.participants = tournamentRecord.participants.filter(\n    (participant) => {\n      const participantToRemove =\n        participantIds.includes(participant.participantId) ||\n        (participant.participantType === PAIR &&\n          participant.individualParticipantIds.some((id) =>\n            participantIds.includes(id)\n          ));\n\n      // remove deleted individualParticipantIds from TEAMs\n      if (\n        !participantToRemove &&\n        participant.participantType === TEAM &&\n        participant.individualParticipantIds.some((id) =>\n          participantIds.includes(id)\n        )\n      ) {\n        participant.individualParticipantIds =\n          participant.individualParticipantIds.filter(\n            (id) => !participantIds.includes(id)\n          );\n      }\n\n      if (\n        participantToRemove &&\n        addIndividualParticipantsToEvents &&\n        [PAIR, participantTeam].includes(participant.participantType)\n      ) {\n        for (const individualParticipantId of participant.individualParticipantIds ||\n          []) {\n          if (!participantIds.includes(individualParticipantId)) {\n            if (!mappedIndividualParticipantIdsToAdd[participant.participantId])\n              mappedIndividualParticipantIdsToAdd[participant.participantId] =\n                [];\n            mappedIndividualParticipantIdsToAdd[participant.participantId].push(\n              individualParticipantId\n            );\n          }\n        }\n      }\n      return !participantToRemove;\n    }\n  );\n\n  const participantsRemovedCount =\n    participantsCount - tournamentRecord.participants.length;\n\n  removeParticipantIdsFromAllTeams({\n    individualParticipantIds: participantIds,\n    tournamentRecord,\n  });\n\n  if (addIndividualParticipantsToEvents) {\n    for (const event of tournamentRecord.events || []) {\n      const groupParticipantIds = eventParticipantIdsRemoved[event.eventId];\n      const individualParticipantIds = groupParticipantIds\n        .map(\n          (participantId) =>\n            mappedIndividualParticipantIdsToAdd[participantId] || []\n        )\n        .flat();\n      addEventEntries({\n        participantIds: individualParticipantIds,\n        entryStatus: UNGROUPED,\n        tournamentRecord,\n        event,\n      });\n    }\n  }\n\n  if (participantsRemovedCount) {\n    addNotice({\n      payload: { participantIds, tournamentId: tournamentRecord.tournamentId },\n      topic: DELETE_PARTICIPANTS,\n    });\n  }\n\n  return participantsRemovedCount\n    ? { ...SUCCESS, participantsRemovedCount }\n    : { error: CANNOT_REMOVE_PARTICIPANTS };\n}\n","import { getFlightProfile } from '../event/getFlightProfile';\n\nimport { STRUCTURE_SELECTED_STATUSES } from '../../constants/entryStatusConstants';\nimport {\n  DrawDefinition,\n  Entry,\n  EntryStatusUnion,\n  Event,\n} from '../../types/tournamentTypes';\n\ntype GetStageEntriesArgs = {\n  entryStatuses?: EntryStatusUnion[];\n  drawDefinition: DrawDefinition;\n  selected?: boolean;\n  drawId?: string;\n  stage?: string;\n  event: Event;\n};\nexport function getStageEntries({\n  selected = true,\n  drawDefinition,\n  entryStatuses,\n  drawId,\n  event,\n  stage,\n}: GetStageEntriesArgs) {\n  let entries: Entry[] = event.entries ?? [];\n\n  if (drawId) {\n    const { flightProfile } = getFlightProfile({ event });\n    const flight = flightProfile?.flights?.find(\n      (flight) => flight.drawId === drawId\n    );\n    if (flight) {\n      entries = flight.drawEntries;\n    } else if (drawDefinition.entries) {\n      entries = drawDefinition?.entries;\n    }\n  }\n\n  const stageEntries = entries.filter(\n    (entry) =>\n      (!entryStatuses?.length ||\n        !entry.entryStatus ||\n        entryStatuses.includes(entry.entryStatus)) &&\n      (!stage || !entry.entryStage || entry.entryStage === stage) &&\n      (!selected ||\n        (entry.entryStatus &&\n          STRUCTURE_SELECTED_STATUSES.includes(entry.entryStatus)))\n  );\n  return { entries, stageEntries };\n}\n","import { deleteParticipants } from '../participants/deleteParticipants';\nimport { getStageEntries } from '../../query/drawDefinition/getStageEntries';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { getParticipantId } from '../../global/functions/extractors';\nimport { arrayIndices } from '../../utilities/arrays';\nimport { removeEventEntries } from './removeEventEntries';\nimport { addEventEntries } from './addEventEntries';\n\nimport { UNGROUPED } from '../../constants/entryStatusConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { PAIR, TEAM_PARTICIPANT } from '../../constants/participantConstants';\nimport {\n  ErrorType,\n  INVALID_EVENT_TYPE,\n  INVALID_PARTICIPANT_TYPE,\n  MISSING_EVENT,\n  MISSING_PARTICIPANT_ID,\n  MISSING_TOURNAMENT_RECORD,\n  PARTICIPANT_ENTRY_NOT_FOUND,\n  PARTICIPANT_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\nimport { DOUBLES_EVENT, TEAM_EVENT } from '../../constants/eventConstants';\nimport { DrawDefinition, Tournament, Event } from '../../types/tournamentTypes';\n\n/**\n * When grouped participant entries are destroyed, individualParticipantIds will be added as { individualEntryStatus } participant entries\n *\n * @param {object} tournamentRecord - passed in by tournamentEngine\n * @param {string} participantId - id of TEAM/PAIR participant to remove\n * @param {string} eventId - resolved to { event } by tournamentEngine\n * @param {string} drawId - optional - resolved to { drawDefinition }\n * @param {boolean} removeGroupParticipant - whether to also remove grouping participant from tournamentRecord.participants\n *\n */\n\ntype DestroyGroupEntryArgs = {\n  removeGroupParticipant?: boolean;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  participantId: string;\n  drawId?: string;\n  stage?: string;\n  event: Event;\n};\n\nexport function destroyGroupEntry({\n  removeGroupParticipant,\n  tournamentRecord,\n  drawDefinition,\n  participantId,\n  drawId,\n  stage,\n  event,\n}: DestroyGroupEntryArgs): {\n  success?: boolean;\n  error?: ErrorType;\n  participantRemoved?: boolean;\n} {\n  const stack = 'destroyGroupEntry';\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!participantId)\n    return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack });\n  if (!event) return { error: MISSING_EVENT };\n\n  if (\n    !event.eventType ||\n    ![DOUBLES_EVENT, TEAM_EVENT].includes(event.eventType)\n  ) {\n    return decorateResult({ result: { error: INVALID_EVENT_TYPE }, stack });\n  }\n\n  const tournamentParticipants = tournamentRecord.participants ?? [];\n  const participant = tournamentParticipants.find(\n    (participant) => participant.participantId === participantId\n  );\n\n  if (!participant) {\n    return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack });\n  }\n\n  if (\n    !participant.participantType ||\n    ![PAIR, TEAM_PARTICIPANT].includes(participant.participantType) ||\n    (participant.participantType === TEAM_PARTICIPANT &&\n      event.eventType !== TEAM_EVENT) ||\n    (participant.participantType === PAIR && event.eventType !== DOUBLES_EVENT)\n  ) {\n    return { error: INVALID_PARTICIPANT_TYPE };\n  }\n\n  const eventEntries = event.entries ?? [];\n  const entry = eventEntries.find(\n    (entry) => entry.participantId === participantId\n  );\n  if (!entry) return { error: PARTICIPANT_ENTRY_NOT_FOUND };\n\n  const { stageEntries } = getStageEntries({\n    selected: false,\n    drawDefinition,\n    drawId,\n    event,\n    stage,\n  });\n  const groupedParticipantIds = stageEntries.map(getParticipantId);\n  const individualParticipantIdsInGroups = tournamentParticipants\n    .filter(({ participantId }) =>\n      groupedParticipantIds.includes(participantId)\n    )\n    .map(({ individualParticipantIds }) => individualParticipantIds)\n    .flat()\n    .filter(Boolean);\n\n  // find only those individualParticipantIds which do not occur MULTIPLE TIMES in PAIRs/GROUPs in the event.entries or drawEntries\n  // this scenario can occur in e.g. ITA tournaments where an individual participant is paired multiple times across flights\n  const individualParticipantIds = participant.individualParticipantIds?.filter(\n    (participantId) =>\n      arrayIndices(participantId, individualParticipantIdsInGroups).length === 1\n  );\n\n  // remove the group participant from event entries\n  let result = removeEventEntries({\n    participantIds: [participantId],\n    event,\n  });\n  if (result.error) return result;\n\n  if (individualParticipantIds?.length) {\n    result = addEventEntries({\n      participantIds: individualParticipantIds,\n      entryStatus: UNGROUPED,\n      entryStage: entry.entryStage,\n      tournamentRecord,\n      drawDefinition,\n      drawId,\n      event,\n    });\n    if (result.error) return result;\n  }\n\n  let participantRemoved;\n  if (removeGroupParticipant) {\n    const result = deleteParticipants({\n      participantIds: [participantId],\n      tournamentRecord,\n    });\n    if (result.success) participantRemoved = true;\n  }\n\n  return { ...SUCCESS, participantRemoved };\n}\n","import { destroyGroupEntry } from './destroyGroupEntry';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { DrawDefinition, Tournament, Event } from '../../types/tournamentTypes';\n\n/**\n *\n * @param {object} tournamentRecord - passed in by tournamentEngine\n * @param {string} participantId - id of TEAM/PAIR participant to remove\n * @param {string} eventId - resolved to { event } by tournamentEngine\n * @param {string} drawId - optional - resolved to { drawDefinition }\n * @param {boolean} removeGroupParticipant - whether to also remove grouping participant from tournamentRecord.participants\n *\n */\n\ntype DestroyPairEntryArgs = {\n  removeGroupParticipant?: boolean;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  participantId: string;\n  drawId?: string;\n  event: Event;\n};\nexport function destroyPairEntry({\n  removeGroupParticipant,\n  tournamentRecord,\n  drawDefinition,\n  participantId,\n  drawId,\n  event,\n}: DestroyPairEntryArgs) {\n  return destroyGroupEntry({\n    removeGroupParticipant,\n    tournamentRecord,\n    drawDefinition,\n    participantId,\n    drawId,\n    event,\n  });\n}\n\nexport function destroyPairEntries(params) {\n  if (!params.tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const { participantIds, ...rest } = params;\n\n  let destroyedCount = 0;\n  const errors: any[] = [];\n\n  for (const participantId of participantIds) {\n    const result = destroyGroupEntry({ participantId, ...rest });\n    if (result.success) destroyedCount += 1;\n    if (result.error) errors.push(result.error);\n  }\n\n  return destroyedCount ? { destroyedCount, ...SUCCESS } : { error: errors };\n}\n","import { conditionallyDisableLinkPositioning } from './positionGovernor/conditionallyDisableLinkPositioning';\nimport { addPositionActionTelemetry } from './positionGovernor/addPositionActionTelemetry';\nimport { assignDrawPositionBye } from '../matchUps/drawPositions/assignDrawPositionBye';\nimport { clearDrawPosition } from '../matchUps/drawPositions/positionClear';\nimport { findTournamentParticipant } from '../../acquire/findTournamentParticipant';\nimport { findStructure } from '../../acquire/findStructure';\nimport { modifyEntriesStatus } from '../entries/modifyEntriesStatus';\nimport { destroyPairEntry } from '../entries/destroyPairEntry';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\n\nimport { ALTERNATE, WITHDRAWN } from '../../constants/entryStatusConstants';\nimport { PAIR } from '../../constants/participantConstants';\n\nexport function removeDrawPositionAssignment(\n  params\n): ResultType & { participantId?: string } {\n  const {\n    tournamentRecord,\n    replaceWithBye,\n    drawDefinition,\n    destroyPair,\n    entryStatus,\n    matchUpsMap,\n    drawId,\n  } = params;\n\n  const stack = 'removeDrawPositionAssignment';\n\n  const result = clearDrawPosition(params);\n  if (result.error) return decorateResult({ result, stack });\n\n  const { participantId } = result;\n  const { drawPosition, event, structureId } = params;\n\n  if ([ALTERNATE, WITHDRAWN].includes(entryStatus) && participantId) {\n    const { tournamentRecord } = params;\n    const { participant } = findTournamentParticipant({\n      tournamentRecord,\n      participantId,\n    });\n    const { participantType, individualParticipantIds } = participant ?? {};\n\n    if (destroyPair && participantType === PAIR) {\n      const result = destroyPairEntry({\n        tournamentRecord,\n        drawDefinition,\n        participantId,\n        event,\n      });\n      if (result.error) return decorateResult({ result, stack });\n      if (individualParticipantIds)\n        modifyEntriesStatus({\n          participantIds: individualParticipantIds,\n          tournamentRecord,\n          drawDefinition,\n          entryStatus,\n          drawId,\n          event,\n        });\n    } else {\n      modifyEntriesStatus({\n        participantIds: [participantId],\n        tournamentRecord,\n        drawDefinition,\n        entryStatus,\n        drawId,\n        event,\n      });\n    }\n  }\n\n  if (replaceWithBye) {\n    const result = assignDrawPositionBye({\n      tournamentRecord,\n      drawDefinition,\n      drawPosition,\n      structureId,\n      matchUpsMap,\n      event,\n    });\n    if (result.error) return decorateResult({ result, stack });\n  }\n\n  const { structure } = findStructure({ drawDefinition, structureId });\n  conditionallyDisableLinkPositioning({\n    structure,\n    drawPositions: [drawPosition],\n  });\n  const positionAction = {\n    name: 'removeDrawPositionAssignment',\n    replaceWithBye,\n    drawPosition,\n    entryStatus,\n    structureId,\n  };\n  addPositionActionTelemetry({ drawDefinition, positionAction });\n\n  return result;\n}\n","import { isString } from './objects';\n\nexport function capitalizeFirst(str) {\n  return !isString(str)\n    ? str\n    : str\n        .split(' ')\n        .map((name) =>\n          name\n            .split('')\n            .map((c, i) => (i ? c.toLowerCase() : c.toUpperCase()))\n            .join('')\n        )\n        .join(' ');\n}\n\nexport function constantToString(str) {\n  return !isString(str) ? str : capitalizeFirst(str.replace(/_/g, ' '));\n}\n","import { unique } from '../../../utilities/arrays';\nimport { UUID } from '../../../utilities/UUID';\n\nimport { ROUND_OUTCOME } from '../../../constants/drawDefinitionConstants';\nimport { SeedingProfile } from '../../../types/factoryTypes';\nimport {\n  MatchUp,\n  SeedAssignment,\n  Structure,\n} from '../../../types/tournamentTypes';\n\ntype StructureTemplateArgs = {\n  seedAssignments?: SeedAssignment[];\n  qualifyingRoundNumber?: number;\n  structureAbbreviation?: string;\n  seedingProfile?: SeedingProfile;\n  finishingPosition?: string;\n  structures?: Structure[];\n  structureOrder?: number;\n  matchUpFormat?: string;\n  stageSequence?: number;\n  structureName?: string;\n  structureType?: string;\n  matchUpType?: string;\n  matchUps?: MatchUp[];\n  roundOffset?: number;\n  structureId?: string;\n  roundLimit?: number;\n  stageOrder?: number;\n  stage?: string;\n};\n\nexport const structureTemplate = ({\n  finishingPosition = ROUND_OUTCOME,\n  qualifyingRoundNumber,\n  structureAbbreviation,\n  seedAssignments = [],\n  stageSequence = 1,\n  structureOrder,\n  seedingProfile,\n  matchUpFormat,\n  structureType,\n  structureName,\n  matchUpType,\n  matchUps = [],\n  structureId,\n  roundOffset,\n  roundLimit,\n  stageOrder,\n  structures,\n  stage,\n}: StructureTemplateArgs) => {\n  const structure: any = {\n    structureId: structureId ?? UUID(),\n    structureAbbreviation,\n    finishingPosition,\n    seedAssignments,\n    matchUpFormat,\n    stageSequence,\n    structureName,\n  };\n\n  if (structureOrder) structure.structureOrder = structureOrder;\n  if (structureType) structure.structureType = structureType;\n  if (seedingProfile) {\n    if (typeof seedingProfile === 'string') {\n      structure.seedingProfile = seedingProfile;\n    } else if (\n      typeof seedingProfile === 'object' &&\n      typeof seedingProfile.positioning === 'string'\n    ) {\n      structure.seedingProfile = seedingProfile.positioning;\n    }\n  }\n  if (matchUpType) structure.matchUpType = matchUpType;\n  if (roundOffset) structure.roundOffset = roundOffset;\n  if (stageOrder) structure.stageOrder = stageOrder;\n  if (roundLimit) structure.roundLimit = roundLimit;\n  if (stage) structure.stage = stage;\n\n  if (qualifyingRoundNumber)\n    structure.qualifyingRoundNumber = qualifyingRoundNumber;\n\n  const drawPositions = matchUps\n    .flatMap(({ drawPositions }) => drawPositions)\n    .filter(Boolean);\n\n  if (structures) {\n    structure.structures = structures;\n  } else {\n    structure.matchUps = matchUps;\n    structure.positionAssignments = unique(drawPositions)\n      .sort((a, b) => a - b)\n      .map((drawPosition) => ({ drawPosition }));\n  }\n\n  return structure;\n};\n\nexport default structureTemplate;\n","import { modifyDrawNotice } from '../notifications/drawNotifications';\nimport { constantToString } from '../../utilities/strings';\nimport structureTemplate from '../../assemblies/generators/templates/structureTemplate';\n\nimport { MISSING_DRAW_DEFINITION } from '../../constants/errorConditionConstants';\nimport { VOLUNTARY_CONSOLATION } from '../../constants/drawDefinitionConstants';\nimport { DrawDefinition } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\n\ntype AddVoluntaryConsolationStructureArgs = {\n  structureAbbreviation?: string;\n  drawDefinition: DrawDefinition;\n  structureName?: string;\n  matchUpType?: string;\n  structureId?: string;\n};\n\nexport function addVoluntaryConsolationStructure({\n  structureName = constantToString(VOLUNTARY_CONSOLATION),\n  structureAbbreviation,\n  drawDefinition,\n  matchUpType,\n  structureId,\n}: AddVoluntaryConsolationStructureArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const structure = structureTemplate({\n    stage: VOLUNTARY_CONSOLATION,\n    structureAbbreviation,\n    structureName,\n    matchUps: [],\n    structureId,\n    matchUpType,\n  });\n\n  if (!drawDefinition.structures) drawDefinition.structures = [];\n  drawDefinition.structures.push(structure);\n\n  modifyDrawNotice({ drawDefinition, structureIds: [structure.structureId] });\n\n  return { ...SUCCESS };\n}\n","import { getPositionAssignments as positionAssignments } from '../drawDefinition/positionsGetter';\n\nimport { MAIN } from '../../constants/drawDefinitionConstants';\nimport {\n  MISSING_DRAW_DEFINITION,\n  MISSING_STRUCTURE_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Structure,\n  Tournament,\n} from '../../types/tournamentTypes';\n\ntype GetPositionAssignmentsArgs = {\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  structure?: Structure;\n  structureId?: string;\n  stage?: string;\n};\nexport function getPositionAssignments({\n  tournamentRecord,\n  drawDefinition,\n  stage = MAIN,\n  structureId,\n  structure,\n}: GetPositionAssignmentsArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!structure && !drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (\n    !structure &&\n    !structureId &&\n    drawDefinition?.structures?.filter((structure) => structure.stage === stage)\n      .length === 1\n  ) {\n    structure = drawDefinition.structures.find(\n      (structure) => structure.stage === stage\n    );\n  }\n  if (!structure && !structureId) return { error: MISSING_STRUCTURE_ID };\n\n  const { error, positionAssignments: assignments } = positionAssignments({\n    drawDefinition,\n    structureId,\n    structure,\n  });\n  return {\n    positionAssignments: assignments ?? [],\n    structureId: structure?.structureId,\n    error,\n  };\n}\n","import { extractDate } from '../../../utilities/dateTime';\n\nexport function getUpdatedSchedulingProfile({\n  schedulingProfile,\n  venueIds,\n  eventIds,\n  drawIds,\n}) {\n  const issues: string[] = [];\n  const updatedSchedulingProfile = schedulingProfile\n    ?.map((dateSchedulingProfile) => {\n      const date = extractDate(dateSchedulingProfile?.scheduleDate);\n      if (!date) {\n        issues.push(`Invalid date: ${dateSchedulingProfile?.scheduledDate}`);\n        return;\n      }\n\n      const venues = (dateSchedulingProfile?.venues || [])\n        .map((venue) => {\n          const { rounds, venueId } = venue;\n          const venueExists = venueIds?.includes(venueId);\n          if (!venueExists) {\n            issues.push(`Missing venueId: ${venueId}`);\n            return;\n          }\n\n          const filteredRounds = rounds.filter((round) => {\n            const validEventIdAndDrawId =\n              eventIds.includes(round.eventId) &&\n              drawIds.includes(round.drawId);\n            if (!validEventIdAndDrawId)\n              issues.push(\n                `Invalid eventId: ${round.eventId} or drawId: ${round.drawId}`\n              );\n            return validEventIdAndDrawId;\n          });\n\n          if (!filteredRounds.length) return;\n\n          return { venueId, rounds: filteredRounds };\n        })\n        .filter(Boolean);\n\n      return venues.length && date && { ...dateSchedulingProfile, venues };\n    })\n    .filter(Boolean);\n\n  const modifications = issues.length;\n  return { updatedSchedulingProfile, modifications, issues };\n}\n","import { getAllStructureMatchUps } from '../query/matchUps/getAllStructureMatchUps';\nimport { getRoundMatchUps } from '../query/matchUps/getRoundMatchUps';\nimport { getDrawStructures } from '../acquire/findStructure';\nimport { isConvertableInteger, isPowerOf2 } from '../utilities/math';\nimport { isValidDateString } from '../utilities/dateTime';\n\nimport { INVALID_VALUES, VENUE_NOT_FOUND } from '../constants/errorConditionConstants';\n\nexport function validateSchedulingProfile({ tournamentRecords, schedulingProfile }): any {\n  if (!schedulingProfile) return { valid: true };\n\n  if (!Array.isArray(schedulingProfile)) return { valid: false, error: INVALID_VALUES };\n\n  const { venueIds, tournamentsMap } = getAllRelevantSchedulingIds({\n    tournamentRecords,\n  });\n\n  let error, info;\n  const isValid = schedulingProfile.every((dateSchedule) => {\n    const { scheduleDate, venues } = dateSchedule;\n    if (!isValidDateString(scheduleDate)) {\n      return false;\n    }\n    return venues.every((venueProfile) => {\n      const { venueId, rounds } = venueProfile;\n      if (typeof venueId !== 'string') {\n        info = 'venueId should be a string';\n        return false;\n      }\n      if (!Array.isArray(rounds)) {\n        info = 'rounds should be an array';\n        return false;\n      }\n      if (!venueIds.includes(venueId)) {\n        error = VENUE_NOT_FOUND;\n        return false;\n      }\n      const validRounds = rounds.every((round) => {\n        if (!round) {\n          info = 'empty round';\n          return false;\n        }\n        const { roundSegment, tournamentId, structureId, roundNumber, eventId, drawId } = round;\n\n        const rounds = tournamentsMap?.[tournamentId]?.[eventId]?.[drawId]?.[structureId];\n\n        const validRound = rounds?.includes(roundNumber);\n        if (!validRound) info = 'Invalid rounds';\n\n        const { segmentNumber, segmentsCount } = roundSegment || {};\n        const validSegment =\n          !roundSegment ||\n          (isConvertableInteger(segmentNumber) && isPowerOf2(segmentsCount) && segmentNumber <= segmentsCount);\n\n        if (!validSegment) info = 'Invalid segment';\n        return validRound && validSegment;\n      });\n\n      return !validRounds ? false : true;\n    });\n  });\n\n  if (!isValid && !error) {\n    error = INVALID_VALUES;\n  }\n\n  return { valid: !!isValid, error, info };\n}\n\nexport function tournamentRelevantSchedulingIds(params) {\n  const { tournamentRecord = {}, tournamentMap = {}, requireCourts } = params;\n  const tournamentIds: string[] = [];\n  const structureIds: string[] = [];\n  const eventIds: string[] = [];\n  const drawIds: string[] = [];\n  const venueIds: string[] = (tournamentRecord?.venues || []).map(\n    ({ venueId, courts }) => (!requireCourts || courts?.length) && venueId,\n  );\n  const tournamentId = tournamentRecord?.tournamentId;\n\n  if (tournamentId) {\n    tournamentIds.push(tournamentId);\n    tournamentMap[tournamentId] = {};\n    const events = tournamentRecord?.events || [];\n    events.forEach((event) => {\n      const eventId = event.eventId;\n      eventIds.push(eventId);\n      tournamentMap[tournamentId][eventId] = {};\n      (event.drawDefinitions || []).forEach((drawDefinition) => {\n        const drawId = drawDefinition.drawId;\n        drawIds.push(drawId);\n        tournamentMap[tournamentId][eventId][drawId] = {};\n        const { structures } = getDrawStructures({ drawDefinition });\n        (structures || []).forEach((structure) => {\n          const structureId = structure.structureId;\n          const { matchUps } = getAllStructureMatchUps({ structure });\n          const { roundMatchUps } = getRoundMatchUps({ matchUps });\n          const rounds = roundMatchUps && Object.keys(roundMatchUps).map((roundNumber) => parseInt(roundNumber));\n\n          tournamentMap[tournamentId][eventId][drawId][structureId] = rounds;\n\n          structureIds.push(structureId);\n          if (structure.structures?.length) {\n            structure.structures.forEach((itemStructure) => {\n              structureIds.push(itemStructure.structureId);\n              tournamentMap[tournamentId][eventId][drawId][itemStructure.structureId] = rounds;\n            });\n          }\n        });\n      });\n    });\n  }\n\n  return {\n    tournamentMap,\n    tournamentIds,\n    structureIds,\n    venueIds,\n    eventIds,\n    drawIds,\n  };\n}\n\nexport function getAllRelevantSchedulingIds(params) {\n  const records: any = (params?.tournamentRecords && Object.values(params?.tournamentRecords)) || [];\n  const tournamentsMap = {};\n  const { venueIds, eventIds, drawIds, structureIds, tournamentIds } = records.reduce(\n    (aggregator, tournamentRecord) => {\n      const { tournamentIds, tournamentMap, structureIds, venueIds, eventIds, drawIds } =\n        tournamentRelevantSchedulingIds({\n          tournamentRecord,\n        });\n      venueIds.forEach((venueId) => {\n        if (!aggregator.venueIds.includes(venueId)) aggregator.venueIds.push(venueId);\n      });\n      aggregator.tournamentIds.push(...tournamentIds);\n      aggregator.structureIds.push(...structureIds);\n      aggregator.eventIds.push(...eventIds);\n      aggregator.drawIds.push(...drawIds);\n      Object.assign(tournamentsMap, tournamentMap);\n      return aggregator;\n    },\n    {\n      tournamentIds: [],\n      structureIds: [],\n      venueIds: [],\n      eventIds: [],\n      drawIds: [],\n    },\n  );\n\n  return {\n    tournamentsMap,\n    tournamentIds,\n    structureIds,\n    venueIds,\n    eventIds,\n    drawIds,\n  };\n}\n","import { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { findExtension } from '../../acquire/findExtension';\nimport { isObject } from '../../utilities/objects';\n\nimport { DISABLED } from '../../constants/extensionConstants';\n\nexport function getInContextCourt({\n  convertExtensions,\n  ignoreDisabled,\n  venue,\n  court,\n}) {\n  const inContextCourt = {\n    ...makeDeepCopy(court, convertExtensions, true),\n    venueId: venue.venueId,\n  };\n  const { extension } = findExtension({\n    name: DISABLED,\n    element: court,\n  });\n\n  if (ignoreDisabled && extension) {\n    const disabledDates = isObject(extension.value)\n      ? extension.value?.dates\n      : undefined;\n\n    const dateAvailability =\n      extension?.value === true\n        ? []\n        : inContextCourt.dateAvailability\n            .map((availability) => {\n              const date = availability.date;\n              if (!date || disabledDates.includes(date)) return; // ignore defaultAvailility (no date)\n              return availability;\n            })\n            .filter(Boolean);\n\n    inContextCourt.dateAvailability = dateAvailability;\n  }\n\n  return { inContextCourt };\n}\n","import { isObject } from '../../utilities/objects';\n\ntype GetDisabledStatusArgs = {\n  dates?: string[];\n  extension?: any;\n};\n\nexport function getDisabledStatus({\n  dates = [],\n  extension,\n}: GetDisabledStatusArgs) {\n  if (!extension) return false;\n\n  // boolean value false means court is entirely disabled\n  if (typeof extension.value === 'boolean' && extension.value) return true;\n  // even if a court is disabled for specific dates, if no dates are provided then it is not considered disabled\n  // REFINEMENT: if disabledDates include all dates from tournament.startDate to tournament.endDate then court is disabled\n\n  if (!dates.length) return false;\n\n  const disabledDates = isObject(extension.value)\n    ? extension.value?.dates\n    : undefined;\n\n  if (Array.isArray(disabledDates)) {\n    if (!disabledDates?.length) return false;\n    const datesToConsider = disabledDates.filter(\n      (date) => !dates.length || dates.includes(date)\n    );\n\n    // only if all provided dates appear in disabled dates is the court considered disabled\n    return !!datesToConsider.length;\n  }\n\n  return undefined;\n}\n","import { getInContextCourt } from './getInContextCourt';\nimport { getDisabledStatus } from '../extensions/getDisabledStatus';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { findExtension } from '../../acquire/findExtension';\n\nimport { HydratedCourt, HydratedVenue } from '../../types/hydrated';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { Tournament, Venue } from '../../types/tournamentTypes';\nimport { DISABLED } from '../../constants/extensionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../constants/errorConditionConstants';\n\ntype GetVenuesAndCourtsArgs = {\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  convertExtensions?: boolean;\n  ignoreDisabled?: boolean;\n  tournamentId?: string;\n  venueIds?: string[];\n  dates?: string[];\n};\nexport function getVenuesAndCourts(\n  params: GetVenuesAndCourtsArgs\n): ResultType & {\n  venues?: HydratedVenue[];\n  courts?: HydratedCourt[];\n} {\n  const {\n    convertExtensions,\n    ignoreDisabled,\n    venueIds = [],\n    dates, // used in conjunction with ignoreDisabled\n  } = params;\n\n  const tournamentRecords =\n    params.tournamentRecords ||\n    (params.tournamentRecord && {\n      [params.tournamentRecord.tournamentId]: params.tournamentRecord,\n    }) ||\n    {};\n\n  const uniqueVenueIds: string[] = [];\n  const uniqueCourtIds: string[] = [];\n  const courts: HydratedCourt[] = [];\n  const venues: HydratedVenue[] = [];\n\n  const tournamentIds = Object.keys(tournamentRecords).filter(\n    (id) => !params.tournamentId || id === params.tournamentId\n  );\n  tournamentIds.forEach((tournamentId) => {\n    const tournamentRecord = tournamentRecords[tournamentId];\n    for (const venue of tournamentRecord.venues ?? []) {\n      if (venueIds.length && !venueIds.includes(venue.venueId)) continue;\n      if (ignoreDisabled) {\n        const { extension } = findExtension({\n          name: DISABLED,\n          element: venue,\n        });\n        if (extension?.value) continue;\n      }\n      if (!uniqueVenueIds.includes(venue.venueId)) {\n        venues.push(makeDeepCopy(venue, convertExtensions, true));\n        uniqueVenueIds.push(venue.venueId);\n      }\n      for (const court of venue.courts ?? []) {\n        if (!uniqueCourtIds.includes(court.courtId)) {\n          // if dates are provided, only ignore the court if it is disabled for all given dates\n          if (ignoreDisabled) {\n            const { extension } = findExtension({\n              name: DISABLED,\n              element: court,\n            });\n            const isDisabled = getDisabledStatus({ extension, dates });\n            if (isDisabled) continue;\n          }\n          const { inContextCourt } = getInContextCourt({\n            convertExtensions,\n            ignoreDisabled,\n            venue,\n            court,\n          });\n\n          courts.push(inContextCourt);\n          uniqueCourtIds.push(court.courtId);\n        }\n      }\n    }\n  });\n\n  return { courts, venues, ...SUCCESS };\n}\n\nexport function getTournamentVenuesAndCourts({\n  convertExtensions,\n  tournamentRecord,\n  ignoreDisabled,\n  dates, // used in conjunction with ignoreDisabled\n}: GetVenuesAndCourtsArgs): ResultType & {\n  venues?: HydratedVenue[];\n  courts?: HydratedCourt[];\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const venues = makeDeepCopy(tournamentRecord.venues ?? [], convertExtensions)\n    .filter((venue) => {\n      if (!ignoreDisabled) return venue;\n      const { extension } = findExtension({\n        name: DISABLED,\n        element: venue,\n      });\n      return !extension?.value && venue;\n    })\n    .filter(Boolean);\n\n  const courts = venues.reduce((courts, venue) => {\n    const additionalCourts = (venue?.courts || [])\n      .filter((court) => {\n        if (!ignoreDisabled && !dates?.length) return court;\n        const { extension } = findExtension({\n          name: DISABLED,\n          element: court,\n        });\n        return getDisabledStatus({ extension, dates });\n      })\n      .filter(Boolean)\n      .map((court) => {\n        const { inContextCourt } = getInContextCourt({\n          convertExtensions,\n          ignoreDisabled,\n          venue,\n          court,\n        });\n\n        return inContextCourt;\n      });\n\n    return additionalCourts.length ? courts.concat(additionalCourts) : courts;\n  }, []);\n\n  return { venues, courts };\n}\n\ntype Accumulator = {\n  venueIds: string[];\n  venues: Venue[];\n};\n\ntype GetCompeitionVenuesArgs = {\n  tournamentRecords: TournamentRecords;\n  requireCourts?: boolean;\n  dates?: string[];\n};\n\nexport function getCompetitionVenues({\n  tournamentRecords,\n  requireCourts,\n  dates,\n}: GetCompeitionVenuesArgs): {\n  venueIds?: string[];\n  error?: ErrorType;\n  venues?: Venue[];\n} {\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const tournamentIds = Object.keys(tournamentRecords);\n  return tournamentIds.reduce(\n    (accumulator: Accumulator, tournamentId) => {\n      const tournamentRecord = tournamentRecords[tournamentId];\n      const { venues } = getTournamentVenuesAndCourts({\n        tournamentRecord,\n        dates,\n      });\n      venues?.forEach((venue) => {\n        const { venueId, courts } = venue;\n        const includeVenue = !requireCourts || courts?.length;\n        if (includeVenue && !accumulator.venueIds.includes(venueId)) {\n          accumulator.venues.push(venue);\n          accumulator.venueIds.push(venueId);\n        }\n      });\n      return accumulator;\n    },\n    { venues: [], venueIds: [] }\n  );\n}\n","import { checkRequiredParameters } from '../../parameters/checkRequiredParameters';\n\nimport { TOURNAMENT_RECORDS } from '../../constants/attributeConstants';\nimport { ErrorType } from '../../constants/errorConditionConstants';\nimport { TournamentRecords } from '../../types/factoryTypes';\n\ntype Aggregator = {\n  tournamentIdMap: { [key: string]: string[] };\n  eventIds: string[];\n  drawIds: string[];\n};\n\ntype AggregatorResut = {\n  tournamentIdMap?: { [key: string]: string[] };\n  eventIds?: string[];\n  drawIds?: string[];\n  error?: ErrorType;\n};\n\n// Returns arrays of all drawIds and eventIds across tournamentRecords\n// Returns an combined array of drawIds and eventIds for each tournamentId\nexport function getEventIdsAndDrawIds(params: { tournamentRecords: TournamentRecords }): AggregatorResut {\n  const paramCheck = checkRequiredParameters(params, [{ [TOURNAMENT_RECORDS]: true }]);\n  if (paramCheck.error) return paramCheck;\n\n  const tournamentIds = Object.keys(params.tournamentRecords);\n\n  return tournamentIds.reduce(\n    (aggregator: Aggregator, tournamentId) => {\n      aggregator.tournamentIdMap[tournamentId] = [];\n\n      const tournamentRecord = params.tournamentRecords[tournamentId];\n      const events = tournamentRecord.events || [];\n      const eventIds = events.map(({ eventId }) => eventId);\n      const drawIds = events.map((event) => (event.drawDefinitions || []).map(({ drawId }) => drawId)).flat();\n\n      aggregator.tournamentIdMap[tournamentId].push(...eventIds, ...drawIds);\n      aggregator.eventIds.push(...eventIds);\n      aggregator.drawIds.push(...drawIds);\n\n      return aggregator;\n    },\n    { eventIds: [], drawIds: [], tournamentIdMap: {} },\n  );\n}\n","import { getUpdatedSchedulingProfile } from '../../query/matchUps/scheduling/getUpdatedSchedulingProfile';\nimport { validateSchedulingProfile } from '../../validators/validateSchedulingProfile';\nimport { getCompetitionVenues } from '../../query/venues/venuesAndCourtsGetter';\nimport { removeExtension } from '../extensions/removeExtension';\nimport { getEventIdsAndDrawIds } from '../../query/tournaments/getEventIdsAndDrawIds';\nimport { addExtension } from '../extensions/addExtension';\nimport { findExtension } from '../../acquire/findExtension';\n\nimport { SCHEDULING_PROFILE } from '../../constants/extensionConstants';\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { Tournament } from '../../types/tournamentTypes';\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../constants/errorConditionConstants';\n\ntype GetSchedulingProfileArgs = {\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n};\n\nexport function getSchedulingProfile({\n  tournamentRecords,\n  tournamentRecord,\n}: GetSchedulingProfileArgs): {\n  schedulingProfile?: any;\n  modifications?: number;\n  error?: ErrorType;\n  issues?: string[];\n} {\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const { extension } = findExtension({\n    element: tournamentRecord, // if tournamentRecord is provided, use it\n    name: SCHEDULING_PROFILE,\n    tournamentRecords,\n    discover: true,\n  });\n\n  let schedulingProfile = extension?.value || [];\n\n  if (schedulingProfile.length) {\n    const { venueIds } = getCompetitionVenues({\n      requireCourts: true,\n      tournamentRecords,\n    });\n    const { eventIds, drawIds } = getEventIdsAndDrawIds({ tournamentRecords });\n\n    const { updatedSchedulingProfile, modifications, issues } =\n      getUpdatedSchedulingProfile({\n        schedulingProfile,\n        venueIds,\n        eventIds,\n        drawIds,\n      });\n\n    if (modifications) {\n      schedulingProfile = updatedSchedulingProfile;\n      const result = setSchedulingProfile({\n        tournamentRecords,\n        tournamentRecord,\n        schedulingProfile,\n      });\n      if (result.error) return result;\n\n      return { schedulingProfile, modifications, issues };\n    }\n  }\n\n  return { schedulingProfile, modifications: 0 };\n}\n\ntype SetSchedulingProfileArgs = {\n  tournamentRecords: TournamentRecords;\n  tournamentRecord?: Tournament;\n  schedulingProfile?: any[];\n};\nexport function setSchedulingProfile({\n  tournamentRecords,\n  tournamentRecord,\n  schedulingProfile,\n}: SetSchedulingProfileArgs) {\n  const profileValidity = validateSchedulingProfile({\n    tournamentRecords,\n    schedulingProfile,\n  });\n\n  if (profileValidity.error) return profileValidity;\n\n  if (!schedulingProfile)\n    return removeExtension({\n      element: tournamentRecord,\n      name: SCHEDULING_PROFILE,\n      tournamentRecords,\n      discover: true,\n    });\n\n  const extension = {\n    name: SCHEDULING_PROFILE,\n    value: schedulingProfile,\n  };\n\n  return addExtension({ tournamentRecords, discover: true, extension });\n}\n\nexport function checkAndUpdateSchedulingProfile(params) {\n  const { tournamentRecord } = params;\n\n  const tournamentRecords =\n    params.tournamentRecords ||\n    (tournamentRecord && {\n      [tournamentRecord.tournamentId]: tournamentRecord,\n    }) ||\n    {};\n\n  if (!params.schedulingProfile) {\n    const { modifications, issues } = getSchedulingProfile({\n      tournamentRecords,\n      tournamentRecord,\n    });\n    return { success: !modifications, modifications, issues };\n  }\n\n  const { venueIds } = getCompetitionVenues({ tournamentRecords });\n  const { eventIds, drawIds } = getEventIdsAndDrawIds({ tournamentRecords });\n\n  const { updatedSchedulingProfile, modifications, issues } =\n    getUpdatedSchedulingProfile({\n      schedulingProfile: params.schedulingProfile,\n      venueIds,\n      eventIds,\n      drawIds,\n    });\n\n  if (modifications) {\n    return {\n      ...setSchedulingProfile({\n        schedulingProfile: updatedSchedulingProfile,\n        tournamentRecords,\n      }),\n      modifications,\n      issues,\n    };\n  }\n\n  return { ...SUCCESS, modifications, issues };\n}\n","import { findTournamentParticipant } from '../../acquire/findTournamentParticipant';\nimport { getTimeItem } from '../../query/base/timeItems';\n\nimport { TimeItem, Tournament } from '../../types/tournamentTypes';\nimport { ELEMENT_REQUIRED } from '../../constants/infoConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  EVENT_NOT_FOUND,\n  INVALID_TIME_ITEM,\n  MISSING_PARTICIPANT_ID,\n  MISSING_TIME_ITEM,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\ntype AddTimeItemArgs = {\n  removePriorValues?: boolean;\n  duplicateValues?: boolean;\n  creationTime?: boolean;\n  timeItem: TimeItem;\n  element: any;\n};\nexport function addTimeItem(params: AddTimeItemArgs) {\n  const {\n    duplicateValues = true,\n    creationTime = true,\n    removePriorValues,\n    timeItem,\n    element,\n  } = params;\n  if (!timeItem) return { error: MISSING_TIME_ITEM };\n  if (!element) return { error: MISSING_VALUE, info: ELEMENT_REQUIRED };\n\n  const timeItemAttributes = timeItem && Object.keys(timeItem);\n  const requiredAttributes = ['itemType', 'itemValue'];\n  const validTimeItem =\n    requiredAttributes.filter((attribute) =>\n      timeItemAttributes.includes(attribute)\n    ).length === requiredAttributes.length;\n\n  if (!validTimeItem) return { error: INVALID_TIME_ITEM };\n\n  if (!element.timeItems) {\n    element.timeItems = [];\n  } else {\n    // check if timeItem with equivalent value already exists\n    const { itemType, itemSubTypes, itemValue } = timeItem;\n    const existingTimeItem =\n      itemType &&\n      getTimeItem({\n        itemSubTypes,\n        itemType,\n        element,\n      })?.timeItem;\n    if (\n      existingTimeItem &&\n      JSON.stringify(existingTimeItem?.itemValue) ===\n        JSON.stringify(itemValue) &&\n      !duplicateValues\n    ) {\n      return { ...SUCCESS };\n    }\n  }\n\n  if (timeItem.itemSubTypes && !timeItem.itemSubTypes.length) {\n    delete timeItem.itemSubTypes;\n  }\n\n  if (creationTime) {\n    const createdAt = new Date().toISOString();\n    Object.assign(timeItem, { createdAt });\n  }\n\n  if (removePriorValues) {\n    element.timeItems = element.timeItems.filter(\n      ({ itemType }) => timeItem.itemType !== itemType\n    );\n  }\n\n  // if priorValues are being remvoed and there is no new itemValue, do not add by pushing\n  const doNotAdd = removePriorValues && !timeItem.itemValue;\n  if (!doNotAdd) {\n    element.timeItems.push(timeItem);\n  }\n\n  return { ...SUCCESS };\n}\n\ntype AddParticipantTimeItemArgs = {\n  tournamentRecord: Tournament;\n  removePriorValues?: boolean;\n  duplicateValues?: boolean;\n  creationTime?: boolean;\n  participantId: string;\n  timeItem: TimeItem;\n};\nexport function addParticipantTimeItem({\n  creationTime = true,\n  removePriorValues,\n  tournamentRecord,\n  duplicateValues,\n  participantId,\n  timeItem,\n}: AddParticipantTimeItemArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!participantId) return { error: MISSING_PARTICIPANT_ID };\n\n  const result = findTournamentParticipant({ tournamentRecord, participantId });\n  if (result.error) return result;\n\n  return addTimeItem({\n    element: result.participant,\n    removePriorValues,\n    duplicateValues,\n    creationTime,\n    timeItem,\n  });\n}\n\nexport function addTournamentTimeItem(params) {\n  const {\n    removePriorValues,\n    tournamentRecord,\n    duplicateValues,\n    creationTime,\n    timeItem,\n  } = params;\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  return addTimeItem({\n    element: tournamentRecord,\n    removePriorValues,\n    duplicateValues,\n    creationTime,\n    timeItem,\n  });\n}\n\nexport function addEventTimeItem(params) {\n  const { removePriorValues, duplicateValues, creationTime, timeItem, event } =\n    params;\n  if (!event) return { error: EVENT_NOT_FOUND };\n  return addTimeItem({\n    removePriorValues,\n    duplicateValues,\n    element: event,\n    creationTime,\n    timeItem,\n  });\n}\n\nexport function resetTimeItems({ element }) {\n  if (!element) return { error: MISSING_VALUE };\n  element.timeItems = [];\n  return { ...SUCCESS };\n}\n","import { addEventTimeItem } from '../timeItems/addTimeItem';\nimport { getEventPublishStatus } from '../../query/event/getEventPublishStatus';\nimport { isObject } from '../../utilities/objects';\n\nimport { PUBLIC, PUBLISH, STATUS } from '../../constants/timeItemConstants';\nimport { INVALID_VALUES } from '../../constants/errorConditionConstants';\nimport { Event } from '../../types/tournamentTypes';\n\ntype ModifyEventPublishStatus = {\n  statusObject: { [key: string]: any };\n  removePriorValues?: boolean;\n  status?: string;\n  event: Event;\n};\n\nexport function modifyEventPublishStatus({\n  removePriorValues = true,\n  status = PUBLIC,\n  statusObject,\n  event,\n}: ModifyEventPublishStatus) {\n  if (!isObject(statusObject)) return { error: INVALID_VALUES };\n  const publishStatus = getEventPublishStatus({ event, status });\n  const itemType = `${PUBLISH}.${STATUS}`;\n  const updatedTimeItem = {\n    itemValue: { [status]: { ...publishStatus, ...statusObject } },\n    itemType,\n  };\n\n  return addEventTimeItem({\n    timeItem: updatedTimeItem,\n    removePriorValues,\n    event,\n  });\n}\n","import { makeDeepCopy } from '../../utilities/makeDeepCopy';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\nexport function getTournamentInfo({ tournamentRecord }): {\n  tournamentInfo?: any;\n  error?: ErrorType;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const tournamentInfo = (({\n    tournamentId,\n    tournamentRank,\n    tournamentStatus,\n\n    formalName,\n    tournamentName,\n    promotionalName,\n    onlineResources,\n\n    localTimeZone,\n    startDate,\n    endDate,\n\n    hostCountryCode,\n    tournamentContacts,\n    tournamentAddresses,\n  }) => ({\n    tournamentId,\n    tournamentRank,\n    tournamentStatus,\n\n    formalName,\n    tournamentName,\n    promotionalName,\n    onlineResources,\n\n    localTimeZone,\n    startDate,\n    endDate,\n\n    hostCountryCode,\n    tournamentContacts,\n    tournamentAddresses,\n  }))(tournamentRecord);\n\n  return {\n    ...SUCCESS,\n    tournamentInfo: makeDeepCopy(tournamentInfo, false, true),\n  };\n}\n","import {\n  generateRange,\n  intersection,\n  overlap,\n  unique,\n} from '../../utilities/arrays';\n\nimport { DrawDefinition } from '../../types/tournamentTypes';\nimport { StructureProfile } from '../../types/factoryTypes';\nimport {\n  BOTTOM_UP,\n  DRAW,\n  QUALIFYING,\n  RANDOM,\n  TOP_DOWN,\n  VOLUNTARY_CONSOLATION,\n  WATERFALL,\n} from '../../constants/drawDefinitionConstants';\n\n/**\n * return an array of arrays of grouped structureIds => structureGroups\n * the expectation is that all structures within a drawDefintion are linked\n * return a boolean whether this condition is met => allSructuresLinked\n */\nexport function getStructureGroups({\n  drawDefinition,\n}: {\n  drawDefinition: DrawDefinition;\n}): {\n  sourceStructureIds: { [key: string]: boolean };\n  hasDrawFeedProfile: { [key: string]: boolean }; // denotes placement is by DRAW, e.g. manually placed qualifiers\n  structureProfiles: { [key: string]: StructureProfile };\n  allStructuresLinked: boolean;\n  structureGroups: string[][];\n  maxQualifyingDepth: number;\n} {\n  const structures = drawDefinition.structures ?? [];\n  const links = drawDefinition.links ?? [];\n\n  const structureProfiles = new Map<string, StructureProfile>();\n\n  const initStructureProfile = (structureId) => {\n    const profile =\n      structureProfiles.get(structureId) ||\n      (structureProfiles.set(structureId, {\n        drawSources: [],\n        drawTargets: [],\n        progeny: [],\n        sources: [],\n        targets: [],\n      }) &&\n        structureProfiles.get(structureId));\n\n    if (profile && !profile?.stage) {\n      const structure = structures.find(\n        (structure) => structure.structureId === structureId\n      );\n      profile.stage = structure?.stage;\n    }\n\n    return profile;\n  };\n\n  const sourceStructureIds = {};\n  const hasDrawFeedProfile = {};\n  let linkedStructureIds = links.map((link) => {\n    const sourceId = link.source.structureId;\n    const targetId = link.target.structureId;\n\n    const sourceProfile = initStructureProfile(sourceId);\n    const targetProfile = initStructureProfile(targetId);\n    if (\n      [BOTTOM_UP, TOP_DOWN, RANDOM, WATERFALL].includes(link.target.feedProfile)\n    ) {\n      sourceProfile?.targets.push(targetId);\n      targetProfile?.sources.push(sourceId);\n    } else if (link.target.feedProfile === DRAW) {\n      targetProfile?.drawSources.push(sourceId);\n      sourceProfile?.drawTargets.push(targetId);\n    }\n\n    hasDrawFeedProfile[targetId] =\n      hasDrawFeedProfile[targetId] || link.target.feedProfile === DRAW;\n    sourceStructureIds[targetId] = unique([\n      ...(sourceStructureIds[targetId] || []),\n      sourceId,\n    ]).filter(Boolean);\n\n    return [link.source.structureId, link.target.structureId];\n  });\n\n  for (const structureId of structureProfiles.keys()) {\n    const profile = structureProfiles.get(structureId);\n    if (profile) {\n      const sourceIds = profile.targets ?? [];\n      while (sourceIds.length) {\n        const sourceId = sourceIds.pop();\n        const sourceProfile = sourceId && structureProfiles[sourceId];\n        if (sourceProfile?.targets?.length) {\n          sourceIds.push(...sourceProfile.targets);\n        } else if (sourceProfile) {\n          profile.rootStage = sourceProfile.stage;\n        }\n      }\n      if (!profile.rootStage) profile.rootStage = profile.stage;\n\n      if (!profile.targets?.length) {\n        const targetIds = profile.sources ?? [];\n        while (targetIds.length) {\n          const targetId = targetIds.pop();\n          const targetProfile = targetId && structureProfiles[targetId];\n          if (targetProfile?.sources?.length) {\n            for (const id of targetProfile.sources) {\n              if (!profile.progeny?.includes(id)) profile.progeny?.push(id);\n            }\n            targetIds.push(...targetProfile.sources);\n          }\n        }\n      }\n    }\n  }\n\n  let maxQualifyingDepth = 0;\n  for (const structureId of structureProfiles.keys()) {\n    const profile = structureProfiles.get(structureId);\n    if (profile && profile.rootStage === QUALIFYING) {\n      const drawTargets = [profile.drawTargets?.[0]];\n      let distanceFromMain = 0;\n      while (drawTargets.length) {\n        distanceFromMain += 1;\n        const drawTarget = drawTargets.pop();\n        const targetProfile = drawTarget\n          ? structureProfiles.get(drawTarget)\n          : undefined;\n        if (targetProfile?.drawTargets?.length) {\n          drawTargets.push(targetProfile.drawTargets[0]);\n        }\n      }\n      profile.distanceFromMain = distanceFromMain;\n      if (distanceFromMain > maxQualifyingDepth)\n        maxQualifyingDepth = distanceFromMain;\n    }\n  }\n\n  // iterate through all groups of structureIds to flatten tree of links between structures\n  const iterations = linkedStructureIds.length;\n  generateRange(0, Math.ceil(iterations / 2)).forEach(() => {\n    linkedStructureIds = generateRange(0, iterations).map((index) => {\n      const structureIds = linkedStructureIds[index];\n      const mergedWithOverlappingIds =\n        linkedStructureIds.reduce((biggest, ids) => {\n          const hasOverlap = overlap(structureIds, ids);\n          return hasOverlap ? biggest.concat(...ids) : biggest;\n        }, []) || [];\n      return unique(structureIds.concat(...mergedWithOverlappingIds));\n    });\n  });\n\n  // at this point all linkedStructureIds arrays should be equivalent\n  // use the first of these as the identity array\n  const groupedStructureIds = linkedStructureIds[0];\n\n  // utility method to recognize equivalent arrays of structureIds\n  const identityLink = (a, b) => intersection(a, b).length === a.length;\n\n  // check that all arrays of linkedStructureIds are equivalent to identity array\n  const allLinkStructuresLinked = linkedStructureIds\n    .slice(1)\n    .reduce((allLinkStructuresLinked, ids) => {\n      return allLinkStructuresLinked && identityLink(ids, groupedStructureIds);\n    }, true);\n\n  // if a drawDefinition contains no links then no structure groups will exist\n  // filter out undefined when there are no links in a drawDefinition\n  const structureGroups = [groupedStructureIds].filter(Boolean);\n\n  // this is the same as structureGroups, but excludes VOLUNTARY_CONSOLATION\n  const linkCheck: string[][] = [groupedStructureIds].filter(Boolean);\n\n  // iterate through all structures to add missing structureIds\n  structures.forEach((structure) => {\n    const { structureId, stage } = structure;\n    const existingGroup = structureGroups.find((group) => {\n      return group.includes(structureId);\n    });\n    if (!existingGroup) {\n      structureGroups.push([structureId]);\n      if (stage !== VOLUNTARY_CONSOLATION) linkCheck.push([structureId]);\n    }\n  });\n\n  const allStructuresLinked = allLinkStructuresLinked && linkCheck.length === 1;\n\n  if (!links?.length && structures.length === 1) {\n    initStructureProfile(structures[0].structureId);\n  }\n\n  return {\n    structureProfiles: Object.fromEntries(structureProfiles),\n    allStructuresLinked,\n    maxQualifyingDepth,\n    sourceStructureIds,\n    hasDrawFeedProfile,\n    structureGroups,\n  };\n}\n","import { getStructureSeedAssignments } from '../structure/getStructureSeedAssignments';\nimport { getAllStructureMatchUps } from '../matchUps/getAllStructureMatchUps';\nimport { structureSort } from '../../functions/sorters/structureSort';\nimport { getStructureGroups } from '../structure/getStructureGroups';\nimport { xa } from '../../utilities/objects';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { getPositionAssignments } from './positionsGetter';\nimport { findStructure } from '../../acquire/findStructure';\nimport { findExtension } from '../../acquire/findExtension';\n\nimport { PARTICIPANT_ID } from '../../constants/attributeConstants';\nimport { TALLY } from '../../constants/extensionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { ErrorType, MISSING_DRAW_DEFINITION, UNLINKED_STRUCTURES } from '../../constants/errorConditionConstants';\nimport {\n  ABANDONED,\n  BYE,\n  CANCELLED,\n  COMPLETED,\n  DEFAULTED,\n  DOUBLE_DEFAULT,\n  DOUBLE_WALKOVER,\n  IN_PROGRESS,\n  RETIRED,\n  WALKOVER,\n} from '../../constants/matchUpStatusConstants';\nimport { CONSOLATION, MAIN, PLAY_OFF, QUALIFYING } from '../../constants/drawDefinitionConstants';\n\nexport function getDrawData(params): {\n  structures?: any[];\n  success?: boolean;\n  error?: ErrorType;\n  drawInfo?: any;\n} {\n  const {\n    tournamentParticipants = [],\n    includePositionAssignments,\n    policyDefinitions,\n    tournamentRecord,\n    inContext = true,\n    usePublishState,\n    drawDefinition,\n    publishStatus,\n    noDeepCopy,\n    sortConfig,\n    context,\n    event,\n  } = params;\n\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const drawInfo: any = (({ matchUpFormat, updatedAt, drawType, drawName, drawId }) => ({\n    matchUpFormat,\n    updatedAt,\n    drawName,\n    drawType,\n    drawId,\n  }))(drawDefinition);\n\n  let mainStageSeedAssignments, qualificationStageSeedAssignments;\n  const { allStructuresLinked, sourceStructureIds, hasDrawFeedProfile, structureGroups } = getStructureGroups({\n    drawDefinition,\n  });\n\n  if (!allStructuresLinked) {\n    return { error: UNLINKED_STRUCTURES };\n  }\n\n  let drawActive = false;\n  let participantPlacements = false; // if any positionAssignments include a participantId\n  const groupedStructures = structureGroups.map((structureIds) => {\n    const completedStructures = {};\n    const structures = structureIds\n      .map((structureId) => {\n        const { structure } = findStructure({ drawDefinition, structureId });\n        const { seedAssignments } = getStructureSeedAssignments({\n          drawDefinition,\n          structure,\n        });\n\n        // capture the seedAssignments for MAIN/QUALIFYING { stageSequence: 1 }\n        if (structure?.stage === MAIN && structure.stageSequence === 1) {\n          mainStageSeedAssignments = seedAssignments;\n        }\n        if (structure?.stage === QUALIFYING && structure.stageSequence === 1) {\n          qualificationStageSeedAssignments = seedAssignments;\n        }\n\n        return structure;\n      })\n      .sort((a, b) => structureSort(a, b, sortConfig))\n      .map((structure) => {\n        if (!structure) return;\n        const structureId = structure?.structureId;\n        let seedAssignments = [];\n\n        // pass seedAssignments from { stageSequence: 1 } to other stages\n        if (structure.stage && [MAIN, CONSOLATION, PLAY_OFF].includes(structure.stage)) {\n          seedAssignments = mainStageSeedAssignments;\n        }\n\n        if (structure?.stage === QUALIFYING) {\n          seedAssignments = qualificationStageSeedAssignments;\n        }\n\n        const { matchUps, roundMatchUps, roundProfile } = getAllStructureMatchUps({\n          // only propagate seedAssignments where none are present\n          seedAssignments: !structure?.seedAssignments?.length ? seedAssignments : undefined,\n          context: { drawId: drawInfo.drawId, ...context },\n          tournamentParticipants,\n          policyDefinitions,\n          tournamentRecord,\n          usePublishState,\n          publishStatus,\n          drawDefinition,\n          inContext,\n          structure,\n          event,\n        });\n\n        const { positionAssignments } = getPositionAssignments({\n          structure,\n        });\n\n        const participantResults = positionAssignments\n          ?.filter(xa(PARTICIPANT_ID))\n          .map((assignment) => {\n            participantPlacements = true;\n            const { drawPosition, participantId } = assignment;\n            const { extension } = findExtension({\n              element: assignment,\n              name: TALLY,\n            });\n            return (\n              extension && {\n                drawPosition,\n                participantId,\n                participantResult: extension.value,\n              }\n            );\n          })\n          .filter((f) => f?.participantResult);\n\n        const structureInfo: any = structure\n          ? (({ stageSequence, structureName, structureType, matchUpFormat, stage }) => ({\n              stageSequence,\n              structureName,\n              structureType,\n              matchUpFormat,\n              stage,\n            }))(structure)\n          : {};\n\n        structureInfo.sourceStructureIds = sourceStructureIds[structureId];\n        structureInfo.hasDrawFeedProfile = hasDrawFeedProfile[structureId];\n        structureInfo.positionAssignments = positionAssignments;\n\n        structureInfo.structureActive = matchUps.reduce((active, matchUp) => {\n          const activeMatchUpStatus = [\n            COMPLETED,\n            CANCELLED,\n            DEFAULTED,\n            RETIRED,\n            WALKOVER,\n            IN_PROGRESS,\n            DOUBLE_DEFAULT,\n            DOUBLE_WALKOVER,\n          ].includes(matchUp.matchUpStatus);\n          return active || activeMatchUpStatus || !!matchUp.winningSide || !!matchUp.score?.scoreStringSide1;\n        }, false);\n\n        const structureCompleted = matchUps.reduce((completed, matchUp) => {\n          return completed && [BYE, COMPLETED, RETIRED, WALKOVER, DEFAULTED, ABANDONED].includes(matchUp.matchUpStatus);\n        }, !!matchUps.length);\n        structureInfo.structureCompleted = structureCompleted;\n        completedStructures[structureId] = structureCompleted;\n\n        if (structureInfo.structureActive) drawActive = true;\n\n        return {\n          ...structureInfo,\n          participantResults,\n          seedAssignments,\n          roundMatchUps,\n          roundProfile,\n          structureId,\n        };\n      });\n\n    // cleanup attribute used for sorting\n    structures.forEach((structure) => {\n      if (!includePositionAssignments) delete structure.positionAssignments;\n      structure.sourceStructuresComplete = structure.sourceStructureIds?.every((id) => completedStructures[id]);\n    });\n\n    return structures;\n  });\n\n  const structures = groupedStructures.flat();\n\n  drawInfo.drawActive = drawActive;\n  drawInfo.participantPlacements = participantPlacements;\n  drawInfo.drawGenerated = structures?.reduce((generated, structure) => {\n    return generated || !!structure?.roundMatchUps;\n  }, false);\n  drawInfo.drawCompleted = structures?.reduce(\n    (completed, structure) => completed && structure.structureCompleted,\n    true,\n  );\n\n  return {\n    structures: noDeepCopy ? structures : makeDeepCopy(structures, false, true),\n    drawInfo: noDeepCopy ? drawInfo : makeDeepCopy(drawInfo, false, true),\n    ...SUCCESS,\n  };\n}\n","import { getTournamentInfo } from '../tournaments/getTournamentInfo';\nimport { getParticipants } from '../participants/getParticipants';\nimport { getEventPublishStatus } from './getEventPublishStatus';\nimport { getPublishState } from '../events/getPublishState';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { isConvertableInteger } from '../../utilities/math';\nimport { getDrawData } from '../drawDefinition/getDrawData';\nimport { generateRange } from '../../utilities/arrays';\nimport { getVenueData } from '../venues/getVenueData';\n\nimport { Event, Tournament } from '../../types/tournamentTypes';\nimport { PUBLIC } from '../../constants/timeItemConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ParticipantsProfile,\n  PolicyDefinitions,\n  StructureSortConfig,\n} from '../../types/factoryTypes';\nimport {\n  ErrorType,\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\ntype GetEventDataArgs = {\n  participantsProfile?: ParticipantsProfile;\n  includePositionAssignments?: boolean;\n  policyDefinitions?: PolicyDefinitions;\n  sortConfig?: StructureSortConfig;\n  tournamentRecord: Tournament;\n  usePublishState?: boolean;\n  status?: string;\n  event: Event;\n};\n\nexport function getEventData(params: GetEventDataArgs): {\n  error?: ErrorType;\n  success?: boolean;\n  eventData?: any;\n} {\n  const {\n    includePositionAssignments,\n    tournamentRecord: t,\n    participantsProfile,\n    policyDefinitions,\n    usePublishState,\n    status = PUBLIC,\n    sortConfig,\n    event: e,\n  } = params;\n  const tournamentRecord = makeDeepCopy(t, false, true);\n  const event = makeDeepCopy(e, false, true);\n\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n\n  const { eventId } = event;\n  const { tournamentId, endDate } = tournamentRecord;\n\n  const publishStatus = getEventPublishStatus({ event, status });\n  const { publishState } = getPublishState({ event });\n\n  const { participants: tournamentParticipants } = getParticipants({\n    withGroupings: true,\n    withEvents: false,\n    withDraws: false,\n    ...participantsProfile, // order is important!!\n    tournamentRecord,\n  });\n\n  const stageFilter = ({ stage, drawId }) => {\n    if (!usePublishState) return true;\n    const stageDetails = publishStatus?.drawDetails?.[drawId]?.stageDetails;\n    if (!stageDetails || !Object.keys(stageDetails).length) return true;\n    return stageDetails[stage]?.published;\n  };\n\n  const structureFilter = ({ structureId, drawId }) => {\n    if (!usePublishState) return true;\n    const structureDetails =\n      publishStatus?.drawDetails?.[drawId]?.structureDetails;\n    if (!structureDetails || !Object.keys(structureDetails).length) return true;\n    return structureDetails[structureId]?.published;\n  };\n\n  const drawFilter = ({ drawId }) => {\n    if (!usePublishState) return true;\n    if (publishStatus.drawDetails) {\n      return publishStatus.drawDetails[drawId]?.publishingDetail?.published;\n    } else if (publishStatus.drawIds) {\n      return publishStatus.drawIds.includes(drawId);\n    }\n    return true;\n  };\n\n  const roundLimitMapper = ({ drawId, structure }) => {\n    if (!usePublishState) return structure;\n    const roundLimit =\n      publishStatus?.drawDetails?.[drawId]?.structureDetails?.[\n        structure.structureId\n      ]?.roundLimit;\n    if (isConvertableInteger(roundLimit)) {\n      const roundNumbers = generateRange(1, roundLimit + 1);\n      const roundMatchUps = {};\n      const roundProfile = {};\n      for (const roundNumber of roundNumbers) {\n        if (structure.roundMatchUps[roundNumber]) {\n          roundMatchUps[roundNumber] = structure.roundMatchUps[roundNumber];\n          roundProfile[roundNumber] = structure.roundProfile[roundNumber];\n        }\n      }\n      structure.roundMatchUps = roundMatchUps;\n      structure.roundProfile = roundProfile;\n    }\n    return structure;\n  };\n\n  const drawDefinitions = event.drawDefinitions || [];\n  const drawsData = drawDefinitions\n    .filter(drawFilter)\n    .map((drawDefinition) =>\n      (({ drawInfo, structures }) => ({\n        ...drawInfo,\n        structures,\n      }))(\n        getDrawData({\n          context: { eventId, tournamentId, endDate },\n          includePositionAssignments,\n          tournamentParticipants,\n          noDeepCopy: true,\n          policyDefinitions,\n          tournamentRecord,\n          usePublishState,\n          drawDefinition,\n          publishStatus,\n          sortConfig,\n          event,\n        })\n      )\n    )\n    .map(({ structures, ...drawData }) => {\n      const filteredStructures = structures\n        ?.filter(\n          ({ stage, structureId }) =>\n            structureFilter({ structureId, drawId: drawData.drawId }) &&\n            stageFilter({ stage, drawId: drawData.drawId })\n        )\n        .map((structure) =>\n          roundLimitMapper({ drawId: drawData.drawId, structure })\n        );\n      return {\n        ...drawData,\n        structures: filteredStructures,\n      };\n    })\n    .filter((drawData) => drawData.structures?.length);\n\n  const { tournamentInfo } = getTournamentInfo({ tournamentRecord });\n  const venues = tournamentRecord.venues || [];\n  const venuesData = venues.map((venue) =>\n    (({ venueData }) => ({\n      ...venueData,\n    }))(\n      getVenueData({\n        tournamentRecord,\n        venueId: venue.venueId,\n      })\n    )\n  );\n\n  const eventInfo: any = (({\n    eventId,\n    eventName,\n    eventType,\n    eventLevel,\n    surfaceCategory,\n    matchUpFormat,\n    category,\n    gender,\n    startDate,\n    endDate,\n    ballType,\n    discipline,\n  }) => ({\n    eventId,\n    eventName,\n    eventType,\n    eventLevel,\n    surfaceCategory,\n    matchUpFormat,\n    category,\n    gender,\n    startDate,\n    endDate,\n    ballType,\n    discipline,\n  }))(event);\n\n  const eventData = {\n    tournamentInfo,\n    venuesData,\n    eventInfo,\n    drawsData,\n  };\n\n  eventData.eventInfo.publishState = publishState;\n  eventData.eventInfo.publish = publishStatus;\n\n  return { ...SUCCESS, eventData };\n}\n","import { getAppliedPolicies } from '../../query/extensions/getAppliedPolicies';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { modifyEventPublishStatus } from './modifyEventPublishStatus';\nimport { getEventPublishStatus } from '../../query/event/getEventPublishStatus';\nimport { addNotice } from '../../global/state/globalState';\nimport { getEventData } from '../../query/event/getEventData';\n\nimport { Event, Tournament } from '../../types/tournamentTypes';\nimport { PUBLISH_EVENT } from '../../constants/topicConstants';\nimport { PolicyDefinitions } from '../../types/factoryTypes';\nimport { PUBLIC } from '../../constants/timeItemConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  DRAW_DEFINITION_NOT_FOUND,\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n  STRUCTURE_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\nexport type PublishingDetail = {\n  roundLimit?: number; // only applicable to structureDetails\n  published?: boolean;\n  embargo?: string;\n};\n\nexport type DrawPublishingDetails = {\n  structureDetails?: { [key: string]: PublishingDetail }; // if no keys, all published\n  stageDetails?: { [key: string]: PublishingDetail }; // if no keys, all published; stage embargo supercedes structure embargo\n  publishingDetail: PublishingDetail; // draw embargo supercedes structure/stage embargo\n  structureIdsToRemove?: string[];\n  structureIdsToAdd?: string[];\n  stagesToRemove?: string[];\n  stagesToAdd?: string[];\n};\n\ntype PublishEventType = {\n  includePositionAssignments?: boolean;\n  policyDefinitions?: PolicyDefinitions;\n  removePriorValues?: boolean;\n  tournamentRecord: Tournament;\n  drawIds?: string[];\n  status?: string;\n  event?: Event;\n\n  drawDetails?: { [key: string]: DrawPublishingDetails }; // if no keys, all published\n\n  drawIdsToRemove?: string[];\n  drawIdsToAdd?: string[];\n};\n\nexport function publishEvent(params: PublishEventType) {\n  const {\n    includePositionAssignments,\n    removePriorValues,\n    tournamentRecord,\n    status = PUBLIC,\n    event,\n\n    drawIdsToRemove,\n    drawIdsToAdd,\n  } = params;\n\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n\n  // publishing will draw on scoring policy, round naming policy and participant (privacy) policy\n  const { appliedPolicies } = getAppliedPolicies({ tournamentRecord, event });\n  const policyDefinitions = {\n    ...appliedPolicies,\n    ...params.policyDefinitions,\n  };\n\n  const eventDrawIds = event.drawDefinitions?.map(({ drawId }) => drawId) ?? [];\n\n  const keyedDrawIds = params.drawDetails\n    ? Object.keys(params.drawDetails)\n    : [];\n  const specifiedDrawIds = keyedDrawIds.length ? [] : params.drawIds;\n\n  const drawIdsToValidate = (drawIdsToAdd ?? []).concat(\n    ...(drawIdsToRemove ?? []),\n    ...(specifiedDrawIds ?? []),\n    ...keyedDrawIds\n  );\n  const invalidDrawIds = drawIdsToValidate.filter(\n    (drawId) => !eventDrawIds.includes(drawId)\n  );\n  if (invalidDrawIds.length) {\n    return decorateResult({\n      result: { error: DRAW_DEFINITION_NOT_FOUND },\n      context: { invalidDrawIds },\n    });\n  }\n\n  const pubStatus = getEventPublishStatus({ event, status });\n\n  // filter out any drawIds that do not have corresponding drawDefinitions not in the event\n  const drawDetails = Object.keys(pubStatus?.drawDetails || {})\n    .filter((drawId) => eventDrawIds.includes(drawId))\n    .reduce((details: any, drawId) => {\n      details[drawId] = pubStatus.drawDetails[drawId];\n      return details;\n    }, {});\n\n  for (const drawId of eventDrawIds) {\n    if (!drawIdsToValidate.length || drawIdsToValidate.includes(drawId)) {\n      if (\n        drawIdsToRemove?.includes(drawId) ||\n        (specifiedDrawIds?.length && !specifiedDrawIds.includes(drawId))\n      ) {\n        drawDetails[drawId] = {\n          ...drawDetails[drawId],\n          publishingDetail: { published: false },\n        };\n      } else if (\n        drawIdsToAdd?.includes(drawId) ||\n        specifiedDrawIds?.includes(drawId) ||\n        !specifiedDrawIds?.length\n      ) {\n        drawDetails[drawId] = {\n          ...drawDetails[drawId],\n          publishingDetail: { published: true },\n        };\n      }\n    }\n\n    if (params.drawDetails?.[drawId]) {\n      const newDetail = params.drawDetails[drawId];\n      let structureDetails =\n        newDetail.structureDetails ?? drawDetails[drawId].structureDetails;\n      const stageDetails =\n        newDetail.stageDetails ?? drawDetails[drawId].stageDetails ?? {};\n\n      const {\n        structureIdsToRemove = [],\n        structureIdsToAdd = [],\n        publishingDetail = {},\n        stagesToRemove = [],\n        stagesToAdd = [],\n      } = newDetail;\n\n      if (structureIdsToAdd || stagesToAdd) publishingDetail.published = true;\n\n      drawDetails[drawId] = {\n        publishingDetail,\n        structureDetails,\n        stageDetails,\n      };\n\n      if (structureIdsToAdd.length || structureIdsToRemove.length) {\n        const drawStructureIds = (\n          event.drawDefinitions?.find(\n            (drawDefinition) => drawDefinition.drawId === drawId\n          )?.structures ?? []\n        ).map(({ structureId }) => structureId);\n        const structureIdsToValidate = (structureIdsToAdd ?? []).concat(\n          structureIdsToRemove ?? []\n        );\n        const invalidStructureIds = structureIdsToValidate.filter(\n          (structureId) => !drawStructureIds.includes(structureId)\n        );\n        if (invalidStructureIds.length) {\n          return decorateResult({\n            result: { error: STRUCTURE_NOT_FOUND },\n            context: { invalidStructureIds },\n          });\n        }\n\n        structureDetails = structureDetails ?? {};\n        for (const structureId of drawStructureIds) {\n          if (structureIdsToRemove.includes(structureId)) {\n            structureDetails[structureId] = { published: false };\n          } else {\n            structureDetails[structureId] = { published: true };\n          }\n        }\n\n        drawDetails[drawId].structureDetails = structureDetails;\n      }\n\n      const drawStages = (\n        event.drawDefinitions?.find(\n          (drawDefinition) => drawDefinition.drawId === drawId\n        )?.structures ?? []\n      ).map(({ stage }) => stage as string);\n\n      if (stagesToAdd.length) {\n        for (const stage of stagesToAdd) {\n          stageDetails[stage] = { published: true };\n        }\n\n        for (const stage of drawStages) {\n          if (!stageDetails[stage]) {\n            stageDetails[stage] = { published: false };\n          }\n        }\n      }\n      if (stagesToAdd.length || stagesToRemove.length) {\n        for (const stage of stagesToRemove) {\n          stageDetails[stage] = { published: false };\n        }\n\n        for (const stage of drawStages) {\n          if (!stageDetails[stage]) {\n            stageDetails[stage] = { published: true };\n          }\n        }\n      }\n\n      if (stagesToAdd.length || stagesToRemove.length) {\n        drawDetails[drawId].stageDetails = stageDetails;\n      }\n    }\n  }\n\n  modifyEventPublishStatus({\n    statusObject: { drawDetails },\n    removePriorValues,\n    status,\n    event,\n  });\n\n  const { eventData } = getEventData({\n    includePositionAssignments,\n    usePublishState: true,\n    tournamentRecord,\n    policyDefinitions,\n    event,\n  });\n\n  addNotice({\n    payload: { eventData, tournamentId: tournamentRecord.tournamentId },\n    topic: PUBLISH_EVENT,\n  });\n\n  return { ...SUCCESS, eventData };\n}\n","export const DELETE_DRAW_DEFINITIONS = 'deleteDrawDefinitions';\nexport const AUTO_SCHEDULING_AUDIT = 'autoSchedulingAudit';\nexport const DELETE_EVENTS = 'deleteEvents';\n\nexport const auditConstants = {\n  AUTO_SCHEDULING_AUDIT,\n  DELETE_EVENTS,\n  DELETE_DRAW_DEFINITIONS,\n};\n\nexport default auditConstants;\n","import { getPositionAssignments } from '../../query/structure/getPositionAssignments';\nimport { checkAndUpdateSchedulingProfile } from '../tournaments/schedulingProfile';\nimport { getEventPublishStatus } from '../../query/event/getEventPublishStatus';\nimport { getAppliedPolicies } from '../../query/extensions/getAppliedPolicies';\nimport { checkScoreHasValue } from '../../query/matchUp/checkScoreHasValue';\nimport { allDrawMatchUps } from '../../query/matchUps/getAllDrawMatchUps';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { modifyEventPublishStatus } from './modifyEventPublishStatus';\nimport { addEventExtension } from '../extensions/addRemoveExtensions';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { getDrawStructures } from '../../acquire/findStructure';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { addNotice } from '../../global/state/globalState';\nimport { addExtension } from '../extensions/addExtension';\nimport { findExtension } from '../../acquire/findExtension';\nimport { findEvent } from '../../acquire/findEvent';\nimport { publishEvent } from './publishEvent';\nimport {\n  deleteDrawNotice,\n  deleteMatchUpsNotice,\n} from '../notifications/drawNotifications';\n\nimport { STRUCTURE_SELECTED_STATUSES } from '../../constants/entryStatusConstants';\nimport { DELETE_DRAW_DEFINITIONS } from '../../constants/auditConstants';\nimport { POLICY_TYPE_SCORING } from '../../constants/policyConstants';\nimport { Event, Tournament } from '../../types/tournamentTypes';\nimport { PolicyDefinitions } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { AUDIT } from '../../constants/topicConstants';\nimport {\n  MISSING_TOURNAMENT_RECORD,\n  SCORES_PRESENT,\n} from '../../constants/errorConditionConstants';\nimport { MAIN, QUALIFYING } from '../../constants/drawDefinitionConstants';\nimport {\n  DRAW_DELETIONS,\n  FLIGHT_PROFILE,\n} from '../../constants/extensionConstants';\n\ntype DeleteDrawDefinitionArgs = {\n  policyDefinitions?: PolicyDefinitions;\n  tournamentRecord: Tournament;\n  autoPublish?: boolean;\n  drawIds?: string[];\n  auditData?: any;\n  eventId?: string;\n  force?: boolean;\n  event?: Event;\n};\nexport function deleteDrawDefinitions(params: DeleteDrawDefinitionArgs) {\n  if (!params.tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  const stack = 'deleteDrawDefinitions';\n\n  let drawIds = params.drawIds ?? [];\n  let event = params.event;\n  const {\n    autoPublish = true,\n    tournamentRecord,\n    auditData,\n    eventId,\n    force,\n  } = params;\n\n  const { appliedPolicies } = getAppliedPolicies({ tournamentRecord, event });\n  const policyDefinitions = { ...appliedPolicies, ...params.policyDefinitions };\n\n  const drawId = Array.isArray(drawIds) ? drawIds[0] : undefined;\n\n  if (!event) {\n    const result = findEvent({ tournamentRecord, eventId, drawId });\n    if (result.error) return result;\n    event = result.event;\n  }\n\n  const deletedDrawsDetail: any[] = [];\n  const matchUpIds: string[] = [];\n  const auditTrail: any[] = [];\n\n  if (!event?.drawDefinitions)\n    return decorateResult({\n      info: 'event has no drawDefinition',\n      result: { ...SUCCESS },\n      stack,\n    });\n\n  const eventDrawIds = event.drawDefinitions.map(({ drawId }) => drawId);\n  // if drawIds were not provided, assume that the intent is to delete all drawDefinitions\n  if (!drawIds.length) drawIds = eventDrawIds;\n\n  drawIds = drawIds.filter((drawId) => eventDrawIds.includes(drawId));\n\n  if (!drawIds.length)\n    return decorateResult({\n      info: 'nothing to do; no matching drawIds in event.',\n      result: { ...SUCCESS },\n      stack,\n    });\n\n  const flightProfile = makeDeepCopy(\n    getFlightProfile({ event }).flightProfile,\n    false,\n    true\n  );\n\n  const positionAssignmentMap = ({\n    participantId,\n    drawPosition,\n    qualifier,\n    bye,\n  }) => ({ bye, qualifier, drawPosition, participantId });\n\n  const allowDeletionWithScoresPresent =\n    force ??\n    appliedPolicies?.[POLICY_TYPE_SCORING]?.allowDeletionWithScoresPresent\n      ?.drawDefinitions;\n\n  const publishStatus = getEventPublishStatus({ event }) ?? {};\n\n  let updatedDrawIds =\n    publishStatus.drawIds ??\n    (publishStatus.drawDetails && Object.keys(publishStatus.drawDetails)) ??\n    [];\n  let publishedDrawsDeleted;\n\n  const drawIdsWithScoresPresent: string[] = [];\n  const filteredDrawDefinitions = event.drawDefinitions.filter(\n    (drawDefinition) => {\n      if (drawIds.includes(drawDefinition.drawId)) {\n        const matchUps =\n          allDrawMatchUps({ event, drawDefinition })?.matchUps ?? [];\n\n        const scoresPresent = matchUps.some(({ score }) =>\n          checkScoreHasValue({ score })\n        );\n        if (scoresPresent && !allowDeletionWithScoresPresent) {\n          drawIdsWithScoresPresent.push(drawDefinition.drawId);\n          return true;\n        }\n\n        const { drawId, drawType, drawName } = drawDefinition;\n        const flight = flightProfile?.flights?.find(\n          (flight) => flight.drawId === drawDefinition.drawId\n        );\n\n        if (flight) {\n          flight.drawEntries = flight.drawEntries?.filter((entry) =>\n            STRUCTURE_SELECTED_STATUSES.includes(entry.entryStatus)\n          );\n        }\n\n        if (updatedDrawIds.includes(drawId)) {\n          updatedDrawIds = updatedDrawIds.filter((id) => id !== drawId);\n          publishedDrawsDeleted = true;\n        }\n\n        const mainStructure = getDrawStructures({\n          stageSequence: 1,\n          drawDefinition,\n          stage: MAIN,\n        })?.structures?.[0];\n\n        const pa: any = mainStructure\n          ? getPositionAssignments({\n              structureId: mainStructure.structureId,\n              tournamentRecord,\n              drawDefinition,\n            })\n          : undefined;\n\n        const positionAssignments = pa?.positionAssignments?.map(\n          positionAssignmentMap\n        );\n\n        const qualifyingStructures = getDrawStructures({\n          stage: QUALIFYING,\n          drawDefinition,\n        })?.structures;\n\n        const qualifyingPositionAssignments = qualifyingStructures?.length\n          ? qualifyingStructures.map((qualifyingStructure) => {\n              const stageSequence = qualifyingStructure.stageSequence;\n              const pa: any = getPositionAssignments({\n                structureId: qualifyingStructure.structureId,\n                tournamentRecord,\n                drawDefinition,\n              });\n              const positionAssignments = pa?.positionAssignments.map(\n                positionAssignmentMap\n              );\n              return { positionAssignments, stageSequence };\n            })\n          : undefined;\n\n        // TODO: conditionally add auditTrail based on policyDefinitions\n        const audit = {\n          action: DELETE_DRAW_DEFINITIONS,\n          payload: {\n            drawDefinitions: [drawDefinition],\n            eventId: eventId ?? event?.eventId,\n            auditData,\n          },\n        };\n        auditTrail.push(audit);\n\n        deletedDrawsDetail.push(\n          definedAttributes({\n            tournamentId: tournamentRecord.tournamentId,\n            eventId: eventId ?? event?.eventId,\n            qualifyingPositionAssignments,\n            positionAssignments,\n            auditData,\n            drawType,\n            drawName,\n            drawId,\n          })\n        );\n        matchUps?.forEach(({ matchUpId }) => matchUpIds.push(matchUpId));\n      }\n      return !drawIds.includes(drawDefinition.drawId);\n    }\n  );\n\n  if (drawIdsWithScoresPresent.length && !force) {\n    return decorateResult({\n      context: { drawIdsWithScoresPresent },\n      result: { error: SCORES_PRESENT },\n      stack,\n    });\n  }\n\n  event.drawDefinitions = filteredDrawDefinitions;\n\n  if (flightProfile) {\n    const extension = {\n      name: FLIGHT_PROFILE,\n      value: flightProfile,\n    };\n\n    addEventExtension({ event, extension });\n  }\n\n  // cleanup references to drawId in schedulingProfile extension\n  checkAndUpdateSchedulingProfile({ tournamentRecord });\n\n  if (publishedDrawsDeleted) {\n    const drawDetails = {};\n    for (const drawId of updatedDrawIds) {\n      drawDetails[drawId] = publishStatus.drawDetails?.[drawId] ?? {\n        published: true,\n      };\n    }\n    const result = modifyEventPublishStatus({\n      statusObject: { drawDetails },\n      event,\n    });\n    if (result.error) return { error: result.error };\n  }\n\n  if (auditTrail.length) {\n    addNotice({ topic: AUDIT, payload: auditTrail });\n  }\n  if (matchUpIds.length) {\n    deleteMatchUpsNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      matchUpIds,\n    });\n  }\n\n  drawIds.forEach((drawId) => {\n    deleteDrawNotice({ drawId });\n  });\n\n  addDrawDeletionTelemetry({ event, deletedDrawsDetail, auditData });\n\n  if (autoPublish && publishedDrawsDeleted) {\n    const result = publishEvent({\n      drawIdsToRemove: drawIds,\n      policyDefinitions,\n      tournamentRecord,\n      event,\n    });\n    if (result.error) return { ...SUCCESS, info: result.error };\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction addDrawDeletionTelemetry({ event, deletedDrawsDetail, auditData }) {\n  const { extension } = findExtension({\n    name: DRAW_DELETIONS,\n    element: event,\n  });\n\n  const deletionData = { ...auditData, deletedDrawsDetail };\n  const updatedExtension = {\n    name: DRAW_DELETIONS,\n    value: Array.isArray(extension?.value)\n      ? extension?.value.concat(deletionData)\n      : [deletionData],\n  };\n  addExtension({ element: event, extension: updatedExtension });\n}\n","export function getMatchUp({ matchUps, matchUpId }) {\n  const matchUp = (matchUps || []).find(\n    (matchUp) => matchUp.matchUpId === matchUpId\n  );\n\n  return { matchUp };\n}\n","import { getAllStructureMatchUps } from '../query/matchUps/getAllStructureMatchUps';\nimport { getContextContent } from '../query/hierarchical/getContextContent';\nimport { getMatchUp } from '../query/matchUps/getMatchUpFromMatchUps';\nimport { MatchUpsMap } from '../query/matchUps/getMatchUpsMap';\nimport { makeDeepCopy } from '../utilities/makeDeepCopy';\nimport { getDrawStructures } from './findStructure';\n\nimport { ContextContent, ContextProfile } from '../types/factoryTypes';\nimport { HydratedMatchUp } from '../types/hydrated';\nimport {\n  ErrorType,\n  INVALID_VALUES,\n  MATCHUP_NOT_FOUND,\n  MISSING_DRAW_DEFINITION,\n  MISSING_MATCHUP_ID,\n} from '../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Participant,\n  Structure,\n} from '../types/tournamentTypes';\n\n/*\n  public version of findMatchUp\n*/\nexport function publicFindDrawMatchUp(params) {\n  Object.assign(params, { inContext: true });\n  return {\n    matchUp: makeDeepCopy(findDrawMatchUp(params).matchUp, false, true),\n  };\n}\n\ntype FindDrawMatchUpArgs = {\n  tournamentParticipants?: Participant[];\n  context?: { [key: string]: any };\n  contextContent?: ContextContent;\n  contextProfile?: ContextProfile;\n  afterRecoveryTimes?: boolean;\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  inContext?: boolean;\n  matchUpId: string;\n  event?: Event;\n};\n\nexport function findDrawMatchUp({\n  tournamentParticipants,\n  afterRecoveryTimes,\n  contextContent,\n  contextProfile,\n  drawDefinition,\n  matchUpsMap,\n  matchUpId,\n  inContext,\n  context,\n  event,\n}: FindDrawMatchUpArgs): {\n  matchUp?: HydratedMatchUp;\n  structure?: Structure;\n  error?: ErrorType;\n} {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n  if (typeof matchUpId !== 'string') return { error: INVALID_VALUES };\n\n  const { structures = [] } = getDrawStructures({ drawDefinition });\n\n  if (contextProfile && !contextContent)\n    contextContent = getContextContent({ contextProfile, drawDefinition });\n\n  for (const structure of structures) {\n    const { matchUps } = getAllStructureMatchUps({\n      tournamentParticipants,\n      afterRecoveryTimes,\n      contextContent,\n      drawDefinition,\n      contextProfile,\n      matchUpsMap,\n      inContext,\n      structure,\n      context,\n      event,\n    });\n    const { matchUp } = getMatchUp({ matchUps, matchUpId });\n\n    if (matchUp) return { matchUp, structure };\n  }\n\n  return { error: MATCHUP_NOT_FOUND };\n}\n","import { getMappedStructureMatchUps } from '../../../query/matchUps/getMatchUpsMap';\n\nimport {\n  DOUBLE_DEFAULT,\n  DOUBLE_WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\n\nexport function getPairedPreviousMatchUpIsDoubleExit(params) {\n  let { sourceMatchUp } = params;\n  const { targetMatchUp, structure, matchUpsMap, drawPosition } = params;\n\n  const previousRoundNumber =\n    targetMatchUp.roundNumber > 1 && targetMatchUp.roundNumber - 1;\n\n  const structureMatchUps = getMappedStructureMatchUps({\n    structureId: structure.structureId,\n    matchUpsMap,\n  });\n\n  if (!sourceMatchUp && drawPosition) {\n    sourceMatchUp = structureMatchUps.find(\n      ({ drawPositions, roundNumber }) =>\n        roundNumber === previousRoundNumber &&\n        drawPositions?.includes(drawPosition)\n    );\n  }\n\n  // look for paired round position in previous round\n  // missing sourceMatchUp causes pairedRoundPosition to be NaN, which is OK\n  const sourceRoundPosition = sourceMatchUp?.roundPosition;\n  const offset = sourceRoundPosition % 2 ? 1 : -1;\n  const pairedRoundPosition = sourceRoundPosition + offset;\n  const pairedPreviousMatchUp =\n    previousRoundNumber &&\n    structureMatchUps.find(\n      ({ roundNumber, roundPosition }) =>\n        roundNumber === previousRoundNumber &&\n        roundPosition === pairedRoundPosition\n    );\n\n  const pairedPreviousMatchUpStatus = pairedPreviousMatchUp?.matchUpStatus;\n  const pairedPreviousMatchUpIsDoubleExit = [\n    DOUBLE_WALKOVER,\n    DOUBLE_DEFAULT,\n  ].includes(pairedPreviousMatchUpStatus);\n\n  return { pairedPreviousMatchUp, pairedPreviousMatchUpIsDoubleExit };\n}\n","import { getMappedStructureMatchUps } from '../../../query/matchUps/getMatchUpsMap';\n\nexport function getPairedPreviousMatchUp({\n  structureId,\n  matchUpsMap,\n  matchUp,\n}) {\n  const sourceRoundPosition = matchUp?.roundPosition;\n  const offset = sourceRoundPosition % 2 ? 1 : -1;\n  const pairedRoundPosition = sourceRoundPosition + offset;\n  const structureMatchUps = getMappedStructureMatchUps({\n    matchUpsMap,\n    structureId,\n  });\n  const pairedPreviousMatchUp = structureMatchUps.find(\n    ({ roundNumber, roundPosition }) =>\n      roundNumber === matchUp?.roundNumber &&\n      roundPosition === pairedRoundPosition\n  );\n  return { pairedPreviousMatchUp };\n}\n","import { getPairedPreviousMatchUp } from '../positionGovernor/getPairedPreviousMatchup';\nimport { isString } from '../../../utilities/objects';\n\nimport { MatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { MatchUp } from '../../../types/tournamentTypes';\n\ntype UpdateMatchUpStatusCodesArgs = {\n  inContextDrawMatchUps: any[];\n  sourceMatchUpStatus?: string;\n  matchUpsMap: MatchUpsMap;\n  sourceMatchUpId?: string;\n  matchUp: MatchUp;\n};\n\nexport function updateMatchUpStatusCodes({\n  inContextDrawMatchUps,\n  sourceMatchUpStatus,\n  sourceMatchUpId,\n  matchUpsMap,\n  matchUp,\n}: UpdateMatchUpStatusCodesArgs): undefined {\n  // find sourceMatchUp and matchUp paired with sourceMatchUp to workout sourceSideNumber\n  const sourceMatchUp = inContextDrawMatchUps.find(\n    (matchUp) => matchUp.matchUpId === sourceMatchUpId\n  );\n  const { pairedPreviousMatchUp } = getPairedPreviousMatchUp({\n    structureId: sourceMatchUp?.structureId,\n    matchUp: sourceMatchUp,\n    matchUpsMap,\n  });\n  if (sourceMatchUp && pairedPreviousMatchUp) {\n    const pairedPreviousMatchUpId = pairedPreviousMatchUp?.matchUpId;\n    const pairedMatchUp = inContextDrawMatchUps.find(\n      (matchUp) => matchUp.matchUpId === pairedPreviousMatchUpId\n    );\n    const sourceSideNumber =\n      sourceMatchUp?.structureId === pairedMatchUp?.structureId\n        ? // if structureIds are equivalent then sideNumber is inferred from roundPositions\n          (sourceMatchUp?.roundPosition < pairedMatchUp?.roundPosition && 1) ||\n          2\n        : // if different structureIds then structureId that is not equivalent to noContextWinnerMatchUp.structureId is fed\n          // ... and fed positions are always sideNumber 1\n          (sourceMatchUp.structureId === pairedMatchUp?.structureId && 2) || 1;\n\n    matchUp.matchUpStatusCodes = (matchUp.matchUpStatusCodes ?? []).map(\n      (code) => {\n        const value = isString(code) || !isNaN(code) ? { code } : code;\n        if (value.sideNumber === sourceSideNumber) {\n          return { ...value, previousMatchUpStatus: sourceMatchUpStatus };\n        }\n        return value;\n      }\n    );\n  }\n}\n","export function getExitWinningSide({\n  inContextDrawMatchUps,\n  drawPosition,\n  matchUpId,\n}) {\n  // determine which sideNumber { drawPosition } will be and assign winningSide\n  // NOTE: at present this is dependent on presence of .winnerMatchUpId and .loserMatchUpId\n  // TODO: reusable function that will be able to use position targeting using links\n  // which will need to filter by previous round then get positionTargets for each matchUp in the round\n\n  const sourceMatchUps = inContextDrawMatchUps\n    .filter(\n      ({ winnerMatchUpId, loserMatchUpId }) =>\n        loserMatchUpId === matchUpId || winnerMatchUpId === matchUpId\n    )\n    // sourceMatchUps MUST be sorted by roundPosition\n    .sort((a, b) => a.roundPosition - b.roundPosition);\n\n  const matchUp = inContextDrawMatchUps.find(\n    (matchUp) => matchUp.matchUpId === matchUpId\n  );\n  const feedRound = matchUp.feedRound;\n\n  return feedRound\n    ? 1\n    : sourceMatchUps.reduce((sideNumber, sourceMatchUp, index) => {\n        if (sourceMatchUp.drawPositions?.includes(drawPosition))\n          return index + 1;\n        return sideNumber;\n      }, undefined);\n}\n","import { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { findExtension } from '../../../acquire/findExtension';\n\nimport { LINEUPS } from '../../../constants/extensionConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  DrawDefinition,\n  Event,\n  MatchUp,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype UpdateSideLineUpArgs = {\n  inContextTargetMatchUp?: HydratedMatchUp;\n  drawPositionSideIndex: number;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  teamParticipantId: string;\n  matchUp: MatchUp;\n  event?: Event;\n};\n\nexport function updateSideLineUp({\n  inContextTargetMatchUp,\n  drawPositionSideIndex,\n  teamParticipantId,\n  tournamentRecord,\n  drawDefinition,\n  matchUp,\n  event,\n}: UpdateSideLineUpArgs) {\n  // update matchUp.sides to include lineUps\n  const drawPositionSideNumber =\n    inContextTargetMatchUp?.sides?.[drawPositionSideIndex]?.sideNumber;\n\n  const sideExists =\n    drawPositionSideNumber &&\n    matchUp.sides?.find((side) => side.sideNumber === drawPositionSideNumber);\n\n  const { extension: existingExtension } = findExtension({\n    element: drawDefinition,\n    name: LINEUPS,\n  });\n\n  const lineUps = existingExtension?.value || {};\n  const lineUp = makeDeepCopy(lineUps[teamParticipantId], false, true);\n\n  if (sideExists) {\n    matchUp?.sides?.forEach((side) => {\n      if (side.sideNumber === drawPositionSideNumber) {\n        side.lineUp = lineUp;\n      }\n    });\n  } else {\n    matchUp.sides = [1, 2].map((sideNumber) => {\n      const existingSide =\n        matchUp.sides?.find((side) => side.sideNumber === sideNumber) ?? {};\n      return { ...existingSide, sideNumber };\n    });\n\n    const targetSide = matchUp.sides.find(\n      (side) => side.sideNumber === drawPositionSideNumber\n    );\n    if (targetSide) targetSide.lineUp = lineUp;\n  }\n\n  modifyMatchUpNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    context: 'updateSidLineUp',\n    eventId: event?.eventId,\n    drawDefinition,\n    matchUp,\n  });\n}\n","import { getPairedPreviousMatchUpIsDoubleExit } from '../../drawDefinitions/positionGovernor/getPairedPreviousMatchUpIsDoubleExit';\nimport { getUpdatedDrawPositions } from '../../drawDefinitions/matchUpGovernor/getUpdatedDrawPositions';\nimport { updateMatchUpStatusCodes } from '../../drawDefinitions/matchUpGovernor/matchUpStatusCodes';\nimport { getExitWinningSide } from '../../drawDefinitions/matchUpGovernor/getExitWinningSide';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { assignDrawPositionBye } from './assignDrawPositionBye';\nimport { updateSideLineUp } from '../lineUps/updateSideLineUp';\nimport { positionTargets } from './positionTargets';\nimport { overlap } from '../../../utilities/arrays';\nimport {\n  MatchUpsMap,\n  getMappedStructureMatchUps,\n  getMatchUpsMap,\n} from '../../../query/matchUps/getMatchUpsMap';\n\nimport { FIRST_MATCHUP } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport { TEAM } from '../../../constants/matchUpTypes';\nimport {\n  DRAW_POSITION_ASSIGNED,\n  STRUCTURE_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\nimport {\n  BYE,\n  COMPLETED,\n  DEFAULTED,\n  DOUBLE_DEFAULT,\n  DOUBLE_WALKOVER,\n  RETIRED,\n  TO_BE_PLAYED,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype AssignMatchUpDrawPositionArgs = {\n  inContextDrawMatchUps: HydratedMatchUp[];\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  sourceMatchUpStatus?: string;\n  matchUpsMap?: MatchUpsMap;\n  sourceMatchUpId?: string;\n  matchUpStatus?: string;\n  drawPosition: number;\n  matchUpId: string;\n  event?: Event;\n};\nexport function assignMatchUpDrawPosition({\n  inContextDrawMatchUps,\n  sourceMatchUpStatus,\n  tournamentRecord,\n  sourceMatchUpId,\n  drawDefinition,\n  matchUpStatus,\n  drawPosition,\n  matchUpsMap,\n  matchUpId,\n  event,\n}: AssignMatchUpDrawPositionArgs) {\n  const stack = 'assignMatchUpDrawPosition';\n\n  if (!matchUpsMap) {\n    matchUpsMap = getMatchUpsMap({ drawDefinition });\n  }\n\n  if (!inContextDrawMatchUps) {\n    inContextDrawMatchUps =\n      getAllDrawMatchUps({\n        inContext: true,\n        drawDefinition,\n        matchUpsMap,\n      }).matchUps ?? [];\n  }\n\n  const inContextMatchUp = inContextDrawMatchUps.find(\n    (m) => m.matchUpId === matchUpId\n  );\n  const structureId = inContextMatchUp?.structureId;\n  const structure = drawDefinition?.structures?.find(\n    (structure) => structure.structureId === structureId\n  );\n\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  const matchUp = matchUpsMap?.drawMatchUps?.find(\n    (matchUp) => matchUp.matchUpId === matchUpId\n  );\n\n  const drawPositions: number[] = matchUp?.drawPositions ?? [];\n  const { positionAdded, positionAssigned, updatedDrawPositions } =\n    getUpdatedDrawPositions({ drawPosition, drawPositions });\n\n  const { positionAssignments } = getPositionAssignments({\n    drawDefinition,\n    structure,\n  });\n\n  const matchUpAssignments = positionAssignments?.filter((assignment) =>\n    updatedDrawPositions.includes(assignment.drawPosition)\n  );\n  const isByeMatchUp = matchUpAssignments?.find(({ bye }) => bye);\n  const isDoubleExitExit =\n    matchUp?.matchUpStatus &&\n    [WALKOVER, DEFAULTED].includes(matchUp.matchUpStatus) &&\n    updatedDrawPositions.filter(Boolean).length < 2;\n\n  matchUpStatus =\n    (isByeMatchUp && BYE) ||\n    matchUpStatus ||\n    (isDoubleExitExit && matchUp.matchUpStatus) ||\n    (matchUp?.matchUpStatus &&\n      [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUp.matchUpStatus) &&\n      matchUp.matchUpStatus) ||\n    TO_BE_PLAYED;\n\n  if (matchUp && positionAdded) {\n    // necessary to update inContextDrawMatchUps\n    inContextDrawMatchUps =\n      getAllDrawMatchUps({\n        inContext: true,\n        drawDefinition,\n        matchUpsMap,\n      }).matchUps ?? [];\n    const exitWinningSide =\n      (isDoubleExitExit &&\n        getExitWinningSide({\n          inContextDrawMatchUps,\n          drawPosition,\n          matchUpId,\n        })) ||\n      undefined;\n\n    if (matchUp?.matchUpStatusCodes) {\n      updateMatchUpStatusCodes({\n        inContextDrawMatchUps,\n        sourceMatchUpStatus,\n        sourceMatchUpId,\n        matchUpsMap,\n        matchUp,\n      });\n    }\n\n    // only in the case of \"Double Exit\" produced \"Exit\" can a winningSide be assigned at the same time as a position\n    Object.assign(matchUp, {\n      drawPositions: updatedDrawPositions,\n      winningSide: exitWinningSide,\n      matchUpStatus,\n    });\n\n    modifyMatchUpNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      eventId: inContextMatchUp?.eventId,\n      context: stack,\n      drawDefinition,\n      matchUp,\n    });\n  }\n\n  const targetData = positionTargets({\n    inContextDrawMatchUps,\n    inContextMatchUp,\n    drawDefinition,\n    matchUpId,\n  });\n  const {\n    targetMatchUps: { winnerMatchUp, loserMatchUp, loserTargetDrawPosition },\n    targetLinks: { loserTargetLink },\n  } = targetData;\n\n  const structureMatchUps = getMappedStructureMatchUps({\n    structureId: structure.structureId,\n    matchUpsMap,\n  });\n\n  if (positionAssigned && isByeMatchUp) {\n    if (winnerMatchUp) {\n      if ([BYE, DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUpStatus)) {\n        const result = assignMatchUpDrawPosition({\n          matchUpId: winnerMatchUp.matchUpId,\n          inContextDrawMatchUps,\n          tournamentRecord,\n          drawDefinition,\n          drawPosition,\n          matchUpsMap,\n        });\n        if (result.error) return result;\n      } else {\n        const { structureId } = winnerMatchUp;\n        if (structureId !== structure.structureId) {\n          console.log(\n            'winnerMatchUp in different structure... participant is in different targetDrawPosition'\n          );\n        }\n      }\n    }\n  } else if (winnerMatchUp && inContextMatchUp && !inContextMatchUp.feedRound) {\n    const { pairedPreviousMatchUpIsDoubleExit } =\n      getPairedPreviousMatchUpIsDoubleExit({\n        targetMatchUp: matchUp,\n        drawPosition,\n        matchUpsMap,\n        structure,\n      });\n\n    if (pairedPreviousMatchUpIsDoubleExit) {\n      const result = assignMatchUpDrawPosition({\n        matchUpId: winnerMatchUp.matchUpId,\n        inContextDrawMatchUps,\n        tournamentRecord,\n        drawDefinition,\n        drawPosition,\n        matchUpsMap,\n      });\n      if (result.error) return result;\n    }\n  }\n\n  // if { matchUpType: TEAM } then also assign the default lineUp to the appopriate side\n  if (matchUp?.matchUpType === TEAM) {\n    const inContextTargetMatchUp = inContextDrawMatchUps?.find(\n      ({ matchUpId }) => matchUpId === matchUp.matchUpId\n    );\n    const sides: any[] = inContextTargetMatchUp?.sides ?? [];\n    const drawPositionSideIndex = sides.reduce(\n      (index, side, i) => (side.drawPosition === drawPosition ? i : index),\n      undefined\n    );\n    const teamParticipantId = positionAssignments?.find(\n      (assignment) => assignment.drawPosition === drawPosition\n    )?.participantId;\n\n    if (teamParticipantId && drawPositionSideIndex !== undefined) {\n      updateSideLineUp({\n        inContextTargetMatchUp,\n        drawPositionSideIndex,\n        teamParticipantId,\n        tournamentRecord,\n        drawDefinition,\n        matchUp,\n      });\n    }\n  }\n\n  // if FIRST_MATCH_LOSER_CONSOLATION, check whether a BYE should be placed in consolation feed\n  if (\n    loserTargetLink?.linkCondition === FIRST_MATCHUP &&\n    updatedDrawPositions.filter(Boolean).length === 2 &&\n    !isByeMatchUp\n  ) {\n    const firstRoundMatchUps = structureMatchUps.filter(\n      ({ drawPositions, roundNumber }) =>\n        roundNumber === 1 && overlap(drawPositions, updatedDrawPositions)\n    );\n    const byePropagation = firstRoundMatchUps.every(({ matchUpStatus }) =>\n      [COMPLETED, RETIRED].includes(matchUpStatus)\n    );\n    if (byePropagation && loserMatchUp) {\n      const { structureId } = loserMatchUp;\n      const result = assignDrawPositionBye({\n        drawPosition: loserTargetDrawPosition,\n        tournamentRecord,\n        drawDefinition,\n        structureId,\n        matchUpsMap,\n        event,\n      });\n      if (result.error) return result;\n    }\n  }\n\n  if (positionAssigned) {\n    return { ...SUCCESS };\n  } else {\n    return decorateResult({\n      result: { error: DRAW_POSITION_ASSIGNED },\n      context: { drawPosition },\n      stack,\n    });\n  }\n}\n","import { numericSort } from '../../../utilities/sorting';\n\n/**\n * ensures that a matchUp has 2 and only 2 drawPositions\n * Checks to see whether drawPosition is already present in drawPositions\n * Does NOT allow a position to be assigned if there are already 2 drawPositions\n */\ntype GetUpdateDrawPositions = {\n  drawPositions: number[];\n  drawPosition: number;\n};\nexport function getUpdatedDrawPositions({\n  drawPosition,\n  drawPositions,\n}: GetUpdateDrawPositions): {\n  updatedDrawPositions: number[];\n  positionAssigned: boolean;\n  positionAdded: boolean;\n} {\n  let positionAdded = false;\n  let positionAssigned = !!drawPositions?.includes(drawPosition);\n  const updated = positionAssigned\n    ? drawPositions || []\n    : [...drawPositions, undefined, undefined]\n        .slice(0, 2) // accounts for empty array, should always have length 2\n        .map((position) => {\n          if (!position && !positionAssigned) {\n            positionAssigned = true;\n            positionAdded = true;\n            return drawPosition;\n          } else {\n            return position;\n          }\n        })\n        .sort(numericSort)\n        .filter(Boolean);\n  const updatedDrawPositions = updated as number[];\n\n  return { updatedDrawPositions, positionAdded, positionAssigned };\n}\n","import { numericSort } from '../../../../../utilities/sorting';\nimport { unique } from '../../../../../utilities/arrays';\n\nexport function getRoundRobinGroupMatchUps({ drawPositions }) {\n  const positionMatchUps = (position) => {\n    return drawPositions\n      .filter((p) => p !== position)\n      .map((o) => [position, o]);\n  };\n  const groupMatchUps = [].concat(...drawPositions.map(positionMatchUps));\n\n  const uniqueMatchUpGroupings = unique(\n    groupMatchUps.map(drawPositionsHash)\n  ).map((h) => h.split('|').map((p) => +p));\n\n  return { groupMatchUps, uniqueMatchUpGroupings };\n}\n\nexport function drawPositionsHash(drawPositions) {\n  return [...drawPositions].sort(numericSort).join('|');\n}\n\nexport function groupRounds({ groupSize, drawPositionOffset }) {\n  const numArr = (count) => [...Array(count)].map((_, i) => i);\n  const groupPositions: number[] = numArr(\n    2 * Math.round(groupSize / 2) + 1\n  ).slice(1);\n  const rounds: any[] = numArr(groupPositions.length - 1).map(() => []);\n\n  let aRow = groupPositions.slice(0, groupPositions.length / 2);\n  let bRow = groupPositions.slice(groupPositions.length / 2);\n\n  groupPositions.slice(1).forEach((_, i) => {\n    aRow.forEach((_, j) => {\n      rounds[i].push([aRow[j], bRow[j]]);\n    });\n    const aHead = aRow.shift();\n    const aDown = aRow.pop();\n    const bUp = bRow.shift();\n    aRow = [aHead, bUp, ...aRow].filter(Boolean) as number[];\n    bRow = [...bRow, aDown].filter(Boolean) as number[];\n  });\n\n  const aHead = aRow.shift();\n  const aDown = aRow.pop();\n  const bUp = bRow.shift();\n  aRow = [aHead, bUp, ...aRow].filter(Boolean) as number[];\n  bRow = [...bRow, aDown].filter(Boolean) as number[];\n\n  const sum = (x) => x[0].reduce((a, b) => a + b);\n  return [...rounds]\n    .reverse()\n    .sort((a, b) => sum(a) - sum(b))\n    .map((round) =>\n      round\n        .filter((groupPositions) =>\n          groupPositions.every((position) => position <= groupSize)\n        )\n        .map((groupPositions) => {\n          const drawPositions = groupPositions.map(\n            (groupPosition) => groupPosition + drawPositionOffset\n          );\n          return drawPositionsHash(drawPositions);\n        })\n    );\n}\n\nexport function determineRoundNumber({ rounds, hash }) {\n  return rounds.reduce(\n    (p, round, i) => (round.includes(hash) ? i + 1 : p),\n    undefined\n  );\n}\n\nexport const roundRobinGroups = {\n  getRoundRobinGroupMatchUps,\n  determineRoundNumber,\n  drawPositionsHash,\n  groupRounds,\n};\n","import { addExtension } from '../../../../../mutate/extensions/addExtension';\nimport { structureTemplate } from '../../../templates/structureTemplate';\nimport { constantToString } from '../../../../../utilities/strings';\nimport { generateRange } from '../../../../../utilities/arrays';\nimport { UUID } from '../../../../../utilities/UUID';\nimport {\n  getRoundRobinGroupMatchUps,\n  drawPositionsHash,\n  groupRounds,\n} from './roundRobinGroups';\n\nimport { MatchUp, EventTypeUnion } from '../../../../../types/tournamentTypes';\nimport { ResultType } from '../../../../../global/functions/decorateResult';\nimport { ROUND_TARGET } from '../../../../../constants/extensionConstants';\nimport { SUCCESS } from '../../../../../constants/resultConstants';\nimport {\n  BYE,\n  TO_BE_PLAYED,\n} from '../../../../../constants/matchUpStatusConstants';\nimport {\n  MAIN,\n  ITEM,\n  WIN_RATIO,\n  CONTAINER,\n} from '../../../../../constants/drawDefinitionConstants';\nimport {\n  PlayoffAttributes,\n  PolicyDefinitions,\n  SeedingProfile,\n} from '../../../../../types/factoryTypes';\n\ntype GenerateRoundRobinArgs = {\n  playoffAttributes?: PlayoffAttributes;\n  appliedPolicies?: PolicyDefinitions;\n  seedingProfile?: SeedingProfile;\n  groupNameBase?: string;\n  structureName?: string;\n  stageSequence?: number;\n  structureOptions?: any;\n  matchUpType?: EventTypeUnion;\n  groupNames?: string[];\n  roundTarget?: number;\n  structureId?: string;\n  drawSize: number;\n  idPrefix?: string;\n  isMock?: boolean;\n  uuids?: string[];\n  stage?: string;\n};\n\nexport function generateRoundRobin(params: GenerateRoundRobinArgs) {\n  const {\n    groupNameBase = 'Group',\n    playoffAttributes,\n    stageSequence = 1,\n    structureOptions,\n    appliedPolicies,\n    seedingProfile,\n    stage = MAIN,\n    matchUpType,\n    roundTarget,\n    structureId,\n    groupNames,\n    drawSize,\n    idPrefix,\n    isMock,\n    uuids,\n  } = params;\n\n  const structureName =\n    params.structureName ??\n    playoffAttributes?.['0']?.name ??\n    constantToString(MAIN);\n\n  const { groupCount, groupSize } = deriveGroups({\n    structureOptions,\n    appliedPolicies,\n    drawSize,\n  });\n\n  const finishingPosition = WIN_RATIO;\n\n  let maxRoundNumber;\n\n  const structures = generateRange(1, groupCount + 1).map((structureOrder) => {\n    const matchUps = roundRobinMatchUps({\n      groupSize: groupSize,\n      structureOrder,\n      matchUpType,\n      drawSize,\n      idPrefix,\n      isMock,\n    });\n    maxRoundNumber = Math.max(\n      ...matchUps.map(({ roundNumber }) => roundNumber)\n    );\n\n    const structureName =\n      groupNames?.[structureOrder - 1] ?? `${groupNameBase} ${structureOrder}`;\n\n    return structureTemplate({\n      structureId: uuids?.pop(),\n      structureType: ITEM,\n      finishingPosition,\n      structureOrder,\n      structureName,\n      matchUps,\n    });\n  });\n\n  const structure = structureTemplate({\n    structureId: structureId ?? uuids?.pop(),\n    structureType: CONTAINER,\n    finishingPosition,\n    seedingProfile,\n    structureName,\n    stageSequence,\n    structures,\n    stage,\n  });\n\n  if (roundTarget)\n    addExtension({\n      extension: { name: ROUND_TARGET, value: roundTarget },\n      element: structure,\n    });\n\n  return {\n    structures: [structure],\n    maxRoundNumber,\n    groupCount,\n    links: [],\n    groupSize,\n    ...SUCCESS,\n  };\n}\n\nfunction deriveGroups({ appliedPolicies, structureOptions, drawSize }) {\n  if (appliedPolicies) {\n    // TODO: policy to set groupSizeLimit\n  }\n\n  let groupSize = structureOptions?.groupSize;\n  const groupSizeLimit = structureOptions?.groupSizeLimit || 8;\n  const { validGroupSizes } = getValidGroupSizes({\n    groupSizeLimit,\n    drawSize,\n  });\n  const maxValidGroupSize = validGroupSizes && Math.max(...validGroupSizes);\n\n  const validGroupSize = groupSize && validGroupSizes?.includes(groupSize);\n\n  if (!validGroupSize) {\n    // if no groupSize specified or if groupSize is not valid\n    if ((groupSize && groupSize > 4) || !validGroupSizes?.includes(4)) {\n      groupSize = maxValidGroupSize;\n    } else {\n      groupSize = 4;\n    }\n  }\n\n  const groupCount = Math.ceil(drawSize / groupSize);\n  return { groupSize, groupCount };\n}\n\ntype GetValidGroupSizesArgs = {\n  groupSizeLimit?: number;\n  drawSize: number;\n};\nexport function getValidGroupSizes({\n  drawSize,\n  groupSizeLimit = 10,\n}: GetValidGroupSizesArgs): ResultType & { validGroupSizes?: number[] } {\n  const validGroupSizes = generateRange(3, groupSizeLimit + 1).filter(\n    (groupSize) => {\n      const groupsCount = Math.ceil(drawSize / groupSize);\n      const byesCount = groupsCount * groupSize - drawSize;\n      const maxParticipantsPerGroup = Math.ceil(drawSize / groupsCount);\n      const maxByesPerGroup = Math.ceil(byesCount / groupsCount);\n      return (\n        (!byesCount || byesCount < groupSize) &&\n        maxParticipantsPerGroup === groupSize &&\n        maxParticipantsPerGroup >= 3 &&\n        maxByesPerGroup < 2\n      );\n    }\n  );\n  return { ...SUCCESS, validGroupSizes };\n}\n\ntype RoundRobinMatchUpsArgs = {\n  structureOrder: number;\n  matchUpType?: EventTypeUnion;\n  groupSize: number;\n  drawSize: number;\n  idPrefix?: string;\n  isMock?: boolean;\n  uuids?: string[];\n};\n\nfunction roundRobinMatchUps({\n  structureOrder,\n  matchUpType,\n  groupSize,\n  drawSize,\n  idPrefix,\n  isMock,\n  uuids,\n}: RoundRobinMatchUpsArgs) {\n  const drawPositionOffset = (structureOrder - 1) * groupSize;\n  const drawPositions = generateRange(\n    1 + drawPositionOffset,\n    groupSize + 1 + drawPositionOffset\n  );\n\n  const { uniqueMatchUpGroupings } = getRoundRobinGroupMatchUps({\n    drawPositions,\n  });\n  const rounds: any[] = groupRounds({ groupSize, drawPositionOffset });\n\n  const matchUps = uniqueMatchUpGroupings\n    .map(positionMatchUp)\n    .sort((a, b) => (a.roundNumber || Infinity) - (b.roundNumber || Infinity));\n\n  return matchUps;\n\n  function determineRoundNumber(hash) {\n    return rounds.reduce(\n      (p, round, i) => (round.includes(hash) ? i + 1 : p),\n      undefined\n    );\n  }\n\n  // returns a range for array of possible finishing drawPositions\n  function positionMatchUp(drawPositions) {\n    const hash = drawPositionsHash(drawPositions);\n    const roundNumber = determineRoundNumber(hash);\n    const range = [1, drawSize];\n    const matchUpId = roundRobinMatchUpId({\n      structureOrder,\n      drawPositions,\n      roundNumber,\n      idPrefix,\n      uuids,\n    });\n\n    const matchUp: MatchUp = {\n      matchUpStatus: roundNumber ? TO_BE_PLAYED : BYE,\n      matchUpType, // does not (perhaps) need to be included; but because structures[].structure unsure about derivation inContext\n      // finishingPositionRange in RR is not very useful, but provided for consistency\n      finishingPositionRange: { winner: range, loser: range },\n      drawPositions,\n      roundNumber,\n      matchUpId,\n    };\n    if (isMock) matchUp.isMock = true;\n\n    return matchUp;\n  }\n}\n\nfunction roundRobinMatchUpId({\n  structureOrder,\n  drawPositions,\n  roundNumber,\n  idPrefix,\n  uuids,\n}) {\n  return idPrefix\n    ? `${idPrefix}-${structureOrder}-${roundNumber}-DP-${drawPositions.join(\n        '-'\n      )}`\n    : uuids?.pop() || UUID();\n}\n","import { getValidGroupSizes } from '../../../assemblies/generators/drawDefinitions/drawTypes/roundRobin/roundRobin';\nimport { chunkArray, generateRange, overlap } from '../../../utilities/arrays';\nimport { isConvertableInteger, nextPowerOf2 } from '../../../utilities/math';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../../global/functions/decorateResult';\n\nimport { INVALID_VALUES } from '../../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\n/**\n * Generates seedBlocks for USTA or ITF style seeding\n * In the USTA seeding pattern no seed positions are ever adjacent;\n * ...on the top of the draw seed positions are always on the top of a group of positions\n * ...on the bottom of the draw seed positions are always on the bottom of a group of positions\n * In the ITF seeding pattern seed positions alternate between top and bottom of groups of positions\n *\n * @param {number} roundRobinGroupsCount - optional - number of round robin groups\n * @param {number} participantsCount - number of participants, coerced into a valid elimination structure size\n * @param {boolean} cluster - whether to cluster seed positions (ITF)\n * @returns\n */\n\ntype GetSeedBlocksArgs = {\n  roundRobinGroupsCount?: number;\n  participantsCount: number;\n  cluster?: boolean;\n};\n\nexport function getSeedBlocks(\n  params: GetSeedBlocksArgs\n): ResultType & { seedBlocks?: any; success?: boolean } {\n  const { roundRobinGroupsCount, participantsCount, cluster } = params;\n  if (!isConvertableInteger(participantsCount))\n    return {\n      seedBlocks: undefined,\n      ...decorateResult({\n        result: { error: INVALID_VALUES },\n        context: { participantsCount },\n        stack: 'getSeedBlocks',\n      }),\n    };\n\n  const drawSize = nextPowerOf2(participantsCount);\n\n  if (roundRobinGroupsCount) {\n    // ensure that drawSize has not already been subdivided\n    // e.g. each group treated as a separate drawSize whilst passing total groupsCount\n    const increment = Math.min(roundRobinGroupsCount, drawSize);\n    const seedBlocks: number[][] = [];\n    let position = 1;\n\n    generateRange(0, increment).forEach(() => {\n      seedBlocks.push([position]);\n      position++;\n    });\n\n    while (position < drawSize) {\n      const range = generateRange(position, position + increment);\n      position += increment;\n      seedBlocks.push(range);\n    }\n    return { ...SUCCESS, seedBlocks };\n  }\n\n  const range = generateRange(1, drawSize + 1);\n\n  const positions: number[] = [];\n  let chunkSize = drawSize / 2;\n  // first two seed blocks are always [[1], [drawSize]], e.g. [[1], [32]] for a 32 drawSize\n  // While loop generates an array of ordered drawPositions which are later broken into blocks\n\n  while (chunkSize > 1) {\n    const chunks = chunkArray(range, chunkSize);\n    const chunksCount = chunks.length;\n\n    // for each chunk generate candidates\n    // throw out candidates if the chunk positions include an already selected position\n    // this has the effect of skipping chunks where seeds have already been identified\n    chunks.forEach((chunk, i) => {\n      let candidate;\n      const top = i < chunksCount / 2;\n      const isEven = i % 2 === 0;\n      const first = chunk[0];\n      const last = chunk[chunk.length - 1];\n\n      if (cluster && chunksCount > 4) {\n        // for ITF/CLUSTER seeding the pattern changes and then stabilizes\n        if (chunksCount === 8) {\n          candidate = top ? last : first;\n        } else {\n          candidate = isEven ? first : last;\n        }\n      } else {\n        // for USTA/SEPARATE seeding the pattern is simple: first on top, last on bottom\n        candidate = top ? first : last;\n      }\n      if (!overlap(chunk, positions)) {\n        positions.push(candidate);\n      }\n    });\n    chunkSize = chunkSize / 2;\n  }\n\n  const remainingPositions = range.filter(\n    (position) => !positions.includes(position)\n  );\n\n  while (remainingPositions.length) {\n    // for remaining positions alternately select from bottom/top\n    if (remainingPositions.length % 2 === 0) {\n      positions.push(remainingPositions.pop());\n    } else {\n      positions.push(remainingPositions.shift());\n    }\n  }\n\n  // generate an array of seed block sizes... [1, 1, 2, 4, 8, 16...]\n  // 20 ensures a more than adequate number of seedBlocks!\n  const seedBlockSizes = generateRange(0, 20).map((x) => Math.pow(2, x));\n  seedBlockSizes.unshift(1);\n  // the number of seedBlocks is given by the index of drawSize in seedBlockSizes\n  const iterations = seedBlockSizes.indexOf(drawSize);\n\n  let sum = 0;\n  const seedBlocks: number[][] = [];\n  // iterate over seed block sizes to generate seedBlocks\n  generateRange(0, iterations).forEach((i) => {\n    seedBlocks.push(positions.slice(sum, sum + seedBlockSizes[i]));\n    sum += seedBlockSizes[i];\n  });\n\n  return { ...SUCCESS, seedBlocks };\n}\n\ntype GetSeedGroupsArgs = {\n  roundRobinGroupsCount?: number;\n  drawSize: number;\n};\nexport function getSeedGroups({\n  roundRobinGroupsCount,\n  drawSize,\n}: GetSeedGroupsArgs): ResultType & { seedGroups?: any } {\n  const stack = 'getSeedGroups';\n\n  if (!isConvertableInteger(drawSize))\n    return {\n      seedGroups: undefined,\n      ...decorateResult({\n        result: { error: INVALID_VALUES },\n        context: { drawSize },\n        stack,\n      }),\n    };\n\n  if (roundRobinGroupsCount) {\n    if (!isConvertableInteger(roundRobinGroupsCount))\n      return {\n        seedGroups: undefined,\n        ...decorateResult({\n          context: { roundRobinGroupsCount },\n          result: { error: INVALID_VALUES },\n          stack,\n        }),\n      };\n\n    let seedNumber = 1;\n    const roundsCount = Math.floor(drawSize / roundRobinGroupsCount);\n    const seedGroups = generateRange(0, roundsCount).map(() => {\n      const seedNumbers = generateRange(\n        seedNumber,\n        seedNumber + roundRobinGroupsCount\n      );\n      seedNumber += roundRobinGroupsCount;\n      return seedNumbers;\n    });\n    return { seedGroups };\n  } else {\n    const { seedBlocks } = getSeedBlocks({\n      participantsCount: drawSize,\n      roundRobinGroupsCount,\n    });\n\n    let seedNumber = 0;\n    const seedGroups = (seedBlocks || []).map((seedBlock) =>\n      (seedBlock || []).map(() => {\n        seedNumber += 1;\n        return seedNumber;\n      })\n    );\n\n    return { seedGroups };\n  }\n}\n\ntype GetSeedingThresholdsArgs = {\n  roundRobinGroupsCount?: number;\n  participantsCount: number;\n};\nexport function getSeedingThresholds({\n  roundRobinGroupsCount,\n  participantsCount,\n}: GetSeedingThresholdsArgs): ResultType & {\n  seedingThresholds?: any;\n  success?: boolean;\n} {\n  if (roundRobinGroupsCount) {\n    const { validGroupSizes } = getValidGroupSizes({\n      drawSize: participantsCount,\n    });\n    const validGroupsCounts = validGroupSizes?.map((groupSize) =>\n      Math.ceil(participantsCount / groupSize)\n    );\n    const invalid = !validGroupsCounts?.includes(roundRobinGroupsCount);\n\n    if (invalid) {\n      return decorateResult({\n        context: { roundRobinGroupsCount },\n        result: { error: INVALID_VALUES },\n      });\n    }\n  }\n\n  const { seedGroups } = getSeedGroups({\n    drawSize: participantsCount,\n    roundRobinGroupsCount,\n  });\n\n  const seedingThresholds =\n    seedGroups?.map((seedNumberBlock) => Math.min(...seedNumberBlock)) || [];\n\n  return { ...SUCCESS, seedingThresholds };\n}\n","import { isConvertableInteger } from '../../utilities/math';\nimport { ensureInt } from '../../utilities/ensureInt';\n\nexport function getNumericSeedValue(seedValue) {\n  if (!seedValue) return Infinity;\n  if (isConvertableInteger(seedValue)) return ensureInt(seedValue);\n  const firstValue = seedValue.split('-')[0];\n  if (isConvertableInteger(firstValue)) return ensureInt(firstValue);\n  return Infinity;\n}\n","import { chunkArray, generateRange } from '../../../utilities/arrays';\nimport { numericSort } from '../../../utilities/sorting';\n\nimport { CLUSTER, WATERFALL } from '../../../constants/drawDefinitionConstants';\n\nfunction getDivisions({ size }) {\n  const divisions: number[] = [size];\n\n  let division = size;\n  while (division / 2 === Math.floor(division / 2)) {\n    division = division / 2;\n    divisions.push(division);\n  }\n\n  if (!divisions.includes(1)) divisions.push(1);\n\n  divisions.sort(numericSort);\n  divisions.reverse();\n  return divisions;\n}\n\ntype GenerateBlockPatternArgs = {\n  positioning?: string;\n  size: number;\n};\n\nexport function getSubBlock({ blockPattern, index }) {\n  let i = 0;\n  for (const subBlock of blockPattern) {\n    if (i === index) return subBlock;\n    let j = 0;\n    while (j < subBlock.length) {\n      if (i === index) return subBlock;\n      i += 1;\n      j++;\n    }\n  }\n}\n\nexport function generateBlockPattern({ positioning, size }: GenerateBlockPatternArgs): {\n  divisionGroupings: number[][];\n  divisions: number[];\n} {\n  const divisions = getDivisions({ size });\n  const divisionGroupings: number[][] = [];\n  const selected: number[] = [];\n\n  const firstMember = (arr) => arr[0];\n  const lastMember = (arr) => arr[arr.length - 1];\n  const getMember = (arr, i) =>\n    (positioning && [CLUSTER, WATERFALL].includes(positioning) && i % 2 ? lastMember(arr) : firstMember(arr)) ||\n    firstMember(arr);\n  const noneSelected = (chunk, i) => {\n    if (chunk.every((member) => !selected.includes(member))) {\n      const member = getMember(chunk, i);\n      selected.push(member);\n      return member;\n    }\n  };\n  const notSelected = (chunk) => {\n    const notSelected = chunk.filter((member) => !selected.includes(member));\n    if (notSelected.length) {\n      selected.push(...notSelected);\n      return notSelected;\n    }\n  };\n  const select = (chunk, i) => {\n    const member = getMember(chunk, i);\n    if (!selected.includes(member)) {\n      selected.push(member);\n      return member;\n    }\n  };\n\n  const range = generateRange(1, size + 1);\n\n  for (const division of divisions) {\n    if (division === 1) {\n      const chunks = chunkArray(range, 2);\n      // first check all pairs for pair that has no member included in selected\n      const positions = chunks.map(noneSelected).filter(Boolean);\n      if (positions.length) divisionGroupings.push(positions);\n      // then return positions from each chunk which are not selected\n      const lastPositions = chunks.flatMap(notSelected).filter(Boolean);\n      if (lastPositions.length) divisionGroupings.push(lastPositions);\n    } else {\n      const chunks = chunkArray(range, division);\n      const positions = chunks.map(select).filter(Boolean);\n      if (positions.length) divisionGroupings.push(positions);\n    }\n  }\n\n  return { divisions, divisionGroupings };\n}\n","import { getSeedBlocks, getSeedGroups } from '../../mutate/drawDefinitions/positionGovernor/getSeedBlocks';\nimport { getPositionAssignments, structureAssignedDrawPositions } from './positionsGetter';\nimport { getStructureSeedAssignments } from '../structure/getStructureSeedAssignments';\nimport { chunkArray, generateRange, shuffleArray } from '../../utilities/arrays';\nimport { getAllStructureMatchUps } from '../matchUps/getAllStructureMatchUps';\nimport { getAppliedPolicies } from '../extensions/getAppliedPolicies';\nimport { getNumericSeedValue } from './getNumericSeedValue';\nimport { findStructure } from '../../acquire/findStructure';\nimport { isLucky } from './isLucky';\n\nimport { generateBlockPattern, getSubBlock } from '../../assemblies/generators/drawDefinitions/generateBlockPattern';\nimport { CLUSTER, CONTAINER, QUALIFYING, WATERFALL } from '../../constants/drawDefinitionConstants';\nimport { INVALID_SEED_POSITION, MISSING_STRUCTURE } from '../../constants/errorConditionConstants';\nimport { PolicyDefinitions, SeedBlock, SeedingProfile } from '../../types/factoryTypes';\nimport { DrawDefinition, Structure } from '../../types/tournamentTypes';\n\n/**\n * A seedBlock is an object pairing an array of drawPositions with an array of seedNumbers { drawPositions: [], seedNumbers: []}\n * In an elimination structure The first seedBlock is { drawPositions: [1], seedNumbers: [1] }\n * In an elimination structure The second seedBlock is{ drawPositions: [drawSize], seedNumbers: [2] }\n * In an elimination structure the third seedBlock is { drawPositions: [a, b], seedNumbers: [3, 4] }\n * In an elimination structure the fourth seedBlock is { drawPositions: [w, x, y, z], seedNumbers: [5, 6, 7, 8] }\n * The calculations for the positioning of [a, b] and [w, x, y, z] are specific to seeding policies\n */\n\ntype GetValidSeedBlocksArgs = {\n  appliedPolicies?: PolicyDefinitions;\n  provisionalPositioning?: boolean;\n  drawDefinition?: DrawDefinition;\n  seedingProfile?: SeedingProfile;\n  returnAllProxies?: boolean;\n  allPositions?: boolean;\n  structure: Structure;\n};\n\nexport function getValidSeedBlocks({\n  provisionalPositioning,\n  returnAllProxies,\n  appliedPolicies,\n  seedingProfile,\n  drawDefinition,\n  allPositions,\n  structure,\n}: GetValidSeedBlocksArgs) {\n  let validSeedBlocks: SeedBlock[] = [];\n\n  if (!structure) return { error: MISSING_STRUCTURE };\n\n  const { matchUps, roundMatchUps } = getAllStructureMatchUps({\n    matchUpFilters: { roundNumbers: [1] },\n    provisionalPositioning,\n    structure,\n  });\n  const { seedAssignments } = getStructureSeedAssignments({\n    provisionalPositioning,\n    returnAllProxies,\n    drawDefinition,\n    structure,\n  });\n  const { positionAssignments } = structureAssignedDrawPositions({ structure });\n  const positionsCount = positionAssignments?.length;\n  const seedsCount = seedAssignments?.length ?? 0;\n\n  let allDrawPositions: number[] = [];\n  const roundNumbers = Object.keys(roundMatchUps)\n    .map((n) => parseInt(n))\n    .sort((a, b) => a - b);\n  const uniqueDrawPositionsByRound = roundNumbers\n    .map((roundNumber) => {\n      const roundDrawPositions = roundMatchUps[roundNumber]\n        .map((matchUp) => matchUp.drawPositions)\n        .flat(Infinity)\n        .filter(Boolean);\n      const uniqueRoundDrawPositions = roundDrawPositions.filter(\n        (drawPosition) => !allDrawPositions.includes(drawPosition),\n      );\n      allDrawPositions = allDrawPositions.concat(...roundDrawPositions);\n      return uniqueRoundDrawPositions;\n    })\n    .filter((f) => f.length)\n    .reverse();\n\n  const firstRoundDrawPositions = uniqueDrawPositionsByRound.pop();\n  const firstRoundDrawPositionOffset = (firstRoundDrawPositions && Math.min(...firstRoundDrawPositions) - 1) || 0;\n\n  seedingProfile = seedingProfile ?? appliedPolicies?.seeding?.seedingProfile;\n  const baseDrawSize = firstRoundDrawPositions?.length || 0;\n\n  // firstRoundDrawPositions have been popped\n  // seedRangeDrawPositionBlocks determines FEED_IN\n  const seedRangeDrawPositionBlocks = uniqueDrawPositionsByRound.filter(\n    (block) => block.filter((drawPosition) => drawPosition <= seedsCount).length,\n  );\n\n  const { stage, structureType, roundLimit } = structure;\n  const isContainer = structureType === CONTAINER;\n  const isFeedIn = !isContainer && uniqueDrawPositionsByRound?.length;\n  const qualifyingBlocks = !isContainer && stage === QUALIFYING && roundLimit;\n\n  const fedSeedBlockPositions = seedRangeDrawPositionBlocks.flat(Infinity);\n  const fedSeedNumberOffset = isFeedIn ? fedSeedBlockPositions?.length : 0;\n  const countLimit = allPositions ? positionsCount : seedsCount;\n  const isLuckyStructure = isLucky({\n    drawDefinition,\n    structure,\n    matchUps,\n  });\n  const firstRoundSeedsCount = isLuckyStructure\n    ? 0\n    : (!isFeedIn && countLimit) ||\n      (countLimit && fedSeedBlockPositions.length < countLimit && countLimit - fedSeedBlockPositions.length) ||\n      0;\n\n  if (qualifyingBlocks) {\n    const seedingBlocksCount = structure?.matchUps\n      ? structure.matchUps.filter(({ roundNumber }) => roundNumber === structure.roundLimit).length\n      : 0;\n    const chunkSize = firstRoundDrawPositions.length / seedingBlocksCount;\n\n    if (isFeedIn) {\n      // TODO: figure this out\n    } else {\n      const positioning = getSeedPattern(seedingProfile);\n      const drawPositionChunks = chunkArray(firstRoundDrawPositions, chunkSize);\n      let groupNumber = 1;\n      const seedGroups = generateRange(0, drawPositionChunks[0].length).map(() => {\n        const seedNumbers = generateRange(groupNumber, groupNumber + drawPositionChunks.length);\n        groupNumber += drawPositionChunks.length;\n        return seedNumbers;\n      });\n\n      ({ validSeedBlocks } = getSeedBlockPattern({\n        drawPositionBlocks: drawPositionChunks,\n        nonRandom: seedingProfile?.nonRandom,\n        positioning,\n        seedGroups,\n      }));\n    }\n  } else if (isContainer) {\n    const result = getContainerBlocks({\n      nonRandom: seedingProfile?.nonRandom,\n      seedingProfile,\n      structure,\n    });\n    ({ validSeedBlocks } = result);\n  } else if (isFeedIn) {\n    // for FEED_IN structures, block seeding proceeds from final rounds\n    // to earlier rounds.  If there are more seeds than fed positions,\n    // then seeds must be assigned to first round drawPositions\n    validSeedBlocks = seedRangeDrawPositionBlocks.map((block) => {\n      return { seedNumbers: block, drawPositions: block };\n    });\n  } else if (isLuckyStructure) {\n    const blocks = chunkArray(firstRoundDrawPositions, 2).map((block, i) => ({\n      drawPositions: [block[0]],\n      seedNumbers: [i + 1],\n    }));\n    blocks.forEach((block) => validSeedBlocks.push(block));\n  }\n\n  if (!isContainer && !isLuckyStructure && !qualifyingBlocks) {\n    const { blocks } = constructPower2Blocks({\n      drawPositionOffset: firstRoundDrawPositionOffset,\n      seedNumberOffset: fedSeedNumberOffset,\n      seedCountGoal: firstRoundSeedsCount,\n      seedingProfile,\n      baseDrawSize,\n    });\n    blocks.forEach((block) => validSeedBlocks.push(block));\n  }\n\n  const seedDrawPositions = validSeedBlocks.flatMap((seedBlock) => seedBlock.drawPositions);\n  const validSeedPositions = seedDrawPositions.reduce((result, drawPosition) => {\n    return firstRoundDrawPositions?.includes(drawPosition) && result;\n  }, true);\n\n  if (!isLuckyStructure && !isFeedIn && !isContainer && !validSeedPositions) {\n    return {\n      error: INVALID_SEED_POSITION,\n      validSeedBlocks: [],\n      isContainer,\n      isFeedIn,\n    };\n  }\n\n  return {\n    isLuckyStructure,\n    validSeedBlocks,\n    isContainer,\n    isFeedIn,\n  };\n}\n\nexport function getContainerBlocks({ seedingProfile, structure, nonRandom }) {\n  const containedStructures = structure.structures || [];\n  const roundRobinGroupsCount = containedStructures.length;\n  const positionAssignments = getPositionAssignments({\n    structure,\n  })?.positionAssignments;\n  const positioning = getSeedPattern(seedingProfile);\n\n  const drawSize = positionAssignments?.length ?? 0;\n  const { seedGroups } = getSeedGroups({\n    roundRobinGroupsCount,\n    drawSize,\n  });\n  const drawPositionBlocks = containedStructures.map(\n    (containedStructure) =>\n      getPositionAssignments({\n        structure: containedStructure,\n      }).positionAssignments?.map((assignment) => assignment.drawPosition),\n  );\n\n  return getSeedBlockPattern({\n    drawPositionBlocks,\n    positioning,\n    seedGroups,\n    nonRandom,\n  });\n}\n\ntype GetSeedBlockPatternArgs = {\n  drawPositionBlocks: number[][];\n  seedGroups: number[][];\n  positioning?: string;\n  nonRandom?: boolean;\n};\n\nexport function getSeedBlockPattern({\n  drawPositionBlocks,\n  positioning,\n  seedGroups,\n  nonRandom,\n}: GetSeedBlockPatternArgs) {\n  const validSeedBlocks: SeedBlock[] = [];\n\n  const { divisionGroupings } = generateBlockPattern({\n    size: seedGroups.length,\n    positioning,\n  });\n\n  const assignedPositions: number[] = [];\n  seedGroups.forEach((seedGroup, i) => {\n    const relativePositions = getSubBlock({\n      blockPattern: divisionGroupings,\n      index: i,\n    });\n    seedGroup.forEach((seedNumber: number, j) => {\n      const blockIndex = i % 2 ? drawPositionBlocks.length - j - 1 : j;\n      const block = drawPositionBlocks[blockIndex].slice();\n      let consideredDrawPositions = block.filter(\n        (drawPosition, i) => relativePositions.includes(i + 1) && drawPosition,\n      );\n      if (positioning !== WATERFALL) {\n        consideredDrawPositions = nonRandom ? consideredDrawPositions : shuffleArray(consideredDrawPositions);\n      } else if (i % 2) {\n        consideredDrawPositions.reverse();\n      }\n      const drawPosition = consideredDrawPositions.find((drawPosition) => !assignedPositions.includes(drawPosition));\n\n      if (drawPosition) {\n        assignedPositions.push(drawPosition);\n        validSeedBlocks.push({\n          drawPositions: [drawPosition],\n          seedNumbers: [seedNumber],\n        });\n      }\n    });\n  });\n\n  return { validSeedBlocks };\n}\n\nfunction constructPower2Blocks(params) {\n  const {\n    drawPositionOffset = 0,\n    roundRobinGroupsCount,\n    seedNumberOffset = 0,\n    seedingProfile,\n    seedCountGoal,\n    baseDrawSize,\n  } = params;\n\n  let count = 1;\n  const blocks: any[] = [];\n\n  const { seedBlocks } = getSeedBlocks({\n    cluster: getSeedPattern(seedingProfile) === CLUSTER,\n    participantsCount: baseDrawSize,\n    roundRobinGroupsCount,\n  });\n\n  count = 0;\n  for (const seedBlock of seedBlocks) {\n    if (count + 1 > seedCountGoal) break;\n    const drawPositions = seedBlock.map((drawPosition) => drawPosition + drawPositionOffset);\n    const seedNumbers = getSeeds(count + 1, seedBlock.length).map((seedNumber) => +seedNumber + seedNumberOffset);\n    count += seedBlock.length;\n    blocks.push({ drawPositions, seedNumbers });\n  }\n\n  return { blocks };\n\n  function getSeeds(s, n) {\n    return Array.from(new Array(n), (_, i) => i + s);\n  }\n}\n\n/**\n * method operates in three modes:\n * 1. Lenient (default) - any valid seed number can go in any valid seed position\n * 2. Ignore - method is bypassed and always returns true\n * 3. Strict - drawPosition is only valid if it is found in seedBlock which contains seedNumber\n */\n\ntype IsValidSeedPositionArgs = {\n  appliedPolicies?: PolicyDefinitions;\n  drawDefinition: DrawDefinition;\n  drawPosition: number;\n  seedBlockInfo?: any;\n  structureId: string;\n  seedNumber?: number;\n};\n\nexport function isValidSeedPosition({\n  appliedPolicies,\n  drawDefinition,\n  seedBlockInfo,\n  drawPosition,\n  structureId,\n  seedNumber,\n}: IsValidSeedPositionArgs) {\n  const { structure } = findStructure({ drawDefinition, structureId });\n  if (!appliedPolicies) {\n    appliedPolicies = getAppliedPolicies({ drawDefinition }).appliedPolicies;\n  }\n\n  let validSeedBlocks = seedBlockInfo?.validSeedBlocks;\n\n  if (!validSeedBlocks && structure) {\n    validSeedBlocks = getValidSeedBlocks({\n      appliedPolicies,\n      drawDefinition,\n      structure,\n    })?.validSeedBlocks;\n  }\n\n  if (appliedPolicies?.seeding?.validSeedPositions?.ignore) return true;\n  if (appliedPolicies?.seeding?.validSeedPositions?.strict) {\n    const targetSeedBlock = validSeedBlocks.find((seedBlock) => seedBlock.seedNumbers.includes(seedNumber));\n    const validSeedPositions = targetSeedBlock?.drawPositions || [];\n    return validSeedPositions.includes(drawPosition);\n  }\n\n  const validSeedPositions: number[] = [].concat(...validSeedBlocks.map((seedBlock) => seedBlock.drawPositions));\n  return validSeedPositions.includes(drawPosition);\n}\n\nexport function getNextSeedBlock(params) {\n  const { provisionalPositioning, drawDefinition, seedingProfile, seedBlockInfo, structureId, randomize } = params;\n\n  const { structure } = findStructure({ drawDefinition, structureId });\n  const { seedAssignments } = getStructureSeedAssignments({\n    returnAllProxies: params.returnAllProxies,\n    provisionalPositioning,\n    drawDefinition,\n    structure,\n  });\n  const { positionAssignments } = structureAssignedDrawPositions({ structure });\n  const positionsWithParticipants = positionAssignments?.filter(\n    (assignment) => assignment.participantId ?? assignment.bye ?? assignment.qualifier,\n  );\n  const assignedDrawPositions = positionsWithParticipants?.map((assignment) => assignment.drawPosition).filter(Boolean);\n\n  const { appliedPolicies } = getAppliedPolicies({ drawDefinition });\n  const validSeedBlocks =\n    seedBlockInfo?.validSeedBlocks ||\n    (structure &&\n      getValidSeedBlocks({\n        returnAllProxies: params.returnAllProxies,\n        provisionalPositioning,\n        appliedPolicies,\n        drawDefinition,\n        seedingProfile,\n        structure,\n      })?.validSeedBlocks);\n  const unfilledSeedBlocks = (validSeedBlocks || []).filter((seedBlock) => {\n    const unfilledPositions = seedBlock.drawPositions.filter(\n      (drawPosition) => !assignedDrawPositions?.includes(drawPosition),\n    );\n    return unfilledPositions.length;\n  });\n  const nextSeedBlock = unfilledSeedBlocks[0];\n\n  const assignedSeedParticipantIds = seedAssignments?.map((assignment) => assignment.participantId).filter(Boolean);\n  const assignedPositionParticipantIds = positionAssignments\n    ?.map((assignment) => assignment.participantId)\n    .filter(Boolean);\n  const placedSeedParticipantIds = assignedSeedParticipantIds?.filter(\n    (participantId) => assignedPositionParticipantIds?.includes(participantId),\n  );\n\n  const unplacedSeedIds = assignedSeedParticipantIds?.filter(\n    (participantId) => !assignedPositionParticipantIds?.includes(participantId),\n  );\n\n  const unplacedSeedAssignments = seedAssignments?.filter(\n    (assignment) => unplacedSeedIds?.includes(assignment.participantId),\n  );\n\n  const seedsWithoutDrawPositions = seedAssignments?.filter((assignment) => !assignment.participantId);\n  const seedsLeftToAssign =\n    unplacedSeedAssignments?.length && unplacedSeedAssignments.length > 0\n      ? unplacedSeedAssignments.length\n      : seedsWithoutDrawPositions?.length ?? 0;\n  const unfilled =\n    (seedsLeftToAssign &&\n      nextSeedBlock?.drawPositions.filter((drawPosition) => !assignedDrawPositions?.includes(drawPosition))) ||\n    [];\n  const unfilledPositions = randomize ? shuffleArray(unfilled) : unfilled;\n  const selectedParticipantIds: string[] = [];\n  const randomlySelectedUnplacedSeedValueIds = unfilledPositions\n    .map(() => {\n      const assignment = randomlySelectLowestSeedValue(unplacedSeedAssignments, selectedParticipantIds);\n      const participantId = assignment?.participantId;\n      if (participantId) selectedParticipantIds.push(participantId);\n      return participantId;\n    })\n    .filter(Boolean);\n\n  const placedSeedNumbers = seedAssignments\n    ?.filter((assignment) => placedSeedParticipantIds?.includes(assignment.participantId))\n    .map((assignment) => assignment.seedNumber);\n  const blockSeedNumbers = nextSeedBlock?.seedNumbers || [];\n\n  // unplacedSeedNumbers and unplacedSeedNumberIds will only be used\n  // when policy specifies that seedNumbers/seedValues must be unique\n  const unplacedSeedNumbers = blockSeedNumbers.filter((seedNumber) => !placedSeedNumbers?.includes(seedNumber));\n\n  const unplacedSeedNumberIds = seedAssignments\n    ?.filter((assignment) => unplacedSeedNumbers.includes(assignment.seedNumber))\n    .map((assignment) => assignment.participantId);\n\n  const duplicateSeedNumbers = appliedPolicies?.seeding?.duplicateSeedNumbers;\n  const allowsDuplicateSeedNumbers = duplicateSeedNumbers !== undefined ? duplicateSeedNumbers : true;\n\n  const unplacedSeedParticipantIds = allowsDuplicateSeedNumbers\n    ? randomlySelectedUnplacedSeedValueIds\n    : unplacedSeedNumberIds;\n\n  return {\n    nextSeedBlock,\n    unplacedSeedParticipantIds,\n    unplacedSeedNumbers,\n    unfilledPositions,\n    unplacedSeedAssignments,\n  };\n\n  function randomlySelectLowestSeedValue(assignments, selectedParticipantIds) {\n    const filteredAssignments = assignments.filter(\n      (assignment) => !selectedParticipantIds.includes(assignment.participantId),\n    );\n    const lowestSeedValue = Math.min(\n      ...filteredAssignments.map((assignment) => getNumericSeedValue(assignment.seedValue)),\n    );\n    const assignmentsWithLowestSeedValue = filteredAssignments.filter(\n      (assignment) => getNumericSeedValue(assignment.seedValue) === lowestSeedValue,\n    );\n    const randomizedAssignments = shuffleArray(assignmentsWithLowestSeedValue);\n    return randomizedAssignments.pop();\n  }\n}\n\nexport function getSeedPattern(seedingProfile) {\n  if (typeof seedingProfile === 'string') return seedingProfile;\n  if (typeof seedingProfile === 'object') return seedingProfile.positioning;\n}\n","import { getStructureSeedAssignments } from '../../../query/structure/getStructureSeedAssignments';\nimport { getFlightProfile } from '../../../query/event/getFlightProfile';\nimport { modifySeedAssignmentsNotice } from '../../notifications/drawNotifications';\nimport { structureAssignedDrawPositions } from '../../../query/drawDefinition/positionsGetter';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { participantInEntries } from '../../../query/drawDefinition/entryGetter';\nimport { isValidSeedPosition } from '../../../query/drawDefinition/seedGetter';\nimport { findStructure } from '../../../acquire/findStructure';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { SeedingProfile } from '../../../types/factoryTypes';\nimport {\n  INVALID_DRAW_POSITION_FOR_SEEDING,\n  INVALID_PARTICIPANT_ID,\n  INVALID_SEED_NUMBER,\n} from '../../../constants/errorConditionConstants';\nimport { DrawDefinition, Event, Tournament } from '../../../types/tournamentTypes';\n\ntype AssignSeedArgs = {\n  provisionalPositioning?: boolean;\n  tournamentRecord?: Tournament;\n  seedingProfile?: SeedingProfile;\n  drawDefinition: DrawDefinition;\n  participantId: string;\n  seedBlockInfo?: any;\n  structureId: string;\n  seedNumber: number;\n  seedValue?: string | number;\n  eventId?: string;\n  event?: Event;\n};\nexport function assignSeed({\n  provisionalPositioning,\n  tournamentRecord,\n  drawDefinition,\n  seedingProfile,\n  participantId,\n  seedBlockInfo,\n  structureId,\n  seedNumber,\n  seedValue,\n  eventId,\n  event,\n}: AssignSeedArgs) {\n  const stack = 'assignSeed';\n  const { structure } = findStructure({ drawDefinition, structureId });\n  const { positionAssignments } = structureAssignedDrawPositions({ structure });\n  const seedAssignments = getStructureSeedAssignments({\n    provisionalPositioning,\n    drawDefinition,\n    structure,\n  }).seedAssignments as any;\n  const seedNumbers = seedAssignments.map((assignment) => assignment.seedNumber);\n\n  const validParticipantId = participantInEntries({\n    drawDefinition,\n    participantId,\n  });\n\n  if (participantId && !validParticipantId)\n    return decorateResult({\n      result: { error: INVALID_PARTICIPANT_ID },\n      context: { participantId },\n      stack,\n    });\n\n  const flightsCount = event ? getFlightProfile({ event }).flightProfile?.flights?.length : 0;\n  const flighted = flightsCount && flightsCount > 1;\n\n  const relevantAssignment = positionAssignments?.find((assignment) => assignment.participantId === participantId);\n  const assignedDrawPosition = relevantAssignment?.drawPosition;\n\n  if (assignedDrawPosition) {\n    const positionIsValid = isValidSeedPosition({\n      drawPosition: assignedDrawPosition,\n      drawDefinition,\n      seedBlockInfo,\n      structureId,\n      seedNumber,\n    });\n    if (!positionIsValid)\n      return decorateResult({\n        result: { error: INVALID_DRAW_POSITION_FOR_SEEDING },\n        context: { assignedDrawPosition },\n        info: 'invalid seed position',\n        stack,\n      });\n  }\n\n  if (!seedNumbers.includes(seedNumber)) {\n    seedAssignments.push({ seedNumber, seedValue });\n  }\n\n  let success;\n  seedAssignments.forEach((assignment) => {\n    // ensure that this participantId is not assigned to any other seedNumber\n    if (assignment.participantId === participantId && assignment.seedNumber !== seedNumber) {\n      assignment.participantId = undefined;\n    }\n    // assign participantId to target seedNumber\n    if (assignment.seedNumber === seedNumber) {\n      assignment.participantId = participantId;\n      if (!seedingProfile?.groupSeedingThreshold && !flighted) assignment.seedValue = seedValue ?? seedNumber;\n      success = true;\n    }\n  });\n\n  if (success) {\n    modifySeedAssignmentsNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      drawDefinition,\n      structure,\n      eventId,\n    });\n    return { ...SUCCESS };\n  }\n\n  return decorateResult({ result: { error: INVALID_SEED_NUMBER }, stack });\n}\n","import { getContainedStructures } from '../../../query/drawDefinition/getContainedStructures';\nimport { MatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { intersection } from '../../../utilities/arrays';\n\nimport { DrawDefinition, Structure } from '../../../types/tournamentTypes';\nimport { HydratedMatchUp } from '../../../types/hydrated';\n\ntype GetTargetMatchUpsArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  drawDefinition?: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  structure: Structure;\n  assignments?: any;\n};\nexport function getTargetMatchUps({\n  inContextDrawMatchUps,\n  drawDefinition,\n  assignments,\n  matchUpsMap,\n  structure,\n}: GetTargetMatchUpsArgs) {\n  // to support ROUND_ROBIN contained structures\n  const containedStructures = getContainedStructures({\n    drawDefinition,\n  })?.containedStructures;\n\n  const targetStructureIds =\n    containedStructures?.[structure.structureId]?.map(\n      ({ structureId }) => structureId\n    ) || [];\n\n  targetStructureIds.push(structure?.structureId);\n\n  const drawPositions =\n    assignments?.map(({ drawPosition }) => drawPosition) || [];\n\n  // find all matchUps in the specified structure which contain the target drawPositions\n  const targetMatchUps =\n    inContextDrawMatchUps?.filter(\n      (matchUp) =>\n        targetStructureIds.includes(matchUp.structureId) &&\n        intersection(matchUp.drawPositions ?? [], drawPositions).length\n    ) ?? [];\n\n  const targetMatchUpIds = targetMatchUps.map(({ matchUpId }) => matchUpId);\n  const matchUps =\n    matchUpsMap?.drawMatchUps?.filter((matchUp) =>\n      targetMatchUpIds.includes(matchUp.matchUpId)\n    ) ?? [];\n\n  return { drawPositions, matchUps, targetMatchUps };\n}\n","import { getCollectionPositionAssignments } from '../events/getCollectionPositionAssignments';\nimport { unique } from '../../utilities/arrays';\n\nimport { LineUp } from '../../types/factoryTypes';\n\nexport function removeLineUpSubstitutions({ lineUp }: { lineUp: LineUp }) {\n  if (!Array.isArray(lineUp)) return;\n\n  const participantAssignments = {};\n\n  const permutations = unique(\n    lineUp\n      .flatMap(\n        ({ collectionAssignments }) =>\n          collectionAssignments?.map(({ collectionId, collectionPosition }) =>\n            [collectionId, collectionPosition].join('|')\n          )\n      )\n      .filter(Boolean)\n  );\n\n  permutations.forEach((permutation) => {\n    const [collectionId, position] = permutation.split('|');\n    const collectionPosition = parseInt(position);\n    const { assignedParticipantIds } = getCollectionPositionAssignments({\n      collectionPosition,\n      collectionId,\n      lineUp,\n    });\n\n    assignedParticipantIds.forEach((participantId) => {\n      if (!participantAssignments[participantId])\n        participantAssignments[participantId] = [];\n      participantAssignments[participantId].push({\n        collectionId,\n        collectionPosition,\n      });\n    });\n  });\n\n  return Object.keys(participantAssignments).map((participantId) => ({\n    participantId,\n    collectionAssignments: participantAssignments[participantId],\n  }));\n}\n","export function mustBeAnArray(value) {\n  return `${value} must be an array`;\n}\n","import { getParticipantId } from '../global/functions/extractors';\nimport { mustBeAnArray } from '../utilities/mustBeAnArray';\nimport { unique } from '../utilities/arrays';\n\nimport { INVALID_VALUES } from '../constants/errorConditionConstants';\nimport { TieFormat } from '../types/tournamentTypes';\nimport { LineUp } from '../types/factoryTypes';\n\ntype ValidateLineUpArgs = {\n  tieFormat?: TieFormat;\n  lineUp: LineUp;\n};\nexport function validateLineUp({ lineUp, tieFormat }: ValidateLineUpArgs) {\n  const errors: string[] = [];\n  if (!Array.isArray(lineUp)) {\n    errors.push(mustBeAnArray('lineUp'));\n    return { valid: false, errors, error: INVALID_VALUES };\n  }\n\n  const validItems = lineUp.every((item) => {\n    if (typeof item !== 'object') {\n      errors.push(`lineUp entries must be objects`);\n      return false;\n    }\n    const { participantId, collectionAssignments } = item;\n    if (!participantId) {\n      errors.push('Missing participantId');\n      return false;\n    }\n    if (typeof participantId !== 'string') {\n      errors.push('participantIds must be strings');\n      return false;\n    }\n    if (!Array.isArray(collectionAssignments)) {\n      errors.push(mustBeAnArray('collectionAssignments'));\n      return false;\n    }\n\n    return collectionAssignments.every((collectionAssignment) => {\n      if (typeof collectionAssignment !== 'object') {\n        errors.push('collectionAssignments must be objects');\n        return false;\n      }\n\n      const { collectionPosition } = collectionAssignment;\n      if (typeof collectionPosition !== 'number') {\n        errors.push('collectionPosition must be a number');\n        return false;\n      }\n\n      return true;\n    });\n  });\n\n  const noDuplicates =\n    unique(lineUp.map(getParticipantId)).length === lineUp.length;\n  if (!noDuplicates) errors.push('Duplicated participantId(s)');\n\n  if (tieFormat) {\n    // validate that all lineUp assignments contain valid collectionIds and collectionPositions\n  }\n\n  const valid = validItems && noDuplicates;\n\n  return { valid, errors, error: errors.length ? INVALID_VALUES : undefined };\n}\n","import { addDrawNotice } from '../notifications/drawNotifications';\nimport { addExtension } from '../extensions/addExtension';\nimport { removeLineUpSubstitutions } from './removeLineUpSubstitutions';\nimport { findExtension } from '../../acquire/findExtension';\nimport { validateLineUp } from '../../validators/validateTeamLineUp';\n\nimport { LINEUPS } from '../../constants/extensionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ErrorType,\n  MISSING_DRAW_DEFINITION,\n  MISSING_PARTICIPANT_ID,\n} from '../../constants/errorConditionConstants';\nimport { DrawDefinition, TieFormat } from '../../types/tournamentTypes';\nimport { LineUp } from '../../types/factoryTypes';\n\n// update an extension on the drawDefinition that keeps track of the latest lineUp for all team participantIds\n// each matchUp in the draw will use this as the template on first load and then write lineUp to the matchUp\n\ntype UpdateTeamLineUpArgs = {\n  drawDefinition: DrawDefinition;\n  participantId: string;\n  tieFormat: TieFormat;\n  drawId?: string;\n  lineUp: LineUp;\n};\n\nexport function updateTeamLineUp({\n  drawDefinition,\n  participantId,\n  tieFormat,\n  lineUp,\n}: UpdateTeamLineUpArgs): { success?: boolean; error?: ErrorType } {\n  if (typeof drawDefinition !== 'object')\n    return { error: MISSING_DRAW_DEFINITION };\n  if (typeof participantId !== 'string')\n    return { error: MISSING_PARTICIPANT_ID };\n\n  const validation = validateLineUp({ lineUp, tieFormat });\n  if (!validation.valid) return validation;\n\n  const { extension: existingExtension } = findExtension({\n    element: drawDefinition,\n    name: LINEUPS,\n  });\n\n  const value = existingExtension?.value || {};\n  value[participantId] = removeLineUpSubstitutions({ lineUp });\n\n  const extension = { name: LINEUPS, value };\n\n  addExtension({ element: drawDefinition, extension });\n  addDrawNotice({ drawDefinition });\n\n  return { ...SUCCESS };\n}\n","import { updateTeamLineUp } from '../../drawDefinitions/updateTeamLineUp';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { getTargetMatchUps } from '../../drawDefinitions/positionGovernor/getTargetMatchUps';\n\nimport { MISSING_DRAW_DEFINITION } from '../../../constants/errorConditionConstants';\nimport { MatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { TEAM_MATCHUP } from '../../../constants/matchUpTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  DrawDefinition,\n  Event,\n  Structure,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype ResetLineUpsArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  inheritance?: boolean;\n  structure: Structure;\n  assignments?: any;\n  event?: Event;\n};\nexport function resetLineUps({\n  inContextDrawMatchUps,\n  inheritance = true,\n  tournamentRecord,\n  drawDefinition,\n  matchUpsMap,\n  assignments,\n  structure,\n  event,\n}: ResetLineUpsArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const { drawPositions, matchUps, targetMatchUps } = getTargetMatchUps({\n    inContextDrawMatchUps,\n    matchUpsMap,\n    assignments,\n    structure,\n  });\n\n  // remove all lineUps on appropriate sides of matchUps which include drawPositions\n  // this will cause all lineUps to revert back to the team default lineUps (last modification) stored in LINEUPS extension\n  for (const inContextMatchUp of targetMatchUps) {\n    if (inContextMatchUp.matchUpType !== TEAM_MATCHUP) continue;\n\n    (inContextMatchUp.sides ?? []).forEach((side: any, sideIndex) => {\n      if (side?.drawPosition && drawPositions?.includes(side.drawPosition)) {\n        const matchUp = matchUps.find(\n          ({ matchUpId }) => matchUpId === inContextMatchUp.matchUpId\n        );\n        if (matchUp?.sides?.[sideIndex]) {\n          delete matchUp.sides[sideIndex].lineUp;\n\n          if (inheritance === false) {\n            // remove lineup for team participantId from drawDefinition LINE_UP extension\n            const tieFormat = inContextMatchUp.tieFormat;\n            const participantId = side.participantId;\n\n            if (tieFormat && participantId) {\n              updateTeamLineUp({\n                drawDefinition,\n                participantId,\n                lineUp: [],\n                tieFormat,\n              });\n            }\n          }\n\n          modifyMatchUpNotice({\n            tournamentId: tournamentRecord?.tournamentId,\n            context: 'resetLineUps',\n            eventId: event?.eventId,\n            drawDefinition,\n            matchUp,\n          });\n        }\n      }\n    });\n  }\n\n  return { ...SUCCESS };\n}\n","import { modifyRoundRobinMatchUpsStatus } from '../matchUpStatus/modifyRoundRobinMatchUpsStatus';\nimport { getStructureDrawPositionProfiles } from '../../../query/structure/getStructureDrawPositionProfiles';\nimport { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { assignMatchUpDrawPosition } from './assignMatchUpDrawPosition';\nimport { modifyPositionAssignmentsNotice } from '../../notifications/drawNotifications';\nimport { getStructureSeedAssignments } from '../../../query/structure/getStructureSeedAssignments';\nimport { getRoundMatchUps } from '../../../query/matchUps/getRoundMatchUps';\nimport { structureAssignedDrawPositions } from '../../../query/drawDefinition/positionsGetter';\nimport { getInitialRoundNumber } from '../../../query/matchUps/getInitialRoundNumber';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../../global/functions/decorateResult';\nimport {\n  MatchUpsMap,\n  getMatchUpsMap,\n} from '../../../query/matchUps/getMatchUpsMap';\nimport { getParticipantId } from '../../../global/functions/extractors';\nimport { isValidSeedPosition } from '../../../query/drawDefinition/seedGetter';\nimport { assignSeed } from '../../drawDefinitions/entryGovernor/seedAssignment';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { getTargetMatchUps } from '../../drawDefinitions/positionGovernor/getTargetMatchUps';\nimport { updateSideLineUp } from '../lineUps/updateSideLineUp';\nimport { clearDrawPosition } from './positionClear';\nimport { isAdHoc } from '../../../query/drawDefinition/isAdHoc';\nimport { resetLineUps } from '../lineUps/resetLineUps';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { SeedingProfile } from '../../../types/factoryTypes';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport { TEAM } from '../../../constants/matchUpTypes';\nimport {\n  INVALID_DRAW_POSITION,\n  EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT,\n  INVALID_DRAW_POSITION_FOR_SEEDING,\n  DRAW_POSITION_ACTIVE,\n  MISSING_PARTICIPANT_ID,\n  INVALID_MATCHUP,\n  ErrorType,\n  STRUCTURE_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\nimport {\n  CONSOLATION,\n  CONTAINER,\n  MAIN,\n  PLAY_OFF,\n  QUALIFYING,\n} from '../../../constants/drawDefinitionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  MatchUpStatusUnion,\n  PositionAssignment,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype AssignDrawPositionArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  sourceMatchUpStatus?: MatchUpStatusUnion;\n  provisionalPositioning?: boolean;\n  seedingProfile?: SeedingProfile;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  isQualifierPosition?: boolean;\n  matchUpsMap?: MatchUpsMap;\n  participantId: string;\n  drawPosition: number;\n  seedBlockInfo?: any;\n  structureId: string;\n  event?: Event;\n};\n\nexport function assignDrawPosition({\n  provisionalPositioning,\n  inContextDrawMatchUps,\n  isQualifierPosition, // internal use\n  sourceMatchUpStatus,\n  tournamentRecord,\n  drawDefinition,\n  seedingProfile,\n  participantId,\n  seedBlockInfo,\n  drawPosition,\n  matchUpsMap,\n  structureId,\n  event,\n}: AssignDrawPositionArgs): ResultType & {\n  positionAssignments?: PositionAssignment[];\n} {\n  const stack = 'assignDrawPosition';\n\n  if (!participantId && !isQualifierPosition)\n    return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack });\n\n  matchUpsMap = matchUpsMap ?? getMatchUpsMap({ drawDefinition });\n\n  if (!inContextDrawMatchUps) {\n    ({ matchUps: inContextDrawMatchUps } = getAllDrawMatchUps({\n      inContext: true,\n      drawDefinition,\n      matchUpsMap,\n    }));\n  }\n\n  const result = findStructure({ drawDefinition, structureId });\n  if (result.error) return decorateResult({ result, stack });\n  const { structure } = result;\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  // there are no drawPositions assigned for ADHOC structures\n  if (isAdHoc({ drawDefinition, structure }))\n    return decorateResult({ result: { error: INVALID_MATCHUP }, stack });\n\n  const { seedAssignments } = getStructureSeedAssignments({\n    provisionalPositioning,\n    drawDefinition,\n    structure,\n  });\n\n  const relevantAssignment = seedAssignments?.find(\n    (assignment) => assignment.participantId === participantId\n  );\n  const participantSeedNumber = relevantAssignment?.seedNumber;\n\n  const { appliedPolicies } = getAppliedPolicies({\n    tournamentRecord,\n    drawDefinition,\n    structure,\n    event,\n  });\n  if (participantSeedNumber) {\n    const isValidDrawPosition = isValidSeedPosition({\n      seedNumber: participantSeedNumber,\n      appliedPolicies,\n      drawDefinition,\n      seedBlockInfo,\n      drawPosition,\n      structureId,\n    });\n    if (!isValidDrawPosition)\n      return decorateResult({\n        result: { error: INVALID_DRAW_POSITION_FOR_SEEDING },\n        context: { drawPosition },\n        stack,\n      });\n  }\n\n  const sadp = structureAssignedDrawPositions({ structure });\n  const positionAssignments: PositionAssignment[] =\n    sadp.positionAssignments || [];\n  const positionAssignment = positionAssignments?.find(\n    (assignment) => assignment.drawPosition === drawPosition\n  );\n  if (!positionAssignment)\n    return decorateResult({\n      result: { error: INVALID_DRAW_POSITION },\n      context: { drawPosition },\n      stack,\n    });\n\n  const participantAlreadyAssigned = positionAssignments\n    ?.map(getParticipantId)\n    .includes(participantId);\n\n  if (participantAlreadyAssigned) {\n    return decorateResult({\n      result: { error: EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT },\n      context: { drawPosition },\n      stack,\n    });\n  }\n\n  const { containsParticipant, containsBye } =\n    drawPositionFilled(positionAssignment);\n\n  if (containsBye) {\n    const result = clearDrawPosition({\n      inContextDrawMatchUps,\n      tournamentRecord,\n      drawDefinition,\n      drawPosition,\n      structureId,\n      matchUpsMap,\n      event,\n    }) as { error?: ErrorType };\n    if (result.error) return decorateResult({ result, stack });\n  }\n\n  if (\n    containsParticipant &&\n    positionAssignment.participantId !== participantId\n  ) {\n    const { activeDrawPositions } = getStructureDrawPositionProfiles({\n      drawDefinition,\n      structureId,\n    });\n    const drawPositionIsActive = activeDrawPositions.includes(drawPosition);\n    if (drawPositionIsActive) {\n      return decorateResult({ result: { error: DRAW_POSITION_ACTIVE }, stack });\n    }\n\n    // cleanup side[].lineUps of previous participantId in TEAM matchUps\n    resetLineUps({\n      assignments: [positionAssignment],\n      inContextDrawMatchUps,\n      tournamentRecord,\n      drawDefinition,\n      matchUpsMap,\n      structure,\n    });\n  }\n\n  positionAssignment.participantId = participantId;\n  if (isQualifierPosition) positionAssignment.qualifier = true;\n\n  if (\n    (structure?.stageSequence || 0) > 1 ||\n    (structure.stage && [CONSOLATION, PLAY_OFF].includes(structure.stage))\n  ) {\n    const targetStage = structure.stage === QUALIFYING ? QUALIFYING : MAIN;\n    const targetStructure = drawDefinition.structures?.find(\n      (structure) =>\n        structure?.stage === targetStage && structure?.stageSequence === 1\n    );\n    const seedAssignments = targetStructure?.seedAssignments ?? [];\n    const assignment = seedAssignments.find(\n      (assignment) => assignment.participantId === participantId\n    );\n\n    if (assignment?.participantId) {\n      const { participantId, seedNumber, seedValue } = assignment;\n      assignSeed({\n        eventId: event?.eventId,\n        provisionalPositioning,\n        tournamentRecord,\n        drawDefinition,\n        seedingProfile,\n        participantId,\n        seedNumber,\n        seedValue,\n        // ...assignment,\n        structureId,\n        event,\n      });\n    }\n  }\n\n  if (structure.structureType !== CONTAINER) {\n    addDrawPositionToMatchUps({\n      provisionalPositioning,\n      inContextDrawMatchUps,\n      sourceMatchUpStatus,\n      tournamentRecord,\n      drawDefinition,\n      drawPosition,\n      matchUpsMap,\n      structure,\n      event,\n    });\n  } else {\n    modifyRoundRobinMatchUpsStatus({\n      positionAssignments,\n      tournamentRecord,\n      drawDefinition,\n      matchUpsMap,\n      structure,\n    });\n\n    // for ROUND_ROBIN events with TEAM matchUps, attach default lineUp\n    const { drawPositions, matchUps, targetMatchUps } = getTargetMatchUps({\n      assignments: [positionAssignment],\n      inContextDrawMatchUps,\n      drawDefinition,\n      matchUpsMap,\n      structure,\n    });\n\n    // if a team participant is being assigned and there is a default lineUp, attach to side\n    if (\n      drawPositions &&\n      matchUps?.length === 1 &&\n      matchUps[0].matchUpType === TEAM\n    ) {\n      const sides: any = targetMatchUps?.[0].sides ?? [];\n      const drawPositionSideIndex = sides.reduce(\n        (sideIndex, side, i: number) =>\n          drawPositions?.includes(side.drawPosition) ? i : sideIndex,\n        undefined\n      );\n\n      updateSideLineUp({\n        inContextTargetMatchUp: targetMatchUps[0],\n        teamParticipantId: participantId,\n        matchUp: matchUps[0],\n        drawPositionSideIndex,\n        tournamentRecord,\n        drawDefinition,\n      });\n    }\n  }\n\n  modifyPositionAssignmentsNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    drawDefinition,\n    structure,\n    event,\n  });\n\n  return { positionAssignments, ...SUCCESS };\n\n  function drawPositionFilled(positionAssignment) {\n    const containsBye = positionAssignment.bye;\n    const containsQualifier = positionAssignment.qualifier;\n    const containsParticipant = positionAssignment.participantId;\n    const filled = containsBye || containsQualifier || containsParticipant;\n    return { containsBye, containsQualifier, containsParticipant, filled };\n  }\n}\n\n// used for matchUps which are NOT in a ROUND_ROBIN { structureType: CONTAINER }\nfunction addDrawPositionToMatchUps({\n  provisionalPositioning,\n  inContextDrawMatchUps,\n  sourceMatchUpStatus,\n  tournamentRecord,\n  drawDefinition,\n  drawPosition,\n  matchUpsMap,\n  structure,\n  event,\n}) {\n  const matchUpFilters = { isCollectionMatchUp: false };\n  const { matchUps } = getAllStructureMatchUps({\n    provisionalPositioning,\n    matchUpFilters,\n    drawDefinition,\n    matchUpsMap,\n    structure,\n    event,\n  });\n\n  const { roundMatchUps } = getRoundMatchUps({ matchUps });\n  const { initialRoundNumber } = getInitialRoundNumber({\n    drawPosition,\n    matchUps,\n  });\n\n  const matchUp =\n    initialRoundNumber &&\n    roundMatchUps?.[initialRoundNumber].find(\n      (matchUp) => matchUp.drawPositions?.includes(drawPosition)\n    );\n\n  if (matchUp) {\n    const result = assignMatchUpDrawPosition({\n      matchUpId: matchUp.matchUpId,\n      inContextDrawMatchUps,\n      sourceMatchUpStatus,\n      tournamentRecord,\n      drawDefinition,\n      drawPosition,\n      matchUpsMap,\n    });\n    if (result.error)\n      return decorateResult({\n        stack: 'assignDrawPositionToMatchUps',\n        context: { drawPosition },\n        result,\n      });\n  }\n  return { ...SUCCESS };\n}\n","import { conditionallyDisableLinkPositioning } from '../../drawDefinitions/positionGovernor/conditionallyDisableLinkPositioning';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { getMatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { addPositionActionTelemetry } from '../../drawDefinitions/positionGovernor/addPositionActionTelemetry';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { assignDrawPosition } from './positionAssignment';\nimport { clearDrawPosition } from './positionClear';\n\nimport { MISSING_DRAW_DEFINITION } from '../../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\nexport function positionParticipantAction(params) {\n  const {\n    participantIdAttributeName = 'participantId',\n    isQualifierPosition,\n    positionActionName,\n    tournamentRecord,\n    drawDefinition,\n    participantId,\n    drawPosition,\n    structureId,\n    event,\n  } = params;\n\n  const stack = 'positionParticipantAction';\n\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  let { inContextDrawMatchUps, matchUpsMap } = params;\n\n  if (!matchUpsMap) {\n    matchUpsMap = getMatchUpsMap({ drawDefinition });\n    Object.assign(params, { matchUpsMap });\n  }\n\n  if (!inContextDrawMatchUps) {\n    ({ matchUps: inContextDrawMatchUps } = getAllDrawMatchUps({\n      inContext: true,\n      drawDefinition,\n      matchUpsMap,\n    }));\n    Object.assign(params, { inContextDrawMatchUps });\n  }\n\n  const { positionAssignments } = getPositionAssignments({\n    drawDefinition,\n    structureId,\n  });\n  const positionAssignment = positionAssignments?.find(\n    (assignment) => assignment.drawPosition === drawPosition\n  );\n\n  if (positionAssignment?.participantId) {\n    const removedParticipantId = positionAssignment.participantId;\n    const result = assignDrawPosition({\n      inContextDrawMatchUps,\n      tournamentRecord,\n      drawDefinition,\n      participantId,\n      drawPosition,\n      structureId,\n      matchUpsMap,\n      event,\n    });\n    if (!result.success) {\n      return decorateResult({ result, stack });\n    }\n    return successNotice({\n      removedParticipantId,\n    });\n  }\n\n  const result = clearDrawPosition({\n    inContextDrawMatchUps,\n    tournamentRecord,\n    drawDefinition,\n    drawPosition,\n    structureId,\n    matchUpsMap,\n    event,\n  });\n  if (result.error) return decorateResult({ result, stack });\n  const removedParticipantId = result.participantId;\n\n  const assignResult = assignDrawPosition({\n    inContextDrawMatchUps,\n    isQualifierPosition,\n    tournamentRecord,\n    drawDefinition,\n    participantId,\n    drawPosition,\n    structureId,\n    matchUpsMap,\n    event,\n  });\n  if (!assignResult.success)\n    return decorateResult({ result: assignResult, stack });\n\n  return successNotice({ removedParticipantId });\n\n  function successNotice({ removedParticipantId }) {\n    const { structure } = findStructure({ drawDefinition, structureId });\n    conditionallyDisableLinkPositioning({\n      drawPositions: [drawPosition],\n      structure,\n    });\n    const positionAction = {\n      [participantIdAttributeName]: participantId,\n      name: positionActionName,\n      drawPosition,\n      structureId,\n    };\n\n    addPositionActionTelemetry({ drawDefinition, positionAction });\n\n    return decorateResult({\n      context: { removedParticipantId },\n      result: { ...SUCCESS },\n      stack,\n    });\n  }\n}\n","import { allTournamentMatchUps } from '../query/matchUps/getAllTournamentMatchUps';\nimport { hydrateParticipants } from '../query/participants/hydrateParticipants';\nimport { getContextContent } from '../query/hierarchical/getContextContent';\nimport { allDrawMatchUps } from '../query/matchUps/getAllDrawMatchUps';\nimport { makeDeepCopy } from '../utilities/makeDeepCopy';\nimport { findDrawMatchUp } from './findDrawMatchUp';\nimport { findEvent } from './findEvent';\n\nimport { HydratedMatchUp } from '../types/hydrated';\nimport {\n  ContextContent,\n  ContextProfile,\n  ParticipantsProfile,\n} from '../types/factoryTypes';\nimport {\n  DrawDefinition,\n  Tournament,\n  Event,\n  Structure,\n} from '../types/tournamentTypes';\nimport {\n  DRAW_DEFINITION_NOT_FOUND,\n  ErrorType,\n  MATCHUP_NOT_FOUND,\n  MISSING_MATCHUP_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../constants/errorConditionConstants';\n\ntype FindMatchUpType = {\n  participantsProfile?: ParticipantsProfile;\n  contextContent?: ContextContent;\n  contextProfile?: ContextProfile;\n  drawDefinition?: DrawDefinition;\n  afterRecoveryTimes?: boolean;\n  tournamentRecord: Tournament;\n  nextMatchUps?: boolean;\n  inContext?: boolean;\n  matchUpId: string;\n  eventId?: string;\n  drawId?: string;\n  event?: Event;\n};\n\ntype FindMatchUpResult = {\n  drawDefinition?: DrawDefinition;\n  matchUp?: HydratedMatchUp;\n  structure?: Structure;\n  error?: ErrorType;\n};\n\nexport function publicFindMatchUp(params: FindMatchUpType): FindMatchUpResult {\n  Object.assign(params, { inContext: true });\n  const { matchUp, error } = findMatchUp(params);\n  return { matchUp: makeDeepCopy(matchUp, true, true), error };\n}\n\nexport function findMatchUp({\n  participantsProfile,\n  afterRecoveryTimes,\n  tournamentRecord,\n  contextContent,\n  contextProfile,\n  drawDefinition,\n  nextMatchUps,\n  matchUpId,\n  inContext,\n  eventId,\n  drawId,\n  event,\n}: FindMatchUpType): FindMatchUpResult {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (typeof matchUpId !== 'string') return { error: MISSING_MATCHUP_ID };\n\n  // brute force\n  if (!drawDefinition || !event) {\n    const matchUps =\n      allTournamentMatchUps({ tournamentRecord, nextMatchUps }).matchUps ?? [];\n\n    const inContextMatchUp = matchUps.find(\n      (matchUp) => matchUp.matchUpId === matchUpId\n    );\n    if (!inContextMatchUp) return { error: MATCHUP_NOT_FOUND };\n\n    // since drawEngineFindMatchUp is being used, additional context needs to be provided\n    ({ eventId, drawId } = inContextMatchUp);\n    ({ event, drawDefinition } = findEvent({\n      tournamentRecord,\n      eventId,\n      drawId,\n    }));\n  }\n\n  if (!drawDefinition) return { error: DRAW_DEFINITION_NOT_FOUND };\n\n  if (contextProfile && !contextContent)\n    contextContent = getContextContent({ tournamentRecord, contextProfile });\n\n  const additionalContext = {\n    surfaceCategory: event?.surfaceCategory ?? tournamentRecord.surfaceCategory,\n    indoorOutDoor: event?.indoorOutdoor ?? tournamentRecord.indoorOutdoor,\n    endDate: event?.endDate ?? tournamentRecord.endDate,\n    tournamentId: tournamentRecord.tournamentId,\n    eventId: eventId ?? event?.eventId,\n    drawId,\n  };\n\n  const { participants: tournamentParticipants = [] } = hydrateParticipants({\n    participantsProfile,\n    tournamentRecord,\n    contextProfile,\n    inContext,\n  });\n\n  if (nextMatchUps) {\n    const matchUps =\n      allDrawMatchUps({\n        context: inContext ? additionalContext : undefined,\n        participants: tournamentParticipants,\n        afterRecoveryTimes,\n        contextContent,\n        contextProfile,\n        drawDefinition,\n        nextMatchUps,\n        inContext,\n        event,\n      }).matchUps ?? [];\n    const inContextMatchUp = matchUps.find(\n      (matchUp) => matchUp.matchUpId === matchUpId\n    );\n    if (!inContextMatchUp) return { error: MATCHUP_NOT_FOUND };\n    const structure = drawDefinition?.structures?.find(\n      (structure) => structure.structureId === inContextMatchUp.structureId\n    );\n    return { drawDefinition, structure, matchUp: inContextMatchUp };\n  } else {\n    const { matchUp, structure } = findDrawMatchUp({\n      context: inContext ? additionalContext : undefined,\n      tournamentParticipants,\n      afterRecoveryTimes,\n      contextContent,\n      drawDefinition,\n      contextProfile,\n      matchUpId,\n      inContext,\n      event,\n    });\n\n    return { matchUp, structure, drawDefinition };\n  }\n}\n","import { findMatchUp } from '../acquire/findMatchUp';\nimport { isObject, isString } from '../utilities/objects';\n\nimport { MATCHUP, STRUCTURE } from '../constants/attributeConstants';\nimport {\n  ErrorType,\n  INVALID_VALUES,\n  NOT_FOUND,\n} from '../constants/errorConditionConstants';\n\ntype Params = { [key: string]: any };\ntype ParamsToResolve = {\n  attr?: { [key: string]: any }; // passed into resolution function\n  error?: ErrorType;\n  validate?: any;\n  param: string;\n  type?: string;\n}[];\n\nexport function resolveFromParameters(\n  params: Params,\n  paramsToResolve: ParamsToResolve\n) {\n  if (!isObject(params)) return { error: INVALID_VALUES };\n  if (!Array.isArray(paramsToResolve)) return { error: INVALID_VALUES };\n\n  const resolutions: any = {};\n  for (const { param, error, attr } of paramsToResolve) {\n    const resolution = findResolution({ params, param, attr, error });\n    if (resolution?.error) return resolution;\n    resolutions[param] = resolution;\n  }\n\n  return resolutions;\n}\n\nfunction findResolution({ params, param, attr, error }) {\n  if (\n    param === STRUCTURE &&\n    isObject(params.drawDefinition) &&\n    isString(params.structureId)\n  ) {\n    const result = (params.drawDefinition.structures ?? []).find(\n      ({ structureId }) => structureId === params.structureId\n    );\n    return !result.length && error ? { error } : { structure: result };\n  }\n\n  if (param === MATCHUP) {\n    const result = findMatchUp({\n      ...params,\n      ...attr,\n    });\n    return result.error && error ? { ...result, error } : result;\n  }\n\n  return { error: NOT_FOUND, info: { param } };\n}\n","import { addTimeItem } from '../../timeItems/addTimeItem';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\n\nimport { MATCHUP_NOT_FOUND } from '../../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  DrawDefinition,\n  Event,\n  TimeItem,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\n/*\n  generic function to addMatchUpTimeItem\n  must retrieve matchUp WITHOUT CONTEXT so original can be modified\n*/\n\ntype AddMatchUpTimeItem = {\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  removePriorValues?: boolean;\n  duplicateValues?: boolean;\n  disableNotice?: boolean;\n  timeItem: TimeItem;\n  matchUpId: string;\n  event?: Event;\n};\nexport function addMatchUpTimeItem({\n  removePriorValues,\n  tournamentRecord,\n  duplicateValues,\n  drawDefinition,\n  disableNotice,\n  matchUpId,\n  timeItem,\n  event,\n}: AddMatchUpTimeItem) {\n  const { matchUp } = findDrawMatchUp({ drawDefinition, event, matchUpId });\n  if (!matchUp) return { error: MATCHUP_NOT_FOUND };\n\n  const result = addTimeItem({\n    removePriorValues,\n    element: matchUp,\n    duplicateValues,\n    timeItem,\n  });\n  if (!disableNotice) {\n    modifyMatchUpNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      eventId: event?.eventId,\n      context: 'addTimeItem',\n      drawDefinition,\n      matchUp,\n    });\n  }\n  return result;\n}\n\ntype ResetMatchUpTimeItemsArgs = {\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpId: string;\n  event?: Event;\n};\nexport function resetMatchUpTimeItems({\n  tournamentRecord,\n  drawDefinition,\n  matchUpId,\n  event,\n}: ResetMatchUpTimeItemsArgs) {\n  const { matchUp } = findDrawMatchUp({ drawDefinition, event, matchUpId });\n  if (!matchUp) return { error: MATCHUP_NOT_FOUND };\n  matchUp.timeItems = [];\n  modifyMatchUpNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    context: 'resetTimeItems',\n    eventId: event?.eventId,\n    drawDefinition,\n    matchUp,\n  });\n  return { ...SUCCESS };\n}\n","import { getCheckedInParticipantIds } from '../../../query/matchUp/getCheckedInParticipantIds';\nimport { getMatchUpParticipantIds } from '../../../query/matchUp/getMatchUpParticipantIds';\nimport { checkRequiredParameters } from '../../../parameters/checkRequiredParameters';\nimport { resolveFromParameters } from '../../../parameters/resolveFromParameters';\nimport { checkScoreHasValue } from '../../../query/matchUp/checkScoreHasValue';\nimport { addMatchUpTimeItem } from './matchUpTimeItems';\n\nimport { activeMatchUpStatuses, completedMatchUpStatuses } from '../../../constants/matchUpStatusConstants';\nimport { CheckInOutParticipantArgs } from '../../../types/factoryTypes';\nimport { CHECK_OUT } from '../../../constants/timeItemConstants';\nimport {\n  INVALID_ACTION,\n  INVALID_PARTICIPANT_ID,\n  PARTICIPANT_NOT_CHECKED_IN,\n} from '../../../constants/errorConditionConstants';\nimport {\n  DRAW_DEFINITION,\n  IN_CONTEXT,\n  MATCHUP,\n  MATCHUP_ID,\n  PARAM,\n  PARTICIPANT_ID,\n  TOURNAMENT_RECORD,\n} from '../../../constants/attributeConstants';\n\nexport function checkOutParticipant(params: CheckInOutParticipantArgs) {\n  const requiredParams = [\n    { [TOURNAMENT_RECORD]: true },\n    { [DRAW_DEFINITION]: true },\n    { [PARTICIPANT_ID]: true },\n    { [MATCHUP_ID]: true },\n  ];\n  const paramCheck = checkRequiredParameters(params, requiredParams);\n  if (paramCheck.error) return paramCheck;\n\n  const resolutions = resolveFromParameters(params, [{ [PARAM]: MATCHUP, attr: { [IN_CONTEXT]: true } }]);\n  if (resolutions.error) return resolutions;\n\n  const { tournamentRecord, drawDefinition, participantId, matchUpId } = params;\n\n  const matchUp = resolutions?.matchUp?.matchUp;\n  const { matchUpStatus, score } = matchUp ?? {};\n\n  if (\n    (matchUpStatus && activeMatchUpStatuses.includes(matchUpStatus)) ||\n    (matchUpStatus && completedMatchUpStatuses.includes(matchUpStatus)) ||\n    checkScoreHasValue({ score })\n  ) {\n    return { error: INVALID_ACTION };\n  }\n\n  const getCheckedResult = getCheckedInParticipantIds({\n    matchUp,\n  });\n  if (getCheckedResult?.error) return getCheckedResult;\n  const { checkedInParticipantIds, allRelevantParticipantIds } = getCheckedResult ?? {};\n\n  if (!allRelevantParticipantIds?.includes(participantId)) {\n    return { error: INVALID_PARTICIPANT_ID };\n  }\n  if (!checkedInParticipantIds?.includes(participantId)) {\n    return { error: PARTICIPANT_NOT_CHECKED_IN };\n  }\n\n  const getIdsResult = getMatchUpParticipantIds({ matchUp });\n  if (getIdsResult?.error) return getIdsResult;\n\n  const { sideParticipantIds, nestedIndividualParticipantIds } = getIdsResult ?? {};\n\n  const sideIndex = sideParticipantIds?.indexOf(participantId);\n  if (sideIndex !== undefined && [0, 1].includes(sideIndex)) {\n    (nestedIndividualParticipantIds?.[sideIndex] ?? []).forEach((participantId) => {\n      const timeItem = {\n        itemType: CHECK_OUT,\n        itemValue: participantId,\n      };\n      addMatchUpTimeItem({ drawDefinition, matchUpId, timeItem });\n    });\n  }\n\n  const timeItem = {\n    itemValue: participantId,\n    itemType: CHECK_OUT,\n  };\n\n  return addMatchUpTimeItem({\n    tournamentRecord,\n    drawDefinition,\n    matchUpId,\n    timeItem,\n  });\n}\n","import { getCheckedInParticipantIds } from '../../../query/matchUp/getCheckedInParticipantIds';\nimport { checkRequiredParameters } from '../../../parameters/checkRequiredParameters';\nimport { resolveFromParameters } from '../../../parameters/resolveFromParameters';\nimport { addMatchUpTimeItem } from './matchUpTimeItems';\n\nimport { INVALID_PARTICIPANT_ID } from '../../../constants/errorConditionConstants';\nimport { CheckInOutParticipantArgs } from '../../../types/factoryTypes';\nimport { CHECK_IN } from '../../../constants/timeItemConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  DRAW_DEFINITION,\n  ERROR,\n  IN_CONTEXT,\n  MATCHUP,\n  MATCHUP_ID,\n  PARAM,\n  PARTICIPANT_ID,\n  TOURNAMENT_RECORD,\n} from '../../../constants/attributeConstants';\n\nexport function checkInParticipant(params: CheckInOutParticipantArgs) {\n  const requiredParams = [\n    { [TOURNAMENT_RECORD]: true },\n    { [DRAW_DEFINITION]: true },\n    { [PARTICIPANT_ID]: true },\n    { [MATCHUP_ID]: true },\n  ];\n  const paramCheck = checkRequiredParameters(params, requiredParams);\n  if (paramCheck[ERROR]) return paramCheck;\n\n  const resolutions = resolveFromParameters(params, [{ [PARAM]: MATCHUP, attr: { [IN_CONTEXT]: true } }]);\n  if (resolutions[ERROR]) return resolutions;\n\n  const { tournamentRecord, drawDefinition, participantId, matchUpId } = params;\n\n  const result = getCheckedInParticipantIds({\n    matchUp: resolutions?.matchUp?.matchUp,\n  });\n  if (result?.error) return result;\n\n  const { checkedInParticipantIds, allRelevantParticipantIds } = result ?? {};\n\n  if (checkedInParticipantIds?.includes(participantId)) return { ...SUCCESS };\n\n  if (!allRelevantParticipantIds?.includes(participantId)) return { [ERROR]: INVALID_PARTICIPANT_ID };\n\n  const timeItem = {\n    itemValue: participantId,\n    itemType: CHECK_IN,\n  };\n\n  return addMatchUpTimeItem({\n    tournamentRecord,\n    drawDefinition,\n    matchUpId,\n    timeItem,\n  });\n}\n","import { getCheckedInParticipantIds } from '../../../query/matchUp/getCheckedInParticipantIds';\nimport { checkRequiredParameters } from '../../../parameters/checkRequiredParameters';\nimport { resolveFromParameters } from '../../../parameters/resolveFromParameters';\nimport { checkOutParticipant } from './checkOutParticipant';\nimport { checkInParticipant } from './checkInParticipant';\n\nimport { MATCHUP_NOT_FOUND, MISSING_TOURNAMENT_RECORD } from '../../../constants/errorConditionConstants';\nimport { DrawDefinition, Tournament } from '../../../types/tournamentTypes';\nimport { TournamentRecords } from '../../../types/factoryTypes';\nimport {\n  DRAW_DEFINITION,\n  ERROR,\n  MATCHUP,\n  MATCHUP_ID,\n  PARAM,\n  PARTICIPANT_ID,\n} from '../../../constants/attributeConstants';\n\ntype ToggleParticipantCheckInStateArgs = {\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  activeTournamentId?: string;\n  participantId: string;\n  tournamentId?: string;\n  matchUpIds?: string[];\n  matchUpId: string;\n};\n\nexport function toggleParticipantCheckInState(params: ToggleParticipantCheckInStateArgs) {\n  const paramCheck = checkRequiredParameters(params, [\n    { [PARTICIPANT_ID]: true, [DRAW_DEFINITION]: true, [MATCHUP_ID]: true },\n  ]);\n  if (paramCheck.error) return paramCheck;\n\n  const tournamentId = params.tournamentId ?? params.activeTournamentId;\n  const tournamentRecord = params.tournamentRecord ?? (tournamentId && params.tournamentRecords?.[tournamentId]);\n\n  const { participantId, matchUpId, drawDefinition } = params;\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const resolutions = resolveFromParameters(params, [{ [PARAM]: MATCHUP, [ERROR]: MATCHUP_NOT_FOUND }]);\n  const matchUp = resolutions.matchUp?.matchUp;\n  if (!matchUp) return { error: MATCHUP_NOT_FOUND };\n\n  const { checkedInParticipantIds = [] } = getCheckedInParticipantIds({\n    matchUp,\n  });\n\n  if (participantId && checkedInParticipantIds.includes(participantId)) {\n    return checkOutParticipant({\n      tournamentRecord,\n      drawDefinition,\n      participantId,\n      matchUpId,\n      matchUp,\n    });\n  } else {\n    return checkInParticipant({\n      tournamentRecord,\n      drawDefinition,\n      participantId,\n      matchUpId,\n      matchUp,\n    });\n  }\n}\n","import { resolveTieFormat } from '../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { getPositionAssignments } from '../../query/drawDefinition/positionsGetter';\nimport { getParticipants } from '../../query/participants/getParticipants';\nimport { getMatchUpsMap } from '../../query/matchUps/getMatchUpsMap';\nimport { findDrawMatchUp } from '../../acquire/findDrawMatchUp';\nimport { xa } from '../../utilities/objects';\n\nimport { DOUBLES, SINGLES } from '../../constants/matchUpTypes';\nimport { TEAM } from '../../constants/participantConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport {\n  EVENT_NOT_FOUND,\n  ErrorType,\n  INVALID_MATCHUP,\n  MATCHUP_NOT_FOUND,\n  MISSING_DRAW_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  MatchUp,\n  Participant,\n  Structure,\n  TieFormat,\n  Tournament,\n} from '../../types/tournamentTypes';\n\n// for a given tieMatchUpId (SINGLES or DOUBLES) return:\n// the tieMatchUp, the dualMatchUp within which it occurs, an inContext copy of the dualMatchUp\n// the tieFormat, collectionId and collectionPosition & etc.\n\ntype GetTieMatchUpContextArgs = {\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  tieMatchUpId: string;\n  event: Event;\n};\nexport function getTieMatchUpContext({\n  tournamentRecord,\n  drawDefinition,\n  tieMatchUpId,\n  event,\n}: GetTieMatchUpContextArgs): {\n  inContextDualMatchUp?: HydratedMatchUp;\n  inContextTieMatchUp?: HydratedMatchUp;\n  teamParticipants?: Participant[];\n  relevantAssignments?: any[];\n  collectionPosition?: number;\n  drawPositions?: number[];\n  tieFormat?: TieFormat;\n  collectionId?: string;\n  dualMatchUp?: MatchUp;\n  matchUpTieId?: string;\n  structure?: Structure;\n  matchUpType?: string;\n  tieMatchUp?: MatchUp;\n  error?: ErrorType;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!drawDefinition) return { error: MISSING_DRAW_ID };\n  if (!event) return { error: EVENT_NOT_FOUND };\n\n  const matchUpsMap = getMatchUpsMap({ drawDefinition });\n\n  // tieMatchUp is matchUpType: SINGLES or DOUBLES\n  const { matchUp: tieMatchUp } = findDrawMatchUp({\n    matchUpId: tieMatchUpId,\n    drawDefinition,\n    matchUpsMap,\n  });\n  if (!tieMatchUp) return { error: MATCHUP_NOT_FOUND };\n\n  const { matchUp: inContextTieMatchUp, structure } = findDrawMatchUp({\n    tournamentParticipants: tournamentRecord.participants,\n    matchUpId: tieMatchUpId,\n    inContext: true,\n    drawDefinition,\n    matchUpsMap,\n    event,\n  });\n  if (!inContextTieMatchUp) return { error: MATCHUP_NOT_FOUND };\n\n  const { collectionPosition, drawPositions, collectionId, matchUpTieId, matchUpType } = inContextTieMatchUp;\n\n  if (matchUpType && ![SINGLES, DOUBLES].includes(matchUpType)) return { error: INVALID_MATCHUP };\n\n  const { positionAssignments } = getPositionAssignments({ structure });\n  const relevantAssignments = positionAssignments?.filter(\n    (assignment) => drawPositions?.includes(assignment.drawPosition),\n  );\n\n  const { matchUp: dualMatchUp } = findDrawMatchUp({\n    matchUpId: matchUpTieId,\n    drawDefinition,\n    matchUpsMap,\n  });\n\n  const sideParticipantIds = dualMatchUp?.sides?.map(xa('participantId')) ?? [];\n\n  const assignedParticipantIds = relevantAssignments?.map(xa('participantId')) ?? [];\n\n  const participantIds = [...sideParticipantIds, ...assignedParticipantIds];\n\n  const { participants: teamParticipants } = getParticipants({\n    tournamentRecord,\n    participantFilters: {\n      participantTypes: [TEAM],\n      participantIds,\n    },\n  });\n\n  const { matchUp: inContextDualMatchUp } = findDrawMatchUp({\n    matchUpId: matchUpTieId,\n    inContext: true,\n    drawDefinition,\n    matchUpsMap,\n  });\n\n  const tieFormat = resolveTieFormat({\n    matchUp: dualMatchUp,\n    drawDefinition,\n    structure,\n    event,\n  })?.tieFormat;\n\n  return {\n    inContextDualMatchUp,\n    inContextTieMatchUp,\n    relevantAssignments,\n    collectionPosition,\n    teamParticipants,\n    collectionId,\n    matchUpType,\n    dualMatchUp,\n    tieMatchUp,\n    tieFormat,\n    structure,\n    ...SUCCESS,\n  };\n}\n","import { decorateResult } from '../../global/functions/decorateResult';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { addNotice } from '../../global/state/globalState';\nimport { intersection } from '../../utilities/arrays';\nimport { UUID } from '../../utilities/UUID';\n\nimport { ADD_PARTICIPANTS } from '../../constants/topicConstants';\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { Tournament } from '../../types/tournamentTypes';\nimport {\n  GROUP,\n  INDIVIDUAL,\n  PAIR,\n  participantTypes,\n  TEAM,\n} from '../../constants/participantConstants';\nimport {\n  INVALID_PARTICIPANT_IDS,\n  INVALID_PARTICIPANT_TYPE,\n  MISSING_PARTICIPANT_ROLE,\n  MISSING_PARTICIPANT_IDS,\n  MISSING_PERSON_DETAILS,\n  MISSING_TOURNAMENT_RECORD,\n  PARTICIPANT_ID_EXISTS,\n  MISSING_PARTICIPANT,\n  INVALID_VALUES,\n  PARTICIPANT_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\ntype AddParticipantType = {\n  allowDuplicateParticipantIdPairs?: boolean;\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord: Tournament;\n  activeTournamentId?: string;\n  returnParticipant?: boolean;\n  disableNotice?: boolean;\n  pairOverride?: boolean;\n  tournamentId?: string;\n  participant: any; // participantId may be missing and is added by the method\n};\n\nexport function addParticipant(params: AddParticipantType) {\n  const stack = 'addParticipant';\n\n  const {\n    allowDuplicateParticipantIdPairs,\n    returnParticipant,\n    disableNotice,\n    pairOverride,\n    participant,\n  } = params;\n\n  const tournamentRecord = params.tournamentId // if a tournamentId is specified, use it!\n    ? params.tournamentRecords?.[params.tournamentId]\n    : params.tournamentRecord ??\n      (params.activeTournamentId &&\n        params.tournamentRecords?.[params.activeTournamentId]);\n\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!participant)\n    return decorateResult({ result: { error: MISSING_PARTICIPANT }, stack });\n  if (!participant.participantId) participant.participantId = UUID();\n  if (!tournamentRecord.participants) tournamentRecord.participants = [];\n\n  const { participantId, individualParticipantIds } = participant;\n\n  const idExists = tournamentRecord.participants.reduce(\n    (p, c) => c.participantId === participantId || p,\n    false\n  );\n  if (idExists) return { error: PARTICIPANT_ID_EXISTS };\n\n  const { participantType, participantRole } = participant;\n  if (\n    !participantType ||\n    !Object.keys(participantTypes).includes(participantType)\n  )\n    return { error: INVALID_PARTICIPANT_TYPE, participantType };\n\n  if (!participantRole) return { error: MISSING_PARTICIPANT_ROLE };\n\n  const tournamentParticipants = tournamentRecord.participants || [];\n  const tournamentIndividualParticipantIds = tournamentParticipants\n    .filter(\n      (tournamentParticipant) =>\n        tournamentParticipant.participantType === INDIVIDUAL\n    )\n    .map((individualParticipant) => individualParticipant.participantId);\n\n  if (participantType !== INDIVIDUAL && participant.person)\n    return { error: INVALID_VALUES, person: participant.person };\n\n  if (individualParticipantIds && !Array.isArray(individualParticipantIds))\n    return { error: INVALID_VALUES, individualParticipantIds };\n\n  if (participantType === PAIR) {\n    if (participant.person)\n      return { error: INVALID_VALUES, person: participant.person };\n    if (!participant.individualParticipantIds) {\n      return decorateResult({\n        result: { error: MISSING_PARTICIPANT_IDS },\n        stack,\n      });\n    } else if (\n      participant.individualParticipantIds.length !== 2 &&\n      !pairOverride\n    ) {\n      return decorateResult({\n        info: 'PAIR must be 2 individualParticipantIds',\n        result: { error: INVALID_PARTICIPANT_IDS },\n        stack,\n      });\n    } else {\n      const individualParticipantIds = tournamentParticipants\n        .filter((participant) => participant.participantType === INDIVIDUAL)\n        .map((participant) => participant.participantId);\n\n      if (!Array.isArray(participant.individualParticipantIds))\n        return decorateResult({\n          result: { error: INVALID_PARTICIPANT_IDS },\n          stack,\n        });\n\n      const validPairParticipants = participant.individualParticipantIds.reduce(\n        (valid, participantId) =>\n          individualParticipantIds.includes(participantId) && valid,\n        true\n      );\n      if (!validPairParticipants)\n        return decorateResult({\n          result: { error: INVALID_PARTICIPANT_IDS },\n          stack,\n        });\n    }\n\n    const existingPairParticipants = tournamentParticipants\n      .filter((participant) => participant.participantType === PAIR)\n      .map((participant) => ({\n        individualParticipantIds: participant.individualParticipantIds,\n        participant,\n      }));\n\n    // determine whether a PAIR participant already exists\n    const existingPairParticipant =\n      participant.participantType === PAIR &&\n      existingPairParticipants.find(\n        (existingPairParticipant) =>\n          intersection(\n            existingPairParticipant.individualParticipantIds,\n            participant.individualParticipantIds\n          ).length === 2\n      );\n\n    if (existingPairParticipant && !allowDuplicateParticipantIdPairs) {\n      return {\n        ...SUCCESS,\n        existingParticipant: true,\n        participant:\n          returnParticipant &&\n          makeDeepCopy(existingPairParticipant.participant),\n      };\n    }\n\n    if (!participant.participantName) {\n      const individualParticipants = tournamentParticipants.filter(\n        (tournamentParticipant) =>\n          participant.individualParticipantIds?.includes(\n            tournamentParticipant.participantId\n          )\n      );\n\n      let participantName = individualParticipants\n        .map((participant) => participant.person?.standardFamilyName)\n        .filter(Boolean)\n        .join('/');\n      if (individualParticipants.length === 1) participantName += '/Unknown';\n\n      participant.participantName = participantName;\n    }\n  } else if (participantType === INDIVIDUAL) {\n    if (\n      !participant.person?.standardFamilyName ||\n      !participant.person?.standardGivenName\n    )\n      return { error: MISSING_PERSON_DETAILS };\n\n    if (!participant.participantName) {\n      const participantName = `${participant.person.standardFamilyName.toUpperCase()}, ${\n        participant.person.standardGivenName\n      }`;\n      participant.participantName = participantName;\n    }\n  } else if (participantType && [TEAM, GROUP].includes(participantType)) {\n    if (!individualParticipantIds) participant.individualParticipantIds = [];\n    if (participant.individualParticipantIds?.length) {\n      for (const individualParticipantId of participant.individualParticipantIds) {\n        if (typeof individualParticipantId !== 'string') {\n          return decorateResult({\n            result: {\n              participantId: individualParticipantId,\n              error: INVALID_VALUES,\n            },\n            stack,\n          });\n        }\n        if (\n          !tournamentIndividualParticipantIds.includes(individualParticipantId)\n        ) {\n          return decorateResult({\n            result: {\n              participantId: individualParticipantId,\n              error: PARTICIPANT_NOT_FOUND,\n            },\n            stack,\n          });\n        }\n      }\n    }\n  } else {\n    return { error: INVALID_PARTICIPANT_TYPE };\n  }\n\n  tournamentRecord.participants.push(participant);\n\n  if (!disableNotice) {\n    addNotice({\n      payload: {\n        tournamentId: tournamentRecord.tournamentId,\n        participants: [participant],\n      },\n      topic: ADD_PARTICIPANTS,\n    });\n  }\n\n  const result = {\n    participant: returnParticipant && makeDeepCopy(participant),\n    ...SUCCESS,\n  };\n  return definedAttributes(result);\n}\n","import { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { findExtension } from '../../../acquire/findExtension';\n\nimport { DrawDefinition, MatchUp } from '../../../types/tournamentTypes';\nimport { LINEUPS } from '../../../constants/extensionConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\n\ntype EnsureSideLineUpsArgs = {\n  inContextDualMatchUp?: HydratedMatchUp;\n  drawDefinition: DrawDefinition;\n  tournamentId?: string;\n  dualMatchUp?: MatchUp;\n  eventId?: string;\n};\nexport function ensureSideLineUps({\n  inContextDualMatchUp,\n  drawDefinition,\n  tournamentId,\n  dualMatchUp,\n  eventId,\n}: EnsureSideLineUpsArgs) {\n  if (dualMatchUp) {\n    if (!inContextDualMatchUp) {\n      inContextDualMatchUp = findDrawMatchUp({\n        matchUpId: dualMatchUp.matchUpId,\n        inContext: true,\n        drawDefinition,\n      })?.matchUp;\n    }\n\n    const { extension } = findExtension({\n      element: drawDefinition,\n      name: LINEUPS,\n    });\n\n    const lineUps = makeDeepCopy(extension?.value || {}, false, true);\n\n    const extractSideDetail = ({ displaySideNumber, drawPosition, sideNumber }) => ({\n      drawPosition,\n      sideNumber,\n      displaySideNumber,\n    });\n\n    dualMatchUp.sides = inContextDualMatchUp?.sides?.map((contextSide: any) => {\n      const participantId = contextSide.participantId;\n      const referenceLineUp = (participantId && lineUps[participantId]) || undefined;\n      const { lineUp: noContextLineUp, ...noContextSideDetail } =\n        dualMatchUp.sides?.find(({ sideNumber }) => sideNumber === contextSide.sideNumber) ?? {};\n      const lineUp = noContextLineUp?.length ? noContextLineUp : referenceLineUp;\n      return {\n        ...extractSideDetail(contextSide),\n        ...noContextSideDetail,\n        lineUp,\n      };\n    });\n\n    modifyMatchUpNotice({\n      context: 'ensureSidLineUps',\n      matchUp: dualMatchUp,\n      drawDefinition,\n      tournamentId,\n      eventId,\n    });\n  }\n}\n","import { getCollectionPositionAssignments } from '../../events/getCollectionPositionAssignments';\nimport { getPairedParticipant } from '../../../query/participant/getPairedParticipant';\nimport { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { getParticipants } from '../../../query/participants/getParticipants';\nimport { deleteParticipants } from '../../participants/deleteParticipants';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { updateTeamLineUp } from '../../drawDefinitions/updateTeamLineUp';\nimport { getTieMatchUpContext } from '../../events/getTieMatchUpContext';\nimport { addParticipant } from '../../participants/addParticipant';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { ensureSideLineUps } from './ensureSideLineUps';\nimport { unique } from '../../../utilities/arrays';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../../global/functions/decorateResult';\n\nimport POLICY_MATCHUP_ACTIONS_DEFAULT from '../../../fixtures/policies/POLICY_MATCHUP_ACTIONS_DEFAULT';\nimport { POLICY_TYPE_MATCHUP_ACTIONS } from '../../../constants/policyConstants';\nimport { LineUp, PolicyDefinitions } from '../../../types/factoryTypes';\nimport { FEMALE, MALE } from '../../../constants/genderConstants';\nimport { COMPETITOR } from '../../../constants/participantRoles';\nimport { PAIR } from '../../../constants/participantConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { DOUBLES } from '../../../constants/matchUpTypes';\nimport {\n  EXISTING_PARTICIPANT,\n  INVALID_PARTICIPANT,\n  INVALID_PARTICIPANT_TYPE,\n  MISSING_PARTICIPANT_ID,\n  NOT_FOUND,\n  PARTICIPANT_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype ReplaceTieMatchUpParticipantIdArgs = {\n  policyDefinitions?: PolicyDefinitions;\n  existingParticipantId: string;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  newParticipantId: string;\n  enforceGender?: boolean;\n  substitution?: boolean;\n  tieMatchUpId: string;\n  event: Event;\n};\n\nexport function replaceTieMatchUpParticipantId(\n  params: ReplaceTieMatchUpParticipantIdArgs\n): ResultType & {\n  participantRemoved?: string;\n  participantAdded?: string;\n  modifiedLineUp?: LineUp;\n} {\n  const matchUpContext = getTieMatchUpContext(params);\n  if (matchUpContext.error) return matchUpContext;\n  const stack = 'replaceTieMatchUpParticipantid';\n\n  const {\n    existingParticipantId,\n    tournamentRecord,\n    newParticipantId,\n    drawDefinition,\n    substitution,\n    event,\n  } = params;\n\n  if (!existingParticipantId || !newParticipantId)\n    return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack });\n\n  if (existingParticipantId === newParticipantId) return { ...SUCCESS };\n\n  const {\n    inContextDualMatchUp,\n    inContextTieMatchUp,\n    collectionPosition,\n    collectionId,\n    dualMatchUp,\n    tieMatchUp,\n    tieFormat,\n  } = matchUpContext;\n\n  const matchUpType = inContextTieMatchUp?.matchUpType;\n\n  const side: any = inContextTieMatchUp?.sides?.find(\n    (side: any) =>\n      side.participant?.participantId === existingParticipantId ||\n      side.participant?.individualParticipantIds?.includes(\n        existingParticipantId\n      )\n  );\n  if (!side) return { error: PARTICIPANT_NOT_FOUND };\n\n  const targetParticipants =\n    getParticipants({\n      tournamentRecord,\n      participantFilters: {\n        participantIds: [existingParticipantId, newParticipantId],\n      },\n    })?.participants ?? [];\n\n  if (targetParticipants.length !== 2)\n    return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack });\n  if (\n    targetParticipants[0].participantType !==\n    targetParticipants[1].participantType\n  )\n    return decorateResult({\n      result: { error: INVALID_PARTICIPANT_TYPE },\n      stack,\n    });\n\n  const { appliedPolicies } = getAppliedPolicies({\n    tournamentRecord,\n    drawDefinition,\n    event,\n  });\n\n  const matchUpActionsPolicy =\n    params.policyDefinitions?.[POLICY_TYPE_MATCHUP_ACTIONS] ??\n    appliedPolicies?.[POLICY_TYPE_MATCHUP_ACTIONS] ??\n    POLICY_MATCHUP_ACTIONS_DEFAULT[POLICY_TYPE_MATCHUP_ACTIONS];\n\n  const newParticipant = targetParticipants.find(\n    ({ participantId }) => participantId === newParticipantId\n  );\n\n  const genderEnforced =\n    (params.enforceGender ??\n      matchUpActionsPolicy?.participants?.enforceGender) !== false;\n  if (\n    genderEnforced &&\n    [MALE, FEMALE].includes(inContextTieMatchUp?.gender) &&\n    inContextTieMatchUp?.gender !== newParticipant?.person?.sex\n  ) {\n    return { error: INVALID_PARTICIPANT, info: 'Gender mismatch' };\n  }\n\n  const substitutionProcessCodes =\n    matchUpActionsPolicy?.processCodes?.substitution;\n\n  ensureSideLineUps({\n    tournamentId: tournamentRecord.tournamentId,\n    eventId: event.eventId,\n    inContextDualMatchUp,\n    drawDefinition,\n    dualMatchUp,\n  });\n\n  const dualMatchUpSide = dualMatchUp?.sides?.find(\n    ({ sideNumber }) => sideNumber === side.sideNumber\n  );\n\n  if (!dualMatchUpSide) {\n    return decorateResult({\n      result: {\n        sideNumber: side.sideNumber,\n        existingParticipantId,\n        error: NOT_FOUND,\n      },\n      stack,\n    });\n  }\n\n  const allTieIndividualParticipantIds = inContextTieMatchUp?.sides?.flatMap(\n    (side: any) =>\n      side.participant?.individualParticipantIds ||\n      side.participant?.participantId ||\n      []\n  );\n\n  if (allTieIndividualParticipantIds?.includes(newParticipantId)) {\n    return decorateResult({ result: { error: EXISTING_PARTICIPANT }, stack });\n  }\n\n  const teamParticipantId = inContextDualMatchUp?.sides?.find(\n    ({ sideNumber }) => sideNumber === side.sideNumber\n  )?.participantId;\n\n  const teamLineUp = dualMatchUpSide.lineUp;\n  const newParticipantIdInLineUp = teamLineUp?.find(\n    ({ participantId }) => newParticipantId === participantId\n  );\n\n  const substitutionOrder = teamLineUp?.reduce(\n    (order, teamCompetitor: any) =>\n      teamCompetitor.substitutionOrder > order\n        ? teamCompetitor.substitutionOrder\n        : order,\n    0\n  );\n\n  const modifiedLineUp =\n    teamLineUp?.map((teamCompetitor) => {\n      const modifiedCompetitor = makeDeepCopy(teamCompetitor, false, true);\n\n      // if the current competitor is not either id, return as is\n      if (\n        ![existingParticipantId, newParticipantId].includes(\n          modifiedCompetitor.participantId\n        )\n      ) {\n        return modifiedCompetitor;\n      }\n\n      // if current competitor includes an id then filter out current assignment\n      if (\n        !substitution &&\n        [existingParticipantId, newParticipantId].includes(\n          modifiedCompetitor.participantId\n        )\n      ) {\n        modifiedCompetitor.collectionAssignments =\n          modifiedCompetitor.collectionAssignments?.filter(\n            (assignment) =>\n              !(\n                assignment.collectionPosition === collectionPosition &&\n                assignment.collectionId === collectionId\n              )\n          );\n      }\n\n      if (\n        substitution &&\n        existingParticipantId === modifiedCompetitor.participantId\n      ) {\n        modifiedCompetitor.collectionAssignments =\n          modifiedCompetitor.collectionAssignments.map((assignment) => {\n            if (\n              assignment.collectionPosition === collectionPosition &&\n              assignment.collectionId === collectionId &&\n              assignment.substitutionOrder === undefined\n            ) {\n              return { ...assignment, substitutionOrder };\n            }\n            return assignment;\n          });\n      }\n\n      // if current competitor is newParticipantId, push the new assignment\n      if (modifiedCompetitor.participantId === newParticipantId) {\n        if (!modifiedCompetitor.collectionAssignments)\n          modifiedCompetitor.collectionAssignments = [];\n        const assignment: any = { collectionId, collectionPosition };\n        if (substitution) {\n          assignment.previousParticipantId = existingParticipantId;\n          assignment.substitutionOrder = (substitutionOrder ?? 0) + 1;\n        }\n        modifiedCompetitor.collectionAssignments.push(assignment);\n      }\n\n      return modifiedCompetitor;\n    }) ?? [];\n\n  if (!newParticipantIdInLineUp) {\n    const collectionAssignment: any = { collectionId, collectionPosition };\n    if (substitution) {\n      collectionAssignment.substitutionOrder = (substitutionOrder ?? 0) + 1;\n      collectionAssignment.previousParticipantId = existingParticipantId;\n    }\n    const assignment = {\n      collectionAssignments: [collectionAssignment],\n      participantId: newParticipantId,\n    };\n    modifiedLineUp.push(assignment);\n  }\n\n  const isDoubles = matchUpType === DOUBLES;\n\n  const { assignedParticipantIds: existingIndividualParticipantIds } =\n    getCollectionPositionAssignments({\n      lineUp: teamLineUp,\n      collectionPosition,\n      collectionId,\n    });\n\n  // now check whether new pairParticipant exists\n  const { assignedParticipantIds: individualParticipantIds } =\n    getCollectionPositionAssignments({\n      lineUp: modifiedLineUp,\n      collectionPosition,\n      collectionId,\n    });\n\n  dualMatchUpSide.lineUp = modifiedLineUp;\n\n  if (teamParticipantId && tieFormat) {\n    const result = updateTeamLineUp({\n      participantId: teamParticipantId,\n      lineUp: modifiedLineUp,\n      drawDefinition,\n      tieFormat,\n    });\n    if (result.error) return decorateResult({ result, stack });\n  } else {\n    console.log('team participantId not found');\n  }\n\n  let participantAdded, participantRemoved;\n  if (isDoubles) {\n    const { tournamentRecord } = params;\n    let result = getPairedParticipant({\n      participantIds: individualParticipantIds,\n      tournamentRecord,\n    });\n\n    if (!result.participant) {\n      const participant = {\n        participantRole: COMPETITOR,\n        individualParticipantIds,\n        participantType: PAIR,\n      };\n      const result = addParticipant({\n        returnParticipant: true,\n        pairOverride: true,\n        tournamentRecord,\n        participant,\n      });\n      if (result.error) return decorateResult({ result, stack });\n      participantAdded = result.participant?.participantId;\n    }\n\n    // now attempt to cleanup/delete previous pairParticipant\n    result = getPairedParticipant({\n      participantIds: existingIndividualParticipantIds,\n      tournamentRecord,\n    });\n    const existingPairParticipantId = result.participant?.participantId;\n    if (existingPairParticipantId) {\n      const result = deleteParticipants({\n        participantIds: [existingPairParticipantId],\n        tournamentRecord,\n      });\n      if (result.success) participantRemoved = existingPairParticipantId;\n    }\n  }\n\n  if (substitution || side.substitutions?.length === 1) {\n    if (substitution) {\n      if (substitutionProcessCodes && tieMatchUp) {\n        tieMatchUp.processCodes = unique([\n          ...(tieMatchUp?.processCodes ?? []),\n          ...substitutionProcessCodes,\n        ]);\n      }\n    } else {\n      // if there was only one substitution, remove processCode(s)\n      for (const substitutionProcessCode of substitutionProcessCodes || []) {\n        const codeIndex = tieMatchUp?.processCodes?.lastIndexOf(\n          substitutionProcessCode\n        );\n        // remove only one instance of substitutionProcessCode\n        codeIndex !== undefined &&\n          tieMatchUp?.processCodes?.splice(codeIndex, 1);\n      }\n    }\n\n    if (tieMatchUp) {\n      modifyMatchUpNotice({\n        tournamentId: tournamentRecord?.tournamentId,\n        matchUp: tieMatchUp,\n        context: stack,\n        drawDefinition,\n      });\n    }\n  }\n\n  if (dualMatchUp) {\n    modifyMatchUpNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      matchUp: dualMatchUp,\n      context: stack,\n      drawDefinition,\n    });\n  }\n\n  return { ...SUCCESS, modifiedLineUp, participantRemoved, participantAdded };\n}\n","import { getTeamLineUp } from '../drawDefinitions/getTeamLineUp';\n\nimport { INVALID_VALUES } from '../../constants/errorConditionConstants';\n\nexport function removeCollectionAssignments({\n  collectionPosition,\n  teamParticipantId,\n  dualMatchUpSide,\n  drawDefinition,\n  participantIds,\n  collectionId,\n}) {\n  if (!collectionId || !collectionPosition || !Array.isArray(participantIds))\n    return {\n      modifiedLineUp: dualMatchUpSide?.lineUp || [],\n      error: INVALID_VALUES,\n    };\n\n  const lineUp =\n    dualMatchUpSide?.lineUp ||\n    getTeamLineUp({\n      participantId: teamParticipantId,\n      drawDefinition,\n    })?.lineUp;\n\n  const previousParticipantIds: string[] = [];\n  const assignmentsRemoved: any[] = [];\n\n  const modifiedLineUp =\n    lineUp\n      ?.map((teamCompetitor) => {\n        // don't modify an individual team competitor unless it appears in participantIds\n        if (!participantIds.includes(teamCompetitor.participantId)) {\n          return teamCompetitor;\n        }\n\n        const collectionAssignments =\n          teamCompetitor.collectionAssignments?.filter((assignment) => {\n            const target =\n              assignment.collectionId === collectionId &&\n              assignment.collectionPosition === collectionPosition;\n            if (target) {\n              if (assignment.previousParticipantId) {\n                previousParticipantIds.push(assignment.previousParticipantId);\n              }\n              assignmentsRemoved.push({\n                participantId: teamCompetitor.participantId,\n                ...assignment,\n              });\n            }\n            return !target;\n          });\n        return {\n          participantId: teamCompetitor.participantId,\n          collectionAssignments,\n        };\n      })\n      .filter(Boolean) || [];\n\n  return { modifiedLineUp, assignmentsRemoved, previousParticipantIds };\n}\n","import { addNotice, getTopics } from '../../global/state/globalState';\nimport { updateTeamEventEntries } from './updateTeamEventEntries';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\n\nimport { removeParticipantIdsFromAllTeams } from './removeIndividualParticipantIds';\nimport { GROUP, INDIVIDUAL, TEAM } from '../../constants/participantConstants';\nimport { Participant, Tournament } from '../../types/tournamentTypes';\nimport { MODIFY_PARTICIPANTS } from '../../constants/topicConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_PARTICIPANT_IDS,\n  INVALID_PARTICIPANT_TYPE,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n  PARTICIPANT_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\ntype AddIndividualParticipantIdsType = {\n  individualParticipantIds: string[]; // individual participantIds to be added to grouping participant\n  removeFromOtherTeams?: boolean; // optional -whether or not to remove from other teams\n  groupingParticipantId: string; // grouping participant to which participantIds are to be added\n  tournamentRecord: Tournament; // passed in automatically by tournamentEngine\n};\nexport function addIndividualParticipantIds({\n  individualParticipantIds,\n  groupingParticipantId,\n  removeFromOtherTeams,\n  tournamentRecord,\n}: AddIndividualParticipantIdsType): ResultType & {\n  groupingParticipant?: Participant;\n  added?: number;\n} {\n  const stack = 'addIndividualParticipantIds';\n  if (!tournamentRecord)\n    return decorateResult({\n      result: { error: MISSING_TOURNAMENT_RECORD },\n      stack,\n    });\n  if (!groupingParticipantId || !individualParticipantIds)\n    return decorateResult({ result: { error: MISSING_VALUE }, stack });\n\n  const tournamentParticipants = tournamentRecord.participants ?? [];\n  const groupingParticipant = tournamentParticipants.find(\n    (participant) => participant.participantId === groupingParticipantId\n  );\n  if (!groupingParticipant)\n    return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack });\n\n  if (\n    groupingParticipant?.participantType &&\n    ![TEAM, GROUP].includes(groupingParticipant.participantType)\n  ) {\n    return decorateResult({\n      context: { participantType: groupingParticipant.participantType },\n      result: { error: INVALID_PARTICIPANT_TYPE },\n      stack,\n    });\n  }\n\n  // integrity chck to ensure only individuals can be added to groupings\n  const invalidParticipantIds = individualParticipantIds.filter(\n    (participantId) => {\n      const participant = tournamentParticipants.find(\n        (tournamentParticipant) =>\n          tournamentParticipant.participantId === participantId\n      );\n      return participant?.participantType !== INDIVIDUAL;\n    }\n  );\n\n  if (invalidParticipantIds.length)\n    return decorateResult({\n      result: { error: INVALID_PARTICIPANT_IDS, invalidParticipantIds },\n      stack,\n    });\n\n  if (!groupingParticipant.individualParticipantIds)\n    groupingParticipant.individualParticipantIds = [];\n  const existingIndividualParticipantIds =\n    groupingParticipant.individualParticipantIds;\n\n  const participantIdsToAdd = individualParticipantIds.filter(\n    (participantId) => {\n      const participantIsMember =\n        existingIndividualParticipantIds.includes(participantId);\n      return !participantIsMember;\n    }\n  );\n\n  if (participantIdsToAdd.length) {\n    if (removeFromOtherTeams) {\n      removeParticipantIdsFromAllTeams({\n        individualParticipantIds: participantIdsToAdd,\n        tournamentRecord,\n      });\n    }\n    groupingParticipant.individualParticipantIds =\n      groupingParticipant.individualParticipantIds.concat(\n        ...participantIdsToAdd\n      );\n  }\n\n  const { topics } = getTopics();\n  if (topics.includes(MODIFY_PARTICIPANTS)) {\n    const updatedParticipant = tournamentParticipants.find(\n      ({ participantId }) => participantId === groupingParticipantId\n    );\n\n    addNotice({\n      topic: MODIFY_PARTICIPANTS,\n      payload: { participants: [updatedParticipant] },\n    });\n  }\n\n  updateTeamEventEntries({\n    individualParticipantIds,\n    groupingParticipantId,\n    tournamentRecord,\n  });\n\n  return {\n    groupingParticipant: makeDeepCopy(groupingParticipant, false, true),\n    added: participantIdsToAdd.length,\n    ...SUCCESS,\n  };\n}\n","import { getFlightProfile } from '../../query/event/getFlightProfile';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { TEAM } from '../../constants/eventConstants';\n\n/**\n * function called internally to cleanup event entries when individuals have been added to team events\n */\nexport function updateTeamEventEntries({\n  individualParticipantIds,\n  groupingParticipantId,\n  tournamentRecord,\n}) {\n  const relevantEvents = (tournamentRecord.events || []).filter(\n    (event) =>\n      event?.eventType === TEAM &&\n      event?.entries?.some(\n        (entry) => entry.participantId === groupingParticipantId\n      )\n  );\n\n  const filterEntry = (entry) =>\n    !individualParticipantIds.includes(entry.participantId);\n\n  for (const event of relevantEvents) {\n    event.entries = (event.entries || []).filter(filterEntry);\n\n    const { flightProfile } = getFlightProfile({ event });\n    flightProfile?.flights?.forEach((flight) => {\n      flight.drawEntries = (flight.drawEntries || []).filter(filterEntry);\n    });\n\n    event?.drawDefinitions?.forEach((drawDefinition) => {\n      drawDefinition.entries = (drawDefinition.entries || []).filter(\n        filterEntry\n      );\n    });\n  }\n\n  return { ...SUCCESS };\n}\n","import { findTournamentParticipant } from '../../acquire/findTournamentParticipant';\nimport { addIndividualParticipantIds } from './addIndividualParticipantIds';\nimport { getParticipants } from '../../query/participants/getParticipants';\nimport { getParticipantId } from '../../global/functions/extractors';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { participantRoles } from '../../constants/participantRoles';\nimport { genderConstants } from '../../constants/genderConstants';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { addNotice } from '../../global/state/globalState';\nimport { countries } from '../../fixtures/countryData';\nimport { addParticipant } from './addParticipant';\n\nimport { MODIFY_PARTICIPANTS } from '../../constants/topicConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { TEAM } from '../../constants/matchUpTypes';\nimport {\n  CANNOT_MODIFY_PARTICIPANT_TYPE,\n  MISSING_PARTICIPANT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\nimport {\n  GROUP,\n  INDIVIDUAL,\n  PAIR,\n  participantTypes,\n} from '../../constants/participantConstants';\n\nexport function modifyParticipant(params) {\n  const {\n    updateParticipantName = true,\n    groupingParticipantId,\n    removeFromOtherTeams,\n    tournamentRecord,\n    pairOverride,\n    participant,\n  } = params;\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!participant) return { error: MISSING_PARTICIPANT };\n\n  if (!participant.participantId)\n    return addParticipant({ tournamentRecord, participant });\n\n  const { participant: existingParticipant } = findTournamentParticipant({\n    participantId: participant.participantId,\n    tournamentRecord,\n  });\n\n  if (!existingParticipant)\n    return addParticipant({ tournamentRecord, participant });\n\n  const {\n    participantRoleResponsibilties,\n    individualParticipantIds,\n    participantOtherName,\n    participantName,\n    participantRole,\n    participantType,\n    onlineResources, // TODO: validate onlineResources\n    contacts, // TODO: validate contacts\n    person,\n  } = participant;\n\n  if (\n    participantType &&\n    existingParticipant.participantType !== participantType\n  )\n    return { error: CANNOT_MODIFY_PARTICIPANT_TYPE };\n\n  const newValues: any = {};\n\n  // validate participant attributes\n  if (contacts) newValues.contacts = contacts;\n  if (onlineResources) newValues.onlineResources = onlineResources;\n\n  if (participantName && typeof participantName === 'string')\n    newValues.participantName = participantName;\n  if (participantOtherName && typeof participantOtherName === 'string')\n    newValues.participantOtherName = participantOtherName;\n\n  if (Array.isArray(individualParticipantIds)) {\n    const { participants: individualParticipants } = getParticipants({\n      participantFilters: { participantTypes: [INDIVIDUAL] },\n      tournamentRecord,\n    });\n    const allIndividualParticipantIds =\n      individualParticipants?.map(getParticipantId);\n\n    if (allIndividualParticipantIds) {\n      // check that all new individualParticipantIds exist and are { participantType: INDIVIDUAL }\n      const updatedIndividualParticipantIds = individualParticipantIds.filter(\n        (participantId) =>\n          typeof participantId === 'string' &&\n          allIndividualParticipantIds.includes(participantId)\n      );\n\n      if (\n        [GROUP, TEAM].includes(\n          participantType || existingParticipant.participantType\n        ) ||\n        (participantType === PAIR &&\n          (updatedIndividualParticipantIds.length === 2 || pairOverride))\n      ) {\n        newValues.individualParticipantIds = updatedIndividualParticipantIds;\n      }\n\n      // check whether to update PAIR participantName\n      if (\n        existingParticipant.participantType === participantTypes.PAIR &&\n        updateParticipantName\n      ) {\n        newValues.participantName = generatePairParticipantName({\n          individualParticipants,\n          newValues,\n        });\n      }\n    }\n  }\n  if (Object.keys(participantRoles).includes(participantRole))\n    newValues.participantRole = participantRole;\n  if (Object.keys(participantTypes).includes(participantType))\n    newValues.participantType = participantType;\n\n  if (Array.isArray(participantRoleResponsibilties))\n    newValues.participantRoleResponsibilties = participantRoleResponsibilties;\n\n  if (\n    existingParticipant.participantType === participantTypes.INDIVIDUAL &&\n    person\n  ) {\n    updatePerson({\n      updateParticipantName,\n      existingParticipant,\n      newValues,\n      person,\n    });\n  }\n\n  Object.assign(existingParticipant, definedAttributes(newValues));\n\n  if (groupingParticipantId) {\n    addIndividualParticipantIds({\n      individualParticipantIds: [existingParticipant.participantId],\n      groupingParticipantId,\n      removeFromOtherTeams,\n      tournamentRecord,\n    });\n  }\n\n  addNotice({\n    topic: MODIFY_PARTICIPANTS,\n    payload: {\n      tournamentId: tournamentRecord.tournamentId,\n      participants: [existingParticipant],\n    },\n  });\n\n  return {\n    participant: makeDeepCopy(existingParticipant),\n    ...SUCCESS,\n  };\n}\n\nfunction generatePairParticipantName({ individualParticipants, newValues }) {\n  const individualParticipantIds = newValues.individualParticipantIds;\n  let participantName = individualParticipants\n    .filter(({ participantId }) =>\n      individualParticipantIds.includes(participantId)\n    )\n    .map(({ person }) => person?.standardFamilyName)\n    .filter(Boolean)\n    .sort()\n    .join('/');\n\n  if (individualParticipantIds.length === 1) participantName += '/Unknown';\n  return participantName;\n}\n\nfunction updatePerson({\n  updateParticipantName,\n  existingParticipant,\n  newValues,\n  person,\n}) {\n  const newPersonValues: any = {};\n  const {\n    standardFamilyName,\n    standardGivenName,\n    nationalityCode,\n    personId,\n    sex,\n  } = person;\n  if (sex && Object.keys(genderConstants).includes(sex))\n    newPersonValues.sex = sex;\n\n  let personNameModified;\n  if (personId && typeof personId === 'string') {\n    newPersonValues.personId = personId;\n  }\n\n  if (\n    nationalityCode &&\n    typeof nationalityCode === 'string' &&\n    (validNationalityCode(nationalityCode) || nationalityCode === '') // empty string to remove value\n  ) {\n    newPersonValues.nationalityCode = nationalityCode;\n  }\n\n  if (\n    standardFamilyName &&\n    typeof standardFamilyName === 'string' &&\n    standardFamilyName.length > 1\n  ) {\n    newPersonValues.standardFamilyName = standardFamilyName;\n    personNameModified = true;\n  }\n\n  if (\n    standardGivenName &&\n    typeof standardGivenName === 'string' &&\n    standardGivenName.length > 1\n  ) {\n    newPersonValues.standardGivenName = standardGivenName;\n    personNameModified = true;\n  }\n\n  if (personNameModified && updateParticipantName) {\n    const participantName = `${newPersonValues.standardGivenName} ${newPersonValues.standardFamilyName}`;\n    newValues.participantName = participantName;\n  }\n\n  Object.assign(existingParticipant.person, newPersonValues);\n}\n\nexport function validNationalityCode(code) {\n  return countries\n    .flatMap(({ iso, ioc }) => [iso, ioc])\n    .filter(Boolean)\n    .includes(code);\n}\n","import { removeCollectionAssignments } from '../../events/removeCollectionAssignments';\nimport { getPairedParticipant } from '../../../query/participant/getPairedParticipant';\nimport { ResultType, decorateResult } from '../../../global/functions/decorateResult';\nimport { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { getParticipants } from '../../../query/participants/getParticipants';\nimport { deleteParticipants } from '../../participants/deleteParticipants';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { modifyParticipant } from '../../participants/modifyParticipant';\nimport { updateTeamLineUp } from '../../drawDefinitions/updateTeamLineUp';\nimport { getTieMatchUpContext } from '../../events/getTieMatchUpContext';\nimport { addParticipant } from '../../participants/addParticipant';\nimport { getTeamLineUp } from '../../drawDefinitions/getTeamLineUp';\nimport { ensureSideLineUps } from './ensureSideLineUps';\nimport { overlap } from '../../../utilities/arrays';\n\nimport POLICY_MATCHUP_ACTIONS_DEFAULT from '../../../fixtures/policies/POLICY_MATCHUP_ACTIONS_DEFAULT';\nimport { DrawDefinition, Event, Tournament } from '../../../types/tournamentTypes';\nimport { POLICY_TYPE_MATCHUP_ACTIONS } from '../../../constants/policyConstants';\nimport { INDIVIDUAL, PAIR } from '../../../constants/participantConstants';\nimport { LineUp, PolicyDefinitions } from '../../../types/factoryTypes';\nimport { DOUBLES, SINGLES } from '../../../constants/matchUpTypes';\nimport { FEMALE, MALE } from '../../../constants/genderConstants';\nimport { COMPETITOR } from '../../../constants/participantRoles';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_PARTICIPANT,\n  INVALID_PARTICIPANT_TYPE,\n  INVALID_SIDE_NUMBER,\n  MISSING_COLLECTION_DEFINITION,\n  MISSING_PARTICIPANT_ID,\n  MISSING_TIE_FORMAT,\n  PARTICIPANT_NOT_FOUND,\n  TEAM_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\n\ntype AssignMatchUpSideParticipantIdArgs = {\n  policyDefinitions?: PolicyDefinitions;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  teamParticipantId?: string;\n  enforceGender?: boolean;\n  participantId: string;\n  tieMatchUpId: string;\n  sideNumber?: number;\n  event: Event;\n};\n\nexport function assignTieMatchUpParticipantId(\n  params: AssignMatchUpSideParticipantIdArgs,\n): ResultType & { deletedParticipantId?: string; modifiedLineUp?: LineUp } {\n  const matchUpContext = getTieMatchUpContext(params);\n  if (matchUpContext.error) return matchUpContext;\n  const stack = 'assignTieMatchUpParticipantId';\n\n  let teamParticipantId = params.teamParticipantId;\n  const { tournamentRecord, drawDefinition, participantId, event } = params;\n\n  if (!participantId) {\n    return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack });\n  }\n\n  if (params.sideNumber && ![1, 2].includes(params.sideNumber)) {\n    return decorateResult({ result: { error: INVALID_SIDE_NUMBER }, stack });\n  }\n\n  const {\n    inContextDualMatchUp,\n    inContextTieMatchUp,\n    relevantAssignments,\n    collectionPosition,\n    teamParticipants,\n    collectionId,\n    matchUpType,\n    dualMatchUp,\n    tieFormat,\n  } = matchUpContext;\n\n  const allTieIndividualParticipantIds = inContextTieMatchUp?.sides?.flatMap(\n    (side: any) => side.participant?.individualParticipantIds || side.participant?.participantId || [],\n  );\n\n  if (allTieIndividualParticipantIds?.includes(participantId)) {\n    return decorateResult({ result: { ...SUCCESS }, stack });\n  }\n\n  teamParticipantId =\n    teamParticipantId ??\n    (params.sideNumber\n      ? inContextDualMatchUp?.sides?.find((side) => side.sideNumber === params.sideNumber)?.participantId\n      : undefined);\n\n  const participantToAssign = getParticipants({\n    participantFilters: { participantIds: [participantId] },\n    tournamentRecord,\n  })?.participants?.[0];\n\n  if (!participantToAssign) {\n    return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack });\n  }\n\n  const { appliedPolicies } = getAppliedPolicies({\n    tournamentRecord,\n    drawDefinition,\n    event,\n  });\n\n  const matchUpActionsPolicy =\n    params.policyDefinitions?.[POLICY_TYPE_MATCHUP_ACTIONS] ??\n    appliedPolicies?.[POLICY_TYPE_MATCHUP_ACTIONS] ??\n    POLICY_MATCHUP_ACTIONS_DEFAULT[POLICY_TYPE_MATCHUP_ACTIONS];\n\n  const genderEnforced = (params.enforceGender ?? matchUpActionsPolicy?.participants?.enforceGender) !== false;\n\n  if (\n    genderEnforced &&\n    [MALE, FEMALE].includes(inContextTieMatchUp?.gender) &&\n    inContextTieMatchUp?.gender !== participantToAssign.person?.sex\n  ) {\n    return { error: INVALID_PARTICIPANT, info: 'Gender mismatch' };\n  }\n\n  const { individualParticipantIds, participantType } = participantToAssign;\n\n  // check that the participantToAssign is the correct participantType for tieMatchUp.matchUpType\n  if (matchUpType === SINGLES && participantType !== INDIVIDUAL) {\n    return { error: INVALID_PARTICIPANT_TYPE };\n  }\n\n  const relevantParticipantIds = participantType === INDIVIDUAL ? [participantId] : individualParticipantIds;\n\n  const participantTeam =\n    (teamParticipantId && teamParticipants?.find(({ participantId }) => participantId === teamParticipantId)) ||\n    teamParticipants?.find(({ individualParticipantIds }) => overlap(relevantParticipantIds, individualParticipantIds));\n\n  if (!participantTeam) return { error: TEAM_NOT_FOUND };\n\n  if (!teamParticipantId) teamParticipantId = participantTeam.participantId;\n  if (!teamParticipantId) return { error: PARTICIPANT_NOT_FOUND };\n\n  const teamAssignment = relevantAssignments?.find(\n    (assignment) => assignment.participantId === participantTeam?.participantId,\n  );\n  const teamDrawPosition = teamAssignment?.drawPosition;\n  const dualTeamSideNumber = dualMatchUp?.sides?.find((side: any) => side.participantId === teamParticipantId)\n    ?.sideNumber;\n  const teamSideNumber = inContextTieMatchUp?.sides?.find(\n    (side: any) => teamDrawPosition && side.drawPosition === teamDrawPosition,\n  )?.sideNumber;\n  const sideNumber = dualTeamSideNumber ?? teamSideNumber ?? params.sideNumber;\n\n  if (!tieFormat) {\n    return { error: MISSING_TIE_FORMAT };\n  }\n\n  const collectionDefinition = tieFormat.collectionDefinitions?.find(\n    (collectionDefinition) => collectionDefinition.collectionId === collectionId,\n  );\n\n  if (!collectionDefinition) return { error: MISSING_COLLECTION_DEFINITION };\n\n  ensureSideLineUps({\n    tournamentId: tournamentRecord.tournamentId,\n    eventId: event.eventId,\n    inContextDualMatchUp,\n    drawDefinition,\n    dualMatchUp,\n  });\n\n  const dualMatchUpSide = dualMatchUp?.sides?.find((side) => side.sideNumber === sideNumber);\n\n  const tieMatchUpSide = inContextTieMatchUp?.sides?.find((side) => side.sideNumber === sideNumber);\n\n  const lineUp =\n    dualMatchUpSide?.lineUp ??\n    getTeamLineUp({\n      participantId: teamParticipantId,\n      drawDefinition,\n    })?.lineUp;\n\n  const targetAssignments = lineUp?.filter(\n    (participantAssignment) =>\n      participantAssignment.collectionAssignments?.find(\n        (assignment) =>\n          assignment.collectionPosition === collectionPosition &&\n          assignment.collectionId === collectionId &&\n          !assignment.previousParticipantId,\n      ),\n  );\n  const assignedParticipantIds = targetAssignments?.map((assignment) => assignment?.participantId);\n\n  // participantIds is an array of ids for individual team participants whose assignments should be modified\n  const participantIds =\n    (assignedParticipantIds?.length > 1 && assignedParticipantIds) ||\n    (participantType === PAIR ? participantToAssign.individualParticipantIds : [participantId]);\n\n  // first filter out any collectionAssignment with equivalent collectionId/collectionPosition/participantId\n  const removeResult = removeCollectionAssignments({\n    collectionPosition,\n    teamParticipantId,\n    dualMatchUpSide,\n    drawDefinition,\n    participantIds,\n    collectionId,\n  });\n  if (removeResult.error) return decorateResult({ result: removeResult, stack });\n\n  const { modifiedLineUp } = removeResult;\n\n  let deletedParticipantId;\n\n  if (matchUpType === DOUBLES) {\n    if (participantType !== PAIR) {\n      let result: any = updateLineUp({\n        collectionPosition,\n        teamParticipantId,\n        drawDefinition,\n        modifiedLineUp,\n        participantId,\n        collectionId,\n        tieFormat,\n      });\n      if (result?.error) return decorateResult({ result, stack });\n\n      result = addParticipantId2Pair({\n        side: tieMatchUpSide,\n      });\n      if (result.error) return result;\n      deletedParticipantId = result.deletedParticipantId;\n\n      if (dualMatchUpSide) dualMatchUpSide.lineUp = modifiedLineUp;\n      if (dualMatchUp) {\n        modifyMatchUpNotice({\n          tournamentId: tournamentRecord?.tournamentId,\n          matchUp: dualMatchUp,\n          context: stack,\n          drawDefinition,\n        });\n      }\n    } else if (participantType === PAIR) {\n      for (const participantId of participantIds) {\n        updateLineUp({\n          collectionPosition,\n          teamParticipantId,\n          drawDefinition,\n          modifiedLineUp,\n          participantId,\n          collectionId,\n          tieFormat,\n        });\n      }\n    }\n  } else {\n    const result = updateLineUp({\n      collectionPosition,\n      teamParticipantId,\n      drawDefinition,\n      modifiedLineUp,\n      participantId,\n      collectionId,\n      tieFormat,\n    });\n    if (result?.error) return result;\n  }\n\n  if (dualMatchUpSide) dualMatchUpSide.lineUp = modifiedLineUp;\n  if (dualMatchUp)\n    modifyMatchUpNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      matchUp: dualMatchUp,\n      context: stack,\n      drawDefinition,\n    });\n\n  if (deletedParticipantId) {\n    const { error } = deleteParticipants({\n      participantIds: [deletedParticipantId],\n      tournamentRecord,\n    });\n    if (error) console.log('cleanup');\n  }\n\n  return { ...SUCCESS, modifiedLineUp };\n\n  function addParticipantId2Pair({ side }) {\n    let deletedParticipantId;\n\n    if (!side.participant) {\n      const newPairParticipant = {\n        individualParticipantIds: [participantId],\n        participantRole: COMPETITOR,\n        participantType: PAIR,\n      };\n      const result = addParticipant({\n        participant: newPairParticipant,\n        pairOverride: true,\n        tournamentRecord,\n      });\n      if (result.error) return result;\n    } else {\n      const individualParticipantIds = side.participant.individualParticipantIds || [];\n\n      const sideParticipantsCount = individualParticipantIds.filter(Boolean).length;\n\n      if (sideParticipantsCount === 1) {\n        const { participant } = getPairedParticipant({\n          participantIds: individualParticipantIds,\n          tournamentRecord,\n        });\n\n        individualParticipantIds.push(participantId);\n\n        const { participant: existingParticipant } = getPairedParticipant({\n          participantIds: individualParticipantIds,\n          tournamentRecord,\n        });\n\n        if (!existingParticipant && participant) {\n          participant.individualParticipantIds = individualParticipantIds;\n          const result = modifyParticipant({\n            pairOverride: true,\n            tournamentRecord,\n            participant,\n          });\n          if (result.error) return result;\n        } else {\n          // check if there is a pairParticipant that includes both individualParticipantIds\n          // if there is, use that and delete the PAIR participant with only one [individualParticipantId]\n          deletedParticipantId = participant?.participantId;\n        }\n      }\n    }\n\n    return { ...SUCCESS, deletedParticipantId };\n  }\n}\n\nfunction updateLineUp({\n  collectionPosition,\n  teamParticipantId,\n  drawDefinition,\n  modifiedLineUp,\n  participantId,\n  collectionId,\n  tieFormat,\n}) {\n  const templateTeamLineUp = getTeamLineUp({\n    participantId: teamParticipantId,\n    drawDefinition,\n  })?.lineUp;\n\n  const participantCompetitiorProfile = (modifiedLineUp || templateTeamLineUp)?.find(\n    (teamCompetitor) => teamCompetitor?.participantId === participantId,\n  );\n\n  const newAssignment = { collectionId, collectionPosition };\n\n  if (participantCompetitiorProfile) {\n    participantCompetitiorProfile.collectionAssignments.push(newAssignment);\n  } else {\n    const teamCompetitor = {\n      collectionAssignments: [newAssignment],\n      participantId,\n    };\n\n    modifiedLineUp.push(teamCompetitor);\n  }\n\n  return updateTeamLineUp({\n    participantId: teamParticipantId,\n    lineUp: modifiedLineUp,\n    drawDefinition,\n    tieFormat,\n  });\n}\n","import { unique } from '../utilities/arrays';\n\nimport { CollectionValueProfile } from '../types/tournamentTypes';\nimport { SUCCESS } from '../constants/resultConstants';\n\ntype ValidateCollectionDefinitionArgs = {\n  collectionValueProfiles: CollectionValueProfile[];\n  matchUpCount: number;\n};\n\nexport function validateCollectionValueProfiles({\n  collectionValueProfiles,\n  matchUpCount,\n}: ValidateCollectionDefinitionArgs) {\n  const errors: string[] = [];\n  if (!Array.isArray(collectionValueProfiles)) {\n    errors.push(\n      `collectionValueProfiles is not an array: ${collectionValueProfiles}`\n    );\n    return { errors };\n  }\n  if (\n    collectionValueProfiles.length &&\n    collectionValueProfiles.length !== matchUpCount\n  ) {\n    errors.push(`collectionValueProfiles do not align with matchUpsCount`);\n    return { errors };\n  }\n  for (const valueProfile of collectionValueProfiles) {\n    if (typeof valueProfile !== 'object') {\n      errors.push(`valueProfile is not type object: ${valueProfile}`);\n      return { errors };\n    }\n    const { matchUpValue, collectionPosition } = valueProfile;\n    if (\n      typeof matchUpValue !== 'number' ||\n      typeof collectionPosition !== 'number' ||\n      collectionPosition > matchUpCount ||\n      collectionPosition < 1\n    ) {\n      errors.push(\n        `Invalid value profile: value and collectionPosition must be numeric. collectionPosition cannot be greater than matchUpCount`\n      );\n      return { errors };\n    }\n  }\n  const collectionPositions = collectionValueProfiles.map(\n    (valueProfile) => valueProfile.collectionPosition\n  );\n  if (collectionPositions.length !== unique(collectionPositions).length) {\n    errors.push('collectionPositions are not unique');\n    return { errors };\n  }\n\n  return { ...SUCCESS };\n}\n","import { makeDeepCopy } from '../../../utilities/makeDeepCopy';\n\nimport { TieFormat } from '../../../types/tournamentTypes';\n\nexport function copyTieFormat(tieFormat?: TieFormat) {\n  if (!tieFormat) return undefined;\n  return makeDeepCopy(tieFormat, false, true);\n}\n","import { isConvertableInteger } from '../../../utilities/math';\nimport { ensureInt } from '../../../utilities/ensureInt';\n\ntype GetGroupValueGroupsArgs = {\n  collectionGroups: { groupValue?: number; groupNumber?: number }[];\n};\nexport function getGroupValueGroups({\n  collectionGroups = [],\n}: GetGroupValueGroupsArgs) {\n  // set up to handle groupValue\n  const groupValueGroups = Object.assign(\n    {},\n    ...collectionGroups\n      .filter(\n        (group: any) =>\n          isConvertableInteger(group?.groupValue) && group?.groupNumber\n      )\n      .map((group: any) => ({\n        [group.groupNumber]: {\n          ...group,\n          allGroupMatchUpsCompleted: true,\n          matchUpsCount: 0,\n          sideWins: [0, 0],\n          values: [0, 0],\n        },\n      }))\n  );\n\n  // must be coerced to numbers\n  const groupValueNumbers = Object.keys(groupValueGroups).map((num) =>\n    ensureInt(num)\n  );\n\n  return { groupValueGroups, groupValueNumbers };\n}\n","import { getGroupValueGroups } from '../../assemblies/generators/drawDefinitions/getGroupValueGroups';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { CollectionDefinition } from '../../types/tournamentTypes';\nimport { isConvertableInteger } from '../../utilities/math';\n\ntype CalculateWinCriteriaArgs = {\n  collectionGroups?: { groupValue?: number; groupNumber?: number }[];\n  collectionDefinitions?: CollectionDefinition[];\n};\nexport function calculateWinCriteria({\n  collectionDefinitions = [],\n  collectionGroups = [],\n}: CalculateWinCriteriaArgs): ResultType & {\n  aggregateValue?: boolean;\n  valueGoal?: number;\n} {\n  let valueTotal = 0;\n\n  const { groupValueNumbers } = getGroupValueGroups({ collectionGroups });\n\n  let aggregateValueImperative;\n\n  for (const collectionDefinition of collectionDefinitions || []) {\n    const {\n      collectionValueProfiles,\n      collectionGroupNumber,\n      collectionValue,\n      matchUpCount,\n      matchUpValue,\n      scoreValue,\n      setValue,\n    } = collectionDefinition;\n\n    const belongsToValueGroup =\n      collectionGroupNumber &&\n      groupValueNumbers.includes(collectionGroupNumber);\n\n    if (isConvertableInteger(setValue || scoreValue)) {\n      // because setValues and scoreValues are unpredictable,\n      // any collectionDefintion that has either of these two values without a collectionValue forces the tieFormat to aggregateValue\n      aggregateValueImperative = true;\n    } else if (belongsToValueGroup) {\n      continue;\n    } else if (\n      typeof collectionValue === 'number' &&\n      isConvertableInteger(collectionValue)\n    ) {\n      valueTotal += collectionValue;\n    } else if (collectionValueProfiles?.length) {\n      for (const collectionValueProfile of collectionValueProfiles) {\n        valueTotal += collectionValueProfile.matchUpValue;\n      }\n    } else if (\n      typeof matchUpValue === 'number' &&\n      isConvertableInteger(matchUpValue)\n    ) {\n      valueTotal += (matchUpCount ?? 0) * matchUpValue;\n    }\n  }\n\n  for (const collectionGroup of collectionGroups) {\n    valueTotal += collectionGroup.groupValue ?? 0;\n  }\n\n  if (aggregateValueImperative || !valueTotal)\n    return { aggregateValue: true, ...SUCCESS };\n\n  const valueGoal = Math.floor(valueTotal / 2) + 1;\n\n  return { valueGoal, ...SUCCESS };\n}\n","import { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { getObjectTieFormat } from './getObjectTieFormat';\nimport { getItemTieFormat } from './getItemTieFormat';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../../global/functions/decorateResult';\n\nimport { TEAM_MATCHUP } from '../../../constants/matchUpTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  ErrorType,\n  INVALID_MATCHUP,\n  MISSING_DRAW_DEFINITION,\n  MISSING_TIE_FORMAT,\n} from '../../../constants/errorConditionConstants';\n\nimport {\n  DrawDefinition,\n  Event,\n  MatchUp,\n  Structure,\n  TieFormat,\n} from '../../../types/tournamentTypes';\n\ntype GetTieFormatArgs = {\n  drawDefinition?: DrawDefinition;\n  structure?: Structure;\n  structureId?: string;\n  matchUpId?: string;\n  matchUp?: MatchUp;\n  eventId?: string;\n  event?: Event;\n};\n\nexport function getTieFormat({\n  drawDefinition,\n  structureId,\n  matchUpId,\n  structure,\n  matchUp,\n  eventId, // optional - if an eventId is present only return tieFormat for event\n  event,\n}: GetTieFormatArgs): ResultType & {\n  structure?: Structure;\n  tieFormat?: TieFormat;\n  success?: boolean;\n  matchUp?: MatchUp;\n} {\n  const stack = 'getTieFormat';\n  let tieFormat;\n\n  structureId = structure?.structureId ?? structureId;\n  matchUpId = matchUp?.matchUpId ?? matchUpId;\n\n  if ((matchUpId || structureId) && !drawDefinition)\n    return { error: MISSING_DRAW_DEFINITION };\n\n  if (eventId && event) {\n    tieFormat = getObjectTieFormat(event);\n  } else if (matchUpId) {\n    // if matchUpId is present, structure and drawDefinition are always required\n    if (drawDefinition && (!matchUp || !structure)) {\n      const result: {\n        matchUp?: MatchUp;\n        error?: ErrorType;\n        structure?: Structure;\n      } = findDrawMatchUp({\n        drawDefinition,\n        matchUpId,\n      });\n      if (result.error) return result;\n      if (result.matchUp?.matchUpType !== TEAM_MATCHUP) {\n        return decorateResult({ result: { error: INVALID_MATCHUP }, stack });\n      }\n\n      if (!structure) structure = result.structure;\n      if (!matchUp) matchUp = result.matchUp;\n    }\n\n    tieFormat =\n      getItemTieFormat({\n        item: matchUp,\n        drawDefinition,\n        structure,\n        event,\n      }) ||\n      getItemTieFormat({\n        item: structure,\n        drawDefinition,\n        structure,\n        event,\n      }) ||\n      getObjectTieFormat(drawDefinition) ||\n      getObjectTieFormat(event);\n  } else if (drawDefinition && structureId) {\n    if (!structure) {\n      const result = findStructure({ drawDefinition, structureId });\n      if (result.error) return result;\n      structure = result?.structure;\n    }\n    tieFormat =\n      getItemTieFormat({\n        item: structure,\n        drawDefinition,\n        structure,\n        event,\n      }) ||\n      getObjectTieFormat(drawDefinition) ||\n      getObjectTieFormat(event);\n  } else {\n    tieFormat = getObjectTieFormat(drawDefinition) || getObjectTieFormat(event);\n  }\n\n  if (!tieFormat)\n    return decorateResult({ result: { error: MISSING_TIE_FORMAT }, stack });\n\n  return {\n    ...SUCCESS,\n    structure,\n    tieFormat,\n    matchUp,\n  };\n}\n","import { SET, NOAD } from '../../../constants/matchUpFormatConstants';\nimport { isObject } from '../../../utilities/objects';\n\nexport function stringify(matchUpFormatObject, preserveRedundant?: boolean) {\n  if (!isObject(matchUpFormatObject)) undefined;\n  if (\n    (matchUpFormatObject?.bestOf || matchUpFormatObject?.exactly) &&\n    matchUpFormatObject?.setFormat\n  ) {\n    return getSetFormat(matchUpFormatObject, preserveRedundant);\n  }\n  return undefined;\n}\n\nfunction getNumber(formatstring) {\n  return !isNaN(Number(formatstring)) && Number(formatstring);\n}\n\nfunction timedSetFormat(matchUpFormatObject) {\n  let value = `T${matchUpFormatObject.minutes}`;\n  if (matchUpFormatObject.based) value += matchUpFormatObject.based;\n  if (matchUpFormatObject.modifier) value += `@${matchUpFormatObject.modifier}`;\n  return value;\n}\n\nfunction getSetFormat(matchUpFormatObject, preserveRedundant?: boolean) {\n  const bestOfValue = getNumber(matchUpFormatObject.bestOf) || undefined;\n  const exactly = getNumber(matchUpFormatObject.exactly) || undefined;\n  const setLimit = bestOfValue || exactly;\n\n  if (\n    matchUpFormatObject.setFormat?.timed &&\n    matchUpFormatObject.simplified &&\n    setLimit === 1\n  ) {\n    return timedSetFormat(matchUpFormatObject.setFormat);\n  }\n  const setLimitCode = (setLimit && `${SET}${setLimit}`) || '';\n  const setCountValue = stringifySet(\n    matchUpFormatObject.setFormat,\n    preserveRedundant\n  );\n  const setCode = (setCountValue && `S:${setCountValue}`) || '';\n  const finalSetCountValue = stringifySet(\n    matchUpFormatObject.finalSetFormat,\n    preserveRedundant\n  );\n\n  const finalSetCode =\n    (setLimit &&\n      setLimit > 1 &&\n      finalSetCountValue &&\n      setCountValue !== finalSetCountValue && // don't include final set code if equivalent to other sets\n      `F:${finalSetCountValue}`) ||\n    '';\n  const valid = setLimitCode && setCountValue;\n\n  if (valid) {\n    return [setLimitCode, setCode, finalSetCode].filter((f) => f).join('-');\n  }\n  return undefined;\n}\n\nfunction stringifySet(setObject, preserveRedundant) {\n  if (typeof setObject === 'object' && Object.keys(setObject).length) {\n    if (setObject.timed) return timedSetFormat(setObject);\n    if (setObject.tiebreakSet) return tiebreakFormat(setObject.tiebreakSet);\n    const setToValue = getNumber(setObject.setTo);\n    if (setToValue) {\n      const NoAD = (setObject.NoAD && NOAD) || '';\n      const setTiebreakValue = tiebreakFormat(setObject.tiebreakFormat);\n      const setTiebreakCode =\n        (setTiebreakValue && `/${setTiebreakValue}`) || '';\n      const tiebreakAtValue = getNumber(setObject.tiebreakAt);\n      const tiebreakAtCode =\n        (tiebreakAtValue &&\n          (tiebreakAtValue !== setToValue || preserveRedundant) &&\n          `@${tiebreakAtValue}`) ||\n        '';\n      if (setTiebreakValue !== false) {\n        return `${setToValue}${NoAD}${setTiebreakCode}${tiebreakAtCode}`;\n      }\n    }\n  }\n  return undefined;\n}\n\nfunction tiebreakFormat(tieobject) {\n  if (tieobject) {\n    if (typeof tieobject === 'object' && !tieobject.tiebreakTo) {\n      return '';\n    } else if (\n      typeof tieobject === 'object' &&\n      getNumber(tieobject.tiebreakTo)\n    ) {\n      let value = `TB${tieobject.tiebreakTo}${tieobject.NoAD ? NOAD : ''}`;\n      if (tieobject.modifier) value += `@${tieobject.modifier}`;\n      return value;\n    } else {\n      return false;\n    }\n  }\n  return undefined;\n}\n","import { stringify } from '../assemblies/generators/matchUpFormatCode/stringify';\nimport { parse } from '../assemblies/generators/matchUpFormatCode/parse';\n\nexport function isValidMatchUpFormat({\n  matchUpFormat,\n}: {\n  matchUpFormat: string;\n}): boolean {\n  if (typeof matchUpFormat !== 'string') return false;\n  const parsedFormat = parse(matchUpFormat);\n\n  const setParts = matchUpFormat.match(\n    /-S:([1-9])+\\/TB([0-9]{1,2})@?([1-9]?)*/\n  );\n  const setsTo = setParts?.[1];\n  const tiebreakTo = setParts?.[2];\n  const tiebreakAt = setParts?.[3];\n\n  const finalSetParts = matchUpFormat.match(\n    /-F:([1-9])+\\/TB([0-9]{1,2})@?([1-9]?)*/\n  );\n  const finalSetTo = finalSetParts?.[1];\n  const finalSetTiebreakTo = finalSetParts?.[2];\n  const finalTiebreakAt = finalSetParts?.[3];\n\n  const preserveRedundant = !!(\n    (setParts && tiebreakTo && setsTo === tiebreakAt) ||\n    (finalSetParts && finalSetTiebreakTo && finalSetTo === finalTiebreakAt)\n  );\n\n  const stringified = stringify(parsedFormat, preserveRedundant);\n\n  return stringified === matchUpFormat;\n}\n","import { ResultType, decorateResult } from '../global/functions/decorateResult';\n\nimport { INVALID_GENDER } from '../constants/errorConditionConstants';\nimport { ANY, FEMALE, MALE, MIXED } from '../constants/genderConstants';\nimport { GenderUnion } from '../types/tournamentTypes';\nimport { DOUBLES } from '../constants/matchUpTypes';\n\ntype GenderValidityCheckArgs = {\n  referenceGender?: GenderUnion;\n  matchUpType?: string;\n  gender?: GenderUnion;\n};\n\nexport const mixedGenderError =\n  'MIXED events can not contain mixed singles or { gender: ANY } collections';\nexport const anyMixedError =\n  'events with { gender: ANY } can not contain MIXED singles collections';\n\nexport function tieFormatGenderValidityCheck(\n  params: GenderValidityCheckArgs\n): ResultType {\n  const stack = 'tieFormatGenderValidityCheck';\n  const { referenceGender, matchUpType, gender } = params;\n  if (\n    referenceGender &&\n    gender &&\n    [MALE, FEMALE].includes(referenceGender) &&\n    referenceGender !== gender\n  )\n    return decorateResult({\n      result: { valid: false, error: INVALID_GENDER },\n      context: { gender },\n      stack,\n    });\n\n  if (\n    referenceGender === MIXED &&\n    (gender === ANY || (gender === MIXED && matchUpType !== DOUBLES))\n  ) {\n    return decorateResult({\n      result: { error: INVALID_GENDER, valid: false },\n      info: mixedGenderError,\n      stack,\n    });\n  }\n\n  if (referenceGender === ANY && gender === MIXED && matchUpType !== DOUBLES)\n    return decorateResult({\n      result: { error: INVALID_GENDER, valid: false },\n      info: anyMixedError,\n      stack,\n    });\n\n  return { valid: true };\n}\n","import { definedAttributes } from '../../utilities/definedAttributes';\nimport { isNumeric } from '../../utilities/math';\nimport {\n  dateStringDaysChange,\n  extractDate,\n  isValidDateString,\n  zeroPad,\n} from '../../utilities/dateTime';\n\nimport { Category } from '../../types/tournamentTypes';\nimport {\n  INVALID_CATEGORY,\n  INVALID_DATE,\n} from '../../constants/errorConditionConstants';\n\nconst typeMatch = (arr, type) =>\n  arr.filter(Boolean).every((i) => typeof i === type);\nconst allNumeric = (arr) => arr.filter(Boolean).every(isNumeric);\n\ntype ParseArgs = {\n  consideredDate?: string;\n  category?: Category;\n};\nexport function getCategoryAgeDetails(params: ParseArgs) {\n  const category = params.category;\n\n  if (typeof category !== 'object') return { error: INVALID_CATEGORY };\n\n  let { ageCategoryCode, ageMaxDate, ageMinDate, ageMax, ageMin } = category;\n\n  const categoryName = category.categoryName;\n  let combinedAge;\n\n  if (\n    !typeMatch(\n      [ageCategoryCode, ageMaxDate, ageMinDate, categoryName],\n      'string'\n    ) ||\n    !allNumeric(\n      [ageMax, ageMin] ||\n        ![ageMaxDate, ageMinDate].filter(Boolean).every(isValidDateString)\n    )\n  )\n    return { error: INVALID_CATEGORY };\n\n  const consideredDate =\n    params.consideredDate ?? extractDate(new Date().toLocaleDateString('sv'));\n  if (!isValidDateString(consideredDate)) return { error: INVALID_DATE };\n\n  // const [consideredYear, month, day] = consideredDate\n  const [consideredYear] = consideredDate\n    .split('-')\n    .slice(0, 3)\n    .map((n) => parseInt(n));\n  // const monthDay = `${zeroPad(month)}-${zeroPad(day)}`;\n\n  const previousDayDate = dateStringDaysChange(consideredDate, -1);\n  const [previousDayMonth, previousDay] = previousDayDate\n    .split('-')\n    .slice(1, 3)\n    .map((n) => parseInt(n));\n  const previousMonthDay = `${zeroPad(previousDayMonth)}-${zeroPad(\n    previousDay\n  )}`;\n\n  const nextDayDate = dateStringDaysChange(consideredDate, 1);\n  const [nextDayMonth, nextDay] = nextDayDate\n    .split('-')\n    .slice(1, 3)\n    .map((n) => parseInt(n));\n  const nextMonthDay = `${zeroPad(nextDayMonth)}-${zeroPad(nextDay)}`;\n\n  let calculatedAgeMaxDate =\n    ageMin && dateStringDaysChange(consideredDate, -1 * 365 * ageMin);\n  let calculatedAgeMinDate =\n    ageMax && dateStringDaysChange(consideredDate, -1 * 365 * ageMax);\n\n  // collect errors; e.g. provided ageMin does not equal calculated ageMin\n  const errors: string[] = [];\n\n  const addError = (errorString: string) =>\n    !errors.includes(errorString) && errors.push(errorString);\n\n  ageCategoryCode = ageCategoryCode ?? categoryName;\n\n  const prePost = /^([UO]?)(\\d{1,2})([UO]?)$/;\n  const extractCombined = /^C(\\d{1,2})-(\\d{1,2})$/;\n\n  const isBetween = ageCategoryCode?.includes('-');\n  const isCombined = isBetween && ageCategoryCode?.match(extractCombined);\n  const isCoded = ageCategoryCode?.match(prePost);\n\n  // construct min or max date with or without year\n  //const isYYMM = (datePart) => datePart.match(/^\\d{2}-\\d{2}$/);\n  const constructedDate = (y, df) => `${y}-${df}`;\n\n  const uPre = (ageInt) => {\n    const ageMinYear = consideredYear - ageInt;\n    const newMinDate = constructedDate(ageMinYear, nextMonthDay);\n\n    if (category.ageMinDate && category.ageMinDate !== newMinDate)\n      addError(`Invalid submitted ageMinDate: ${ageMinDate}`);\n\n    ageMinDate = newMinDate;\n\n    if (ageCategoryCode) {\n      if (category.ageMax && category.ageMax !== ageInt - 1) {\n        addError(`Invalid submitted ageMax: ${ageMax}`);\n        calculatedAgeMinDate = undefined;\n      }\n      ageMax = ageInt - 1;\n    }\n  };\n\n  const uPost = (ageInt) => {\n    const ageMinYear = consideredYear - ageInt - 1;\n    const newMinDate = constructedDate(ageMinYear, nextMonthDay);\n\n    if (category.ageMin && category.ageMin > ageInt) {\n      addError(`Invalid submitted ageMin: ${ageMin}`);\n    }\n\n    if (category.ageMax && category.ageMax > ageInt) {\n      addError(`Invalid submitted ageMax: ${ageMax}`);\n    }\n\n    if (category.ageMinDate && category.ageMinDate !== newMinDate)\n      addError(`Invalid submitted ageMinDate: ${ageMinDate}`);\n\n    ageMinDate = newMinDate;\n\n    if (ageCategoryCode) {\n      if (category.ageMax && category.ageMax !== ageInt) {\n        addError(`Invalid submitted ageMax: ${ageMax}`);\n        calculatedAgeMaxDate = undefined;\n      }\n      ageMax = ageInt;\n    }\n  };\n\n  const oPre = (ageInt) => {\n    const ageMaxYear = consideredYear - ageInt;\n    const newMaxDate = constructedDate(ageMaxYear, previousMonthDay);\n\n    if (category.ageMaxDate && category.ageMaxDate !== newMaxDate)\n      addError(`Invalid submitted ageMaxDate: ${ageMaxDate}`);\n\n    ageMaxDate = newMaxDate;\n\n    if (ageCategoryCode) {\n      if (category.ageMin && category.ageMin !== ageInt + 1) {\n        addError(`Invalid submitted ageMin: ${ageMin}`);\n        calculatedAgeMaxDate = undefined;\n      }\n      ageMin = ageInt + 1;\n    }\n  };\n\n  const oPost = (ageInt) => {\n    const ageMaxYear = consideredYear - ageInt - 1;\n    const newMaxDate = constructedDate(ageMaxYear, previousMonthDay);\n\n    if (category.ageMaxDate && category.ageMaxDate !== newMaxDate)\n      addError(`Invalid submitted ageMaxDate: ${ageMaxDate}`);\n\n    ageMaxDate = newMaxDate;\n\n    if (ageCategoryCode) {\n      if (category.ageMin && category.ageMin !== ageInt) {\n        addError(`Invalid submitted ageMin: ${ageMin}`);\n        calculatedAgeMaxDate = undefined;\n      }\n      ageMin = ageInt;\n    }\n  };\n\n  const processCode = (code) => {\n    const [pre, age, post] = (code.match(prePost) || []).slice(1);\n    const ageInt = parseInt(age);\n    if (pre === 'U') {\n      if (category.ageMaxDate && category.ageMaxDate !== ageMaxDate) {\n        addError(`Invalid submitted ageMaxDate: ${category.ageMaxDate}`);\n      }\n      uPre(ageInt);\n    } else if (pre === 'O') {\n      oPre(ageInt);\n    }\n\n    if (post === 'U') {\n      if (category.ageMaxDate && category.ageMaxDate !== ageMaxDate) {\n        addError(`Invalid submitted ageMaxDate: ${category.ageMaxDate}`);\n      }\n      uPost(ageInt);\n    } else if (post === 'O') {\n      oPost(ageInt);\n    }\n\n    ageMaxDate = ageMaxDate ?? calculatedAgeMaxDate;\n    ageMinDate = ageMinDate ?? calculatedAgeMinDate;\n  };\n\n  if (isCombined) {\n    // min and max birthdates are not relevant\n    // TODO: utility function to calculate combined age given two birthdates?\n    ageMaxDate = undefined;\n    ageMinDate = undefined;\n    ageMax = undefined;\n    ageMin = undefined;\n\n    if (category.ageMin) {\n      // calculate ageMaxDate\n      const ageMaxYear = consideredYear - category.ageMin;\n      ageMaxDate = constructedDate(ageMaxYear, previousMonthDay);\n    }\n    if (category.ageMax) {\n      // calculate ageMinDate\n      const ageMinYear = consideredYear - category.ageMax - 1;\n      ageMinDate = constructedDate(ageMinYear, nextMonthDay);\n    }\n\n    const [lowAge, highAge] = (ageCategoryCode?.match(extractCombined) ?? [])\n      .slice(1)\n      .map((n) => parseInt(n));\n    if (lowAge <= highAge) {\n      ageMin = lowAge;\n      ageMax = highAge;\n      combinedAge = true;\n    } else {\n      addError(`Invalid combined age range ${ageCategoryCode}`);\n    }\n  } else if (isBetween) {\n    ageCategoryCode?.split('-').forEach(processCode);\n  } else if (isCoded) {\n    processCode(ageCategoryCode);\n  } else {\n    if (ageMin) oPre(ageMin);\n    if (ageMax) uPost(ageMax);\n  }\n\n  if (ageMax && category.ageMin && category.ageMin > ageMax) {\n    addError(`Invalid submitted ageMin: ${category.ageMin}`);\n    ageMin = undefined;\n  }\n\n  const result = definedAttributes({\n    consideredDate,\n    combinedAge,\n    ageMaxDate,\n    ageMinDate,\n    ageMax,\n    ageMin,\n  });\n\n  if (errors.length) result.errors = errors;\n\n  return result;\n}\n","import { getCategoryAgeDetails } from '../query/event/getCategoryAgeDetails';\nimport { decorateResult } from '../global/functions/decorateResult';\nimport { isObject } from '../utilities/objects';\n\nimport { INVALID_VALUES } from '../constants/errorConditionConstants';\nimport { isNumeric } from '../utilities/math';\n\nexport function validateCategory({ category }) {\n  if (!isObject(category)) return { error: INVALID_VALUES };\n\n  const categoryDetails = getCategoryAgeDetails({ category });\n  if (categoryDetails.error) return { error: categoryDetails };\n\n  const { ratingMax, ratingMin } = category;\n\n  if (ratingMax && !isNumeric(ratingMax))\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      context: { ratingMax },\n    });\n\n  if (ratingMin && !isNumeric(ratingMin))\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      context: { ratingMin },\n    });\n\n  return { ...categoryDetails };\n}\n","import { definedAttributes } from '../../utilities/definedAttributes';\nimport { validateCategory } from '../../validators/validateCategory';\n\nimport { Category } from '../../types/tournamentTypes';\n\ntype CategoryCanContainArgs = {\n  childCategory: Category;\n  withDetails?: boolean;\n  category: Category;\n};\n\nexport function categoryCanContain({\n  childCategory,\n  withDetails,\n  category,\n}: CategoryCanContainArgs) {\n  const categoryDetails = validateCategory({ category });\n  const childCategoryDetails = validateCategory({\n    category: childCategory,\n  });\n\n  const invalidAgeMin =\n    childCategoryDetails.ageMin &&\n    ((categoryDetails.ageMin &&\n      childCategoryDetails.ageMin < categoryDetails.ageMin) ||\n      (categoryDetails.ageMax &&\n        childCategoryDetails.ageMin > categoryDetails.ageMax));\n\n  const invalidAgeMax =\n    childCategoryDetails.ageMax &&\n    ((categoryDetails.ageMax &&\n      childCategoryDetails.ageMax > categoryDetails.ageMax) ||\n      (categoryDetails.ageMin &&\n        childCategoryDetails.ageMax < categoryDetails.ageMin));\n\n  const invalidAgeMinDate =\n    childCategoryDetails.ageMinDate &&\n    categoryDetails.ageMaxDate &&\n    new Date(childCategoryDetails.ageMinDate) >\n      new Date(categoryDetails.ageMaxDate);\n\n  const invalidAgeMaxDate =\n    childCategoryDetails.ageMaxDate &&\n    categoryDetails.ageMinDate &&\n    new Date(childCategoryDetails.ageMaxDate) <\n      new Date(categoryDetails.ageMinDate);\n\n  const ratingComparison =\n    category?.ratingType &&\n    childCategory?.ratingType &&\n    category.ratingType === childCategory.ratingType;\n\n  const invalidRatingRange =\n    ratingComparison &&\n    ((category.ratingMin &&\n      childCategory.ratingMin &&\n      childCategory.ratingMin < category.ratingMin) ||\n      (category.ratingMax &&\n        childCategory.ratingMax &&\n        childCategory.ratingMax > category.ratingMax) ||\n      (category.ratingMin &&\n        childCategory.ratingMax &&\n        childCategory.ratingMax < category.ratingMin) ||\n      (category.ratingMax &&\n        childCategory.ratingMin &&\n        childCategory.ratingMin > category.ratingMax));\n\n  const invalidBallType =\n    category?.ballType &&\n    childCategory?.ballType &&\n    category.ballType !== childCategory.ballType;\n\n  const valid =\n    !invalidRatingRange &&\n    !invalidAgeMinDate &&\n    !invalidAgeMaxDate &&\n    !invalidBallType &&\n    !invalidAgeMax &&\n    !invalidAgeMin;\n\n  const ignoreFalse = true;\n  const result = definedAttributes(\n    {\n      invalidRatingRange,\n      invalidAgeMinDate,\n      invalidAgeMaxDate,\n      invalidBallType,\n      invalidAgeMax,\n      invalidAgeMin,\n      valid,\n    },\n    ignoreFalse\n  );\n\n  if (withDetails) {\n    Object.assign(result, { categoryDetails, childCategoryDetails });\n  }\n\n  return result;\n}\n","import { isValidMatchUpFormat } from '../../../validators/isValidMatchUpFormat';\nimport { stringify } from '../../generators/matchUpFormatCode/stringify';\nimport { parse } from '../../generators/matchUpFormatCode/parse';\n\nexport const matchUpFormatCode = {\n  isValid: isValidMatchUpFormat,\n  isValidMatchUpFormat,\n  stringify,\n  parse,\n};\n\nexport default matchUpFormatCode;\n","import { tieFormatGenderValidityCheck } from './tieFormatGenderValidityCheck';\nimport { categoryCanContain } from '../query/event/categoryCanContain';\nimport { matchUpFormatCode } from '../assemblies/governors/matchUpFormatGovernor';\nimport { validateCollectionValueProfiles } from './validateCollectionValueProfiles';\nimport { decorateResult } from '../global/functions/decorateResult';\nimport { isConvertableInteger } from '../utilities/math';\n\nimport { DOUBLES, SINGLES } from '../constants/matchUpTypes';\nimport {\n  INVALID_CATEGORY,\n  INVALID_COLLECTION_DEFINITION,\n  INVALID_OBJECT,\n} from '../constants/errorConditionConstants';\nimport {\n  Category,\n  CollectionDefinition,\n  Event,\n  EventTypeUnion,\n  GenderUnion,\n} from '../types/tournamentTypes';\n\ntype ValidateCollectionDefinitionArgs = {\n  collectionDefinition: CollectionDefinition;\n  referenceGender?: GenderUnion;\n  referenceCategory?: Category;\n  checkCollectionIds?: boolean;\n  eventType?: EventTypeUnion;\n  checkCategory?: boolean;\n  checkGender?: boolean;\n  event?: Event;\n};\nexport function validateCollectionDefinition({\n  checkCategory = true,\n  collectionDefinition,\n  checkCollectionIds,\n  checkGender = true,\n  referenceCategory,\n  referenceGender,\n  event,\n}: ValidateCollectionDefinitionArgs) {\n  referenceGender = referenceGender ?? event?.gender;\n  const stack = 'validateCollectionDefinition';\n  const errors: string[] = [];\n\n  if (typeof collectionDefinition !== 'object') {\n    errors.push(\n      `collectionDefinition must be an object: ${collectionDefinition}`\n    );\n    return decorateResult({ result: { errors, error: INVALID_OBJECT }, stack });\n  }\n\n  const {\n    collectionValueProfiles,\n    collectionGroupNumber,\n    collectionValue,\n    collectionId,\n    matchUpCount,\n    matchUpFormat,\n    matchUpValue,\n    matchUpType,\n    scoreValue,\n    setValue,\n    category,\n    gender,\n  } = collectionDefinition;\n\n  if (checkCollectionIds && typeof collectionId !== 'string') {\n    errors.push(`collectionId is not type string: ${collectionId}`);\n  }\n  if (typeof matchUpCount !== 'number') {\n    errors.push(`matchUpCount is not type number: ${matchUpCount}`);\n  }\n  if (matchUpType && ![SINGLES, DOUBLES].includes(matchUpType)) {\n    errors.push(`matchUpType must be SINGLES or DOUBLES: ${matchUpType}`);\n  }\n\n  const valueDeclarations = [!!collectionValueProfiles?.length]\n    .concat(\n      [matchUpValue, collectionValue, scoreValue, setValue].map(\n        isConvertableInteger\n      )\n    )\n    .filter(Boolean);\n\n  if (valueDeclarations.length !== 1) {\n    errors.push(\n      'Missing value definition for matchUps: matchUpValue, collectionValue, or collectionValueProfiles'\n    );\n  }\n\n  if (matchUpValue && typeof matchUpValue !== 'number') {\n    errors.push(`matchUpValue is not type number: ${matchUpValue}`);\n  }\n  if (collectionValue && typeof collectionValue !== 'number') {\n    errors.push(`collectionValue is not type number: ${collectionValue}`);\n  }\n  if (collectionValueProfiles && matchUpCount) {\n    const result = validateCollectionValueProfiles({\n      collectionValueProfiles,\n      matchUpCount,\n    });\n    if (result.errors) {\n      errors.push(...result.errors);\n    }\n  }\n\n  if (collectionGroupNumber && typeof collectionGroupNumber !== 'number') {\n    errors.push(`collectionGroupNumber is not type number: ${collectionValue}`);\n  }\n\n  if (\n    matchUpFormat &&\n    !matchUpFormatCode.isValidMatchUpFormat({ matchUpFormat })\n  ) {\n    errors.push(`Invalid matchUpFormat: ${matchUpFormat}`);\n  }\n\n  if (checkGender) {\n    const result = tieFormatGenderValidityCheck({\n      referenceGender,\n      matchUpType,\n      gender,\n    });\n\n    if (result.error) {\n      return decorateResult({\n        context: { referenceGender, gender },\n        result,\n        stack,\n      });\n    }\n  }\n\n  if (checkCategory && referenceCategory && category) {\n    const result = categoryCanContain({\n      category: referenceCategory,\n      childCategory: category,\n    });\n    if (!result.valid)\n      return decorateResult({\n        result: { error: INVALID_CATEGORY },\n        context: result,\n        stack,\n      });\n  }\n\n  if (errors.length)\n    return decorateResult({\n      result: { errors, error: INVALID_COLLECTION_DEFINITION },\n      stack,\n    });\n\n  return { valid: true };\n}\n","import { decorateResult, ResultType } from '../global/functions/decorateResult';\nimport { validateCollectionDefinition } from './validateCollectionDefinition';\nimport { mustBeAnArray } from '../utilities/mustBeAnArray';\nimport { unique } from '../utilities/arrays';\n\nimport { INVALID_TIE_FORMAT } from '../constants/errorConditionConstants';\nimport { Category, Event, GenderUnion } from '../types/tournamentTypes';\n\ntype ValidateTieFormatArgs = {\n  checkCollectionIds?: boolean;\n  enforceCategory?: boolean;\n  enforceGender?: boolean;\n  gender?: GenderUnion;\n  category?: Category;\n  tieFormat?: any; // not using TieFormat type because incoming value is potentially invalid\n  event?: Event;\n};\n\nexport function validateTieFormat(params: ValidateTieFormatArgs): ResultType {\n  const checkCategory = !!(\n    params?.enforceCategory !== false && params?.category\n  );\n  const checkGender = !!(params?.enforceGender !== false && params?.gender);\n  const checkCollectionIds = params?.checkCollectionIds;\n  const tieFormat = params?.tieFormat;\n  const event = params?.event;\n\n  const stack = 'validateTieFormat';\n  const errors: string[] = [];\n\n  if (!params || !tieFormat || typeof tieFormat !== 'object') {\n    errors.push('tieFormat must be an object');\n    return decorateResult({\n      result: { error: INVALID_TIE_FORMAT },\n      context: { tieFormat, errors },\n      stack,\n    });\n  }\n\n  if (typeof tieFormat.winCriteria !== 'object') {\n    errors.push('tieFormat.winCriteria must be an object');\n    return decorateResult({\n      result: { error: INVALID_TIE_FORMAT },\n      context: { tieFormat, errors },\n      stack,\n    });\n  }\n\n  if (!Array.isArray(tieFormat.collectionDefinitions)) {\n    errors.push(mustBeAnArray('tieFormat.collectionDefinitions'));\n    return decorateResult({\n      result: { error: INVALID_TIE_FORMAT },\n      context: { tieFormat, errors },\n      stack,\n    });\n  }\n\n  let aggregateValueImperative;\n  const validCollections = tieFormat.collectionDefinitions.every(\n    (collectionDefinition) => {\n      const { setValue, scoreValue, collectionValue } = collectionDefinition;\n      if ((setValue || scoreValue) && !collectionValue)\n        aggregateValueImperative = true;\n      const { valid, errors: collectionDefinitionErrors } =\n        validateCollectionDefinition({\n          referenceCategory: params.category,\n          referenceGender: params.gender,\n          collectionDefinition,\n          checkCollectionIds,\n          checkCategory,\n          checkGender,\n          event,\n        });\n\n      if (valid) {\n        return true;\n      } else if (Array.isArray(collectionDefinitionErrors)) {\n        errors.push(...collectionDefinitionErrors);\n      }\n      return false;\n    }\n  );\n\n  const validWinCriteria =\n    (typeof tieFormat.winCriteria?.valueGoal === 'number' &&\n      tieFormat.winCriteria?.valueGoal > 0 &&\n      !aggregateValueImperative) ||\n    tieFormat.winCriteria?.aggregateValue;\n\n  if (!(validWinCriteria || tieFormat.winCriteria?.aggregateValue)) {\n    if (aggregateValueImperative) {\n      errors.push('aggregateValue is required');\n    } else {\n      errors.push(\n        'Either non-zero valueGoal, or { aggregateValue: true } must be specified in winCriteria'\n      );\n    }\n    return decorateResult({\n      context: { tieFormat, errors, aggregateValueImperative },\n      result: { error: INVALID_TIE_FORMAT },\n      stack,\n    });\n  }\n\n  const collectionIds = tieFormat.collectionDefinitions.map(\n    ({ collectionId }) => collectionId\n  );\n  const uniqueCollectionIds =\n    !checkCollectionIds ||\n    collectionIds.length === unique(collectionIds).length;\n\n  const valid = validCollections && validWinCriteria && uniqueCollectionIds;\n\n  const result = { valid, errors };\n  if (!valid) {\n    return decorateResult({\n      result: { error: INVALID_TIE_FORMAT },\n      context: { tieFormat, errors },\n      stack,\n    });\n  }\n  return result;\n}\n","import { generateRange } from '../../../utilities/arrays';\nimport { UUID } from '../../../utilities/UUID';\n\nimport { TO_BE_PLAYED } from '../../../constants/matchUpStatusConstants';\nimport { MatchUp, TieFormat } from '../../../types/tournamentTypes';\n\ntype GenerateTieMatchUpsArgs = {\n  tieFormat?: TieFormat;\n  matchUp?: MatchUp;\n  isMock?: boolean;\n  uuids?: string[];\n};\nexport function generateTieMatchUps({ matchUp, tieFormat, isMock, uuids }: GenerateTieMatchUpsArgs) {\n  const { collectionDefinitions } = tieFormat ?? {};\n\n  const tieMatchUps = (collectionDefinitions ?? [])\n    .map((collectionDefinition) => generateCollectionMatchUps({ matchUp, collectionDefinition, uuids, isMock }))\n    .filter(Boolean)\n    .flat();\n\n  return { tieMatchUps };\n}\n\ntype GenerateCollectionMatchUpsArgs = {\n  collectionPositionOffset?: number;\n  collectionDefinition: any;\n  matchUpsLimit?: number;\n  matchUp?: MatchUp;\n  isMock?: boolean;\n  uuids?: string[];\n};\nexport function generateCollectionMatchUps({\n  collectionPositionOffset = 0,\n  collectionDefinition,\n  matchUpsLimit, // internal use allows generation of missing matchUps on \"reset\"\n  matchUp,\n  isMock,\n  uuids,\n}: GenerateCollectionMatchUpsArgs): MatchUp[] {\n  const { matchUpCount, matchUpType, collectionId, processCodes } = collectionDefinition || {};\n\n  const numberToGenerate = matchUpsLimit ?? matchUpCount ?? 0;\n\n  const getMatchUpId = (index) => {\n    if (!isMock && !matchUp?.isMock) return uuids?.pop() ?? UUID();\n    const collectionId = collectionDefinition?.collectionId;\n    return uuids?.pop() ?? `${matchUp?.matchUpId}-${collectionId}-TMU-${index + 1}`;\n  };\n\n  return generateRange(0, numberToGenerate).map((index) => {\n    const collectionPosition = collectionPositionOffset + index + 1;\n    return {\n      sides: [{ sideNumber: 1 }, { sideNumber: 2 }],\n      matchUpId: getMatchUpId(index),\n      matchUpStatus: TO_BE_PLAYED,\n      collectionPosition,\n      collectionId,\n      processCodes,\n      matchUpType,\n      isMock,\n    };\n  });\n}\n","import { DOUBLES_MATCHUP } from '../../../constants/matchUpTypes';\n\nexport function getTieFormatDesc(tieFormat) {\n  if (!tieFormat) return {};\n\n  const matchUpFormats: string[] = [];\n\n  const tieFormatName = tieFormat.tieFormatName;\n  const tieFormatDesc = tieFormat.collectionDefinitions\n    ?.map((def) => {\n      const { matchUpType, matchUpFormat, matchUpCount, category, gender } =\n        def;\n\n      if (!matchUpFormats.includes(matchUpFormat))\n        matchUpFormats.push(matchUpFormat);\n\n      const ageCategoryCode = category?.ageCategoryCode;\n      const matchUpTypeCode = matchUpType === DOUBLES_MATCHUP ? 'D' : 'S';\n      return [\n        matchUpCount,\n        matchUpTypeCode,\n        ageCategoryCode,\n        matchUpFormat,\n        gender,\n      ].join(';');\n    })\n    .join('|');\n  return {\n    tieFormatName: (tieFormat && tieFormatName) || 'UNNAMED',\n    matchUpFormats,\n    tieFormatDesc,\n  };\n}\n","import { getTieFormatDesc } from '../../../query/hierarchical/tieFormats/getTieFormatDescription';\nimport { stringSort } from '../../../functions/sorters/stringSort';\nimport { isConvertableInteger } from '../../../utilities/math';\nimport { difference, unique } from '../../../utilities/arrays';\n\nimport { TieFormat } from '../../../types/tournamentTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\ntype CompareTieFormatsArgs = {\n  considerations?: any;\n  descendant: TieFormat;\n  ancestor: TieFormat;\n};\n\nexport function compareTieFormats({\n  considerations = {},\n  descendant,\n  ancestor,\n}: CompareTieFormatsArgs) {\n  const descendantDifferences: any = {};\n  const ancestorDifferences: any = {};\n\n  const {\n    matchUpFormats: descendantMatchUpFormats,\n    tieFormatDesc: descendantDesc,\n  } = getTieFormatDesc(descendant);\n\n  const {\n    matchUpFormats: ancestorMatchUpFormats,\n    tieFormatDesc: ancestorDesc,\n  } = getTieFormatDesc(ancestor);\n\n  const matchUpFormatDifferences = unique(\n    (descendantMatchUpFormats ?? [])\n      .filter((format) => !(ancestorMatchUpFormats ?? []).includes(format))\n      .concat(\n        (ancestorMatchUpFormats ?? []).filter(\n          (format) => !(descendantMatchUpFormats ?? []).includes(format)\n        )\n      )\n  );\n\n  const nameDifference = !!(\n    considerations?.collectionName &&\n    descendant.collectionDefinitions\n      .map(({ collectionName }) => collectionName)\n      .join('|') !==\n      ancestor.collectionDefinitions\n        .map(({ collectionName }) => collectionName)\n        .join('|')\n  );\n\n  const orderDifference = !!(\n    considerations?.collectionOrder &&\n    descendant.collectionDefinitions\n      .map(({ collectionOrder }) => collectionOrder)\n      .join('|') !==\n      ancestor.collectionDefinitions\n        .map(({ collectionOrder }) => collectionOrder)\n        .join('|')\n  );\n\n  const descendantCollectionDefinitions = Object.assign(\n    {},\n    ...(descendant?.collectionDefinitions || []).map(\n      (collectionDefinition) => ({\n        [collectionDefinition.collectionId]: collectionDefinition,\n      })\n    )\n  );\n  const ancestorCollectionDefinitions = Object.assign(\n    {},\n    ...(ancestor?.collectionDefinitions || []).map((collectionDefinition) => ({\n      [collectionDefinition.collectionId]: collectionDefinition,\n    }))\n  );\n\n  descendantDifferences.collectionIds = difference(\n    Object.keys(descendantCollectionDefinitions),\n    Object.keys(ancestorCollectionDefinitions)\n  );\n  ancestorDifferences.collectionIds = difference(\n    Object.keys(ancestorCollectionDefinitions),\n    Object.keys(descendantCollectionDefinitions)\n  );\n\n  descendantDifferences.collectionsValue = getCollectionsValue(\n    descendantCollectionDefinitions\n  );\n\n  ancestorDifferences.collectionsValue = getCollectionsValue(\n    ancestorCollectionDefinitions\n  );\n\n  descendantDifferences.groupsCount =\n    ancestor?.collectionGroups?.length ??\n    (0 - (descendant?.collectionGroups?.length ?? 0) || 0);\n\n  ancestorDifferences.groupsCount = descendantDifferences.groupsCount\n    ? -1 * descendantDifferences.groupsCount\n    : 0;\n\n  const valueDifference =\n    descendantDifferences.collectionsValue.totalValue -\n    ancestorDifferences.collectionsValue.totalValue;\n  const matchUpCountDifference =\n    descendantDifferences.collectionsValue.totalMatchUps -\n    ancestorDifferences.collectionsValue.totalMatchUps;\n\n  const assignmentValuesCountDifference =\n    ancestorDifferences.collectionsValue.assignmentValues.length !==\n    descendantDifferences.collectionsValue.assignmentValues.length;\n\n  const assignmentValuesDifference =\n    ancestorDifferences.collectionsValue.assignmentValues.some(\n      (assignment, i) => {\n        const comparisonAssignment =\n          descendantDifferences.collectionsValue.assignmentValues[i];\n        if (!comparisonAssignment) return true;\n\n        if (assignment.valueKey !== comparisonAssignment.valueKey) return true;\n        if (assignment.value !== comparisonAssignment.value) return true;\n        if (Array.isArray(assignment.value)) {\n          return assignment.value.every(\n            (value, i) => comparisonAssignment.value[i] === value\n          );\n        }\n\n        return false;\n      }\n    );\n\n  const different =\n    nameDifference ||\n    orderDifference ||\n    ancestorDesc !== descendantDesc ||\n    assignmentValuesCountDifference ||\n    assignmentValuesDifference ||\n    valueDifference !== 0;\n\n  const invalidValues = [\n    ...ancestorDifferences.collectionsValue.invalidValues,\n    ...descendantDifferences.collectionsValue.invalidValues,\n  ];\n  const invalid = invalidValues.length && invalidValues;\n\n  return {\n    matchUpFormatDifferences,\n    matchUpCountDifference,\n    descendantDifferences,\n    ancestorDifferences,\n    orderDifference,\n    valueDifference,\n    nameDifference,\n    descendantDesc,\n    ancestorDesc,\n    ...SUCCESS,\n    different,\n    invalid,\n  };\n}\n\nfunction getCollectionsValue(definitions) {\n  const invalidValues: { collectionId: string }[] = [];\n  const assignmentValues: { valueKey: string; value: number | number[] }[] = [];\n  let totalMatchUps = 0;\n\n  const collectionIds = Object.keys(definitions).sort(stringSort);\n  const totalValue = collectionIds.reduce((total, collectionId) => {\n    const collectionDefinition = definitions[collectionId];\n    const {\n      collectionValueProfiles,\n      collectionValue,\n      matchUpCount,\n      matchUpValue,\n      scoreValue,\n      setValue,\n    } = collectionDefinition;\n\n    const valueAssignments = {\n      collectionValueProfiles,\n      collectionValue,\n      matchUpValue,\n      scoreValue,\n      setValue,\n    };\n\n    const valueKeys = Object.keys(valueAssignments).filter(\n      (key) => ![undefined, null].includes(valueAssignments[key])\n    );\n    if (valueKeys.length !== 1) {\n      invalidValues.push({ collectionId });\n    }\n\n    const valueKey = valueKeys[0];\n    if (valueKey) {\n      const value =\n        valueKey === 'collectionValueProfiles'\n          ? Object.values(collectionValueProfiles)\n          : valueAssignments[valueKey];\n      assignmentValues.push({ valueKey, value });\n    }\n\n    totalMatchUps += matchUpCount;\n\n    if (collectionValueProfiles)\n      return (\n        total +\n        collectionValueProfiles.reduce(\n          (total, profile) => total + profile.value,\n          0\n        )\n      );\n\n    if (matchUpCount) {\n      if (isConvertableInteger(matchUpValue))\n        return total + matchUpValue * matchUpCount;\n\n      if (isConvertableInteger(scoreValue))\n        return total + scoreValue * matchUpCount;\n\n      if (isConvertableInteger(setValue))\n        return total + setValue * matchUpCount;\n\n      return total + collectionValue;\n    }\n\n    return total;\n  }, 0);\n\n  return { totalValue, totalMatchUps, invalidValues, assignmentValues };\n}\n","import { checkScoreHasValue } from '../query/matchUp/checkScoreHasValue';\n\nimport {\n  completedMatchUpStatuses,\n  IN_PROGRESS,\n} from '../constants/matchUpStatusConstants';\n\nexport function validUpdate({ matchUp, updateInProgressMatchUps }) {\n  return (\n    !matchUp.winningSide &&\n    ![completedMatchUpStatuses].includes(matchUp.matchUpStatus) &&\n    (updateInProgressMatchUps ||\n      (matchUp.matchUpStatus !== IN_PROGRESS && !checkScoreHasValue(matchUp)))\n  );\n}\n","import { generateCollectionMatchUps } from '../../assemblies/generators/drawDefinitions/tieMatchUps';\nimport { compareTieFormats } from '../../query/hierarchical/tieFormats/compareTieFormats';\nimport { getAllStructureMatchUps } from '../../query/matchUps/getAllStructureMatchUps';\nimport { ResultType, decorateResult } from '../../global/functions/decorateResult';\nimport { copyTieFormat } from '../../query/hierarchical/tieFormats/copyTieFormat';\nimport { getTieFormat } from '../../query/hierarchical/tieFormats/getTieFormat';\nimport { instanceCount, intersection } from '../../utilities/arrays';\nimport { xa } from '../../utilities/objects';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { validUpdate } from '../../validators/validUpdate';\nimport {\n  addMatchUpsNotice,\n  deleteMatchUpsNotice,\n  modifyDrawNotice,\n  modifyMatchUpNotice,\n} from '../notifications/drawNotifications';\n\nimport { DrawDefinition, Event, MatchUp, Structure, TieFormat, Tournament } from '../../types/tournamentTypes';\nimport { TO_BE_PLAYED } from '../../constants/matchUpStatusConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { TEAM } from '../../constants/matchUpTypes';\nimport {\n  CANNOT_MODIFY_TIEFORMAT,\n  ErrorType,\n  INVALID_MATCHUP,\n  INVALID_TIE_FORMAT,\n  MISSING_DRAW_DEFINITION,\n  MISSING_TIE_FORMAT,\n} from '../../constants/errorConditionConstants';\n\n// used to determine that all collections have the same collectionIds\nfunction checkStructureMatchUpCounts({ from, to }) {\n  const referenceKeys = Object.keys(from);\n  const sameKeys = intersection(referenceKeys, Object.keys(to)).length === referenceKeys.length;\n\n  const differentMatchUpsCount = referenceKeys.filter((collectionId) => from[collectionId] !== to[collectionId]);\n  const matchUpsCountChanges = differentMatchUpsCount.map((collectionId) => ({\n    countChange: to[collectionId] - from[collectionId],\n    collectionId,\n  }));\n\n  const sameMatchUpsCount = referenceKeys.every((key) => from[key] === to[key]);\n  const equivalent = sameKeys && sameMatchUpsCount;\n  return { equivalent, matchUpsCountChanges };\n}\n\ntype UpdateTieFormatArgs = {\n  updateInProgressMatchUps?: boolean;\n  tournamentRecord?: Tournament;\n  drawDefinition?: DrawDefinition;\n  structure?: Structure;\n  tieFormat: TieFormat;\n  matchUp?: MatchUp;\n  eventId?: string;\n  uuids?: string[];\n  event?: Event;\n};\n\ntype UpdateTieFormatResult = {\n  modifiedStructuresCount?: number;\n  modifiedMatchUpsCount?: number;\n  addedMatchUpsCount?: number;\n  modifiedCount?: number;\n  tieFormat?: TieFormat;\n  error?: ErrorType;\n};\n\nexport function updateTieFormat({\n  updateInProgressMatchUps,\n  tournamentRecord,\n  drawDefinition,\n  structure,\n  tieFormat,\n  eventId,\n  matchUp,\n  event,\n  uuids,\n}: UpdateTieFormatArgs): UpdateTieFormatResult {\n  const stack = 'updateTieFormat';\n  const tournamentId = tournamentRecord?.tournamentId;\n  let modifiedStructuresCount = 0;\n  let modifiedMatchUpsCount = 0;\n  let addedMatchUpsCount = 0;\n  let modifiedCount = 0;\n\n  const collectionMap = tieFormat?.collectionDefinitions.reduce((instanceMap, def) => {\n    instanceMap[def.collectionId] = (instanceMap[def.collectionId] || 0) + def.matchUpCount;\n    return instanceMap;\n  }, {});\n\n  const matchingCollections = ({ tieFormat }) => {\n    const cMap = tieFormat?.collectionDefinitions.reduce((instanceMap, def) => {\n      instanceMap[def.collectionId] = (instanceMap[def.collectionId] || 0) + def.matchUpCount;\n      return instanceMap;\n    }, {});\n    return checkStructureMatchUpCounts({ from: cMap, to: collectionMap }).equivalent;\n  };\n\n  const drawDefaultTieFormat = getTieFormat({ drawDefinition })?.tieFormat;\n  const eventDefaultTieFormat = getTieFormat({ event })?.tieFormat;\n\n  if (event && eventId) {\n    for (const drawDefinition of event.drawDefinitions ?? []) {\n      processDrawDefinition({ drawDefinition });\n    }\n    event.tieFormat = copyTieFormat(tieFormat);\n    modifiedCount += 1;\n  } else if (matchUp) {\n    if (!matchUp.tieMatchUps) {\n      return decorateResult({ result: { error: INVALID_MATCHUP }, stack });\n    }\n    // ensure that all tieMatchUps are referenced by tieFormat\n    const matchUpMap = instanceCount(matchUp.tieMatchUps?.map(({ collectionId }) => collectionId));\n    const check = checkStructureMatchUpCounts({\n      to: collectionMap,\n      from: matchUpMap,\n    });\n    const { changes, changesArePossible, cannotChangeReaon } = getMatchUpChangesArePossible({\n      matchUp,\n      check,\n    });\n\n    if (check.equivalent) {\n      if (validUpdate({ matchUp, updateInProgressMatchUps })) {\n        matchUp.tieFormat = copyTieFormat(tieFormat);\n        modifiedCount += 1;\n      } else {\n        return decorateResult({\n          result: { error: CANNOT_MODIFY_TIEFORMAT },\n          info: 'matchUp is IN_PROGRESS or COMPLETE',\n          stack,\n        });\n      }\n    } else if (changesArePossible) {\n      makeChanges({ tieFormat, matchUp, changes, uuids });\n    } else {\n      return decorateResult({\n        context: { collectionMap, matchUpMap },\n        result: { error: INVALID_TIE_FORMAT },\n        info: cannotChangeReaon || 'specified changes not possible',\n        stack,\n      });\n    }\n\n    modifiedMatchUpsCount += 1;\n    modifyMatchUpNotice({\n      eventId: event?.eventId,\n      context: stack,\n      drawDefinition,\n      tournamentId,\n      matchUp,\n    });\n  } else if (structure) {\n    // all TEAM matchUps within the structure have tieMatchUps which were created following a tieFormat which occurs higher in the hierarchy\n    // attaching a tieFormat to the structure must ensure that affected TEAM matchUps within the structure all have appropriate tieMatchUps\n    // therefore those that fail to match the modified tieFormat MUST have an appropriate tieFormat attached from higher in the hierarchy\n    const inheritedTieFormat = drawDefaultTieFormat ?? eventDefaultTieFormat;\n    const modified = processStructure({\n      inheritedTieFormat,\n      structure,\n    })?.modifiedMatchUpsCount;\n\n    if (modified) {\n      modifiedMatchUpsCount += modified;\n      modifiedStructuresCount += 1;\n      modifiedCount += 1;\n    }\n\n    const different =\n      !structure.tieFormat ||\n      compareTieFormats({\n        ancestor: structure.tieFormat,\n        descendant: tieFormat,\n      }).different;\n\n    if (different) {\n      structure.tieFormat = copyTieFormat(tieFormat);\n      modifiedStructuresCount += 1;\n      modifiedCount += 1;\n    }\n\n    (modified || different) &&\n      drawDefinition &&\n      modifyDrawNotice({\n        structureIds: [structure.structureId],\n        eventId: event?.eventId,\n        drawDefinition,\n      });\n  } else if (drawDefinition) {\n    processDrawDefinition({ drawDefinition });\n    drawDefinition.tieFormat = copyTieFormat(tieFormat);\n    modifiedCount += 1;\n  } else {\n    return { error: MISSING_DRAW_DEFINITION };\n  }\n\n  return {\n    modifiedStructuresCount,\n    modifiedMatchUpsCount,\n    addedMatchUpsCount,\n    modifiedCount,\n    ...SUCCESS,\n    tieFormat,\n  };\n\n  function processDrawDefinition({ drawDefinition }) {\n    const structures = drawDefinition.structures || [];\n    const modifiedStructureIds: string[] = [];\n\n    for (const structure of structures) {\n      // if a sub-structure has a tieFormat then setting drawDefinition.tieFormat will have no effect\n      if (structure.tieFormat) continue;\n\n      const inheritedTieFormat = eventDefaultTieFormat;\n      const modifiedCount = processStructure({\n        inheritedTieFormat,\n        structure,\n      })?.modifiedMatchUpsCount;\n\n      if (modifiedCount) {\n        modifiedStructuresCount += 1;\n        modifiedMatchUpsCount += modifiedCount;\n        const structureId = structure.structureId;\n        modifiedStructureIds.push(structureId);\n      }\n    }\n\n    modifyDrawNotice({\n      structureIds: modifiedStructureIds,\n      eventId: event?.eventId,\n      drawDefinition,\n    });\n\n    return modifiedStructureIds.length;\n  }\n\n  function processStructure({ inheritedTieFormat, structure }): ResultType & {\n    modifiedMatchUpsCount?: number;\n  } {\n    let modifiedMatchUpsCount = 0;\n    const structureMatchUps =\n      getAllStructureMatchUps({\n        matchUpFilters: { matchUpTypes: [TEAM] },\n        structure,\n      })?.matchUps || [];\n\n    for (const matchUp of structureMatchUps) {\n      const validToUpdate = validUpdate({ matchUp, updateInProgressMatchUps });\n\n      let modified = false;\n      const tieMatchUpsMap = instanceCount(matchUp.tieMatchUps?.map(({ collectionId }) => collectionId));\n      const check = checkStructureMatchUpCounts({\n        from: tieMatchUpsMap,\n        to: collectionMap,\n      });\n      if (!check.equivalent) {\n        const { changes, changesArePossible } = getMatchUpChangesArePossible({\n          matchUp,\n          check,\n        });\n\n        if (changesArePossible && !matchUp.tieFormat) {\n          makeChanges({ changes, matchUp, tieFormat, uuids });\n        } else if (inheritedTieFormat) {\n          const different =\n            !matchUp.tieFormat ||\n            compareTieFormats({\n              ancestor: inheritedTieFormat,\n              descendant: matchUp.tieFormat,\n            }).different;\n\n          if (different) {\n            matchUp.tieFormat = inheritedTieFormat;\n            modified = true;\n          }\n        } else {\n          return decorateResult({\n            result: { error: MISSING_TIE_FORMAT },\n            stack,\n          });\n        }\n      } else if (matchUp.tieFormat && matchingCollections(matchUp) && validToUpdate) {\n        matchUp.tieFormat = copyTieFormat(tieFormat);\n        modified = true;\n      }\n\n      if (modified) {\n        modifiedMatchUpsCount += 1;\n        modifyMatchUpNotice({\n          tournamentId: tournamentRecord?.tournamentId,\n          drawDefinition,\n          context: stack,\n          eventId,\n          matchUp,\n        });\n      }\n    }\n\n    return { modifiedMatchUpsCount };\n  }\n\n  function makeChanges({ uuids, matchUp, tieFormat, changes }) {\n    matchUp.tieFormat = copyTieFormat(tieFormat);\n    const matchUpIdsRemoved: string[] = [];\n    const matchUpsAdded: MatchUp[] = [];\n\n    changes.forEach((change) => {\n      if (change.countChange > 0) {\n        const collectionPositionOffset = Math.max(\n          0,\n          ...matchUp.tieMatchUps\n            .filter((tieMatchUp) => tieMatchUp.collectionId === change.collectionId)\n            .map(xa('collectionPosition')),\n        );\n        const collectionDefinition = tieFormat.collectionDefinitions.find(\n          (def) => def.collectionId === change.collectionId,\n        );\n        const newMatchUps: MatchUp[] = generateCollectionMatchUps({\n          matchUpsLimit: change.countChange,\n          collectionPositionOffset,\n          collectionDefinition,\n          matchUp,\n          uuids,\n        });\n        matchUpsAdded.push(...makeDeepCopy(newMatchUps, false, true));\n        addedMatchUpsCount += matchUpsAdded.length;\n        matchUp.tieMatchUps.push(...newMatchUps);\n      } else {\n        const tieMatchUpIdsToRemove = change.toBePlayedTieMatchUpIds.slice(0, Math.abs(change.countChange));\n        console.log('remove', tieMatchUpIdsToRemove.length);\n        matchUpIdsRemoved.push(...tieMatchUpIdsToRemove);\n        matchUp.tieMatchUps = matchUp.tieMatchUps.filter(({ matchUpId }) => !tieMatchUpIdsToRemove.includes(matchUpId));\n      }\n    });\n\n    matchUpsAdded.length &&\n      addMatchUpsNotice({\n        matchUps: matchUpsAdded,\n        drawDefinition,\n        tournamentId,\n        eventId,\n      });\n\n    matchUpIdsRemoved.length &&\n      deleteMatchUpsNotice({\n        matchUpIds: matchUpIdsRemoved,\n        action: 'updateTieFormat',\n        drawDefinition,\n        tournamentId,\n        eventId,\n      });\n\n    return { matchUpIdsRemoved, matchUpsAdded };\n  }\n}\n\nfunction getMatchUpChangesArePossible({ check, matchUp }) {\n  let cannotChangeReaon = '';\n  const changes: any[] = [];\n\n  const changesArePossible = check.matchUpsCountChanges.every(({ collectionId, countChange }) => {\n    const toBePlayedTieMatchUpIds = matchUp.tieMatchUps\n      .filter((tieMatchUp) => tieMatchUp.collectionId === collectionId && tieMatchUp.matchUpStatus === TO_BE_PLAYED)\n      .map(xa('matchUpId'));\n\n    const possibleToChange = toBePlayedTieMatchUpIds.length + countChange >= 0 || countChange > 0;\n\n    if (!possibleToChange && countChange < 0) cannotChangeReaon = 'Insufficient TO_BE_PLAYED matchUps';\n\n    changes.push({\n      toBePlayedTieMatchUpIds,\n      collectionId,\n      countChange,\n    });\n    return possibleToChange;\n  });\n  return { changesArePossible, changes, cannotChangeReaon };\n}\n","import { addExtension } from '../../extensions/addExtension';\nimport { findExtension } from '../../../acquire/findExtension';\n\nimport { TIE_FORMAT_MODIFICATIONS } from '../../../constants/extensionConstants';\n\nexport function tieFormatTelemetry({ drawDefinition, auditData }) {\n  const { extension } = findExtension({\n    name: TIE_FORMAT_MODIFICATIONS,\n    element: drawDefinition,\n  });\n\n  const updatedExtension = {\n    name: TIE_FORMAT_MODIFICATIONS,\n    value: Array.isArray(extension?.value)\n      ? extension?.value.concat(auditData)\n      : [auditData],\n  };\n  addExtension({ element: drawDefinition, extension: updatedExtension });\n}\n","import { validateCollectionValueProfiles } from '../../../validators/validateCollectionValueProfiles';\nimport { copyTieFormat } from '../../../query/hierarchical/tieFormats/copyTieFormat';\nimport { calculateWinCriteria } from '../../../query/matchUp/calculateWinCriteria';\nimport { getTieFormat } from '../../../query/hierarchical/tieFormats/getTieFormat';\nimport { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { isValidMatchUpFormat } from '../../../validators/isValidMatchUpFormat';\nimport { validateTieFormat } from '../../../validators/validateTieFormat';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { updateTieFormat } from '../../tieFormat/updateTieFormat';\nimport { isConvertableInteger } from '../../../utilities/math';\nimport { tieFormatTelemetry } from './tieFormatTelemetry';\nimport { intersection } from '../../../utilities/arrays';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../../global/functions/decorateResult';\n\nimport { TIE_FORMAT_MODIFICATIONS } from '../../../constants/extensionConstants';\nimport { genderConstants } from '../../../constants/genderConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  Category,\n  CollectionValueProfile,\n  DrawDefinition,\n  Event,\n  TieFormat,\n  Tournament,\n  EventTypeUnion,\n  GenderUnion,\n} from '../../../types/tournamentTypes';\nimport {\n  INVALID_VALUES,\n  MISSING_VALUE,\n  NOT_FOUND,\n  NOT_IMPLEMENTED,\n} from '../../../constants/errorConditionConstants';\n\n// all child matchUps need to be checked for collectionAssignments / collectionPositions which need to be removed when collectionDefinition.collectionIds are removed\ntype ModifyCollectionDefinitionArgs = {\n  updateInProgressMatchUps?: boolean;\n  tournamentRecord?: Tournament;\n  drawDefinition?: DrawDefinition;\n  collectionOrder?: number;\n  collectionName?: string;\n  tieFormatName?: string;\n  matchUpFormat?: string;\n  matchUpType?: EventTypeUnion;\n  matchUpCount?: number;\n  gender?: GenderUnion;\n  collectionId: string;\n  structureId?: string;\n  category?: Category;\n  matchUpId?: string;\n  eventId?: string;\n  event?: Event;\n\n  // value assignment, only one is allowed to have a value\n  collectionValueProfiles?: CollectionValueProfile[];\n  collectionValue?: number;\n  matchUpValue?: number;\n  scoreValue?: number;\n  setValue?: number;\n};\n\nexport function modifyCollectionDefinition({\n  updateInProgressMatchUps = false,\n  tournamentRecord,\n  collectionOrder,\n  collectionName,\n  tieFormatName,\n  drawDefinition,\n  matchUpFormat,\n  matchUpCount,\n  collectionId,\n  matchUpType,\n  structureId,\n  matchUpId,\n  category,\n  eventId,\n  gender,\n  event,\n\n  // value assignment, only one is allowed to have a value\n  collectionValueProfiles,\n  collectionValue,\n  matchUpValue,\n  scoreValue,\n  setValue,\n}: ModifyCollectionDefinitionArgs): ResultType & {\n  tieFormat?: TieFormat;\n  modifications?: any[];\n} {\n  const stack = 'modifyCollectionDefinition';\n\n  if (matchUpFormat && !isValidMatchUpFormat({ matchUpFormat })) {\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      context: { matchUpFormat },\n      stack,\n    });\n  }\n  if (collectionName && typeof collectionName !== 'string') {\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      context: { collectionName },\n      stack,\n    });\n  }\n  if (gender && !Object.values(genderConstants).includes(gender)) {\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      context: { gender },\n      stack,\n    });\n  }\n  if (category && typeof category !== 'object') {\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      context: { category },\n      stack,\n    });\n  }\n\n  const valueAssignments = {\n    collectionValueProfiles,\n    collectionValue,\n    matchUpValue,\n    scoreValue,\n    setValue,\n  };\n\n  if (\n    !Object.values(valueAssignments).filter(Boolean).length &&\n    !collectionOrder &&\n    !collectionName &&\n    !matchUpFormat &&\n    !matchUpCount &&\n    !matchUpType\n  )\n    return decorateResult({ result: { error: MISSING_VALUE }, stack });\n\n  if (Object.values(valueAssignments).filter(Boolean).length > 1)\n    return decorateResult({\n      info: 'Only one value assignment allowed per collectionDefinition',\n      result: { error: INVALID_VALUES },\n      stack,\n    });\n\n  let result = getTieFormat({\n    drawDefinition,\n    structureId,\n    matchUpId,\n    eventId,\n    event,\n  });\n  if (result.error) {\n    return decorateResult({ result, stack });\n  }\n\n  const { matchUp, structure, tieFormat: existingTieFormat } = result;\n  const tieFormat = copyTieFormat(existingTieFormat);\n\n  const sourceCollectionDefinition =\n    existingTieFormat?.collectionDefinitions.find(\n      (collectionDefinition) =>\n        collectionDefinition.collectionId === collectionId\n    );\n  const targetCollectionDefinition = tieFormat?.collectionDefinitions.find(\n    (collectionDefinition) => collectionDefinition.collectionId === collectionId\n  );\n\n  if (!sourceCollectionDefinition)\n    return decorateResult({\n      info: 'source collectionDefinition',\n      result: { error: NOT_FOUND },\n      context: { collectionId },\n      stack,\n    });\n\n  const value = collectionValue ?? matchUpValue ?? scoreValue ?? setValue;\n  if (collectionValueProfiles) {\n    const result = validateCollectionValueProfiles({\n      matchUpCount:\n        matchUpCount ?? sourceCollectionDefinition?.matchUpCount ?? 0,\n      collectionValueProfiles,\n    });\n    if (result.errors) {\n      return decorateResult({\n        result: { error: INVALID_VALUES },\n        info: result.errors,\n        stack,\n      });\n    }\n  } else if (value && !isConvertableInteger(value)) {\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      info: 'value is not an integer',\n      context: { value },\n      stack,\n    });\n  }\n\n  const equivalentValueProfiles = (a, b) =>\n    intersection(Object.keys(a), Object.keys(b)).length ===\n      Object.keys(a).length &&\n    intersection(Object.values(a), Object.values(b)).length ===\n      Object.values(a).length;\n\n  const valueProfileModified =\n    collectionValueProfiles &&\n    (!sourceCollectionDefinition.collectionValueProfiles ||\n      !equivalentValueProfiles(\n        sourceCollectionDefinition.collectionValueProfiles,\n        collectionValueProfiles\n      ));\n\n  const valueModified =\n    (isConvertableInteger(collectionValue) &&\n      sourceCollectionDefinition.collectionValue !== collectionValue) ||\n    (isConvertableInteger(matchUpValue) &&\n      sourceCollectionDefinition.matchUpValue !== matchUpValue) ||\n    (isConvertableInteger(scoreValue) &&\n      sourceCollectionDefinition.scoreValue !== scoreValue) ||\n    (isConvertableInteger(setValue) &&\n      sourceCollectionDefinition.setValue !== setValue) ||\n    valueProfileModified;\n\n  const modifications: any[] = [];\n  if (valueModified) {\n    // cleanup any previously existing value assignment\n    targetCollectionDefinition.collectionValueProfiles = undefined;\n    targetCollectionDefinition.collectionValue = undefined;\n    targetCollectionDefinition.matchUpValue = undefined;\n    targetCollectionDefinition.scoreValue = undefined;\n    targetCollectionDefinition.setValue = undefined;\n\n    // add new value assignment\n    Object.assign(targetCollectionDefinition, valueAssignments);\n    modifications.push({\n      collectionId,\n      ...definedAttributes(valueAssignments),\n    });\n  }\n\n  // must remove all collectionGroups which contain the collection which has been modified\n  if (\n    (isConvertableInteger(scoreValue) || isConvertableInteger(setValue)) &&\n    targetCollectionDefinition.collectionGroupNumber\n  ) {\n    const targetCollectionGroupNumber =\n      targetCollectionDefinition.collectionGroupNumber;\n    tieFormat.collectionDefinitions = tieFormat.collectionDefinitions.map(\n      (collectionDefinition) => {\n        const { collectionGroupNumber, ...rest } = collectionDefinition;\n        if (collectionGroupNumber === targetCollectionGroupNumber) {\n          return rest;\n        } else {\n          return collectionDefinition;\n        }\n      }\n    );\n    tieFormat.collectionGroups = tieFormat.collectionGroups.filter(\n      ({ groupNumber }) => groupNumber !== targetCollectionGroupNumber\n    );\n    modifications.push({\n      collectionId,\n      change: 'collectionGroupNumber removed',\n    });\n  }\n\n  // calculate new winCriteria for tieFormat\n  // if existing winCriteria is aggregateValue, retain\n  const { aggregateValue, valueGoal } = calculateWinCriteria(tieFormat);\n  const winCriteria = definedAttributes({ aggregateValue, valueGoal });\n  if (\n    winCriteria.aggregateValue !==\n      existingTieFormat?.winCriteria.aggregateValue ||\n    winCriteria.valueGoal !== existingTieFormat?.winCriteria.valueGoal\n  ) {\n    tieFormat.winCriteria = winCriteria;\n    modifications.push({ collectionId, winCriteria });\n  }\n\n  if (\n    isConvertableInteger(collectionOrder) &&\n    sourceCollectionDefinition.collectionOrder !== collectionOrder\n  ) {\n    targetCollectionDefinition.collectionOrder = collectionOrder;\n    modifications.push({ collectionId, collectionOrder });\n  }\n  if (\n    collectionName &&\n    sourceCollectionDefinition.collectionName !== collectionName\n  ) {\n    targetCollectionDefinition.collectionName = collectionName;\n    modifications.push({ collectionId, collectionName });\n  }\n  if (\n    matchUpFormat &&\n    sourceCollectionDefinition.matchUpFormat !== matchUpFormat\n  ) {\n    targetCollectionDefinition.matchUpFormat = matchUpFormat;\n    modifications.push({ collectionId, matchUpFormat });\n  }\n  if (\n    isConvertableInteger(matchUpCount) &&\n    sourceCollectionDefinition.matchUpCount !== matchUpCount\n  ) {\n    targetCollectionDefinition.matchUpCount = matchUpCount;\n    modifications.push({ collectionId, matchUpCount });\n  }\n  if (matchUpType && sourceCollectionDefinition.matchUpType !== matchUpType) {\n    // TODO: updateTieFormat needs to support\n    // targetCollectionDefinition.matchUpType = matchUpType;\n    // modifications.push({ collectionId, matchUpType });\n    return decorateResult({\n      result: { error: NOT_IMPLEMENTED },\n      context: { matchUpType },\n      stack,\n    });\n  }\n  if (category && sourceCollectionDefinition.category !== category) {\n    targetCollectionDefinition.category = category;\n    modifications.push({ collectionId, category });\n  }\n  if (gender && sourceCollectionDefinition.gender !== gender) {\n    // TODO: remove all inappropriately gendered participants\n    targetCollectionDefinition.gender = gender;\n    modifications.push({ collectionId, gender });\n  }\n\n  const modifiedTieFormat = definedAttributes(tieFormat);\n  result = validateTieFormat({ tieFormat: modifiedTieFormat });\n  if (result.error) {\n    return decorateResult({ result, stack });\n  }\n\n  if (!modifications.length) {\n    return decorateResult({ result: { ...SUCCESS, modifications } });\n  }\n\n  // Note: this logic needs to exist both here and in `modifyTieFormat`\n  // it is duplicated because this method can be called independently\n  const changedTieFormatName =\n    existingTieFormat?.tieFormatName !== tieFormatName;\n\n  // if tieFormat has changed, force renaming of the tieFormat\n  if (changedTieFormatName) {\n    modifiedTieFormat.tieFormatName = tieFormatName;\n    modifications.push({ tieFormatName });\n  } else if (modifications.length) {\n    delete modifiedTieFormat.tieFormatName;\n    modifications.push(\n      'tieFormatName removed: modifications without new tieFormatName'\n    );\n  }\n  result = updateTieFormat({\n    tieFormat: modifiedTieFormat,\n    updateInProgressMatchUps,\n    tournamentRecord,\n    drawDefinition,\n    structure,\n    eventId,\n    matchUp,\n    event,\n  });\n\n  if (!result.error) {\n    const { appliedPolicies } = getAppliedPolicies({ tournamentRecord });\n    if (appliedPolicies?.audit?.[TIE_FORMAT_MODIFICATIONS]) {\n      const auditData = definedAttributes({\n        collectionDefinition: targetCollectionDefinition,\n        drawId: drawDefinition?.drawId,\n        action: stack,\n        structureId,\n        matchUpId,\n        eventId,\n      });\n      tieFormatTelemetry({ drawDefinition, auditData });\n    }\n  }\n\n  return decorateResult({ result: { ...result, modifications }, stack });\n}\n","import { conditionallyDisableLinkPositioning } from '../../drawDefinitions/positionGovernor/conditionallyDisableLinkPositioning';\nimport { addPositionActionTelemetry } from '../../drawDefinitions/positionGovernor/addPositionActionTelemetry';\nimport { removeDrawPositionAssignment } from '../../drawDefinitions/removeDrawPositionAssignment';\nimport { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { getMatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { assignDrawPositionBye } from './assignDrawPositionBye';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { updateSideLineUp } from '../lineUps/updateSideLineUp';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { assignDrawPosition } from './positionAssignment';\nimport { resetLineUps } from '../lineUps/resetLineUps';\nimport {\n  modifyDrawNotice,\n  modifyPositionAssignmentsNotice,\n} from '../../notifications/drawNotifications';\n\nimport { CONTAINER } from '../../../constants/drawDefinitionConstants';\nimport { TEAM_MATCHUP } from '../../../constants/matchUpTypes';\nimport { TEAM_EVENT } from '../../../constants/eventConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n  MISSING_STRUCTURE_ID,\n  STRUCTURE_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\n\nexport function swapDrawPositionAssignments({\n  tournamentRecord,\n  drawDefinition,\n  drawPositions,\n  structureId,\n  event,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structureId) return { error: MISSING_STRUCTURE_ID };\n  if (drawPositions?.length !== 2) {\n    return { error: INVALID_VALUES, drawPositions };\n  }\n\n  const matchUpsMap = getMatchUpsMap({ drawDefinition });\n\n  const { matchUps: inContextDrawMatchUps } = getAllDrawMatchUps({\n    inContext: true,\n    drawDefinition,\n    matchUpsMap,\n  });\n\n  const { structure } = findStructure({ drawDefinition, structureId });\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  let result;\n  if (structure.structureType === CONTAINER) {\n    // { structureType: CONTAINER } indicates that the swap is within a ROUND ROBIN structure\n    result = roundRobinSwap({\n      inContextDrawMatchUps,\n      tournamentRecord,\n      drawDefinition,\n      drawPositions,\n      matchUpsMap,\n      structure,\n      event,\n    });\n  } else {\n    // if not a CONTAINER then swap occurs within elimination structure\n    result = eliminationSwap({\n      inContextDrawMatchUps,\n      tournamentRecord,\n      drawDefinition,\n      drawPositions,\n      matchUpsMap,\n      structure,\n      event,\n    });\n  }\n\n  if (result.error) return result;\n\n  conditionallyDisableLinkPositioning({ structure, drawPositions });\n  const positionAction = {\n    name: 'swapDrawPositionAssignments',\n    drawPositions,\n    structureId,\n  };\n  addPositionActionTelemetry({ drawDefinition, positionAction });\n\n  modifyPositionAssignmentsNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    drawDefinition,\n    structure,\n    event,\n  });\n\n  if (event.eventType === TEAM_EVENT) {\n    // update side lineUps for drawPositions that were swapped\n    const inContextTargetMatchUps = getAllStructureMatchUps({\n      matchUpFilters: { matchUpTypes: [TEAM_MATCHUP] },\n      inContext: true,\n      structure,\n    }).matchUps.filter(\n      (matchUp) =>\n        matchUp.drawPositions?.some((drawPosition) =>\n          drawPositions.includes(drawPosition)\n        )\n    );\n    const structureMatchUps = getAllStructureMatchUps({\n      structure,\n      matchUpFilters: { matchUpTypes: [TEAM_MATCHUP] },\n    }).matchUps;\n\n    inContextTargetMatchUps.forEach((inContextTargetMatchUp) => {\n      (inContextTargetMatchUp.sides || []).forEach((inContextSide) => {\n        const drawPosition = inContextSide?.drawPosition;\n        if (drawPositions.includes(drawPosition)) {\n          const teamParticipantId = inContextSide.participantId;\n          const matchUp = structureMatchUps.find(\n            ({ matchUpId }) => matchUpId === inContextTargetMatchUp.matchUpId\n          );\n          const drawPositionSideIndex = inContextTargetMatchUp?.sides?.reduce(\n            (index, side, i) =>\n              side.drawPosition === drawPosition ? i : index,\n            undefined\n          );\n\n          updateSideLineUp({\n            inContextTargetMatchUp,\n            drawPositionSideIndex,\n            teamParticipantId,\n            tournamentRecord,\n            drawDefinition,\n            matchUp,\n            event,\n          });\n        }\n      });\n    });\n  }\n  modifyDrawNotice({ drawDefinition, structureIds: [structureId] });\n\n  return { ...SUCCESS };\n}\n\nfunction eliminationSwap({\n  inContextDrawMatchUps,\n  tournamentRecord,\n  drawDefinition,\n  drawPositions,\n  matchUpsMap,\n  structure,\n  event,\n}) {\n  // if not a CONTAINER then swap occurs within elimination structure\n  const assignments = structure?.positionAssignments.filter(\n    (assignment) => drawPositions?.includes(assignment.drawPosition)\n  );\n\n  if (!assignments) {\n    return {\n      error: INVALID_VALUES,\n      structure,\n      info: 'Missing positionAssignments',\n    };\n  }\n\n  // if both positions are BYE no need to do anything\n  if (assignments.filter(({ bye }) => bye).length === 2) return { ...SUCCESS };\n\n  // if both positions are qualifier no need to do anything\n  if (assignments.filter(({ qualifier }) => qualifier).length === 2)\n    return { ...SUCCESS };\n\n  const isQualifierSwap = assignments.some(({ qualifier }) => qualifier);\n  const isByeSwap = assignments.some(({ bye }) => bye);\n\n  if (isByeSwap && !isQualifierSwap) {\n    return swapParticipantIdWithBYE({\n      inContextDrawMatchUps,\n      tournamentRecord,\n      drawDefinition,\n      assignments,\n      matchUpsMap,\n      structure,\n      event,\n    });\n  } else {\n    return eliminationPosiitonSwap({\n      inContextDrawMatchUps,\n      tournamentRecord,\n      drawDefinition,\n      assignments,\n      matchUpsMap,\n      structure,\n      event,\n    });\n  }\n}\n\nfunction swapParticipantIdWithBYE({\n  inContextDrawMatchUps,\n  tournamentRecord,\n  drawDefinition,\n  assignments,\n  matchUpsMap,\n  structure,\n  event,\n}) {\n  // remove the assignment that has a participantId\n  const originalByeAssignment = assignments.find(({ bye }) => bye);\n  const originalParticipantIdAssignment = assignments.find(\n    ({ participantId }) => participantId\n  );\n  const originalByeDrawPosition = originalByeAssignment.drawPosition;\n  const { participantId, drawPosition: originalParticipantIdDrawPosition } =\n    originalParticipantIdAssignment;\n  const { structureId } = structure;\n\n  // remove both drawPosition assignments\n  let result = removeDrawPositionAssignment({\n    drawPosition: originalByeDrawPosition,\n    inContextDrawMatchUps,\n    tournamentRecord,\n    drawDefinition,\n    structureId,\n    matchUpsMap,\n  });\n  if (result.error) return result;\n\n  result = removeDrawPositionAssignment({\n    drawPosition: originalParticipantIdDrawPosition,\n    inContextDrawMatchUps,\n    tournamentRecord,\n    drawDefinition,\n    structureId,\n    matchUpsMap,\n  });\n  if (result.error) return result;\n\n  assignDrawPositionBye({\n    drawPosition: originalParticipantIdDrawPosition,\n    tournamentRecord,\n    drawDefinition,\n    structureId,\n    matchUpsMap,\n    event,\n  });\n\n  // replace the original byeAssignment with participantId\n  result = assignDrawPosition({\n    drawPosition: originalByeDrawPosition,\n    inContextDrawMatchUps,\n    tournamentRecord,\n    drawDefinition,\n    structureId,\n    participantId,\n    matchUpsMap,\n    event,\n  });\n  if (result.error) return result;\n\n  return { ...SUCCESS };\n}\n\nfunction eliminationPosiitonSwap({\n  inContextDrawMatchUps,\n  tournamentRecord,\n  drawDefinition,\n  assignments,\n  matchUpsMap,\n  structure,\n  event,\n}) {\n  // preserves order of drawPositions in original positionAssignments array\n  // while insuring that all attributes are faithfully copied over and only drawPosition is swapped\n  const newAssignments = Object.assign(\n    {},\n    ...assignments.map((assignment, index) => {\n      const { drawPosition } = assignment;\n      const newAssignment = { ...assignments[1 - index], drawPosition };\n      return { [drawPosition]: newAssignment };\n    })\n  );\n\n  structure.positionAssignments = structure.positionAssignments.map(\n    (assignment) => newAssignments[assignment.drawPosition] || assignment\n  );\n\n  resetLineUps({\n    inContextDrawMatchUps,\n    tournamentRecord,\n    drawDefinition,\n    matchUpsMap,\n    assignments,\n    structure,\n    event,\n  });\n\n  return { ...SUCCESS };\n}\n\nfunction roundRobinSwap({\n  inContextDrawMatchUps,\n  tournamentRecord,\n  drawDefinition,\n  drawPositions,\n  matchUpsMap,\n  structure,\n  event,\n}) {\n  const assignments = structure.structures?.reduce((assignments, structure) => {\n    const structureAssignments = structure?.positionAssignments.filter(\n      (assignment) => drawPositions?.includes(assignment.drawPosition)\n    );\n    if (structureAssignments) assignments.push(...structureAssignments);\n    return assignments;\n  }, []);\n\n  // if both positions are BYE no need to do anything\n  if (assignments.filter(({ bye }) => bye).length === 2) return { ...SUCCESS };\n\n  // if both positions are QUALIFIER no need to do anything\n  if (assignments.filter(({ qualifier }) => qualifier).length === 2)\n    return { ...SUCCESS };\n\n  resetLineUps({\n    inContextDrawMatchUps,\n    tournamentRecord,\n    drawDefinition,\n    matchUpsMap,\n    assignments,\n    structure,\n    event,\n  });\n\n  const isQualifierSwap = assignments.some(({ qualifier }) => qualifier);\n  const isByeSwap = assignments.some(({ bye }) => bye);\n\n  if (isByeSwap && !isQualifierSwap) {\n    swapParticipantIdWithBYE({\n      inContextDrawMatchUps,\n      tournamentRecord,\n      drawDefinition,\n      assignments,\n      matchUpsMap,\n      structure,\n      event,\n    });\n  } else {\n    // for Round Robin the positionAssignments are distributed across structures\n    // so the strategy of creating a new positionAssignments array won't work\n    const originalAssignments = makeDeepCopy(assignments, false, true);\n    assignments.forEach((assignment, index) => {\n      const newParticipantId = originalAssignments[1 - index].participantId;\n      assignment.qualifier = originalAssignments[1 - index].qualifier;\n      assignment.participantId = newParticipantId;\n    });\n  }\n\n  return { ...SUCCESS };\n}\n","import { findStructure, getDrawStructures } from '../../acquire/findStructure';\n\nimport { DrawDefinition, Structure } from '../../types/tournamentTypes';\nimport {\n  MISSING_DRAW_DEFINITION,\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\ntype GetPlayoffStructuresArgs = {\n  drawDefinition: DrawDefinition;\n  structureId: string;\n};\n\nexport function getPlayoffStructures({\n  drawDefinition,\n  structureId,\n}: GetPlayoffStructuresArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const { structure } = findStructure({ drawDefinition, structureId });\n\n  const targetStructureIds = (drawDefinition?.links || [])\n    .filter((link) => link.source?.structureId === structureId)\n    .map((link) => link.target?.structureId);\n\n  const playoffStructures = (drawDefinition?.structures || []).filter(\n    (structure) => targetStructureIds.includes(structure.structureId)\n  );\n\n  return { playoffStructures, structure };\n}\n\nexport function getEventStructures({\n  withStageGrouping,\n  stageSequences,\n  stageSequence,\n  roundTarget,\n  stages,\n  event,\n  stage,\n}) {\n  if (!event) return { error: MISSING_EVENT };\n  const stageStructures = {};\n  const structures: Structure[] = [];\n\n  for (const drawDefinition of event.drawDefinitions || []) {\n    const { structures: drawStructures, stageStructures: drawStageStructures } =\n      getDrawStructures({\n        withStageGrouping,\n        stageSequences,\n        drawDefinition,\n        stageSequence,\n        roundTarget,\n        stages,\n        stage,\n      });\n\n    structures.push(...drawStructures);\n    if (drawStageStructures) {\n      for (const stage of Object.keys(drawStageStructures)) {\n        if (!stageStructures[stage]) stageStructures[stage] = [];\n        stageStructures[stage].push(...drawStageStructures[stage]);\n      }\n    }\n  }\n\n  return { structures, stageStructures };\n}\n\nexport function getTournamentStructures({\n  withStageGrouping,\n  tournamentRecord,\n  stageSequences,\n  stageSequence,\n  roundTarget,\n  stages,\n  stage,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  const stageStructures = {};\n  const structures: Structure[] = [];\n\n  for (const event of tournamentRecord.events || []) {\n    const {\n      structures: eventStructures,\n      stageStructures: eventStageStructures,\n    } = getEventStructures({\n      withStageGrouping,\n      stageSequences,\n      stageSequence,\n      roundTarget,\n      stages,\n      event,\n      stage,\n    });\n\n    if (eventStructures) structures.push(...eventStructures);\n    if (eventStageStructures) {\n      for (const stage of Object.keys(eventStageStructures)) {\n        if (!stageStructures[stage]) stageStructures[stage] = [];\n        stageStructures[stage].push(...eventStageStructures[stage]);\n      }\n    }\n  }\n\n  return { structures, stageStructures };\n}\n","import { getPlayoffStructures } from '../structure/structureGetter';\nimport { getStructureMatchUps } from '../structure/getStructureMatchUps';\nimport { getPositionAssignments } from './positionsGetter';\n\nimport { STRUCTURE_SELECTED_STATUSES } from '../../constants/entryStatusConstants';\nimport { MISSING_DRAW_DEFINITION } from '../../constants/errorConditionConstants';\nimport { DrawDefinition, Structure } from '../../types/tournamentTypes';\nimport { TEAM } from '../../constants/matchUpTypes';\n\ntype StructureActionsArgs = {\n  drawDefinition: DrawDefinition;\n  structureId: string;\n};\n\nexport function structureActions(params: StructureActionsArgs) {\n  const actions = [];\n  if (!params?.drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  const isComplete = isCompletedStructure(params);\n  const hasPlayoffPositionsFilled = allPlayoffPositionsFilled(params);\n  return { actions, state: { isComplete, hasPlayoffPositionsFilled } };\n}\n\ntype StructureQueryArgs = {\n  drawDefinition: DrawDefinition;\n  structure?: Structure;\n  structureId?: string;\n};\nexport function isCompletedStructure(params: StructureQueryArgs) {\n  if (!params?.drawDefinition) return false;\n  const structureMatchUps = getStructureMatchUps(params);\n\n  const includesTeamMatchUps = structureMatchUps?.includesTeamMatchUps;\n  let { completedMatchUps, pendingMatchUps, upcomingMatchUps } =\n    structureMatchUps || {};\n\n  if (includesTeamMatchUps) {\n    completedMatchUps = completedMatchUps?.filter(\n      ({ matchUpType }) => matchUpType === TEAM\n    );\n    pendingMatchUps = pendingMatchUps?.filter(\n      ({ matchUpType }) => matchUpType === TEAM\n    );\n    upcomingMatchUps = upcomingMatchUps?.filter(\n      ({ matchUpType }) => matchUpType === TEAM\n    );\n  }\n\n  const isComplete =\n    completedMatchUps?.length &&\n    !pendingMatchUps?.length &&\n    !upcomingMatchUps?.length;\n\n  return !!isComplete;\n}\n\nexport function allPlayoffPositionsFilled(params: StructureActionsArgs) {\n  const { drawDefinition, structureId } = params;\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const { playoffStructures } = getPlayoffStructures({\n    drawDefinition,\n    structureId,\n  });\n\n  if (!playoffStructures?.length) return false;\n\n  const enteredParticipantsCount =\n    drawDefinition?.entries?.filter(\n      (entry) =>\n        entry?.entryStatus &&\n        STRUCTURE_SELECTED_STATUSES.includes(entry.entryStatus)\n    )?.length ?? 0;\n\n  let participantIdsCount = 0;\n  const allPositionsFilled = (playoffStructures || []).reduce(\n    (allFilled, structure) => {\n      const positionAssignments =\n        getPositionAssignments({ structure }).positionAssignments ?? [];\n      const structurePositionsFilled = positionAssignments?.filter(\n        (assignment) => {\n          if (assignment.participantId) participantIdsCount++;\n          return assignment?.bye ?? assignment?.participantId;\n        }\n      ).length;\n      return !!(structurePositionsFilled && allFilled);\n    },\n    !!playoffStructures.length\n  );\n\n  // account for playoffStructure with only one participant\n  const allParticipantIdsPlaced =\n    participantIdsCount === enteredParticipantsCount;\n\n  return allPositionsFilled || allParticipantIdsPlaced;\n}\n","type ProcessAccessorsArgs = {\n  significantCharacters?: number;\n  accessors: string[];\n  value: any;\n};\n\nexport function processAccessors({\n  significantCharacters,\n  accessors = [],\n  value,\n}: ProcessAccessorsArgs): string[] {\n  const extractedValues: any[] = [];\n  const accessor = accessors[0];\n  if (value?.[accessor]) {\n    const remainingKeys = accessors.slice(1);\n    if (Array.isArray(value[accessor])) {\n      const values = value[accessor];\n      values.forEach((nestedValue) => {\n        const result = processAccessors({\n          accessors: remainingKeys,\n          significantCharacters,\n          value: nestedValue,\n        });\n        extractedValues.push(...result);\n      });\n    } else {\n      value = value[accessor];\n      if (remainingKeys.length) {\n        const result = processAccessors({\n          accessors: remainingKeys,\n          significantCharacters,\n          value,\n        });\n        extractedValues.push(...result);\n      } else {\n        checkValue({ value });\n      }\n    }\n  }\n\n  function checkValue({ value }) {\n    if (value && ['string', 'number'].includes(typeof value)) {\n      const extractedValue = significantCharacters\n        ? value.slice(0, significantCharacters)\n        : value;\n      extractedValues.push(extractedValue);\n    }\n  }\n  return extractedValues;\n}\n","import { processAccessors } from '../drawDefinition/processAccessors';\nimport { unique } from '../../utilities/arrays';\n\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { HydratedParticipant } from '../../types/hydrated';\nimport { IdCollections } from '../../types/factoryTypes';\nimport {\n  MISSING_PARTICIPANT,\n  MISSING_PARTICIPANTS,\n  MISSING_POLICY_ATTRIBUTES,\n} from '../../constants/errorConditionConstants';\n\n/**\n *\n * Each policyAttribute is a string definining how to access the nested participant attribute to be accessed\n * 'person.nationalityCode' targets => { participant: { person: { natinalityCode }}}\n *\n * If an attribute within a policyAttribute definition is an array then the function iterates over members of the array\n * The use case for this behavior is when a participant is a team and contains individualPatticipants: []\n * 'individualParticipants.person.nationalityCode' targets =>\n *  { participant: { individualParticipants: [ { person: { nationalityCode }}, { person: { nationalityCode }}]}}\n */\n\ntype GetAttributeGroupingsArgs = {\n  participants: HydratedParticipant[];\n  targetParticipantIds: string[];\n  idCollections?: IdCollections;\n  policyAttributes: any;\n};\nexport function getAttributeGroupings({\n  targetParticipantIds,\n  policyAttributes,\n  idCollections,\n  participants,\n}: GetAttributeGroupingsArgs): ResultType | { [key: string]: string[] } {\n  if (!Array.isArray(policyAttributes)) {\n    return { error: MISSING_POLICY_ATTRIBUTES };\n  }\n  if (!Array.isArray(participants)) {\n    return { error: MISSING_PARTICIPANTS };\n  }\n  const groupings = {};\n  targetParticipantIds.forEach((participantId) => {\n    const participant = participants.find(\n      (candidate) => candidate.participantId === participantId\n    );\n\n    const { values } = extractAttributeValues({\n      policyAttributes,\n      idCollections,\n      participants,\n      participant,\n    });\n    if (values) {\n      values.forEach((value) => {\n        if (!groupings[value]) groupings[value] = [];\n        if (!groupings[value].includes(participantId)) {\n          groupings[value].push(participantId);\n        }\n      });\n    }\n  });\n\n  return groupings;\n}\n\ntype ExtractAttributeValuesArgs = {\n  participants?: HydratedParticipant[];\n  participant?: HydratedParticipant;\n  idCollections?: IdCollections; // { [directive]: [participantId]}\n  policyAttributes: any;\n};\nexport function extractAttributeValues({\n  policyAttributes,\n  idCollections,\n  participants,\n  participant,\n}: ExtractAttributeValuesArgs) {\n  if (!Array.isArray(policyAttributes)) {\n    return { error: MISSING_POLICY_ATTRIBUTES };\n  }\n  if (!participant) {\n    return { error: MISSING_PARTICIPANT };\n  }\n  const extractedValues: string[] = [];\n  policyAttributes.forEach((policyAttribute) => {\n    const { directive, groupings, key, significantCharacters } =\n      policyAttribute || {};\n\n    if (key) {\n      const accessors = key.split('.');\n      extractedValues.push(\n        ...processAccessors({\n          significantCharacters,\n          value: participant,\n          accessors,\n        })\n      );\n    } else if (directive) {\n      // extractedValues are values to be avoided\n      // e.g. for { directive: 'pairParticipants' } the extractedValues would be [ 'partnerParticipantId' ]\n      const includeIds = policyAttribute?.includeIds;\n      const collectionIds = (idCollections?.[directive] || []).filter(\n        (participantId) => !includeIds || includeIds.includes(participantId)\n      );\n      if (collectionIds?.length && participants?.length) {\n        collectionIds.forEach((collectionParticipantId) => {\n          const collectionParticipant = participants.find(\n            (participant) =>\n              participant.participantId === collectionParticipantId\n          );\n          if (\n            collectionParticipant?.individualParticipantIds?.includes(\n              participant.participantId\n            )\n          ) {\n            const participantId = collectionParticipant?.participantId;\n            extractedValues.push(participantId);\n          }\n        });\n      }\n    } else if (groupings) {\n      Object.keys(groupings).forEach((key) => {\n        if (groupings[key].includes(participant.participantId)) {\n          extractedValues.push(key);\n        }\n      });\n    }\n  });\n\n  const values = unique(extractedValues);\n  return { values };\n}\n","import { extractAttributeValues } from '../../../../query/participants/getAttributeGrouping';\n\nexport function getPositionedParticipants({\n  candidatePositionAssignments,\n  participantsWithGroupings,\n  policyAttributes,\n  idCollections,\n}) {\n  const participantsMap = Object.assign(\n    {},\n    ...participantsWithGroupings.map((participant) => ({\n      [participant.participantId]: participant,\n    }))\n  );\n\n  return candidatePositionAssignments.map((assignment) => {\n    const participant = participantsMap[assignment.participantId];\n    const { values } = extractAttributeValues({\n      participants: participantsWithGroupings,\n      policyAttributes,\n      idCollections,\n      participant,\n    });\n    return { ...assignment, values };\n  });\n}\n","/**\n *\n * @param {string[]} allGroups - group names derived from participant attributes which match policyAttributes\n * @param {string[]} groupsToAvoid - names of groups which contain the participantId currently being placed\n * @param {object[]} positionAssignments - array of assignment objects { drawPosition, participantId }\n *\n */\nfunction getPositionProfiles({\n  participantIdGroups,\n  positionAssignments,\n  groupsToAvoid,\n}) {\n  return Object.assign(\n    {},\n    ...positionAssignments\n      .filter((assignment) => assignment?.participantId)\n      .map((assginment) => {\n        const { drawPosition, participantId } = assginment;\n        const participantGroups = participantIdGroups\n          ? participantIdGroups[participantId] || []\n          : [];\n\n        const includesGroupsToAvoid = !!groupsToAvoid.some((group) =>\n          participantGroups.includes(group)\n        );\n        return { [drawPosition]: { participantGroups, includesGroupsToAvoid } };\n      })\n  );\n}\n\n/**\n *\n * @param {string[]} allGroups - group names derived from participant attributes which match policyAttributes\n * @param {string[]} groupsToAvoid - names of groups which contain the participantId currently being placed\n * @param {number[]} unfilledPositions - drawPositions which have not been assigned a participantid\n * @param {object[]} positionAssignments - array of assignment objects { drawPosition, participantId }\n * @param {object[]} chunkedDrawPositions - array of arrays of drawPositions\n *\n * Returns different types of placement options.\n * 1. positions which are unassigned\n * 2. unassigned positions which are not paired with any other participantId\n * 3. unassigned positions which are paired and which have no conflicting groupings (groupings to avoid)\n *\n */\nexport function analyzeEliminationDrawPositions(params) {\n  const { unfilledPositions, chunkedDrawPositions } = params;\n  const profiledPositions = getPositionProfiles(params);\n\n  const checkedChunk = chunkedDrawPositions.map((chunkedGrouping) => {\n    const unassigned = unfilledPositions.filter((unfilledPosition) =>\n      chunkedGrouping.includes(unfilledPosition)\n    );\n    const unpaired = unpairedPositions(unassigned);\n    const paired = unassigned.filter(\n      (drawPosition) => !unpaired.includes(drawPosition)\n    );\n    const pairedNoConflict = paired.filter((drawPosition) => {\n      const pairedPosition = getPairedPosition(drawPosition);\n      return !profiledPositions[pairedPosition]?.includesGroupsToAvoid;\n    });\n    return { unassigned, unpaired, pairedNoConflict };\n  });\n\n  return checkedChunk;\n\n  function unpairedPositions(unassigned) {\n    return unassigned.filter((u) => !pairAssigned(u));\n\n    function pairAssigned(drawPosition) {\n      const pairedPosition = getPairedPosition(drawPosition);\n      return !unassigned.includes(pairedPosition);\n    }\n  }\n}\n\n/**\n *\n * @param {string[]} allGroups - group names derived from participant attributes which match policyAttributes\n * @param {string[]} groupsToAvoid - names of groups which contain the participantId currently being placed\n * @param {number[]} unfilledPositions - drawPositions which have not been assigned a participantid\n * @param {object[]} positionAssignments - array of assignment objects\n * @param {object[]} chunkedDrawPositions - array of arrays of drawPositions\n *\n * Returns different types of placement options.\n * 1. positions which are unassigned\n * 2. unassigned positions which are not paired with any other participantId\n * 3. unassigned positions which are paired and which have no conflicting groupings (groupings to avoid)\n *\n */\n\nexport function analyzeRoundRobinDrawPositions(params) {\n  const { unfilledPositions, chunkedDrawPositions } = params;\n  const profiledPositions = getPositionProfiles(params);\n\n  return chunkedDrawPositions.map((chunkedGrouping) => {\n    const unassigned = unfilledPositions.filter((unfilledPosition) =>\n      chunkedGrouping.includes(unfilledPosition)\n    );\n    const unpaired =\n      unassigned.length === chunkedGrouping.length ? unassigned : [];\n    const conflictsCount = chunkedGrouping.filter(\n      (drawPosition) => profiledPositions[drawPosition]?.includesGroupsToAvoid\n    ).length;\n    const pairedNoConflict = conflictsCount ? [] : unassigned;\n    return { unassigned, unpaired, pairedNoConflict, conflictsCount };\n  });\n}\n\n/**\n *\n * @param {string} drawPosition\n *\n * Returns paired position for first round matches in elimination structures\n */\nfunction getPairedPosition(drawPosition) {\n  return Number(drawPosition % 2 ? drawPosition + 1 : drawPosition - 1);\n}\n\n/**\n *\n * @param {sring[]} allGroups - array of group names (attribute values) for all groups under consideration\n * @param {string} participantId - ID of the participant in question\n *\n * Returns the group name for all groups including participantid\n *\n */\nexport function getParticipantGroups({ allGroups, participantId }) {\n  return Object.keys(allGroups).filter((key) =>\n    allGroups[key].includes(participantId)\n  );\n}\n","import {\n  analyzeEliminationDrawPositions,\n  analyzeRoundRobinDrawPositions,\n} from './analyzeDrawPositions';\n\n/**\n *\n * @param {string[]} allGroups - group names derived from participant attributes which match policyAttributes\n * @param {number[]} unfilledPositions - drawPositions which have not been assigned a participantid\n * @param {object[]} drawPositionChunks - ranges of drawPositions grouped by levels of separation\n * @param {object[]} positionAssignments - array of assignment objects\n * @param {boolean} isRoundRobin - use round robin draw position analysis\n * @param {string[]} selectedParticipantGroups - names of groups which contain the participantId currently being placed\n *\n * Returns different types of placement options.\n * Similar to analyzeDraawPositions, but aggregates options.\n * Options are arranged from largest to smallest chunk sizes.\n * To achieve maximum separation start with largest chunk sizes.\n *\n * 1. positions which are unassigned\n * 2. unassigned positions which are not paired with any other participantId\n * 3. unassigned positions which are paired and which have no conflicting groupings (groupings to avoid)\n *\n */\nexport function organizeDrawPositionOptions({\n  selectedParticipantGroups,\n  participantIdGroups,\n  positionAssignments,\n  drawPositionChunks,\n  unfilledPositions,\n  isRoundRobin,\n}) {\n  const vettedChunks = drawPositionChunks.map((chunkedDrawPositions) => {\n    if (isRoundRobin) {\n      return analyzeRoundRobinDrawPositions({\n        groupsToAvoid: selectedParticipantGroups,\n        chunkedDrawPositions,\n        participantIdGroups,\n        positionAssignments,\n        unfilledPositions,\n      });\n    } else {\n      return analyzeEliminationDrawPositions({\n        groupsToAvoid: selectedParticipantGroups,\n        chunkedDrawPositions,\n        participantIdGroups,\n        positionAssignments,\n        unfilledPositions,\n      });\n    }\n  });\n\n  // each type of vettedChunk is first extracted and filtered...\n  // ...then combined with others of the same type and filtered\n  if (isRoundRobin) {\n    const unassigned = vettedChunks\n      .map((chunk) =>\n        chunk\n          .map((grouping) => grouping.unassigned)\n          .filter((unassigned) => unassigned?.length)\n      )\n      .filter((f) => f?.length)\n      .sort((a, b) => (b.length || 0) - (a.length || 0));\n    const unpaired = vettedChunks\n      .map((chunk) =>\n        chunk\n          .map((grouping) => grouping.unpaired)\n          .filter((unpaired) => unpaired?.length)\n      )\n      .filter((f) => f?.length);\n    const pairedNoConflict = vettedChunks\n      .map((chunk) =>\n        chunk\n          .map((grouping) => grouping.pairedNoConflict)\n          .filter((pairedNoConflict) => pairedNoConflict?.length)\n      )\n      .filter((f) => f?.length)\n      .sort((a, b) => (b.length || 0) - (a.length || 0));\n    return { unassigned, unpaired, pairedNoConflict };\n  } else {\n    const unassigned = vettedChunks\n      .map((chunk) =>\n        chunk\n          .map((grouping) => grouping.unassigned)\n          .filter((unassigned) => unassigned?.length)\n      )\n      .filter((f) => f?.length);\n    const unpaired = vettedChunks\n      .map((chunk) =>\n        chunk\n          .map((grouping) => grouping.unpaired)\n          .filter((unpaired) => unpaired?.length)\n      )\n      .filter((f) => f?.length);\n    const pairedNoConflict = vettedChunks\n      .map((chunk) =>\n        chunk\n          .map((grouping) => grouping.pairedNoConflict)\n          .filter((pairedNoConflict) => pairedNoConflict?.length)\n      )\n      .filter((f) => f?.length);\n\n    return { unassigned, unpaired, pairedNoConflict };\n  }\n}\n","import { PositionAssignment } from '../../../../types/tournamentTypes';\n\ntype GetUnplaced = {\n  positionAssignments: PositionAssignment[];\n  participantIds: string[];\n};\n\nexport function getUnplacedParticipantIds({\n  positionAssignments,\n  participantIds,\n}: GetUnplaced) {\n  const assignedParticipantIds = positionAssignments.map(\n    (assignment) => assignment.participantId\n  );\n  return participantIds.filter(\n    (participantId) => !assignedParticipantIds.includes(participantId)\n  );\n}\n","import { organizeDrawPositionOptions } from './organizeDrawPositionOptions';\nimport { PositionAssignment } from '../../../../types/tournamentTypes';\nimport { getUnplacedParticipantIds } from './getUnplacedParticipantIds';\nimport { getParticipantGroups } from './analyzeDrawPositions';\nimport { getNextParticipantId } from './getNextParticipantId';\nimport { getUnfilledPositions } from './getUnfilledPositions';\nimport { randomPop } from '../../../../utilities/arrays';\n\ntype GetParticipantPlacementArgs = {\n  candidatePositionAssignments: PositionAssignment[];\n  participantIdGroups?: { [key: string]: string[] };\n  drawPositionGroups: [number, number][]; // drawPositions paird with their initial round opponent drawPosition\n  allGroups: { [key: string]: any }; // map of values and participantIds which have those values\n  unseededParticipantIds: string[];\n  drawPositionChunks?: number[][]; // drawPositions grouped by round starting with the final round\n  pairedPriority?: boolean; // flag whether to prioritize positions which already have one opponent placed\n  groupKey: string;\n};\n\nexport function getParticipantPlacement({\n  candidatePositionAssignments,\n  unseededParticipantIds,\n  participantIdGroups,\n  drawPositionChunks,\n  drawPositionGroups,\n  pairedPriority,\n  allGroups,\n  groupKey,\n}: GetParticipantPlacementArgs) {\n  const largestGroupSize = drawPositionGroups.reduce((largest, group) => {\n    return group.length > largest ? group.length : largest;\n  }, 0);\n  const useSpecifiedGroupKey = largestGroupSize <= 2;\n\n  const targetParticipantIds = getUnplacedParticipantIds({\n    positionAssignments: candidatePositionAssignments,\n    participantIds: unseededParticipantIds,\n  });\n\n  const unfilledPositions = getUnfilledPositions({\n    positionAssignments: candidatePositionAssignments,\n    drawPositionGroups,\n  });\n\n  const { participantId: selectedParticipantId, groupKey: newGroupKey } =\n    getNextParticipantId({\n      targetParticipantIds,\n      useSpecifiedGroupKey,\n      allGroups,\n      groupKey,\n    });\n\n  const selectedParticipantGroups = getParticipantGroups({\n    participantId: selectedParticipantId,\n    allGroups,\n  });\n\n  const drawPositionOptions = organizeDrawPositionOptions({\n    positionAssignments: candidatePositionAssignments,\n    isRoundRobin: useSpecifiedGroupKey,\n    selectedParticipantGroups,\n    participantIdGroups,\n    drawPositionChunks,\n    unfilledPositions,\n  });\n  const { unassigned, unpaired, pairedNoConflict } = drawPositionOptions;\n\n  // the first element of each options array represents the greatest possible round separation\n  const pnc = pairedNoConflict?.length && pairedNoConflict[0];\n  const up = unpaired?.length && unpaired[0];\n  const desiredOptions = pairedPriority && pnc ? pnc : up;\n  const fallbackOptions = pairedPriority ? up : pnc;\n\n  const prioritizedOptions =\n    (desiredOptions?.length && desiredOptions) ||\n    (fallbackOptions?.length && fallbackOptions);\n\n  let targetDrawPosition;\n  if (prioritizedOptions?.length) {\n    const section = randomPop(prioritizedOptions);\n    targetDrawPosition = randomPop(section);\n  } else {\n    const section = randomPop(unassigned[0]);\n    targetDrawPosition = randomPop(section);\n  }\n\n  return { newGroupKey, selectedParticipantId, targetDrawPosition };\n}\n","/**\n *\n * @param {object[]} matchUps\n * @param {object[]} positionAssignments - assignment objects which associate drawPositions with participantIds\n *\n * Returns an array of drawPositions which have not been filled\n */\n\nexport function getUnfilledPositions({\n  drawPositionGroups,\n  positionAssignments,\n}) {\n  const assignmentMap = Object.assign(\n    {},\n    ...positionAssignments.map((assignment) => ({\n      [assignment.drawPosition]: assignment,\n    }))\n  );\n\n  return drawPositionGroups\n    .map((drawPositions) => {\n      return drawPositions\n        .filter(Boolean)\n        .map((drawPosition) => assignmentMap[drawPosition])\n        .filter(Boolean)\n        .filter((assignment) => !assignment.participantId && !assignment.bye)\n        .map((assignment) => assignment.drawPosition);\n    })\n    .flat()\n    .filter(Boolean);\n}\n","import { randomMember } from '../../../../utilities/arrays';\n\ntype GetNextParticipantId = {\n  allGroups: { [key: string]: string[] };\n  targetParticipantIds: string[];\n  useSpecifiedGroupKey?: boolean;\n  largestFirst?: boolean;\n  groupKey: string;\n};\n\nexport function getNextParticipantId({\n  useSpecifiedGroupKey = false,\n  targetParticipantIds,\n  largestFirst = true,\n  allGroups,\n  groupKey,\n}: GetNextParticipantId): { participantId: string; groupKey: string } {\n  const groupings = Object.assign(\n    {},\n    ...Object.keys(allGroups)\n      .map((group) => [\n        group,\n        allGroups[group].filter((id) => targetParticipantIds.includes(id)),\n      ])\n      .filter((item) => item[1].length)\n      .map(([group, ids]) => ({ [group as string]: ids }))\n  );\n\n  const largestGroupSize = Object.keys(groupings).reduce(\n    (size, key) =>\n      groupings[key].length > size ? groupings[key].length : size,\n    0\n  );\n  const largestSizedGroupings = Object.keys(groupings).filter(\n    (key) => groupings[key].length === largestGroupSize\n  );\n\n  const randomGroupKey = largestFirst\n    ? randomMember(largestSizedGroupings)\n    : randomMember(Object.keys(groupings));\n\n  groupKey =\n    useSpecifiedGroupKey && groupings[groupKey]?.length\n      ? groupKey\n      : randomGroupKey;\n\n  const participantId =\n    groupKey && groupings[groupKey]\n      ? randomMember(groupings[groupKey])\n      : randomMember(targetParticipantIds);\n  return { participantId, groupKey };\n}\n","import { getRoundRobinGroupMatchUps } from '../../../../assemblies/generators/drawDefinitions/drawTypes/roundRobin/roundRobinGroups';\nimport { overlap } from '../../../../utilities/arrays';\n\nexport function getAvoidanceConflicts({ isRoundRobin, groupedParticipants }) {\n  const avoidanceConflicts: any[] = [];\n  if (isRoundRobin) {\n    groupedParticipants.forEach((participantGroup) => {\n      const drawPositions = participantGroup.map(\n        (participant) => participant.drawPosition\n      );\n      const { uniqueMatchUpGroupings } = getRoundRobinGroupMatchUps({\n        drawPositions,\n      });\n      const drawPositionValuesMap = Object.assign(\n        {},\n        ...participantGroup.map((participant) => ({\n          [participant.drawPosition]: participant,\n        }))\n      );\n      uniqueMatchUpGroupings.forEach((grouping) => {\n        const avoidanceConflict = overlap(\n          drawPositionValuesMap[grouping[0]].values || [],\n          drawPositionValuesMap[grouping[1]].values || []\n        );\n\n        if (avoidanceConflict) {\n          avoidanceConflicts.push(grouping);\n          participantGroup.conflict = true;\n        }\n      });\n    });\n  } else {\n    groupedParticipants.forEach((matchUpPair) => {\n      const avoidanceConflict = overlap(\n        matchUpPair[0]?.values || [],\n        matchUpPair[1]?.values || []\n      );\n\n      if (avoidanceConflict) {\n        avoidanceConflicts.push(matchUpPair);\n        matchUpPair.conflict = true;\n      }\n    });\n  }\n\n  return avoidanceConflicts;\n}\n","import { getAvoidanceConflicts } from './getAvoidanceConflicts';\n\nexport function getSwapOptions({\n  positionedParticipants,\n  potentialDrawPositions,\n  drawPositionGroups,\n  avoidanceConflicts,\n  isRoundRobin,\n}) {\n  return avoidanceConflicts\n    .map((conflict) => {\n      const drawPositions = conflict.map((c) => c.drawPosition);\n      const moveableParticipants = conflict.filter((placedParticipant) =>\n        potentialDrawPositions.includes(placedParticipant.drawPosition)\n      );\n      return moveableParticipants\n        .map((moveableParticipant) => {\n          const possibleDrawPositions = potentialDrawPositions.filter(\n            (position) => !drawPositions?.includes(position)\n          );\n\n          const possibleDrawPositionsNoConflict = possibleDrawPositions.filter(\n            (possibleDrawPosition) => {\n              const potentialOpponentDrawPosition = drawPositionGroups\n                .find((pair) => pair.includes(possibleDrawPosition))\n                .find((drawPosition) => drawPosition !== possibleDrawPosition);\n              const potentialOpponent = positionedParticipants.find(\n                (placement) =>\n                  placement.drawPosition === potentialOpponentDrawPosition\n              );\n              const possibleDrawPositionGroup = [\n                moveableParticipant,\n                potentialOpponent,\n              ];\n              const conflictPotential = getAvoidanceConflicts({\n                isRoundRobin,\n                groupedParticipants: [possibleDrawPositionGroup],\n              });\n              const swappedParticipant = positionedParticipants.find(\n                (placement) => placement.drawPosition === possibleDrawPosition\n              );\n              const possibleExistingOpponentGroup = [\n                swappedParticipant,\n                potentialOpponent,\n              ];\n              const existingOpponentConflictPotential = getAvoidanceConflicts({\n                isRoundRobin,\n                groupedParticipants: [possibleExistingOpponentGroup],\n              });\n              return (\n                !conflictPotential.length &&\n                !existingOpponentConflictPotential.length\n              );\n            }\n          );\n\n          if (possibleDrawPositionsNoConflict.length) {\n            return {\n              drawPosition: moveableParticipant.drawPosition,\n              possibleDrawPositions: possibleDrawPositionsNoConflict,\n            };\n          }\n\n          return undefined;\n        })\n        .filter(Boolean);\n    })\n    .flat(1);\n}\n","import { getPositionedParticipants } from './getPositionedParticipants';\nimport { getParticipantPlacement } from './getParticipantPlacement';\nimport { makeDeepCopy } from '../../../../utilities/makeDeepCopy';\nimport { getAvoidanceConflicts } from './getAvoidanceConflicts';\nimport { getSwapOptions } from './getSwapOptions';\nimport {\n  chunkArray,\n  generateRange,\n  randomPop,\n} from '../../../../utilities/arrays';\n\nimport { INVALID_ASSIGNMENT } from '../../../../constants/errorConditionConstants';\nimport { PositionAssignment } from '../../../../types/tournamentTypes';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport { IdCollections } from '../../../../types/factoryTypes';\n\ntype GeneratePositioningCandidateArgs = {\n  participantIdGroups?: { [key: string]: string[] };\n  initialPositionAssignments: PositionAssignment[]; // positionAssignments before any new participants placed\n  policyAttributes?: { [key: string]: any }[];\n  drawPositionGroups: [number, number][]; // drawPositions paird with their initial round opponent drawPosition\n  unseededParticipantIds: string[];\n  allGroups: { [key: string]: any }; // map of values and participantIds which have those values\n  unseededByePositions?: number[];\n  drawPositionChunks?: number[][]; // drawPositions grouped by round starting with the final round\n  participantsWithGroupings: any; //  participants with added team/group/pair participantIds arrays\n  opponentsToPlaceCount: number;\n  idCollections: IdCollections;\n  pairedPriority?: boolean; // flag whether to prioritize positions which already have one opponent placed\n  drawSize?: number;\n};\n\nexport function generatePositioningCandidate(\n  params: GeneratePositioningCandidateArgs\n) {\n  const {\n    initialPositionAssignments,\n    participantsWithGroupings,\n    opponentsToPlaceCount,\n    unseededByePositions,\n    drawPositionGroups,\n    policyAttributes,\n    idCollections,\n    allGroups,\n  } = params;\n\n  const errors: any[] = [];\n  let groupKey;\n\n  const groupSize = Math.min(\n    ...(drawPositionGroups || []).map((dpg) => dpg?.length).filter(Boolean)\n  );\n  const isRoundRobin = groupSize > 2;\n\n  const candidatePositionAssignments = makeDeepCopy(\n    initialPositionAssignments,\n    false,\n    true\n  ).filter((assignment) => !assignment.qualifier);\n\n  // all drawPositions which are available for placement\n  const potentialDrawPositions = initialPositionAssignments\n    .filter(\n      (assignment) =>\n        !assignment.participantId &&\n        (!assignment.bye ||\n          unseededByePositions?.includes(assignment.drawPosition))\n    )\n    .map((assignment) => assignment.drawPosition);\n\n  generateRange(0, opponentsToPlaceCount).forEach(() => {\n    const { newGroupKey, selectedParticipantId, targetDrawPosition } =\n      getParticipantPlacement({\n        ...params,\n        candidatePositionAssignments,\n        allGroups,\n        groupKey,\n      });\n    groupKey = newGroupKey;\n\n    candidatePositionAssignments.forEach((assignment) => {\n      if (assignment.drawPosition === targetDrawPosition) {\n        assignment.participantId = selectedParticipantId;\n      }\n    });\n  });\n\n  let positionedParticipants = getPositionedParticipants({\n    candidatePositionAssignments,\n    participantsWithGroupings,\n    policyAttributes,\n    idCollections,\n  });\n\n  let groupedParticipants = chunkArray(positionedParticipants, groupSize);\n  let avoidanceConflicts = getAvoidanceConflicts({\n    groupedParticipants,\n    isRoundRobin,\n  });\n\n  let attempts = 0;\n  while (attempts < 20 && avoidanceConflicts.length) {\n    const swapOptions = getSwapOptions({\n      positionedParticipants,\n      potentialDrawPositions,\n      avoidanceConflicts,\n      drawPositionGroups,\n      isRoundRobin,\n    });\n    if (swapOptions.length) {\n      const result = swapAssignedPositions({\n        candidatePositionAssignments,\n        swapOptions,\n      });\n      if (result.error) console.log({ result });\n\n      positionedParticipants = getPositionedParticipants({\n        candidatePositionAssignments,\n        participantsWithGroupings,\n        policyAttributes,\n        idCollections,\n      });\n\n      groupedParticipants = chunkArray(positionedParticipants, groupSize);\n      avoidanceConflicts = getAvoidanceConflicts({\n        groupedParticipants,\n        isRoundRobin,\n      });\n      attempts++;\n    } else {\n      attempts = 20;\n    }\n  }\n\n  candidatePositionAssignments.forEach((assignment) => {\n    // TODO: Investigate this scenario\n    if (assignment.bye && assignment.participantId) {\n      const error = INVALID_ASSIGNMENT;\n      errors.push(error);\n    }\n    if (assignment.qualifier && assignment.participantId) {\n      const error = INVALID_ASSIGNMENT;\n      errors.push(error);\n    }\n  });\n\n  return {\n    positionAssignments: candidatePositionAssignments,\n    conflicts: avoidanceConflicts.length,\n    groupedParticipants,\n    errors,\n  };\n}\n\nexport function swapAssignedPositions({\n  candidatePositionAssignments,\n  swapOptions,\n}) {\n  const swapOption = randomPop(swapOptions);\n  if (!swapOption) return { error: { message: 'No swap options' } };\n\n  const firstPosition = swapOption.drawPosition;\n  const secondPosition = randomPop(swapOption.possibleDrawPositions);\n  const firstAssignment = candidatePositionAssignments.find(\n    (assignment) => assignment.drawPosition === firstPosition\n  );\n  const secondAssignment =\n    candidatePositionAssignments.find(\n      (assignment) => assignment.drawPosition === secondPosition\n    ) ?? {};\n\n  const updatedFirstAssignmentAttributes = {\n    participantId: secondAssignment?.participantId,\n    qualifier: secondAssignment?.qualifier,\n    bye: secondAssignment?.bye,\n  };\n  const updatedSecondAssignmentAttributes = {\n    participantId: firstAssignment.participantId,\n    qualifier: firstAssignment.qualifier,\n    bye: firstAssignment.bye,\n  };\n\n  Object.assign(firstAssignment, updatedFirstAssignmentAttributes);\n  Object.assign(secondAssignment, updatedSecondAssignmentAttributes);\n\n  return { ...SUCCESS };\n}\n","import { getAllStructureMatchUps } from '../../../../query/matchUps/getAllStructureMatchUps';\nimport { assignDrawPositionBye } from '../../../matchUps/drawPositions/assignDrawPositionBye';\nimport { assignDrawPosition } from '../../../matchUps/drawPositions/positionAssignment';\nimport { getAttributeGroupings } from '../../../../query/participants/getAttributeGrouping';\nimport { generatePositioningCandidate } from './generatePositioningCandidate';\nimport { decorateResult } from '../../../../global/functions/decorateResult';\nimport { chunkArray, generateRange } from '../../../../utilities/arrays';\nimport { getUnplacedParticipantIds } from './getUnplacedParticipantIds';\nimport { addParticipantGroupings } from './addParticipantGroupings';\nimport { findStructure } from '../../../../acquire/findStructure';\nimport { numericSort } from '../../../../utilities/sorting';\nimport {\n  getPositionAssignments,\n  structureAssignedDrawPositions,\n} from '../../../../query/drawDefinition/positionsGetter';\nimport {\n  deriveExponent,\n  isPowerOf2,\n  nearestPowerOf2,\n} from '../../../../utilities/math';\n\nimport { GROUP, PAIR, TEAM } from '../../../../constants/participantConstants';\nimport { MatchUpsMap } from '../../../../query/matchUps/getMatchUpsMap';\nimport { CONTAINER } from '../../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport { IdCollections } from '../../../../types/factoryTypes';\nimport {\n  INSUFFICIENT_DRAW_POSITIONS,\n  MISSING_AVOIDANCE_POLICY,\n  NO_CANDIDATES,\n} from '../../../../constants/errorConditionConstants';\nimport {\n  HydratedMatchUp,\n  HydratedParticipant,\n} from '../../../../types/hydrated';\nimport {\n  DrawDefinition,\n  Event,\n  Tournament,\n} from '../../../../types/tournamentTypes';\n\ntype RandomUnseededDistribution = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  participants: HydratedParticipant[];\n  provisionalPositioning?: boolean;\n  unseededParticipantIds: string[];\n  unseededByePositions: number[];\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  seedBlockInfo?: any;\n  structureId: string;\n  drawSize: number;\n  avoidance?: any;\n  entries?: any;\n  event?: Event;\n};\nexport function randomUnseededSeparation({\n  provisionalPositioning,\n  unseededParticipantIds,\n  inContextDrawMatchUps,\n  unseededByePositions,\n  tournamentRecord,\n  drawDefinition,\n  seedBlockInfo,\n  participants,\n  matchUpsMap,\n  structureId,\n  avoidance,\n  drawSize,\n  // entries, // entries for the specific stage of drawDefinition\n  event,\n}: RandomUnseededDistribution) {\n  if (!avoidance) {\n    return { error: MISSING_AVOIDANCE_POLICY };\n  }\n  const { candidatesCount = 1, policyAttributes, targetDivisions } = avoidance;\n  let { roundsToSeparate } = avoidance;\n\n  const stack = 'randomUnseededSeparation';\n\n  // policyAttributes determines participant attributes which are to be used for avoidance\n  // roundsToSeparate determines desired degree of separation between players with matching attribute values\n  // targetDivisions derives roundsToSeparate from the number of rounds\n\n  const { structure } = findStructure({ drawDefinition, structureId });\n  const { matchUps } = getAllStructureMatchUps({\n    provisionalPositioning,\n    matchUpsMap,\n    structure,\n    event,\n  });\n\n  if (targetDivisions && isPowerOf2(targetDivisions) && !roundsToSeparate) {\n    const exponent: number = deriveExponent(targetDivisions) || 0;\n    const roundsCount = matchUps.reduce(\n      (count, matchUp) =>\n        matchUp.roundNumber > count ? matchUp.roundNumber : count,\n      0\n    );\n    roundsToSeparate = roundsCount < exponent ? 1 : roundsCount - exponent + 1;\n  }\n\n  const { positionAssignments } = structureAssignedDrawPositions({ structure });\n  const participantsWithGroupings = addParticipantGroupings({\n    participantsProfile: { convertExtensions: true },\n    deepCopy: false,\n    participants,\n  }).participantsWithGroupings;\n\n  const unassignedPositions = positionAssignments?.filter(\n    (assignment) => !assignment.participantId\n  );\n\n  const allDrawPositions = positionAssignments?.map(\n    (assignment) => assignment.drawPosition\n  );\n\n  const isRoundRobin = structure?.structureType === CONTAINER;\n\n  const params = isRoundRobin\n    ? { structure, matchUps, allDrawPositions, roundsToSeparate }\n    : { matchUps, allDrawPositions, roundsToSeparate };\n\n  const { drawPositionGroups, drawPositionChunks } = isRoundRobin\n    ? roundRobinParticipantGroups(params)\n    : eliminationParticipantGroups(params);\n\n  const idCollections: IdCollections = {\n    groupParticipants: participants\n      .filter((participant) => participant.participantType === GROUP)\n      .map((participant) => participant.participantId),\n    teamParticipants: participants\n      .filter((participant) => participant.participantType === TEAM)\n      .map((participant) => participant.participantId),\n    pairParticipants: participants\n      .filter((participant) => participant.participantType === PAIR)\n      .map((participant) => participant.participantId),\n  };\n\n  const allGroups = getAttributeGroupings({\n    targetParticipantIds: unseededParticipantIds,\n    policyAttributes,\n    idCollections,\n    participants,\n  });\n\n  if (allGroups.error) {\n    return decorateResult({ result: allGroups, stack });\n  }\n\n  const participantIdGroups = Object.assign(\n    {},\n    ...unseededParticipantIds.map((participantId) => {\n      const groups = Object.keys(allGroups).filter((key) =>\n        (allGroups[key] ?? []).includes(participantId)\n      );\n      return { [participantId]: groups };\n    })\n  );\n\n  const unplacedParticipantIds = getUnplacedParticipantIds({\n    participantIds: unseededParticipantIds,\n    positionAssignments,\n  });\n\n  if (unplacedParticipantIds.length > (unassignedPositions?.length || 0)) {\n    return { error: INSUFFICIENT_DRAW_POSITIONS };\n  }\n\n  let candidate;\n  const opponentsToPlaceCount = unplacedParticipantIds.length;\n\n  const noPairPriorityCandidates = generateRange(0, candidatesCount).map(() =>\n    generatePositioningCandidate({\n      initialPositionAssignments: positionAssignments,\n      participantsWithGroupings,\n      unseededParticipantIds,\n      opponentsToPlaceCount,\n      pairedPriority: false,\n      unseededByePositions,\n      participantIdGroups,\n      drawPositionChunks,\n      drawPositionGroups,\n      policyAttributes,\n      idCollections,\n      allGroups,\n      drawSize,\n    })\n  );\n\n  candidate = noPairPriorityCandidates.reduce(\n    (p: any, c) => (!p || (c.conflicts || 0) < (p.conflicts || 0) ? c : p),\n    undefined\n  );\n\n  if (!candidate || candidate.conflicts) {\n    const pairedPriorityCandidates = generateRange(0, candidatesCount).map(() =>\n      generatePositioningCandidate({\n        initialPositionAssignments: positionAssignments,\n        participantsWithGroupings,\n        unseededParticipantIds,\n        opponentsToPlaceCount,\n        pairedPriority: true,\n        unseededByePositions,\n        participantIdGroups,\n        drawPositionChunks,\n        drawPositionGroups,\n        policyAttributes,\n        idCollections,\n        allGroups,\n        drawSize,\n        // entries,\n      })\n    );\n\n    const candidates = noPairPriorityCandidates\n      .concat(...pairedPriorityCandidates)\n      .filter((candidate) => !candidate.errors?.length);\n\n    candidate = candidates.reduce(\n      (p: any, c) => (!p || (c.conflicts || 0) < (p.conflicts || 0) ? c : p),\n      undefined\n    );\n  }\n\n  if (!candidate) return { error: NO_CANDIDATES };\n\n  const alreadyAssignedParticipantIds = (\n    getPositionAssignments({ structure })?.positionAssignments ?? []\n  )\n    .filter((assignment) => assignment.participantId)\n    .map((assignment) => assignment.participantId);\n\n  const filteredAssignments = candidate.positionAssignments.filter(\n    (assignment) =>\n      !alreadyAssignedParticipantIds.includes(assignment.participantId)\n  );\n\n  for (const assignment of filteredAssignments) {\n    if (assignment.bye) {\n      const result = assignDrawPositionBye({\n        tournamentRecord,\n        drawDefinition,\n        seedBlockInfo,\n        structureId,\n        matchUpsMap,\n        event,\n        ...assignment,\n      });\n      if (result.error) return decorateResult({ result, stack });\n    } else if (assignment.participantId) {\n      const result = assignDrawPosition({\n        automaticPlacement: true,\n        inContextDrawMatchUps,\n        tournamentRecord,\n        drawDefinition,\n        seedBlockInfo,\n        structureId,\n        matchUpsMap,\n        event,\n        ...assignment,\n      });\n\n      if (result.error) {\n        return decorateResult({ result, stack, context: { assignment } });\n      }\n    }\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction roundRobinParticipantGroups(params) {\n  const {\n    structure: { structures },\n  } = params;\n  const drawPositionGroups = structures.map((structure) =>\n    structure.positionAssignments.map((assignment) => assignment.drawPosition)\n  );\n  return { drawPositionGroups, drawPositionChunks: [drawPositionGroups] };\n}\n\nfunction eliminationParticipantGroups({\n  allDrawPositions,\n  roundsToSeparate,\n  matchUps,\n}) {\n  const drawPositionPairs = matchUps\n    .filter((matchUp) => matchUp.roundNumber === 1)\n    .map((matchUp) => matchUp.drawPositions);\n  const firstRoundMatchUpDrawPositions = drawPositionPairs\n    .flat()\n    .sort(numericSort);\n  const greatestFirstRoundDrawPosition = Math.max(\n    ...firstRoundMatchUpDrawPositions\n  );\n  const fedDrawPositions = allDrawPositions.filter(\n    (drawPositon) => drawPositon > greatestFirstRoundDrawPosition\n  );\n\n  const structureSize = firstRoundMatchUpDrawPositions.length;\n  const rangeStart = structureSize === 2 ? 1 : 2;\n  const roundSizes = generateRange(rangeStart, structureSize).filter(\n    (f) => f === nearestPowerOf2(f)\n  );\n\n  const chunkSizes = roundSizes\n    .slice(0, roundsToSeparate || roundSizes.length)\n    .reverse();\n  const drawPositionChunks = chunkSizes.map((size) =>\n    chunkArray(firstRoundMatchUpDrawPositions, size)\n  );\n\n  if (fedDrawPositions.length) {\n    // TODO: calculate chunking for fed drawPositions and add to appropriate drawPositionChunks\n    // This calculation will be based on \"{ roundPosition, roundNumber } = matchUp\"\n    // ...for matchUps which include fedDrawPositions\n    console.log({ fedDrawPositions });\n  }\n\n  return { drawPositionGroups: drawPositionPairs, drawPositionChunks };\n}\n","import { randomUnseededSeparation } from '../../drawDefinitions/positionGovernor/avoidance/randomUnseededSeparation';\nimport { getStructureSeedAssignments } from '../../../query/structure/getStructureSeedAssignments';\nimport { structureAssignedDrawPositions } from '../../../query/drawDefinition/positionsGetter';\nimport { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { getStageEntries } from '../../../query/drawDefinition/stageGetter';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { findExtension } from '../../../acquire/findExtension';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { assignDrawPosition } from './positionAssignment';\nimport { shuffleArray } from '../../../utilities/arrays';\n\nimport { INSUFFICIENT_DRAW_POSITIONS } from '../../../constants/errorConditionConstants';\nimport { DIRECT_ENTRY_STATUSES } from '../../../constants/entryStatusConstants';\nimport { POLICY_TYPE_AVOIDANCE } from '../../../constants/policyConstants';\nimport { ROUND_TARGET } from '../../../constants/extensionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  PLAY_OFF,\n  QUALIFYING,\n} from '../../../constants/drawDefinitionConstants';\n\nexport function positionUnseededParticipants({\n  provisionalPositioning,\n  inContextDrawMatchUps,\n  unseededByePositions,\n  multipleStructures,\n  tournamentRecord,\n  drawDefinition,\n  seedBlockInfo,\n  participants,\n  matchUpsMap,\n  structureId,\n  structure,\n  drawSize,\n  event,\n}) {\n  const stack = 'positionUnseededParticipants';\n\n  if (!structure)\n    ({ structure } = findStructure({ drawDefinition, structureId }));\n  if (!structureId) ({ structureId } = structure);\n\n  const { positionAssignments } = structureAssignedDrawPositions({ structure });\n  const { seedAssignments } = getStructureSeedAssignments({\n    provisionalPositioning,\n    drawDefinition,\n    structure,\n  });\n\n  const assignedSeedParticipantIds = seedAssignments\n    ?.map((assignment) => assignment.participantId)\n    .filter(Boolean);\n\n  const { stage, stageSequence } = structure;\n\n  const roundTarget =\n    stage === QUALIFYING\n      ? findExtension({ element: structure, name: ROUND_TARGET })?.extension\n          ?.value\n      : undefined;\n\n  const entryStatuses = DIRECT_ENTRY_STATUSES;\n  const entries = getStageEntries({\n    provisionalPositioning,\n    drawDefinition,\n    stageSequence,\n    entryStatuses,\n    structureId,\n    roundTarget,\n    stage,\n  });\n  const unseededEntries = entries.filter(\n    (entry) => !assignedSeedParticipantIds?.includes(entry.participantId)\n  );\n  const unseededParticipantIds = unseededEntries.map(\n    (entry) => entry.participantId\n  );\n  const unfilledDrawPositions = positionAssignments\n    ?.filter((assignment) => {\n      return (\n        !assignment.participantId && !assignment.bye && !assignment.qualifier\n      );\n    })\n    .map((assignment) => assignment.drawPosition);\n\n  if (\n    !multipleStructures &&\n    unseededParticipantIds.length > (unfilledDrawPositions?.length || 0)\n  ) {\n    return decorateResult({\n      result: { error: INSUFFICIENT_DRAW_POSITIONS },\n      context: {\n        unseededParticipantsCount: unseededParticipantIds.length,\n        unfilledDrawPositionsCount: unfilledDrawPositions?.length,\n      },\n      stack,\n    });\n  }\n\n  const { appliedPolicies } = getAppliedPolicies({\n    tournamentRecord,\n    drawDefinition,\n    event,\n  });\n  let avoidance = appliedPolicies?.[POLICY_TYPE_AVOIDANCE];\n\n  if (structure.stage === PLAY_OFF) {\n    // generate avoidance policies automatically for Playoffs from Round Robin Groups\n    const groupings = entries.reduce((groupings, entry) => {\n      if (!groupings[entry.groupingValue]) groupings[entry.groupingValue] = [];\n      groupings[entry.groupingValue].push(entry.participantId);\n      return groupings;\n    }, {});\n    if (Object.keys(groupings).length) {\n      if (!avoidance) avoidance = { policyName: 'Playoff Avoidance' };\n      if (!avoidance.policyAttributes) avoidance.policyAttributes = [];\n      avoidance.policyAttributes.push({ groupings });\n    }\n  }\n\n  if (avoidance && participants) {\n    return randomUnseededSeparation({\n      provisionalPositioning,\n      unseededParticipantIds,\n      inContextDrawMatchUps,\n      unseededByePositions,\n      tournamentRecord,\n      drawDefinition,\n      seedBlockInfo,\n      participants,\n      matchUpsMap,\n      structureId,\n      avoidance,\n      drawSize,\n      entries,\n    });\n  } else {\n    return randomUnseededDistribution({\n      provisionalPositioning,\n      unseededParticipantIds,\n      inContextDrawMatchUps,\n      unfilledDrawPositions,\n      multipleStructures,\n      tournamentRecord,\n      drawDefinition,\n      seedBlockInfo,\n      structureId,\n      matchUpsMap,\n      drawSize,\n      event,\n    });\n  }\n}\n\nfunction randomUnseededDistribution({\n  provisionalPositioning,\n  unseededParticipantIds,\n  inContextDrawMatchUps,\n  unfilledDrawPositions,\n  multipleStructures,\n  tournamentRecord,\n  drawDefinition,\n  seedBlockInfo,\n  matchUpsMap,\n  structureId,\n  drawSize,\n  event,\n}) {\n  // when { drawSize: 2 } reverse the order so that popping results in equivalent order\n  const shuffledDrawPositions =\n    drawSize > 2\n      ? shuffleArray(unfilledDrawPositions)\n      : unfilledDrawPositions.reverse();\n\n  for (const participantId of unseededParticipantIds) {\n    const drawPosition = shuffledDrawPositions.pop();\n    if (!multipleStructures || drawPosition) {\n      const result = assignDrawPosition({\n        provisionalPositioning,\n        inContextDrawMatchUps,\n        tournamentRecord,\n        drawDefinition,\n        seedBlockInfo,\n        participantId,\n        drawPosition,\n        matchUpsMap,\n        structureId,\n        event,\n      });\n      if (result?.error) console.log('!!!!!', { result });\n      if (result?.error)\n        return decorateResult({ result, stack: 'randomUnseededDistribution' });\n    }\n  }\n  return { ...SUCCESS };\n}\n","import { structureAssignedDrawPositions } from '../../../query/drawDefinition/positionsGetter';\nimport { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { getQualifiersCount } from '../../../query/drawDefinition/getQualifiersCount';\nimport { getRoundMatchUps } from '../../../query/matchUps/getRoundMatchUps';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { generateRange, randomPop } from '../../../utilities/arrays';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { ensureInt } from '../../../utilities/ensureInt';\n\nimport { CONSOLATION } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_STAGE,\n  NO_DRAW_POSITIONS_AVAILABLE_FOR_QUALIFIERS,\n} from '../../../constants/errorConditionConstants';\n\nexport function positionQualifiers(params) {\n  const structure = params.structure ?? findStructure(params).structure;\n\n  const stack = 'positionQualifiers';\n  const qualifierDrawPositions: number[] = [];\n\n  if (structure.stage === CONSOLATION) {\n    return decorateResult({ result: { error: INVALID_STAGE }, stack });\n  }\n\n  const {\n    unplacedRoundQualifierCounts,\n    positionAssignments,\n    roundDrawPositions,\n  } = getQualifiersData(params);\n\n  for (const roundNumber of Object.keys(unplacedRoundQualifierCounts)) {\n    const unfilledDrawPositions = positionAssignments\n      ?.filter((assignment) => {\n        return (\n          roundDrawPositions[roundNumber].includes(assignment.drawPosition) &&\n          !assignment.participantId &&\n          !assignment.qualifier &&\n          !assignment.bye\n        );\n      })\n      .map((assignment) => assignment.drawPosition);\n\n    if (\n      unplacedRoundQualifierCounts[roundNumber] > (unfilledDrawPositions || 0)\n    )\n      return decorateResult({\n        result: { error: NO_DRAW_POSITIONS_AVAILABLE_FOR_QUALIFIERS },\n        context: { unfilledDrawPositions },\n        stack,\n      });\n\n    generateRange(0, unplacedRoundQualifierCounts[roundNumber]).forEach(() => {\n      const drawPosition = randomPop(unfilledDrawPositions);\n      qualifierDrawPositions.push(drawPosition);\n      positionAssignments?.forEach((assignment) => {\n        if (assignment.drawPosition === drawPosition) {\n          assignment.qualifier = true;\n          delete assignment.participantId;\n          delete assignment.bye;\n        }\n      });\n    });\n  }\n\n  return { ...SUCCESS, qualifierDrawPositions };\n}\n\nexport function getQualifiersData({ drawDefinition, structure, structureId }) {\n  if (!structure)\n    ({ structure } = findStructure({ drawDefinition, structureId }));\n  if (!structureId) ({ structureId } = structure);\n\n  const { positionAssignments } = structureAssignedDrawPositions({ structure });\n\n  const { stage, stageSequence } = structure;\n\n  const { qualifiersCount, roundQualifiersCounts } = getQualifiersCount({\n    drawDefinition,\n    stageSequence,\n    structureId,\n    stage,\n  });\n\n  // now figure out which drawPositions are in which rounds\n  const trn = roundQualifiersCounts ? Object.keys(roundQualifiersCounts) : [];\n  const targetRoundNumbers = trn.map((n) => ensureInt(n));\n  const { matchUps } = getAllStructureMatchUps({ structure });\n  const { roundProfile } = getRoundMatchUps({ matchUps });\n  const roundDrawPositions = Object.assign(\n    {},\n    ...targetRoundNumbers\n      .filter((roundNumber) => roundProfile?.[roundNumber])\n      .map((roundNumber) => ({\n        [roundNumber]:\n          roundProfile?.[roundNumber]?.drawPositions?.filter(Boolean) ?? [],\n      }))\n  );\n\n  const assignedQualifierPositions = positionAssignments\n    ?.filter((assignment) => assignment.qualifier)\n    .map((assignment) => assignment.drawPosition);\n\n  const unplacedQualifiersCount =\n    qualifiersCount - (assignedQualifierPositions?.length ?? 0);\n  const placedQualifiersCount = assignedQualifierPositions?.length;\n\n  const unplacedRoundQualifierCounts = Object.assign(\n    {},\n    ...targetRoundNumbers.map((roundNumber) => {\n      const assignedQualifierPositions = positionAssignments\n        ?.filter(\n          (assignment) =>\n            assignment.qualifier &&\n            roundDrawPositions[roundNumber]?.drawPositions?.includes(\n              assignment.drawPosition\n            )\n        )\n        .map((assignment) => assignment.drawPosition);\n      return {\n        [roundNumber]:\n          (roundQualifiersCounts?.[roundNumber] ?? 0) -\n          (assignedQualifierPositions?.length ?? 0),\n      };\n    })\n  );\n\n  return {\n    unplacedRoundQualifierCounts,\n    unplacedQualifiersCount,\n    placedQualifiersCount,\n    roundQualifiersCounts,\n    positionAssignments,\n    roundDrawPositions,\n    qualifiersCount,\n  };\n}\n","import { chunkArray, shuffleArray } from '../../../../utilities/arrays';\nimport { isOdd } from '../../../../utilities/math';\n\n/*\n  seedBlocks for 32 seeds in a draw of 128 are as follows:\n\n  [\n    { drawPositions: [ 1 ], seedNumbers: [ 1 ] },\n    { drawPositions: [ 128 ], seedNumbers: [ 2 ] },\n    { drawPositions: [ 33, 96 ], seedNumbers: [ 3, 4 ] },\n    { drawPositions: [ 17, 49, 80, 112 ], seedNumbers: [ 5, 6, 7, 8 ] },\n    {\n      drawPositions: [ 9, 25,  41,  57, 72, 88, 104, 120 ],\n      seedNumbers: [ 9, 10, 11, 12, 13, 14, 15, 16 ] },\n    {\n      drawPositions: [ 5,  13, 21, 29, 37, 45, 53, 61, 68, 76, 84, 92, 100, 108, 116, 124 ],\n      seedNumbers: [ 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32 ]\n    }\n  ]\n\n  When the number of BYEs to be distributed for a seedBlock is LESS than the number of seed position in the block\n  it is necessary to evenly distribute the BYEs across all divisions, e.g. 1/2, 1/4, 1/8\n\n  For instance, in a draw of 128 with 116 participants there are 12 BYEs.  The first 8 BYEs are consumed by the\n  first four seedBlocks leaving 4 BYEs to b distributed  across the 8 drawPositions claimed by seeds 9-16.\n\n  The drawPositions for seeds 9-16 are:\n  [ 9, 25,  41,  57, 72, 88, 104, 120 ]\n\n  These are sorted low to high and grouped in chunks of 2 drawPositions: \n  [9, 25],  [41,  57], [72, 88], [104, 120]\n\n  These are then transformed into nested arrays which are each level an array of 2 items:\n  [[9, 25],  [41, 57]], [[72, 88], [104, 120]]\n\n  This nesting corresponds to the initial round of elimination structures which always contains power-of-2 drawPositions\n\n  An even distribution of BYEs to seeded drawPositions is achieved by iteratively popping a drawPosition from the nested structure,\n  at each level comparing the flattened length of the 2 items of the array\n\n  For comparison, the nesting of seed 17-32 would be as follows:\n  [[[5,  13], [21, 29]], [[37, 45], [53, 61]]], [[[68, 76], [84, 92]], [[100, 108], [116, 124]]],\n */\n\nexport function getBlockSortedRandomDrawPositions({\n  orderedSortedFirstRoundSeededDrawPositions: strictOrder,\n  validSeedBlocks,\n  byesToPlace,\n}) {\n  const drawPositions: number[] = [];\n\n  validSeedBlocks.forEach((seedBlock) => {\n    const leftToPlace = byesToPlace - drawPositions.length;\n    if (leftToPlace > seedBlock.drawPositions.length) {\n      drawPositions.push(...seedBlock.drawPositions);\n    } else {\n      const nestedDrawPositions = nestArray(\n        chunkArray(seedBlock.drawPositions, 2)\n      );\n\n      let drawPosition;\n      let desiredPosition = strictOrder[drawPositions.length];\n      while (\n        (drawPosition = popFromLargerSide(nestedDrawPositions, desiredPosition))\n      ) {\n        drawPositions.push(drawPosition);\n        desiredPosition = strictOrder[drawPositions.length];\n      }\n    }\n  });\n\n  const blockSortedRandom = drawPositions\n    .map((p) => (Array.isArray(p) ? shuffleArray(p) : p))\n    .flat(Infinity);\n\n  if (isOdd(byesToPlace)) {\n    const blockFirstSeedNumbers = validSeedBlocks.map(\n      (block) => block.seedNumbers[0]\n    );\n    if (blockFirstSeedNumbers.includes(byesToPlace)) return strictOrder;\n  }\n\n  return blockSortedRandom;\n}\n\n// desiredPosition is provided by strict seed order bye placement\n// when the sides are balanced, side selection is driven by desiredPosition\nfunction popFromLargerSide(arr, desiredPosition) {\n  if (Array.isArray(arr) && arr.length !== 2) return arr.pop();\n  if (!Array.isArray(arr[0])) {\n    if (arr.includes(desiredPosition))\n      return arr.indexOf(desiredPosition) ? arr.pop() : arr.shift();\n    return Math.round(Math.random()) ? arr.pop() : arr.shift();\n  }\n\n  const side1 = arr[0].flat(Infinity).length;\n  const side2 = arr[1].flat(Infinity).length;\n  if (side1 === side2) {\n    const desiredSide = arr[0].flat(Infinity).includes(desiredPosition)\n      ? arr[0]\n      : arr[1];\n    if (desiredPosition) return popFromLargerSide(desiredSide, desiredPosition);\n    return popFromLargerSide(arr[Math.round(Math.random())], desiredPosition);\n  }\n  return side1 < side2\n    ? popFromLargerSide(arr[1], desiredPosition)\n    : popFromLargerSide(arr[0], desiredPosition);\n}\n\nfunction nestArray(arr) {\n  const midPoint = Math.floor(arr.length / 2);\n  return arr.length > 2\n    ? [nestArray(arr.slice(0, midPoint)), nestArray(arr.slice(midPoint))]\n    : arr;\n}\n","import { getStructurePositionedSeeds } from '../../../../query/structure/getStructurePositionedSeeds';\nimport { getNumericSeedValue } from '../../../../query/drawDefinition/getNumericSeedValue';\nimport { getBlockSortedRandomDrawPositions } from './getBlockSortedRandomDrawPositions';\nimport { getValidSeedBlocks } from '../../../../query/drawDefinition/seedGetter';\nimport { unique } from '../../../../utilities/arrays';\n\nexport function getSeedOrderByePositions({\n  provisionalPositioning,\n  relevantMatchUps,\n  appliedPolicies,\n  drawDefinition,\n  seedingProfile,\n  seedBlockInfo,\n  byesToPlace,\n  structure,\n}) {\n  if (!seedBlockInfo) {\n    seedBlockInfo = getValidSeedBlocks({\n      provisionalPositioning,\n      appliedPolicies,\n      drawDefinition,\n      seedingProfile,\n      structure,\n    });\n  }\n\n  const { isFeedIn, isLuckyStructure, isContainer } = seedBlockInfo;\n  let { validSeedBlocks } = seedBlockInfo;\n  if (appliedPolicies?.seeding?.containerByesIgnoreSeeding)\n    validSeedBlocks = [];\n\n  const positionedSeeds =\n    getStructurePositionedSeeds({\n      provisionalPositioning,\n      drawDefinition,\n      structure,\n    }) ?? [];\n\n  const relevantDrawPositions = unique(\n    [].concat(...relevantMatchUps.map((matchUp) => matchUp.drawPositions))\n  );\n  const relevantPositionedSeeds = positionedSeeds.filter((positionedSeed) => {\n    return relevantDrawPositions.includes(positionedSeed.drawPosition);\n  });\n\n  // within seedBlocks positionedSeeds are sorted by seedValue to handle the situation\n  // where there are multiple players seeded with the same seedValue which have been\n  // randomly assigned to different seedBlocks\n  // Example: more than one 4th seed, but only one of them placed in the 3-4 seed block\n  // 3rd seed must get 3rd Bye, and 4th seed placed in the 3-4 seed block must get 4th bye\n  const seedValueSort = (a, b) =>\n    getNumericSeedValue(a.seedValue) - getNumericSeedValue(b.seedValue);\n  const valueOrderedBlockSortedPositionedSeeds = validSeedBlocks.reduce(\n    (result, seedBlock) => {\n      const positionedSeedsInBlock = relevantPositionedSeeds\n        .filter(\n          (positionedSeed) =>\n            seedBlock.drawPositions?.includes(positionedSeed.drawPosition)\n        )\n        .sort(seedValueSort);\n      return result.concat(...positionedSeedsInBlock);\n    },\n    []\n  );\n\n  const orderedSortedFirstRoundSeededDrawPositions =\n    valueOrderedBlockSortedPositionedSeeds.map(\n      (positionedSeed) => positionedSeed.drawPosition\n    );\n\n  const blockSortedRandomDrawPositions = getBlockSortedRandomDrawPositions({\n    orderedSortedFirstRoundSeededDrawPositions,\n    validSeedBlocks,\n    byesToPlace,\n  });\n\n  // returns list of bye positions which strictly follows where seeds\n  // have been placed according to sorted seedNumbers\n  const strictSeedOrderByePositions = getOrderedByePositions({\n    orderedSeedDrawPositions: orderedSortedFirstRoundSeededDrawPositions,\n    relevantMatchUps,\n  }).slice(0, byesToPlace);\n\n  const blockSeedOrderByePositions = getOrderedByePositions({\n    orderedSeedDrawPositions: blockSortedRandomDrawPositions,\n    relevantMatchUps,\n  }).slice(0, byesToPlace);\n\n  return {\n    strictSeedOrderByePositions,\n    blockSeedOrderByePositions,\n    isLuckyStructure,\n    positionedSeeds,\n    isContainer,\n    isFeedIn,\n  };\n}\n\nfunction getOrderedByePositions({\n  orderedSeedDrawPositions,\n  relevantMatchUps,\n}) {\n  // if relevantMatchUps excludes FEED_IN rounds...\n  // matchUpDrawPositions will equal firstRoundDrawPositions\n  // In CONTAINER/ROUND_ROBIN structures drawPositions are duplicated\n  // and therefore must placed in drawOrder within Groups\n\n  const matchUpDrawPositionPairs = relevantMatchUps.map(\n    (matchUp) => matchUp.drawPositions\n  );\n  const consideredDrawPositionPairs = matchUpDrawPositionPairs\n    .map((pair) => pair?.sort((a, b) => a - b))\n    .filter((pair) => pair?.[0] + 1 === pair?.[1]);\n\n  // sort seededMatchUps so that pairedPositions represent seed order\n  const seedOrderSortedDrawPositionPairs = orderedSeedDrawPositions\n    .map((drawPosition) =>\n      consideredDrawPositionPairs.find(\n        (drawPositions) => drawPositions?.includes(drawPosition)\n      )\n    )\n    .filter(Boolean);\n\n  return seedOrderSortedDrawPositionPairs\n    .map((drawPositions) => {\n      return drawPositions?.reduce((byePosition, drawPosition) => {\n        const included = orderedSeedDrawPositions.includes(drawPosition);\n        return included ? byePosition : drawPosition;\n      }, undefined);\n    })\n    .filter(Boolean);\n}\n","import { DrawDefinition, Structure } from '../../types/tournamentTypes';\nimport { getStructureSeedAssignments } from './getStructureSeedAssignments';\nimport { structureAssignedDrawPositions } from '../drawDefinition/positionsGetter';\n\ntype GetStructurePositionedSeeds = {\n  provisionalPositioning?: boolean;\n  drawDefinition: DrawDefinition;\n  structure: Structure;\n};\nexport function getStructurePositionedSeeds({\n  provisionalPositioning,\n  drawDefinition,\n  structure,\n}: GetStructurePositionedSeeds) {\n  const { positionAssignments } = structureAssignedDrawPositions({ structure });\n  const { seedAssignments } = getStructureSeedAssignments({\n    provisionalPositioning,\n    drawDefinition,\n    structure,\n  });\n  const seedMap = Object.assign(\n    {},\n    ...(seedAssignments || [])\n      .filter((assignment) => assignment.participantId)\n      .map((assignment: any) => ({\n        // because we already know participantId is present!\n        [assignment.participantId]: assignment,\n      }))\n  );\n  return positionAssignments\n    ?.map((assignment: any) => {\n      return !seedMap[assignment.participantId]\n        ? ''\n        : {\n            ...assignment,\n            seedNumber: seedMap[assignment.participantId].seedNumber,\n            seedValue: seedMap[assignment.participantId].seedValue,\n          };\n    })\n    .filter(Boolean);\n}\n","import { assignDrawPositionBye } from '../../../matchUps/drawPositions/assignDrawPositionBye';\nimport { getByesData } from '../../../../query/drawDefinition/getByesData';\nimport { getSeedOrderByePositions } from './getSeedOrderedByePositions';\nimport { getDevContext } from '../../../../global/state/globalState';\nimport { getUnseededByePositions } from './getUnseededByePositions';\nimport { findStructure } from '../../../../acquire/findStructure';\nimport { shuffleArray } from '../../../../utilities/arrays';\n\nimport { MatchUpsMap } from '../../../../query/matchUps/getMatchUpsMap';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport {\n  CONTAINER,\n  ITEM,\n  QUALIFYING,\n} from '../../../../constants/drawDefinitionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Structure,\n  Tournament,\n} from '../../../../types/tournamentTypes';\nimport {\n  PolicyDefinitions,\n  SeedingProfile,\n} from '../../../../types/factoryTypes';\n\ntype PositionByesArgs = {\n  appliedPolicies?: PolicyDefinitions;\n  provisionalPositioning?: boolean;\n  tournamentRecord?: Tournament;\n  seedingProfile?: SeedingProfile;\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  structure?: Structure;\n  structureId?: string;\n  seedBlockInfo?: any;\n  seedsOnly?: boolean;\n  seedLimit?: number;\n  event?: Event;\n};\nexport function positionByes({\n  provisionalPositioning,\n  tournamentRecord,\n  appliedPolicies,\n  drawDefinition,\n  seedBlockInfo,\n  seedingProfile,\n  matchUpsMap,\n  structureId,\n  structure,\n  seedLimit,\n  seedsOnly,\n  event,\n}: PositionByesArgs) {\n  if (!structure)\n    ({ structure } = findStructure({ drawDefinition, structureId }));\n  if (!structureId) structureId = structure?.structureId;\n\n  const blockOrdered = !(\n    structure?.structures ?? structure?.stage === QUALIFYING\n  );\n\n  const { byesCount, placedByes, relevantMatchUps } = getByesData({\n    provisionalPositioning,\n    drawDefinition,\n    matchUpsMap,\n    structure,\n    event,\n  });\n  const byesToPlace = byesCount - (placedByes || 0);\n  if (byesToPlace <= 0) return { ...SUCCESS };\n\n  const {\n    strictSeedOrderByePositions,\n    blockSeedOrderByePositions,\n    isLuckyStructure,\n    isFeedIn,\n  } = getSeedOrderByePositions({\n    provisionalPositioning,\n    relevantMatchUps,\n    appliedPolicies,\n    drawDefinition,\n    seedingProfile,\n    seedBlockInfo,\n    byesToPlace,\n    structure,\n  });\n\n  const ignoreSeededByes =\n    structure?.structureType &&\n    [CONTAINER, ITEM].includes(structure.structureType) &&\n    appliedPolicies?.seeding?.containerByesIgnoreSeeding;\n\n  const seedOrderByePositions =\n    blockOrdered && blockSeedOrderByePositions?.length\n      ? blockSeedOrderByePositions\n      : strictSeedOrderByePositions;\n\n  let { unseededByePositions } = getUnseededByePositions({\n    provisionalPositioning,\n    seedOrderByePositions,\n    isLuckyStructure,\n    appliedPolicies,\n    drawDefinition,\n    seedLimit,\n    structure,\n    isFeedIn,\n  });\n\n  const isOdd = (x) => x % 2;\n  // method determines whether candidate c is paired to elements in an array\n  const isNotPaired = (arr, c) =>\n    (arr || []).every((a) => (isOdd(a) ? c !== a + 1 : c !== a - 1));\n\n  // first add all drawPositions paired with sorted seeds drawPositions\n  // then add quarter separated and evenly distributed drawPositions\n  // derived from theoretical seeding of firstRoundParticipants\n  // HOWEVER, if separated and evenly distributed drawPositions result\n  // in a BYE/BYE pairing, prioritize remaining unpaired positions\n  let byePositions: number[] = [].concat(...seedOrderByePositions);\n\n  if (!seedsOnly) {\n    while (unseededByePositions.length) {\n      const unPairedPosition = unseededByePositions.find((position) =>\n        isNotPaired(byePositions, position)\n      );\n      if (unPairedPosition) {\n        byePositions.push(unPairedPosition);\n        unseededByePositions = unseededByePositions.filter(\n          (position) => position !== unPairedPosition\n        );\n      } else {\n        byePositions.push(...unseededByePositions);\n        unseededByePositions = [];\n      }\n    }\n  }\n\n  if (ignoreSeededByes) {\n    byePositions = shuffleArray(byePositions);\n    if (getDevContext({ ignoreSeededByes })) console.log({ byePositions });\n  }\n\n  // then take only the number of required byes\n  const byeDrawPositions = byePositions.slice(0, byesToPlace);\n\n  for (const drawPosition of byeDrawPositions) {\n    const result = assignDrawPositionBye({\n      provisionalPositioning,\n      tournamentRecord,\n      drawDefinition,\n      drawPosition,\n      matchUpsMap,\n      structureId,\n      structure,\n      event,\n    });\n    if (result?.error) return result;\n  }\n\n  return { ...SUCCESS, unseededByePositions, byeDrawPositions };\n}\n","import { getAllStructureMatchUps } from '../matchUps/getAllStructureMatchUps';\nimport { structureAssignedDrawPositions } from './positionsGetter';\nimport { getQualifiersCount } from './getQualifiersCount';\nimport { getStageEntries } from './stageGetter';\n\nimport { STRUCTURE_SELECTED_STATUSES } from '../../constants/entryStatusConstants';\nimport {\n  CONSOLATION,\n  CONTAINER,\n} from '../../constants/drawDefinitionConstants';\n\nexport function getByesData({\n  provisionalPositioning,\n  drawDefinition,\n  matchUpsMap,\n  structure,\n  event,\n}) {\n  const matchUpFilters = { isCollectionMatchUp: false };\n  const { matchUps, roundMatchUps } = getAllStructureMatchUps({\n    afterRecoveryTimes: false,\n    provisionalPositioning,\n    drawDefinition,\n    matchUpFilters,\n    matchUpsMap,\n    structure,\n    event,\n  });\n  const firstRoundMatchUps = roundMatchUps?.[1] || [];\n\n  // firstRoundMatchUps don't work for CONTAINER / ROUND_ROBIN structures\n\n  const isRoundRobin = structure?.structureType === CONTAINER;\n  const relevantMatchUps = isRoundRobin ? matchUps : firstRoundMatchUps;\n\n  // maxByes for RR can only be the number of structures... no more than one bye per structure\n  const maxByes = isRoundRobin\n    ? structure?.structures?.length || 0\n    : matchUps.length;\n\n  // get stage/stageSequence Entries and qualifiers\n  const { structureId, stage, stageSequence } = structure;\n  const entries = getStageEntries({\n    entryStatuses: STRUCTURE_SELECTED_STATUSES,\n    provisionalPositioning,\n    drawDefinition,\n    stageSequence,\n    structureId,\n    stage,\n  });\n\n  const { qualifiersCount } = getQualifiersCount({\n    provisionalPositioning,\n    drawDefinition,\n    stageSequence,\n    structureId,\n    stage,\n  });\n  const entriesCount = entries.length + qualifiersCount;\n\n  // # Byes = drawSize (positionAssignments) - total entries\n  // const { positionAssignments, qualifierPositions, byePositions, unassignedPositions } = structureAssignedDrawPositions({structure});\n  const { positionAssignments, unassignedPositions } =\n    structureAssignedDrawPositions({ structure });\n  const unassignedDrawPositions = unassignedPositions?.map(\n    (position) => position.drawPosition\n  );\n  const placedByes = positionAssignments?.filter((assignment) => assignment.bye)\n    .length;\n  const placedByePositions = positionAssignments\n    ?.filter((assignment) => assignment.bye)\n    .map((assignment) => assignment.drawPosition);\n\n  const positionsToAvoidDoubleBye = relevantMatchUps\n    .map((matchUp) => matchUp.drawPositions)\n    .filter((drawPositions) => {\n      return drawPositions?.reduce(\n        (noBye, drawPosition) =>\n          !placedByePositions?.includes(drawPosition) && noBye,\n        true\n      );\n    })\n    .flat(Infinity)\n    .filter((drawPosition) => unassignedDrawPositions?.includes(drawPosition));\n\n  const drawSize = positionAssignments?.length;\n  let byesCount = drawSize ? drawSize - entriesCount : 0;\n  if (\n    byesCount > maxByes &&\n    structure.stageSequence === 1 &&\n    structure.stage !== CONSOLATION\n  ) {\n    byesCount = maxByes;\n  }\n\n  return {\n    placedByes,\n    byesCount,\n    relevantMatchUps,\n    placedByePositions,\n    roundMatchUps,\n    positionsToAvoidDoubleBye,\n  };\n}\n","import { structureAssignedDrawPositions } from '../../../../query/drawDefinition/positionsGetter';\nimport { getSeedPattern, getValidSeedBlocks } from '../../../../query/drawDefinition/seedGetter';\nimport { getAllStructureMatchUps } from '../../../../query/matchUps/getAllStructureMatchUps';\nimport { chunkArray, shuffleArray, unique } from '../../../../utilities/arrays';\nimport { numericSort } from '../../../../utilities/sorting';\nimport { getSeedBlocks } from '../getSeedBlocks';\n\nimport { CLUSTER, CONTAINER, QUALIFYING } from '../../../../constants/drawDefinitionConstants';\n\nexport function getUnseededByePositions({\n  provisionalPositioning,\n  seedOrderByePositions,\n  isLuckyStructure,\n  appliedPolicies,\n  drawDefinition,\n  seedLimit,\n  structure,\n  isFeedIn,\n}) {\n  const seedingProfile = appliedPolicies?.seeding?.seedingProfile;\n  const isQualifying = structure.stage === QUALIFYING;\n\n  const { positionAssignments } = structureAssignedDrawPositions({ structure });\n  const filledDrawPositions = positionAssignments\n    ?.filter((assignment) => assignment.participantId)\n    .map((assignment) => assignment.drawPosition);\n\n  const matchUpFilters = { isCollectionMatchUp: false };\n  const { matchUps, roundMatchUps } = getAllStructureMatchUps({\n    provisionalPositioning,\n    matchUpFilters,\n    structure,\n  });\n  const firstRoundMatchUps = roundMatchUps?.[1] || [];\n\n  // firstRoundMatchUps don't work for CONTAINER / ROUND_ROBIN structures\n  const relevantMatchUps = structure.structureType === CONTAINER ? matchUps : firstRoundMatchUps;\n  const relevantDrawPositions = unique([].concat(...relevantMatchUps.map((matchUp) => matchUp.drawPositions)));\n  const drawPositionOffset = Math.min(...relevantDrawPositions) - 1;\n\n  const filledRelevantDrawPositions = filledDrawPositions?.filter((drawPosition) =>\n    relevantDrawPositions.includes(drawPosition),\n  );\n\n  const getHalves = (chunk) => {\n    const halfLength = Math.ceil(chunk.length / 2);\n    const halves = [chunk.slice(0, halfLength), chunk.slice(halfLength)];\n    const halfLengths = halves.map((half) => [].concat(...half.flat(Infinity)).length);\n    const shortLength = Math.min(...halfLengths.flat(Infinity));\n    const longLength = Math.max(...halfLengths.flat(Infinity));\n    const longIndex = halfLengths.indexOf(longLength);\n    const unequalHalves = shortLength !== longLength;\n    const shuffledHalves = shuffleArray(halves);\n    const [greaterHalf, lesserHalf] =\n      !shortLength || unequalHalves\n        ? [halves[longIndex], halves[1 - longIndex]]\n        : [shuffledHalves[0], shuffledHalves[1]];\n    return { greaterHalf, lesserHalf };\n  };\n  const getNextDrawPosition = (chunks) => {\n    const { greaterHalf, lesserHalf } = getHalves(chunks);\n    const { greaterHalf: greaterQuarter, lesserHalf: lesserQuarter } = getHalves(greaterHalf);\n    const shuffledQuarter = shuffleArray(greaterQuarter.flat(Infinity));\n    const drawPosition = shuffledQuarter.pop();\n    const diminishedQuarter = greaterQuarter.flat().filter((position) => position !== drawPosition);\n    const newlyFilteredChunks = [...lesserHalf, ...lesserQuarter, diminishedQuarter];\n    return { newlyFilteredChunks, drawPosition };\n  };\n  const notSeedByePosition = (drawPosition) => !seedOrderByePositions.includes(drawPosition);\n  const unfilledDrawPosition = (drawPosition) => !filledRelevantDrawPositions?.includes(drawPosition);\n  const quarterSeparateBlock = (block) => {\n    const sortedChunked = chunkArray(block.sort(numericSort), Math.ceil(block.length / 4));\n    let filteredChunks = sortedChunked.map((chunk) => chunk.filter(unfilledDrawPosition));\n    const drawPositionCount = [].concat(...filteredChunks.flat(Infinity)).length;\n    const orderedDrawPositions: number[] = [];\n    for (let i = 0; i < drawPositionCount; i++) {\n      const { newlyFilteredChunks, drawPosition } = getNextDrawPosition(filteredChunks);\n      orderedDrawPositions.push(drawPosition);\n      filteredChunks = newlyFilteredChunks;\n    }\n    return orderedDrawPositions;\n  };\n\n  // The goal here is to get an order for assigning bye positions which is well distributed\n  // setting allPositions: true returns seedBlocks for all positions\n  // overriding the default which returns only seedBlocks for seedsCount\n  const { validSeedBlocks } = getValidSeedBlocks({\n    provisionalPositioning,\n    allPositions: true,\n    appliedPolicies,\n    drawDefinition,\n    structure,\n  });\n\n  const validBlockDrawPositions = validSeedBlocks?.map(\n    (block) => block.drawPositions?.map((drawPosition) => drawPosition + drawPositionOffset),\n  );\n\n  let unfilledSeedBlocks;\n\n  if (isFeedIn) {\n    // FEED_IN structures calculate seedDrawPositions uniquely\n    // and require a special case to properly calculate bye positions\n    const baseDrawSize = relevantDrawPositions.length;\n    const { seedBlocks } = getSeedBlocks({\n      cluster: getSeedPattern(seedingProfile) === CLUSTER,\n      participantsCount: baseDrawSize,\n    });\n    const blockDrawPositions = seedBlocks.map((seedBlock) =>\n      seedBlock.map((drawPosition) => drawPosition + drawPositionOffset),\n    );\n\n    unfilledSeedBlocks = blockDrawPositions.map(quarterSeparateBlock).filter((block) => block.length);\n  } else if (isQualifying) {\n    unfilledSeedBlocks = validBlockDrawPositions?.map((block) => block.filter(unfilledDrawPosition));\n  } else {\n    if (isLuckyStructure) {\n      //\n    }\n    unfilledSeedBlocks = validBlockDrawPositions?.map(quarterSeparateBlock).filter((block) => block.length);\n  }\n\n  // for Round Robins pairs need to be reduced to pairs in drawPosition order\n  const matchUpPairedDrawPositions = relevantMatchUps\n    .map((matchUp) => matchUp.drawPositions)\n    .map((pair) => pair?.sort((a, b) => a - b))\n    .filter((pair) => pair?.[0] + 1 === pair?.[1]);\n\n  const findDrawPositionPair = (drawPosition) => {\n    return matchUpPairedDrawPositions.reduce((pair, candidate) => {\n      return candidate.includes(drawPosition)\n        ? candidate.reduce((p, c) => (c !== drawPosition ? c : p), undefined)\n        : pair;\n    }, undefined);\n  };\n\n  let unseededByePositions = unfilledSeedBlocks\n    .map((block) => block.map(findDrawPositionPair))\n    .flat(Infinity)\n    .filter(unfilledDrawPosition)\n    .filter(notSeedByePosition)\n    .filter(Boolean);\n\n  if (isQualifying && !structure.structures) {\n    // need to know how many qualifying blocks so that unseededByePositions can be shuffled\n    // (after removing blocks.length time blocks which had seeds placed)\n    // console.log(validBlockDrawPositions.length, unseededByePositions.length);\n    const seedingOverhang = seedLimit % 4;\n    const overhangDrawPositions = unseededByePositions.slice(0, seedingOverhang);\n    const qualifierBlocksCount = roundMatchUps[structure.roundLimit]?.length;\n    const shuffledRemainder = chunkArray(unseededByePositions.slice(seedingOverhang), qualifierBlocksCount)\n      .map(shuffleArray)\n      .flat();\n    unseededByePositions = overhangDrawPositions.concat(shuffledRemainder);\n  }\n\n  return { unseededByePositions };\n}\n","import { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { generateRange } from '../../../utilities/arrays';\nimport { assignDrawPosition } from './positionAssignment';\nimport {\n  getValidSeedBlocks,\n  getNextSeedBlock,\n} from '../../../query/drawDefinition/seedGetter';\n\nimport { HydratedMatchUp, HydratedParticipant } from '../../../types/hydrated';\nimport { MatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  PolicyDefinitions,\n  SeedBlock,\n  SeedingProfile,\n} from '../../../types/factoryTypes';\nimport {\n  ErrorType,\n  MISSING_DRAW_POSITION,\n} from '../../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Structure,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype PositionSeedBlocksArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  participants?: HydratedParticipant[];\n  appliedPolicies?: PolicyDefinitions;\n  provisionalPositioning?: boolean;\n  tournamentRecord?: Tournament;\n  validSeedBlocks?: SeedBlock[];\n  seedingProfile?: SeedingProfile;\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  structure?: Structure;\n  groupsCount?: number;\n  structureId?: string;\n  seedBlockInfo?: any;\n  event?: Event;\n};\nexport function positionSeedBlocks({\n  provisionalPositioning,\n  inContextDrawMatchUps,\n  tournamentRecord,\n  appliedPolicies,\n  validSeedBlocks,\n  drawDefinition,\n  seedingProfile,\n  seedBlockInfo,\n  participants,\n  groupsCount,\n  structureId,\n  matchUpsMap,\n  structure,\n  event,\n}: PositionSeedBlocksArgs) {\n  const seedPositions: number[] = [];\n  const errors: any[] = [];\n  let placedSeedBlocks = 0;\n\n  if (!structure)\n    ({ structure } = findStructure({ drawDefinition, structureId }));\n  if (!structureId) structureId = structure?.structureId;\n\n  if (!appliedPolicies) {\n    appliedPolicies = getAppliedPolicies({ drawDefinition }).appliedPolicies;\n  }\n  if (!validSeedBlocks) {\n    const result =\n      structure &&\n      getValidSeedBlocks({\n        provisionalPositioning,\n        appliedPolicies,\n        drawDefinition,\n        seedingProfile,\n        structure,\n      });\n    if (result?.error) errors.push(result.error);\n    validSeedBlocks = result?.validSeedBlocks;\n  }\n\n  groupsCount = groupsCount ?? validSeedBlocks?.length ?? 0;\n\n  generateRange(0, groupsCount).forEach(() => {\n    if (placedSeedBlocks < (groupsCount || 0)) {\n      const result = positionSeedBlock({\n        provisionalPositioning,\n        inContextDrawMatchUps,\n        tournamentRecord,\n        drawDefinition,\n        seedingProfile,\n        seedBlockInfo,\n        participants,\n        structureId,\n        matchUpsMap,\n        event,\n      });\n      if (result?.success) {\n        placedSeedBlocks++;\n        seedPositions.push(...(result.seedPositions ?? []));\n      }\n      if (result.error) {\n        errors.push({ seedPositionError: result.error });\n      }\n    }\n  });\n\n  if (errors.length) return { error: errors };\n  return { ...SUCCESS, seedPositions };\n}\n\nfunction positionSeedBlock({\n  provisionalPositioning,\n  inContextDrawMatchUps,\n  tournamentRecord,\n  drawDefinition,\n  seedingProfile,\n  seedBlockInfo,\n  participants,\n  structureId,\n  matchUpsMap,\n  event,\n}): { success?: boolean; error?: ErrorType; seedPositions?: number[] } {\n  const { unplacedSeedParticipantIds, unfilledPositions } = getNextSeedBlock({\n    provisionalPositioning,\n    randomize: true,\n    drawDefinition,\n    seedingProfile,\n    seedBlockInfo,\n    structureId,\n    event,\n  });\n\n  const { appliedPolicies } = getAppliedPolicies({ drawDefinition });\n  const { avoidance } = appliedPolicies ?? {};\n  if (avoidance && participants && unplacedSeedParticipantIds?.length > 2) {\n    // TODO: 'implement seed placement avoidance';\n  }\n\n  const seedPositions: number[] = [];\n\n  for (const participantId of unplacedSeedParticipantIds) {\n    const drawPosition = unfilledPositions.pop();\n    if (!drawPosition) return { error: MISSING_DRAW_POSITION };\n    seedPositions.push(drawPosition);\n\n    const result = assignDrawPosition({\n      provisionalPositioning,\n      inContextDrawMatchUps,\n      tournamentRecord,\n      drawDefinition,\n      seedingProfile,\n      participantId,\n      seedBlockInfo,\n      drawPosition,\n      matchUpsMap,\n      structureId,\n      event,\n    });\n\n    if (!result.success) return result;\n  }\n\n  return { ...SUCCESS, seedPositions };\n}\n","import { positionUnseededParticipants } from '../matchUps/drawPositions/positionUnseededParticipants';\nimport { getPositionAssignments } from '../../query/drawDefinition/positionsGetter';\nimport { getQualifiersCount } from '../../query/drawDefinition/getQualifiersCount';\nimport { positionQualifiers } from '../matchUps/drawPositions/positionQualifiers';\nimport { getAppliedPolicies } from '../../query/extensions/getAppliedPolicies';\nimport { positionByes } from './positionGovernor/byePositioning/positionByes';\nimport { positionSeedBlocks } from '../matchUps/drawPositions/positionSeeds';\nimport { getParticipants } from '../../query/participants/getParticipants';\nimport { getStageEntries } from '../../query/drawDefinition/stageGetter';\nimport { getAllDrawMatchUps } from '../../query/matchUps/drawMatchUps';\nimport { modifyDrawNotice } from '../notifications/drawNotifications';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { findStructure } from '../../acquire/findStructure';\nimport { ResultType, decorateResult } from '../../global/functions/decorateResult';\nimport { getSeedPattern, getValidSeedBlocks } from '../../query/drawDefinition/seedGetter';\nimport { MatchUpsMap, getMatchUpsMap } from '../../query/matchUps/getMatchUpsMap';\nimport { disableNotifications, enableNotifications } from '../../global/state/globalState';\n\nimport { LUCKY_DRAW, WATERFALL } from '../../constants/drawDefinitionConstants';\nimport { STRUCTURE_NOT_FOUND } from '../../constants/errorConditionConstants';\nimport { DIRECT_ENTRY_STATUSES } from '../../constants/entryStatusConstants';\nimport { PolicyDefinitions, SeedingProfile } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport { DrawDefinition, Event, PositionAssignment, Tournament } from '../../types/tournamentTypes';\n\n// TODO: Throw an error if an attempt is made to automate positioning for a structure that already has completed matchUps\ntype AutomatedPositioningArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  appliedPolicies?: PolicyDefinitions;\n  provisionalPositioning?: boolean;\n  seedingProfile?: SeedingProfile;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  multipleStructures?: boolean;\n  applyPositioning?: boolean;\n  matchUpsMap?: MatchUpsMap;\n  placementGroup?: number;\n  placeByes?: boolean;\n  structureId: string;\n  seedsOnly?: boolean;\n  seedLimit?: number;\n  drawType?: string;\n  drawSize?: number;\n  event?: Event;\n};\nexport function automatedPositioning({\n  applyPositioning = true,\n  provisionalPositioning,\n  inContextDrawMatchUps,\n  multipleStructures,\n  placeByes = true,\n  tournamentRecord,\n  appliedPolicies,\n  placementGroup,\n  drawDefinition,\n  seedingProfile,\n  structureId,\n  matchUpsMap,\n  seedLimit,\n  seedsOnly,\n  drawType,\n  drawSize,\n  event,\n}: AutomatedPositioningArgs): ResultType & {\n  positionAssignments?: PositionAssignment[];\n  positioningReport?: { [key: string]: any }[];\n  success?: boolean;\n  conflicts?: any[];\n} {\n  const positioningReport: any[] = [];\n\n  //-----------------------------------------------------------\n  // handle notification state for all exit conditions\n  if (!applyPositioning) {\n    // when positioning is not being applied no notifications are generated\n    // because only the positionAssignments are returned\n    disableNotifications();\n    // positioningAssignments are applied to a copy of the drawDefinition,\n    // not the actual drawDefinition...\n    drawDefinition = makeDeepCopy(drawDefinition, false, true);\n  }\n\n  const handleErrorCondition = (result) => {\n    if (!applyPositioning) enableNotifications();\n    return decorateResult({ result, stack: 'automatedPositioning' });\n  };\n\n  const handleSuccessCondition = (result) => {\n    if (!applyPositioning) enableNotifications();\n    return result;\n  };\n  //-----------------------------------------------------------\n\n  const result = findStructure({ drawDefinition, structureId });\n  if (result.error) return handleErrorCondition(result);\n  const structure = result.structure;\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  if (!appliedPolicies) {\n    appliedPolicies = getAppliedPolicies({\n      drawDefinition,\n      structure,\n      event,\n    })?.appliedPolicies;\n  }\n\n  const { qualifiersCount } = getQualifiersCount({\n    stageSequence: structure.stageSequence,\n    provisionalPositioning,\n    stage: structure.stage,\n    drawDefinition,\n    structureId,\n  });\n\n  const entryStatuses = DIRECT_ENTRY_STATUSES;\n  const entries = getStageEntries({\n    stageSequence: structure.stageSequence,\n    provisionalPositioning,\n    stage: structure.stage,\n    placementGroup,\n    drawDefinition,\n    entryStatuses,\n    structureId,\n  });\n\n  if (!entries?.length && !qualifiersCount) return handleSuccessCondition({ ...SUCCESS });\n\n  matchUpsMap = matchUpsMap ?? getMatchUpsMap({ drawDefinition });\n\n  if (!inContextDrawMatchUps) {\n    ({ matchUps: inContextDrawMatchUps } = getAllDrawMatchUps({\n      inContext: true,\n      drawDefinition,\n      matchUpsMap,\n    }));\n  }\n\n  let unseededByePositions = [];\n\n  const seedBlockInfo = getValidSeedBlocks({\n    provisionalPositioning,\n    appliedPolicies,\n    drawDefinition,\n    seedingProfile,\n    structure,\n  });\n  if (seedBlockInfo.error) return seedBlockInfo;\n  const { validSeedBlocks } = seedBlockInfo;\n\n  positioningReport.push({ validSeedBlocks });\n\n  const participants = tournamentRecord\n    ? getParticipants({\n        withIndividualParticipants: true,\n        tournamentRecord,\n      })?.participants\n    : [];\n\n  if (getSeedPattern(structure.seedingProfile || seedingProfile) === WATERFALL) {\n    // since WATERFALL attempts to place ALL participants\n    // BYEs must be placed first to ensure lower seeds get BYEs\n    let result: any = placeByes\n      ? positionByes({\n          provisionalPositioning,\n          tournamentRecord,\n          appliedPolicies,\n          drawDefinition,\n          seedBlockInfo,\n          matchUpsMap,\n          structure,\n          seedLimit,\n          seedsOnly,\n          event,\n        })\n      : undefined;\n    if (result?.error) return handleErrorCondition(result);\n    unseededByePositions = result.unseededByePositions;\n\n    positioningReport.push({ action: 'positionByes', unseededByePositions });\n\n    const profileSeeding = structure.seedingProfile ? { positioning: structure.seedingProfile } : seedingProfile;\n\n    result = positionSeedBlocks({\n      seedingProfile: profileSeeding,\n      provisionalPositioning,\n      inContextDrawMatchUps,\n      tournamentRecord,\n      appliedPolicies,\n      validSeedBlocks,\n      drawDefinition,\n      seedBlockInfo,\n      participants,\n      matchUpsMap,\n      structure,\n      event,\n    });\n    if (result.error) return handleErrorCondition(result);\n\n    positioningReport.push({\n      seedPositions: result.seedPositions,\n      action: 'positionSeedBlocks',\n    });\n  } else {\n    // otherwise... seeds need to be placed first so that BYEs\n    // can follow the seedValues of placed seeds\n    if (drawType !== LUCKY_DRAW) {\n      const profileSeeding = structure.seedingProfile ? { positioning: structure.seedingProfile } : seedingProfile;\n      const result: any = positionSeedBlocks({\n        seedingProfile: profileSeeding,\n        provisionalPositioning,\n        inContextDrawMatchUps,\n        tournamentRecord,\n        appliedPolicies,\n        validSeedBlocks,\n        drawDefinition,\n        seedBlockInfo,\n        participants,\n        matchUpsMap,\n        structure,\n        event,\n      });\n\n      if (result.error) return handleErrorCondition(result);\n\n      positioningReport.push({\n        action: 'positionSeedBlocks',\n        seedPositions: result.seedPositions,\n      });\n    }\n\n    const result = placeByes\n      ? positionByes({\n          provisionalPositioning,\n          tournamentRecord,\n          appliedPolicies,\n          drawDefinition,\n          seedBlockInfo,\n          matchUpsMap,\n          structure,\n          seedLimit,\n          seedsOnly,\n          event,\n        })\n      : undefined;\n\n    if (result?.error) {\n      return handleErrorCondition(result);\n    }\n    unseededByePositions = result?.unseededByePositions;\n    positioningReport.push({\n      action: 'positionByes',\n      byeDrawPositions: result?.byeDrawPositions,\n      unseededByePositions,\n    });\n  }\n\n  const conflicts: any = {};\n\n  if (!seedsOnly) {\n    // qualifiers are randomly placed BEFORE unseeded because in FEED_IN draws they may have roundTargets\n    // this can be modified ONLY if a check is place for round targeting and qualifiers are placed first\n    // in this specific circumstance\n    let result: any = positionQualifiers({\n      inContextDrawMatchUps,\n      tournamentRecord,\n      appliedPolicies,\n      validSeedBlocks,\n      drawDefinition,\n      seedBlockInfo,\n      participants,\n      matchUpsMap,\n      structure,\n    });\n    if (result.error) {\n      return handleErrorCondition(result);\n    }\n    if (result.conflicts) conflicts.qualifierConflicts = result.conflicts;\n    positioningReport.push({\n      action: 'positionQualifiers',\n      qualifierDrawPositions: result.qualifierDrawPositions,\n    });\n\n    result = positionUnseededParticipants({\n      provisionalPositioning,\n      inContextDrawMatchUps,\n      unseededByePositions,\n      multipleStructures,\n      tournamentRecord,\n      drawDefinition,\n      seedBlockInfo,\n      participants,\n      matchUpsMap,\n      structureId,\n      structure,\n      drawSize,\n      event,\n    });\n\n    if (result.error) {\n      return handleErrorCondition(result);\n    }\n    if (result.conflicts) conflicts.unseededConflicts = result.conflicts;\n    positioningReport.push({ action: 'positionUnseededParticipants' });\n  }\n\n  const { positionAssignments } = getPositionAssignments({\n    drawDefinition,\n    structure,\n  });\n\n  modifyDrawNotice({ drawDefinition, structureIds: [structureId] });\n\n  //-----------------------------------------------------------\n  // re-enable notifications, if they have been disabled\n  if (!applyPositioning) enableNotifications();\n  //-----------------------------------------------------------\n\n  return { positionAssignments, conflicts, ...SUCCESS, positioningReport };\n}\n","import { isCompletedStructure } from '../../query/drawDefinition/structureActions';\nimport { getMinFinishingPositionRange } from '../../functions/sorters/structureSort';\nimport { getPlayoffStructures } from '../../query/structure/structureGetter';\nimport { automatedPositioning } from './automatedPositioning';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { SeedingProfile } from '../../types/factoryTypes';\nimport {\n  DRAW_DEFINITION_NOT_FOUND,\n  EVENT_NOT_FOUND,\n  ErrorType,\n  INCOMPLETE_SOURCE_STRUCTURE,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  PositionAssignment,\n  Tournament,\n} from '../../types/tournamentTypes';\n\ntype StructurePositionAssignmentType = {\n  positionAssignments: PositionAssignment[];\n  structureId: string;\n};\n\ntype AutomatedPlayoffPositioningArgs = {\n  provisionalPositioning?: boolean;\n  seedingProfile?: SeedingProfile;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  applyPositioning?: boolean;\n  structureId: string;\n  placeByes?: boolean;\n  seedsOnly?: boolean;\n  event: Event;\n};\nexport function automatedPlayoffPositioning(\n  params: AutomatedPlayoffPositioningArgs\n): {\n  structurePositionAssignments?: StructurePositionAssignmentType[];\n  positioningReports?: { [key: string]: any }[];\n  success?: boolean;\n  error?: ErrorType;\n} {\n  const {\n    applyPositioning = true,\n    provisionalPositioning,\n    tournamentRecord,\n    drawDefinition,\n    seedingProfile,\n    structureId,\n    placeByes,\n    seedsOnly,\n    event,\n  } = params;\n\n  if (!event) return { error: EVENT_NOT_FOUND };\n  if (!drawDefinition) return { error: DRAW_DEFINITION_NOT_FOUND };\n\n  const structureIsComplete = isCompletedStructure({\n    drawDefinition,\n    structureId,\n  });\n  if (!structureIsComplete && !provisionalPositioning) {\n    return { error: INCOMPLETE_SOURCE_STRUCTURE };\n  }\n\n  const playoffStructures = getPlayoffStructures({\n    drawDefinition,\n    structureId,\n  }).playoffStructures?.sort(\n    (a, b) => getMinFinishingPositionRange(a) - getMinFinishingPositionRange(b)\n  );\n  const structurePositionAssignments: StructurePositionAssignmentType[] = [];\n\n  const positioningReports: { [key: string]: any }[] = [];\n\n  if (playoffStructures) {\n    for (const structure of playoffStructures) {\n      const { structureId: playoffStructureId } = structure;\n      const result = automatedPositioning({\n        structureId: playoffStructureId,\n        provisionalPositioning,\n        applyPositioning,\n        tournamentRecord,\n        drawDefinition,\n        seedingProfile,\n        placeByes,\n        seedsOnly,\n      });\n\n      if (result.error) return result;\n\n      if (result.positionAssignments) {\n        structurePositionAssignments.push({\n          positionAssignments: result.positionAssignments,\n          structureId: playoffStructureId,\n        });\n      }\n      if (result.positioningReport)\n        positioningReports.push(result.positioningReport);\n    }\n  }\n\n  return { ...SUCCESS, structurePositionAssignments, positioningReports };\n}\n","import { getStructureGroups } from '../../../query/structure/getStructureGroups';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\n\nexport function resequenceStructures({ drawDefinition }) {\n  const { maxQualifyingDepth, structureProfiles } = getStructureGroups({\n    drawDefinition,\n  });\n\n  for (const structure of drawDefinition.structures) {\n    const profile = structureProfiles[structure.structureId];\n    if (profile.distanceFromMain) {\n      structure.stageSequence =\n        maxQualifyingDepth + 1 - profile.distanceFromMain;\n    }\n  }\n\n  return { ...SUCCESS };\n}\n","import { resequenceStructures } from './structureGovernor/resequenceStructures';\nimport { getAllStructureMatchUps } from '../../query/matchUps/getAllStructureMatchUps';\nimport { addTournamentTimeItem } from '../timeItems/addTimeItem';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { findStructure } from '../../acquire/findStructure';\nimport {\n  addMatchUpsNotice,\n  modifyDrawNotice,\n} from '../notifications/drawNotifications';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_DRAW_DEFINITION,\n  MISSING_STRUCTURE,\n  MISSING_TARGET_LINK,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  DrawLink,\n  Structure,\n} from '../../types/tournamentTypes';\n\nexport function attachQualifyingStructure({\n  tournamentRecord,\n  drawDefinition,\n  structure,\n  link,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const result = attachQualifying({\n    tournamentId: tournamentRecord.tournamentId,\n    drawDefinition,\n    structure,\n    link,\n  });\n  if (result.error) return result;\n\n  const qualifyingDetails = {\n    structureId: structure.structureId,\n    drawId: drawDefinition.drawId,\n  };\n\n  const timeItem = {\n    itemType: 'attachQualifyingStructures',\n    itemValue: qualifyingDetails,\n  };\n  addTournamentTimeItem({ tournamentRecord, timeItem });\n\n  return result;\n}\n\ntype AttachQualifyingArgs = {\n  drawDefinition: DrawDefinition;\n  tournamentId?: string;\n  structure: Structure;\n  eventId?: string;\n  link: DrawLink;\n};\nexport function attachQualifying({\n  drawDefinition,\n  tournamentId,\n  structure,\n  eventId,\n  link,\n}: AttachQualifyingArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structure) return { error: MISSING_STRUCTURE };\n  if (!link) return { error: MISSING_TARGET_LINK };\n\n  const targetStructureId = link.target.structureId;\n  const result = findStructure({\n    drawDefinition,\n    structureId: targetStructureId,\n  });\n  if (result.error)\n    return decorateResult({\n      stack: 'attachQualifyingStructure',\n      context: { targetStructureId },\n      result,\n    });\n\n  if (!drawDefinition.structures) drawDefinition.structures = [];\n  if (!drawDefinition.links) drawDefinition.links = [];\n  drawDefinition.structures.push(structure);\n  drawDefinition.links.push(link);\n\n  resequenceStructures({ drawDefinition });\n\n  const matchUps = getAllStructureMatchUps({ structure })?.matchUps || [];\n\n  addMatchUpsNotice({\n    drawDefinition,\n    tournamentId,\n    matchUps,\n    eventId,\n  });\n  modifyDrawNotice({ drawDefinition, structureIds: [structure.structureId] });\n\n  return { ...SUCCESS };\n}\n","export const FORMAT_STANDARD = 'SET3-S:6/TB7'; // Best of 3 Tiebreak Sets to 6\nexport const FORMAT_STANDARD_NOAD = 'SET3-S:6NOAD'; // Best of 3 NOAD Sets to 6 with deciding game at 5-5\nexport const FORMAT_ATP_DOUBLES = 'SET3-S:6/TB7-F:TB10'; // Best of 3 Sets to 6, no Ad, Final Set Tiebreak to 10\nexport const FORMAT_SHORT_SETS = 'SET3-S:4/TB7'; // Best of 3 Sets to 4'\nexport const FORMAT_FAST4 = 'SET3-S:4/TB5@3'; // Best of 3 Sets to 4, Tiebreak at 3\nexport const TIMED20 = 'SET1-S:T20'; // Timed 20 minute set\nexport const FORMAT_PRO_SET = 'SET1-S:8/TB7'; // One Set to 8 with Advantage with tiebreak at 8-8\nexport const FORMAT_COLLEGE_PRO_SET = 'SET1-S:8/TB7@7'; // One Set to 8 with tiebreak at 7-7\n\nexport const matchUpFormats = {\n  FORMAT_STANDARD,\n  FORMAT_STANDARD_NOAD,\n  FORMAT_ATP_DOUBLES,\n  FORMAT_SHORT_SETS,\n  FORMAT_FAST4,\n  FORMAT_PRO_SET,\n  FORMAT_COLLEGE_PRO_SET,\n  TIMED20,\n};\n","import { parse } from '../../../assemblies/generators/matchUpFormatCode/parse';\nimport { ensureInt } from '../../../utilities/ensureInt';\n\nimport { FORMAT_STANDARD } from '../../../fixtures/scoring/matchUpFormats';\nimport { Score } from '../../../types/tournamentTypes';\nimport {\n  DEFAULTED,\n  RETIRED,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\n\ntype CountSetsArgs = {\n  matchUpFormat?: string;\n  matchUpStatus?: string;\n  winningSide?: number;\n  tallyPolicy?: any;\n  score?: Score;\n};\n\nexport type Tally = [number, number];\n\nexport function countSets({\n  winningSide: matchUpWinningSide,\n  matchUpFormat = FORMAT_STANDARD,\n  matchUpStatus,\n  tallyPolicy,\n  score,\n}: CountSetsArgs) {\n  const setsTally: Tally = [0, 0];\n  const sets = score?.sets;\n  const matchUpWinnerIndex =\n    typeof matchUpWinningSide === 'number' && matchUpWinningSide - 1;\n  const parsedMatchUpFormat = parse(matchUpFormat);\n  const setsToWin = getSetsToWin(parsedMatchUpFormat?.bestOf ?? 1);\n\n  if (\n    typeof matchUpWinnerIndex === 'number' &&\n    ((matchUpStatus === DEFAULTED && tallyPolicy?.setsCreditForDefaults) ||\n      (matchUpStatus === WALKOVER && tallyPolicy?.setsCreditForWalkovers))\n  ) {\n    // in the case of WALKOVER or DEFAULT, matchUp winner gets full sets to win value\n    setsTally[matchUpWinnerIndex] = setsToWin;\n  } else {\n    for (const set of sets || []) {\n      const { winningSide: setWinningSide } = set;\n      if (setWinningSide) setsTally[setWinningSide - 1] += 1;\n    }\n  }\n  if (typeof matchUpWinnerIndex === 'number' && matchUpStatus === RETIRED) {\n    // if the loser has setsToWin then last set was incomplete and needs to be subtracted from loser\n    if (+setsTally[1 - matchUpWinnerIndex] === setsToWin)\n      setsTally[1 - matchUpWinnerIndex] -= 1;\n    if (tallyPolicy?.setsCreditForRetirements)\n      setsTally[matchUpWinnerIndex] = setsToWin;\n  }\n  return setsTally;\n}\n\ninterface CountGames {\n  matchUpFormat?: string;\n  matchUpStatus?: string;\n  winningSide?: number;\n  tallyPolicy?: any;\n  score: Score;\n}\n\nexport function countGames({\n  matchUpFormat = FORMAT_STANDARD,\n  winningSide: matchUpWinningSide,\n  matchUpStatus,\n  tallyPolicy,\n  score,\n}: CountGames) {\n  // IMPORTANT: recognize finalSetFormat\n  const { sets } = score || {};\n  if (!sets) return [0, 0];\n\n  const matchUpWinnerIndex =\n    typeof matchUpWinningSide === 'number' && matchUpWinningSide - 1;\n  const parsedMatchUpFormat = parse(matchUpFormat);\n  const bestOf = parsedMatchUpFormat?.bestOf ?? 1;\n  const setsToWin = getSetsToWin(bestOf);\n  const tiebreakAt = parsedMatchUpFormat?.setFormat?.tiebreakAt || 0;\n\n  const gamesTally: number[][] = [[], []];\n\n  if (\n    typeof matchUpWinnerIndex === 'number' &&\n    ((matchUpStatus === DEFAULTED && tallyPolicy?.gamesCreditForDefaults) ||\n      (matchUpStatus === WALKOVER && tallyPolicy?.gamesCreditForWalkovers))\n  ) {\n    const gamesForSet = parsedMatchUpFormat?.setFormat?.setTo || 0;\n    const minimumGameWins = setsToWin * gamesForSet;\n    gamesTally[matchUpWinnerIndex].push(minimumGameWins);\n  } else {\n    sets.forEach((set, i) => {\n      const setNumber = set.setNumber || i + 1;\n      const whichFormat =\n        setNumber > setsToWin && parsedMatchUpFormat?.finalSetFormat\n          ? 'finalSetFormat'\n          : 'setFormat';\n      const based = parsedMatchUpFormat?.[whichFormat]?.based;\n      const isTiebreakSet = parsedMatchUpFormat?.[whichFormat].tiebreakSet;\n\n      const { side1Score, side2Score } = set;\n\n      if (isGamesBased(based)) {\n        gamesTally[0].push(ensureInt(side1Score || 0));\n        gamesTally[1].push(ensureInt(side2Score || 0));\n      }\n\n      // count a tiebreak set also as a game won\n      if (\n        isTiebreakSet &&\n        set.winningSide &&\n        tallyPolicy?.gamesCreditForTiebreakSets !== false\n      ) {\n        gamesTally[set.winningSide - 1].push(1);\n      }\n    });\n  }\n\n  if (matchUpStatus === RETIRED && typeof matchUpWinnerIndex === 'number') {\n    // setFormat must consider whether retirment occurred in a finalSet which has a different format\n    const whichFormat =\n      sets.length > setsToWin && parsedMatchUpFormat?.finalSetFormat\n        ? 'finalSetFormat'\n        : 'setFormat';\n    const format = parsedMatchUpFormat?.[whichFormat];\n\n    if (isGamesBased(format.based)) {\n      const gamesForSet = format?.setTo || 0;\n\n      const getComplement = (value) => {\n        if (!parsedMatchUpFormat || value === '') return;\n        if (+value === tiebreakAt - 1 || +value === tiebreakAt)\n          return ensureInt(tiebreakAt || 0) + 1;\n        if (+value < tiebreakAt) return gamesForSet;\n        return tiebreakAt;\n      };\n\n      const setsTally = countSets({\n        winningSide: matchUpWinningSide,\n        score: { sets },\n        matchUpStatus,\n        matchUpFormat,\n        tallyPolicy,\n      });\n\n      const loserLeadSet = gamesTally\n        .map((g) => g[matchUpWinnerIndex] <= g[1 - matchUpWinnerIndex])\n        .reduce((a, b) => a + (b ? 1 : 0), 0);\n      // if sets where loser lead > awarded sets, adjust last game to winner\n      if (loserLeadSet > setsTally[1 - matchUpWinnerIndex]) {\n        const talliedGames = gamesTally[matchUpWinnerIndex].length;\n        const complement = getComplement(\n          gamesTally[1 - matchUpWinnerIndex][talliedGames - 1]\n        );\n        if (complement)\n          gamesTally[matchUpWinnerIndex][talliedGames - 1] = complement;\n      }\n\n      // if the gamesTally[x].length is less than the number of sets to win award gamesForSet to winner\n      // gamesTally[x].length is an array of games won for each set, so length is number of sets\n      if (\n        setsToWin > gamesTally[matchUpWinnerIndex].length &&\n        tallyPolicy?.gamesCreditForRetirements\n      ) {\n        gamesTally[matchUpWinnerIndex].push(gamesForSet);\n      }\n    }\n  }\n\n  return [\n    gamesTally[0].reduce((a, b) => a + b, 0),\n    gamesTally[1].reduce((a, b) => a + b, 0),\n  ];\n}\n\nexport function countPoints({\n  matchUpFormat,\n  score,\n}: {\n  matchUpFormat?: string;\n  score: Score;\n}): { pointsTally: Tally; tiebreaksTally: Tally } {\n  const parsedMatchUpFormat = matchUpFormat ? parse(matchUpFormat) : undefined;\n  const bestOf = parsedMatchUpFormat?.bestOf ?? 1;\n  const setsToWin = getSetsToWin(bestOf);\n  const tiebreaksTally: Tally = [0, 0];\n  const pointsTally: Tally = [0, 0];\n\n  score?.sets?.forEach((set, i) => {\n    const setNumber = set.setNumber || i + 1;\n    const whichFormat =\n      setNumber > setsToWin && parsedMatchUpFormat?.finalSetFormat\n        ? 'finalSetFormat'\n        : 'setFormat';\n    const based = parsedMatchUpFormat?.[whichFormat]?.based;\n\n    if (isPointsBased(based)) {\n      const { side1Score, side2Score } = set;\n      if (side1Score) pointsTally[0] += ensureInt(side1Score || 0);\n      if (side2Score) pointsTally[1] += ensureInt(side2Score || 0);\n    } else {\n      if (set.side1TiebreakScore)\n        pointsTally[0] += ensureInt(set.side1TiebreakScore || 0);\n      if (set.side2TiebreakScore)\n        pointsTally[1] += ensureInt(set.side2TiebreakScore || 0);\n\n      if ((set.side1TiebreakScore || set.side2TiebreakScore) && set.winningSide)\n        tiebreaksTally[set.winningSide - 1] += 1;\n    }\n  });\n\n  return { pointsTally, tiebreaksTally };\n}\n\nfunction getSetsToWin(bestOfGames) {\n  return (bestOfGames && Math.ceil(bestOfGames / 2)) || 1;\n}\n\nfunction isPointsBased(based) {\n  return based === 'P';\n}\n\nfunction isGamesBased(based) {\n  return !isPointsBased(based);\n}\n","import { countGames, countSets, countPoints } from './scoreCounters';\nimport { calculatePercentages } from './calculatePercentages';\nimport { intersection } from '../../../utilities/arrays';\nimport { ensureInt } from '../../../utilities/ensureInt';\n\nimport { DOUBLES, SINGLES } from '../../../constants/matchUpTypes';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  completedMatchUpStatuses,\n  DEFAULTED,\n  RETIRED,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\n\n// DONE: ?? this TODO seems old\n/*\nTODO: for TEAM matchUps, what are now games won/lost should be tieMatchUps won/lost\nand the games/sets of all tieMatchUps should be aggregated\n*/\n\ntype GetParticipantResultsArgs = {\n  matchUps: HydratedMatchUp[];\n  participantIds?: string[];\n  matchUpFormat?: string;\n  perPlayer?: number;\n  tallyPolicy?: any;\n};\n\nexport function getParticipantResults({\n  participantIds,\n  matchUpFormat,\n  tallyPolicy,\n  perPlayer,\n  matchUps,\n}: GetParticipantResultsArgs) {\n  const participantResults = {};\n\n  const excludeMatchUpStatuses = tallyPolicy?.excludeMatchUpStatuses || [];\n\n  const filteredMatchUps = matchUps.filter((matchUp) => {\n    return (\n      // Do not filter out team matchUps based on matchUpStatus\n      (matchUp.tieMatchUps ||\n        !excludeMatchUpStatuses.includes(matchUp.matchUpStatus)) &&\n      // include if no participantIds (idsFilter active) have been specified\n      // if idsFilter is active then exclude matchUps which are not between specified participantIds\n      (!participantIds?.length ||\n        intersection(participantIds, [\n          getSideId(matchUp, 0),\n          getSideId(matchUp, 1),\n        ]).length === 2)\n    );\n  });\n\n  const allSets = filteredMatchUps.flatMap(({ score, tieMatchUps }) =>\n    tieMatchUps\n      ? tieMatchUps\n          .filter(\n            ({ matchUpStatus }) =>\n              !excludeMatchUpStatuses.includes(matchUpStatus)\n          )\n          .flatMap(({ score }) => score?.sets?.length ?? 0)\n      : score?.sets?.length ?? 0\n  );\n  const totalSets = allSets.reduce((a, b) => a + b, 0);\n\n  for (const matchUp of filteredMatchUps) {\n    const { matchUpStatus, tieMatchUps, tieFormat, score, winningSide, sides } =\n      matchUp;\n\n    const manualGamesOverride =\n      tieFormat &&\n      matchUp._disableAutoCalc &&\n      tieFormat.collectionDefinitions.every(({ scoreValue }) => scoreValue);\n\n    const winningParticipantId = winningSide && getWinningSideId(matchUp);\n    const losingParticipantId = winningSide && getLosingSideId(matchUp);\n\n    if (!winningParticipantId && !losingParticipantId) {\n      if (matchUpStatus && completedMatchUpStatuses.includes(matchUpStatus)) {\n        const participantIdSide1 = getSideId(matchUp, 0);\n        const participantIdSide2 = getSideId(matchUp, 1);\n        if (participantIdSide1) {\n          checkInitializeParticipant(participantResults, participantIdSide1);\n          participantResults[participantIdSide1].matchUpsCancelled += 1;\n        }\n        if (participantIdSide2) {\n          checkInitializeParticipant(participantResults, participantIdSide2);\n          participantResults[participantIdSide2].matchUpsCancelled += 1;\n        }\n      } else if (tieMatchUps?.length) {\n        perPlayer = 0; // if any matchUps are matchUpType: TEAM don't calculate perPlayer\n\n        for (const tieMatchUp of tieMatchUps) {\n          if (tieMatchUp.winningSide) {\n            const tieWinningParticipantId = sides?.find(\n              ({ sideNumber }) => sideNumber === tieMatchUp.winningSide\n            )?.participantId;\n            const tieLosingParticipantId = sides?.find(\n              ({ sideNumber }) => sideNumber === tieMatchUp.winningSide\n            )?.participantId;\n            if (tieWinningParticipantId && tieLosingParticipantId) {\n              checkInitializeParticipant(\n                participantResults,\n                tieWinningParticipantId\n              );\n              checkInitializeParticipant(\n                participantResults,\n                tieLosingParticipantId\n              );\n              participantResults[tieWinningParticipantId].tieMatchUpsWon += 1;\n              participantResults[tieLosingParticipantId].tieMatchUpsLost += 1;\n\n              if (tieMatchUp.matchUpType === SINGLES) {\n                participantResults[tieWinningParticipantId].tieSinglesWon += 1;\n                participantResults[tieLosingParticipantId].tieSinglesLost += 1;\n              } else if (tieMatchUp.matchUpType === DOUBLES) {\n                participantResults[tieWinningParticipantId].tieDoublesWon += 1;\n                participantResults[tieLosingParticipantId].tieDoublesLost += 1;\n              }\n            }\n          }\n\n          processScore({\n            score: tieMatchUp.score,\n            manualGamesOverride,\n            participantResults,\n            sides, // use sides from the TEAM matchUp\n          });\n        }\n      } else {\n        processScore({\n          manualGamesOverride,\n          participantResults,\n          score,\n          sides,\n        });\n      }\n    } else {\n      checkInitializeParticipant(participantResults, winningParticipantId);\n      checkInitializeParticipant(participantResults, losingParticipantId);\n\n      if (tieMatchUps?.length) {\n        perPlayer = 0; // if any matchUps are matchUpType: TEAM don't calculate perPlayer\n\n        for (const tieMatchUp of tieMatchUps) {\n          const { matchUpType } = tieMatchUp;\n          const isDoubles = matchUpType === DOUBLES;\n          const isSingles = matchUpType === SINGLES;\n\n          if (tieMatchUp.winningSide) {\n            // logic ensures that losing TEAM participant gets credit for tieMatchUps won & etc.\n            if (tieMatchUp.winningSide === winningSide) {\n              if (winningParticipantId) {\n                participantResults[winningParticipantId].tieMatchUpsWon += 1;\n                if (isSingles)\n                  participantResults[winningParticipantId].tieSinglesWon += 1;\n                if (isDoubles)\n                  participantResults[winningParticipantId].tieDoublesWon += 1;\n              }\n              if (losingParticipantId) {\n                participantResults[losingParticipantId].tieMatchUpsLost += 1;\n                if (isSingles)\n                  participantResults[losingParticipantId].tieSinglesLost += 1;\n                if (isDoubles) {\n                  participantResults[losingParticipantId].tieDoublesLost += 1;\n                }\n              }\n            } else if (tieMatchUp.winningSide !== winningSide) {\n              if (losingParticipantId) {\n                participantResults[losingParticipantId].tieMatchUpsWon += 1;\n                if (isSingles)\n                  participantResults[losingParticipantId].tieSinglesWon += 1;\n                if (isDoubles) {\n                  participantResults[losingParticipantId].tieDoublesWon += 1;\n                }\n              }\n              if (winningParticipantId) {\n                participantResults[winningParticipantId].tieMatchUpsLost += 1;\n                if (isSingles)\n                  participantResults[winningParticipantId].tieSinglesLost += 1;\n                if (isDoubles) {\n                  participantResults[winningParticipantId].tieDoublesLost += 1;\n                }\n              }\n            }\n          }\n\n          processMatchUp({\n            matchUpFormat: tieMatchUp.matchUpFormat,\n            matchUpStatus: tieMatchUp.matchUpStatus,\n            score: tieMatchUp.score,\n            winningParticipantId,\n            losingParticipantId,\n            participantResults,\n            isTieMatchUp: true,\n            manualGamesOverride,\n            tallyPolicy,\n            winningSide,\n          });\n        }\n        processOutcome({\n          winningParticipantId,\n          losingParticipantId,\n          participantResults,\n          matchUpStatus,\n        });\n      } else {\n        processMatchUp({\n          matchUpFormat: matchUp.matchUpFormat ?? matchUpFormat,\n          isTieMatchUp: undefined,\n          winningParticipantId,\n          manualGamesOverride,\n          losingParticipantId,\n          participantResults,\n          matchUpStatus,\n          tallyPolicy,\n          winningSide,\n          score,\n        });\n      }\n    }\n\n    if (manualGamesOverride) {\n      const side1participantId = sides?.find(\n        ({ sideNumber }) => sideNumber === 1\n      )?.participantId;\n      const side2participantId = sides?.find(\n        ({ sideNumber }) => sideNumber === 2\n      )?.participantId;\n\n      checkInitializeParticipant(participantResults, side1participantId);\n      checkInitializeParticipant(participantResults, side2participantId);\n\n      const gamesWonSide1 = score?.sets?.reduce(\n        (total, set) => total + (set?.side1Score ?? 0),\n        0\n      );\n      const gamesWonSide2 = score?.sets?.reduce(\n        (total, set) => total + (set.side2Score ?? 0),\n        0\n      );\n\n      if (side1participantId) {\n        participantResults[side1participantId].gamesWon += gamesWonSide1;\n        participantResults[side1participantId].gamesLost += gamesWonSide2;\n      }\n\n      if (side2participantId) {\n        participantResults[side2participantId].gamesWon += gamesWonSide2;\n        participantResults[side2participantId].gamesLost += gamesWonSide1;\n      }\n    }\n  }\n\n  calculatePercentages({\n    participantResults,\n    matchUpFormat,\n    tallyPolicy,\n    perPlayer,\n    totalSets,\n  });\n\n  return { participantResults };\n}\n\nfunction getWinningSideId(matchUp) {\n  const winnerIndex = matchUp.winningSide - 1;\n  return getSideId(matchUp, winnerIndex);\n}\n\nfunction getLosingSideId(matchUp) {\n  const loserIndex = 1 - (matchUp.winningSide - 1);\n  return getSideId(matchUp, loserIndex);\n}\n\nfunction getSideId(matchUp, index) {\n  if (!matchUp?.sides) {\n    console.log('no sides:', { matchUp });\n    return 'foo';\n  }\n  const Side = matchUp.sides[index];\n  if (!Side) {\n    console.log('No Side', { matchUp, index });\n    return 'foo';\n  }\n  return Side.participantId;\n}\n\nfunction checkInitializeParticipant(participantResults, participantId) {\n  if (participantId && !participantResults[participantId])\n    participantResults[participantId] = {\n      allDefaults: 0,\n      defaults: 0,\n      defeats: [],\n      gamesLost: 0,\n      gamesWon: 0,\n      matchUpsCancelled: 0,\n      matchUpsLost: 0,\n      matchUpsWon: 0,\n      pointsLost: 0,\n      pointsWon: 0,\n      retirements: 0,\n      setsLost: 0,\n      setsWon: 0,\n      tieSinglesWon: 0,\n      tieSinglesLost: 0,\n      tieDoublesWon: 0,\n      tieDoublesLost: 0,\n      tieMatchUpsLost: 0,\n      tieMatchUpsWon: 0,\n      victories: [],\n      walkovers: 0,\n    };\n}\n\nfunction processScore({\n  manualGamesOverride,\n  participantResults,\n  score,\n  sides,\n}) {\n  const { sets } = score || {};\n  const gamesTally: number[][] = [[], []];\n  const setsTally = [0, 0];\n\n  for (const set of sets || []) {\n    const { winningSide: setWinningSide, side1Score, side2Score } = set;\n    if (setWinningSide) setsTally[setWinningSide - 1] += 1;\n    gamesTally[0].push(ensureInt(side1Score || 0));\n    gamesTally[1].push(ensureInt(side2Score || 0));\n  }\n\n  const gamesTotal = [\n    gamesTally[0].reduce((a, b) => a + b, 0),\n    gamesTally[1].reduce((a, b) => a + b, 0),\n  ];\n\n  sides.forEach((side, i) => {\n    const { participantId } = side;\n    if (participantId) {\n      checkInitializeParticipant(participantResults, participantId);\n      participantResults[participantId].setsWon += setsTally[i];\n      participantResults[participantId].setsLost += setsTally[1 - i];\n      if (!manualGamesOverride) {\n        participantResults[participantId].gamesWon += gamesTotal[i];\n        participantResults[participantId].gamesLost += gamesTotal[1 - i];\n      }\n    }\n  });\n}\n\nfunction processMatchUp({\n  winningParticipantId,\n  losingParticipantId,\n  participantResults,\n  manualGamesOverride,\n  matchUpFormat,\n  matchUpStatus,\n  isTieMatchUp,\n  tallyPolicy,\n  winningSide,\n  score,\n}) {\n  const winningSideIndex = winningSide && winningSide - 1;\n  const losingSideIndex = 1 - winningSideIndex;\n\n  if (!isTieMatchUp) {\n    processOutcome({\n      winningParticipantId,\n      losingParticipantId,\n      participantResults,\n      matchUpStatus,\n    });\n  }\n\n  const setsTally = countSets({\n    matchUpStatus,\n    matchUpFormat,\n    tallyPolicy,\n    winningSide,\n    score,\n  });\n  const gamesTally = countGames({\n    matchUpStatus,\n    matchUpFormat,\n    tallyPolicy,\n    winningSide,\n    score,\n  });\n  const { pointsTally } = countPoints({ score, matchUpFormat });\n\n  if (winningParticipantId) {\n    participantResults[winningParticipantId].setsWon +=\n      setsTally[winningSideIndex];\n    participantResults[winningParticipantId].setsLost +=\n      setsTally[losingSideIndex];\n\n    if (!manualGamesOverride) {\n      participantResults[winningParticipantId].gamesWon +=\n        gamesTally[winningSideIndex];\n      participantResults[winningParticipantId].gamesLost +=\n        gamesTally[losingSideIndex];\n    }\n\n    participantResults[winningParticipantId].pointsWon +=\n      pointsTally[winningSideIndex];\n    participantResults[winningParticipantId].pointsLost +=\n      pointsTally[losingSideIndex];\n  }\n  if (losingParticipantId) {\n    participantResults[losingParticipantId].setsWon +=\n      setsTally[losingSideIndex];\n    participantResults[losingParticipantId].setsLost +=\n      setsTally[winningSideIndex];\n\n    if (!manualGamesOverride) {\n      participantResults[losingParticipantId].gamesWon +=\n        gamesTally[losingSideIndex];\n      participantResults[losingParticipantId].gamesLost +=\n        gamesTally[winningSideIndex];\n    }\n\n    participantResults[losingParticipantId].pointsWon +=\n      pointsTally[losingSideIndex];\n    participantResults[losingParticipantId].pointsLost +=\n      pointsTally[winningSideIndex];\n  }\n}\n\nfunction processOutcome({\n  winningParticipantId,\n  losingParticipantId,\n  participantResults,\n  matchUpStatus,\n}) {\n  if (losingParticipantId) {\n    if (matchUpStatus === WALKOVER)\n      participantResults[losingParticipantId].walkovers += 1;\n    if (matchUpStatus === DEFAULTED)\n      participantResults[losingParticipantId].defaults += 1;\n    if (matchUpStatus === RETIRED)\n      participantResults[losingParticipantId].retirements += 1;\n\n    // attribute to catch all scenarios where participant terminated matchUp irregularly\n    if ([DEFAULTED, RETIRED, WALKOVER].includes(matchUpStatus))\n      participantResults[losingParticipantId].allDefaults += 1;\n\n    participantResults[losingParticipantId].matchUpsLost += 1;\n  }\n\n  if (winningParticipantId) {\n    participantResults[winningParticipantId].matchUpsWon += 1;\n  }\n\n  if (losingParticipantId && winningParticipantId) {\n    participantResults[losingParticipantId].defeats.push(winningParticipantId);\n    participantResults[winningParticipantId].victories.push(\n      losingParticipantId\n    );\n  }\n}\n","import { parse } from '../../../assemblies/generators/matchUpFormatCode/parse';\n\nexport function calculatePercentages({\n  participantResults,\n  matchUpFormat,\n  tallyPolicy,\n  perPlayer,\n  totalSets,\n}) {\n  const parsedGroupMatchUpFormat =\n    (matchUpFormat && parse(matchUpFormat)) || {};\n  const bestOfGames = parsedGroupMatchUpFormat.bestOf;\n  const bracketSetsToWin = (bestOfGames && Math.ceil(bestOfGames / 2)) || 1;\n  const bracketGamesForSet = parsedGroupMatchUpFormat.setFormat?.setTo;\n\n  Object.keys(participantResults).forEach((participantId) => {\n    const setsWon = participantResults[participantId].setsWon;\n    const setsLost = participantResults[participantId].setsLost;\n    const setsTotal = tallyPolicy?.groupTotalSetsPlayed\n      ? totalSets\n      : perPlayer * (bracketSetsToWin || 0) || setsWon + setsLost;\n    let setsPct = Math.round((setsWon / setsTotal) * 1000) / 1000;\n    if (setsPct === Infinity || isNaN(setsPct)) setsPct = setsTotal;\n\n    const tieMatchUpsWon = participantResults[participantId].tieMatchUpsWon;\n    const tieMatchUpsLost = participantResults[participantId].tieMatchUpsLost;\n    const tieMatchUpsTotal = tieMatchUpsWon + tieMatchUpsLost;\n    let tieMatchUpsPct =\n      Math.round((tieMatchUpsWon / tieMatchUpsTotal) * 1000) / 1000;\n    if (tieMatchUpsPct === Infinity || isNaN(tieMatchUpsPct))\n      tieMatchUpsPct = tieMatchUpsWon;\n\n    const matchUpsWon = participantResults[participantId].matchUpsWon;\n    const matchUpsLost = participantResults[participantId].matchUpsLost;\n    const matchUpsTotal = matchUpsWon + matchUpsLost;\n    let matchUpsPct = Math.round((matchUpsWon / matchUpsTotal) * 1000) / 1000;\n    if (matchUpsPct === Infinity || isNaN(matchUpsPct))\n      matchUpsPct = matchUpsWon;\n\n    const gamesWon = participantResults[participantId].gamesWon || 0;\n    const gamesLost = participantResults[participantId].gamesLost || 0;\n    const minimumExpectedGames =\n      (perPlayer || 0) * (bracketSetsToWin || 0) * (bracketGamesForSet || 0);\n    const gamesTotal = Math.max(minimumExpectedGames, gamesWon + gamesLost);\n    let gamesPct = Math.round((gamesWon / gamesTotal) * 1000) / 1000;\n    if (gamesPct === Infinity || isNaN(gamesPct)) gamesPct = 0;\n\n    let pointsPct =\n      Math.round(\n        (participantResults[participantId].pointsWon /\n          participantResults[participantId].pointsLost) *\n          1000\n      ) / 1000;\n    if (pointsPct === Infinity || isNaN(pointsPct)) pointsPct = 0;\n\n    participantResults[participantId].setsWon = setsWon;\n    participantResults[participantId].setsLost = setsLost;\n    participantResults[participantId].setsPct = setsPct;\n    participantResults[participantId].tieMatchUpsWon = tieMatchUpsWon;\n    participantResults[participantId].tieMatchUpsPct = tieMatchUpsPct;\n    participantResults[participantId].matchUpsPct = matchUpsPct;\n    participantResults[participantId].gamesWon = gamesWon;\n    participantResults[participantId].gamesLost = gamesLost;\n    participantResults[participantId].gamesPct = gamesPct;\n    participantResults[participantId].pointsPct = pointsPct;\n    participantResults[participantId].result =\n      `${participantResults[participantId].matchUpsWon}/${participantResults[participantId].matchUpsLost}`;\n  });\n}\n","type GetGroupsArgs = {\n  participantResults: any;\n  participantIds?: string[];\n  attribute: string;\n};\n\nexport function getGroups({\n  participantResults,\n  participantIds,\n  attribute,\n}: GetGroupsArgs) {\n  const resultsArray = getResultsArray({ participantResults, participantIds });\n  return resultsArray.reduce((groups, participantResult) => {\n    const { participantId, results } = participantResult;\n    const value = results?.[attribute];\n    if (!isNaN(value) && participantId) {\n      if (groups[value]) {\n        groups[value].push(participantId);\n      } else {\n        groups[value] = [participantId];\n      }\n    }\n    return groups;\n  }, {});\n}\n\ntype GetResultsArrayArgs = {\n  participantResults: any;\n  participantIds?: string[];\n};\n\nexport function getResultsArray(params: GetResultsArrayArgs) {\n  const participantIds =\n    params.participantIds || Object.keys(params.participantResults);\n  return participantIds.reduce((arr: any[], participantId: string, i) => {\n    arr.push({\n      participantId,\n      i,\n      results: params.participantResults[participantId],\n    });\n    return arr;\n  }, []);\n}\n","import { getParticipantResults } from './getParticipantResults';\nimport { instanceCount } from '../../../utilities/arrays';\nimport { getGroups, getResultsArray } from './getGroups';\nimport { isNumeric } from '../../../utilities/math';\n\n/*\nRound Robin group tally logic by default implements the following guidelines:\n\nThe participant who wins the most matches is the winner.\nIf two players are tied, then the winner of their head-to-head match is the winner.\n\nIf three or more players are tied, tie are broken as follows:\n The head-to-head win-loss record in matches involving just the tied players;\n The participant with the highest percentage of sets won of all sets completed;\n The head-to-head win-loss record in matches involving the players who remain tied;\n The participant with the highest percentage of games won of all games completed;\n The head-to-head win-loss record in matches involving the players who remain tied;\n The participant with the highest percentage of sets won of sets completed among players in the group under consideration;\n The head-to-head win-loss record in matches involving the players who remain tied;\n The participant with the highest percentage of games won of games completed among the players under consideration; and\n The head-to-head win-loss record in matches involving the players who remain tied.\n\nAfter initial separation of participants by `matchUpsWon`,\nthe implementation is configurable by supplying an array of `tallyDirectives` in the `tallyPolicy`.\n\nThe algorithm relies on the values avaialble in the calculated `participantResults` and works as follows:\n separate participants into groups by a given attribute\n a group with a single participant is 'resolved'\n groups of two participants are resolved by head-to-head (if not disabled/if participants faced each other)\n groups of three or more search for an attribute that will separate them into smaller groups\n participantResults scoped to the members of a group and recalculated when `{ idsFilter: true }`\n when { maxParticipants: 2 } is defined the rule is skipped if there are more than maxParticipants tied\n*/\n\nconst headToHeadTallyDirectives = [\n  { attribute: 'matchUpsPct', idsFilter: false },\n  { attribute: 'allDefaults', reversed: true, idsFilter: false },\n  { attribute: 'defaults', reversed: true, idsFilter: false },\n  { attribute: 'walkovers', reversed: true, idsFilter: false },\n  { attribute: 'retirements', reversed: true, idsFilter: false },\n  { attribute: 'setsPct', idsFilter: false },\n  { attribute: 'gamesPct', idsFilter: false },\n  { attribute: 'pointsPct', idsFilter: false },\n  { attribute: 'matchUpsPct', idsFilter: true },\n  { attribute: 'setsPct', idsFilter: true },\n  { attribute: 'gamesPct', idsFilter: true },\n  { attribute: 'pointsPct', idsFilter: true },\n];\n\n// defines offsets for generating large integer for comparison\nconst GEMScoreValueMap = {\n  matchUpsPct: 20,\n  tieMatchUpsPct: 16,\n  setsPct: 12,\n  gamesPct: 8,\n  pointsPct: 4,\n};\n\n/**\n *\n * @param {object[]} participantResults - calculated results for each participant\n * @param {number} participantsCount - number of participants in round robin group\n * @param {object} subOrderMap - { [participantId]: subOrder }\n *\n */\n\nexport function getGroupOrder(params) {\n  const {\n    requireCompletion = true,\n    participantResults,\n    subOrderMap,\n    tallyPolicy,\n  } = params;\n\n  const report: any[] = [];\n\n  // if not all opponents have completed their matchUps, no orders are assigned\n  if (requireCompletion && !isComplete(params)) {\n    return {};\n  }\n\n  const attribute = [\n    'tieMatchUpsWon',\n    'tieSinglesWon',\n    'tieDoublesWon',\n    'matchUpsWon',\n    'pointsWon',\n    'gamesWon',\n    'setsWon',\n    'gamesPct',\n    'setsPct',\n    'pointsPct',\n    'matchUpsPct',\n  ].includes(tallyPolicy?.groupOrderKey)\n    ? tallyPolicy.groupOrderKey\n    : 'matchUpsWon';\n\n  const orderedTallyGroups = getGroups({\n    participantResults,\n    attribute,\n  });\n\n  report.push({ attribute, groups: orderedTallyGroups });\n\n  const groupOrder = Object.keys(orderedTallyGroups)\n    .map((key) => parseFloat(key))\n    .sort((a, b) => b - a)\n    .map((key) => orderedTallyGroups[key])\n    .map((participantIds) => {\n      const result = groupSubSort({ participantIds, ...params });\n      report.push(...(result.report ?? []));\n      return result.order;\n    })\n    .flat(Infinity);\n\n  let groupPosition = 1;\n  let priorPositionResolution;\n  groupOrder.forEach((finishingPosition, index) => {\n    if (\n      // after the first position, which is always 1,\n      index &&\n      // increment group position if position is resolved\n      (finishingPosition.resolved ||\n        // increment group position if position is unresolved and prior position was resolved\n        (priorPositionResolution && !finishingPosition.resolved))\n    ) {\n      groupPosition += 1;\n    }\n    // update prior position resolution\n    priorPositionResolution = finishingPosition.resolved;\n\n    if (finishingPosition.resolved) {\n      // if a position is resolved, position is index + 1\n      finishingPosition.position = index + 1;\n      // if a position is resolved, update groupPosition\n      groupPosition = finishingPosition.position;\n    } else {\n      // if a position is unresovled, position is groupPosition\n      finishingPosition.position = groupPosition;\n    }\n  });\n\n  const positions = groupOrder.map(({ position }) => position);\n  const positionsCount = instanceCount(positions);\n\n  groupOrder.forEach((finishingPosition) => {\n    const { participantId, position } = finishingPosition || {};\n    const participantResult = participantResults[participantId];\n    finishingPosition.GEMscore = getRatioHash(participantResult);\n\n    const positionInstances = positionsCount[position];\n\n    if (finishingPosition?.position !== undefined) {\n      // subOrder is only assigned if there are ties\n      if (positionInstances > 1) {\n        finishingPosition.ties = positionInstances;\n        if (subOrderMap) {\n          finishingPosition.subOrder = subOrderMap[participantId];\n        }\n      }\n\n      finishingPosition.rankOrder = position;\n      finishingPosition.groupOrder =\n        position + (finishingPosition.subOrder || 1) - 1;\n    }\n  });\n\n  return { groupOrder, report: report.flat(Infinity).filter(Boolean) };\n\n  // NOTE: TallyPolicy.GEMscore could be an object instead of an array of attributes\n  // which would allow for custom valueMaps... or valueMap could use index as multiplier\n  function getRatioHash(result) {\n    const attributes = Array.isArray(tallyPolicy?.GEMscore)\n      ? Object.keys(GEMScoreValueMap).filter((attribute) =>\n          tallyPolicy.GEMscore.includes(attribute)\n        )\n      : Object.keys(GEMScoreValueMap);\n\n    const attributeValues = attributes.map(\n      (attribute) =>\n        (result[attribute] || 0) *\n        Math.pow(10, GEMScoreValueMap[attribute].toFixed(3))\n    );\n\n    return attributeValues.reduce((a, b) => a + b, 0);\n  }\n}\n\nfunction isComplete({ participantResults, participantsCount }) {\n  const resultsArray = getResultsArray({ participantResults });\n  const participantsFinished = resultsArray.filter(\n    (r) =>\n      participantsCount - 1 ===\n      r.results.matchUpsWon +\n        r.results.matchUpsLost +\n        r.results.matchUpsCancelled\n  );\n  return participantsCount === participantsFinished.length;\n}\n\nfunction processAttribute({\n  disableHeadToHead,\n  participantIds,\n  matchUpFormat,\n  tallyPolicy,\n  attribute,\n  idsFilter,\n  matchUps,\n  reversed, // reverses default which is greatest to least\n}) {\n  const { participantResults } = getParticipantResults({\n    participantIds: idsFilter && participantIds,\n    matchUpFormat,\n    tallyPolicy,\n    matchUps,\n  });\n\n  const groups = getGroups({\n    participantResults,\n    participantIds,\n    attribute,\n  });\n\n  const report: any[] = [{ attribute, reversed, groups, idsFilter }];\n  let order;\n\n  if (Object.keys(groups).length > 1 && participantIds.length) {\n    // separation by attribute was successful\n    order = Object.keys(groups)\n      .map((key) => parseFloat(key))\n      .sort((a, b) => (reversed ? a - b : b - a))\n      .map((key) => groups[key])\n      .map((participantIds) => {\n        const result = groupSubSort({\n          participantResults,\n          disableHeadToHead,\n          participantIds,\n          matchUpFormat,\n          tallyPolicy,\n          matchUps,\n        });\n        report.push(...(result.report ?? []));\n        return result.order;\n      })\n      .flat(Infinity);\n  }\n\n  return { order, report };\n}\n\nfunction groupSubSort({\n  participantResults,\n  disableHeadToHead,\n  participantIds,\n  matchUpFormat,\n  tallyPolicy,\n  matchUps,\n}) {\n  const excludedDirectives: any[] = [];\n  const report: any[] = [];\n  let result;\n\n  if (participantIds?.length === 1) {\n    const participantId = participantIds[0];\n    return {\n      order: [{ resolved: true, participantId }],\n    };\n  }\n  if (\n    participantIds?.length === 2 &&\n    (!tallyPolicy?.headToHead ||\n      (!tallyPolicy.headToHead.disabled && !disableHeadToHead))\n  ) {\n    const result = headToHeadWinner({ participantIds, participantResults });\n    if (result) {\n      const headToHeadWinner = result[0].participantId;\n      report.push({ attribute: 'head2Head', participantIds, headToHeadWinner });\n      return { order: [result], headToHeadWinner, report };\n    }\n  }\n\n  const directives = tallyPolicy?.tallyDirectives || headToHeadTallyDirectives;\n\n  const filteredDirectives = directives.filter((directive) => {\n    // if maxParticipants is defined, filter out the rule if # of participants is greater than maxParticipants\n    const keepDirective = !(\n      isNumeric(directive.maxParticipants) &&\n      participantIds?.length > directive.maxParticipants\n    );\n\n    if (!keepDirective) excludedDirectives.push(directive);\n    return keepDirective;\n  });\n\n  if (excludedDirectives.length)\n    report.push({ excludedDirectives, participantIds });\n\n  filteredDirectives.every(\n    ({ attribute, reversed, idsFilter, disableHeadToHead }) => {\n      result = processAttribute({\n        disableHeadToHead,\n        participantIds,\n        matchUpFormat,\n        tallyPolicy,\n        attribute,\n        idsFilter,\n        matchUps,\n        reversed,\n      });\n      report.push(result.report);\n\n      // return false if a rule has successfully broken the tie\n      return result.order ? false : true;\n    }\n  );\n\n  if (result.order) return { order: result.order, report };\n\n  return {\n    order: participantIds?.map((participantId) => ({ participantId })),\n    report,\n  };\n}\n\n// NOTE: This currently considers one victory rather than a head2head win/loss record (considering rounds of play where participants may encounter each other more than once)\nfunction headToHeadWinner({ participantIds, participantResults }) {\n  if (!participantIds) return;\n\n  if (\n    participantResults[participantIds[0]].victories.includes(participantIds[1])\n  ) {\n    return participantIds.map((participantId) => ({\n      resolved: true,\n      participantId,\n    }));\n  } else if (\n    participantResults[participantIds[1]].victories.includes(participantIds[0])\n  ) {\n    return participantIds\n      .reverse()\n      .map((participantId) => ({ resolved: true, participantId }));\n  }\n}\n","import { checkMatchUpIsComplete } from '../../matchUp/checkMatchUpIsComplete';\nimport { getDevContext } from '../../../global/state/globalState';\nimport { validMatchUps } from '../../../validators/validMatchUp';\nimport { getParticipantResults } from './getParticipantResults';\nimport { unique } from '../../../utilities/arrays';\nimport { getTallyReport } from './getTallyReport';\nimport { getGroupOrder } from './getGroupOrder';\n\nimport { POLICY_TYPE_ROUND_ROBIN_TALLY } from '../../../constants/policyConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { BYE } from '../../../constants/matchUpStatusConstants';\nimport { PolicyDefinitions } from '../../../types/factoryTypes';\nimport { TEAM } from '../../../constants/matchUpTypes';\nimport {\n  INVALID_VALUES,\n  MISSING_MATCHUPS,\n} from '../../../constants/errorConditionConstants';\n\ntype TallyParticipantResultsArgs = {\n  policyDefinitions?: PolicyDefinitions;\n  generateReport?: boolean;\n  matchUpFormat?: string;\n  perPlayer?: number;\n  subOrderMap?: any;\n  matchUps: any[];\n};\n\ntype TallyResultType = {\n  completedTieMatchUps?: boolean;\n  bracketComplete?: boolean;\n  participantResults?: any;\n  readableReport?: string;\n  report?: string[];\n  order?: any[];\n};\n\nexport function tallyParticipantResults({\n  policyDefinitions,\n  generateReport,\n  matchUpFormat,\n  matchUps = [],\n  subOrderMap,\n  perPlayer,\n}: TallyParticipantResultsArgs): TallyResultType & ResultType {\n  if (!validMatchUps(matchUps)) return { error: MISSING_MATCHUPS };\n\n  const structureIds = matchUps.reduce(\n    (structureIds, { structureId }) =>\n      structureIds.includes(structureId)\n        ? structureIds\n        : structureIds.concat(structureId),\n    []\n  );\n  if (structureIds.length !== 1)\n    return { error: INVALID_VALUES, info: 'Maximum one structureId' };\n\n  const relevantMatchUps = matchUps.filter(\n    (matchUp) => matchUp && matchUp.matchUpStatus !== BYE\n  );\n\n  const participantsCount =\n    relevantMatchUps.length &&\n    unique(relevantMatchUps.map(({ drawPositions }) => drawPositions).flat())\n      .length;\n\n  const bracketComplete =\n    relevantMatchUps.filter((matchUp) => checkMatchUpIsComplete({ matchUp }))\n      .length === relevantMatchUps.length;\n  // if bracket is incomplete don't use expected matchUps perPlayer for calculating\n  if (!bracketComplete) perPlayer = 0;\n\n  const completedTieMatchUps = matchUps.every(\n    ({ matchUpType, tieMatchUps }) =>\n      matchUpType === TEAM &&\n      tieMatchUps?.every((matchUp) => checkMatchUpIsComplete({ matchUp }))\n  );\n\n  const tallyPolicy = policyDefinitions?.[POLICY_TYPE_ROUND_ROBIN_TALLY];\n\n  const consideredMatchUps = matchUps.filter(\n    (matchUp) =>\n      checkMatchUpIsComplete({ matchUp }) || matchUp.matchUpType === TEAM\n  );\n  const { participantResults } = getParticipantResults({\n    matchUps: consideredMatchUps,\n    matchUpFormat,\n    tallyPolicy,\n    perPlayer,\n  });\n\n  let report, order;\n\n  const { groupOrder, report: groupOrderReport } = getGroupOrder({\n    matchUps: consideredMatchUps,\n    participantResults,\n    participantsCount,\n    matchUpFormat,\n    tallyPolicy,\n    subOrderMap,\n  });\n\n  // do not add groupOrder if bracket is not complete\n  if (bracketComplete && groupOrder) {\n    report = groupOrderReport;\n    order = groupOrder;\n\n    groupOrder.forEach((finishingPosition) => {\n      const { participantId, groupOrder, rankOrder, subOrder, ties, GEMscore } =\n        finishingPosition;\n      const participantResult = participantResults[participantId];\n      Object.assign(participantResult, {\n        groupOrder,\n        rankOrder,\n        GEMscore,\n        subOrder,\n        ties,\n      });\n    });\n  } else {\n    const { groupOrder: provisionalOrder, report: provisionalOrderReport } =\n      getGroupOrder({\n        requireCompletion: false,\n        participantResults,\n        participantsCount,\n        matchUpFormat,\n        tallyPolicy,\n        subOrderMap,\n        matchUps,\n      });\n\n    report = provisionalOrderReport;\n    order = provisionalOrder;\n\n    if (provisionalOrder) {\n      provisionalOrder.forEach((finishingPosition) => {\n        const { participantId, groupOrder, GEMscore } = finishingPosition;\n        const participantResult = participantResults[participantId];\n        Object.assign(participantResult, {\n          provisionalOrder: groupOrder,\n          GEMscore,\n        });\n      });\n    }\n  }\n\n  const result = {\n    completedTieMatchUps,\n    readableReport: '',\n    participantResults,\n    bracketComplete,\n    order: [],\n    report,\n  };\n\n  if (bracketComplete || completedTieMatchUps) {\n    result.order = order;\n  }\n\n  if (generateReport || getDevContext({ tally: true })) {\n    const readable = getTallyReport({ matchUps, report, order });\n    if (getDevContext({ tally: true })) console.log(readable);\n    result.readableReport = readable;\n  }\n\n  return result;\n}\n","export function getTallyReport({ matchUps, order, report }) {\n  const participants = {};\n\n  matchUps.forEach(({ sides }) => {\n    sides.forEach((side) => {\n      if (side.participantId && side.participant) {\n        participants[side.participantId] = side.participant.participantName;\n      }\n    });\n  });\n\n  const readable: string[] = [];\n\n  if (Array.isArray(report)) {\n    report.forEach((step, i) => {\n      if (step.excludedDirectives?.length) {\n        const attributes = step.excludedDirectives\n          .map(({ attribute }) => attribute)\n          .join(', ');\n        const note = `${attributes.length} directives were excluded due to participants limit}`;\n        readable.push(note);\n        const excluded = `Excluded: ${attributes}`;\n        readable.push(excluded);\n      } else {\n        const floatSort = (a, b) =>\n          parseFloat(step.reversed ? a : b) - parseFloat(step.reversed ? b : a);\n\n        const participantsCount = step.groups\n          ? Object.values(step.groups).flat(Infinity).length\n          : step.participantIds?.length ?? 0;\n\n        const getExplanation = (step) => {\n          step.groups &&\n            Object.keys(step.groups)\n              .sort(floatSort)\n              .forEach((key) => {\n                const participantNames = step.groups[key]\n                  .map((participantId) => participants[participantId])\n                  .join(', ');\n                const explanation = `${key} ${step.attribute}: ${participantNames}`;\n                readable.push(explanation);\n              });\n        };\n\n        const reversed = step.reversed ? ' in reverse order' : '';\n\n        const action = step.groups ? 'grouped' : 'separated';\n        const description = `Step ${\n          i + 1\n        }: ${participantsCount} particiants were ${action}${reversed} by ${\n          step.attribute\n        }`;\n        readable.push(description);\n        if (step.idsFilter) {\n          const note = `${step.attribute} was calculated considering ONLY TIED PARTICIPANTS`;\n          readable.push(note);\n        }\n        getExplanation(step);\n      }\n      readable.push('----------------------');\n    });\n  }\n\n  readable.push('Final Order:');\n  order.forEach((orderEntry) => {\n    const { participantId, resolved } = orderEntry;\n    const pOrder = orderEntry.groupOrder || orderEntry.provisionalOrder;\n    readable.push(\n      `${pOrder}: ${participants[participantId]} => resolved: ${!!resolved}`\n    );\n  });\n\n  return readable.join('\\r\\n');\n}\n","import { isConvertableInteger } from '../../../utilities/math';\n\nimport {\n  COMPLETED,\n  completedMatchUpStatuses,\n} from '../../../constants/matchUpStatusConstants';\n\nexport function evaluateCollectionResult({\n  collectionDefinition,\n  groupValueNumbers,\n  groupValueGroups,\n  sideTieValues,\n  tieMatchUps,\n}) {\n  const collectionMatchUps = tieMatchUps.filter(\n    (matchUp) => matchUp.collectionId === collectionDefinition.collectionId\n  );\n\n  // keep track of the values derived from matchUps\n  const sideMatchUpValues: number[] = [0, 0];\n  // will be equivalent to sideMatchUpValues unless there is a collectionValue,\n  // in which case the sideMatchUpValues are used in comparision with winCriteria\n  let sideCollectionValues: number[] = [0, 0];\n\n  const allCollectionMatchUpsCompleted = collectionMatchUps.every((matchUp) =>\n    completedMatchUpStatuses.includes(matchUp.matchUpStatus)\n  );\n\n  const {\n    collectionValueProfiles,\n    collectionGroupNumber,\n    collectionValue,\n    matchUpValue,\n    winCriteria,\n    scoreValue,\n    setValue,\n  } = collectionDefinition;\n\n  const belongsToValueGroup =\n    collectionGroupNumber && groupValueNumbers.includes(collectionGroupNumber);\n\n  const sideWins = [0, 0];\n  collectionMatchUps.forEach((matchUp) => {\n    if (matchUp.winningSide) sideWins[matchUp.winningSide - 1] += 1;\n  });\n\n  if (isConvertableInteger(matchUpValue)) {\n    // if tiebreak set count as set value and game value\n    collectionMatchUps.forEach((matchUp) => {\n      if (matchUp.winningSide) {\n        sideMatchUpValues[matchUp.winningSide - 1] += matchUpValue;\n      }\n    });\n  } else if (isConvertableInteger(setValue)) {\n    collectionMatchUps.forEach((matchUp) => {\n      matchUp.score?.sets?.forEach((set) => {\n        if (set.winningSide) sideMatchUpValues[set.winningSide - 1] += setValue;\n      });\n    });\n  } else if (isConvertableInteger(scoreValue)) {\n    collectionMatchUps.forEach((matchUp) => {\n      matchUp.score?.sets?.forEach((set) => {\n        const {\n          side1TiebreakScore = 0,\n          side2TiebreakScore = 0,\n          side1Score = 0,\n          side2Score = 0,\n        } = set;\n\n        if (\n          matchUp.matchUpStatus === COMPLETED ||\n          matchUp.winningSide ||\n          set.winningSide\n        ) {\n          if (side1Score || side2Score) {\n            sideMatchUpValues[0] += side1Score;\n            sideMatchUpValues[1] += side2Score;\n          } else if (\n            (side1TiebreakScore || side2TiebreakScore) &&\n            set.winningSide\n          ) {\n            sideMatchUpValues[set.winningSide - 1] += 1;\n          }\n        }\n      });\n    });\n  } else if (Array.isArray(collectionValueProfiles)) {\n    // this must come last because it will be true for []\n    collectionMatchUps.forEach((matchUp) => {\n      if (matchUp.winningSide) {\n        const collectionPosition = matchUp.collectionPosition;\n        const matchUpValue = getCollectionPositionValue({\n          collectionDefinition,\n          collectionPosition,\n        });\n\n        if (isConvertableInteger(matchUpValue)) {\n          sideMatchUpValues[matchUp.winningSide - 1] += matchUpValue;\n        }\n      }\n    });\n  }\n\n  // processed separately so that setValue, scoreValue and collecitonValueProfile can be used in conjunction with collectionValue\n  if (isConvertableInteger(collectionValue)) {\n    let collectionWinningSide;\n\n    if (winCriteria?.aggregateValue) {\n      if (allCollectionMatchUpsCompleted) {\n        if (\n          isConvertableInteger(matchUpValue || setValue || scoreValue) &&\n          sideMatchUpValues[0] !== sideMatchUpValues[1]\n        ) {\n          collectionWinningSide =\n            sideMatchUpValues[0] > sideMatchUpValues[1] ? 1 : 2;\n        } else if (sideWins[0] !== sideWins[1]) {\n          collectionWinningSide = sideWins[0] > sideWins[1] ? 1 : 2;\n        }\n      }\n    } else if (winCriteria?.valueGoal) {\n      collectionWinningSide = sideMatchUpValues.reduce(\n        (winningSide, side, i) => {\n          return side >= winCriteria.valueGoal ? i + 1 : winningSide;\n        },\n        0\n      );\n    } else {\n      const winGoal = Math.floor(collectionDefinition.matchUpCount / 2) + 1;\n\n      collectionWinningSide = sideWins.reduce((winningSide, side, i) => {\n        return side >= winGoal ? i + 1 : winningSide;\n      }, 0);\n    }\n\n    if (collectionWinningSide) {\n      if (belongsToValueGroup) {\n        groupValueGroups[collectionGroupNumber].values[\n          collectionWinningSide - 1\n        ] += collectionValue;\n      } else {\n        sideCollectionValues[collectionWinningSide - 1] += collectionValue;\n      }\n    }\n  } else if (belongsToValueGroup) {\n    groupValueGroups[collectionGroupNumber].values[0] +=\n      sideMatchUpValues[0] || 0;\n    groupValueGroups[collectionGroupNumber].values[1] +=\n      sideMatchUpValues[1] || 0;\n  } else {\n    sideCollectionValues = sideMatchUpValues;\n  }\n\n  if (!belongsToValueGroup) {\n    sideCollectionValues.forEach(\n      (sideCollectionValue, i) => (sideTieValues[i] += sideCollectionValue || 0)\n    );\n  } else {\n    groupValueGroups[collectionGroupNumber].sideWins[0] += sideWins[0] || 0;\n    groupValueGroups[collectionGroupNumber].sideWins[1] += sideWins[1] || 0;\n    groupValueGroups[collectionGroupNumber].allGroupMatchUpsCompleted =\n      groupValueGroups[collectionGroupNumber].allGroupMatchUpsCompleted &&\n      allCollectionMatchUpsCompleted;\n    groupValueGroups[collectionGroupNumber].matchUpsCount +=\n      collectionMatchUps.length;\n  }\n}\n\nfunction getCollectionPositionValue({\n  collectionDefinition,\n  collectionPosition,\n}) {\n  const collectionValueProfiles =\n    collectionDefinition.collectionValueProfiles || [];\n  const profile = collectionValueProfiles?.find(\n    (profile) => profile.collectionPosition === collectionPosition\n  );\n  return profile?.matchUpValue;\n}\n","import { resolveTieFormat } from '../../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { validateTieFormat } from '../../../validators/validateTieFormat';\nimport { tallyParticipantResults } from '../../../query/matchUps/roundRobinTally/roundRobinTally';\nimport { completedMatchUpStatuses } from '../../../constants/matchUpStatusConstants';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { evaluateCollectionResult } from './evaluateCollectionResult';\nimport { getGroupValueGroups } from '../drawDefinitions/getGroupValueGroups';\n\nimport {\n  INVALID_VALUES,\n  MISSING_MATCHUP,\n  MISSING_TIE_FORMAT,\n} from '../../../constants/errorConditionConstants';\n\nimport { MatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  DrawDefinition,\n  Event,\n  Structure,\n  TieFormat,\n} from '../../../types/tournamentTypes';\n\n/**\n * Calculates the number of wins per side and winningSide. When provided with `sideAdjustments`\n * will calculate prjected score and winningSide which is necessary for checking validity of score\n */\n\ntype TieMatchUpScore = {\n  scoreStringSide1?: string;\n  scoreStringSide2?: string;\n  winningSide?: number;\n  set?: any;\n};\n\ntype GenerateTieMatchUpScoreArgs = {\n  sideAdjustments?: [number, number];\n  drawDefinition?: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  matchUp: HydratedMatchUp;\n  structure?: Structure;\n  tieFormat?: TieFormat;\n  separator?: string;\n  event?: Event;\n};\n\nexport function generateTieMatchUpScore(\n  params: GenerateTieMatchUpScoreArgs\n): TieMatchUpScore & ResultType {\n  const {\n    sideAdjustments = [0, 0], // currently unused?\n    separator = '-',\n    drawDefinition,\n    matchUpsMap,\n    structure,\n    matchUp,\n    event,\n  } = params;\n\n  if (\n    !Array.isArray(sideAdjustments) ||\n    sideAdjustments.length !== 2 ||\n    isNaN(sideAdjustments.reduce((a, b) => a + b))\n  ) {\n    return { error: INVALID_VALUES };\n  }\n\n  if (!matchUp) return { error: MISSING_MATCHUP };\n  const tieFormat =\n    resolveTieFormat({ matchUp, drawDefinition, structure, event })\n      ?.tieFormat || params?.tieFormat;\n\n  if (!tieFormat) return { error: MISSING_TIE_FORMAT };\n\n  const result = validateTieFormat({ tieFormat });\n  if (result.error) return result;\n\n  const collectionDefinitions = tieFormat?.collectionDefinitions || [];\n  const tieMatchUps = matchUp?.tieMatchUps ?? [];\n  const sideTieValues = [0, 0];\n\n  const { groupValueGroups, groupValueNumbers } =\n    getGroupValueGroups(tieFormat);\n\n  for (const collectionDefinition of collectionDefinitions) {\n    evaluateCollectionResult({\n      collectionDefinition,\n      groupValueNumbers,\n      groupValueGroups,\n      sideTieValues,\n      tieMatchUps,\n    });\n  }\n\n  // process each relevant group for groupValue\n  for (const groupNumber of groupValueNumbers) {\n    const group = groupValueGroups[groupNumber];\n    const {\n      allGroupMatchUpsCompleted,\n      matchUpCount,\n      winCriteria,\n      groupValue,\n      sideWins,\n      values,\n    } = group;\n\n    let groupWinningSide;\n\n    if (winCriteria?.aggregateValue) {\n      if (allGroupMatchUpsCompleted && values[0] !== values[1]) {\n        groupWinningSide = values[0] > values[1] ? 1 : 2;\n      }\n    } else if (winCriteria?.valueGoal) {\n      groupWinningSide = values.reduce((winningSide, side, i) => {\n        return side >= winCriteria.valueGoal ? i + 1 : winningSide;\n      }, undefined);\n    } else {\n      const winGoal = Math.floor(matchUpCount / 2) + 1;\n      groupWinningSide = sideWins.reduce((winningSide, side, i) => {\n        return side >= winGoal ? i + 1 : winningSide;\n      }, undefined);\n    }\n\n    if (groupWinningSide) {\n      sideTieValues[groupWinningSide - 1] += groupValue || 0;\n    }\n  }\n\n  const sideScores = sideTieValues.map(\n    (sideTieValue, i) => (sideTieValue || 0) + sideAdjustments[i]\n  );\n\n  const set = {\n    side1Score: sideScores[0],\n    side2Score: sideScores[1],\n    winningSide: undefined,\n  };\n  const scoreStringSide1 = sideScores.join(separator);\n  const scoreStringSide2 = sideScores.slice().reverse().join(separator);\n\n  // now calculate if there is a winningSide\n  let winningSide;\n  if (tieFormat?.winCriteria) {\n    const { valueGoal, aggregateValue, tallyDirectives } =\n      tieFormat.winCriteria;\n    if (valueGoal) {\n      const sideThatWon = sideScores\n        .map((points, sideIndex) => ({ sideNumber: sideIndex + 1, points }))\n        .find(({ points }) => points >= valueGoal);\n      winningSide = sideThatWon?.sideNumber;\n    } else if (aggregateValue) {\n      const allTieMatchUpsCompleted = tieMatchUps.every(\n        (matchUp) =>\n          (matchUp.matchUpStatus &&\n            completedMatchUpStatuses.includes(matchUp.matchUpStatus)) ||\n          matchUp.winningSide\n      );\n      if (allTieMatchUpsCompleted && sideScores[0] !== sideScores[1]) {\n        winningSide = sideScores[0] > sideScores[1] ? 1 : 2;\n      }\n    }\n\n    if (!winningSide && tallyDirectives) {\n      const matchUpId = matchUp.matchUpId;\n      const inContextMatchUp = matchUp.hasContext\n        ? matchUp\n        : matchUpsMap?.drawMatchUps?.[matchUpId] ||\n          (drawDefinition &&\n            findDrawMatchUp({\n              inContext: true,\n              drawDefinition,\n              matchUpId,\n            })?.matchUp);\n\n      if (inContextMatchUp) {\n        const { completedTieMatchUps, order } = tallyParticipantResults({\n          matchUps: [inContextMatchUp],\n        });\n        if (completedTieMatchUps && order?.length) {\n          const winningParticipantId = order[0].participantId;\n          winningSide = inContextMatchUp.sides.find(\n            ({ participantId }) => participantId === winningParticipantId\n          )?.sideNumber;\n        }\n      }\n    }\n  }\n\n  if (winningSide) set.winningSide = winningSide;\n\n  return {\n    scoreStringSide1,\n    scoreStringSide2,\n    winningSide,\n    set,\n  };\n}\n","import { TO_BE_PLAYED } from '../../../constants/matchUpStatusConstants';\n\nexport const toBePlayed = {\n  matchUpStatus: TO_BE_PLAYED,\n  matchUpStatusCodes: [],\n  score: {\n    scoreStringSide1: '',\n    scoreStringSide2: '',\n    sets: undefined,\n  },\n  matchUpFormat: undefined,\n  winningSide: undefined,\n};\n","import { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { getInitialRoundNumber } from '../../../query/matchUps/getInitialRoundNumber';\nimport {\n  MatchUpsMap,\n  getMatchUpsMap,\n} from '../../../query/matchUps/getMatchUpsMap';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { updateMatchUpStatusCodes } from '../../drawDefinitions/matchUpGovernor/matchUpStatusCodes';\nimport { findStructure } from '../../../acquire/findStructure';\n\nimport { CONTAINER } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  BYE,\n  DEFAULTED,\n  TO_BE_PLAYED,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype RemoveSubsequentDrawPositionArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  dualMatchUp?: HydratedMatchUp;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  sourceMatchUpStatus?: string;\n  targetDrawPosition: number;\n  matchUpsMap?: MatchUpsMap;\n  sourceMatchUpId?: string;\n  roundNumber: number;\n  structureId: string;\n  event?: Event;\n};\nexport function removeSubsequentRoundsParticipant({\n  inContextDrawMatchUps,\n  sourceMatchUpStatus,\n  targetDrawPosition,\n  tournamentRecord,\n  sourceMatchUpId,\n  drawDefinition,\n  structureId,\n  dualMatchUp,\n  roundNumber,\n  matchUpsMap,\n  event,\n}: RemoveSubsequentDrawPositionArgs) {\n  const { structure } = findStructure({ drawDefinition, structureId });\n  if (structure?.structureType === CONTAINER) return { ...SUCCESS };\n\n  matchUpsMap = matchUpsMap ?? getMatchUpsMap({ drawDefinition });\n  const mappedMatchUps = matchUpsMap?.mappedMatchUps || {};\n  const matchUps = mappedMatchUps[structureId].matchUps;\n\n  const { initialRoundNumber } = getInitialRoundNumber({\n    drawPosition: targetDrawPosition,\n    matchUps,\n  });\n\n  const relevantMatchUps = matchUps?.filter(\n    (matchUp: any) =>\n      matchUp.roundNumber >= roundNumber &&\n      matchUp.roundNumber !== initialRoundNumber &&\n      matchUp.drawPositions?.includes(targetDrawPosition)\n  );\n\n  const { positionAssignments } = getPositionAssignments({\n    drawDefinition,\n    structureId,\n  });\n\n  for (const matchUp of relevantMatchUps ?? []) {\n    removeDrawPosition({\n      inContextDrawMatchUps,\n      sourceMatchUpStatus,\n      positionAssignments,\n      targetDrawPosition,\n      tournamentRecord,\n      sourceMatchUpId,\n      drawDefinition,\n      dualMatchUp,\n      matchUpsMap,\n      matchUp,\n      event,\n    });\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction removeDrawPosition({\n  inContextDrawMatchUps,\n  positionAssignments,\n  sourceMatchUpStatus,\n  targetDrawPosition,\n  tournamentRecord,\n  sourceMatchUpId,\n  drawDefinition,\n  dualMatchUp,\n  matchUpsMap,\n  matchUp,\n  event,\n}) {\n  const stack = 'removeSubsequentDrawPosition';\n\n  if (dualMatchUp) {\n    // remove propagated lineUp\n    const inContextMatchUp = inContextDrawMatchUps.find(\n      ({ matchUpId }) => matchUp.matchUpId === matchUpId\n    );\n    const targetSideNumber = inContextMatchUp.sides?.find(\n      (side) => side.drawPosition === targetDrawPosition\n    )?.sideNumber;\n    const targetSide = matchUp.sides?.find(\n      (side) => side.sideNumber === targetSideNumber\n    );\n    if (targetSide) {\n      delete targetSide.lineUp;\n    }\n  }\n\n  matchUp.drawPositions = (matchUp.drawPositions || [])\n    .map((drawPosition) =>\n      drawPosition === targetDrawPosition ? undefined : drawPosition\n    )\n    .filter(Boolean);\n  const matchUpAssignments = positionAssignments.filter(\n    ({ drawPosition }) => matchUp.drawPositions?.includes(drawPosition)\n  );\n  const matchUpContainsBye = matchUpAssignments.filter(\n    (assignment) => assignment.bye\n  ).length;\n\n  matchUp.matchUpStatus =\n    (matchUpContainsBye && BYE) ||\n    ([DEFAULTED, WALKOVER].includes(matchUp.matchUpStatus) &&\n      matchUp.matchUpStatus) ||\n    TO_BE_PLAYED;\n\n  // if the matchUpStatus is WALKOVER then it is DOUBLE_WALKOVER produced\n  // ... and the winningSide must be removed\n  if ([WALKOVER, DEFAULTED].includes(matchUp.matchUpStatus))\n    matchUp.winningSide = undefined;\n\n  if (matchUp.matchUpStatusCodes) {\n    updateMatchUpStatusCodes({\n      inContextDrawMatchUps,\n      sourceMatchUpStatus,\n      sourceMatchUpId,\n      matchUpsMap,\n      matchUp,\n    });\n  }\n\n  modifyMatchUpNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    eventId: event?.eventId,\n    context: `${stack}-${targetDrawPosition}`,\n    drawDefinition,\n    matchUp,\n  });\n\n  return { ...SUCCESS };\n}\n","import { getEventIdsAndDrawIds } from '../query/tournaments/getEventIdsAndDrawIds';\n\nimport { TournamentRecords } from '../types/factoryTypes';\n\ntype FindTournamentIdArgs = {\n  tournamentRecords: TournamentRecords;\n  eventId?: string;\n  drawId?: string;\n};\nexport function findTournamentId({\n  tournamentRecords,\n  eventId,\n  drawId,\n}: FindTournamentIdArgs): string | undefined {\n  const { tournamentIdMap } = getEventIdsAndDrawIds({ tournamentRecords });\n  const tournamentIds: string[] = tournamentIdMap\n    ? Object.keys(tournamentIdMap)\n    : [];\n  return tournamentIds.find(\n    (tournamentId) =>\n      (eventId && tournamentIdMap?.[tournamentId].includes(eventId)) ||\n      (drawId && tournamentIdMap?.[tournamentId].includes(drawId))\n  );\n}\n","import { tallyParticipantResults } from '../../../query/matchUps/roundRobinTally/roundRobinTally';\nimport { getPolicyDefinitions } from '../../../query/extensions/getAppliedPolicies';\nimport { modifyDrawNotice } from '../../notifications/drawNotifications';\nimport { removeExtension } from '../../extensions/removeExtension';\nimport { addExtension } from '../../extensions/addExtension';\nimport { validMatchUps } from '../../../validators/validMatchUp';\nimport { createSubOrderMap } from './createSubOrderMap';\n\nimport { POLICY_TYPE_ROUND_ROBIN_TALLY } from '../../../constants/policyConstants';\nimport { INVALID_VALUES } from '../../../constants/errorConditionConstants';\nimport { SUB_ORDER, TALLY } from '../../../constants/extensionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\nexport function updateAssignmentParticipantResults({\n  positionAssignments,\n  tournamentRecord,\n  drawDefinition,\n  matchUpFormat,\n  matchUps,\n  event,\n}) {\n  if (!validMatchUps(matchUps)) return { error: INVALID_VALUES };\n  if (!positionAssignments) return { error: INVALID_VALUES };\n\n  const { policyDefinitions } = getPolicyDefinitions({\n    policyTypes: [POLICY_TYPE_ROUND_ROBIN_TALLY],\n    tournamentRecord,\n    drawDefinition,\n    event,\n  });\n  const { subOrderMap } = createSubOrderMap({ positionAssignments });\n\n  const result = tallyParticipantResults({\n    policyDefinitions,\n    matchUpFormat,\n    subOrderMap,\n    matchUps,\n  });\n  if (result.error) return result;\n\n  const { participantResults, bracketComplete, report } = result;\n\n  const participantIds = Object.keys(participantResults);\n\n  positionAssignments.forEach((assignment) => {\n    const { participantId } = assignment;\n    if (participantIds.includes(participantId)) {\n      const extension = {\n        value: participantResults[participantId],\n        name: TALLY,\n      };\n      addExtension({ element: assignment, extension });\n      if (!participantResults[participantId].ties) {\n        removeExtension({\n          element: assignment,\n          name: SUB_ORDER,\n        });\n      }\n    } else {\n      removeExtension({\n        element: assignment,\n        name: TALLY,\n      });\n      removeExtension({\n        element: assignment,\n        name: SUB_ORDER,\n      });\n    }\n  });\n\n  modifyDrawNotice({ drawDefinition });\n\n  return {\n    ...SUCCESS,\n    participantResults,\n    bracketComplete,\n    report,\n  };\n}\n","import { xa } from '../../../utilities/objects';\nimport { findExtension } from '../../../acquire/findExtension';\nimport { instanceCount } from '../../../utilities/arrays';\nimport { ensureInt } from '../../../utilities/ensureInt';\n\nimport { PARTICIPANT_ID } from '../../../constants/attributeConstants';\nimport { SUB_ORDER } from '../../../constants/extensionConstants';\n\nexport function createSubOrderMap({ positionAssignments }) {\n  const subOrderArray = (positionAssignments || [])\n    .filter(xa(PARTICIPANT_ID))\n    .map((assignment) => {\n      const { extension } = findExtension({\n        element: assignment,\n        name: SUB_ORDER,\n      });\n      const value = ensureInt(extension?.value);\n      const subOrder = !isNaN(value) && value;\n      return subOrder && { participantId: assignment.participantId, subOrder };\n    })\n    .filter(Boolean);\n\n  // we only want subOrders that are unique, and we want them sorted and re-assigned to ordered values\n  const subOrders = subOrderArray.map(({ subOrder }) => subOrder);\n  const subOrdersCount = instanceCount(subOrders);\n\n  const subOrderMap = Object.assign(\n    {},\n    ...subOrderArray\n      .filter(({ subOrder }) => subOrdersCount[subOrder] === 1)\n      .map(({ participantId, subOrder }) => ({\n        [participantId]: subOrder,\n      })),\n  );\n\n  return { subOrderMap };\n}\n","import { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\nexport function addNotes(params?) {\n  if (typeof params !== 'object') return { error: MISSING_VALUE };\n  if (typeof params.element !== 'object') return { error: INVALID_VALUES };\n  if (!params.notes) return { error: MISSING_VALUE };\n\n  if (typeof params.notes !== 'string' && !params.notes?.testing)\n    return { error: INVALID_VALUES };\n\n  Object.assign(params.element, { notes: params.notes });\n\n  return { ...SUCCESS };\n}\n\nexport function removeNotes(params?) {\n  if (typeof params !== 'object') return { error: MISSING_VALUE };\n  if (typeof params.element !== 'object') return { error: INVALID_VALUES };\n\n  if (params.element.notes) delete params.element.notes;\n\n  return { ...SUCCESS };\n}\n","import { updateAssignmentParticipantResults } from '../../drawDefinitions/matchUpGovernor/updateAssignmentParticipantResults';\nimport { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { checkScoreHasValue } from '../../../query/matchUp/checkScoreHasValue';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { toBePlayed } from '../../../fixtures/scoring/outcomes/toBePlayed';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { getMatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { getTopics } from '../../../global/state/globalState';\nimport { isAdHoc } from '../../../query/drawDefinition/isAdHoc';\nimport { isLucky } from '../../../query/drawDefinition/isLucky';\nimport { addNotes } from '../../base/addRemoveNotes';\nimport { unique } from '../../../utilities/arrays';\nimport {\n  modifyMatchUpNotice,\n  updateInContextMatchUp,\n} from '../../notifications/drawNotifications';\n\nimport { MATCHUP_NOT_FOUND } from '../../../constants/errorConditionConstants';\nimport { UPDATE_INCONTEXT_MATCHUP } from '../../../constants/topicConstants';\nimport { POLICY_TYPE_SCORING } from '../../../constants/policyConstants';\nimport { CONTAINER } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { TEAM } from '../../../constants/matchUpTypes';\nimport {\n  AWAITING_RESULT,\n  completedMatchUpStatuses,\n  DOUBLE_WALKOVER,\n  SUSPENDED,\n  DEFAULTED,\n  WALKOVER,\n  IN_PROGRESS,\n} from '../../../constants/matchUpStatusConstants';\nimport {\n  DrawDefinition,\n  Event,\n  MatchUp,\n  MatchUpStatusUnion,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\n/**\n *\n * Single place where matchUp.score can be modified.\n *\n * Mutates passed matchUp object.\n * Moving forward this will be used for integrity checks and any middleware that needs to execute\n *\n */\n\ntype ModifyMatchUpScoreArgs = {\n  matchUpStatus?: MatchUpStatusUnion;\n  tournamentRecord?: Tournament;\n  matchUpStatusCodes?: string[];\n  drawDefinition?: DrawDefinition;\n  removeWinningSide?: boolean;\n  matchUpFormat?: string;\n  removeScore?: boolean;\n  winningSide?: number;\n  matchUpId: string;\n  matchUp: MatchUp; // matchUp without context\n  notes?: string;\n  event?: Event;\n  score?: any;\n};\n\nexport function modifyMatchUpScore({\n  matchUpStatusCodes,\n  removeWinningSide,\n  tournamentRecord,\n  drawDefinition,\n  matchUpFormat,\n  matchUpStatus,\n  removeScore,\n  winningSide,\n  matchUpId,\n  matchUp, // matchUp without context\n  event,\n  notes,\n  score,\n}: ModifyMatchUpScoreArgs) {\n  const stack = 'modifyMatchUpScore';\n  let structure;\n\n  const isDualMatchUp = matchUp.matchUpType === TEAM;\n\n  if (isDualMatchUp && drawDefinition) {\n    if (matchUpId && matchUp.matchUpId !== matchUpId) {\n      // the modification is to be applied to a tieMatchUp\n      const findResult = findDrawMatchUp({\n        drawDefinition,\n        matchUpId,\n        event,\n      });\n      if (!findResult.matchUp) return { error: MATCHUP_NOT_FOUND };\n      ({ matchUp, structure } = findResult);\n    } else {\n      // the modification is to be applied to the TEAM matchUp\n    }\n  } else if (matchUp.matchUpId !== matchUpId) {\n    console.log('!!!!!');\n  }\n\n  if (\n    (matchUpStatus && [WALKOVER, DOUBLE_WALKOVER].includes(matchUpStatus)) ||\n    removeScore\n  ) {\n    Object.assign(matchUp, { ...toBePlayed });\n  } else if (score) {\n    matchUp.score = score;\n  }\n\n  const wasDefaulted =\n    matchUpStatus &&\n    matchUp?.matchUpStatus === DEFAULTED &&\n    matchUpStatus !== DEFAULTED;\n\n  if (matchUpStatus) matchUp.matchUpStatus = matchUpStatus;\n  if (matchUpFormat) matchUp.matchUpFormat = matchUpFormat;\n  if (matchUpStatusCodes) matchUp.matchUpStatusCodes = matchUpStatusCodes;\n  if (winningSide) matchUp.winningSide = winningSide;\n  if (removeWinningSide) matchUp.winningSide = undefined;\n\n  if (!structure && drawDefinition) {\n    ({ structure } = findDrawMatchUp({\n      drawDefinition,\n      matchUpId,\n      event,\n    }));\n  }\n\n  if (\n    matchUpStatus &&\n    !matchUp.winningSide &&\n    checkScoreHasValue(matchUp) &&\n    !completedMatchUpStatuses.includes(matchUpStatus) &&\n    ![AWAITING_RESULT, SUSPENDED].includes(matchUpStatus)\n  ) {\n    matchUp.matchUpStatus = IN_PROGRESS;\n  }\n\n  let defaultedProcessCodes;\n  if (\n    (wasDefaulted && matchUp?.processCodes?.length) ||\n    matchUpStatus === DEFAULTED\n  ) {\n    const appliedPolicies = getAppliedPolicies({\n      tournamentRecord,\n      drawDefinition,\n      structure,\n      event,\n    })?.appliedPolicies;\n\n    defaultedProcessCodes =\n      appliedPolicies?.[POLICY_TYPE_SCORING]?.processCodes\n        ?.incompleteAssignmentsOnDefault;\n  }\n\n  if (!matchUp.collectionId) {\n    const isRoundRobin = structure?.structureType === CONTAINER;\n    const isAdHocStructure = isAdHoc({ drawDefinition, structure });\n    if (\n      isLucky({ drawDefinition, structure }) ||\n      isAdHocStructure ||\n      isRoundRobin\n    ) {\n      const updateTally = (structure) => {\n        // matchUpFormat set here is only used in updateAssignmentParticipantResults\n        matchUpFormat = isDualMatchUp\n          ? 'SET1-S:T100'\n          : matchUpFormat ??\n            matchUp.matchUpFormat ??\n            structure?.matchUpFormat ??\n            drawDefinition?.matchUpFormat ??\n            event?.matchUpFormat;\n\n        const matchUpFilters = isDualMatchUp\n          ? { matchUpTypes: [TEAM] }\n          : undefined;\n        const { matchUps } = getAllStructureMatchUps({\n          afterRecoveryTimes: false,\n          tournamentRecord,\n          inContext: true,\n          matchUpFilters,\n          drawDefinition,\n          structure,\n          event,\n        });\n\n        if (isAdHocStructure) {\n          structure.positionAssignments = unique(\n            matchUps\n              .flatMap((matchUp) =>\n                (matchUp.sides ?? []).map((side) => side.participantId)\n              )\n              .filter(Boolean)\n          ).map((participantId) => ({ participantId }));\n        }\n\n        return updateAssignmentParticipantResults({\n          positionAssignments: structure.positionAssignments,\n          tournamentRecord,\n          drawDefinition,\n          matchUpFormat,\n          matchUps,\n          event,\n        });\n      };\n\n      const itemStructure =\n        isRoundRobin &&\n        structure.structures.find((itemStructure) => {\n          return itemStructure?.matchUps.find(\n            (matchUp) => matchUp.matchUpId === matchUpId\n          );\n        });\n\n      const result = updateTally(itemStructure || structure);\n      if (result.error) return decorateResult({ result, stack });\n    }\n  }\n\n  if (notes) {\n    const result = addNotes({ element: matchUp, notes });\n    if (result.error) return decorateResult({ result, stack });\n  }\n\n  const tournamentId = tournamentRecord?.tournamentId;\n  const sendInContext = getTopics().topics.includes(UPDATE_INCONTEXT_MATCHUP);\n  const matchUpsMap =\n    (sendInContext || defaultedProcessCodes) &&\n    getMatchUpsMap({ drawDefinition });\n  const inContextMatchUp =\n    matchUpsMap &&\n    getAllDrawMatchUps({\n      // client will not normally be receiving participants for the first time...\n      // ... and should therefore already have groupings / ratings / rankings for participants\n      // participantsProfile: { withGroupings: true },\n      matchUpFilters: { matchUpIds: [matchUpId] },\n      nextMatchUps: true,\n      tournamentRecord, // required to hydrate participants\n      inContext: true,\n      drawDefinition,\n      matchUpsMap,\n    }).matchUps?.[0];\n\n  if (sendInContext && inContextMatchUp) {\n    updateInContextMatchUp({ tournamentId, inContextMatchUp });\n  }\n\n  if (\n    Array.isArray(defaultedProcessCodes) &&\n    inContextMatchUp &&\n    !inContextMatchUp.sides?.every(({ participantId }) => participantId)\n  ) {\n    if (matchUpStatus === DEFAULTED) {\n      matchUp.processCodes = unique([\n        ...(matchUp.processCodes ?? []),\n        ...defaultedProcessCodes,\n      ]);\n    } else {\n      for (const processCode of defaultedProcessCodes || []) {\n        const codeIndex =\n          processCode && matchUp?.processCodes?.lastIndexOf(processCode);\n        // remove only one instance of processCode\n        matchUp?.processCodes?.splice(codeIndex, 1);\n      }\n    }\n  }\n\n  modifyMatchUpNotice({\n    eventId: event?.eventId,\n    context: stack,\n    drawDefinition,\n    tournamentId,\n    matchUp,\n  });\n\n  return { ...SUCCESS };\n}\n","import { resolveTieFormat } from '../../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { generateTieMatchUpScore } from '../../../assemblies/generators/tieMatchUpScore/generateTieMatchUpScore';\nimport { copyTieFormat } from '../../../query/hierarchical/tieFormats/copyTieFormat';\nimport { isActiveMatchUp } from '../../../tests/queries/matchUps/activeMatchUp';\nimport { removeExtension } from '../../extensions/removeExtension';\nimport { findTournamentId } from '../../../acquire/findTournamentId';\nimport { ensureSideLineUps } from '../lineUps/ensureSideLineUps';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { findExtension } from '../../../acquire/findExtension';\nimport { modifyMatchUpScore } from './modifyMatchUpScore';\n\nimport { DISABLE_AUTO_CALC } from '../../../constants/extensionConstants';\nimport { MatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { TournamentRecords } from '../../../types/factoryTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  ErrorType,\n  INVALID_MATCHUP,\n  MATCHUP_NOT_FOUND,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../../constants/errorConditionConstants';\nimport {\n  COMPLETED,\n  completedMatchUpStatuses,\n  IN_PROGRESS,\n  TO_BE_PLAYED,\n} from '../../../constants/matchUpStatusConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype UpdateTieMatchUpScoreArgs = {\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  exitWhenNoValues?: boolean;\n  matchUpsMap?: MatchUpsMap;\n  matchUpStatus?: string;\n  tournamentId?: string;\n  removeScore?: boolean;\n  matchUpId: string;\n  event?: Event;\n};\nexport function updateTieMatchUpScore(params: UpdateTieMatchUpScoreArgs): {\n  removeWinningSide?: boolean;\n  tieFormatRemoved?: boolean;\n  winningSide?: number;\n  error?: ErrorType;\n  success?: boolean;\n  score?: any;\n} {\n  const {\n    exitWhenNoValues,\n    drawDefinition,\n    matchUpStatus,\n    removeScore,\n    matchUpsMap,\n    matchUpId,\n    event,\n  } = params;\n\n  const tournamentRecords =\n    params.tournamentRecords ||\n    (params.tournamentRecord && {\n      [params.tournamentRecord?.tournamentId]: params.tournamentRecord,\n    }) ||\n    {};\n\n  const tournamentId =\n    params.tournamentId || params.tournamentRecord?.tournamentId;\n  tournamentRecords && findTournamentId({ tournamentRecords, ...params });\n  const tournamentRecord = tournamentId && tournamentRecords[tournamentId];\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const result = findDrawMatchUp({ drawDefinition, event, matchUpId });\n  if (result.error) return result;\n  if (!result.matchUp) return { error: MATCHUP_NOT_FOUND };\n\n  const { matchUp, structure } = result;\n\n  if (!matchUp.tieMatchUps) return { error: INVALID_MATCHUP };\n\n  ensureSideLineUps({\n    tournamentId: tournamentRecord?.tournamentId,\n    eventId: event?.eventId,\n    dualMatchUp: matchUp,\n    drawDefinition,\n  });\n\n  const { extension } = findExtension({\n    name: DISABLE_AUTO_CALC,\n    element: matchUp,\n  });\n\n  if (extension?.value) {\n    if (!removeScore) {\n      return { ...SUCCESS, score: matchUp.score };\n    } else {\n      removeExtension({ element: matchUp, name: DISABLE_AUTO_CALC });\n    }\n  }\n\n  const tieFormat = resolveTieFormat({\n    drawDefinition,\n    structure,\n    matchUp,\n    event,\n  })?.tieFormat;\n\n  matchUp.tieFormat = copyTieFormat(tieFormat);\n\n  const scoreResult = generateTieMatchUpScore({\n    drawDefinition,\n    matchUpsMap,\n    structure,\n    matchUp,\n    event,\n  });\n\n  const { winningSide, set, scoreStringSide1, scoreStringSide2 } = scoreResult;\n\n  const setHasValue = set?.side1Score || set?.side2Score;\n  if (exitWhenNoValues && !matchUp.score && !setHasValue) {\n    return { ...SUCCESS };\n  }\n\n  const scoreObject = {\n    scoreStringSide1,\n    scoreStringSide2,\n    sets: set ? [set] : [],\n  };\n\n  const hasWinner = winningSide && [1, 2].includes(winningSide);\n  const newMatchUpStatus =\n    (hasWinner && COMPLETED) ||\n    (isActiveMatchUp({\n      matchUpStatus: matchUpStatus ?? matchUp.matchUpStatus,\n      tieMatchUps: matchUp.tieMatchUps,\n      winningSide: matchUp.winningSide,\n      score: scoreObject,\n    }) &&\n      IN_PROGRESS) ||\n    TO_BE_PLAYED;\n\n  const removeWinningSide = !!(matchUp.winningSide && !hasWinner);\n  const hasResults = matchUp.tieMatchUps.find(\n    ({ score, winningSide, matchUpStatus }) =>\n      (score?.sets?.length &&\n        (score.sets[0].side1Score || score.sets[0].side2Score)) ||\n      (matchUpStatus && completedMatchUpStatuses.includes(matchUpStatus)) ||\n      winningSide\n  );\n\n  let tieFormatRemoved;\n\n  if (matchUp.tieFormat && !hasWinner && !hasResults) {\n    // if matchUp.tieFormat is equivalent to hierarchical tieFormat, remove\n    const inheritedTieFormat = resolveTieFormat({\n      drawDefinition,\n      structure,\n      event,\n    })?.tieFormat;\n\n    if (\n      inheritedTieFormat &&\n      JSON.stringify(tieFormat) === JSON.stringify(inheritedTieFormat)\n    ) {\n      matchUp.tieFormatId = undefined;\n      matchUp.tieFormat = undefined;\n      tieFormatRemoved = true;\n    }\n  }\n\n  modifyMatchUpScore({\n    matchUpStatus: newMatchUpStatus,\n    score: scoreObject,\n    removeWinningSide,\n    tournamentRecord,\n    drawDefinition,\n    removeScore,\n    winningSide,\n    matchUpId,\n    matchUp,\n    event,\n  });\n\n  return {\n    ...SUCCESS,\n    score: scoreObject,\n    removeWinningSide,\n    tieFormatRemoved,\n    winningSide,\n  };\n}\n","import { includesMatchUpStatuses } from '../../drawDefinitions/matchUpGovernor/includesMatchUpStatuses';\nimport { structureAssignedDrawPositions } from '../../../query/drawDefinition/positionsGetter';\nimport { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { removeSubsequentRoundsParticipant } from './removeSubsequentRoundsParticipant';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { updateTieMatchUpScore } from '../score/tieMatchUpScore';\nimport { modifyMatchUpScore } from '../score/modifyMatchUpScore';\nimport { isAdHoc } from '../../../query/drawDefinition/isAdHoc';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { instanceCount } from '../../../utilities/arrays';\nimport { clearDrawPosition } from './positionClear';\n\nimport { FIRST_MATCHUP } from '../../../constants/drawDefinitionConstants';\nimport { TO_BE_PLAYED } from '../../../constants/matchUpStatusConstants';\nimport { MatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  ErrorType,\n  MISSING_DRAW_POSITIONS,\n  STRUCTURE_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  DrawLink,\n  Event,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\nexport function removeDirectedParticipants(params): {\n  error?: ErrorType;\n  success?: boolean;\n  tieMatchUpResult?: any;\n} {\n  const {\n    dualWinningSideChange,\n    inContextDrawMatchUps,\n    tournamentRecord,\n    drawDefinition,\n    matchUpStatus,\n    matchUpsMap,\n    dualMatchUp,\n    targetData,\n    matchUpId,\n    structure,\n    event,\n  } = params;\n\n  const isCollectionMatchUp = Boolean(params.matchUp.collectionId);\n  const isAdHocMatchUp = isAdHoc({ drawDefinition, structure });\n\n  // targetData will have team matchUp when params.matchUp is a collectionMatchUp\n  const { drawPositions, winningSide } = targetData.matchUp || {};\n  if (!isAdHocMatchUp && !drawPositions) {\n    return { error: MISSING_DRAW_POSITIONS };\n  }\n\n  const {\n    targetLinks: { loserTargetLink, winnerTargetLink, byeTargetLink },\n    targetMatchUps: { loserMatchUp, winnerMatchUp, byeMatchUp },\n  } = targetData;\n\n  const result = modifyMatchUpScore({\n    ...params,\n    matchUpStatus: matchUpStatus || TO_BE_PLAYED,\n    removeWinningSide: true,\n  });\n  if (result.error) return result;\n\n  let tieMatchUpResult;\n  if (isCollectionMatchUp) {\n    const { matchUpTieId, matchUpsMap } = params;\n    tieMatchUpResult = updateTieMatchUpScore({\n      matchUpId: matchUpTieId,\n      tournamentRecord,\n      drawDefinition,\n      matchUpsMap,\n      event,\n    });\n    if (!dualWinningSideChange && !tieMatchUpResult.removeWinningSide)\n      return { ...SUCCESS };\n  }\n\n  if (isAdHocMatchUp) return { ...SUCCESS };\n\n  const { matchUps: sourceMatchUps } = getAllStructureMatchUps({\n    afterRecoveryTimes: false,\n    inContext: true,\n    drawDefinition,\n    matchUpsMap,\n    structure,\n  });\n\n  const { positionAssignments } = structureAssignedDrawPositions({ structure });\n\n  const winningIndex = winningSide - 1;\n  const losingIndex = 1 - winningIndex;\n  const winningDrawPosition = drawPositions[winningIndex];\n  const loserDrawPosition = drawPositions[losingIndex];\n\n  // use reduce for single pass resolution of both\n  const { winnerParticipantId, loserParticipantId } =\n    positionAssignments?.reduce(\n      (assignments: any, assignment) => {\n        if (assignment.drawPosition === loserDrawPosition)\n          assignments.loserParticipantId = assignment.participantId;\n        if (assignment.drawPosition === winningDrawPosition)\n          assignments.winnerParticipantId = assignment.participantId;\n        return assignments;\n      },\n      { winnerParticipantId: undefined, loserParticipantId: undefined }\n    ) || {};\n\n  const drawPositionMatchUps = sourceMatchUps.filter(\n    (matchUp) => matchUp.drawPositions?.includes(loserDrawPosition)\n  );\n\n  if (winnerMatchUp) {\n    removeDirectedWinner({\n      sourceMatchUpStatus: matchUpStatus,\n      sourceMatchUpId: matchUpId,\n      inContextDrawMatchUps,\n      winningDrawPosition,\n      winnerParticipantId,\n      tournamentRecord,\n      winnerTargetLink,\n      drawDefinition,\n      winnerMatchUp,\n      dualMatchUp,\n      matchUpsMap,\n    });\n  }\n\n  if (loserMatchUp) {\n    const { winnerHadMatchUpStatus: winnerHadBye } = includesMatchUpStatuses({\n      drawPositionMatchUps,\n      loserDrawPosition,\n      sourceMatchUps,\n    });\n\n    const loserLinkCondition = loserTargetLink.linkCondition;\n    const firstMatchUpLoss = loserLinkCondition === FIRST_MATCHUP;\n\n    if (winnerHadBye && firstMatchUpLoss) {\n      // The fed drawPosition is always the lowest number\n      const drawPosition = Math.min(...loserMatchUp.drawPositions);\n      removeDirectedBye({\n        targetLink: loserTargetLink,\n        inContextDrawMatchUps,\n        drawDefinition,\n        drawPosition,\n        matchUpsMap,\n        event,\n      });\n    }\n\n    const removeLoserResult = removeDirectedLoser({\n      sourceMatchUpStatus: matchUpStatus,\n      sourceMatchUpId: matchUpId,\n      loserParticipantId,\n      tournamentRecord,\n      loserTargetLink,\n      drawDefinition,\n      loserMatchUp,\n      dualMatchUp,\n      matchUpsMap,\n      event,\n    });\n    if (removeLoserResult.error) return removeLoserResult;\n  }\n\n  if (byeMatchUp) {\n    // check whether byeMatchUp includes an active drawPosition\n    const drawPosition = Math.min(...byeMatchUp.drawPositions);\n    removeDirectedBye({\n      sourceMatchUpId: matchUpId,\n      targetLink: byeTargetLink,\n      inContextDrawMatchUps,\n      drawDefinition,\n      drawPosition,\n      matchUpsMap,\n      event,\n    });\n  }\n\n  const annotate = tieMatchUpResult && { tieMatchUpResult };\n  return { ...SUCCESS, ...annotate };\n}\ntype RemvoveDirectedWinnerArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  winnerMatchUp: HydratedMatchUp;\n  dualMatchUp?: HydratedMatchUp;\n  tournamentRecord?: Tournament;\n  winnerParticipantId?: string;\n  drawDefinition: DrawDefinition;\n  sourceMatchUpStatus?: string;\n  winningDrawPosition: number;\n  winnerTargetLink?: DrawLink;\n  matchUpsMap?: MatchUpsMap;\n  sourceMatchUpId?: string;\n  event?: Event;\n};\nexport function removeDirectedWinner({\n  inContextDrawMatchUps,\n  winningDrawPosition,\n  sourceMatchUpStatus,\n  winnerParticipantId,\n  tournamentRecord,\n  winnerTargetLink,\n  sourceMatchUpId,\n  drawDefinition,\n  winnerMatchUp,\n  matchUpsMap,\n  dualMatchUp,\n  event,\n}: RemvoveDirectedWinnerArgs) {\n  const { structureId, roundNumber } = winnerMatchUp;\n  const stack = 'removeDirectedWinner';\n\n  if (winnerTargetLink) {\n    const structureId = winnerTargetLink.target.structureId;\n    const { structure } = findStructure({ drawDefinition, structureId });\n    if (!structure) return { error: STRUCTURE_NOT_FOUND };\n    const { positionAssignments } = structureAssignedDrawPositions({\n      structure,\n    });\n\n    // remove participant from seedAssignments\n    structure.seedAssignments = (structure.seedAssignments ?? []).filter(\n      (assignment) => assignment.participantId !== winnerParticipantId\n    );\n\n    const relevantAssignment = positionAssignments?.find(\n      (assignment) => assignment.participantId === winnerParticipantId\n    );\n    const winnerDrawPosition = relevantAssignment?.drawPosition;\n\n    const { matchUps } = getAllStructureMatchUps({\n      drawDefinition,\n      structure,\n      event,\n    });\n    const allDrawPositionInstances = matchUps\n      .map((matchUp) => matchUp.drawPositions)\n      .flat(Infinity)\n      .filter(Boolean);\n    const drawPositionInstanceCount = instanceCount(allDrawPositionInstances);\n    const winnerDrawPositionInstances = winnerDrawPosition\n      ? drawPositionInstanceCount[winnerDrawPosition]\n      : undefined;\n\n    if (winnerDrawPositionInstances === 1) {\n      // only remove position assignment if it has a single instance...\n      // if there are multiple instances then a participant has been fed back into a draw\n      positionAssignments?.forEach((assignment) => {\n        if (assignment.participantId === winnerParticipantId) {\n          delete assignment.participantId;\n        }\n      });\n    } else {\n      const drawPositionMatchUps = matchUps.filter(({ drawPositions }) =>\n        drawPositions.includes(winnerDrawPosition)\n      );\n      console.log(\n        'not removing from position assignments since instances > 1',\n        { drawPositionMatchUps, winnerTargetLink }\n      );\n    }\n\n    const targetMatchUp = matchUpsMap?.drawMatchUps?.find(\n      ({ matchUpId }) => matchUpId === winnerMatchUp.matchUpId\n    );\n\n    targetMatchUp &&\n      modifyMatchUpNotice({\n        tournamentId: tournamentRecord?.tournamentId,\n        eventId: event?.eventId,\n        matchUp: targetMatchUp,\n        context: stack,\n        drawDefinition,\n      });\n  }\n\n  // Remove participant's drawPosition from current and subsequent round matchUps\n  roundNumber &&\n    removeSubsequentRoundsParticipant({\n      targetDrawPosition: winningDrawPosition,\n      inContextDrawMatchUps,\n      sourceMatchUpStatus,\n      tournamentRecord,\n      sourceMatchUpId,\n      drawDefinition,\n      dualMatchUp,\n      matchUpsMap,\n      roundNumber,\n      structureId,\n    });\n\n  return { ...SUCCESS };\n}\n\nfunction removeDirectedLoser({\n  sourceMatchUpStatus,\n  loserParticipantId,\n  tournamentRecord,\n  loserTargetLink,\n  sourceMatchUpId,\n  drawDefinition,\n  loserMatchUp,\n  matchUpsMap,\n  dualMatchUp,\n  event,\n}): { error?: ErrorType; success?: boolean } {\n  const stack = 'removeDirectedLoser';\n  const structureId = loserTargetLink.target.structureId;\n  const { structure } = findStructure({ drawDefinition, structureId });\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n  const { positionAssignments } = structureAssignedDrawPositions({ structure });\n  const relevantDrawPosition = positionAssignments?.find(\n    (assignment) => assignment.participantId === loserParticipantId\n  )?.drawPosition;\n  positionAssignments?.forEach((assignment) => {\n    if (assignment.participantId === loserParticipantId) {\n      delete assignment.participantId;\n    }\n  });\n\n  if (sourceMatchUpId && sourceMatchUpStatus) {\n    // TODO: update matchUpStatusCodes if necessary\n    // console.log({ sourceMatchUpId, sourceMatchUpStatus });\n  }\n\n  // remove participant from seedAssignments\n  structure.seedAssignments = (structure.seedAssignments ?? []).filter(\n    (assignment) => assignment.participantId !== loserParticipantId\n  );\n\n  if (dualMatchUp) {\n    // remove propagated lineUp\n    const drawPositionSideIndex = loserMatchUp?.sides.reduce(\n      (sideIndex, side, i) =>\n        side.drawPosition === relevantDrawPosition ? i : sideIndex,\n      undefined\n    );\n    const targetMatchUp = matchUpsMap?.drawMatchUps?.find(\n      ({ matchUpId }) => matchUpId === loserMatchUp.matchUpId\n    );\n    const targetSide = targetMatchUp?.sides?.[drawPositionSideIndex];\n\n    if (targetSide) {\n      delete targetSide.lineUp;\n\n      modifyMatchUpNotice({\n        tournamentId: tournamentRecord?.tournamentId,\n        eventId: event?.eventId,\n        matchUp: targetMatchUp,\n        context: stack,\n        drawDefinition,\n      });\n    }\n  }\n\n  return { ...SUCCESS };\n}\n\ntype RemoveDirectedByeArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  sourceMatchUpId?: string;\n  drawPosition: number;\n  targetLink: DrawLink;\n  event?: Event;\n};\nexport function removeDirectedBye({\n  inContextDrawMatchUps,\n  tournamentRecord,\n  drawDefinition,\n  drawPosition,\n  matchUpsMap,\n  targetLink,\n  event,\n}: RemoveDirectedByeArgs) {\n  const structureId = targetLink.target.structureId;\n\n  clearDrawPosition({\n    inContextDrawMatchUps,\n    tournamentRecord,\n    drawDefinition,\n    matchUpsMap,\n    drawPosition,\n    structureId,\n    event,\n  });\n\n  return { ...SUCCESS };\n}\n","import { overlap } from '../../../utilities/arrays';\n\nimport {\n  BYE,\n  DEFAULTED,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\n\nexport function includesMatchUpStatuses({\n  matchUpStatuses = [BYE, WALKOVER, DEFAULTED],\n  drawPositionMatchUps,\n  loserDrawPosition,\n  sourceMatchUps,\n}) {\n  const sourceMatchUp = drawPositionMatchUps?.reduce(\n    (sourceMatchUp, matchUp) =>\n      !sourceMatchUp || matchUp.roundNumber > sourceMatchUp.roundNumber\n        ? matchUp\n        : sourceMatchUp,\n    undefined\n  );\n  const winnerDrawPosition = sourceMatchUp?.drawPositions?.find(\n    (drawPosition) => drawPosition !== loserDrawPosition\n  );\n\n  const winnerMatchUpStatuses = sourceMatchUps\n    .filter((matchUp) => matchUp?.drawPositions?.includes(winnerDrawPosition))\n    .map((matchUp) => matchUp.matchUpStatus);\n\n  const loserMatchUpStatuses = sourceMatchUps\n    .filter((matchUp) => matchUp?.drawPositions?.includes(loserDrawPosition))\n    .map((matchUp) => matchUp.matchUpStatus);\n\n  const winnerHadMatchUpStatus = overlap(\n    winnerMatchUpStatuses || [],\n    matchUpStatuses\n  );\n\n  const loserHadMatchUpStatus = overlap(\n    loserMatchUpStatuses || [],\n    matchUpStatuses\n  );\n\n  return {\n    sourceMatchUp,\n    winnerHadMatchUpStatus,\n    winnerMatchUpStatuses,\n    loserHadMatchUpStatus,\n    loserMatchUpStatuses,\n  };\n}\n","import { assignMatchUpDrawPosition } from '../../matchUps/drawPositions/assignMatchUpDrawPosition';\nimport { getPairedPreviousMatchUpIsDoubleExit } from './getPairedPreviousMatchUpIsDoubleExit';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { positionTargets } from '../../matchUps/drawPositions/positionTargets';\nimport { modifyMatchUpScore } from '../../matchUps/score/modifyMatchUpScore';\nimport { getExitWinningSide } from '../matchUpGovernor/getExitWinningSide';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { overlap } from '../../../utilities/arrays';\nimport {\n  advanceDrawPosition,\n  assignDrawPositionBye,\n} from '../../matchUps/drawPositions/assignDrawPositionBye';\n\nimport { CONTAINER } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  DRAW_POSITION_ASSIGNED,\n  MISSING_MATCHUP,\n  MISSING_STRUCTURE,\n} from '../../../constants/errorConditionConstants';\nimport {\n  BYE,\n  DEFAULTED,\n  DOUBLE_DEFAULT,\n  DOUBLE_WALKOVER,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\n\nexport function doubleExitAdvancement(params) {\n  const {\n    tournamentRecord,\n    appliedPolicies,\n    drawDefinition,\n    matchUpsMap,\n    targetData,\n    structure,\n    event,\n  } = params;\n  const stack = 'doubleExitAdvancement';\n\n  if (structure.structureType === CONTAINER)\n    return decorateResult({ result: { ...SUCCESS }, stack });\n\n  const { matchUp: sourceMatchUp, targetMatchUps, targetLinks } = targetData;\n  const { loserMatchUp, winnerMatchUp, loserTargetDrawPosition } =\n    targetMatchUps;\n\n  if (loserMatchUp && loserMatchUp.matchUpStatus !== BYE) {\n    const { loserTargetLink } = targetLinks;\n    if (appliedPolicies?.progression?.doubleExitPropagateBye) {\n      const result = advanceByeToLoserMatchUp({\n        loserTargetDrawPosition,\n        tournamentRecord,\n        loserTargetLink,\n        drawDefinition,\n        loserMatchUp,\n        matchUpsMap,\n        event,\n      });\n      if (result.error) return decorateResult({ result, stack });\n    } else {\n      const { feedRound, drawPositions, matchUpId } = loserMatchUp;\n      const walkoverWinningSide = feedRound\n        ? 2\n        : 2 - drawPositions.indexOf(loserTargetDrawPosition);\n      const result = conditionallyAdvanceDrawPosition({\n        ...params,\n        targetMatchUp: loserMatchUp,\n        walkoverWinningSide,\n        tournamentRecord,\n        sourceMatchUp,\n        matchUpId,\n      });\n      if (result.error) return decorateResult({ result, stack });\n    }\n  }\n\n  if (winnerMatchUp) {\n    const result = conditionallyAdvanceDrawPosition({\n      ...params,\n      matchUpId: winnerMatchUp.matchUpId,\n      targetMatchUp: winnerMatchUp,\n      tournamentRecord,\n      sourceMatchUp,\n    });\n    if (result.error) return decorateResult({ result, stack });\n  }\n\n  return decorateResult({ result: { ...SUCCESS }, stack });\n}\n\n// 1. Assigns a WALKOVER or DEFAULTED status to the winnerMatchUp\n// 2. Advances any drawPosition that is already present\nfunction conditionallyAdvanceDrawPosition(params) {\n  const {\n    inContextDrawMatchUps,\n    tournamentRecord,\n    drawDefinition,\n    sourceMatchUp,\n    targetMatchUp,\n    matchUpsMap,\n  } = params;\n\n  const structure = drawDefinition.structures.find(\n    ({ structureId }) => structureId === targetMatchUp.structureId\n  );\n\n  const DOUBLE_EXIT =\n    params.matchUpStatus === DOUBLE_DEFAULT ? DOUBLE_DEFAULT : DOUBLE_WALKOVER;\n  const EXIT = params.matchUpStatus === DOUBLE_DEFAULT ? DEFAULTED : WALKOVER;\n\n  const stack = 'conditionallyAdvanceDrawPosition';\n\n  const noContextTargetMatchUp = matchUpsMap.drawMatchUps.find(\n    (matchUp) => matchUp.matchUpId === targetMatchUp.matchUpId\n  );\n  if (!noContextTargetMatchUp) return { error: MISSING_MATCHUP };\n\n  const sourceDrawPositions = sourceMatchUp?.drawPositions || [];\n  let targetMatchUpDrawPositions =\n    noContextTargetMatchUp.drawPositions?.filter(Boolean);\n\n  const sameStructure =\n    sourceMatchUp?.structureId === targetMatchUp.structureId;\n\n  // ensure targetMatchUp.drawPositions does not contain sourceMatchUp.drawPositions\n  // this covers the case where a pre-existing advancement was made\n  if (\n    sameStructure &&\n    overlap(sourceDrawPositions, targetMatchUpDrawPositions)\n  ) {\n    targetMatchUpDrawPositions = targetMatchUpDrawPositions.filter(\n      (drawPosition) => !sourceDrawPositions.includes(drawPosition)\n    );\n  }\n\n  // if there are 2 drawPositions in targetMatchUp, something is wrong\n  if (sameStructure && targetMatchUpDrawPositions.length > 1)\n    return decorateResult({ result: { error: DRAW_POSITION_ASSIGNED }, stack });\n\n  const { pairedPreviousMatchUpIsDoubleExit, pairedPreviousMatchUp } =\n    getPairedPreviousMatchUpIsDoubleExit(params);\n\n  // get the targets for the targetMatchUp\n  const targetData = positionTargets({\n    matchUpId: targetMatchUp.matchUpId,\n    inContextDrawMatchUps,\n    drawDefinition,\n  });\n  const { targetMatchUps, targetLinks } = targetData;\n\n  const {\n    loserTargetDrawPosition: nextLoserTargetDrawPosition,\n    winnerMatchUp: nextWinnerMatchUp,\n    loserMatchUp: nextLoserMatchUp,\n  } = targetMatchUps;\n\n  if (nextLoserMatchUp) {\n    const { loserTargetLink } = targetLinks;\n    const result = advanceByeToLoserMatchUp({\n      loserTargetDrawPosition: nextLoserTargetDrawPosition,\n      loserMatchUp: nextLoserMatchUp,\n      tournamentRecord,\n      loserTargetLink,\n      drawDefinition,\n      matchUpsMap,\n    });\n    if (result.error) return decorateResult({ result, stack });\n  }\n\n  const drawPositions =\n    noContextTargetMatchUp.drawPositions?.filter(Boolean) || [];\n\n  const hasDrawPosition = drawPositions.length === 1;\n  const walkoverWinningSide =\n    params.walkoverWinningSide ||\n    (hasDrawPosition &&\n      getExitWinningSide({\n        drawPosition: drawPositions[0],\n        matchUpId: targetMatchUp.matchUpId,\n        inContextDrawMatchUps,\n      })) ||\n    undefined;\n\n  // assign the WALKOVER status to targetMatchUp\n  const existingExit =\n    [WALKOVER, DEFAULTED].includes(noContextTargetMatchUp.matchUpStatus) &&\n    !drawPositions.length;\n  const isFinal = noContextTargetMatchUp.finishingRound === 1;\n\n  const matchUpStatus = existingExit && !isFinal ? DOUBLE_EXIT : EXIT;\n\n  const inContextPairedPreviousMatchUp = inContextDrawMatchUps.find(\n    (candidate) => candidate.matchUpId === pairedPreviousMatchUp.matchUpId\n  );\n  let matchUpStatusCodes: any[] = [];\n  let sourceSideNumber;\n\n  if (sourceMatchUp) {\n    if (\n      sourceMatchUp?.structureId === inContextPairedPreviousMatchUp?.structureId\n    ) {\n      // if structureIds are equivalent then sideNumber is inferred from roundPositions\n      if (sourceMatchUp.roundPosition < pairedPreviousMatchUp?.roundPosition) {\n        sourceSideNumber = 1;\n      } else {\n        sourceSideNumber = 2;\n      }\n    } else if (targetMatchUp.feedRound) {\n      // if different structureIds then structureId that is not equivalent to noContextTargetMatchUp.structureId is fed\n      // ... and fed positions are always sideNumber 1\n      if (sourceMatchUp.structureId === targetMatchUp.structureId) {\n        sourceSideNumber = 2;\n      } else {\n        sourceSideNumber = 1;\n      }\n    } else if (walkoverWinningSide) sourceSideNumber = 3 - walkoverWinningSide;\n  }\n\n  const sourceMatchUpStatus = params.matchUpStatus;\n  const pairedMatchUpStatus = pairedPreviousMatchUp?.matchUpStatus;\n\n  if (sourceSideNumber === 1) {\n    matchUpStatusCodes = [\n      {\n        matchUpStatus: producedMatchUpStatus(sourceMatchUpStatus),\n        previousMatchUpStatus: sourceMatchUpStatus,\n        sideNumber: 1,\n      },\n      {\n        matchUpStatus: producedMatchUpStatus(pairedMatchUpStatus),\n        previousMatchUpStatus: pairedMatchUpStatus,\n        sideNumber: 2,\n      },\n    ];\n  } else if (sourceSideNumber === 2) {\n    matchUpStatusCodes = [\n      {\n        matchUpStatus: producedMatchUpStatus(pairedMatchUpStatus),\n        previousMatchUpStatus: pairedMatchUpStatus,\n        sideNumber: 1,\n      },\n      {\n        matchUpStatus: producedMatchUpStatus(sourceMatchUpStatus),\n        previousMatchUpStatus: sourceMatchUpStatus,\n        sideNumber: 2,\n      },\n    ];\n  }\n\n  if (matchUpStatusCodes.length)\n    matchUpStatusCodes = matchUpStatusCodes.map((code) =>\n      definedAttributes(code)\n    );\n\n  const result = modifyMatchUpScore({\n    ...params,\n    matchUp: noContextTargetMatchUp,\n    winningSide: walkoverWinningSide,\n    matchUpStatusCodes,\n    matchUpStatus,\n  });\n  if (result.error) return decorateResult({ result, stack });\n\n  // when there is an existing 'Double Exit\", the created \"Exit\" is replaced\n  // with a \"Double Exit\" and move on to advancing from this position\n  if (existingExit) {\n    return doubleExitAdvancement({\n      ...params,\n      matchUpStatus,\n      targetData,\n    });\n  }\n\n  if (!nextWinnerMatchUp)\n    return decorateResult({ result: { ...SUCCESS }, stack });\n\n  // any remaining drawPosition in targetMatchUp should be advanced\n  const drawPositionToAdvance =\n    targetMatchUpDrawPositions.length === 2\n      ? targetMatchUpDrawPositions[walkoverWinningSide - 1]\n      : targetMatchUpDrawPositions[0];\n\n  const { positionAssignments } = getPositionAssignments({ structure });\n  const assignment = positionAssignments?.find(\n    (assignment) => assignment.drawPosition === drawPositionToAdvance\n  );\n\n  const noContextNextWinnerMatchUp = matchUpsMap.drawMatchUps.find(\n    (matchUp) => matchUp.matchUpId === nextWinnerMatchUp.matchUpId\n  );\n  const nextWinnerMatchUpDrawPositions =\n    noContextNextWinnerMatchUp?.drawPositions?.filter(Boolean);\n  const nextWinnerMatchUpHasDrawPosition =\n    nextWinnerMatchUpDrawPositions.length === 1;\n\n  if (drawPositionToAdvance) {\n    if (assignment?.bye) {\n      // WO/WO advanced by BYE\n      const targetData = positionTargets({\n        matchUpId: noContextNextWinnerMatchUp.matchUpId,\n        inContextDrawMatchUps,\n        drawDefinition,\n      });\n\n      if (nextWinnerMatchUpHasDrawPosition) {\n        const nextDrawPositionToAdvance =\n          nextWinnerMatchUpDrawPositions.filter(Boolean)[0];\n\n        // if the next targetMatchUp already has a drawPosition\n        const winningSide = getExitWinningSide({\n          drawPosition: nextDrawPositionToAdvance,\n          matchUpId: noContextNextWinnerMatchUp.matchUpId,\n          inContextDrawMatchUps,\n        });\n\n        const result = modifyMatchUpScore({\n          matchUpId: noContextNextWinnerMatchUp.matchUpId,\n          matchUp: noContextNextWinnerMatchUp,\n          matchUpStatus: EXIT,\n          matchUpStatusCodes: [],\n          removeScore: true,\n          drawDefinition,\n          winningSide,\n        });\n        if (result.error) return decorateResult({ result, stack });\n\n        return advanceDrawPosition({\n          drawPositionToAdvance: nextDrawPositionToAdvance,\n          matchUpId: noContextNextWinnerMatchUp.matchUpId,\n          inContextDrawMatchUps,\n          drawDefinition,\n          matchUpsMap,\n        });\n      } else if (\n        [WALKOVER, DEFAULTED].includes(nextWinnerMatchUp.matchUpStatus)\n      ) {\n        // if the next targetMatchUp is a double walkover or double default\n        const result = doubleExitAdvancement({\n          ...params,\n          matchUpId: noContextNextWinnerMatchUp.matchUpId,\n          matchUpStatus,\n          targetData,\n        });\n        if (result.error) return decorateResult({ result, stack });\n      }\n\n      return decorateResult({ result: { ...SUCCESS }, stack });\n    }\n\n    return assignMatchUpDrawPosition({\n      matchUpId: nextWinnerMatchUp.matchUpId,\n      drawPosition: drawPositionToAdvance,\n      inContextDrawMatchUps,\n      drawDefinition,\n    });\n  } else if (pairedPreviousMatchUpIsDoubleExit) {\n    if (!noContextNextWinnerMatchUp) return { error: MISSING_MATCHUP };\n\n    if (nextWinnerMatchUpHasDrawPosition) {\n      const drawPosition = nextWinnerMatchUpDrawPositions[0];\n      const walkoverWinningSide = getExitWinningSide({\n        matchUpId: targetMatchUp.matchUpId,\n        inContextDrawMatchUps,\n        drawPosition,\n      });\n      console.log('existing drawPosition is winningSide', {\n        walkoverWinningSide,\n      });\n    }\n\n    const matchUpStatus = [WALKOVER, DEFAULTED].includes(\n      noContextNextWinnerMatchUp.matchUpStatus\n    )\n      ? EXIT\n      : DOUBLE_EXIT;\n\n    const result = modifyMatchUpScore({\n      matchUpId: noContextNextWinnerMatchUp.matchUpId,\n      matchUp: noContextNextWinnerMatchUp,\n      matchUpStatusCodes: [],\n      removeScore: true,\n      drawDefinition,\n      matchUpStatus,\n    });\n\n    if (result.error) return decorateResult({ result, stack });\n\n    if (matchUpStatus === DOUBLE_EXIT) {\n      const advancementResult = doubleExitAdvancement({\n        ...params,\n        matchUpId: targetMatchUp.matchUpId,\n        matchUpStatus,\n        targetData,\n      });\n      if (advancementResult.error) return advancementResult;\n    }\n  }\n\n  return decorateResult({ result: { ...SUCCESS }, stack });\n}\n\nfunction advanceByeToLoserMatchUp(params) {\n  const {\n    loserTargetDrawPosition,\n    tournamentRecord,\n    loserTargetLink,\n    drawDefinition,\n    matchUpsMap,\n    event,\n  } = params;\n  const structureId = loserTargetLink?.target?.structureId;\n  const { structure } = findStructure({ drawDefinition, structureId });\n  if (!structure) return { error: MISSING_STRUCTURE };\n\n  return assignDrawPositionBye({\n    drawPosition: loserTargetDrawPosition,\n    tournamentRecord,\n    drawDefinition,\n    structureId,\n    matchUpsMap,\n    event,\n  });\n}\n\nfunction producedMatchUpStatus(previousMatchUpStatus) {\n  if (previousMatchUpStatus === DOUBLE_WALKOVER) return WALKOVER;\n  if (previousMatchUpStatus === DOUBLE_DEFAULT) return DEFAULTED;\n  return previousMatchUpStatus;\n}\n","import { doubleExitAdvancement } from '../positionGovernor/doubleExitAdvancement';\nimport { attemptToSetMatchUpStatusBYE } from '../../matchUps/matchUpStatus/attemptToSetMatchUpStatusBYE';\nimport { removeDirectedParticipants } from '../../matchUps/drawPositions/removeDirectedParticipants';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { updateTieMatchUpScore } from '../../matchUps/score/tieMatchUpScore';\nimport { modifyMatchUpScore } from '../../matchUps/score/modifyMatchUpScore';\nimport {\n  isDirectingMatchUpStatus,\n  isNonDirectingMatchUpStatus,\n} from './checkStatusType';\n\nimport {\n  INVALID_MATCHUP_STATUS,\n  UNRECOGNIZED_MATCHUP_STATUS,\n} from '../../../constants/errorConditionConstants';\nimport {\n  BYE,\n  CANCELLED,\n  DOUBLE_DEFAULT,\n  DOUBLE_WALKOVER,\n  TO_BE_PLAYED,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\n\nexport function attemptToSetMatchUpStatus(params) {\n  const {\n    tournamentRecord,\n    drawDefinition,\n    matchUpStatus,\n    structure,\n    matchUp,\n  } = params;\n\n  const teamRoundRobinContext = !!(\n    matchUp.tieMatchUps &&\n    !matchUp.rondPosition &&\n    params.inContextDrawMatchUps.find(\n      (icdm) => icdm.matchUpId === matchUp.matchUpId\n    ).containerStructureId\n  );\n\n  const stack = 'attemptToSetMatchUpStatus';\n\n  const isBYE = matchUpStatus === BYE;\n  const existingWinningSide = matchUp.winningSide;\n  const isDoubleExit = [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(\n    matchUpStatus\n  );\n\n  const directing = isDirectingMatchUpStatus({ matchUpStatus });\n  const nonDirecting = isNonDirectingMatchUpStatus({ matchUpStatus });\n  const unrecognized = !directing && !nonDirecting;\n\n  // if matchUpTieId present a TEAM matchUp is being modified...\n  const onlyModifyScore =\n    params.matchUpTieId || (existingWinningSide && directing && !isDoubleExit);\n\n  const changeCompletedToDoubleExit = existingWinningSide && isDoubleExit;\n\n  const clearScore = () =>\n    modifyMatchUpScore({\n      ...params,\n      removeScore: [CANCELLED, WALKOVER].includes(matchUpStatus),\n      matchUpStatus: matchUpStatus || TO_BE_PLAYED,\n    });\n\n  return (\n    (unrecognized && { error: UNRECOGNIZED_MATCHUP_STATUS }) ||\n    (onlyModifyScore && scoreModification(params)) ||\n    (changeCompletedToDoubleExit &&\n      removeWinningSideAndSetDoubleExit(params)) ||\n    (existingWinningSide && removeDirectedParticipants(params)) ||\n    (nonDirecting && clearScore()) ||\n    (isBYE &&\n      attemptToSetMatchUpStatusBYE({\n        tournamentRecord,\n        drawDefinition,\n        structure,\n        matchUp,\n      })) ||\n    (!directing && { error: UNRECOGNIZED_MATCHUP_STATUS }) ||\n    (isDoubleExit && modifyScoreAndAdvanceDoubleExit(params)) ||\n    (teamRoundRobinContext && scoreModification(params)) ||\n    decorateResult({\n      result: { error: INVALID_MATCHUP_STATUS },\n      stack,\n    })\n  );\n}\n\nfunction removeWinningSideAndSetDoubleExit(params) {\n  const result = removeDirectedParticipants(params);\n  if (result.error) return result;\n  return doubleExitAdvancement(params);\n}\n\nfunction modifyScoreAndAdvanceDoubleExit(params) {\n  const result = scoreModification({ ...params, removeScore: true });\n  if (result.error) return result;\n  return doubleExitAdvancement(params);\n}\n\nfunction scoreModification(params) {\n  const stack = 'scoreModification';\n\n  const removeDirected =\n    params.isCollectionMatchUp &&\n    params.dualMatchUp?.winningSide &&\n    !params.projectedWinningSide;\n\n  if (removeDirected) {\n    const result = removeDirectedParticipants(params);\n    if (result.error) return decorateResult({ result, stack });\n  }\n  const isCollectionMatchUp = Boolean(params.matchUp.collectionId);\n  const result = modifyMatchUpScore(params);\n\n  // recalculate dualMatchUp score if isCollectionMatchUp\n  if (isCollectionMatchUp) {\n    const { matchUpTieId, drawDefinition, matchUpsMap } = params;\n    const tieMatchUpResult = updateTieMatchUpScore({\n      tournamentRecord: params.tournamentRecord,\n      matchUpId: matchUpTieId,\n      event: params.event,\n      drawDefinition,\n      matchUpsMap,\n    });\n    if (tieMatchUpResult.error) {\n      return decorateResult({ result: tieMatchUpResult, stack });\n    }\n    Object.assign(result, { tieMatchUpResult });\n  }\n\n  return decorateResult({ result, stack });\n}\n","import { structureAssignedDrawPositions } from '../../../query/drawDefinition/positionsGetter';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { decorateResult } from '../../../global/functions/decorateResult';\n\nimport { BYE } from '../../../constants/matchUpStatusConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_MATCHUP_STATUS,\n  INVALID_MATCHUP_STATUS_BYE,\n} from '../../../constants/errorConditionConstants';\n\nexport function attemptToSetMatchUpStatusBYE({\n  tournamentRecord,\n  drawDefinition,\n  structure,\n  matchUp,\n}) {\n  const stack = 'attemptToSetMatchUpStatusBYE';\n  if (matchUp?.winningSide) {\n    return decorateResult({\n      result: { error: INVALID_MATCHUP_STATUS },\n      context: { matchUpStatus: BYE },\n      stack,\n    });\n  }\n\n  // It is not possible to change matchUp status to BYE unless\n  // matchUp.drawPositions includes BYE assigned position\n  const { positionAssignments } = structureAssignedDrawPositions({\n    structure,\n  });\n\n  const byeAssignedDrawPositions = positionAssignments\n    ?.filter((assignment) => assignment.bye)\n    .map((assignment) => assignment.drawPosition);\n\n  const matchUpIncludesBye = matchUp.drawPositions?.some(\n    (position) => byeAssignedDrawPositions?.includes(position)\n  );\n\n  if (matchUpIncludesBye) {\n    matchUp.matchUpStatus = BYE;\n    matchUp.matchUpStatusCodes = [];\n    modifyMatchUpNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      context: stack,\n      drawDefinition,\n      matchUp,\n    });\n    return { ...SUCCESS };\n  } else {\n    return decorateResult({\n      result: { error: INVALID_MATCHUP_STATUS_BYE },\n      info: 'matchUp does not include BYE',\n      stack,\n    });\n  }\n}\n","import { getAffectedTargetStructureIds } from './getAffectedTargetStructureIds';\nimport { isCompletedStructure } from '../../../query/drawDefinition/structureActions';\n\nimport { WIN_RATIO } from '../../../constants/drawDefinitionConstants';\n\n/**\n * check effect of winningSide change in a structure where progression is based on WIN_RATIO\n * For ROUND_ROBIN_WITH_PLAYOFF the movement of participants into different structures\n * will be changed and IF no matchUps are active in either structure then participants can be swapped\n */\nexport function checkConnectedStructures({\n  drawDefinition,\n  structure,\n  matchUp,\n}) {\n  const connectedStructureIds: string[] = [];\n\n  // check whether player movement is dependent on win ratio\n  if (structure.finishingPosition === WIN_RATIO) {\n    const structureIsComplete = isCompletedStructure({\n      drawDefinition,\n      structure,\n    });\n    if (structureIsComplete) {\n      // if structure is complete then a changed outcome will have downstream effects\n      const { structureIds } = getAffectedTargetStructureIds({\n        drawDefinition,\n        structure,\n        matchUp,\n      });\n\n      if (structureIds?.length) {\n        connectedStructureIds.push(...structureIds);\n      }\n    }\n  }\n\n  return { connectedStructureIds };\n}\n","import { getContainedStructures } from '../../../query/drawDefinition/getContainedStructures';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { getStructureLinks } from '../../../query/drawDefinition/linkGetter';\nimport { findExtension } from '../../../acquire/findExtension';\nimport { overlap } from '../../../utilities/arrays';\n\nimport { TALLY } from '../../../constants/extensionConstants';\nimport {\n  DrawDefinition,\n  MatchUp,\n  Structure,\n} from '../../../types/tournamentTypes';\n\n/**\n * Finds all structureIds which are affected by an outcome change in a completed structure\n * Is specific to Round Robins which direct participants by WIN_RATIO\n */\n\ntype GetAffectedTargetStructureIds = {\n  drawDefinition: DrawDefinition;\n  structure: Structure;\n  matchUp: MatchUp;\n};\n\nexport function getAffectedTargetStructureIds({\n  drawDefinition,\n  structure,\n  matchUp,\n}: GetAffectedTargetStructureIds) {\n  const { drawPositions } = matchUp;\n  const { positionAssignments } = getPositionAssignments({\n    drawDefinition,\n    structure,\n  });\n\n  const relevantAssignments = positionAssignments?.filter(\n    ({ drawPosition }) => drawPositions?.includes(drawPosition)\n  );\n\n  const finishingPositions = relevantAssignments?.map((assignment) => {\n    const { extension } = findExtension({ element: assignment, name: TALLY });\n    return extension?.value?.groupOrder;\n  });\n\n  const { containerStructures } = getContainedStructures({ drawDefinition });\n  const structureId = containerStructures[structure.structureId];\n\n  const links = getStructureLinks({\n    drawDefinition,\n    structureId,\n  })?.links?.source;\n\n  const structureIds = links\n    ?.filter((link) => {\n      return overlap(finishingPositions, link.source?.finishingPositions || []);\n    })\n    .map((link) => link.source.structureId);\n\n  return { structureIds };\n}\n","import { structureAssignedDrawPositions } from '../../../query/drawDefinition/positionsGetter';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { isDirectingMatchUpStatus } from './checkStatusType';\nimport { modifyMatchUpScore } from '../../matchUps/score/modifyMatchUpScore';\nimport { isAdHoc } from '../../../query/drawDefinition/isAdHoc';\n\nimport { MISSING_ASSIGNMENTS } from '../../../constants/errorConditionConstants';\nimport {\n  ABANDONED,\n  CANCELLED,\n  COMPLETED,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\n\nexport function attemptToModifyScore(params) {\n  const {\n    dualWinningSideChange,\n    matchUpStatusCodes,\n    tournamentRecord,\n    drawDefinition,\n    matchUpFormat,\n    matchUpStatus,\n    winningSide,\n    matchUpId,\n    structure,\n    matchUp,\n    event,\n    score,\n  } = params;\n\n  const matchUpStatusIsValid =\n    isDirectingMatchUpStatus({ matchUpStatus }) ||\n    // in the case that CANCELLED or ABANDONED causes TEAM participant to advance\n    ([CANCELLED, ABANDONED].includes(matchUpStatus) && dualWinningSideChange);\n\n  const stack = 'attemptToModifyScore';\n  const isCollectionMatchUp = Boolean(matchUp.collectionId);\n  const isAdHocMatchUp = isAdHoc({ drawDefinition, structure });\n  const validToScore =\n    isCollectionMatchUp ||\n    isAdHocMatchUp ||\n    drawPositionsAssignedParticipantIds({ structure, matchUp });\n\n  if (!validToScore) {\n    return { error: MISSING_ASSIGNMENTS };\n  }\n\n  const removeScore = [WALKOVER].includes(matchUpStatus);\n\n  const result = modifyMatchUpScore({\n    matchUpStatusCodes: (matchUpStatusIsValid && matchUpStatusCodes) || [],\n    matchUpStatus: (matchUpStatusIsValid && matchUpStatus) || COMPLETED,\n    tournamentRecord,\n    drawDefinition,\n    matchUpFormat,\n    removeScore,\n    winningSide,\n    matchUpId,\n    matchUp,\n    event,\n    score,\n  });\n  return decorateResult({ result, stack });\n}\n\nfunction drawPositionsAssignedParticipantIds({ structure, matchUp }) {\n  const { drawPositions } = matchUp;\n  const { positionAssignments } = structureAssignedDrawPositions({ structure });\n  const assignedParticipantIds = positionAssignments?.filter((assignment) => {\n    return (\n      drawPositions?.includes(assignment.drawPosition) &&\n      assignment.participantId\n    );\n  });\n  return assignedParticipantIds?.length === 2;\n}\n","import { assignDrawPositionBye } from './assignDrawPositionBye';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { attemptToModifyScore } from '../../drawDefinitions/matchUpGovernor/attemptToModifyScore';\nimport { isDirectingMatchUpStatus } from '../../drawDefinitions/matchUpGovernor/checkStatusType';\nimport { updateTieMatchUpScore } from '../score/tieMatchUpScore';\nimport { isAdHoc } from '../../../query/drawDefinition/isAdHoc';\nimport { directWinner } from './directWinner';\nimport { directLoser } from './directLoser';\n\nimport { MISSING_DRAW_POSITIONS } from '../../../constants/errorConditionConstants';\nimport { COMPLETED } from '../../../constants/matchUpStatusConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\nexport function directParticipants(params) {\n  const result = attemptToModifyScore(params);\n\n  if (result.error) return result;\n  const matchUpStatusIsValid = isDirectingMatchUpStatus({\n    matchUpStatus: params.matchUpStatus,\n  });\n\n  const {\n    dualWinningSideChange,\n    projectedWinningSide,\n    inContextDrawMatchUps,\n    tournamentRecord,\n    drawDefinition,\n    matchUpStatus,\n    dualMatchUp,\n    matchUpsMap,\n    winningSide,\n    targetData,\n    matchUpId,\n    structure,\n    matchUp,\n    event,\n  } = params;\n\n  const stack = 'directParticipants';\n  const isCollectionMatchUp = Boolean(matchUp.collectionId);\n  const isAdHocMatchUp = isAdHoc({ drawDefinition, structure });\n  let drawPositions = matchUp.drawPositions;\n\n  let annotate;\n  if (isCollectionMatchUp) {\n    const { matchUpTieId, matchUpsMap } = params;\n    const tieMatchUpResult = updateTieMatchUpScore({\n      matchUpId: matchUpTieId,\n      tournamentRecord,\n      drawDefinition,\n      matchUpsMap,\n      event,\n    });\n    annotate = tieMatchUpResult && { tieMatchUpResult };\n    const matchUpTie = inContextDrawMatchUps.find(\n      ({ matchUpId }) => matchUpId === matchUpTieId\n    );\n    drawPositions = matchUpTie?.drawPositions;\n    if (!dualWinningSideChange) {\n      return decorateResult({ result: { ...SUCCESS, ...annotate }, stack });\n    }\n  }\n\n  if (isAdHocMatchUp) {\n    return decorateResult({ result: { ...SUCCESS, ...annotate }, stack });\n  }\n\n  if (drawPositions) {\n    // if projectedWinningSide is present then a TEAM matchUp is being directed, not the tieMatchUp\n    const winningIndex = projectedWinningSide\n      ? projectedWinningSide - 1\n      : winningSide - 1;\n    const losingIndex = 1 - winningIndex;\n\n    const winningDrawPosition = drawPositions[winningIndex];\n    const loserDrawPosition = drawPositions[losingIndex];\n\n    const {\n      targetLinks: { loserTargetLink, winnerTargetLink, byeTargetLink },\n      targetMatchUps: {\n        winnerMatchUpDrawPositionIndex, // only present when positionTargets found without winnerMatchUpId\n        loserMatchUpDrawPositionIndex, // only present when positionTargets found without loserMatchUpId\n        winnerMatchUp,\n        loserMatchUp,\n        byeMatchUp,\n      },\n    } = targetData;\n\n    if (winnerMatchUp) {\n      const result = directWinner({\n        sourceMatchUpStatus:\n          (matchUpStatusIsValid && matchUpStatus) || COMPLETED,\n        winnerMatchUpDrawPositionIndex,\n        sourceMatchUpId: matchUpId,\n        inContextDrawMatchUps,\n        projectedWinningSide,\n        winningDrawPosition,\n        tournamentRecord,\n        winnerTargetLink,\n        drawDefinition,\n        winnerMatchUp,\n        dualMatchUp,\n        matchUpsMap,\n        event,\n      });\n      if (result.error) return decorateResult({ result, stack });\n    }\n    if (loserMatchUp) {\n      const result = directLoser({\n        sourceMatchUpStatus:\n          (matchUpStatusIsValid && matchUpStatus) || COMPLETED,\n        loserMatchUpDrawPositionIndex,\n        sourceMatchUpId: matchUpId,\n        inContextDrawMatchUps,\n        projectedWinningSide,\n        loserDrawPosition,\n        tournamentRecord,\n        loserTargetLink,\n        drawDefinition,\n        loserMatchUp,\n        winningSide,\n        matchUpsMap,\n        dualMatchUp,\n        event,\n      });\n      if (result.error) return decorateResult({ result, stack });\n    }\n\n    if (byeMatchUp) {\n      const targetMatchUpDrawPositions = byeMatchUp.drawPositions || [];\n      const backdrawPosition = Math.min(\n        ...targetMatchUpDrawPositions.filter(Boolean)\n      );\n      const targetStructureId = byeTargetLink.target.structureId;\n      const result = assignDrawPositionBye({\n        drawPosition: backdrawPosition,\n        structureId: targetStructureId,\n        tournamentRecord,\n        drawDefinition,\n        event,\n      });\n      if (result.error) return decorateResult({ result, stack });\n    }\n  } else {\n    return decorateResult({ result: { error: MISSING_DRAW_POSITIONS }, stack });\n  }\n\n  return decorateResult({ result: { ...SUCCESS, ...annotate }, stack });\n}\n","import { removeLineUpSubstitutions } from '../../drawDefinitions/removeLineUpSubstitutions';\nimport { structureAssignedDrawPositions } from '../../../query/drawDefinition/positionsGetter';\nimport { assignDrawPosition } from './positionAssignment';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { assignMatchUpDrawPosition } from './assignMatchUpDrawPosition';\nimport { assignSeed } from '../../drawDefinitions/entryGovernor/seedAssignment';\nimport { findStructure } from '../../../acquire/findStructure';\n\nimport { QUALIFYING } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\nexport function directWinner({\n  winnerMatchUpDrawPositionIndex,\n  inContextDrawMatchUps,\n  projectedWinningSide,\n  sourceMatchUpStatus,\n  winningDrawPosition,\n  tournamentRecord,\n  winnerTargetLink,\n  sourceMatchUpId,\n  drawDefinition,\n  winnerMatchUp,\n  dualMatchUp,\n  matchUpsMap,\n  event,\n}) {\n  const stack = 'directWinner';\n\n  if (winnerTargetLink) {\n    const targetMatchUpDrawPositions = winnerMatchUp.drawPositions || [];\n    const targetMatchUpDrawPosition =\n      targetMatchUpDrawPositions[winnerMatchUpDrawPositionIndex];\n\n    const sourceStructureId = winnerTargetLink.source.structureId;\n    const result = findStructure({\n      structureId: sourceStructureId,\n      drawDefinition,\n    });\n    if (result.error) return result;\n    const { structure } = result;\n\n    const { positionAssignments: sourcePositionAssignments } =\n      structureAssignedDrawPositions({\n        structureId: sourceStructureId,\n        drawDefinition,\n      });\n\n    const relevantSourceAssignment = sourcePositionAssignments?.find(\n      (assignment) => assignment.drawPosition === winningDrawPosition\n    );\n    const winnerParticipantId = relevantSourceAssignment?.participantId;\n\n    const targetStructureId = winnerTargetLink.target.structureId;\n    const { positionAssignments: targetPositionAssignments } =\n      structureAssignedDrawPositions({\n        structureId: targetStructureId,\n        drawDefinition,\n      });\n\n    const relevantAssignment = targetPositionAssignments?.find(\n      (assignment) => assignment.participantId === winnerParticipantId\n    );\n    const winnerExistingDrawPosition = relevantAssignment?.drawPosition;\n\n    const unfilledTargetMatchUpDrawPositions = targetPositionAssignments\n      ?.filter((assignment) => {\n        const inTarget = targetMatchUpDrawPositions.includes(\n          assignment.drawPosition\n        );\n        const unfilled =\n          !assignment.participantId && !assignment.bye && !assignment.qualifier;\n        return inTarget && unfilled;\n      })\n      .map((assignment) => assignment.drawPosition);\n    const targetDrawPositionIsUnfilled =\n      unfilledTargetMatchUpDrawPositions?.includes(targetMatchUpDrawPosition);\n\n    if (\n      winnerParticipantId &&\n      winnerTargetLink.target.roundNumber === 1 &&\n      targetDrawPositionIsUnfilled\n    ) {\n      assignDrawPosition({\n        drawPosition: targetMatchUpDrawPosition,\n        participantId: winnerParticipantId,\n        structureId: targetStructureId,\n        inContextDrawMatchUps,\n        sourceMatchUpStatus,\n        tournamentRecord,\n        drawDefinition,\n        matchUpsMap,\n        event,\n      });\n    } else if (\n      winnerParticipantId &&\n      unfilledTargetMatchUpDrawPositions?.length\n    ) {\n      const drawPosition = unfilledTargetMatchUpDrawPositions.pop();\n      drawPosition &&\n        assignDrawPosition({\n          participantId: winnerParticipantId,\n          structureId: targetStructureId,\n          inContextDrawMatchUps,\n          sourceMatchUpStatus,\n          tournamentRecord,\n          drawDefinition,\n          drawPosition,\n          matchUpsMap,\n          event,\n        });\n    } else if (winnerExistingDrawPosition) {\n      const result = assignMatchUpDrawPosition({\n        drawPosition: winnerExistingDrawPosition,\n        matchUpId: winnerMatchUp.matchUpId,\n        inContextDrawMatchUps,\n        sourceMatchUpStatus,\n        tournamentRecord,\n        sourceMatchUpId,\n        drawDefinition,\n        matchUpsMap,\n      });\n      if (result.error) return decorateResult({ result, stack });\n    } else {\n      // qualifiers do not get automatically directed\n      if (structure?.stage !== QUALIFYING) {\n        const error = 'winner target position unavaiallble';\n        console.log(error);\n        return { error };\n      }\n    }\n\n    // propagate seedAssignments\n    if (\n      structure?.seedAssignments &&\n      structure.structureId !== targetStructureId\n    ) {\n      const seedAssignment = structure.seedAssignments.find(\n        ({ participantId }) => participantId === winnerParticipantId\n      );\n      const participantId = seedAssignment?.participantId;\n      if (seedAssignment && participantId) {\n        assignSeed({\n          eventId: winnerMatchUp?.eventId,\n          structureId: targetStructureId,\n          ...seedAssignment,\n          tournamentRecord,\n          drawDefinition,\n          participantId,\n        });\n      }\n    }\n  } else {\n    const result = assignMatchUpDrawPosition({\n      matchUpId: winnerMatchUp.matchUpId,\n      drawPosition: winningDrawPosition,\n      inContextDrawMatchUps,\n      sourceMatchUpStatus,\n      tournamentRecord,\n      sourceMatchUpId,\n      drawDefinition,\n      matchUpsMap,\n    });\n    if (result.error) return result;\n  }\n\n  if (dualMatchUp && projectedWinningSide) {\n    // propagate lineUp\n    const side = dualMatchUp.sides?.find(\n      (side) => side.sideNumber === projectedWinningSide\n    );\n    if (side?.lineUp) {\n      const source = dualMatchUp.roundPosition;\n      const target = winnerMatchUp.roundPosition;\n      const targetSideNumber =\n        (source === target && source !== 1) || Math.floor(source / 2) === target\n          ? 2\n          : 1; // this may need to take roundNumber into consideration for cross structure propagation of lineUps\n\n      const targetMatchUp = matchUpsMap?.drawMatchUps?.find(\n        ({ matchUpId }) => matchUpId === winnerMatchUp.matchUpId\n      );\n\n      const updatedSides = [1, 2].map((sideNumber) => {\n        const existingSide =\n          targetMatchUp.sides?.find((side) => side.sideNumber === sideNumber) ||\n          {};\n        return { ...existingSide, sideNumber };\n      });\n\n      targetMatchUp.sides = updatedSides;\n      const targetSide = targetMatchUp.sides.find(\n        (side) => side.sideNumber === targetSideNumber\n      );\n\n      // attach to appropriate side of winnerMatchUp\n      if (targetSide) {\n        const filteredLineUp = side.lineUp?.filter(\n          (assignment) => assignment?.participantId\n        );\n\n        targetSide.lineUp = removeLineUpSubstitutions({\n          lineUp: filteredLineUp,\n        });\n\n        modifyMatchUpNotice({\n          tournamentId: tournamentRecord?.tournamentId,\n          eventId: winnerMatchUp?.eventId,\n          matchUp: targetMatchUp,\n          context: stack,\n          drawDefinition,\n        });\n      }\n    }\n  }\n\n  return { ...SUCCESS };\n}\n","import { structureAssignedDrawPositions } from '../../../query/drawDefinition/positionsGetter';\nimport { removeLineUpSubstitutions } from '../../drawDefinitions/removeLineUpSubstitutions';\nimport { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { checkScoreHasValue } from '../../../query/matchUp/checkScoreHasValue';\nimport { assignSeed } from '../../drawDefinitions/entryGovernor/seedAssignment';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { assignDrawPositionBye } from './assignDrawPositionBye';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { assignDrawPosition } from './positionAssignment';\nimport { numericSort } from '../../../utilities/sorting';\n\nimport { DEFAULTED, WALKOVER } from '../../../constants/matchUpStatusConstants';\nimport { FIRST_MATCHUP } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_DRAW_POSITION,\n  MISSING_PARTICIPANT_ID,\n} from '../../../constants/errorConditionConstants';\n\n/*\n  FIRST_MATCH_LOSER_CONSOLATION linkCondition... check whether it is a participant's first \n*/\nexport function directLoser(params) {\n  const {\n    loserMatchUpDrawPositionIndex,\n    inContextDrawMatchUps,\n    projectedWinningSide,\n    sourceMatchUpStatus,\n    loserDrawPosition,\n    tournamentRecord,\n    loserTargetLink,\n    drawDefinition,\n    loserMatchUp,\n    dualMatchUp,\n    matchUpsMap,\n    event,\n  } = params;\n  const stack = 'directLoser';\n  const loserLinkCondition = loserTargetLink.linkCondition;\n  const targetMatchUpDrawPositions = loserMatchUp.drawPositions || [];\n\n  const fedDrawPositionFMLC =\n    loserLinkCondition === FIRST_MATCHUP &&\n    loserMatchUp.roundNumber === 2 &&\n    Math.min(...targetMatchUpDrawPositions.filter(Boolean));\n\n  const targetMatchUpDrawPosition =\n    fedDrawPositionFMLC ||\n    targetMatchUpDrawPositions[loserMatchUpDrawPositionIndex];\n  const loserBackdrawPosition =\n    fedDrawPositionFMLC ||\n    targetMatchUpDrawPositions[1 - loserMatchUpDrawPositionIndex];\n\n  const sourceStructureId = loserTargetLink.source.structureId;\n  const { structure } = findStructure({\n    structureId: sourceStructureId,\n    drawDefinition,\n  });\n  const { matchUps: sourceMatchUps } = getAllStructureMatchUps({\n    afterRecoveryTimes: false,\n    inContext: true,\n    drawDefinition,\n    structure,\n    event,\n  });\n\n  const drawPositionMatchUps = sourceMatchUps.filter(\n    (matchUp) => matchUp.drawPositions?.includes(loserDrawPosition)\n  );\n\n  // in this calculation BYEs and WALKOVERs are not counted as wins\n  // as well as DEFAULTED when there is no score component\n  const loserDrawPositionWins = drawPositionMatchUps.filter((matchUp) => {\n    const drawPositionSide = matchUp.sides.find(\n      (side) => side.drawPosition === loserDrawPosition\n    );\n    const unscoredOutcome =\n      matchUp.matchUpStatus === WALKOVER ||\n      (matchUp.matchUpStatus === DEFAULTED && !checkScoreHasValue(matchUp));\n    return (\n      drawPositionSide?.sideNumber === matchUp.winningSide && !unscoredOutcome\n    );\n  });\n\n  const validForConsolation =\n    loserLinkCondition === FIRST_MATCHUP && loserDrawPositionWins.length === 0;\n\n  const { positionAssignments: sourcePositionAssignments } =\n    structureAssignedDrawPositions({\n      structureId: sourceStructureId,\n      drawDefinition,\n    });\n\n  const relevantAssignment = sourcePositionAssignments?.find(\n    (assignment) => assignment.drawPosition === loserDrawPosition\n  );\n  const loserParticipantId = relevantAssignment?.participantId;\n\n  const targetStructureId = loserTargetLink.target.structureId;\n  const { positionAssignments: targetPositionAssignments } =\n    structureAssignedDrawPositions({\n      structureId: targetStructureId,\n      drawDefinition,\n    });\n\n  const targetMatchUpPositionAssignments = targetPositionAssignments?.filter(\n    ({ drawPosition }) => targetMatchUpDrawPositions.includes(drawPosition)\n  );\n\n  const loserAlreadyDirected = targetMatchUpPositionAssignments?.some(\n    (assignment) => assignment.participantId === loserParticipantId\n  );\n\n  if (loserAlreadyDirected) {\n    return { ...SUCCESS };\n  }\n\n  const unfilledTargetMatchUpDrawPositions = targetMatchUpPositionAssignments\n    ?.filter((assignment) => {\n      const inTarget = targetMatchUpDrawPositions.includes(\n        assignment.drawPosition\n      );\n      const unfilled =\n        !assignment.participantId && !assignment.bye && !assignment.qualifier;\n      return inTarget && unfilled;\n    })\n    .map((assignment) => assignment.drawPosition);\n\n  const targetDrawPositionIsUnfilled =\n    unfilledTargetMatchUpDrawPositions?.includes(targetMatchUpDrawPosition);\n\n  const isFeedRound =\n    loserTargetLink.target.roundNumber > 1 &&\n    unfilledTargetMatchUpDrawPositions?.length;\n\n  const isFirstRoundValidDrawPosition =\n    loserTargetLink.target.roundNumber === 1 && targetDrawPositionIsUnfilled;\n\n  if (fedDrawPositionFMLC) {\n    const result = loserLinkFedFMLC();\n    if (result.error) return decorateResult({ result, stack });\n  } else if (isFirstRoundValidDrawPosition) {\n    const result = asssignLoserDrawPosition();\n    if (result.error) return decorateResult({ result, stack });\n  } else if (loserParticipantId && isFeedRound) {\n    // if target.roundNumber > 1 then it is a feed round and should always take the lower drawPosition\n    unfilledTargetMatchUpDrawPositions.sort(numericSort);\n    const fedDrawPosition = unfilledTargetMatchUpDrawPositions[0];\n    const result = assignDrawPosition({\n      participantId: loserParticipantId,\n      structureId: targetStructureId,\n      drawPosition: fedDrawPosition,\n      inContextDrawMatchUps,\n      sourceMatchUpStatus,\n      tournamentRecord,\n      drawDefinition,\n      matchUpsMap,\n      event,\n    });\n    if (result.error) return decorateResult({ result, stack });\n  } else {\n    return decorateResult({\n      result: { error: INVALID_DRAW_POSITION },\n      context: { loserDrawPosition, loserTargetLink },\n      stack,\n    });\n  }\n\n  if (\n    structure?.seedAssignments &&\n    structure.structureId !== targetStructureId\n  ) {\n    const seedAssignment = structure.seedAssignments.find(\n      ({ participantId }) => participantId === loserParticipantId\n    );\n    const participantId = seedAssignment?.participantId;\n    if (seedAssignment && participantId) {\n      assignSeed({\n        eventId: loserMatchUp?.eventId,\n        structureId: targetStructureId,\n        ...seedAssignment,\n        tournamentRecord,\n        drawDefinition,\n        participantId,\n      });\n    }\n  }\n\n  if (dualMatchUp && projectedWinningSide) {\n    // propagated lineUp\n    const side = dualMatchUp.sides?.find(\n      (side) => side.sideNumber === 3 - projectedWinningSide\n    );\n    if (side?.lineUp) {\n      const { roundNumber, eventId } = loserMatchUp;\n      const { roundPosition } = dualMatchUp;\n      // for matchUps fed to different structures, sideNumber is always 1 when roundNumber > 1 (fed position)\n      // when roundNumber === 1 then it is even/odd calculated as remainder of roundPositon % 2 + 1\n      const targetSideNumber = roundNumber === 1 ? 2 - (roundPosition % 2) : 1;\n\n      const targetMatchUp = matchUpsMap?.drawMatchUps?.find(\n        ({ matchUpId }) => matchUpId === loserMatchUp.matchUpId\n      );\n\n      const updatedSides = [1, 2].map((sideNumber) => {\n        const existingSide =\n          targetMatchUp.sides?.find((side) => side.sideNumber === sideNumber) ||\n          {};\n        return { ...existingSide, sideNumber };\n      });\n\n      targetMatchUp.sides = updatedSides;\n      const targetSide = targetMatchUp.sides.find(\n        (side) => side.sideNumber === targetSideNumber\n      );\n\n      // attach to appropriate side of winnerMatchUp\n      if (targetSide) {\n        targetSide.lineUp = removeLineUpSubstitutions({ lineUp: side.lineUp });\n\n        modifyMatchUpNotice({\n          tournamentId: tournamentRecord?.tournamentId,\n          matchUp: targetMatchUp,\n          context: stack,\n          drawDefinition,\n          eventId,\n        });\n      }\n    }\n  }\n\n  return { ...SUCCESS };\n\n  function loserLinkFedFMLC() {\n    const stack = 'loserLinkFedFMLC';\n    if (validForConsolation) {\n      return decorateResult({ result: asssignLoserDrawPosition(), stack });\n    } else {\n      return decorateResult({ result: assignLoserPositionBye(), stack });\n    }\n  }\n\n  function assignLoserPositionBye() {\n    const result = assignDrawPositionBye({\n      drawPosition: loserBackdrawPosition,\n      structureId: targetStructureId,\n      tournamentRecord,\n      drawDefinition,\n      event,\n    });\n    return decorateResult({ result, stack: 'assignLoserPositionBye' });\n  }\n\n  function asssignLoserDrawPosition() {\n    const result = loserParticipantId\n      ? assignDrawPosition({\n          drawPosition: targetMatchUpDrawPosition,\n          participantId: loserParticipantId,\n          structureId: targetStructureId,\n          inContextDrawMatchUps,\n          sourceMatchUpStatus,\n          tournamentRecord,\n          drawDefinition,\n          matchUpsMap,\n          event,\n        })\n      : { error: MISSING_PARTICIPANT_ID };\n\n    return decorateResult({ result, stack: 'assignLoserDrawPosition' });\n  }\n}\n","// import { getMatchUpsMap } from '../../getters/getMatchUps/getMatchUpsMap';\nimport { positionTargets } from '../../matchUps/drawPositions/positionTargets';\n\nimport { FIRST_MATCHUP } from '../../../constants/drawDefinitionConstants';\nimport {\n  BYE,\n  DEFAULTED,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\n\nexport function isActiveDownstream(params) {\n  // relevantLink is passed in iterative calls (see below)\n  const { inContextDrawMatchUps, targetData, drawDefinition, relevantLink } =\n    params;\n\n  // const matchUpsMap = params.matchUpsMap || getMatchUpsMap({ drawDefinition });\n\n  const fmlcBYE =\n    relevantLink?.linkCondition === FIRST_MATCHUP &&\n    targetData?.matchUp?.matchUpStatus === BYE;\n\n  if (fmlcBYE) return false;\n\n  const {\n    targetMatchUps: { loserMatchUp, winnerMatchUp },\n    targetLinks,\n  } = targetData;\n\n  const loserMatchUpExit = [DEFAULTED, WALKOVER].includes(\n    loserMatchUp?.matchUpStatus\n  );\n\n  const winnerDrawPositionsCount =\n    winnerMatchUp?.drawPositions?.filter(Boolean).length || 0;\n\n  // if a winnerMatchUp contains a WALKOVER and its source matchUps have no winningSides it cannot be considered active\n  // unless one of its downstream matchUps is active\n  /*\n  const winnerSourceMatchUps =\n    winnerMatchUp &&\n    params.matchUpsMap.drawMatchUps.filter(\n      ({ winnerMatchUpId }) => winnerMatchUpId === winnerMatchUp.matchUpId\n    );\n    */\n\n  if (\n    (loserMatchUp?.winningSide && !loserMatchUpExit) ||\n    // NOTE: produced WALKOVER, DEFAULTEED fed into consolation structures should NOT be considered active\n    (winnerMatchUp?.winningSide &&\n      winnerDrawPositionsCount === 2 &&\n      (!winnerMatchUp.feedRound ||\n        ![WALKOVER, DEFAULTED].includes(winnerMatchUp?.matchUpStatus)))\n  ) {\n    return true;\n  }\n\n  const loserTargetData =\n    loserMatchUp &&\n    positionTargets({\n      matchUpId: loserMatchUp.matchUpId,\n      inContextDrawMatchUps,\n      drawDefinition,\n    });\n\n  const winnerTargetData =\n    winnerMatchUp &&\n    positionTargets({\n      matchUpId: winnerMatchUp.matchUpId,\n      inContextDrawMatchUps,\n      drawDefinition,\n    });\n\n  const loserActive =\n    loserTargetData &&\n    isActiveDownstream({\n      relevantLink: targetLinks?.loserTargetLink,\n      targetData: loserTargetData,\n      inContextDrawMatchUps,\n      drawDefinition,\n    });\n\n  const winnerActive =\n    winnerTargetData &&\n    isActiveDownstream({\n      targetData: winnerTargetData,\n      inContextDrawMatchUps,\n      drawDefinition,\n    });\n\n  return !!(winnerActive || loserActive);\n}\n","import { removeDirectedParticipants } from '../../matchUps/drawPositions/removeDirectedParticipants';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { checkConnectedStructures } from './checkConnectedStructures';\nimport { attemptToModifyScore } from './attemptToModifyScore';\nimport { directParticipants } from '../../matchUps/drawPositions/directParticipants';\nimport { replaceQualifier } from './replaceQualifier';\nimport { placeQualifier } from './placeQualifier';\n\nimport { POLICY_TYPE_PROGRESSION } from '../../../constants/policyConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\nexport function attemptToSetWinningSide(params) {\n  const stack = 'attemptToSetWinningSide';\n  let connectedStructures;\n\n  const {\n    appliedPolicies,\n    disableAutoCalc,\n    drawDefinition,\n    dualMatchUp,\n    winningSide,\n    structure,\n    matchUp,\n  } = params;\n\n  // disableAutoCalc means the score is being set manually\n  if (dualMatchUp?._disableAutoCalc && disableAutoCalc !== false) {\n    return attemptToModifyScore(params);\n  }\n\n  if (matchUp.winningSide && matchUp.winningSide !== winningSide) {\n    // only applies when progression is based on WIN_RATIO, e.g. ROUND_ROBIN_WITH_PLAYOFF\n    const { connectedStructureIds } = checkConnectedStructures({\n      drawDefinition,\n      structure,\n      matchUp,\n    });\n    if (connectedStructureIds.length) {\n      // TODO: return a message if there are effects in connected structures\n      console.log({ connectedStructureIds });\n      connectedStructures = true;\n    }\n\n    const result = removeDirectedParticipants(params);\n    if (result.error) return result;\n  }\n\n  const result = directParticipants(params);\n  if (result.error) return decorateResult({ result, stack });\n\n  let qualifierReplaced, qualifierPlaced;\n  if (\n    params.qualifierChanging &&\n    appliedPolicies?.[POLICY_TYPE_PROGRESSION]?.autoReplaceQualifiers\n  ) {\n    qualifierReplaced = replaceQualifier(params).qualifierReplaced;\n  }\n\n  if (\n    params.qualifierAdvancing &&\n    appliedPolicies?.[POLICY_TYPE_PROGRESSION]?.autoPlaceQualifiers\n  ) {\n    qualifierPlaced = placeQualifier(params).qualifierPlaced;\n  }\n\n  return decorateResult({\n    result: definedAttributes({\n      ...SUCCESS,\n      ...result, // capture attributes from directParticipants\n      connectedStructures,\n      qualifierReplaced,\n      qualifierPlaced,\n    }),\n    stack,\n  });\n}\n","import { modifyPositionAssignmentsNotice } from '../../notifications/drawNotifications';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { positionTargets } from '../../matchUps/drawPositions/positionTargets';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { isActiveDownstream } from './isActiveDownstream';\n\nimport { TO_BE_PLAYED } from '../../../constants/matchUpStatusConstants';\nimport { DRAW } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\nexport function replaceQualifier(params) {\n  let qualifierReplaced;\n  const {\n    inContextDrawMatchUps,\n    inContextMatchUp,\n    drawDefinition,\n    winningSide,\n  } = params;\n\n  const winnerTargetLink = params.targetData.targetLinks?.winnerTargetLink;\n\n  if (winnerTargetLink.target.feedProfile === DRAW) {\n    const previousWinningParticipantId = inContextMatchUp.sides.find(\n      ({ sideNumber }) => sideNumber !== winningSide\n    ).participantId;\n    const mainDrawTargetMatchUp = inContextDrawMatchUps.find(\n      (m) =>\n        m.structureId === winnerTargetLink.target.structureId &&\n        m.roundNumber === winnerTargetLink.target.roundNumber &&\n        m.sides.some(\n          ({ participantId }) => participantId === previousWinningParticipantId\n        )\n    );\n    if (mainDrawTargetMatchUp?.matchUpStatus === TO_BE_PLAYED) {\n      // prevoius winningSide participant was placed in MAIN\n      const targetData = positionTargets({\n        matchUpId: mainDrawTargetMatchUp.matchUpId,\n        inContextDrawMatchUps,\n        drawDefinition,\n      });\n      const activeDownstream = isActiveDownstream({\n        inContextDrawMatchUps,\n        drawDefinition,\n        targetData,\n      });\n      if (!activeDownstream) {\n        const { structure } = findStructure({\n          structureId: mainDrawTargetMatchUp.structureId,\n          drawDefinition,\n        });\n        const positionAssignments = getPositionAssignments({\n          structure,\n        }).positionAssignments;\n        for (const positionAssignment of positionAssignments || []) {\n          if (\n            positionAssignment.participantId === previousWinningParticipantId\n          ) {\n            const newWinningParticipantId = inContextMatchUp.sides.find(\n              ({ sideNumber }) => sideNumber === winningSide\n            ).participantId;\n            positionAssignment.participantId = newWinningParticipantId;\n\n            // update positionAssignments on structure\n            if (structure?.positionAssignments) {\n              structure.positionAssignments = positionAssignments;\n            } else if (structure?.structures) {\n              const assignmentMap = Object.assign(\n                {},\n                ...(positionAssignments || []).map((assignment) => ({\n                  [assignment.drawPosition]: assignment.participantId,\n                }))\n              );\n              for (const subStructure of structure.structures) {\n                subStructure.positionAssignments?.forEach(\n                  (assignment) =>\n                    (assignment.participantId =\n                      assignmentMap[assignment.drawPosition])\n                );\n              }\n            }\n\n            modifyPositionAssignmentsNotice({\n              tournamentId: params.tournamentRecord?.tournamentId,\n              event: params.event,\n              drawDefinition,\n              structure,\n            });\n            qualifierReplaced = true;\n          }\n        }\n      }\n    }\n  }\n\n  return { ...SUCCESS, qualifierReplaced };\n}\n","import { modifyPositionAssignmentsNotice } from '../../notifications/drawNotifications';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { positionTargets } from '../../matchUps/drawPositions/positionTargets';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { isActiveDownstream } from './isActiveDownstream';\nimport { randomMember } from '../../../utilities/arrays';\n\nimport { STRUCTURE_NOT_FOUND } from '../../../constants/errorConditionConstants';\nimport { TO_BE_PLAYED } from '../../../constants/matchUpStatusConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { DRAW } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\nexport function placeQualifier(\n  params\n): ResultType & { qualifierPlaced?: boolean } {\n  let qualifierPlaced;\n  const {\n    inContextDrawMatchUps,\n    inContextMatchUp,\n    drawDefinition,\n    winningSide,\n  } = params;\n\n  const winnerTargetLink = params.targetData.targetLinks?.winnerTargetLink;\n\n  if (winnerTargetLink.target.feedProfile === DRAW) {\n    const winningQualifierId = inContextMatchUp.sides.find(\n      ({ sideNumber }) => sideNumber === winningSide\n    )?.participantId;\n\n    const mainDrawQualifierMatchUps = inContextDrawMatchUps.filter(\n      (m) =>\n        m.structureId === winnerTargetLink.target.structureId &&\n        m.roundNumber === winnerTargetLink.target.roundNumber &&\n        m.sides.some(\n          ({ participantId, qualifier }) => qualifier && !participantId\n        )\n    );\n    const mainDrawTargetMatchUp = randomMember(mainDrawQualifierMatchUps);\n    if (mainDrawTargetMatchUp?.matchUpStatus === TO_BE_PLAYED) {\n      const targetData = positionTargets({\n        matchUpId: mainDrawTargetMatchUp.matchUpId,\n        inContextDrawMatchUps,\n        drawDefinition,\n      });\n      const activeDownstream = isActiveDownstream({\n        inContextDrawMatchUps,\n        drawDefinition,\n        targetData,\n      });\n      if (!activeDownstream) {\n        const targetDrawPosition = mainDrawTargetMatchUp.sides.find(\n          (side) => side.qualifier && !side.participantId\n        )?.drawPosition;\n        const { structure } = findStructure({\n          structureId: mainDrawTargetMatchUp.structureId,\n          drawDefinition,\n        });\n        if (!structure) return { error: STRUCTURE_NOT_FOUND };\n        const positionAssignments = getPositionAssignments({\n          structure,\n        }).positionAssignments;\n\n        for (const positionAssignment of positionAssignments || []) {\n          if (\n            positionAssignment.drawPosition === targetDrawPosition &&\n            !positionAssignment.participantId\n          ) {\n            positionAssignment.participantId = winningQualifierId;\n\n            // update positionAssignments on structure\n            if (structure.positionAssignments) {\n              structure.positionAssignments = positionAssignments;\n            } else if (structure.structures) {\n              const assignmentMap = Object.assign(\n                {},\n                ...(positionAssignments || []).map((assignment) => ({\n                  [assignment.drawPosition]: assignment.participantId,\n                }))\n              );\n              for (const subStructure of structure.structures) {\n                subStructure.positionAssignments?.forEach(\n                  (assignment) =>\n                    (assignment.participantId =\n                      assignmentMap[assignment.drawPosition])\n                );\n              }\n            }\n\n            modifyPositionAssignmentsNotice({\n              tournamentId: params.tournamentRecord?.tournamentId,\n              event: params.event,\n              drawDefinition,\n              structure,\n            });\n            qualifierPlaced = true;\n          }\n        }\n      }\n    }\n  }\n\n  return { ...SUCCESS, qualifierPlaced };\n}\n","import { getPairedPreviousMatchUp } from '../positionGovernor/getPairedPreviousMatchup';\nimport { positionTargets } from '../../matchUps/drawPositions/positionTargets';\nimport { modifyMatchUpScore } from '../../matchUps/score/modifyMatchUpScore';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { intersection, overlap } from '../../../utilities/arrays';\nimport { findStructure } from '../../../acquire/findStructure';\nimport {\n  removeDirectedBye,\n  removeDirectedWinner,\n} from '../../matchUps/drawPositions/removeDirectedParticipants';\n\nimport { pushGlobalLog } from '../../../global/functions/globalLog';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  BYE,\n  completedMatchUpStatuses,\n  DEFAULTED,\n  DOUBLE_DEFAULT,\n  DOUBLE_WALKOVER,\n  TO_BE_PLAYED,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\n\nconst keyColors = {\n  drawPositionToRemove: 'green',\n  iteration: 'brightred',\n  winner: 'green',\n  loser: 'brightred',\n};\n\nexport function removeDoubleExit(params) {\n  const {\n    inContextDrawMatchUps,\n    appliedPolicies,\n    drawDefinition,\n    matchUpsMap,\n    targetData,\n    matchUp,\n  } = params;\n\n  let { iteration = 0 } = params;\n  iteration += 1;\n\n  const stack = 'removeDoubleExit';\n\n  pushGlobalLog({\n    method: stack,\n    color: 'brightyellow',\n    iteration,\n    keyColors,\n  });\n\n  const {\n    targetLinks: { loserTargetLink },\n    targetMatchUps: { loserMatchUp, winnerMatchUp, loserTargetDrawPosition },\n  } = targetData;\n\n  // only handles winnerMatchUps in the same structure\n  if (winnerMatchUp && winnerMatchUp.matchUpStatus !== BYE) {\n    const { stage, roundNumber, roundPosition } = winnerMatchUp;\n    pushGlobalLog({\n      winner: 'winner',\n      stage,\n      roundNumber,\n      roundPosition,\n      keyColors,\n    });\n    conditionallyRemoveDrawPosition({\n      ...params,\n      targetMatchUp: winnerMatchUp,\n      sourceMatchUp: matchUp,\n      iteration,\n    });\n  }\n\n  if (loserMatchUp && loserMatchUp.matchUpStatus !== BYE) {\n    const inContextLoserMatchUp = inContextDrawMatchUps.find(\n      ({ matchUpId }) => matchUpId === loserMatchUp.matchUpId\n    );\n    const { structure: loserStructure } = findStructure({\n      drawDefinition,\n      structureId: inContextLoserMatchUp.structureId,\n    });\n    const { stage, roundNumber, roundPosition, feedRound } = loserMatchUp;\n    pushGlobalLog({\n      loser: 'loser',\n      stage,\n      roundNumber,\n      roundPosition,\n      keyColors,\n      feedRound,\n    });\n    if (appliedPolicies?.progression?.doubleExitPropagateBye) {\n      removeDirectedBye({\n        drawPosition: loserTargetDrawPosition,\n        targetLink: loserTargetLink,\n        inContextDrawMatchUps,\n        drawDefinition,\n        matchUpsMap,\n      });\n    } else {\n      const result = conditionallyRemoveDrawPosition({\n        ...params,\n        structure: loserStructure,\n        targetMatchUp: loserMatchUp,\n        iteration,\n      });\n      if (result.error) return decorateResult({ result, stack });\n    }\n  }\n  return decorateResult({ result: { ...SUCCESS }, stack });\n}\n\nexport function conditionallyRemoveDrawPosition(params) {\n  const {\n    inContextDrawMatchUps,\n    appliedPolicies,\n    drawDefinition,\n    sourceMatchUp,\n    targetMatchUp,\n    matchUpsMap,\n    structure,\n    iteration,\n  } = params;\n\n  const stack = 'conditionallyRemoveDrawPosition';\n  pushGlobalLog({ method: stack });\n\n  // only handles winnerMatchUps in the same structure\n  const nextTargetData = positionTargets({\n    matchUpId: targetMatchUp.matchUpId,\n    inContextDrawMatchUps,\n    drawDefinition,\n  });\n\n  const {\n    targetMatchUps: { winnerMatchUp: nextWinnerMatchUp },\n  } = nextTargetData;\n\n  const noContextTargetMatchUp = matchUpsMap?.drawMatchUps.find(\n    (matchUp) => matchUp.matchUpId === targetMatchUp.matchUpId\n  );\n\n  let pairedPreviousDrawPositions = [];\n  let pairedPreviousDoubleExit;\n  let pairedPreviousMatchUp;\n  let drawPositionToRemove;\n\n  // targetMatchUp has context\n  if (targetMatchUp.feedRound) {\n    const nextWinnerDrawPositions =\n      nextWinnerMatchUp?.drawPositions?.filter(Boolean);\n    drawPositionToRemove = nextWinnerDrawPositions?.find((drawPosition) =>\n      targetMatchUp.drawPositions.includes(drawPosition)\n    );\n  } else if (!sourceMatchUp) {\n    drawPositionToRemove = intersection(\n      targetMatchUp?.drawPositions || [],\n      nextWinnerMatchUp?.drawPositions || []\n    )?.[0];\n  } else {\n    pairedPreviousMatchUp = getPairedPreviousMatchUp({\n      structureId: structure.structureId,\n      matchUp: sourceMatchUp,\n      matchUpsMap,\n    })?.pairedPreviousMatchUp;\n\n    pairedPreviousDoubleExit = [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(\n      pairedPreviousMatchUp?.matchUpStatus\n    );\n\n    pairedPreviousDrawPositions =\n      pairedPreviousMatchUp?.drawPositions?.filter(Boolean) || [];\n\n    const pairedPreviousMatchUpComplete =\n      [...completedMatchUpStatuses, BYE].includes(\n        pairedPreviousMatchUp?.matchUpStatus\n      ) || pairedPreviousMatchUp?.winningSide;\n\n    if (pairedPreviousMatchUpComplete) {\n      const sourceDrawPositions = sourceMatchUp.drawPositions || [];\n      let targetDrawPositions = targetMatchUp.drawPositions?.filter(Boolean);\n      if (overlap(sourceDrawPositions, targetDrawPositions)) {\n        targetDrawPositions = targetDrawPositions?.filter(\n          (drawPosition) => !sourceDrawPositions.includes(drawPosition)\n        );\n      }\n\n      const possibleBranchDrawPositions = sourceDrawPositions.concat(\n        pairedPreviousDrawPositions\n      );\n      drawPositionToRemove = possibleBranchDrawPositions.find(\n        (drawPosition) => targetDrawPositions?.includes(drawPosition)\n      );\n    }\n  }\n\n  if (nextWinnerMatchUp && drawPositionToRemove) {\n    const { stage, roundNumber, roundPosition } = nextWinnerMatchUp;\n    pushGlobalLog({\n      method: 'removeDirectedWinner',\n      drawPositionToRemove,\n      keyColors,\n      color: 'brightgreen',\n      stage,\n      roundNumber,\n      roundPosition,\n    });\n    removeDirectedWinner({\n      winningDrawPosition: drawPositionToRemove,\n      winnerMatchUp: nextWinnerMatchUp,\n      inContextDrawMatchUps,\n      drawDefinition,\n      matchUpsMap,\n    });\n  }\n\n  let result = removeDoubleExit({\n    targetData: nextTargetData,\n    matchUp: targetMatchUp,\n    inContextDrawMatchUps,\n    appliedPolicies,\n    drawDefinition,\n    matchUpsMap,\n    structure,\n    iteration,\n  });\n  if (result.error) return decorateResult({ result, stack });\n\n  const matchUpStatus = getMatchUpStatus({\n    pairedPreviousDoubleExit,\n    noContextTargetMatchUp,\n  });\n\n  const removeScore = !pairedPreviousDoubleExit;\n  result = modifyMatchUpScore({\n    ...params,\n    matchUpStatus,\n    removeScore,\n    score: {\n      scoreStringSide1: '',\n      scoreStringSide2: '',\n      sets: undefined,\n    },\n    removeWinningSide: true,\n    matchUp: noContextTargetMatchUp,\n    matchUpId: targetMatchUp.matchUpId,\n    matchUpStatusCodes: [],\n  });\n\n  if (result.error) return decorateResult({ result, stack });\n\n  return { ...SUCCESS };\n}\n\nfunction getMatchUpStatus({\n  pairedPreviousDoubleExit,\n  noContextTargetMatchUp,\n}) {\n  if (noContextTargetMatchUp.matchUpStatus === BYE) return BYE;\n  if (!pairedPreviousDoubleExit) return TO_BE_PLAYED;\n  return [DOUBLE_DEFAULT, DEFAULTED].includes(\n    noContextTargetMatchUp?.matchUpStatus\n  )\n    ? DEFAULTED\n    : WALKOVER;\n}\n","import { lastSetFormatIsTimed } from '../../../assemblies/generators/matchUpFormatCode/lastSetFormatisTimed';\nimport { checkScoreHasValue } from '../../../query/matchUp/checkScoreHasValue';\nimport { removeDirectedParticipants } from '../../matchUps/drawPositions/removeDirectedParticipants';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { attemptToSetMatchUpStatus } from './attemptToSetMatchUpStatus';\nimport { checkConnectedStructures } from './checkConnectedStructures';\nimport { attemptToSetWinningSide } from './attemptToSetWinningSide';\nimport { attemptToModifyScore } from './attemptToModifyScore';\nimport { updateTieMatchUpScore } from '../../matchUps/score/tieMatchUpScore';\nimport { modifyMatchUpScore } from '../../matchUps/score/modifyMatchUpScore';\nimport { removeDoubleExit } from './removeDoubleExit';\nimport { removeQualifier } from './removeQualifier';\n\nimport { POLICY_TYPE_PROGRESSION } from '../../../constants/policyConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  ABANDONED,\n  CANCELLED,\n  DOUBLE_DEFAULT,\n  DOUBLE_WALKOVER,\n  INCOMPLETE,\n  TO_BE_PLAYED,\n} from '../../../constants/matchUpStatusConstants';\n\nexport function noDownstreamDependencies(params) {\n  const { matchUp, matchUpStatus, score, winningSide } = params;\n  const stack = 'noDownStreamDependencies';\n\n  const doubleExitCleanup =\n    [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUp?.matchUpStatus) &&\n    ![DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUpStatus);\n  if (doubleExitCleanup) {\n    const result = removeDoubleExit(params);\n    if (result.error) return decorateResult({ result, stack });\n  }\n\n  const doubleWalkover = matchUpStatus === DOUBLE_WALKOVER;\n  const scoreWithNoWinningSide =\n    checkScoreHasValue({ score }) &&\n    !doubleWalkover &&\n    ((params.isCollectionMatchUp && !params.projectedWinningSide) ||\n      !winningSide);\n\n  const timedTieMatchUp =\n    params?.inContextMatchUp?.collectionId &&\n    lastSetFormatIsTimed(params.inContextMatchUp);\n\n  const removeScore =\n    params.removeScore ||\n    (!timedTieMatchUp &&\n      ![INCOMPLETE, ABANDONED].includes(matchUpStatus || INCOMPLETE));\n\n  const removeWinningSide =\n    (params.isCollectionMatchUp &&\n      params.dualMatchUp.winningSide &&\n      !params.projectedWinningSide) ||\n    (matchUp.winningSide && !winningSide && !checkScoreHasValue({ score }));\n\n  const statusNotTBP = matchUpStatus && matchUpStatus !== TO_BE_PLAYED;\n\n  const removeDirected = (removeScore) => {\n    let connectedStructures;\n    const { structure, drawDefinition, dualMatchUp, disableAutoCalc } = params;\n\n    // disableAutoCalc means the score is being set manually\n    if (dualMatchUp?._disableAutoCalc && disableAutoCalc !== false) {\n      return attemptToModifyScore(params);\n    }\n\n    const { connectedStructureIds } = checkConnectedStructures({\n      drawDefinition,\n      structure,\n      matchUp,\n    }); // only relevant to WIN_RATIO progression\n\n    if (connectedStructureIds.length) {\n      // TODO: return a message if there are effects in connected structures\n      console.log({ connectedStructureIds });\n      connectedStructures = true;\n    }\n\n    Object.assign(params, { removeScore });\n    const result = removeDirectedParticipants(params);\n    if (result.error) return result;\n\n    if (\n      params.removingQualifier &&\n      params.appliedPolicies?.[POLICY_TYPE_PROGRESSION]?.autoRemoveQualifiers\n    ) {\n      const result = removeQualifier(params);\n      return { ...SUCCESS, connectedStructures, ...result };\n    }\n\n    return { ...SUCCESS, connectedStructures };\n  };\n\n  if (removeWinningSide && winningSide && params.isCollectionMatchUp) {\n    // this is only possible if a TEAM dualMatchUp has an SINGLES/DOUBLES matchUp winningSide change\n    return scoreModification(params);\n  }\n\n  const triggerDualWinningSide =\n    [CANCELLED, ABANDONED].includes(matchUpStatus) &&\n    params.dualWinningSideChange;\n\n  const result = ((winningSide || triggerDualWinningSide) &&\n    attemptToSetWinningSide(params)) ||\n    (scoreWithNoWinningSide && removeDirected(removeScore)) ||\n    (statusNotTBP && attemptToSetMatchUpStatus(params)) ||\n    (removeWinningSide && removeDirected(removeScore)) ||\n    (matchUp && scoreModification({ ...params, removeScore: true })) || {\n      ...SUCCESS, // unknown condition\n    };\n\n  return decorateResult({ result, stack });\n}\n\nfunction scoreModification(params) {\n  const stack = 'scoreModification';\n  const remove =\n    params.isCollectionMatchUp &&\n    params.dualMatchUp?.winningSide &&\n    !params.projectedWinningSide;\n\n  if (remove) {\n    const result = removeDirectedParticipants(params);\n    if (result.error) return result;\n  }\n  const result = modifyMatchUpScore({ ...params });\n\n  // recalculate dualMatchUp score if isCollectionMatchUp\n  if (params.isCollectionMatchUp) {\n    const { matchUpTieId, drawDefinition, event, matchUpsMap } = params;\n    const { removeWinningSide } = updateTieMatchUpScore({\n      tournamentRecord: params.tournamentRecord,\n      matchUpId: matchUpTieId,\n      drawDefinition,\n      matchUpsMap,\n      event,\n    });\n\n    if (removeWinningSide) console.log('REMOVE WINNING SIDE');\n  }\n\n  return decorateResult({ result, stack });\n}\n","import { parse } from '../..//generators/matchUpFormatCode/parse';\nimport { MatchUp } from '../../../types/tournamentTypes';\n\ntype MatchUpArg = {\n  [key: string | number | symbol]: unknown;\n} & MatchUp;\n\nexport function lastSetFormatIsTimed(inContextMatchUp: MatchUpArg): boolean {\n  const { matchUpFormat, score } = inContextMatchUp;\n  const lastSetNumber = score?.sets?.length;\n  const matchUpScoringFormat: any = matchUpFormat && parse(matchUpFormat);\n  const { setFormat, finalSetFormat, bestOf } = matchUpScoringFormat ?? {};\n  const isLastSet = bestOf && lastSetNumber === bestOf;\n  const lastSetFormat = isLastSet ? finalSetFormat || setFormat : setFormat;\n  return lastSetFormat?.timed || false;\n}\n","import { modifyPositionAssignmentsNotice } from '../../notifications/drawNotifications';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { positionTargets } from '../../matchUps/drawPositions/positionTargets';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { isActiveDownstream } from './isActiveDownstream';\n\nimport { TO_BE_PLAYED } from '../../../constants/matchUpStatusConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { DRAW } from '../../../constants/drawDefinitionConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  DrawDefinition,\n  Event,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype RemoveQualifierArgs = {\n  inContextDrawMatchUps: HydratedMatchUp[];\n  inContextMatchUp: HydratedMatchUp;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  targetData: any;\n  event?: Event;\n};\nexport function removeQualifier(\n  params: RemoveQualifierArgs\n): ResultType & { qualifierRemoved?: boolean } {\n  let qualifierRemoved;\n  const { inContextDrawMatchUps, inContextMatchUp, drawDefinition } = params;\n\n  const winnerTargetLink = params.targetData.targetLinks?.winnerTargetLink;\n\n  if (winnerTargetLink.target.feedProfile === DRAW) {\n    const previousWinningParticipantId = inContextMatchUp.sides?.find(\n      ({ sideNumber }) => sideNumber === inContextMatchUp.winningSide\n    )?.participantId;\n    const mainDrawTargetMatchUp = inContextDrawMatchUps.find(\n      (m) =>\n        m.structureId === winnerTargetLink.target.structureId &&\n        m.roundNumber === winnerTargetLink.target.roundNumber &&\n        m.sides?.some(\n          ({ participantId }) => participantId === previousWinningParticipantId\n        )\n    );\n    if (\n      mainDrawTargetMatchUp &&\n      mainDrawTargetMatchUp.matchUpStatus === TO_BE_PLAYED\n    ) {\n      // prevoius winningSide participant was placed in MAIN\n      const targetData = positionTargets({\n        matchUpId: mainDrawTargetMatchUp.matchUpId,\n        inContextDrawMatchUps,\n        drawDefinition,\n      });\n      const activeDownstream = isActiveDownstream({\n        inContextDrawMatchUps,\n        drawDefinition,\n        targetData,\n      });\n      if (!activeDownstream) {\n        const { structure } = findStructure({\n          structureId: mainDrawTargetMatchUp.structureId,\n          drawDefinition,\n        });\n        const positionAssignments = getPositionAssignments({\n          structure,\n        }).positionAssignments;\n\n        for (const positionAssignment of positionAssignments || []) {\n          if (\n            positionAssignment.participantId === previousWinningParticipantId\n          ) {\n            positionAssignment.participantId = undefined;\n\n            // update positionAssignments on structure\n            if (structure?.positionAssignments) {\n              structure.positionAssignments = positionAssignments;\n            } else if (structure?.structures) {\n              const assignmentMap = Object.assign(\n                {},\n                ...(positionAssignments || []).map((assignment) => ({\n                  [assignment.drawPosition]: assignment.participantId,\n                }))\n              );\n\n              for (const subStructure of structure?.structures || []) {\n                subStructure.positionAssignments?.forEach(\n                  (assignment) =>\n                    (assignment.participantId =\n                      assignmentMap[assignment.drawPosition])\n                );\n              }\n            }\n\n            modifyPositionAssignmentsNotice({\n              tournamentId: params.tournamentRecord?.tournamentId,\n              event: params.event,\n              drawDefinition,\n              structure,\n            });\n            qualifierRemoved = true;\n          }\n        }\n      }\n    }\n  }\n\n  return { qualifierRemoved };\n}\n","import { getVenuesAndCourts } from '../../../query/venues/venuesAndCourtsGetter';\nimport { addMatchUpTimeItem } from '../timeItems/matchUpTimeItems';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\n\nimport { DrawDefinition, Tournament } from '../../../types/tournamentTypes';\nimport { ALLOCATE_COURTS } from '../../../constants/timeItemConstants';\nimport { TEAM_MATCHUP } from '../../../constants/matchUpTypes';\nimport {\n  INVALID_MATCHUP,\n  INVALID_VALUES,\n  MISSING_MATCHUP_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../../constants/errorConditionConstants';\n\n// allocate courts for a TEAM matchUp\ntype AllocateTeamMatchUpCourtsArgs = {\n  tournamentRecords?: { [key: string]: Tournament };\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  removePriorValues?: boolean;\n  disableNotice?: boolean;\n  courtDayDate?: string;\n  matchUpId: string;\n  courtIds: any;\n};\nexport function allocateTeamMatchUpCourts({\n  removePriorValues,\n  tournamentRecords,\n  tournamentRecord,\n  drawDefinition,\n  disableNotice,\n  courtDayDate,\n  matchUpId,\n  courtIds,\n}: AllocateTeamMatchUpCourtsArgs) {\n  if (!tournamentRecord && !tournamentRecords)\n    return { error: MISSING_TOURNAMENT_RECORD };\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n  const result = findDrawMatchUp({\n    drawDefinition,\n    matchUpId,\n  });\n  if (result.error) return result;\n  if (result?.matchUp?.matchUpType !== TEAM_MATCHUP)\n    return { error: INVALID_MATCHUP };\n\n  const validCourtIds =\n    courtIds === undefined ||\n    (Array.isArray(courtIds) &&\n      courtIds.length &&\n      courtIds.every((id) => typeof id === 'string'));\n  if (!validCourtIds) return { error: INVALID_VALUES, context: { courtIds } };\n\n  let itemValue;\n  if (courtIds) {\n    const tournaments: any = tournamentRecords\n      ? tournamentRecords\n      : tournamentRecord && {\n          [tournamentRecord.tournamentId]: tournamentRecord,\n        };\n    const result = getVenuesAndCourts({\n      tournamentRecords: tournaments,\n    });\n    if (result.error) return result;\n\n    const specifiedCourts = result.courts?.filter((court) =>\n      courtIds.includes(court.courtId)\n    );\n    if (specifiedCourts?.length !== courtIds.length) {\n      return { error: INVALID_VALUES, context: { courtIds } };\n    }\n    itemValue = specifiedCourts?.map((court) => ({\n      venueId: court.venueId,\n      courtId: court.courtId,\n    }));\n  }\n\n  const timeItem = {\n    itemType: ALLOCATE_COURTS,\n    itemDate: courtDayDate,\n    itemValue,\n  };\n\n  return addMatchUpTimeItem({\n    duplicateValues: false,\n    removePriorValues,\n    tournamentRecord,\n    drawDefinition,\n    disableNotice,\n    matchUpId,\n    timeItem,\n  });\n}\n","import { addMatchUpTimeItem } from '../timeItems/matchUpTimeItems';\nimport { findVenue } from '../../venues/findVenue';\n\nimport { DrawDefinition, Tournament } from '../../../types/tournamentTypes';\nimport { ASSIGN_VENUE } from '../../../constants/timeItemConstants';\nimport {\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_MATCHUP_ID,\n} from '../../../constants/errorConditionConstants';\n\ntype AssignMatchUpVenueArgs = {\n  tournamentRecords?: { [key: string]: Tournament };\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  removePriorValues?: boolean;\n  disableNotice?: boolean;\n  matchUpId: string;\n  venueId?: string;\n};\nexport function assignMatchUpVenue({\n  removePriorValues,\n  tournamentRecords,\n  tournamentRecord,\n  drawDefinition,\n  disableNotice,\n  matchUpId,\n  venueId,\n}: AssignMatchUpVenueArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n\n  if (venueId) {\n    const result = findVenue({\n      tournamentRecords,\n      tournamentRecord,\n      venueId,\n    });\n    if (result.error) return result;\n  }\n\n  const timeItem = {\n    itemType: ASSIGN_VENUE,\n    itemValue: venueId,\n  };\n\n  return addMatchUpTimeItem({\n    duplicateValues: false,\n    removePriorValues,\n    tournamentRecord,\n    drawDefinition,\n    disableNotice,\n    matchUpId,\n    timeItem,\n  });\n}\n","import { findCourt } from '../../venues/findCourt';\nimport { addMatchUpTimeItem } from '../timeItems/matchUpTimeItems';\nimport { assignMatchUpVenue } from './assignMatchUpVenue';\n\nimport { DrawDefinition, Tournament } from '../../../types/tournamentTypes';\nimport { ASSIGN_COURT } from '../../../constants/timeItemConstants';\nimport {\n  ErrorType,\n  MISSING_MATCHUP_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../../constants/errorConditionConstants';\n\ntype AssignMatchUpCourtArgs = {\n  tournamentRecords?: { [key: string]: Tournament };\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  removePriorValues?: boolean;\n  disableNotice?: boolean;\n  courtDayDate: string;\n  matchUpId: string;\n  courtId: string;\n};\nexport function assignMatchUpCourt({\n  removePriorValues,\n  tournamentRecords,\n  tournamentRecord,\n  drawDefinition,\n  disableNotice,\n  courtDayDate,\n  matchUpId,\n  courtId, // not required as \"unasigning\" court can be achieved by setting value to `undefined`\n}: AssignMatchUpCourtArgs): { error?: ErrorType; success?: boolean } {\n  if (!tournamentRecord && !tournamentRecords)\n    return { error: MISSING_TOURNAMENT_RECORD };\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n\n  if (courtId) {\n    const result = findCourt({\n      tournamentRecords,\n      tournamentRecord,\n      courtId,\n    });\n    if (result.error) return result;\n    const venueId = result.venue?.venueId;\n\n    assignMatchUpVenue({\n      tournamentRecords,\n      tournamentRecord,\n      drawDefinition,\n      disableNotice,\n      matchUpId,\n      venueId,\n    });\n  }\n\n  const timeItem = {\n    itemType: ASSIGN_COURT,\n    itemDate: courtDayDate,\n    itemValue: courtId,\n  };\n\n  return addMatchUpTimeItem({\n    duplicateValues: false,\n    removePriorValues,\n    tournamentRecord,\n    drawDefinition,\n    disableNotice,\n    matchUpId,\n    timeItem,\n  });\n}\n","import { scheduledMatchUpDate } from '../../../query/matchUp/scheduledMatchUpDate';\nimport { matchUpTimeModifiers } from '../../../query/matchUp/timeModifiers';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { mustBeAnArray } from '../../../utilities/mustBeAnArray';\nimport { addMatchUpTimeItem } from '../timeItems/matchUpTimeItems';\nimport {\n  convertTime,\n  extractDate,\n  validTimeValue,\n} from '../../../utilities/dateTime';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  MUTUALLY_EXCLUSIVE_TIME_MODIFIERS,\n  SCHEDULED_TIME,\n  TIME_MODIFIERS,\n} from '../../../constants/timeItemConstants';\nimport {\n  INVALID_TIME,\n  INVALID_VALUES,\n  MISSING_MATCHUP_ID,\n} from '../../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  MatchUp,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype AddScheduleAttributeArgs = {\n  tournamentRecord?: Tournament;\n  removePriorValues?: boolean;\n  drawDefinition: DrawDefinition;\n  disableNotice?: boolean;\n  matchUpId: string;\n  event?: Event;\n};\n\ntype AddMatchUpScheduledTimeArgs = {\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  removePriorValues?: boolean;\n  disableNotice?: boolean;\n  scheduledTime?: string;\n  matchUpId?: string;\n  matchUp?: MatchUp;\n};\n\nexport function addMatchUpScheduledTime(params: AddMatchUpScheduledTimeArgs) {\n  const stack = 'addMatchUpScheduledTime';\n  let matchUp = params.matchUp;\n\n  const {\n    removePriorValues,\n    tournamentRecord,\n    drawDefinition,\n    disableNotice,\n    scheduledTime,\n    matchUpId,\n  } = params;\n\n  if (!matchUpId)\n    return decorateResult({ result: { error: MISSING_MATCHUP_ID }, stack });\n\n  // must support undefined as a value so that scheduledTime can be cleared\n  if (!validTimeValue(scheduledTime))\n    return decorateResult({ result: { error: INVALID_TIME }, stack });\n\n  if (!matchUp) {\n    const result = findDrawMatchUp({ drawDefinition, matchUpId });\n    if (result.error) return decorateResult({ result, stack });\n    matchUp = result.matchUp;\n  }\n\n  const timeDate = extractDate(scheduledTime);\n\n  const scheduledDate = scheduledMatchUpDate({ matchUp }).scheduledDate;\n  const keepDate = timeDate && !scheduledDate;\n\n  const existingTimeModifiers =\n    matchUpTimeModifiers({ matchUp }).timeModifiers || [];\n\n  if (existingTimeModifiers?.length) {\n    const result = addMatchUpTimeModifiers({\n      disableNotice: true,\n      removePriorValues,\n      tournamentRecord,\n      timeModifiers: [],\n      drawDefinition,\n      matchUpId,\n      matchUp,\n    });\n    if (result?.error) return decorateResult({ result, stack });\n  }\n\n  // All times stored as military time\n  const militaryTime = convertTime(scheduledTime, true, keepDate);\n  const itemValue = militaryTime;\n  const timeItem = {\n    itemType: SCHEDULED_TIME,\n    itemValue,\n  };\n\n  return addMatchUpTimeItem({\n    duplicateValues: false,\n    removePriorValues,\n    tournamentRecord,\n    drawDefinition,\n    disableNotice,\n    matchUpId,\n    timeItem,\n  });\n}\n\nexport function addMatchUpTimeModifiers({\n  removePriorValues,\n  tournamentRecord,\n  drawDefinition,\n  disableNotice,\n  timeModifiers,\n  matchUpId,\n  matchUp,\n}: AddScheduleAttributeArgs & {\n  matchUp?: HydratedMatchUp;\n  timeModifiers: any[];\n}) {\n  const stack = 'addMatchUpTimeModifiers';\n  if (!matchUpId)\n    return decorateResult({ result: { error: MISSING_MATCHUP_ID }, stack });\n\n  if (timeModifiers !== undefined && !Array.isArray(timeModifiers))\n    return decorateResult({\n      info: mustBeAnArray('timeModifiers'),\n      result: { error: INVALID_VALUES },\n      stack,\n    });\n\n  if (!matchUp) {\n    const result = findDrawMatchUp({ drawDefinition, matchUpId });\n    if (result.error) return decorateResult({ result, stack });\n    matchUp = result.matchUp;\n  }\n  let existingTimeModifiers =\n    matchUpTimeModifiers({ matchUp }).timeModifiers || [];\n  const toBeAdded = timeModifiers.filter(\n    (modifier) => !existingTimeModifiers.includes(modifier)\n  );\n  if (timeModifiers.length && !toBeAdded.length) return { ...SUCCESS };\n\n  // remove all existing exclusives if incoming includes exclusive\n  const containsExclusive = toBeAdded.some((modifier) =>\n    MUTUALLY_EXCLUSIVE_TIME_MODIFIERS.includes(modifier)\n  );\n  if (containsExclusive) {\n    existingTimeModifiers = existingTimeModifiers.filter(\n      (modifier) => !MUTUALLY_EXCLUSIVE_TIME_MODIFIERS.includes(modifier)\n    );\n\n    // scheduledTime should be removed for exclusive timeModifiers\n    const result = addMatchUpScheduledTime({\n      disableNotice: true,\n      removePriorValues,\n      scheduledTime: '',\n      tournamentRecord,\n      drawDefinition,\n      matchUpId,\n    });\n    if (result.error) return decorateResult({ result, stack });\n  }\n\n  // undefined value when array is empty;\n  const itemValue = !timeModifiers?.length\n    ? undefined\n    : [...toBeAdded, ...existingTimeModifiers];\n\n  const timeItem = {\n    itemType: TIME_MODIFIERS,\n    itemValue,\n  };\n\n  return addMatchUpTimeItem({\n    duplicateValues: false,\n    removePriorValues,\n    tournamentRecord,\n    drawDefinition,\n    disableNotice,\n    matchUpId,\n    timeItem,\n  });\n}\n","import { allocateTeamMatchUpCourts } from './allocateTeamMatchUpCourts';\nimport { getMatchUpDependencies } from '../../../query/matchUps/getMatchUpDependencies';\nimport { scheduledMatchUpDate } from '../../../query/matchUp/scheduledMatchUpDate';\nimport { getParticipants } from '../../../query/participants/getParticipants';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { addMatchUpTimeItem } from '../timeItems/matchUpTimeItems';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { findParticipant } from '../../../acquire/findParticipant';\nimport { isConvertableInteger } from '../../../utilities/math';\nimport { ensureInt } from '../../../utilities/ensureInt';\nimport { assignMatchUpCourt } from './assignMatchUpCourt';\nimport { assignMatchUpVenue } from './assignMatchUpVenue';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../../global/functions/decorateResult';\nimport {\n  addMatchUpScheduledTime,\n  addMatchUpTimeModifiers,\n} from './scheduledTime';\nimport {\n  convertTime,\n  extractDate,\n  extractTime,\n  formatDate,\n  getIsoDateString,\n  validTimeValue,\n} from '../../../utilities/dateTime';\nimport { dateValidation, validTimeString } from '../../../validators/regex';\n\nimport { INDIVIDUAL } from '../../../constants/participantConstants';\nimport { AddScheduleAttributeArgs } from '../../../types/factoryTypes';\nimport { OFFICIAL } from '../../../constants/participantRoles';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  MISSING_MATCHUP_ID,\n  INVALID_RESUME_TIME,\n  INVALID_START_TIME,\n  EXISTING_END_TIME,\n  INVALID_STOP_TIME,\n  INVALID_END_TIME,\n  INVALID_DATE,\n  INVALID_TIME,\n  MISSING_DRAW_DEFINITION,\n  MISSING_VALUE,\n  ANACHRONISM,\n  INVALID_VALUES,\n  ErrorType,\n  MISSING_PARTICIPANT_ID,\n  PARTICIPANT_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\nimport {\n  START_TIME,\n  STOP_TIME,\n  RESUME_TIME,\n  END_TIME,\n  SCHEDULED_DATE,\n  COURT_ORDER,\n} from '../../../constants/timeItemConstants';\nimport {\n  DrawDefinition,\n  Event,\n  TimeItem,\n} from '../../../types/tournamentTypes';\n\nfunction timeDate(value, scheduledDate) {\n  const time = validTimeString.test(value) ? value : extractTime(value);\n  const date =\n    extractDate(value) || extractDate(scheduledDate) || formatDate(new Date());\n\n  // doesn't matter if this is invalid due to undefined time because this is used for sorting only\n  return new Date(`${date}T${time}`).getTime();\n}\n\ntype AddMatchUpScheduleItemsArgs = {\n  inContextMatchUps?: HydratedMatchUp[];\n  drawMatchUps?: HydratedMatchUp[];\n  drawDefinition: DrawDefinition;\n  errorOnAnachronism?: boolean;\n  removePriorValues?: boolean;\n  checkChronology?: boolean;\n  matchUpDependencies?: any;\n  disableNotice?: boolean;\n  tournamentRecords: any;\n  tournamentRecord: any;\n  matchUpId: string;\n  schedule: any;\n  event?: Event;\n};\n\nexport function addMatchUpScheduleItems({\n  errorOnAnachronism = false,\n  checkChronology = true,\n  matchUpDependencies,\n  inContextMatchUps,\n  removePriorValues,\n  tournamentRecords,\n  tournamentRecord,\n  drawDefinition,\n  disableNotice,\n  drawMatchUps,\n  matchUpId,\n  schedule,\n  event,\n}: AddMatchUpScheduleItemsArgs): {\n  error?: ErrorType;\n  success?: boolean;\n  warnings?: any[];\n  info?: any;\n} {\n  if (!schedule) return { error: MISSING_VALUE, info: 'Missing schedule' };\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n\n  const stack = 'addMatchUpScheduleItems';\n  let matchUp, warning;\n\n  if (!drawMatchUps) {\n    const result = findDrawMatchUp({ drawDefinition, event, matchUpId });\n    if (result.error) return result;\n    matchUp = result.matchUp;\n  } else {\n    matchUp = drawMatchUps.find(\n      (drawMatchUp) => drawMatchUp.matchUpId === matchUpId\n    );\n  }\n\n  const {\n    endTime,\n    courtId,\n    courtIds,\n    courtOrder,\n    resumeTime,\n    scheduledDate,\n    scheduledTime,\n    startTime,\n    stopTime,\n    timeModifiers,\n    venueId,\n  } = schedule;\n\n  if (checkChronology && (!matchUpDependencies || !inContextMatchUps)) {\n    ({ matchUpDependencies, matchUps: inContextMatchUps } =\n      getMatchUpDependencies({\n        drawDefinition,\n      }));\n  }\n\n  const priorMatchUpIds = matchUpDependencies?.[matchUpId]?.matchUpIds;\n  if (schedule.scheduledDate && checkChronology && priorMatchUpIds) {\n    const priorMatchUpTimes = inContextMatchUps\n      ?.filter(\n        (matchUp) =>\n          (matchUp.schedule?.scheduledDate ||\n            extractDate(matchUp.schedule?.scheduledTime)) &&\n          priorMatchUpIds.includes(matchUp.matchUpId)\n      )\n      .map(({ schedule }) => {\n        const isoDateString = getIsoDateString(schedule);\n        return new Date(isoDateString).getTime();\n      });\n\n    if (priorMatchUpTimes?.length) {\n      const isoDateString = getIsoDateString(schedule);\n      const matchUpTime = new Date(isoDateString).getTime();\n      const maxPriorMatchUpTime = Math.max(...priorMatchUpTimes);\n      if (maxPriorMatchUpTime >= matchUpTime) {\n        if (errorOnAnachronism) {\n          return decorateResult({ result: { error: ANACHRONISM }, stack });\n        } else {\n          warning = ANACHRONISM;\n        }\n      }\n    }\n  }\n\n  if (scheduledDate !== undefined) {\n    const result = addMatchUpScheduledDate({\n      disableNotice: true,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      scheduledDate,\n      matchUpId,\n    });\n    if (result?.error)\n      return decorateResult({ result, stack, context: { scheduledDate } });\n  }\n  if (scheduledTime !== undefined) {\n    const result = addMatchUpScheduledTime({\n      disableNotice: true,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      scheduledTime,\n      matchUpId,\n      matchUp,\n    });\n    if (result?.error)\n      return decorateResult({ result, stack, context: { scheduledTime } });\n  }\n  if (startTime !== undefined) {\n    const result = addMatchUpStartTime({\n      disableNotice: true,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      matchUpId,\n      startTime,\n      event,\n    });\n    if (result?.error)\n      return decorateResult({ result, stack, context: { startTime } });\n  }\n  if (stopTime !== undefined) {\n    const result = addMatchUpStopTime({\n      disableNotice: true,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      matchUpId,\n      stopTime,\n      event,\n    });\n    if (result?.error)\n      return decorateResult({ result, stack, context: { stopTime } });\n  }\n  if (resumeTime !== undefined) {\n    const result = addMatchUpResumeTime({\n      disableNotice: true,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      resumeTime,\n      matchUpId,\n      event,\n    });\n    if (result?.error)\n      return decorateResult({ result, stack, context: { resumeTime } });\n  }\n  if (endTime !== undefined) {\n    const result = addMatchUpEndTime({\n      disableNotice: true,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      matchUpId,\n      endTime,\n      event,\n    });\n    if (result?.error)\n      return decorateResult({ result, stack, context: { endTime } });\n  }\n  if (courtIds !== undefined) {\n    const result = allocateTeamMatchUpCourts({\n      disableNotice: true,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      matchUpId,\n      courtIds,\n    });\n    if (result?.error)\n      return decorateResult({ result, stack, context: { courtIds } });\n  }\n  if (courtId !== undefined && scheduledDate !== undefined) {\n    const result = assignMatchUpCourt({\n      courtDayDate: scheduledDate,\n      disableNotice: true,\n      removePriorValues,\n      tournamentRecords,\n      tournamentRecord,\n      drawDefinition,\n      matchUpId,\n      courtId,\n    });\n    if (result?.error)\n      return decorateResult({ result, stack, context: { courtId } });\n  }\n\n  if (venueId !== undefined) {\n    const result = assignMatchUpVenue({\n      disableNotice: true,\n      removePriorValues,\n      tournamentRecords,\n      tournamentRecord,\n      drawDefinition,\n      matchUpId,\n      venueId,\n    });\n    if (result?.error)\n      return decorateResult({ result, stack, context: { venueId } });\n  }\n\n  if (courtOrder !== undefined && isConvertableInteger(courtOrder)) {\n    const result = addMatchUpCourtOrder({\n      disableNotice: true,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      courtOrder,\n      matchUpId,\n    });\n    if (result?.error)\n      return decorateResult({ result, stack, context: { courtOrder } });\n  }\n\n  if (timeModifiers !== undefined) {\n    const result = addMatchUpTimeModifiers({\n      disableNotice: true,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      timeModifiers,\n      matchUpId,\n      matchUp,\n    });\n    if (result?.error)\n      return decorateResult({ result, stack, context: { timeModifiers } });\n  }\n\n  if (!disableNotice) {\n    modifyMatchUpNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      eventId: event?.eventId,\n      context: stack,\n      drawDefinition,\n      matchUp,\n    });\n  }\n\n  return warning ? { ...SUCCESS, warnings: [warning] } : { ...SUCCESS };\n}\n\nexport function addMatchUpScheduledDate({\n  scheduledDate: dateToSchedule,\n  removePriorValues,\n  tournamentRecord,\n  drawDefinition,\n  disableNotice,\n  matchUpId,\n}: AddScheduleAttributeArgs & { scheduledDate?: string }): ResultType {\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n\n  // TODO: if there is existing scheduledDate and no other relevant timeItems, delete prior\n\n  // TODO: check that scheduledDate is within range of event dates / tournament dates\n  // TODO: check that 1) scheduledDate is valid date and 2) is in range for tournament\n  // this must be done in tournamentEngine wrapper\n\n  const validDate = dateToSchedule && dateValidation.test(dateToSchedule);\n  if (dateToSchedule && !validDate) return { error: INVALID_DATE };\n\n  const scheduledDate = extractDate(dateToSchedule);\n\n  const timeItem = {\n    itemValue: scheduledDate,\n    itemType: SCHEDULED_DATE,\n  };\n\n  return addMatchUpTimeItem({\n    duplicateValues: false,\n    removePriorValues,\n    tournamentRecord,\n    drawDefinition,\n    disableNotice,\n    matchUpId,\n    timeItem,\n  });\n}\n\nexport function addMatchUpCourtOrder({\n  removePriorValues,\n  tournamentRecord,\n  drawDefinition,\n  disableNotice,\n  courtOrder,\n  matchUpId,\n}: AddScheduleAttributeArgs & { courtOrder?: number }) {\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n\n  if (courtOrder && !isConvertableInteger(courtOrder))\n    return { error: INVALID_VALUES, info: 'courtOrder must be numeric' };\n\n  const itemValue = courtOrder && ensureInt(courtOrder);\n  const timeItem = {\n    itemType: COURT_ORDER,\n    itemValue,\n  };\n\n  return addMatchUpTimeItem({\n    duplicateValues: false,\n    removePriorValues,\n    tournamentRecord,\n    drawDefinition,\n    disableNotice,\n    matchUpId,\n    timeItem,\n  });\n}\n\nexport function addMatchUpOfficial({\n  removePriorValues,\n  tournamentRecord,\n  drawDefinition,\n  disableNotice,\n  participantId,\n  officialType,\n  matchUpId,\n}: AddScheduleAttributeArgs & {\n  participantId?: string;\n  officialType?: string;\n}) {\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n\n  // TODO: check that 1) participantId has the appropriate participantRole\n\n  if (!participantId) return { error: MISSING_PARTICIPANT_ID };\n\n  if (tournamentRecord) {\n    const tournamentParticipants =\n      getParticipants({\n        tournamentRecord,\n        participantFilters: {\n          participantTypes: [INDIVIDUAL],\n          participantRoles: [OFFICIAL],\n        },\n      }).participants ?? [];\n\n    const participant = findParticipant({\n      tournamentParticipants,\n      participantId,\n    });\n\n    if (!participant) return { error: PARTICIPANT_NOT_FOUND };\n  }\n\n  const timeItem: TimeItem = {\n    itemType: 'SCHEDULE.ASSIGNMENT.OFFICIAL',\n    itemValue: participantId,\n  };\n  if (officialType) timeItem.itemSubTypes = [officialType];\n\n  return addMatchUpTimeItem({\n    duplicateValues: false,\n    removePriorValues,\n    tournamentRecord,\n    drawDefinition,\n    disableNotice,\n    matchUpId,\n    timeItem,\n  });\n}\n\nexport function addMatchUpStartTime({\n  removePriorValues,\n  tournamentRecord,\n  drawDefinition,\n  disableNotice,\n  matchUpId,\n  startTime,\n  event,\n}: AddScheduleAttributeArgs & { startTime?: string }) {\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n  if (!validTimeValue(startTime)) return { error: INVALID_TIME };\n\n  const { matchUp } = findDrawMatchUp({ drawDefinition, event, matchUpId });\n  const { scheduledDate } = scheduledMatchUpDate({ matchUp });\n  const timeItems = matchUp?.timeItems ?? [];\n\n  const earliestRelevantTimeValue = timeItems\n    .filter((timeItem: any) =>\n      [STOP_TIME, RESUME_TIME, END_TIME].includes(timeItem?.itemType)\n    )\n    .map((timeItem) => timeDate(timeItem.itemValue, scheduledDate))\n    .reduce(\n      (earliest: any, timeValue) =>\n        !earliest || timeValue < earliest ? timeValue : earliest,\n      undefined\n    );\n\n  // START_TIME must be prior to any STOP_TIMEs, RESUME_TIMEs and STOP_TIME\n  if (\n    !earliestRelevantTimeValue ||\n    timeDate(startTime, scheduledDate) < earliestRelevantTimeValue\n  ) {\n    // there can be only one START_TIME; if a prior START_TIME exists, remove it\n    if (matchUp?.timeItems) {\n      matchUp.timeItems = matchUp.timeItems.filter(\n        (timeItem) => timeItem.itemType !== START_TIME\n      );\n    }\n\n    const militaryTime = convertTime(startTime, true, true);\n    const timeItem = { itemType: START_TIME, itemValue: militaryTime };\n\n    return addMatchUpTimeItem({\n      duplicateValues: false,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      disableNotice,\n      matchUpId,\n      timeItem,\n    });\n  } else {\n    return { error: INVALID_START_TIME };\n  }\n}\n\nexport function addMatchUpEndTime({\n  validateTimeSeries = true,\n  removePriorValues,\n  tournamentRecord,\n  drawDefinition,\n  disableNotice,\n  matchUpId,\n  endTime,\n  event,\n}: AddScheduleAttributeArgs & {\n  validateTimeSeries?: boolean;\n  endTime?: string;\n}) {\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n  if (!validTimeValue(endTime)) return { error: INVALID_TIME };\n\n  const { matchUp } = findDrawMatchUp({ drawDefinition, event, matchUpId });\n  const { scheduledDate } = scheduledMatchUpDate({ matchUp });\n  const timeItems = matchUp?.timeItems ?? [];\n\n  const latestRelevantTimeValue = timeItems\n    .filter((timeItem: any) =>\n      [START_TIME, RESUME_TIME, STOP_TIME].includes(timeItem?.itemType)\n    )\n    .map((timeItem) => timeDate(timeItem.itemValue, scheduledDate))\n    .reduce(\n      (latest: any, timeValue) =>\n        !latest || timeValue > latest ? timeValue : latest,\n      undefined\n    );\n\n  // END_TIME must be after any START_TIMEs, STOP_TIMEs, RESUME_TIMEs\n  if (\n    !validateTimeSeries ||\n    !latestRelevantTimeValue ||\n    timeDate(endTime, scheduledDate) > latestRelevantTimeValue\n  ) {\n    // there can be only one END_TIME; if a prior END_TIME exists, remove it\n    if (matchUp?.timeItems) {\n      matchUp.timeItems = matchUp.timeItems.filter(\n        (timeItem) => timeItem.itemType !== END_TIME\n      );\n    }\n\n    // All times stored as military time\n    const militaryTime = convertTime(endTime, true, true);\n    const timeItem = { itemType: END_TIME, itemValue: militaryTime };\n\n    return addMatchUpTimeItem({\n      duplicateValues: false,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      disableNotice,\n      matchUpId,\n      timeItem,\n    });\n  } else {\n    return { error: INVALID_END_TIME };\n  }\n}\n\nexport function addMatchUpStopTime({\n  removePriorValues,\n  tournamentRecord,\n  drawDefinition,\n  disableNotice,\n  matchUpId,\n  stopTime,\n  event,\n}: AddScheduleAttributeArgs & {\n  stopTime?: string;\n}) {\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n  if (!validTimeValue(stopTime)) return { error: INVALID_TIME };\n\n  const { matchUp } = findDrawMatchUp({ drawDefinition, event, matchUpId });\n  const { scheduledDate } = scheduledMatchUpDate({ matchUp });\n  const timeItems = matchUp?.timeItems ?? [];\n\n  // can't add a STOP_TIME if the matchUp is not STARTED or RESUMED, or has START_TIME\n  // if latest relevaant timeItem is a STOP_TIME then overwrite\n\n  const hasEndTime = timeItems.reduce((hasEndTime: any, timeItem) => {\n    return timeItem.itemType === END_TIME || hasEndTime;\n  }, undefined);\n\n  if (hasEndTime) return { error: EXISTING_END_TIME };\n\n  const relevantTimeItems = timeItems\n    .filter((timeItem: any) =>\n      [START_TIME, RESUME_TIME, STOP_TIME].includes(timeItem?.itemType)\n    )\n    .sort(\n      (a, b) =>\n        timeDate(a.itemValue, scheduledDate) -\n        timeDate(b.itemValue, scheduledDate)\n    );\n\n  const lastRelevantTimeItem = relevantTimeItems[relevantTimeItems.length - 1];\n  const lastRelevantTimeItemIsStop =\n    lastRelevantTimeItem && lastRelevantTimeItem.itemType === STOP_TIME;\n\n  const latestRelevantTimeValue = relevantTimeItems\n    .filter(\n      (timeItem) =>\n        !lastRelevantTimeItemIsStop ||\n        timeItem.createdAt !== lastRelevantTimeItem.createdAt\n    )\n    .map((timeItem) => timeDate(timeItem.itemValue, scheduledDate))\n    .reduce(\n      (latest: any, timeValue) =>\n        !latest || timeValue > latest ? timeValue : latest,\n      undefined\n    );\n\n  if (timeDate(stopTime, scheduledDate) > latestRelevantTimeValue) {\n    if (matchUp?.timeItems && lastRelevantTimeItemIsStop) {\n      const targetTimeStamp = lastRelevantTimeItem.createdAt;\n      matchUp.timeItems = matchUp.timeItems.filter(\n        (timeItem) => timeItem.createdAt !== targetTimeStamp\n      );\n    }\n\n    // All times stored as military time\n    const militaryTime = convertTime(stopTime, true, true);\n    const timeItem = {\n      itemValue: militaryTime,\n      itemType: STOP_TIME,\n    };\n\n    return addMatchUpTimeItem({\n      duplicateValues: true,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      disableNotice,\n      matchUpId,\n      timeItem,\n    });\n  } else {\n    return { error: INVALID_STOP_TIME };\n  }\n}\n\nexport function addMatchUpResumeTime({\n  removePriorValues,\n  tournamentRecord,\n  drawDefinition,\n  disableNotice,\n  resumeTime,\n  matchUpId,\n  event,\n}: AddScheduleAttributeArgs & {\n  resumeTime?: string;\n}) {\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n  if (!validTimeValue(resumeTime)) return { error: INVALID_TIME };\n\n  const { matchUp } = findDrawMatchUp({ drawDefinition, event, matchUpId });\n  const { scheduledDate } = scheduledMatchUpDate({ matchUp });\n  const timeItems = matchUp?.timeItems ?? [];\n\n  // can't add a RESUME_TIME if the matchUp is not STOPPED, or if it has ENDED\n  // if latest relevaant timeItem is a RESUME_TIME then overwrite\n\n  const hasEndTime = timeItems.reduce((hasEndTime: any, timeItem) => {\n    return timeItem.itemType === END_TIME || hasEndTime;\n  }, undefined);\n\n  if (hasEndTime) return { error: EXISTING_END_TIME };\n\n  const relevantTimeItems = timeItems\n    .filter((timeItem: any) =>\n      [START_TIME, RESUME_TIME, STOP_TIME].includes(timeItem?.itemType)\n    )\n    .sort(\n      (a, b) =>\n        timeDate(a.itemValue, scheduledDate) -\n        timeDate(b.itemValue, scheduledDate)\n    );\n\n  const lastRelevantTimeItem = relevantTimeItems[relevantTimeItems.length - 1];\n  const lastRelevantTimeItemIsResume =\n    lastRelevantTimeItem && lastRelevantTimeItem.itemType === RESUME_TIME;\n\n  const latestRelevantTimeValue = relevantTimeItems\n    .filter(\n      (timeItem) =>\n        !lastRelevantTimeItemIsResume ||\n        timeItem.createdAt !== lastRelevantTimeItem.createdAt\n    )\n    .map((timeItem) => timeDate(timeItem.itemValue, scheduledDate))\n    .reduce(\n      (latest: any, timeValue) =>\n        !latest || timeValue > latest ? timeValue : latest,\n      undefined\n    );\n\n  if (timeDate(resumeTime, scheduledDate) > latestRelevantTimeValue) {\n    if (matchUp?.timeItems && lastRelevantTimeItemIsResume) {\n      const targetTimeStamp = lastRelevantTimeItem.createdAt;\n      matchUp.timeItems = matchUp.timeItems.filter(\n        (timeItem) => timeItem.createdAt !== targetTimeStamp\n      );\n    }\n\n    // All times stored as military time\n    const militaryTime = convertTime(resumeTime, true, true);\n    const timeItem = {\n      itemValue: militaryTime,\n      itemType: RESUME_TIME,\n    };\n\n    return addMatchUpTimeItem({\n      duplicateValues: true,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      disableNotice,\n      matchUpId,\n      timeItem,\n    });\n  } else {\n    return { error: INVALID_RESUME_TIME };\n  }\n}\n","import { analyzeScore } from '../query/matchUp/analyzeScore';\nimport { mustBeAnArray } from '../utilities/mustBeAnArray';\nimport { isConvertableInteger } from '../utilities/math';\nimport { unique } from '../utilities/arrays';\n\nimport type { Score } from '../types/tournamentTypes';\nimport { ResultType } from '../global/functions/decorateResult';\nimport {\n  INVALID_SCORE,\n  INVALID_VALUES,\n} from '../constants/errorConditionConstants';\n\ntype validateScoreTypes = {\n  existingMatchUpStatus?: string;\n  matchUpStatus?: string;\n  matchUpFormat?: string;\n  winningSide?: number;\n  score: Score;\n};\n\nexport function validateScore({\n  existingMatchUpStatus,\n  matchUpFormat,\n  matchUpStatus,\n  winningSide,\n  score,\n}: validateScoreTypes): ResultType & { valid?: boolean } {\n  if (typeof score !== 'object') return { error: INVALID_VALUES };\n  const { sets, scoreStringSide1, scoreStringSide2 } = score;\n  const info = 'scoreString must be a string!';\n\n  if (scoreStringSide1 !== undefined && typeof scoreStringSide1 !== 'string')\n    return { error: INVALID_VALUES, info };\n\n  if (scoreStringSide2 !== undefined && typeof scoreStringSide2 !== 'string')\n    return { error: INVALID_VALUES, info };\n\n  if (sets !== undefined && !Array.isArray(sets))\n    return { error: INVALID_VALUES, info: mustBeAnArray('sets') };\n\n  if (sets?.length) {\n    const setNumbers = sets.map((set) => set?.setNumber).filter(Boolean);\n    if (setNumbers.length !== unique(setNumbers).length)\n      return { error: INVALID_VALUES, info: 'setNumbers not unique' };\n\n    for (const set of sets) {\n      const {\n        side1Score,\n        side2Score,\n        side1TiebreakScore,\n        side2TiebreakScore,\n        side1PointScore,\n        side2PointScore,\n        winningSide,\n        setNumber,\n      } = set;\n\n      // ensure that if one side has a numeric value then both sides should have a numeric value\n      const numericValuePairs = [\n        [side1Score, side2Score],\n        [side1TiebreakScore, side2TiebreakScore],\n        [side1PointScore, side2PointScore],\n      ]\n        .filter((pair) => pair.some((value) => value !== undefined))\n        .every((pair) =>\n          pair.every((numericValue) => isConvertableInteger(numericValue))\n        );\n\n      if (!numericValuePairs) {\n        return { error: INVALID_VALUES, info: 'non-numeric values' };\n      }\n\n      const numericValues = [setNumber, winningSide]\n        .filter((value) => value !== undefined)\n        .every((numericValue) => isConvertableInteger(numericValue));\n\n      if (!numericValues) {\n        return { error: INVALID_VALUES, info: 'non-numeric values' };\n      }\n\n      if (winningSide && ![1, 2].includes(winningSide))\n        return { error: INVALID_VALUES, info: 'winningSide must be 1 or 2' };\n    }\n\n    const { valid: isValidScore } = analyzeScore({\n      existingMatchUpStatus,\n      matchUpStatus,\n      matchUpFormat,\n      winningSide,\n      score,\n    });\n\n    if (!isValidScore) {\n      return {\n        error: INVALID_SCORE,\n        info: 'score is invalid for matchUpFormat or winningSide does not match calculated winningSide',\n      };\n    }\n  }\n\n  return { valid: true };\n}\n","import { parse } from '../../assemblies/generators/matchUpFormatCode/parse';\nimport { instanceCount } from '../../utilities/arrays';\n\nimport { Score } from '../../types/tournamentTypes';\nimport {\n  DEFAULTED,\n  RETIRED,\n  WALKOVER,\n} from '../../constants/matchUpStatusConstants';\n\ntype AnalyzeScoreArgs = {\n  existingMatchUpStatus?: string;\n  matchUpStatus?: string;\n  matchUpFormat?: string;\n  winningSide?: number;\n  score: Score;\n};\nexport function analyzeScore({\n  existingMatchUpStatus,\n  matchUpFormat,\n  matchUpStatus,\n  winningSide,\n  score,\n}: AnalyzeScoreArgs) {\n  const sets = score?.sets ?? [];\n  const completedSets = sets?.filter((set) => set?.winningSide) || [];\n  const setsWinCounts = completedSets.reduce(\n    (counts, set) => {\n      const { winningSide } = set;\n      if (!winningSide) return counts;\n      const winningSideIndex = winningSide - 1;\n      counts[winningSideIndex]++;\n      return counts;\n    },\n    [0, 0]\n  );\n  const matchUpWinningSideIndex = winningSide ? winningSide - 1 : undefined;\n  const matchUpLosingSideIndex =\n    matchUpWinningSideIndex !== undefined\n      ? 1 - matchUpWinningSideIndex\n      : undefined;\n  const winningSideSetsCount =\n    matchUpWinningSideIndex !== undefined &&\n    setsWinCounts[matchUpWinningSideIndex];\n  const losingSideSetsCount =\n    matchUpLosingSideIndex !== undefined &&\n    setsWinCounts[matchUpLosingSideIndex];\n\n  const matchUpScoringFormat = matchUpFormat ? parse(matchUpFormat) : undefined;\n  const maxSetsCount = Math.max(...setsWinCounts);\n  const maxSetsInstances = instanceCount(setsWinCounts)[maxSetsCount];\n\n  const bestOf = matchUpScoringFormat?.bestOf;\n  const setsToWin = (bestOf && Math.ceil(bestOf / 2)) || 1;\n\n  const relevantMatchUpStatus = matchUpStatus ?? existingMatchUpStatus;\n  const irregularEnding =\n    relevantMatchUpStatus &&\n    [DEFAULTED, RETIRED, WALKOVER].includes(relevantMatchUpStatus);\n\n  const validSets =\n    !matchUpScoringFormat ||\n    !sets.length ||\n    sets.every((set, i) => {\n      const setNumber = i + 1;\n      const isFinalSet = setNumber === bestOf;\n      const isLastSet = setNumber === sets.length;\n\n      const {\n        side1Score,\n        side2Score,\n        side1TiebreakScore,\n        side2TiebreakScore,\n        winningSide: setWinningSide,\n      } = set;\n      const maxSetScore = Math.max(side1Score ?? 0, side2Score ?? 0);\n      const hasTiebreak = side1TiebreakScore ?? side2TiebreakScore;\n\n      const { finalSetFormat, setFormat } = matchUpScoringFormat;\n      const setValues = isFinalSet ? finalSetFormat || setFormat : setFormat;\n\n      if (hasTiebreak) {\n        const { tiebreakTo, NoAD } = setValues?.tiebreakFormat || {};\n        const maxTiebreakScore = Math.max(\n          side1TiebreakScore ?? 0,\n          side2TiebreakScore ?? 0\n        );\n        if (NoAD && maxTiebreakScore > tiebreakTo) return false;\n        if (maxTiebreakScore < tiebreakTo && setWinningSide) {\n          if (isLastSet && !irregularEnding) return false;\n          if (!isLastSet) return false;\n        }\n      }\n\n      if (!setValues.setTo) return true;\n\n      const excessiveSetScore =\n        !setValues.noTiebreak && maxSetScore > setValues.setTo + 1;\n      return !excessiveSetScore;\n    });\n\n  const calculatedWinningSide =\n    ((!matchUpFormat || maxSetsCount === setsToWin) &&\n      maxSetsInstances === 1 &&\n      setsWinCounts.indexOf(maxSetsCount) + 1) ||\n    undefined;\n\n  const valid =\n    validSets &&\n    ((winningSide &&\n      winningSideSetsCount > losingSideSetsCount &&\n      winningSide === calculatedWinningSide) ||\n      (!winningSide && !calculatedWinningSide) ||\n      irregularEnding);\n\n  return { valid };\n}\n","import { resolveTieFormat } from '../../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { generateTieMatchUpScore } from '../../../assemblies/generators/tieMatchUpScore/generateTieMatchUpScore';\nimport { getProjectedDualWinningSide } from '../../drawDefinitions/matchUpGovernor/getProjectedDualWinningSide';\nimport { noDownstreamDependencies } from '../../drawDefinitions/matchUpGovernor/noDownstreamDependencies';\nimport { isActiveDownstream } from '../../drawDefinitions/matchUpGovernor/isActiveDownstream';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { checkScoreHasValue } from '../../../query/matchUp/checkScoreHasValue';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { getMatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { addMatchUpScheduleItems } from '../schedule/scheduleItems';\nimport { removeExtension } from '../../extensions/removeExtension';\nimport { positionTargets } from '../drawPositions/positionTargets';\nimport { pushGlobalLog } from '../../../global/functions/globalLog';\nimport { swapWinnerLoser } from '../drawPositions/swapWinnerLoser';\nimport { validateScore } from '../../../validators/validateScore';\nimport { updateTieMatchUpScore } from '../score/tieMatchUpScore';\nimport { modifyMatchUpScore } from '../score/modifyMatchUpScore';\nimport { ensureSideLineUps } from '../lineUps/ensureSideLineUps';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { addExtension } from '../../extensions/addExtension';\nimport {\n  isDirectingMatchUpStatus,\n  isNonDirectingMatchUpStatus,\n} from '../../drawDefinitions/matchUpGovernor/checkStatusType';\n\nimport { POLICY_TYPE_PROGRESSION } from '../../../constants/policyConstants';\nimport { DISABLE_AUTO_CALC } from '../../../constants/extensionConstants';\nimport { QUALIFYING } from '../../../constants/drawDefinitionConstants';\nimport { PolicyDefinitions } from '../../../types/factoryTypes';\nimport { TEAM } from '../../../constants/matchUpTypes';\nimport {\n  CANNOT_CHANGE_WINNING_SIDE,\n  INCOMPATIBLE_MATCHUP_STATUS,\n  INVALID_MATCHUP_STATUS,\n  INVALID_VALUES,\n  MATCHUP_NOT_FOUND,\n  MISSING_DRAW_DEFINITION,\n  NO_VALID_ACTIONS,\n} from '../../../constants/errorConditionConstants';\nimport {\n  ABANDONED,\n  AWAITING_RESULT,\n  BYE,\n  CANCELLED,\n  COMPLETED,\n  DOUBLE_DEFAULT,\n  DOUBLE_WALKOVER,\n  INCOMPLETE,\n  particicipantsRequiredMatchUpStatuses,\n  TO_BE_PLAYED,\n  validMatchUpStatuses,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\nimport {\n  DrawDefinition,\n  Event,\n  MatchUpStatusUnion,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\n// NOTE: Internal method for setting matchUpStatus or score and winningSide, not to be confused with setMatchUpStatus\n\ntype SetMatchUpStateArgs = {\n  tournamentRecords?: { [key: string]: Tournament };\n  policyDefinitions?: PolicyDefinitions;\n  matchUpStatus?: MatchUpStatusUnion;\n  allowChangePropagation?: boolean;\n  disableScoreValidation?: boolean;\n  projectedWinningSide?: number;\n  matchUpStatusCodes?: string[];\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  disableAutoCalc?: boolean;\n  enableAutoCalc?: boolean;\n  matchUpFormat?: string;\n  matchUpTieId?: string;\n  tieMatchUpId?: string;\n  removeScore?: boolean;\n  winningSide?: number;\n  matchUpId: string;\n  schedule?: any;\n  notes?: string;\n  outcome?: any;\n  event?: Event;\n  score?: any;\n};\n\nexport function setMatchUpState(params: SetMatchUpStateArgs): any {\n  const stack = 'setMatchUpStatus';\n\n  // always clear score if DOUBLE_WALKOVER or WALKOVER\n  if (\n    params.matchUpStatus &&\n    [WALKOVER, DOUBLE_WALKOVER].includes(params.matchUpStatus)\n  )\n    params.score = undefined;\n\n  // matchUpStatus in params is the new status\n  // winningSide in params is new winningSide\n\n  const {\n    allowChangePropagation,\n    disableScoreValidation,\n    tournamentRecords,\n    tournamentRecord,\n    disableAutoCalc,\n    enableAutoCalc,\n    drawDefinition,\n    matchUpStatus,\n    winningSide,\n    matchUpId,\n    event,\n    score,\n  } = params;\n\n  // Check for missing parameters ---------------------------------------------\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  // Check matchUpStatus, matchUpStatus/winningSide validity ------------------\n  if (\n    matchUpStatus &&\n    [CANCELLED, INCOMPLETE, ABANDONED, TO_BE_PLAYED].includes(matchUpStatus) &&\n    winningSide\n  )\n    return { error: INVALID_VALUES, winningSide, matchUpStatus };\n\n  if (![undefined, ...validMatchUpStatuses].includes(matchUpStatus)) {\n    return decorateResult({\n      result: { error: INVALID_MATCHUP_STATUS },\n      info: 'matchUpStatus does not exist',\n      stack: 'setMatchUpStatus',\n    });\n  }\n\n  // Get map of all drawMatchUps and inContextDrawMatchUps ---------------------\n  const matchUpsMap = getMatchUpsMap({ drawDefinition });\n  const { matchUps: inContextDrawMatchUps } = getAllDrawMatchUps({\n    nextMatchUps: true,\n    inContext: true,\n    drawDefinition,\n    matchUpsMap,\n    event,\n  });\n\n  // Find target matchUp ------------------------------------------------------\n  const matchUp = matchUpsMap.drawMatchUps.find(\n    (matchUp) => matchUp.matchUpId === matchUpId\n  );\n\n  const inContextMatchUp = inContextDrawMatchUps?.find(\n    (matchUp) => matchUp.matchUpId === matchUpId\n  );\n\n  if (!matchUp || !inContextDrawMatchUps) return { error: MATCHUP_NOT_FOUND };\n\n  if ((matchUp.winningSide || winningSide) && matchUpStatus === BYE) {\n    return {\n      context: 'Cannot have Bye with winningSide',\n      error: INCOMPATIBLE_MATCHUP_STATUS,\n      matchUpStatus,\n    };\n  }\n\n  const structureId = inContextMatchUp?.structureId;\n  const { structure } = findStructure({ drawDefinition, structureId });\n\n  // Check validity of matchUpStatus considering assigned drawPositions -------\n  const assignedDrawPositions =\n    inContextMatchUp?.drawPositions?.filter(Boolean);\n\n  let dualWinningSideChange;\n  if (matchUp.matchUpType === TEAM) {\n    if (disableAutoCalc) {\n      addExtension({\n        extension: { name: DISABLE_AUTO_CALC, value: true },\n        element: matchUp,\n      });\n    } else if (enableAutoCalc) {\n      const existingDualMatchUpWinningSide = matchUp.winningSide;\n      removeExtension({ name: DISABLE_AUTO_CALC, element: matchUp });\n      const {\n        winningSide: projectedWinningSide,\n        scoreStringSide1,\n        scoreStringSide2,\n        set,\n      } = generateTieMatchUpScore({\n        drawDefinition,\n        matchUpsMap,\n        structure,\n        matchUp,\n        event,\n      });\n\n      const score = {\n        scoreStringSide1,\n        scoreStringSide2,\n        sets: set ? [set] : [],\n      };\n\n      dualWinningSideChange =\n        projectedWinningSide !== existingDualMatchUpWinningSide;\n\n      // setting these parameters will enable noDownStreamDependencies to attemptToSetWinningSide\n      Object.assign(params, {\n        winningSide: projectedWinningSide,\n        dualWinningSideChange,\n        projectedWinningSide,\n        score,\n      });\n    }\n    ensureSideLineUps({\n      tournamentId: tournamentRecord?.tournamentId,\n      inContextDualMatchUp: inContextMatchUp,\n      eventId: event?.eventId,\n      drawDefinition,\n      dualMatchUp: matchUp,\n    });\n  }\n\n  if (\n    matchUp.matchUpType === TEAM &&\n    matchUpStatus &&\n    [\n      AWAITING_RESULT,\n      // for the following statuses should all tieMatchUp results be removed?\n      // CANCELLED,\n      // DOUBLE_WALKOVER,\n      // WALKOVER,\n    ].includes(matchUpStatus)\n  ) {\n    return {\n      error: INVALID_VALUES,\n      info: 'Not supported for matchUpType: TEAM',\n    };\n  }\n\n  const matchUpTieId = inContextMatchUp?.matchUpTieId;\n\n  // Get winner/loser position targets ----------------------------------------\n  const targetData = positionTargets({\n    matchUpId: matchUpTieId || matchUpId, // get targets for TEAM matchUp if tieMatchUp\n    inContextDrawMatchUps,\n    drawDefinition,\n  });\n\n  if (score && matchUp.matchUpType !== TEAM && !disableScoreValidation) {\n    const matchUpFormat =\n      matchUp.matchUpFormat ??\n      structure?.matchUpFormat ??\n      drawDefinition?.matchUpFormat ??\n      event?.matchUpFormat;\n\n    const result = validateScore({\n      existingMatchUpStatus: matchUp.matchUpStatus,\n      matchUpFormat,\n      matchUpStatus,\n      winningSide,\n      score,\n    });\n    if (result.error) {\n      return result;\n    }\n  }\n\n  const positionAssignments = !matchUp?.sides\n    ? getPositionAssignments({\n        drawDefinition,\n        structureId,\n      }).positionAssignments\n    : [];\n\n  const bothSideParticipants =\n    matchUp.sides?.map((side) => side.participantId).filter(Boolean).length ===\n      2 ||\n    (assignedDrawPositions?.length === 2 &&\n      positionAssignments\n        ?.filter((assignment) =>\n          assignedDrawPositions.includes(assignment.drawPosition)\n        )\n        .every((assignment) => assignment.participantId));\n\n  if (\n    matchUpStatus &&\n    particicipantsRequiredMatchUpStatuses.includes(matchUpStatus) &&\n    !bothSideParticipants\n  ) {\n    return decorateResult({\n      info: 'present in participantRequiredMatchUpStatuses',\n      context: { matchUpStatus, bothSideParticipants },\n      result: { error: INVALID_MATCHUP_STATUS },\n    });\n  }\n\n  const appliedPolicies =\n    getAppliedPolicies({\n      policyTypes: [POLICY_TYPE_PROGRESSION],\n      tournamentRecord,\n      drawDefinition,\n      event,\n    })?.appliedPolicies ?? {};\n\n  if (typeof params.policyDefinitions === 'object') {\n    Object.assign(appliedPolicies, params.policyDefinitions);\n  }\n\n  const qualifyingMatch =\n    inContextMatchUp?.stage === QUALIFYING &&\n    inContextMatchUp.finishingRound === 1;\n  const qualifierAdvancing = qualifyingMatch && winningSide;\n  const removingQualifier =\n    qualifyingMatch && // oop\n    matchUp.winningSide &&\n    !winningSide && // function calls last\n    (!params.matchUpStatus ||\n      (params.matchUpStatus &&\n        isNonDirectingMatchUpStatus({\n          matchUpStatus: params.matchUpStatus,\n        }))) &&\n    (!params.outcome || !checkScoreHasValue({ outcome: params.outcome }));\n  const qualifierChanging =\n    qualifierAdvancing && // oop\n    winningSide !== matchUp.winningSide &&\n    matchUp.winningSide;\n\n  Object.assign(params, {\n    inContextDrawMatchUps,\n    qualifierAdvancing,\n    qualifierChanging,\n    removingQualifier,\n    inContextMatchUp,\n    appliedPolicies,\n    matchUpTieId,\n    matchUpsMap,\n    targetData,\n    structure,\n    matchUp,\n  });\n\n  if (matchUpTieId) {\n    const { matchUp: dualMatchUp } = findDrawMatchUp({\n      matchUpId: matchUpTieId,\n      inContext: true,\n      drawDefinition,\n      matchUpsMap,\n      event,\n    });\n    if (dualMatchUp) {\n      const tieFormat = resolveTieFormat({\n        matchUp: dualMatchUp,\n        drawDefinition,\n        structure,\n        event,\n      })?.tieFormat;\n\n      const { projectedWinningSide } = getProjectedDualWinningSide({\n        drawDefinition,\n        matchUpStatus,\n        dualMatchUp,\n        matchUpsMap,\n        winningSide,\n        tieFormat,\n        structure,\n        matchUp,\n        event,\n        score,\n      });\n\n      const existingDualMatchUpWinningSide = dualMatchUp.winningSide;\n      dualWinningSideChange =\n        projectedWinningSide !== existingDualMatchUpWinningSide;\n\n      Object.assign(params, {\n        isCollectionMatchUp: true,\n        dualWinningSideChange,\n        projectedWinningSide,\n        matchUpTieId,\n        dualMatchUp,\n        tieFormat,\n      });\n    }\n  }\n\n  // with propagating winningSide changes, activeDownstream does not apply to collection matchUps\n  const activeDownstream = isActiveDownstream(params);\n  const directingMatchUpStatus = isDirectingMatchUpStatus({ matchUpStatus });\n\n  if (!matchUpTieId) {\n    if (\n      activeDownstream &&\n      !winningSide &&\n      ((matchUpStatus && isNonDirectingMatchUpStatus({ matchUpStatus })) ||\n        (matchUpStatus &&\n          [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUpStatus)))\n    ) {\n      return {\n        error: INCOMPATIBLE_MATCHUP_STATUS,\n        activeDownstream,\n        winningSide,\n      };\n    }\n\n    if (\n      winningSide &&\n      winningSide === matchUp.winningSide &&\n      matchUpStatus &&\n      !directingMatchUpStatus\n    ) {\n      return {\n        context: 'winningSide must include directing matchUpStatus',\n        error: INCOMPATIBLE_MATCHUP_STATUS,\n        directingMatchUpStatus,\n        matchUpStatus,\n      };\n    }\n  }\n\n  // Add scheduling information to matchUp ------------------------------------\n  const { schedule } = params;\n  if (schedule) {\n    const result = addMatchUpScheduleItems({\n      disableNotice: true,\n      tournamentRecords,\n      tournamentRecord,\n      drawDefinition,\n      matchUpId,\n      schedule,\n    });\n    if (result.error) {\n      return result;\n    }\n  }\n\n  const validWinningSideSwap =\n    matchUp.matchUpType !== TEAM &&\n    !dualWinningSideChange &&\n    winningSide &&\n    matchUp.winningSide &&\n    matchUp.winningSide !== winningSide;\n\n  if (\n    allowChangePropagation &&\n    validWinningSideSwap &&\n    matchUp.roundPosition // not round robin if matchUp.roundPosition\n  ) {\n    return swapWinnerLoser(params);\n  }\n\n  const matchUpWinner =\n    (winningSide && !matchUpTieId) || params.projectedWinningSide;\n\n  pushGlobalLog({\n    method: stack,\n    activeDownstream,\n    matchUpWinner,\n    winningSide,\n  });\n\n  const result = (!activeDownstream && noDownstreamDependencies(params)) ||\n    (matchUpWinner && winningSideWithDownstreamDependencies(params)) ||\n    (directingMatchUpStatus && applyMatchUpValues(params)) || {\n      error: NO_VALID_ACTIONS,\n    };\n\n  return decorateResult({ result, stack });\n}\n\nfunction winningSideWithDownstreamDependencies(params) {\n  const { matchUp, winningSide, matchUpTieId, dualWinningSideChange } = params;\n  if (\n    winningSide === matchUp.winningSide ||\n    (matchUpTieId && !dualWinningSideChange)\n  ) {\n    return applyMatchUpValues(params);\n  } else {\n    return decorateResult({\n      stack: 'winningSideWithDownstreamDependencies',\n      result: { error: CANNOT_CHANGE_WINNING_SIDE },\n      context: { winningSide, matchUp },\n    });\n  }\n}\n\nfunction applyMatchUpValues(params) {\n  const { tournamentRecord, matchUp, event } = params;\n  const removeWinningSide =\n    params.isCollectionMatchUp &&\n    matchUp.winningSide &&\n    !params.winningSide &&\n    !checkScoreHasValue({ score: params.score });\n  const newMatchUpStatus = params.isCollectionMatchUp\n    ? params.matchUpStatus || (removeWinningSide && TO_BE_PLAYED) || COMPLETED\n    : params.matchUpStatus || COMPLETED;\n  const removeScore =\n    params.removeScore ||\n    ([CANCELLED, WALKOVER].includes(newMatchUpStatus) &&\n      ![INCOMPLETE, ABANDONED].includes(newMatchUpStatus));\n\n  const result = modifyMatchUpScore({\n    ...params,\n    matchUpStatus: newMatchUpStatus,\n    removeWinningSide,\n    removeScore,\n  });\n  if (result.error) return result;\n\n  // recalculate dualMatchUp score if isCollectionMatchUp\n  if (params.isCollectionMatchUp) {\n    const { matchUpTieId, drawDefinition, matchUpsMap } = params;\n    const tieMatchUpResult = updateTieMatchUpScore({\n      matchUpId: matchUpTieId,\n      tournamentRecord,\n      drawDefinition,\n      matchUpsMap,\n      event,\n    });\n\n    if (tieMatchUpResult.error) return tieMatchUpResult;\n    Object.assign(result, { tieMatchUpResult });\n  }\n\n  return result;\n}\n","import { generateTieMatchUpScore } from '../../../assemblies/generators/tieMatchUpScore/generateTieMatchUpScore';\nimport { resolveTieFormat } from '../../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { checkScoreHasValue } from '../../../query/matchUp/checkScoreHasValue';\nimport { toBePlayed } from '../../../fixtures/scoring/outcomes/toBePlayed';\nimport { MatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  DrawDefinition,\n  Event,\n  MatchUp,\n  Structure,\n  TieFormat,\n} from '../../../types/tournamentTypes';\n\ntype GetProjectedDualWinningSideArgs = {\n  drawDefinition?: DrawDefinition;\n  dualMatchUp: HydratedMatchUp;\n  matchUpsMap?: MatchUpsMap;\n  matchUpStatus?: string;\n  tieFormat?: TieFormat;\n  structure?: Structure;\n  winningSide?: number;\n  matchUp: MatchUp;\n  event?: Event;\n  score?: any;\n};\nexport function getProjectedDualWinningSide({\n  drawDefinition,\n  matchUpStatus,\n  matchUpsMap,\n  winningSide,\n  dualMatchUp,\n  tieFormat,\n  structure,\n  matchUp,\n  event,\n  score,\n}: GetProjectedDualWinningSideArgs) {\n  const projectedDualMatchUp = makeDeepCopy(dualMatchUp, undefined, true);\n  for (const tieMatchUp of projectedDualMatchUp?.tieMatchUps || []) {\n    if (tieMatchUp.matchUpId === matchUp.matchUpId) {\n      tieMatchUp.winningSide = winningSide;\n      tieMatchUp.score = score;\n      if (!checkScoreHasValue({ score }) && !matchUpStatus) {\n        Object.assign(tieMatchUp, { ...toBePlayed });\n      } else if (matchUpStatus) {\n        tieMatchUp.matchUpStatus = matchUpStatus;\n      }\n    }\n  }\n\n  tieFormat =\n    tieFormat ??\n    resolveTieFormat({ matchUp, structure, drawDefinition, event })?.tieFormat;\n\n  const { winningSide: projectedWinningSide } = generateTieMatchUpScore({\n    matchUp: projectedDualMatchUp,\n    drawDefinition,\n    matchUpsMap,\n    structure,\n    tieFormat,\n    event,\n  });\n\n  return { projectedWinningSide };\n}\n","import { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { getDevContext } from '../../../global/state/globalState';\nimport { modifyMatchUpScore } from '../score/modifyMatchUpScore';\n\n/**\n * for FMLC 2nd round matchUps test whether it if a first loss for both participants\n */\nexport function swapWinnerLoser(params) {\n  const { tournamentRecord, inContextMatchUp, structure, drawDefinition } =\n    params;\n  const matchUpRoundNumber = inContextMatchUp.roundNumber;\n\n  const existingWinnerSide = inContextMatchUp.sides.find(\n    (side) => side.sideNumber === inContextMatchUp.winningSide\n  );\n  const existingLoserSide = inContextMatchUp.sides.find(\n    (side) => side.sideNumber !== inContextMatchUp.winningSide\n  );\n\n  const {\n    drawPosition: existingWinnerDrawPosition,\n    participantId: existingWinnerParticipantId,\n  } = existingWinnerSide;\n  const {\n    drawPosition: existingLoserDrawPosition,\n    participantId: existingLoserParticipantId,\n  } = existingLoserSide;\n\n  const stack = 'swapWinnerLoser';\n\n  const { matchUps } = getAllStructureMatchUps(params);\n  const existingWinnerSubsequentMatchUps = matchUps.filter(\n    ({ drawPositions, roundNumber }) =>\n      drawPositions?.includes(existingWinnerDrawPosition) &&\n      roundNumber > matchUpRoundNumber\n  );\n\n  if (getDevContext({ changeWinner: true }))\n    console.log({ existingWinnerSubsequentMatchUps });\n\n  // replace new winningSide drawPosition in all subsequent matches in structure\n  existingWinnerSubsequentMatchUps.forEach((matchUp) => {\n    matchUp.drawPositions =\n      matchUp.drawPositions?.map((drawPosition) =>\n        drawPosition === existingWinnerDrawPosition\n          ? existingLoserDrawPosition\n          : drawPosition\n      ) || [];\n    modifyMatchUpNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      eventId: params.event?.eventId,\n      context: stack,\n      drawDefinition,\n      matchUp,\n    });\n  });\n\n  const { stage: currentStage, stageSequence: currentStageSequence } =\n    structure;\n  const subsequentStructureIds = drawDefinition.structures\n    .filter(\n      ({ stage, stageSequence }) =>\n        stage === currentStage && stageSequence > currentStageSequence\n    )\n    .map(({ structureId }) => structureId);\n\n  const {\n    targetLinks: { loserTargetLink, winnerTargetLink },\n  } = params.targetData;\n  const targetStructureIds = [\n    loserTargetLink?.target.structureId,\n    winnerTargetLink?.target?.structureId,\n  ].filter(Boolean);\n\n  // find target structures that are not part of current stage...\n  // ... as well as any subsequent structures\n  drawDefinition.structures\n    .filter(({ stage, structureId }) => {\n      return stage !== currentStage && targetStructureIds.includes(structureId);\n    })\n    .forEach(\n      ({\n        stage: targetStage,\n        stageSequence: targetStageSequence,\n        structureId,\n      }) => {\n        if (!subsequentStructureIds.includes(structureId))\n          subsequentStructureIds.push(structureId);\n\n        drawDefinition.structures\n          .filter(\n            ({ stage, stageSequence }) =>\n              stage === targetStage && stageSequence > targetStageSequence\n          )\n          .forEach(({ structureId }) => {\n            if (!subsequentStructureIds.includes(structureId))\n              subsequentStructureIds.push(structureId);\n          });\n      }\n    );\n\n  const subsequentStructures = drawDefinition.structures.filter(\n    ({ structureId }) => subsequentStructureIds.includes(structureId)\n  );\n\n  // for each subsequent structure swap drawPosition assignments (where applicable)\n  subsequentStructures.forEach((structure) => {\n    const { positionAssignments } = getPositionAssignments({ structure });\n    const existingWinnerAssignment = positionAssignments?.find(\n      ({ participantId }) => participantId === existingWinnerParticipantId\n    );\n    const existingLoserAssignment = positionAssignments?.find(\n      ({ participantId }) => participantId === existingLoserParticipantId\n    );\n\n    if (existingWinnerAssignment)\n      existingWinnerAssignment.participantId = existingLoserParticipantId;\n    if (existingLoserAssignment)\n      existingLoserAssignment.participantId = existingWinnerParticipantId;\n  });\n\n  // apply new winningSide and any score updates\n  return modifyMatchUpScore(params);\n}\n","import { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { intersection, unique } from '../../utilities/arrays';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_EVENT,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\n/**\n *\n * @param {object} orderedDrawIdsMap - required - mapping of ALL present drawIds => { [drawId]: drawOrder }\n */\nexport function updateDrawIdsOrder({ event, orderedDrawIdsMap }) {\n  if (typeof event !== 'object') return { error: MISSING_EVENT };\n  if (!orderedDrawIdsMap)\n    return { error: MISSING_VALUE, info: 'Missing drawIdsOrderMap' };\n  if (typeof orderedDrawIdsMap !== 'object')\n    return {\n      error: INVALID_VALUES,\n      info: 'orderedDrawIdsMap must be an object',\n    };\n\n  const drawOrders: number[] = Object.values(orderedDrawIdsMap);\n\n  const validDrawOrders = drawOrders.every((drawOrder) => !isNaN(drawOrder));\n  if (!validDrawOrders)\n    return { error: INVALID_VALUES, info: 'drawOrder must be numeric' };\n\n  if (unique(drawOrders).length !== drawOrders.length)\n    return {\n      error: INVALID_VALUES,\n      info: 'drawOrder values must be unique',\n    };\n\n  if (event.drawDefinitions?.length) {\n    const drawIds = (event.drawDefinitions || []).map(({ drawId }) => drawId);\n    const orderedDrawIds = Object.keys(orderedDrawIdsMap);\n    if (\n      orderedDrawIds?.length &&\n      intersection(drawIds, orderedDrawIds).length !== drawIds.length\n    )\n      return { error: INVALID_VALUES, info: 'Missing drawIds' };\n\n    event.drawDefinitions.forEach((drawDefinition) => {\n      drawDefinition.drawOrder = orderedDrawIdsMap[drawDefinition.drawId];\n    });\n  }\n\n  const { flightProfile } = getFlightProfile({ event });\n  flightProfile?.flights?.forEach((flight) => {\n    flight.flightNumber = orderedDrawIdsMap[flight.drawId];\n  });\n\n  return { ...SUCCESS };\n}\n","import { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { updateDrawIdsOrder } from './updateDrawIdsOrder';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\nexport function refreshEventDrawOrder({ tournamentRecord, event }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n\n  const { flightProfile } = getFlightProfile({ event });\n\n  // if there is a flightProfile, derive order from that, otherwise use drawDefinitions array\n  const orderedDrawIdsMap =\n    (flightProfile?.flights &&\n      Object.assign(\n        {},\n        ...flightProfile.flights\n          .sort((a, b) => a.flightNumber - b.flightNumber)\n          .map((flight, i) => ({ [flight.drawId]: i + 1 }))\n      )) ||\n    (event.drawDefinitions?.length &&\n      Object.assign(\n        {},\n        ...event.drawDefinitions\n          .sort((a, b) => a.drawOrder - b.drawOrder)\n          .map((drawDefinition, i) => ({ [drawDefinition.drawId]: i + 1 }))\n      )) ||\n    undefined;\n\n  return orderedDrawIdsMap\n    ? updateDrawIdsOrder({ event, orderedDrawIdsMap })\n    : { ...SUCCESS };\n}\n","import { addDrawNotice } from '../notifications/drawNotifications';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  DRAW_DEFINITION_NOT_FOUND,\n  INVALID_TIME_ITEM,\n  MISSING_TIME_ITEM,\n} from '../../constants/errorConditionConstants';\n\nexport function addDrawDefinitionTimeItem({ drawDefinition, timeItem }) {\n  if (!drawDefinition) return { error: DRAW_DEFINITION_NOT_FOUND };\n  if (!timeItem) return { error: MISSING_TIME_ITEM };\n\n  const timeItemAttributes = timeItem && Object.keys(timeItem);\n  const requiredAttributes = ['itemType', 'itemValue'];\n  const validTimeItem =\n    requiredAttributes.filter((attribute) =>\n      timeItemAttributes.includes(attribute)\n    ).length === requiredAttributes.length;\n\n  if (!validTimeItem) return { error: INVALID_TIME_ITEM };\n\n  if (!drawDefinition.timeItems) drawDefinition.timeItems = [];\n  const createdAt = new Date().toISOString();\n  Object.assign(timeItem, { createdAt });\n  drawDefinition.timeItems.push(timeItem);\n\n  addDrawNotice({ drawDefinition });\n\n  return { ...SUCCESS };\n}\n","import { getStageDrawPositionsCount } from '../../../query/drawDefinition/getStageDrawPositions';\nimport { modifyDrawNotice } from '../../notifications/drawNotifications';\nimport { getQualifiersCount } from '../../../query/drawDefinition/getQualifiersCount';\nimport { modifyEntryProfile } from './modifyEntryProfile';\nimport {\n  stageExists,\n  getStageDirectEntriesCount,\n  getStageWildcardEntriesCount,\n} from '../../../query/drawDefinition/stageGetter';\n\nimport { ALTERNATE } from '../../../constants/entryStatusConstants';\nimport { MAIN } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  DRAW_SIZE_MISMATCH,\n  INVALID_STAGE,\n  MISSING_DRAW_DEFINITION,\n} from '../../../constants/errorConditionConstants';\nimport { DrawDefinition } from '../../../types/tournamentTypes';\n\nexport function setStageDrawSize({\n  stageSequence = 1,\n  drawDefinition,\n  drawSize,\n  stage,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!stageExists({ drawDefinition, stage })) {\n    return { error: INVALID_STAGE };\n  }\n\n  const directAcceptanceEntries = getStageDirectEntriesCount({\n    drawDefinition,\n    stage,\n  });\n\n  const { qualifiersCount } = getQualifiersCount({\n    drawDefinition,\n    stageSequence,\n    stage,\n  });\n  const totalStageDrawPositions = directAcceptanceEntries + qualifiersCount;\n\n  if (drawSize < totalStageDrawPositions) {\n    return {\n      error: DRAW_SIZE_MISMATCH,\n    };\n  }\n\n  const { entryProfile } = modifyEntryProfile({\n    attributes: [{ [stage]: { drawSize } }],\n    drawDefinition,\n  });\n\n  modifyDrawNotice({ drawDefinition });\n  return { ...SUCCESS, entryProfile };\n}\n\nexport function setStageAlternatesCount({\n  alternatesCount,\n  drawDefinition,\n  stage,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!stageExists({ drawDefinition, stage })) {\n    return { error: INVALID_STAGE };\n  }\n\n  modifyEntryProfile({\n    attributes: [{ [stage]: { alternates: alternatesCount } }],\n    drawDefinition,\n  });\n\n  if (!alternatesCount) {\n    drawDefinition.entries =\n      drawDefinition.entries?.filter((entry) => {\n        return entry.entryStatus !== ALTERNATE;\n      }) || [];\n  }\n\n  modifyDrawNotice({ drawDefinition });\n  return { ...SUCCESS };\n}\n\ntype SetWildcardsCount = {\n  drawDefinition: DrawDefinition;\n  wildcardsCount: number;\n  stageSequence?: number;\n  stage: string;\n};\nexport function setStageWildcardsCount({\n  wildcardsCount = 0,\n  drawDefinition,\n  stageSequence,\n  stage,\n}: SetWildcardsCount) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!stageExists({ drawDefinition, stage })) {\n    return { error: INVALID_STAGE };\n  }\n\n  const stageDrawPositions = getStageDrawPositionsCount({\n    drawDefinition,\n    stage,\n  });\n\n  // REMOVE dependency... use link to derive... requires structureId\n  const { qualifiersCount } = getQualifiersCount({\n    drawDefinition,\n    stageSequence,\n    stage,\n  });\n  const wildcardEntriesCount = getStageWildcardEntriesCount({\n    drawDefinition,\n    stage,\n  });\n  const directAcceptanceEntriesCount = getStageDirectEntriesCount({\n    drawDefinition,\n    stage,\n  });\n\n  if (wildcardsCount < wildcardEntriesCount) {\n    const error = Object.assign(DRAW_SIZE_MISMATCH, {\n      message:\n        'Number of Wildcards cannot be less than number of Wildcards already entered',\n    });\n    return { error };\n  }\n\n  const totalStageEntriesCount =\n    directAcceptanceEntriesCount + wildcardsCount + qualifiersCount;\n  if (totalStageEntriesCount > stageDrawPositions) {\n    return {\n      error: DRAW_SIZE_MISMATCH,\n      info: 'Total stage Entries cannot be greater than drawPositions',\n    };\n  }\n\n  modifyEntryProfile({\n    attributes: [{ [stage]: { wildcardsCount } }],\n    drawDefinition,\n  });\n\n  modifyDrawNotice({ drawDefinition });\n  return { ...SUCCESS };\n}\n\nexport function setStageQualifiersCount({\n  qualifiersCount = 0,\n  drawDefinition,\n  stage,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!stageExists({ drawDefinition, stage })) {\n    return { error: INVALID_STAGE };\n  }\n  if (stage !== MAIN) {\n    return {\n      error: DRAW_SIZE_MISMATCH,\n      info: 'qualifiersCount can only be set for main stage',\n    };\n  }\n\n  modifyEntryProfile({\n    attributes: [{ [stage]: { qualifiersCount } }],\n    drawDefinition,\n  });\n\n  modifyDrawNotice({ drawDefinition });\n\n  return { ...SUCCESS };\n}\n","import { modifyDrawNotice } from '../../notifications/drawNotifications';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { updateTargetTeamMatchUps } from '../../tieFormat/updateTargetTeamMatchUps';\nimport { getTargetTeamMatchUps } from '../../../query/hierarchical/tieFormats/getTargetTeamMatchUps';\nimport { calculateWinCriteria } from '../../../query/matchUp/calculateWinCriteria';\nimport { validateTieFormat } from '../../../validators/validateTieFormat';\n\nimport { MISSING_DRAW_DEFINITION } from '../../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  DrawDefinition,\n  Event,\n  MatchUp,\n  Structure,\n  TieFormat,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype CollectionGroupUpdateArgs = {\n  updateInProgressMatchUps?: boolean;\n  drawDefinition: DrawDefinition;\n  tournamentRecord?: Tournament;\n  wasAggregateValue?: boolean;\n  originalValueGoal?: number;\n  tieFormatName?: string;\n  structure?: Structure;\n  structureId?: string;\n  tieFormat: TieFormat;\n  matchUpId?: string;\n  matchUp?: MatchUp;\n  eventId?: string;\n  event?: Event;\n};\nexport function collectionGroupUpdate({\n  updateInProgressMatchUps,\n  originalValueGoal,\n  tournamentRecord,\n  wasAggregateValue,\n  tieFormatName,\n  drawDefinition,\n  structureId,\n  structure,\n  tieFormat,\n  matchUpId,\n  matchUp,\n  eventId,\n  event,\n}: CollectionGroupUpdateArgs) {\n  // calculate new winCriteria for tieFormat\n  // if existing winCriteria is aggregateValue, retain\n  const { aggregateValue, valueGoal } = calculateWinCriteria(tieFormat);\n  tieFormat.winCriteria = definedAttributes({ aggregateValue, valueGoal });\n\n  // if valueGoal has changed, force renaming of the tieFormat\n  if (\n    (originalValueGoal && originalValueGoal !== valueGoal) ||\n    (aggregateValue && !wasAggregateValue)\n  ) {\n    if (tieFormatName) {\n      tieFormat.tieFormatName = tieFormatName;\n    } else {\n      delete tieFormat.tieFormatName;\n    }\n  }\n\n  const { targetMatchUps } = getTargetTeamMatchUps({\n    updateInProgressMatchUps,\n    drawDefinition,\n    structureId,\n    structure,\n    matchUpId,\n    matchUp,\n  });\n\n  updateTargetTeamMatchUps({\n    updateInProgressMatchUps,\n    tournamentRecord,\n    targetMatchUps,\n    drawDefinition,\n    tieFormat,\n    event,\n  });\n\n  const prunedTieFormat = definedAttributes(tieFormat);\n  const result = validateTieFormat({ tieFormat: prunedTieFormat });\n  if (result.error) return result;\n\n  // TODO: implement use of tieFormats and tieFormatId\n  if (eventId && event) {\n    event.tieFormat = prunedTieFormat;\n    // NOTE: there is not yet a modifyEventNotice\n  } else if (matchUpId && matchUp) {\n    matchUp.tieFormat = tieFormat;\n  } else if (structure) {\n    structure.tieFormat = prunedTieFormat;\n  } else if (drawDefinition) {\n    drawDefinition.tieFormat = prunedTieFormat;\n  } else if (!matchUp || !drawDefinition) {\n    return { error: MISSING_DRAW_DEFINITION };\n  }\n\n  modifyDrawNotice({ drawDefinition, eventId: event?.eventId });\n\n  return { ...SUCCESS };\n}\n","import { getAllStructureMatchUps } from '../../matchUps/getAllStructureMatchUps';\nimport { allDrawMatchUps } from '../../matchUps/getAllDrawMatchUps';\nimport { checkScoreHasValue } from '../../matchUp/checkScoreHasValue';\n\nimport { MatchUp } from '../../../types/tournamentTypes';\nimport { TEAM } from '../../../constants/matchUpTypes';\nimport {\n  COMPLETED,\n  IN_PROGRESS,\n} from '../../../constants/matchUpStatusConstants';\n\nexport function getTargetTeamMatchUps({\n  updateInProgressMatchUps,\n  drawDefinition,\n  structureId,\n  structure,\n  matchUpId,\n  matchUp,\n}) {\n  let matchUps: MatchUp[] = [];\n  if (matchUpId && matchUp) {\n    matchUps = [matchUp];\n  } else if (structureId && structure) {\n    matchUps =\n      getAllStructureMatchUps({\n        matchUpFilters: { matchUpTypes: [TEAM] },\n        structure,\n      })?.matchUps ?? [];\n  } else if (drawDefinition) {\n    matchUps =\n      allDrawMatchUps({\n        matchUpFilters: { matchUpTypes: [TEAM] },\n        drawDefinition,\n      })?.matchUps ?? [];\n  }\n\n  // all team matchUps in scope which are completed or which have a tieFormat should not be modified\n  const targetMatchUps = matchUps.filter(\n    (matchUp) =>\n      !matchUp.winningSide &&\n      matchUp.matchUpStatus !== COMPLETED &&\n      (updateInProgressMatchUps ||\n        (matchUp.matchUpStatus !== IN_PROGRESS && !checkScoreHasValue(matchUp)))\n  );\n\n  return { targetMatchUps };\n}\n","import { SUCCESS } from '../../constants/resultConstants';\nimport { updateTieMatchUpScore } from '../matchUps/score/tieMatchUpScore';\nimport { modifyMatchUpNotice } from '../notifications/drawNotifications';\nimport { copyTieFormat } from '../../query/hierarchical/tieFormats/copyTieFormat';\n\nexport function updateTargetTeamMatchUps({\n  updateInProgressMatchUps,\n  tournamentRecord,\n  drawDefinition,\n  targetMatchUps,\n  tieFormat,\n  event,\n}) {\n  for (const targetMatchUp of targetMatchUps) {\n    const hasTieFormat = !!targetMatchUp.tieFormat;\n    if (hasTieFormat) {\n      targetMatchUp.tieFormat = copyTieFormat(tieFormat);\n    }\n\n    let scoreUpdated;\n    if (updateInProgressMatchUps) {\n      // recalculate score\n      const result = updateTieMatchUpScore({\n        matchUpId: targetMatchUp.matchUpId,\n        exitWhenNoValues: true,\n        tournamentRecord,\n        drawDefinition,\n        event,\n      });\n      if (result.error) return result;\n      scoreUpdated = result.score;\n    }\n\n    if (hasTieFormat && !scoreUpdated) {\n      modifyMatchUpNotice({\n        tournamentId: tournamentRecord?.tournamentId,\n        context: 'updateTargetTeamMatchUps',\n        eventId: event?.eventId,\n        matchUp: targetMatchUp,\n        drawDefinition,\n      });\n    }\n  }\n  return { ...SUCCESS };\n}\n","import { getAllStructureMatchUps } from '../../query/matchUps/getAllStructureMatchUps';\nimport { findDrawMatchUp } from '../../acquire/findDrawMatchUp';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { findStructure } from '../../acquire/findStructure';\nimport { isConvertableInteger } from '../../utilities/math';\nimport { numericSortValue } from '../../utilities/arrays';\nimport { copyTieFormat } from '../../query/hierarchical/tieFormats/copyTieFormat';\nimport {\n  modifyDrawNotice,\n  modifyMatchUpNotice,\n} from '../notifications/drawNotifications';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { TEAM } from '../../constants/matchUpTypes';\nimport {\n  INVALID_VALUES,\n  MISSING_MATCHUP,\n  NOT_FOUND,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  MatchUp,\n  Tournament,\n} from '../../types/tournamentTypes';\n\nfunction getOrderedTieFormat({ tieFormat, orderMap }) {\n  const orderedTieFormat = copyTieFormat(tieFormat);\n  orderedTieFormat.collectionDefinitions.forEach((collectionDefinition) => {\n    const collectionOrder = orderMap[collectionDefinition.collectionId];\n    if (collectionOrder) collectionDefinition.collectionOrder = collectionOrder;\n  });\n\n  orderedTieFormat.collectionDefinitions.sort(\n    (a, b) =>\n      numericSortValue(a.collectionOrder) - numericSortValue(b.collectionOrder)\n  );\n\n  return orderedTieFormat;\n}\n\ntype OrderCollectionDefinitionsArgs = {\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  structureId?: string;\n  matchUpId?: string;\n  matchUp?: MatchUp;\n  eventId?: string;\n  orderMap: any;\n  event?: Event;\n};\n\nexport function orderCollectionDefinitions({\n  tournamentRecord,\n  drawDefinition,\n  structureId,\n  matchUpId,\n  orderMap,\n  eventId,\n  matchUp,\n  event,\n}: OrderCollectionDefinitionsArgs) {\n  if (\n    typeof orderMap !== 'object' ||\n    !Object.values(orderMap).every((val) => isConvertableInteger(val))\n  )\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      context: { orderMap },\n    });\n\n  if (eventId && event?.tieFormat) {\n    updateEventTieFormat({ tournamentRecord, event, orderMap });\n  } else if (matchUpId) {\n    const result =\n      drawDefinition &&\n      findDrawMatchUp({\n        drawDefinition,\n        matchUpId,\n      });\n\n    if (result?.error) return result;\n\n    matchUp = result.matchUp;\n    if (!matchUp) return { error: MISSING_MATCHUP };\n\n    if (matchUp?.tieFormat) {\n      matchUp.tieFormat = getOrderedTieFormat({\n        tieFormat: matchUp.tieFormat,\n        orderMap,\n      });\n      modifyMatchUpNotice({\n        tournamentId: tournamentRecord?.tournamentId,\n        eventId: event?.eventId,\n        drawDefinition,\n        matchUp,\n      });\n    }\n  } else if (structureId) {\n    const result = findStructure({ drawDefinition, structureId });\n    if (result.error) return result;\n    const structure = result.structure;\n\n    if (structure?.tieFormat) {\n      structure.tieFormat = getOrderedTieFormat({\n        tieFormat: structure.tieFormat,\n        orderMap,\n      });\n      updateStructureMatchUps({\n        eventId: event?.eventId,\n        tournamentRecord,\n        drawDefinition,\n        structure,\n        orderMap,\n      });\n      modifyDrawNotice({\n        drawDefinition,\n        structureIds: [structure.structureId],\n      });\n    } else if (drawDefinition.tieFormat) {\n      updateDrawTieFormat({\n        structureIds: [structureId],\n        tournamentRecord,\n        drawDefinition,\n        orderMap,\n        event,\n      });\n    } else if (event?.tieFormat) {\n      updateEventTieFormat({\n        structureIds: [structureId],\n        tournamentRecord,\n        orderMap,\n        event,\n      });\n    } else {\n      return { error: NOT_FOUND };\n    }\n  } else if (drawDefinition?.tieFormat) {\n    updateDrawTieFormat({ tournamentRecord, drawDefinition, orderMap, event });\n  } else {\n    return { error: NOT_FOUND };\n  }\n\n  return { ...SUCCESS };\n}\n\ntype UpdateEventTieFormatArgs = {\n  tournamentRecord: Tournament;\n  structureIds?: string[];\n  orderMap?: any;\n  event: Event;\n};\n\nfunction updateEventTieFormat({\n  tournamentRecord,\n  structureIds, // allow scoping to only specific structureIds\n  orderMap,\n  event,\n}: UpdateEventTieFormatArgs) {\n  const updatedFormat = getOrderedTieFormat({\n    tieFormat: event.tieFormat,\n    orderMap,\n  });\n  if (!structureIds?.length) event.tieFormat = updatedFormat;\n\n  for (const drawDefinition of event.drawDefinitions ?? []) {\n    updateDrawTieFormat({\n      tournamentRecord,\n      drawDefinition,\n      structureIds,\n      orderMap,\n      event,\n    });\n  }\n}\n\ntype UpdateDrawTieFormatArgs = {\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  structureIds?: string[];\n  orderMap?: any;\n  event?: Event;\n};\n\nfunction updateDrawTieFormat({\n  tournamentRecord,\n  drawDefinition,\n  structureIds,\n  orderMap,\n  event,\n}: UpdateDrawTieFormatArgs) {\n  const tieFormat = drawDefinition.tieFormat ?? event?.tieFormat;\n  const updatedFormat = getOrderedTieFormat({\n    tieFormat,\n    orderMap,\n  });\n  if (!structureIds?.length) drawDefinition.tieFormat = updatedFormat;\n  const modifiedStructureIds: string[] = [];\n\n  for (const structure of drawDefinition.structures ?? []) {\n    // if structureIds is present, only modify referenced structures\n    if (structureIds?.length && !structureIds.includes(structure.structureId))\n      continue;\n\n    if (structure.tieFormat || structureIds?.includes(structure.structureId))\n      structure.tieFormat = getOrderedTieFormat({\n        tieFormat:\n          structure.tieFormat ?? drawDefinition.tieFormat ?? event?.tieFormat,\n        orderMap,\n      });\n    updateStructureMatchUps({\n      eventId: event?.eventId,\n      tournamentRecord,\n      drawDefinition,\n      structure,\n      orderMap,\n    });\n    modifiedStructureIds.push(structure.structureId);\n  }\n  modifyDrawNotice({ drawDefinition, structureIds: modifiedStructureIds });\n}\n\nfunction updateStructureMatchUps({\n  tournamentRecord,\n  drawDefinition,\n  structure,\n  orderMap,\n  eventId,\n}) {\n  const matchUps = getAllStructureMatchUps({\n    matchUpFilters: { matchUpTypes: [TEAM] },\n    structure,\n  })?.matchUps;\n\n  for (const matchUp of matchUps) {\n    if (matchUp.tieFormat) {\n      matchUp.tieFormat = getOrderedTieFormat({\n        tieFormat: matchUp.tieFormat,\n        orderMap,\n      });\n      modifyMatchUpNotice({\n        tournamentId: tournamentRecord?.tournamentId,\n        drawDefinition,\n        eventId,\n        matchUp,\n      });\n    }\n  }\n}\n","// all child matchUps need to be checked for collectionAssignments which need to be removed when collectionDefinition.collectionIds are removed\n\nimport { getAllStructureMatchUps } from '../../query/matchUps/getAllStructureMatchUps';\nimport { updateTieMatchUpScore } from '../matchUps/score/tieMatchUpScore';\nimport { setMatchUpState } from '../matchUps/matchUpStatus/setMatchUpState';\nimport { getAppliedPolicies } from '../../query/extensions/getAppliedPolicies';\nimport { findDrawMatchUp } from '../../acquire/findDrawMatchUp';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { checkScoreHasValue } from '../../query/matchUp/checkScoreHasValue';\nimport { calculateWinCriteria } from '../../query/matchUp/calculateWinCriteria';\nimport { getTieFormat } from '../../query/hierarchical/tieFormats/getTieFormat';\nimport { tieFormatTelemetry } from '../matchUps/tieFormat/tieFormatTelemetry';\nimport { validateTieFormat } from '../../validators/validateTieFormat';\nimport { compareTieFormats } from '../../query/hierarchical/tieFormats/compareTieFormats';\nimport { copyTieFormat } from '../../query/hierarchical/tieFormats/copyTieFormat';\nimport {\n  deleteMatchUpsNotice,\n  modifyDrawNotice,\n  modifyMatchUpNotice,\n} from '../notifications/drawNotifications';\nimport { allDrawMatchUps } from '../../query/matchUps/getAllDrawMatchUps';\nimport { allEventMatchUps } from '../../query/matchUps/getAllEventMatchUps';\n\nimport { TIE_FORMAT_MODIFICATIONS } from '../../constants/extensionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { TEAM } from '../../constants/matchUpTypes';\nimport { COMPLETED, IN_PROGRESS } from '../../constants/matchUpStatusConstants';\nimport {\n  ErrorType,\n  MISSING_DRAW_DEFINITION,\n  NOT_FOUND,\n  NO_MODIFICATIONS_APPLIED,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  MatchUp,\n  TieFormat,\n  Tournament,\n} from '../../types/tournamentTypes';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport { decorateResult } from '../../global/functions/decorateResult';\n\n/*\n * if an eventId is provided, will be removed from an event tieFormat\n * if a drawId is provided, will be removed from a draw tieFormat\n * if a matchUpId is provided, will be removed from matchUp.tieFormat\n * if a structureId is provided, will be removed from structure.tieFormat\n */\ntype RemoveCollectionDefinitionArgs = {\n  updateInProgressMatchUps?: boolean;\n  tieFormatComparison?: boolean;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  tieFormatName?: string;\n  collectionId: string;\n  structureId?: string;\n  matchUpId?: string;\n  matchUp?: MatchUp;\n  eventId?: string;\n  event?: Event;\n};\nexport function removeCollectionDefinition({\n  updateInProgressMatchUps = true,\n  tieFormatComparison,\n  tournamentRecord,\n  drawDefinition,\n  tieFormatName,\n  collectionId,\n  structureId,\n  matchUpId,\n  eventId,\n  matchUp,\n  event,\n}: RemoveCollectionDefinitionArgs): {\n  targetMatchUps?: HydratedMatchUp[];\n  deletedMatchUpIds?: string[];\n  tieFormat?: TieFormat;\n  success?: boolean;\n  error?: ErrorType;\n} {\n  const stack = 'removeCollectionDefinition';\n  let result = !matchUp\n    ? getTieFormat({\n        drawDefinition,\n        structureId,\n        matchUpId,\n        eventId,\n        event,\n      })\n    : undefined;\n\n  if (result?.error) return decorateResult({ result, stack });\n\n  const structure = result?.structure;\n  matchUp = matchUp ?? result?.matchUp;\n  const existingTieFormat = result?.tieFormat;\n  const tieFormat = copyTieFormat(existingTieFormat);\n\n  result = validateTieFormat({ tieFormat });\n  if (result.error) return decorateResult({ result, stack });\n\n  const targetCollection = tieFormat?.collectionDefinitions?.find(\n    (collectionDefinition) => collectionDefinition.collectionId === collectionId\n  );\n  if (!targetCollection)\n    return decorateResult({ result: { error: NOT_FOUND, collectionId } });\n\n  tieFormat.collectionDefinitions = tieFormat.collectionDefinitions.filter(\n    (collectionDefinition) => collectionDefinition.collectionId !== collectionId\n  );\n\n  // if the collectionDefinition being removed contains a collectionGroupNumber,\n  // remove the collectionGroup and all references to it in other collectionDefinitions\n  if (targetCollection.collectionGroupNumber) {\n    tieFormat.collectionDefinitions = tieFormat.collectionDefinitions.map(\n      (collectionDefinition) => {\n        const { collectionGroupNumber, ...rest } = collectionDefinition;\n        if (collectionGroupNumber) {\n          // collectionGroupNumber removed\n        }\n        return rest;\n      }\n    );\n    tieFormat.collectionGroups = tieFormat.collectionGroups.filter(\n      ({ groupNumber }) =>\n        groupNumber !== targetCollection.collectionGroupNumber\n    );\n  }\n\n  // calculate new winCriteria for tieFormat\n  // if existing winCriteria is aggregateValue, retain\n  const { aggregateValue, valueGoal } = calculateWinCriteria(tieFormat);\n  tieFormat.winCriteria = definedAttributes({ aggregateValue, valueGoal });\n\n  // if valueGoal has changed, force renaming of the tieFormat\n  const originalValueGoal = existingTieFormat?.winCriteria.valueGoal;\n  const wasAggregateValue = existingTieFormat?.winCriteria.aggregateValue;\n  if (\n    (originalValueGoal && originalValueGoal !== valueGoal) ||\n    (aggregateValue && !wasAggregateValue)\n  ) {\n    if (tieFormatName) {\n      tieFormat.tieFormatName = tieFormatName;\n    } else {\n      delete tieFormat.tieFormatName;\n    }\n  }\n\n  // check all scoped lineUps in the drawDefinition to identify collectionAssignments\n  let matchUps: MatchUp[] = [];\n\n  if (matchUpId && matchUp) {\n    matchUps = [matchUp];\n  } else if (structureId && structure) {\n    matchUps =\n      getAllStructureMatchUps({\n        matchUpFilters: { matchUpTypes: [TEAM] },\n        structure,\n      })?.matchUps ?? [];\n  } else if (drawDefinition) {\n    matchUps =\n      allDrawMatchUps({\n        matchUpFilters: { matchUpTypes: [TEAM] },\n        drawDefinition,\n      })?.matchUps ?? [];\n  } else if (event) {\n    matchUps =\n      allEventMatchUps({\n        matchUpFilters: { matchUpTypes: [TEAM] },\n        drawDefinition,\n      })?.matchUps ?? [];\n  }\n\n  // all team matchUps in scope which are completed or which have a score should not be modified\n  // UNLESS all collectionMatchUps have no score\n  const targetMatchUps = (matchUps || []).filter((matchUp) => {\n    const collectionMatchUps = matchUp.tieMatchUps?.filter(\n      (tieMatchUp) => tieMatchUp.collectionId === collectionId\n    );\n    const collectionScore = collectionMatchUps?.some(checkScoreHasValue);\n\n    const tieFormatDifference =\n      tieFormatComparison && matchUp.tieFormat\n        ? compareTieFormats({\n            descendant: matchUp.tieFormat,\n            ancestor: tieFormat,\n          })?.different\n        : false;\n\n    return (\n      (updateInProgressMatchUps && !collectionScore) ||\n      (!matchUp.winningSide &&\n        matchUp.matchUpStatus !== COMPLETED &&\n        (updateInProgressMatchUps ||\n          (matchUp.matchUpStatus !== IN_PROGRESS &&\n            !checkScoreHasValue(matchUp) &&\n            !tieFormatDifference)))\n    );\n  });\n\n  if (!targetMatchUps.length) {\n    return { error: NO_MODIFICATIONS_APPLIED };\n  }\n\n  if (matchUpId && matchUp && updateInProgressMatchUps) {\n    const collectionMatchUps = matchUp.tieMatchUps?.filter(\n      (tieMatchUp) => tieMatchUp.collectionId === collectionId\n    );\n    for (const collectionMatchUp of collectionMatchUps ?? []) {\n      let result: any = setMatchUpState({\n        matchUpId: collectionMatchUp.matchUpId,\n        tieMatchUpId: matchUp?.matchUpId,\n        winningSide: undefined,\n        removeScore: true,\n        tournamentRecord,\n        drawDefinition,\n        event,\n      });\n      if (result.error) return result;\n\n      result = findDrawMatchUp({\n        drawDefinition,\n        matchUpId,\n      });\n      if (result.error) return result;\n      matchUp = result?.matchUp;\n    }\n  }\n\n  const deletedMatchUpIds: string[] = [];\n  for (const matchUp of targetMatchUps) {\n    // remove any collectionAssignments from LineUps that include collectionId\n    for (const side of matchUp?.sides ?? []) {\n      side.lineUp = (side.lineUp ?? []).map((assignment) => ({\n        participantId: assignment.participantId,\n        collectionAssignments: (assignment?.collectionAssignments ?? []).filter(\n          (collectionAssignment) =>\n            collectionAssignment.collectionId !== collectionId\n        ),\n      }));\n    }\n\n    // delete any tieMatchUps that contain collectionId\n    matchUp.tieMatchUps = (matchUp.tieMatchUps ?? []).filter((matchUp) => {\n      const deleteTarget = matchUp.collectionId === collectionId;\n      if (deleteTarget) deletedMatchUpIds.push(matchUp.matchUpId);\n      return !deleteTarget;\n    });\n\n    if (matchUp.tieFormat) matchUp.tieFormat = copyTieFormat(tieFormat);\n\n    if (updateInProgressMatchUps) {\n      // recalculate score\n      const result = updateTieMatchUpScore({\n        matchUpId: matchUp.matchUpId,\n        exitWhenNoValues: true,\n        tournamentRecord,\n        drawDefinition,\n        event,\n      });\n      if (result.error) return result;\n    }\n\n    modifyMatchUpNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      eventId: event?.eventId,\n      drawDefinition,\n      context: stack,\n      matchUp,\n    });\n  }\n\n  // remove any matchUps which contain collectionId\n  if (deletedMatchUpIds.length) {\n    // notify subscribers that matchUps have been deleted\n    deleteMatchUpsNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      matchUpIds: deletedMatchUpIds,\n      eventId: event?.eventId,\n      drawDefinition,\n    });\n  }\n\n  const prunedTieFormat = definedAttributes(tieFormat);\n  result = validateTieFormat({ tieFormat: prunedTieFormat });\n  if (result.error) return decorateResult({ result, stack });\n\n  // TODO: implement use of tieFormats and tieFormatId\n  if (eventId && event) {\n    event.tieFormat = prunedTieFormat;\n    // NOTE: there is not a modifyEventNotice\n  } else if (matchUpId && matchUp) {\n    matchUp.tieFormat = prunedTieFormat;\n  } else if (structure) {\n    structure.tieFormat = prunedTieFormat;\n  } else if (drawDefinition) {\n    drawDefinition.tieFormat = prunedTieFormat;\n  } else if (!matchUp || !drawDefinition) {\n    return { error: MISSING_DRAW_DEFINITION };\n  }\n\n  modifyDrawNotice({ drawDefinition, eventId: event?.eventId });\n\n  const { appliedPolicies } = getAppliedPolicies({ tournamentRecord });\n  if (appliedPolicies?.audit?.[TIE_FORMAT_MODIFICATIONS]) {\n    const auditData = definedAttributes({\n      drawId: drawDefinition?.drawId,\n      action: stack,\n      collectionId,\n      structureId,\n      matchUpId,\n      eventId,\n    });\n    tieFormatTelemetry({ drawDefinition, auditData });\n  }\n\n  return {\n    tieFormat: prunedTieFormat,\n    deletedMatchUpIds,\n    targetMatchUps,\n    ...SUCCESS,\n  };\n}\n","import { definedAttributes } from '../../../../utilities/definedAttributes';\n\nimport { MISSING_STRUCTURE_ID } from '../../../../constants/errorConditionConstants';\nimport { DRAW, WINNER } from '../../../../constants/drawDefinitionConstants';\nimport { LinkTypeUnion } from '../../../../types/tournamentTypes';\n\ntype GenerateQualifyingLinkArgs = {\n  targetEntryRound?: number;\n  sourceRoundNumber: number;\n  finishingPositions?: any;\n  sourceStructureId: string;\n  targetStructureId: string;\n  linkType?: LinkTypeUnion;\n};\nexport function generateQualifyingLink({\n  targetEntryRound = 1,\n  finishingPositions,\n  sourceRoundNumber,\n  sourceStructureId,\n  targetStructureId,\n  linkType = WINNER,\n}: GenerateQualifyingLinkArgs) {\n  if (!sourceStructureId || !targetStructureId)\n    return { error: MISSING_STRUCTURE_ID };\n\n  const link = definedAttributes({\n    linkType,\n    source: {\n      roundNumber: sourceRoundNumber,\n      structureId: sourceStructureId,\n      finishingPositions,\n    },\n    target: {\n      feedProfile: DRAW, // positions are not automatically placed\n      roundNumber: targetEntryRound,\n      structureId: targetStructureId,\n    },\n  });\n\n  return { link };\n}\n","import { UUID } from '../../../utilities/UUID';\n\nexport function generateMatchUpId({\n  roundPosition,\n  roundNumber,\n  idPrefix,\n  uuids,\n}) {\n  return idPrefix\n    ? `${idPrefix}-${roundNumber}-${roundPosition}`\n    : uuids?.pop() || UUID();\n}\n","import { generateMatchUpId } from './generateMatchUpId';\n\nimport { TO_BE_PLAYED } from '../../../constants/matchUpStatusConstants';\n\n/**\n *\n * @param {boolean=} includeMatchUpType\n * @param {string=} matchUpType\n * @param {number} roundNumber\n * @param {object[]} matchUps\n * @param {string=} idPrefix\n * @param {boolean=} isMock\n * @param {string[]=} uuids\n * @param {object[]=} nodes\n * @returns\n */\n\ntype BuildRoundArgs = {\n  includeMatchUpType?: boolean;\n  matchUpType?: string;\n  roundNumber: number;\n  idPrefix?: string;\n  isMock?: boolean;\n  uuids?: string[];\n  matchUps: any[];\n  nodes?: any[];\n};\n\nexport function buildRound({\n  includeMatchUpType,\n  matchUpType,\n  roundNumber,\n  matchUps,\n  idPrefix,\n  isMock,\n  uuids,\n  nodes,\n}: BuildRoundArgs) {\n  let index = 0;\n  const roundNodes: any[] = [];\n  let roundPosition = 1;\n  const matchRoundNumber = roundNumber - 1;\n  const roundMatchUpsCount = nodes?.length;\n\n  while (index < (roundMatchUpsCount || 0)) {\n    const child1 = nodes?.[index];\n    const child2 = nodes?.[index + 1];\n\n    if (matchRoundNumber) child1.roundNumber = matchRoundNumber;\n    if (child2 && matchRoundNumber) child2.roundNumber = matchRoundNumber;\n\n    const matchUpId = generateMatchUpId({\n      roundPosition,\n      roundNumber,\n      idPrefix,\n      uuids,\n    });\n\n    const node = {\n      roundPosition,\n      children: [child1, child2],\n      matchUpId,\n    };\n    roundNodes.push(node);\n\n    const matchUp: any = {\n      drawPositions: node.children.map((c) => c?.drawPosition).filter(Boolean),\n      matchUpStatus: TO_BE_PLAYED,\n      matchUpId: node.matchUpId,\n      roundPosition,\n      roundNumber,\n    };\n\n    // matchUpType is derived for inContext matchUps from structure or drawDefinition\n    if (includeMatchUpType && matchUpType) matchUp.matchUpType = matchUpType;\n    if (isMock) matchUp.isMock = true;\n\n    matchUps.push(matchUp);\n    roundPosition++;\n    index += 2;\n  }\n\n  return { roundNodes, matchUps };\n}\n","import { generateRange } from '../../../../utilities/arrays';\nimport { addFinishingRounds } from '../addFinishingRounds';\nimport { isPowerOf2 } from '../../../../utilities/math';\nimport { buildRound } from '../buildRound';\n\nimport { MatchUp } from '../../../../types/tournamentTypes';\n\ntype TreeMatchUpsArgs = {\n  finishingPositionOffset?: number;\n  finishingPositionLimit?: number;\n  qualifyingRoundNumber?: number;\n  qualifyingPositions?: number;\n  matchUpType?: string;\n  roundLimit?: number;\n  idPrefix?: string;\n  drawSize: number;\n  isMock?: boolean;\n  uuids?: string[];\n};\n\ntype TreeMatchUpsReturn = {\n  matchUps: MatchUp[];\n  roundsCount: number;\n  roundLimit?: number;\n  drawSize?: number;\n};\n\nexport function treeMatchUps({\n  finishingPositionOffset,\n  finishingPositionLimit, // optional - limit finishingPositionRanges\n  qualifyingRoundNumber, // round at which participants qualify\n  qualifyingPositions, // number of positions which qualify\n  matchUpType,\n  roundLimit,\n  idPrefix,\n  drawSize,\n  isMock,\n  uuids,\n}: TreeMatchUpsArgs): TreeMatchUpsReturn {\n  if (isNaN(drawSize) || drawSize < 2 || (qualifyingPositions && drawSize <= qualifyingPositions)) {\n    return { matchUps: [], roundsCount: 0 };\n  }\n\n  if (qualifyingPositions && (!isPowerOf2(drawSize) || drawSize % qualifyingPositions)) {\n    // if drawSize is NOT a multiple of qualifyingPositions...\n    // change drawSize to a multiple of qualifyingPositions that is larger than drawSize\n    let requiredDrawSize = qualifyingPositions;\n    while (requiredDrawSize < drawSize) requiredDrawSize = 2 * requiredDrawSize;\n    drawSize = requiredDrawSize;\n  }\n\n  const isValidQualifying =\n    qualifyingPositions &&\n    !(drawSize % 2) &&\n    (!isNaN(qualifyingPositions) || (qualifyingRoundNumber && !isNaN(qualifyingRoundNumber))) &&\n    (drawSize / qualifyingPositions === Math.round(drawSize / qualifyingPositions) ||\n      (qualifyingRoundNumber && drawSize / qualifyingRoundNumber === Math.round(drawSize / qualifyingRoundNumber)));\n\n  if (!isPowerOf2(drawSize) && !isValidQualifying) {\n    return { matchUps: [], roundsCount: 0 };\n  }\n\n  const nodes = generateRange(1, drawSize + 1).map((drawPosition) => ({\n    drawPosition,\n  }));\n\n  let roundNodes;\n  let matchUps: MatchUp[] = [];\n  let roundNumber = 1;\n\n  ({ roundNodes, matchUps } = buildRound({\n    matchUpType,\n    roundNumber,\n    idPrefix,\n    matchUps,\n    isMock,\n    nodes,\n    uuids,\n  }));\n  roundNumber++;\n\n  roundLimit = roundLimit ?? qualifyingRoundNumber;\n\n  while (roundNodes.length > 1) {\n    if (qualifyingPositions && roundNodes.length === qualifyingPositions) {\n      roundLimit = roundNumber - 1;\n    }\n\n    ({ roundNodes, matchUps } = buildRound({\n      nodes: roundNodes,\n      matchUpType,\n      roundNumber,\n      idPrefix,\n      matchUps,\n      isMock,\n      uuids,\n    }));\n    roundNumber++;\n  }\n\n  const roundsCount = roundNumber - 1; // because roundNumber was incremented at the end of the while loop\n\n  matchUps = addFinishingRounds({\n    finishingPositionOffset,\n    finishingPositionLimit,\n    roundsCount,\n    roundLimit,\n    matchUps,\n  });\n\n  if (!roundLimit) {\n    // this is the case { qualifyingPositions : 1 }\n    // subtract one to account for the last ++\n    roundLimit = roundNumber - 1;\n  } else {\n    matchUps = matchUps.filter((matchUp) => roundLimit && (matchUp.roundNumber ?? 0) <= roundLimit);\n  }\n\n  return { drawSize, matchUps, roundsCount, roundLimit };\n}\n","import { getStructureGroups } from '../../../../query/structure/getStructureGroups';\nimport { coerceEven, isConvertableInteger } from '../../../../utilities/math';\nimport { decorateResult } from '../../../../global/functions/decorateResult';\nimport { addExtension } from '../../../../mutate/extensions/addExtension';\nimport { generateQualifyingLink } from '../links/generateQualifyingLink';\nimport structureTemplate from '../../templates/structureTemplate';\nimport { constantToString } from '../../../../utilities/strings';\nimport { generateRoundRobin } from './roundRobin/roundRobin';\nimport { treeMatchUps } from './eliminationTree';\n\nimport POLICY_ROUND_NAMING_DEFAULT from '../../../../fixtures/policies/POLICY_ROUND_NAMING_DEFAULT';\nimport { POLICY_TYPE_ROUND_NAMING } from '../../../../constants/policyConstants';\nimport { ROUND_TARGET } from '../../../../constants/extensionConstants';\nimport { PolicyDefinitions } from '../../../../types/factoryTypes';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport {\n  ErrorType,\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n  MISSING_DRAW_SIZE,\n  STRUCTURE_NOT_FOUND,\n} from '../../../../constants/errorConditionConstants';\nimport {\n  POSITION,\n  QUALIFYING,\n  ROUND_ROBIN,\n  WINNER,\n} from '../../../../constants/drawDefinitionConstants';\nimport {\n  DrawDefinition,\n  DrawLink,\n  DrawTypeUnion,\n  Event,\n  Structure,\n} from '../../../../types/tournamentTypes';\n\ntype GenerateQualifyingStructureArgs = {\n  appliedPolicies?: PolicyDefinitions;\n  qualifyingRoundNumber: number;\n  drawDefinition: DrawDefinition;\n  qualifyingPositions?: number;\n  participantsCount?: number;\n  targetStructureId: string;\n  drawType?: DrawTypeUnion;\n  structureOptions?: any;\n  matchUpFormat?: string;\n  structureName?: string;\n  structureId?: string;\n  roundTarget: number;\n  drawSize?: number;\n  idPrefix?: string;\n  isMock?: boolean;\n  uuids?: string[];\n  event?: Event;\n};\n\n// for use when adding a qualifying structure to an existing drawDefinition\n// not for use when generating structures from qualifyingProfiles\nexport function generateQualifyingStructure(\n  params: GenerateQualifyingStructureArgs\n): {\n  qualifyingDrawPositionsCount?: number;\n  qualifiersCount?: number;\n  structure?: Structure;\n  error?: ErrorType;\n  success?: boolean;\n  link?: DrawLink;\n} {\n  const stack = 'generateQualifyingStructure';\n\n  if (!params.drawDefinition)\n    return decorateResult({\n      result: { error: MISSING_DRAW_DEFINITION },\n      stack,\n    });\n\n  if (\n    (params.drawSize && !isConvertableInteger(params.drawSize)) ||\n    (params.participantsCount &&\n      !isConvertableInteger(params.participantsCount)) ||\n    (params.qualifyingPositions &&\n      !isConvertableInteger(params.qualifyingPositions))\n  ) {\n    return decorateResult({ result: { error: INVALID_VALUES }, stack });\n  }\n\n  let drawSize = params.drawSize ?? coerceEven(params.participantsCount);\n\n  const {\n    qualifyingRoundNumber,\n    qualifyingPositions,\n    targetStructureId,\n    structureOptions,\n    appliedPolicies,\n    drawDefinition,\n    matchUpFormat,\n    structureName,\n    structureId,\n    roundTarget,\n    drawType,\n    idPrefix,\n    isMock,\n    uuids,\n  } = params;\n\n  if (!params.drawSize)\n    return decorateResult({\n      result: { error: MISSING_DRAW_SIZE },\n      context: { drawSize },\n      stack,\n    });\n\n  if (qualifyingPositions && qualifyingPositions >= params.drawSize)\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      context: { drawSize, qualifyingPositions },\n      stack,\n    });\n\n  let roundLimit: number | undefined,\n    roundsCount: number | undefined,\n    structure: Structure | undefined,\n    matchUps;\n  let qualifiersCount = 0;\n  let finishingPositions;\n  const stageSequence = 1;\n\n  const { structureProfiles } = getStructureGroups({ drawDefinition });\n\n  const structureProfile = structureProfiles[targetStructureId];\n\n  if (!structureProfile) {\n    return decorateResult({\n      result: { error: STRUCTURE_NOT_FOUND },\n      context: { targetStructureId },\n      stack,\n    });\n  }\n\n  const matchUpType = drawDefinition.matchUpType;\n\n  const roundTargetName = roundTarget ? `${roundTarget}-` : '';\n  const isPreQualifying = structureProfile.stage === QUALIFYING;\n  const preQualifyingNaming =\n    appliedPolicies?.[POLICY_TYPE_ROUND_NAMING]?.namingConventions?.pre ??\n    POLICY_ROUND_NAMING_DEFAULT[POLICY_TYPE_ROUND_NAMING]?.namingConventions\n      ?.pre;\n  const pre =\n    isPreQualifying && preQualifyingNaming ? `${preQualifyingNaming}-` : '';\n\n  const qualifyingStructureName =\n    structureName ??\n    (roundTargetName\n      ? `${pre}${constantToString(QUALIFYING)} ${roundTargetName}`\n      : `${pre}${constantToString(QUALIFYING)}`);\n\n  if (drawType === ROUND_ROBIN) {\n    const { maxRoundNumber /*, groupSize*/, structures, groupCount } =\n      generateRoundRobin({\n        structureName: structureName ?? qualifyingStructureName,\n        structureId: structureId ?? uuids?.pop(),\n        stage: QUALIFYING,\n        structureOptions,\n        appliedPolicies,\n        stageSequence,\n        matchUpType,\n        roundTarget,\n        idPrefix,\n        drawSize,\n        isMock,\n        uuids,\n      });\n    qualifiersCount = groupCount;\n    roundLimit = maxRoundNumber;\n    structure = structures[0];\n    finishingPositions = [1];\n  } else {\n    ({ drawSize, matchUps, roundLimit, roundsCount } = treeMatchUps({\n      qualifyingRoundNumber,\n      qualifyingPositions,\n      matchUpType,\n      idPrefix,\n      drawSize,\n      isMock,\n      uuids,\n    }));\n    if (!roundLimit) roundLimit = roundsCount;\n\n    structure = structureTemplate({\n      structureName: structureName ?? qualifyingStructureName,\n      structureId: structureId ?? uuids?.pop(),\n      qualifyingRoundNumber: roundLimit,\n      stage: QUALIFYING,\n      matchUpFormat,\n      stageSequence,\n      matchUpType,\n      roundLimit, // redundant\n      matchUps,\n    });\n\n    if (roundTarget) {\n      addExtension({\n        extension: { name: ROUND_TARGET, value: roundTarget },\n        element: structure,\n      });\n    }\n\n    qualifiersCount = matchUps?.filter(\n      (matchUp) => matchUp.roundNumber === roundLimit\n    )?.length;\n  }\n\n  // order of operations is important here!! finalQualifier positions is not yet updated when this step occurs\n  const linkType = drawType === ROUND_ROBIN ? POSITION : WINNER;\n\n  const link =\n    structure &&\n    roundLimit &&\n    generateQualifyingLink({\n      sourceStructureId: structure.structureId,\n      sourceRoundNumber: roundLimit,\n      targetStructureId,\n      finishingPositions,\n      linkType,\n    })?.link;\n\n  return {\n    qualifyingDrawPositionsCount: drawSize,\n    qualifiersCount,\n    ...SUCCESS,\n    structure,\n    link,\n  };\n}\n","import { isValidMatchUpFormat } from '../../../validators/isValidMatchUpFormat';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { findStructure } from '../../../acquire/findStructure';\nimport {\n  modifyDrawNotice,\n  modifyMatchUpNotice,\n} from '../../notifications/drawNotifications';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { TEAM } from '../../../constants/eventConstants';\nimport {\n  MISSING_MATCHUP_FORMAT,\n  MISSING_DRAW_DEFINITION,\n  UNRECOGNIZED_MATCHUP_FORMAT,\n  STRUCTURE_NOT_FOUND,\n  INVALID_EVENT_TYPE,\n  INVALID_MATCHUP,\n  ErrorType,\n  MATCHUP_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype SetMatchUpMatchUpFormatArgs = {\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  structureIds?: string[];\n  matchUpFormat: string;\n  structureId?: string;\n  matchUpId?: string;\n  event?: Event;\n};\n\n// internal use only; set matchUpFormat for a matchUp or structure\n\nexport function setMatchUpMatchUpFormat(params: SetMatchUpMatchUpFormatArgs): {\n  success?: boolean;\n  error?: ErrorType;\n  info?: string;\n} {\n  let structureIds = params.structureIds;\n  const {\n    tournamentRecord,\n    drawDefinition,\n    matchUpFormat,\n    structureId,\n    matchUpId,\n    event,\n  } = params;\n\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!matchUpFormat) return { error: MISSING_MATCHUP_FORMAT };\n  if (!isValidMatchUpFormat({ matchUpFormat }))\n    return { error: UNRECOGNIZED_MATCHUP_FORMAT };\n  const stack = 'setMatchUpFormat';\n\n  if (matchUpId) {\n    const result = findDrawMatchUp({\n      drawDefinition,\n      matchUpId,\n      event,\n    });\n    if (result.error) return result;\n    if (!result.matchUp) return { error: MATCHUP_NOT_FOUND };\n    const matchUp = result.matchUp;\n    if (matchUp?.matchUpType === TEAM)\n      return {\n        error: INVALID_MATCHUP,\n        info: 'Cannot set matchUpFormat when { matchUpType: TEAM }',\n      };\n\n    matchUp.matchUpFormat = matchUpFormat;\n    modifyMatchUpNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      eventId: event?.eventId,\n      context: stack,\n      drawDefinition,\n      matchUp,\n    });\n  } else if (Array.isArray(structureIds)) {\n    if (event?.eventType === TEAM) return { error: INVALID_EVENT_TYPE };\n    for (const structureId of structureIds) {\n      const result = findStructure({ drawDefinition, structureId });\n      if (result.error) return result;\n      if (!result.structure) {\n        return { error: STRUCTURE_NOT_FOUND };\n      } else {\n        result.structure.matchUpFormat = matchUpFormat;\n      }\n    }\n  } else if (structureId) {\n    if (event?.eventType === TEAM) return { error: INVALID_EVENT_TYPE };\n    const result = findStructure({ drawDefinition, structureId });\n    if (result.error) return result;\n    if (!result.structure) {\n      return { error: STRUCTURE_NOT_FOUND };\n    } else {\n      result.structure.matchUpFormat = matchUpFormat;\n    }\n  } else if (drawDefinition) {\n    drawDefinition.matchUpFormat = matchUpFormat;\n  }\n\n  structureIds = structureIds ?? (structureId ? [structureId] : undefined);\n  modifyDrawNotice({ drawDefinition, structureIds });\n\n  return { ...SUCCESS };\n}\n","import { generateRange } from '../../../utilities/arrays';\nimport { generateMatchUpId } from './generateMatchUpId';\n\nimport { TO_BE_PLAYED } from '../../../constants/matchUpStatusConstants';\nimport { MatchUp } from '../../../types/tournamentTypes';\n\ntype BuildFeedRoundArgs = {\n  includeMatchUpType?: boolean;\n  drawPosition?: number;\n  matchUpType?: string;\n  roundNumber: number;\n  matchUps: MatchUp[];\n  idPrefix?: string;\n  isMock?: boolean;\n  uuids?: string[];\n  fed: number;\n  nodes: any;\n};\nexport function buildFeedRound({\n  includeMatchUpType,\n  drawPosition,\n  roundNumber,\n  matchUpType,\n  idPrefix,\n  matchUps,\n  isMock,\n  uuids,\n  nodes,\n  fed,\n}: BuildFeedRoundArgs): {\n  drawPosition: number | undefined;\n  matchUps: MatchUp[];\n  roundNodes: any;\n} {\n  const feedRoundMatchUpsCount = nodes.length;\n  const initialGroupDrawPosition = drawPosition\n    ? drawPosition - feedRoundMatchUpsCount\n    : undefined;\n  const drawPositionGroup = generateRange(0, feedRoundMatchUpsCount).map(\n    (value) =>\n      initialGroupDrawPosition ? initialGroupDrawPosition + value : undefined\n  );\n\n  const roundNodes: any[] = [];\n  for (let nodeIndex = 0; nodeIndex < feedRoundMatchUpsCount; nodeIndex++) {\n    const feedDrawPosition = drawPositionGroup.shift();\n\n    const feedArm = {\n      drawPosition: feedDrawPosition,\n      fed: fed + 1,\n      feed: true,\n    };\n\n    const position = nodes[nodeIndex];\n    position.roundNumber = roundNumber - 1;\n    const matchUpId = generateMatchUpId({\n      roundPosition: position.roundPosition,\n      roundNumber,\n      idPrefix,\n      uuids,\n    });\n\n    const newMatchUp: any = {\n      roundPosition: position.roundPosition,\n      drawPositions: [feedDrawPosition],\n      matchUpStatus: TO_BE_PLAYED,\n      roundNumber,\n      matchUpId,\n    };\n\n    // matchUpType is derived for inContext matchUps from structure or drawDefinition\n    if (includeMatchUpType) newMatchUp.matchUpType = matchUpType;\n    if (isMock) newMatchUp.isMock = true;\n\n    matchUps.push(newMatchUp);\n\n    const roundNode = { children: [position, feedArm] };\n    roundNodes.push(roundNode);\n  }\n\n  const nextDrawPosition = drawPosition\n    ? drawPosition - feedRoundMatchUpsCount\n    : undefined;\n\n  return { roundNodes, matchUps, drawPosition: nextDrawPosition };\n}\n","import { generateRange, instanceCount } from '../../../utilities/arrays';\nimport { addFinishingRounds } from './addFinishingRounds';\nimport { nearestPowerOf2 } from '../../../utilities/math';\nimport { buildFeedRound } from './buildFeedRound';\nimport { buildRound } from './buildRound';\n\nimport { MatchUp } from '../../../types/tournamentTypes';\n\ntype FeedInMatchUpsArgs = {\n  linkFedFinishingRoundNumbers?: number[];\n  finishingPositionOffset?: number;\n  linkFedRoundNumbers?: number[];\n  feedsFromFinal?: number;\n  isConsolation?: boolean;\n  feedRoundsProfile?: any;\n  baseDrawSize?: number;\n  feedRounds?: number;\n  skipRounds?: number;\n  matchUpType?: string;\n  idPrefix?: string;\n  drawSize?: number;\n  isMock?: boolean;\n  uuids?: string[];\n  fmlc?: boolean;\n};\n\nexport function feedInMatchUps(params: FeedInMatchUpsArgs) {\n  const drawSize = params.drawSize;\n  let {\n    feedRoundsProfile,\n    feedRounds = 0,\n    skipRounds = 0,\n    baseDrawSize,\n  } = params;\n\n  const {\n    linkFedFinishingRoundNumbers,\n    finishingPositionOffset,\n    linkFedRoundNumbers,\n    feedsFromFinal,\n    isConsolation,\n    matchUpType,\n    idPrefix,\n    isMock,\n    uuids,\n    fmlc,\n  } = params;\n  // calculate the number of rounds and the number of matchUps in each round\n  // for normal elimination structure\n  baseDrawSize = baseDrawSize ?? getBaseDrawSize(drawSize);\n  const baseDrawRounds = roundMatchCounts({ drawSize: baseDrawSize });\n  const baseRoundsCount = baseDrawRounds.length;\n\n  let positionsFed = 0;\n  if (feedRoundsProfile?.length) {\n    positionsFed = feedRoundsProfile.reduce((a, b) => a + b, 0);\n  } else if (drawSize) {\n    // having a drawSize defined trumps other configuration options\n    let positionsToFeed = drawSize - baseDrawSize;\n    feedRoundsProfile = baseDrawRounds.filter((feedSize) => {\n      if (feedSize <= positionsToFeed) {\n        positionsToFeed -= feedSize;\n        return true;\n      }\n      return false;\n    });\n    positionsFed = feedRoundsProfile.reduce((a, b) => a + b, 0);\n    feedRounds = feedRoundsProfile.length;\n  } else {\n    // if skipRounds is set higher than baseRoundsCount then there are no feedRounds\n    if (skipRounds >= baseRoundsCount) {\n      feedRounds = 0;\n    } else if (feedsFromFinal) {\n      // if feedsFromFinal is defined, calculate number of feed rounds from Final Match\n      // e.g. feedsFromFinal is 1 for Semifinal, 2 for QuarterFinals, 3 for Round of 16\n      feedRounds = baseRoundsCount - feedsFromFinal;\n      skipRounds = 0;\n    }\n\n    // Given the above, feedsFromFinal trumps skipRounds\n    // and skipRounds >= baseRoundsCount negates feedRounds\n    feedRoundsProfile = baseDrawRounds.filter((feedSize, i) => {\n      if (feedsFromFinal && !feedRounds) return 0;\n      if (feedRounds && i >= skipRounds + feedRounds) return 0;\n      if (i < skipRounds) return 0;\n      return feedSize;\n    });\n    positionsFed = feedRoundsProfile.reduce((a, b) => a + b, 0);\n    feedRounds = feedRoundsProfile.length;\n  }\n\n  const allRounds = [...baseDrawRounds, ...feedRoundsProfile].sort(\n    (a, b) => b - a\n  );\n  const roundsCount = allRounds.length;\n\n  // rounds which have linkFed participants can be specified two ways:\n  // linkFedRoundNumbers[] and linkFedFinishingRoundNumbers[]\n  // the difference being which end of the draw structure === 1\n  const linkFedRoundNumbersIndices = [\n    ...(linkFedRoundNumbers ?? []).map((n) => n - 1),\n    ...(linkFedFinishingRoundNumbers ?? []).map((n) => roundsCount - n),\n  ];\n\n  // positionsFedByLinks can be determined by summing the values in allRounds\n  // which are found at linkFedRoundNumbersIndices\n  const positionsFedByLinks = linkFedRoundNumbersIndices\n    .map((i) => allRounds[i])\n    .reduce((a, b) => a + b, 0);\n  positionsFed = positionsFed - positionsFedByLinks;\n\n  // initialize round creation variables\n  let fed = 0; // keep track of even/odd feed rounds\n  let matchUps: MatchUp[] = []; // accumulate matchUps\n  let roundNodes; // an array of nodes\n  let roundNumber = 1; // initial roundNumber\n\n  // firstRoundDrawPositions are generated and assigned drawPositions\n  const firstRoundDrawPositions = generateRange(0, baseDrawSize).map(\n    (_, i) => ({\n      drawPosition: i + 1 + positionsFed,\n    })\n  );\n\n  // initial nodes fed into buildRound\n  let nodes = firstRoundDrawPositions;\n\n  // drawPosition within structure; offset used for feedRounds\n  let drawPosition: number | undefined = positionsFed + 1;\n\n  for (const baseDrawRound of baseDrawRounds) {\n    ({ roundNodes, matchUps } = buildRound({\n      matchUpType,\n      roundNumber,\n      idPrefix,\n      matchUps,\n      isMock,\n      nodes,\n      uuids,\n    }));\n    roundNumber++;\n    if (feedRoundsProfile.includes(baseDrawRound)) {\n      const roundIterations = instanceCount(feedRoundsProfile)[baseDrawRound];\n      const iterationRange = generateRange(0, roundIterations);\n      const finishingRoundNumber = roundsCount + 1 - roundNumber;\n      const isLinkFedRound =\n        linkFedFinishingRoundNumbers?.includes(finishingRoundNumber) ??\n        linkFedRoundNumbers?.includes(roundNumber);\n\n      iterationRange.forEach(() => {\n        const iterationDrawPosition =\n          (!isLinkFedRound && drawPosition) || undefined;\n        ({ roundNodes, matchUps, drawPosition } = buildFeedRound({\n          drawPosition: iterationDrawPosition,\n          nodes: roundNodes,\n          matchUpType,\n          roundNumber,\n          idPrefix,\n          matchUps,\n          isMock,\n          uuids,\n          fed,\n        }));\n        roundNumber++;\n        fed += 1;\n      });\n    }\n    nodes = roundNodes;\n  }\n\n  // because roundNumber was incremented at the end of the while loop\n  if (roundsCount !== roundNumber - 1) console.log('ERROR');\n\n  // if this is a feed-in consolation then finishing drawPositions must be offset ...\n  // ... by the number of drawPositions which will be fed into the consolation draw\n  // final drawPositions will be played off twice up until the final feed round\n\n  const consolationFinish = baseDrawSize - positionsFed;\n  const modifiedFinishingPositionOffset = isConsolation\n    ? consolationFinish\n    : finishingPositionOffset;\n\n  matchUps = addFinishingRounds({\n    finishingPositionOffset: modifiedFinishingPositionOffset,\n    positionsFed,\n    roundsCount,\n    matchUps,\n    fmlc,\n  });\n\n  const draw = roundNodes?.length ? roundNodes[0] : roundNodes;\n  if (draw) {\n    draw.roundNumber = roundNumber - 1;\n    draw.matchUps = matchUps;\n  }\n\n  return { draw, matchUps, roundsCount };\n\n  function getBaseDrawSize(drawSize) {\n    const nearestP2 = nearestPowerOf2(drawSize);\n    return nearestP2 > drawSize ? nearestP2 / 2 : nearestP2;\n  }\n}\n\n// returns an array of the number of matchUps in each round of an elimination draw\nfunction roundMatchCounts({ drawSize }) {\n  const rounds = Math.ceil(Math.log(drawSize) / Math.log(2));\n  const range = generateRange(0, rounds).reverse();\n  return range.map((r) => Math.pow(2, r));\n}\n","import structureTemplate from '../../templates/structureTemplate';\nimport { generateRange } from '../../../../utilities/arrays';\nimport { feedInMatchUps } from '../feedInMatchUps';\nimport { treeMatchUps } from './eliminationTree';\n\nimport {\n  LOSER,\n  MAIN,\n  TOP_DOWN,\n} from '../../../../constants/drawDefinitionConstants';\nimport { ErrorType } from '../../../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport {\n  DrawDefinition,\n  DrawLink,\n  MatchUp,\n  Structure,\n} from '../../../../types/tournamentTypes';\n\nexport type NamingEntry = {\n  [key: string]: { name: string; abbreviation: string; structureId?: string };\n};\n\ntype GeneratePlayoffStructuresArgs = {\n  addNameBaseToAttributeName?: boolean;\n  finishingPositionNaming?: NamingEntry;\n  playoffStructureNameBase?: string;\n  finishingPositionOffset?: number;\n  playoffAttributes?: NamingEntry;\n  finishingPositionLimit?: number;\n  drawDefinition?: DrawDefinition;\n  exitProfileLimit?: boolean;\n  roundOffsetLimit?: number;\n  staggeredEntry?: boolean; // should only apply to playoffs from round robins\n  sequenceLimit?: number;\n  stageSequence?: number;\n  structureName?: string;\n  matchUpType?: string;\n  roundOffset?: number;\n  structureId?: string;\n  exitProfile?: string;\n  drawSize: number;\n  idPrefix?: string;\n  isMock?: boolean;\n  uuids?: string[];\n  stage: string;\n};\n\nexport function generatePlayoffStructures(\n  params: GeneratePlayoffStructuresArgs\n): {\n  structures?: Structure[];\n  structureName?: string;\n  structureId?: string;\n  matchUps?: MatchUp[];\n  links?: DrawLink[];\n  error?: ErrorType;\n} {\n  const {\n    finishingPositionOffset = 0,\n    addNameBaseToAttributeName,\n    playoffStructureNameBase,\n    finishingPositionNaming,\n    finishingPositionLimit,\n    playoffAttributes,\n    stageSequence = 1,\n    exitProfile = '0',\n    exitProfileLimit,\n    roundOffsetLimit,\n    roundOffset = 0,\n    drawDefinition,\n    staggeredEntry, // not propagated to child structurs\n    sequenceLimit,\n    stage = MAIN,\n    drawSize,\n    idPrefix,\n    isMock,\n    uuids,\n  } = params;\n  const generateStructure =\n    !playoffAttributes || !exitProfileLimit || playoffAttributes?.[exitProfile];\n\n  if (\n    !generateStructure ||\n    drawSize < 2 ||\n    (sequenceLimit && stageSequence > sequenceLimit)\n  )\n    return {};\n\n  const allMatchUps: any[] = [];\n  const structures: Structure[] = [];\n  const links: DrawLink[] = [];\n\n  const matchUpType = params.matchUpType ?? drawDefinition?.matchUpType;\n\n  const finishingPositionsFrom = finishingPositionOffset + 1;\n  const finishingPositionsTo = finishingPositionOffset + drawSize;\n  const finishingPositionRange = `${finishingPositionsFrom}-${finishingPositionsTo}`;\n  const attributeProfile = playoffAttributes?.[exitProfile];\n  const base =\n    (playoffStructureNameBase && `${playoffStructureNameBase} `) || '';\n  const customNaming =\n    playoffAttributes?.[finishingPositionRange] ??\n    finishingPositionNaming?.[finishingPositionRange];\n\n  const structureName =\n    params.structureName ||\n    customNaming?.name ||\n    (attributeProfile?.name &&\n      (addNameBaseToAttributeName\n        ? `${base}${attributeProfile?.name}`\n        : attributeProfile.name)) ||\n    `${base}${finishingPositionRange}`;\n\n  const structureAbbreviation =\n    customNaming?.abbreviation ?? attributeProfile?.abbreviation;\n  const structureId =\n    params.structureId ?? attributeProfile?.structureId ?? uuids?.pop();\n\n  const mainParams = {\n    idPrefix: idPrefix && `${idPrefix}-${structureName}-RP`,\n    finishingPositionOffset,\n    matchUpType,\n    drawSize,\n    isMock,\n    uuids,\n  };\n  const { matchUps } = staggeredEntry\n    ? feedInMatchUps(mainParams) // should only every apply to initial structure\n    : treeMatchUps(mainParams);\n\n  const structure = structureTemplate({\n    structureAbbreviation,\n    stageSequence,\n    structureName,\n    matchUpType,\n    roundOffset,\n    structureId,\n    matchUps,\n    stage,\n  });\n\n  allMatchUps.push(...matchUps);\n  structures.push(structure);\n\n  const rounds = Math.ceil(Math.log(drawSize) / Math.log(2));\n  const roundsToPlayOff = roundOffsetLimit\n    ? Math.min(roundOffsetLimit - roundOffset, rounds)\n    : !finishingPositionLimit || finishingPositionsFrom < finishingPositionLimit\n      ? rounds\n      : 0;\n\n  if (drawSize > 2) {\n    generateRange(1, roundsToPlayOff + 1).forEach((roundNumber) =>\n      generateChildStructures(roundNumber)\n    );\n  }\n\n  return {\n    structureId: structure.structureId,\n    matchUps: allMatchUps,\n    structureName,\n    structures,\n    links,\n    ...SUCCESS,\n  };\n\n  function generateChildStructures(roundNumber) {\n    const playoffDrawPositions = drawSize / Math.pow(2, roundNumber);\n    if (playoffDrawPositions < 2) return;\n\n    const childFinishingPositionOffset =\n      drawSize / Math.pow(2, roundNumber) + finishingPositionOffset;\n    if (\n      finishingPositionLimit &&\n      childFinishingPositionOffset + 1 > finishingPositionLimit\n    )\n      return;\n\n    const {\n      structures: childStructures,\n      structureId: targetStructureId,\n      matchUps: childMatchUps,\n      links: childLinks,\n    } = generatePlayoffStructures({\n      finishingPositionOffset: childFinishingPositionOffset,\n      exitProfile: `${exitProfile}-${roundNumber}`,\n      roundOffset: roundOffset + roundNumber,\n      stageSequence: stageSequence + 1,\n      drawSize: playoffDrawPositions,\n      addNameBaseToAttributeName,\n      playoffStructureNameBase,\n      finishingPositionNaming,\n      finishingPositionLimit,\n      playoffAttributes,\n      exitProfileLimit,\n      roundOffsetLimit,\n      drawDefinition,\n      sequenceLimit,\n      matchUpType,\n      idPrefix,\n      uuids,\n      stage,\n    });\n\n    if (structure.structureId && targetStructureId) {\n      const link = {\n        linkType: LOSER,\n        source: {\n          roundNumber,\n          structureId: structure.structureId,\n        },\n        target: {\n          roundNumber: 1,\n          feedProfile: TOP_DOWN,\n          structureId: targetStructureId,\n        },\n      };\n\n      if (childLinks && structure) childLinks.push(link);\n      if (childLinks?.length) links.push(...childLinks);\n    }\n    if (childStructures?.length) structures.push(...childStructures);\n    if (childMatchUps?.length) allMatchUps.push(...childMatchUps);\n\n    return {\n      structureId: targetStructureId,\n      childLinks,\n      structures,\n    };\n  }\n}\n","import { constantToString } from '../../../../utilities/strings';\nimport structureTemplate from '../../templates/structureTemplate';\nimport { feedInMatchUps } from '../feedInMatchUps';\nimport { treeMatchUps } from './eliminationTree';\n\nimport { DrawLink, Structure } from '../../../../types/tournamentTypes';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport {\n  MAIN,\n  CONSOLATION,\n  LOSER,\n  TOP_DOWN,\n} from '../../../../constants/drawDefinitionConstants';\n\nexport function firstRoundLoserConsolation(params) {\n  const {\n    finishingPositionOffset = 0,\n    playoffAttributes,\n    stageSequence = 1,\n    staggeredEntry,\n    structureName,\n    stage = MAIN,\n    matchUpType,\n    structureId,\n    idPrefix,\n    drawSize,\n    isMock,\n    uuids,\n  } = params;\n\n  const mainParams = {\n    finishingPositionOffset,\n    matchUpType,\n    drawSize,\n    idPrefix,\n    isMock,\n    uuids,\n  };\n  const { matchUps } = staggeredEntry\n    ? feedInMatchUps(mainParams)\n    : treeMatchUps(mainParams);\n\n  const mainStructure = structureTemplate({\n    structureName:\n      structureName || playoffAttributes?.['0']?.name || constantToString(MAIN),\n    structureId: structureId || uuids?.pop(),\n    stageSequence,\n    matchUpType,\n    matchUps,\n    stage,\n  });\n\n  const structures: Structure[] = [mainStructure];\n  const links: DrawLink[] = [];\n\n  if (drawSize > 2) {\n    const consolationDrawPositions = drawSize / 2;\n\n    const { matchUps: consolationMatchUps } = treeMatchUps({\n      finishingPositionOffset:\n        finishingPositionOffset + consolationDrawPositions,\n      idPrefix: idPrefix && `${idPrefix}-c`,\n      drawSize: consolationDrawPositions,\n      matchUpType,\n      isMock,\n    });\n\n    const consolation = constantToString(CONSOLATION);\n    const consolationStructureName =\n      playoffAttributes?.['0-1']?.name ??\n      params.consolationStructureName ??\n      (structureName ? `${structureName} ${consolation}` : consolation);\n\n    const consolationStructure = structureTemplate({\n      structureName: consolationStructureName,\n      matchUps: consolationMatchUps,\n      structureId: uuids?.pop(),\n      stage: CONSOLATION,\n      stageSequence: 1,\n      matchUpType,\n    });\n    structures.push(consolationStructure);\n\n    const link: DrawLink = {\n      linkType: LOSER,\n      source: {\n        roundNumber: 1,\n        structureId: mainStructure.structureId,\n      },\n      target: {\n        roundNumber: 1,\n        feedProfile: TOP_DOWN,\n        structureId: consolationStructure.structureId,\n      },\n    };\n\n    links.push(link);\n  }\n\n  return {\n    ...SUCCESS,\n    structures,\n    links,\n  };\n}\n","import { getDevContext } from '../../../../global/state/globalState';\nimport { generateRange } from '../../../../utilities/arrays';\n\nimport { Structure } from '../../../../types/tournamentTypes';\nimport {\n  BOTTOM_UP,\n  TOP_DOWN,\n  LOSER,\n  FIRST_MATCHUP,\n} from '../../../../constants/drawDefinitionConstants';\n\ntype FeedInLinksArgs = {\n  mainStructure: Structure;\n  consolationStructure;\n  roundOffset?: number;\n  roundsCount: number;\n  feedPolicy?: any;\n  fmlc?: boolean;\n};\nexport function feedInLinks({\n  consolationStructure,\n  roundOffset = 0,\n  mainStructure,\n  roundsCount,\n  feedPolicy,\n  fmlc,\n}: FeedInLinksArgs) {\n  const consolationMatchUps = consolationStructure.matchUps;\n  const roundsFed = consolationMatchUps.reduce((p, matchUp) => {\n    const drawPositions = (matchUp.drawPositions || []).filter(Boolean);\n    return drawPositions.length && !p.includes(matchUp.roundNumber)\n      ? p.concat(matchUp.roundNumber)\n      : p;\n  }, []);\n\n  const roundGroupedOrder = feedPolicy?.roundGroupedOrder || [];\n  const roundFeedProfiles = feedPolicy?.roundFeedProfiles;\n\n  // range excludes final round which is final matchUp\n  return generateRange(1 + roundOffset, roundsCount + 1 + roundOffset)\n    .map((roundNumber) => {\n      const feedProfile =\n        roundFeedProfiles && roundFeedProfiles[roundNumber - 1]\n          ? roundFeedProfiles[roundNumber - 1]\n          : roundNumber % 2\n            ? TOP_DOWN\n            : BOTTOM_UP;\n\n      // after first two rounds of target feed, matchUps are every other round\n      const targetRound =\n        roundNumber - roundOffset <= 2\n          ? roundNumber - roundOffset\n          : (roundNumber - roundOffset - 2) * 2 + 2;\n\n      const link: any = {\n        linkType: LOSER,\n        source: {\n          roundNumber,\n          structureId: mainStructure.structureId,\n        },\n        target: {\n          feedProfile,\n          roundNumber: targetRound,\n          structureId: consolationStructure.structureId,\n        },\n      };\n      const groupedOrder = roundGroupedOrder[roundNumber - 1];\n      if (groupedOrder) link.target.groupedOrder = groupedOrder;\n      if (getDevContext()) {\n        link.source.structureName = mainStructure.structureName;\n        link.target.structureName = consolationStructure.structureName;\n      }\n      if (roundNumber === 2 && fmlc) {\n        link.linkCondition = FIRST_MATCHUP;\n        link.target.feedProfile = TOP_DOWN;\n      }\n      return roundsFed.includes(targetRound) ? link : undefined;\n    })\n    .filter(Boolean);\n}\n","import { constantToString } from '../../../../utilities/strings';\nimport { structureTemplate } from '../../templates/structureTemplate';\nimport { feedInMatchUps } from '../feedInMatchUps';\nimport { treeMatchUps } from './eliminationTree';\nimport { feedInLinks } from '../links/feedInLinks';\n\nimport { DrawLink, Structure } from '../../../../types/tournamentTypes';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport {\n  MAIN,\n  CONSOLATION,\n  PLAY_OFF,\n  LOSER,\n  TOP_DOWN,\n} from '../../../../constants/drawDefinitionConstants';\n\nexport function generateCurtisConsolation(params) {\n  const {\n    playoffStructureNameBase,\n    finishingPositionOffset,\n    stageSequence = 1,\n    playoffAttributes,\n    structureNameMap,\n    staggeredEntry,\n    stage = MAIN,\n    matchUpType,\n    structureId,\n    drawSize,\n    idPrefix,\n    isMock,\n    uuids,\n  } = params;\n\n  const mainParams = {\n    finishingPositionOffset,\n    matchUpType,\n    drawSize,\n    idPrefix,\n    isMock,\n    uuids,\n  };\n  const { matchUps, roundsCount: mainDrawRoundsCount } = staggeredEntry\n    ? feedInMatchUps(mainParams)\n    : treeMatchUps(mainParams);\n  const structureName =\n    params.structureName ??\n    playoffAttributes?.['0']?.name ??\n    constantToString(MAIN);\n  const mainStructure = structureTemplate({\n    structureId: structureId || uuids?.pop(),\n    structureName,\n    stageSequence,\n    matchUpType,\n    matchUps,\n    stage,\n  });\n\n  const structures: Structure[] = [mainStructure];\n  const links: DrawLink[] = [];\n\n  if (drawSize > 2) {\n    const feedRoundOffsets = [0, 2].slice(0, drawSize / 16);\n    const consolationItems = feedRoundOffsets.map((roundOffset, index) => {\n      const stageSequence = index + 1;\n      const { consolationStructure } = consolationFeedStructure({\n        idPrefix: idPrefix && `${idPrefix}-c${index}`,\n        structureId: uuids?.pop(),\n        playoffStructureNameBase,\n        playoffAttributes,\n        structureNameMap,\n        stageSequence,\n        roundOffset,\n        matchUpType,\n        drawSize,\n        isMock,\n        index,\n        uuids,\n      });\n\n      structures.push(consolationStructure);\n\n      const links = feedInLinks({\n        consolationStructure,\n        roundsCount: 2,\n        mainStructure,\n        roundOffset,\n      });\n\n      return { consolationStructure, links };\n    });\n\n    const consolationLinks = consolationItems.map((item) => item.links).flat();\n    links.push(...consolationLinks);\n\n    // only add 3-4 playoff structure\n    // 1. if there is one consolation round, drawSize === 16\n    // 2. if drawSize > 32\n    // when drawSize === 32 then all rounds feed into the two consolation structures\n    if ((drawSize >= 4 && drawSize <= 16) || drawSize > 32) {\n      const { matchUps: playoffMatchUps } = treeMatchUps({\n        idPrefix: idPrefix && `${idPrefix}-p3t4`,\n        finishingPositionOffset: 2,\n        drawSize: 2,\n        matchUpType,\n        isMock,\n      });\n      const defaultName =\n        playoffAttributes?.['3-4']?.name ?? constantToString(PLAY_OFF);\n      const mappedStructureName =\n        structureNameMap?.[defaultName] || defaultName;\n      const structureName = playoffStructureNameBase\n        ? `${playoffStructureNameBase} ${mappedStructureName}`\n        : mappedStructureName;\n\n      const playoffStructure = structureTemplate({\n        structureId: uuids?.pop(),\n        matchUps: playoffMatchUps,\n        stageSequence: 2,\n        stage: PLAY_OFF,\n        structureName,\n        matchUpType,\n      });\n\n      const playoffLink: DrawLink = {\n        linkType: LOSER,\n        source: {\n          roundNumber: mainDrawRoundsCount - 1,\n          structureId: mainStructure.structureId,\n        },\n        target: {\n          structureId: playoffStructure.structureId,\n          feedProfile: TOP_DOWN,\n          roundNumber: 1,\n        },\n      };\n\n      structures.push(playoffStructure);\n      links.push(playoffLink);\n    }\n  }\n\n  return { structures, links, ...SUCCESS };\n}\n\nfunction consolationFeedStructure({\n  playoffStructureNameBase,\n  stageSequence = 1,\n  playoffAttributes,\n  structureNameMap,\n  roundOffset = 0,\n  matchUpType,\n  structureId,\n  idPrefix,\n  drawSize,\n  isMock,\n  index,\n  uuids,\n}) {\n  const consolationDrawPositions = drawSize / (2 * Math.pow(2, roundOffset));\n\n  const { matchUps: consolationMatchUps, roundsCount: consolationRoundsCount } =\n    feedInMatchUps({\n      finishingPositionOffset: consolationDrawPositions,\n      baseDrawSize: consolationDrawPositions,\n      isConsolation: true,\n      feedRounds: 1,\n      matchUpType,\n      idPrefix,\n      isMock,\n      uuids,\n    });\n  const indexedStructureName =\n    (index === 0 && playoffAttributes?.['0-1']?.name) ||\n    (index === 1 && playoffAttributes?.['0-3']?.name);\n  const defaultName =\n    indexedStructureName || `${constantToString(CONSOLATION)} ${index + 1}`;\n  const mappedStructureName = structureNameMap?.[defaultName] || defaultName;\n  const structureName = playoffStructureNameBase\n    ? `${playoffStructureNameBase} ${mappedStructureName}`\n    : mappedStructureName;\n\n  const consolationStructure = structureTemplate({\n    matchUps: consolationMatchUps,\n    stage: CONSOLATION,\n    structureName,\n    stageSequence,\n    matchUpType,\n    structureId,\n  });\n\n  return { consolationStructure, consolationRoundsCount };\n}\n","import { constantToString } from '../../../../utilities/strings';\nimport structureTemplate from '../../templates/structureTemplate';\nimport { feedInMatchUps } from '../feedInMatchUps';\nimport { treeMatchUps } from './eliminationTree';\nimport { feedInLinks } from '../links/feedInLinks';\n\nimport {\n  MAIN,\n  CONSOLATION,\n} from '../../../../constants/drawDefinitionConstants';\nimport { POLICY_TYPE_FEED_IN } from '../../../../constants/policyConstants';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport { DrawLink } from '../../../../types/tournamentTypes';\n\nexport function feedInChampionship(params) {\n  const {\n    finishingPositionOffset,\n    stageSequence = 1,\n    playoffAttributes,\n    policyDefinitions,\n    feedsFromFinal,\n    staggeredEntry,\n    structureName,\n    stage = MAIN,\n    structureId,\n    matchUpType,\n    skipRounds,\n    feedRounds,\n    idPrefix,\n    drawSize,\n    isMock,\n    uuids,\n    fmlc,\n  } = params;\n\n  const feedPolicy =\n    params.feedPolicy || policyDefinitions?.[POLICY_TYPE_FEED_IN];\n\n  const mainParams = {\n    finishingPositionOffset,\n    matchUpType,\n    skipRounds,\n    drawSize,\n    idPrefix,\n    isMock,\n    uuids,\n  };\n  const { matchUps } = staggeredEntry\n    ? feedInMatchUps(mainParams)\n    : treeMatchUps(mainParams);\n\n  const mainStructure = structureTemplate({\n    structureName:\n      structureName || playoffAttributes?.['0']?.name || constantToString(MAIN),\n    structureId: structureId || uuids?.pop(),\n    stageSequence,\n    matchUpType,\n    matchUps,\n    stage,\n  });\n\n  const structures = [mainStructure];\n  const links: DrawLink[] = [];\n\n  const baseDrawSize = drawSize / 2;\n  const { matchUps: consolationMatchUps, roundsCount } = feedInMatchUps({\n    finishingPositionOffset: baseDrawSize,\n    idPrefix: idPrefix && `${idPrefix}-c`,\n    isConsolation: true,\n    feedsFromFinal,\n    baseDrawSize,\n    matchUpType,\n    feedRounds,\n    skipRounds,\n    isMock,\n    uuids,\n    fmlc,\n  });\n\n  if (drawSize > 2) {\n    const name =\n      playoffAttributes?.['0-1']?.name ?? constantToString(CONSOLATION);\n    const structureName = params.playoffStructureNameBase\n      ? `${params.playoffStructureNameBase} ${name}`\n      : name;\n\n    const consolationStructure = structureTemplate({\n      matchUps: consolationMatchUps,\n      structureId: uuids?.pop(),\n      stage: CONSOLATION,\n      stageSequence: 1,\n      structureName,\n      matchUpType,\n    });\n    structures.push(consolationStructure);\n\n    const feedLinks = feedInLinks({\n      consolationStructure,\n      mainStructure,\n      roundsCount,\n      feedPolicy,\n      fmlc,\n    });\n\n    links.push(...feedLinks);\n  }\n\n  return {\n    ...SUCCESS,\n    structures,\n    links,\n  };\n}\n","import { getPositionRangeMap } from '../../../../mutate/drawDefinitions/structureGovernor/getPositionRangeMap';\nimport { ResultType, decorateResult } from '../../../../global/functions/decorateResult';\nimport { structureSort } from '../../../../functions/sorters/structureSort';\nimport { generatePlayoffStructures } from '../drawTypes/playoffStructures';\nimport { firstRoundLoserConsolation } from './firstRoundLoserConsolation';\nimport structureTemplate from '../../templates/structureTemplate';\nimport { generateCurtisConsolation } from './curtisConsolation';\nimport { generateRoundRobin } from './roundRobin/roundRobin';\nimport { numericSort } from '../../../../utilities/sorting';\nimport { nextPowerOf2 } from '../../../../utilities/math';\nimport { feedInChampionship } from './feedInChamp';\nimport { treeMatchUps } from './eliminationTree';\n\nimport { INVALID_VALUES } from '../../../../constants/errorConditionConstants';\nimport { POLICY_TYPE_FEED_IN } from '../../../../constants/policyConstants';\nimport { DrawLink, Structure } from '../../../../types/tournamentTypes';\nimport { WIN_RATIO } from '../../../../constants/statsConstants';\nimport {\n  AD_HOC,\n  COMPASS,\n  COMPASS_ATTRIBUTES,\n  CURTIS_CONSOLATION,\n  DRAW,\n  FEED_IN_CHAMPIONSHIP,\n  FEED_IN_CHAMPIONSHIP_TO_QF,\n  FEED_IN_CHAMPIONSHIP_TO_R16,\n  FEED_IN_CHAMPIONSHIP_TO_SF,\n  FIRST_MATCH_LOSER_CONSOLATION,\n  FIRST_ROUND_LOSER_CONSOLATION,\n  MODIFIED_FEED_IN_CHAMPIONSHIP,\n  OLYMPIC,\n  OLYMPIC_ATTRIBUTES,\n  PLAY_OFF,\n  POSITION,\n  ROUND_ROBIN,\n  SINGLE_ELIMINATION,\n} from '../../../../constants/drawDefinitionConstants';\n\nexport function processPlayoffGroups({\n  requireSequential = true,\n  playoffMatchUpFormat,\n  playoffAttributes,\n  sourceStructureId,\n  policyDefinitions,\n  stageSequence,\n  drawDefinition,\n  playoffGroups,\n  matchUpType,\n  feedPolicy,\n  groupCount,\n  idPrefix,\n  isMock,\n  uuids,\n}): ResultType & {\n  finishingPositionTargets?: any;\n  structures?: Structure[];\n  positionRangeMap?: any;\n  links?: DrawLink[];\n} {\n  feedPolicy = feedPolicy || policyDefinitions?.[POLICY_TYPE_FEED_IN];\n  const stack = 'processPlayoffGroups';\n\n  let finishingPositionOffset = 0;\n  const finishingPositionTargets: any[] = [];\n  const structures: any[] = [];\n  const links: any[] = [];\n\n  const { error, positionRangeMap } = getPositionRangeMap({\n    structureId: sourceStructureId,\n    drawDefinition,\n    playoffGroups,\n  });\n\n  if (error) return decorateResult({ result: { error }, stack });\n\n  const validFinishingPositions =\n    !positionRangeMap ||\n    playoffGroups?.every((profile) => {\n      const { finishingPositions = [] } = profile;\n      if (!finishingPositions.length) return false;\n\n      const sequential = [...finishingPositions]\n        .sort(numericSort)\n        .map((pos, i) => (finishingPositions[i + 1] || pos) - pos)\n        .every((val) => val < 2);\n\n      return (!requireSequential || sequential) && finishingPositions.every((position) => positionRangeMap[position]);\n    });\n\n  if (!validFinishingPositions) {\n    return decorateResult({\n      context: { validFinishingPositions: Object.values(positionRangeMap) },\n      result: { error: INVALID_VALUES },\n      stack,\n    });\n  }\n\n  for (const playoffGroup of playoffGroups) {\n    const finishingPositions = playoffGroup.finishingPositions;\n    const positionsPlayedOff =\n      positionRangeMap && finishingPositions.map((p) => positionRangeMap[p]?.finishingPositions).flat();\n\n    const participantsInDraw = groupCount * finishingPositions.length;\n    const drawSize = nextPowerOf2(participantsInDraw);\n\n    const playoffDrawType = (drawSize === 2 && SINGLE_ELIMINATION) || playoffGroup.drawType || SINGLE_ELIMINATION;\n\n    if (positionsPlayedOff) {\n      finishingPositionOffset = Math.min(...positionsPlayedOff) - 1;\n    }\n\n    const finishingPositionRange =\n      positionsPlayedOff && `${Math.min(...positionsPlayedOff)}-${Math.max(...positionsPlayedOff)}`;\n\n    const structureName =\n      playoffGroup.structureName ||\n      (finishingPositionRange && playoffGroup.playoffAttributes?.[finishingPositionRange]?.name) ||\n      playoffGroup.playoffAttributes?.['0']?.name;\n\n    const playoffGroupParams = {\n      addNameBaseToAttributeName: playoffGroup.addNameBaseToAttributeName,\n      playoffStructureNameBase: playoffGroup.playoffStructureNameBase,\n      finishingPositionNaming: playoffGroup.finishingPositionNaming,\n      finishingPositionLimit: playoffGroup.finishingPositionLimit,\n      structureId: playoffGroup.structureId ?? uuids?.pop(),\n      playoffAttributes: playoffGroup.playoffAttributes,\n      structureNameMap: playoffGroup.structureNameMap,\n      sequenceLimit: playoffGroup.sequenceLimit,\n      structureName,\n    };\n\n    const params = {\n      ...playoffGroupParams,\n      idPrefix: idPrefix && `${idPrefix}-po`,\n      appliedPolicies: policyDefinitions,\n      finishingPositionOffset,\n      stage: PLAY_OFF,\n      stageSequence,\n      matchUpType,\n      drawSize,\n      isMock,\n      uuids,\n    };\n\n    const updateStructureAndLinks = ({ playoffStructures, playoffLinks }) => {\n      const [playoffStructure] = playoffStructures;\n      const playoffLink = generatePlayoffLink({\n        playoffStructureId: playoffStructure.structureId,\n        finishingPositions,\n        sourceStructureId,\n      });\n\n      links.push(playoffLink);\n      links.push(...playoffLinks);\n      structures.push(...playoffStructures);\n      finishingPositionTargets.push({\n        structureId: playoffStructure.structureId,\n        finishingPositions,\n      });\n      // update *after* value has been passed into current playoff structure generator\n      finishingPositionOffset += participantsInDraw;\n    };\n\n    if (playoffDrawType === SINGLE_ELIMINATION) {\n      const { matchUps } = treeMatchUps({\n        finishingPositionLimit: finishingPositionOffset + participantsInDraw,\n        idPrefix: idPrefix && `${idPrefix}-po`,\n        finishingPositionOffset,\n        matchUpType,\n        drawSize,\n        isMock,\n        uuids,\n      });\n\n      const playoffStructure = structureTemplate({\n        structureId: playoffGroup.structureId ?? uuids?.pop(),\n        matchUpFormat: playoffMatchUpFormat,\n        stage: PLAY_OFF,\n        structureName,\n        stageSequence,\n        matchUps,\n      });\n      structures.push(playoffStructure);\n\n      const playoffLink = generatePlayoffLink({\n        playoffStructureId: playoffStructure.structureId,\n        finishingPositions,\n        sourceStructureId,\n      });\n      links.push(playoffLink);\n\n      // update *after* value has been passed into current playoff structure generator\n      finishingPositionOffset += participantsInDraw;\n\n      finishingPositionTargets.push({\n        structureId: playoffStructure.structureId,\n        finishingPositions,\n      });\n    } else if ([COMPASS, OLYMPIC, PLAY_OFF].includes(playoffDrawType)) {\n      const params = {\n        playoffAttributes: playoffGroup.playoffAttributes ?? playoffAttributes,\n        playoffStructureNameBase: playoffGroup.playoffStructureNameBase,\n        structureId: playoffGroup.structureId ?? uuids?.pop(),\n        structureName: playoffGroup.structureName,\n        idPrefix: idPrefix && `${idPrefix}-po`,\n        addNameBaseToAttributeName: true,\n        finishingPositionOffset,\n        stage: PLAY_OFF,\n        roundOffset: 0,\n        stageSequence,\n        drawSize,\n        isMock,\n        uuids,\n      };\n\n      if (playoffDrawType === COMPASS) {\n        Object.assign(params, {\n          playoffAttributes: playoffGroup?.playoffAttributes ?? playoffAttributes ?? COMPASS_ATTRIBUTES,\n          roundOffsetLimit: 3,\n        });\n      } else if (playoffDrawType === OLYMPIC) {\n        Object.assign(params, {\n          playoffAttributes: playoffGroup?.playoffAttributes ?? playoffAttributes ?? OLYMPIC_ATTRIBUTES,\n          roundOffsetLimit: 2,\n        });\n      }\n\n      const result = generatePlayoffStructures(params);\n      if (result.error) return result;\n\n      if (result.links?.length) links.push(...result.links);\n      if (result.structures?.length) structures.push(...result.structures);\n      structures.sort(structureSort);\n\n      if (result.structureId) {\n        const playoffLink = generatePlayoffLink({\n          playoffStructureId: result.structureId,\n          finishingPositions,\n          sourceStructureId,\n        });\n        links.push(playoffLink);\n        finishingPositionTargets.push({\n          structureId: result.structureId,\n          finishingPositions,\n        });\n      }\n      // update *after* value has been passed into current playoff structure generator\n      finishingPositionOffset += participantsInDraw;\n    } else if (\n      [\n        FIRST_MATCH_LOSER_CONSOLATION,\n        FEED_IN_CHAMPIONSHIP,\n        FEED_IN_CHAMPIONSHIP_TO_R16,\n        FEED_IN_CHAMPIONSHIP_TO_QF,\n        FEED_IN_CHAMPIONSHIP_TO_SF,\n        MODIFIED_FEED_IN_CHAMPIONSHIP,\n      ].includes(playoffDrawType)\n    ) {\n      const uuidsFMLC = [uuids?.pop(), uuids?.pop()];\n      const params = {\n        playoffStructureNameBase: playoffGroup.playoffStructureNameBase,\n        structureId: playoffGroup.structureId ?? uuids?.pop(),\n        playoffAttributes: playoffGroup.playoffAttributes,\n        idPrefix: idPrefix && `${idPrefix}-po`,\n        finishingPositionOffset,\n        uuids: uuidsFMLC,\n        stage: PLAY_OFF,\n        structureName,\n        matchUpType,\n        feedPolicy,\n        drawSize,\n        isMock,\n      };\n\n      const additionalAttributes = {\n        [FIRST_MATCH_LOSER_CONSOLATION]: { fmlc: true, feedRounds: 1 },\n        [MODIFIED_FEED_IN_CHAMPIONSHIP]: { feedRounds: 1 },\n        [FEED_IN_CHAMPIONSHIP_TO_R16]: { feedsFromFinal: 3 },\n        [FEED_IN_CHAMPIONSHIP_TO_QF]: { feedsFromFinal: 2 },\n        [FEED_IN_CHAMPIONSHIP_TO_SF]: { feedsFromFinal: 1 },\n      };\n\n      Object.assign(params, additionalAttributes[playoffDrawType] || {});\n\n      const { structures: champitionShipStructures, links: feedInLinks } = feedInChampionship(params);\n      const [playoffStructure] = champitionShipStructures;\n      const playoffLink = generatePlayoffLink({\n        playoffStructureId: playoffStructure.structureId,\n        finishingPositions,\n        sourceStructureId,\n      });\n\n      links.push(playoffLink);\n      links.push(...feedInLinks);\n      structures.push(...champitionShipStructures);\n      finishingPositionTargets.push({\n        structureId: playoffStructure.structureId,\n        finishingPositions,\n      });\n      // update *after* value has been passed into current playoff structure generator\n      finishingPositionOffset += participantsInDraw;\n    } else if ([ROUND_ROBIN].includes(playoffDrawType)) {\n      const { structures: playoffStructures, links: playoffLinks } = generateRoundRobin({\n        ...params,\n        structureOptions: playoffGroup.structureOptions || { groupSize: 4 },\n      });\n      updateStructureAndLinks({ playoffStructures, playoffLinks });\n    } else if ([FIRST_ROUND_LOSER_CONSOLATION].includes(playoffDrawType)) {\n      const { structures: playoffStructures, links: playoffLinks } = firstRoundLoserConsolation(params);\n      updateStructureAndLinks({ playoffStructures, playoffLinks });\n    } else if ([CURTIS_CONSOLATION].includes(playoffDrawType)) {\n      const { structures: playoffStructures, links: playoffLinks } = generateCurtisConsolation(params);\n      updateStructureAndLinks({ playoffStructures, playoffLinks });\n    } else if ([AD_HOC].includes(playoffDrawType)) {\n      const structure = structureTemplate({\n        structureId: playoffGroup.structureId ?? uuids?.pop(),\n        structureName: playoffGroup.structureName,\n        finishingPosition: WIN_RATIO,\n        stage: PLAY_OFF,\n        stageSequence,\n        matchUps: [],\n      });\n      updateStructureAndLinks({\n        playoffStructures: [structure],\n        playoffLinks: [],\n      });\n    }\n  }\n\n  return { finishingPositionTargets, positionRangeMap, structures, links };\n}\n\nfunction generatePlayoffLink({ playoffStructureId, finishingPositions, sourceStructureId }) {\n  return {\n    linkType: POSITION,\n    source: {\n      structureId: sourceStructureId,\n      finishingPositions,\n    },\n    target: {\n      structureId: playoffStructureId,\n      feedProfile: DRAW,\n      roundNumber: 1,\n    },\n  };\n}\n","import { getAvailablePlayoffProfiles } from './getAvailablePlayoffProfiles';\n\nimport {\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n} from '../../../constants/errorConditionConstants';\n\nexport function getPositionRangeMap({\n  playoffGroups,\n  drawDefinition,\n  structureId,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (typeof structureId !== 'string' || !Array.isArray(playoffGroups)) {\n    return { error: INVALID_VALUES };\n  }\n\n  const playoffGroupFinishingPostions = playoffGroups\n    .map(({ finishingPositions }) => finishingPositions)\n    .flat();\n\n  const availablePlayoffProfiles = getAvailablePlayoffProfiles({\n    drawDefinition,\n    structureId,\n  });\n\n  const playoffFinishingPositionRanges =\n    availablePlayoffProfiles.playoffFinishingPositionRanges?.filter((r) =>\n      playoffGroupFinishingPostions.includes(r.finishingPosition)\n    );\n\n  const positionRangeMap = playoffFinishingPositionRanges?.reduce(\n    (positionMap, positionDetail) => {\n      positionMap[positionDetail.finishingPosition] = positionDetail;\n      return positionMap;\n    },\n    {}\n  );\n\n  return { positionRangeMap };\n}\n","import { getAvailablePlayoffProfiles } from '../../../mutate/drawDefinitions/structureGovernor/getAvailablePlayoffProfiles';\nimport { assignDrawPositionBye } from '../../../mutate/matchUps/drawPositions/assignDrawPositionBye';\nimport { getSourceRounds } from '../../../mutate/drawDefinitions/structureGovernor/getSourceRounds';\nimport { generateAndPopulateRRplayoffStructures } from './generateAndPopulateRRplayoffStructures';\nimport { directParticipants } from '../../../mutate/matchUps/drawPositions/directParticipants';\nimport { resolveTieFormat } from '../../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { positionTargets } from '../../../mutate/matchUps/drawPositions/positionTargets';\nimport { checkMatchUpIsComplete } from '../../../query/matchUp/checkMatchUpIsComplete';\nimport { NamingEntry, generatePlayoffStructures } from './drawTypes/playoffStructures';\nimport { ResultType, decorateResult } from '../../../global/functions/decorateResult';\nimport { addGoesTo } from '../../../mutate/drawDefinitions/matchUpGovernor/addGoesTo';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { getMatchUpId } from '../../../global/functions/extractors';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { ensureInt } from '../../../utilities/ensureInt';\nimport { generateTieMatchUps } from './tieMatchUps';\n\nimport { DrawDefinition, DrawLink, Event, Structure, Tournament } from '../../../types/tournamentTypes';\nimport { CONTAINER, LOSER, PLAY_OFF, TOP_DOWN } from '../../../constants/drawDefinitionConstants';\nimport { BYE } from '../../../constants/matchUpStatusConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { RoundProfile } from '../../../types/factoryTypes';\nimport { TEAM } from '../../../constants/matchUpTypes';\nimport {\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n  STRUCTURE_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\n\ntype GenerateAndPopulateArgs = {\n  addNameBaseToAttributeName?: boolean;\n  finishingPositionNaming?: NamingEntry;\n  playoffStructureNameBase?: string;\n  playoffAttributes?: NamingEntry;\n  finishingPositionLimit?: number;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  roundProfiles?: RoundProfile[];\n  playoffPositions?: number[];\n  roundOffsetLimit?: number;\n  exitProfileLimit?: boolean;\n  roundNumbers?: number[];\n  structureId: string;\n  idPrefix?: string;\n  isMock?: boolean;\n  uuids?: string[];\n  event?: Event;\n};\nexport function generateAndPopulatePlayoffStructures(params: GenerateAndPopulateArgs): ResultType & {\n  drawDefinition?: DrawDefinition;\n  matchUpModifications?: any[];\n  structures?: Structure[];\n  links?: DrawLink[];\n  success?: boolean;\n} {\n  const stack = 'genPlayoffStructure';\n  if (!params.drawDefinition)\n    return decorateResult({\n      result: { error: MISSING_DRAW_DEFINITION },\n      stack,\n    });\n\n  const availabilityResult = getAvailablePlayoffProfiles(params);\n  if (availabilityResult.error) {\n    return decorateResult({ result: availabilityResult, stack });\n  }\n\n  const {\n    structureId: sourceStructureId,\n    addNameBaseToAttributeName,\n    playoffStructureNameBase,\n    finishingPositionNaming,\n    finishingPositionLimit,\n    playoffAttributes,\n    playoffPositions,\n    roundOffsetLimit,\n    tournamentRecord,\n    exitProfileLimit,\n    roundProfiles,\n    roundNumbers,\n    idPrefix,\n    isMock,\n    event,\n    uuids,\n  } = params;\n\n  // The goal here is to return { structures, links } and not modify existing drawDefinition\n  // However, a copy of the drawDefinition needs to have the structures attached in order to\n  // populate the newly created structures with participants which should advance into them\n  const drawDefinition = makeDeepCopy(params.drawDefinition, false, true);\n\n  const { structure } = findStructure({\n    structureId: sourceStructureId,\n    drawDefinition,\n  });\n\n  if (!structure) return decorateResult({ result: { error: STRUCTURE_NOT_FOUND }, stack });\n\n  if (structure.structureType === CONTAINER || structure.structures) {\n    return generateAndPopulateRRplayoffStructures({\n      sourceStructureId: structure.structureId,\n      ...params,\n      ...availabilityResult,\n      drawDefinition, // order is important!\n    });\n  }\n\n  const { playoffRoundsRanges: availablePlayoffRoundsRanges, playoffRounds: availablePlayoffRounds } =\n    availabilityResult;\n\n  const {\n    playoffPositionsReturned,\n    error: sourceRoundsError,\n    playoffSourceRounds,\n    playoffRoundsRanges,\n  } = getSourceRounds(params);\n\n  if (sourceRoundsError) {\n    return decorateResult({ result: { error: sourceRoundsError }, stack });\n  }\n\n  const roundProfile = roundProfiles?.length && Object.assign({}, ...roundProfiles);\n\n  const targetRoundNumbers =\n    roundNumbers || (typeof roundProfiles === 'object' && roundProfiles.map((p) => Object.keys(p)).flat());\n\n  const validRoundNumbers =\n    Array.isArray(targetRoundNumbers) && targetRoundNumbers.map((p) => !isNaN(p) && ensureInt(p)).filter(Boolean);\n\n  if (validRoundNumbers) {\n    if (!Array.isArray(validRoundNumbers))\n      return decorateResult({\n        result: { error: INVALID_VALUES },\n        context: { validRoundNumbers },\n        stack,\n      });\n\n    validRoundNumbers.forEach((roundNumber) => {\n      if (!availablePlayoffRounds?.includes(roundNumber)) {\n        return decorateResult({\n          result: { error: INVALID_VALUES },\n          context: { roundNumber },\n          stack,\n        });\n      }\n      return undefined;\n    });\n  }\n\n  if (playoffPositions) {\n    playoffPositions.forEach((playoffPosition) => {\n      if (!playoffPositionsReturned?.includes(playoffPosition)) {\n        return decorateResult({\n          result: { error: INVALID_VALUES },\n          context: { playoffPosition },\n          stack,\n        });\n      }\n      return undefined;\n    });\n  }\n\n  const sourceRounds = validRoundNumbers || playoffSourceRounds;\n  const roundsRanges = validRoundNumbers ? availablePlayoffRoundsRanges : playoffRoundsRanges;\n\n  const newStructures: Structure[] = [];\n  const newLinks: DrawLink[] = [];\n\n  for (const roundNumber of sourceRounds ?? []) {\n    const roundInfo = roundsRanges?.find((roundInfo) => roundInfo.roundNumber === roundNumber);\n    if (!roundInfo)\n      return decorateResult({\n        result: { error: INVALID_VALUES },\n        context: { roundNumber },\n        stack,\n      });\n    const drawSize = roundInfo.finishingPositions.length;\n    const finishingPositionOffset = Math.min(...roundInfo.finishingPositions) - 1;\n\n    const stageSequence = 2;\n    const sequenceLimit = roundNumber && roundProfile?.[roundNumber] && stageSequence + roundProfile[roundNumber] - 1;\n\n    const result = generatePlayoffStructures({\n      exitProfile: `0-${roundNumber}`,\n      addNameBaseToAttributeName,\n      playoffStructureNameBase,\n      finishingPositionOffset,\n      playoffAttributes,\n      exitProfileLimit,\n      stage: PLAY_OFF,\n      roundOffset: 0,\n      drawDefinition,\n      sequenceLimit,\n      stageSequence,\n      drawSize,\n      idPrefix,\n      isMock,\n      uuids,\n\n      finishingPositionNaming,\n      finishingPositionLimit,\n      roundOffsetLimit,\n    });\n    if (result.error) return decorateResult({ result, stack });\n\n    const { structures, links } = result;\n\n    if (structures?.length) newStructures.push(...structures);\n    if (links?.length) newLinks.push(...links);\n\n    if (result.structureId && roundNumber) {\n      const link: DrawLink = {\n        linkType: LOSER,\n        source: {\n          structureId: sourceStructureId,\n          roundNumber,\n        },\n        target: {\n          structureId: result.structureId,\n          feedProfile: TOP_DOWN,\n          roundNumber: 1,\n        },\n      };\n\n      newLinks.push(link);\n    }\n  }\n\n  if (!newStructures.length)\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      info: 'No structures generated',\n      stack,\n    });\n\n  drawDefinition.structures.push(...newStructures);\n  drawDefinition.links.push(...newLinks);\n\n  const { matchUps: inContextDrawMatchUps, matchUpsMap } = getAllDrawMatchUps({\n    inContext: true,\n    drawDefinition,\n  });\n\n  const newStructureIds = newStructures.map(({ structureId }) => structureId);\n  const addedMatchUpIds = inContextDrawMatchUps\n    ?.filter(({ structureId }) => newStructureIds.includes(structureId))\n    .map(getMatchUpId);\n\n  const addedMatchUps = matchUpsMap?.drawMatchUps?.filter(({ matchUpId }) => addedMatchUpIds?.includes(matchUpId));\n\n  if (addedMatchUps?.length) {\n    const tieFormat = resolveTieFormat({ drawDefinition, event })?.tieFormat;\n\n    if (tieFormat) {\n      addedMatchUps.forEach((matchUp) => {\n        const { tieMatchUps } = generateTieMatchUps({ matchUp, tieFormat, isMock });\n        Object.assign(matchUp, { tieMatchUps, matchUpType: TEAM });\n      });\n    }\n  }\n\n  // now advance any players from completed matchUps into the newly added structures\n  const completedMatchUps = inContextDrawMatchUps?.filter(\n    (matchUp) => checkMatchUpIsComplete({ matchUp }) && matchUp.structureId === sourceStructureId,\n  );\n\n  completedMatchUps?.forEach((matchUp) => {\n    const { matchUpId, score, winningSide } = matchUp;\n    const targetData = positionTargets({\n      inContextDrawMatchUps,\n      drawDefinition,\n      matchUpId,\n    });\n    const result = directParticipants({\n      inContextDrawMatchUps,\n      tournamentRecord,\n      drawDefinition,\n      matchUpsMap,\n      winningSide,\n      targetData,\n      matchUpId,\n      structure,\n      matchUp,\n      score,\n      event,\n    });\n    if (result.error) console.log(result.error);\n  });\n\n  const byeMatchUps = inContextDrawMatchUps?.filter(\n    (matchUp) => matchUp.matchUpStatus === BYE && matchUp.structureId === sourceStructureId,\n  );\n\n  byeMatchUps?.forEach((matchUp) => {\n    const { matchUpId } = matchUp;\n    const targetData = positionTargets({\n      inContextDrawMatchUps,\n      drawDefinition,\n      matchUpId,\n    });\n    const {\n      targetLinks: { loserTargetLink },\n      targetMatchUps: {\n        loserMatchUpDrawPositionIndex, // only present when positionTargets found without loserMatchUpId\n        loserMatchUp,\n      },\n    } = targetData;\n\n    if (loserTargetLink && loserMatchUp) {\n      const targetStructureId = loserTargetLink.target.structureId;\n      const targetDrawPosition = loserMatchUp.drawPositions[loserMatchUpDrawPositionIndex];\n\n      const result = assignDrawPositionBye({\n        drawPosition: targetDrawPosition,\n        structureId: targetStructureId,\n        tournamentRecord,\n        drawDefinition,\n        event,\n      });\n      if (result.error) console.log(result.error);\n    }\n  });\n\n  // the matchUps in the source structure must have goesTo details added\n  const matchUpModifications: any[] = [];\n  const goesToMap = addGoesTo({\n    inContextDrawMatchUps,\n    drawDefinition,\n    matchUpsMap,\n  }).goesToMap;\n\n  const { structure: sourceStructure } = findStructure({\n    drawDefinition: params.drawDefinition,\n    structureId: sourceStructureId,\n  });\n\n  const { matchUps: sourceStructureMatchUps } = getAllStructureMatchUps({\n    structure: sourceStructure,\n  });\n\n  sourceStructureMatchUps.forEach((matchUp) => {\n    const loserMatchUpId = goesToMap?.loserMatchUpIds[matchUp.matchUpId];\n    if (loserMatchUpId && matchUp.loserMatchUpId !== loserMatchUpId) {\n      matchUp.loserMatchUpId = loserMatchUpId;\n      const modification = {\n        tournamentId: tournamentRecord?.tournamentId,\n        eventId: params.event?.eventId,\n        context: stack,\n        matchUp,\n      };\n      matchUpModifications.push(modification);\n    }\n    const winnerMatchUpId = goesToMap?.winnerMatchUpIds[matchUp.matchUpId];\n    if (winnerMatchUpId && matchUp.winnerMatchUpId !== winnerMatchUpId) {\n      matchUp.winnerMatchUpId = winnerMatchUpId;\n      const modification = {\n        tournamentId: tournamentRecord?.tournamentId,\n        eventId: params.event?.eventId,\n        context: stack,\n        matchUp,\n      };\n      matchUpModifications.push(modification);\n    }\n  });\n\n  return {\n    structures: newStructures,\n    matchUpModifications,\n    links: newLinks,\n    drawDefinition,\n    ...SUCCESS,\n  };\n}\n","import { automatedPlayoffPositioning } from '../../../mutate/drawDefinitions/automatedPlayoffPositioning';\nimport { resolveTieFormat } from '../../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { processPlayoffGroups } from './drawTypes/processPlayoffGroups';\nimport { getMatchUpId } from '../../../global/functions/extractors';\nimport { findExtension } from '../../../acquire/findExtension';\nimport { generateTieMatchUps } from './tieMatchUps';\n\nimport { INCOMPLETE_SOURCE_STRUCTURE, MISSING_VALUE } from '../../../constants/errorConditionConstants';\nimport { TEAM_MATCHUP } from '../../../constants/matchUpTypes';\nimport { TALLY } from '../../../constants/extensionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\nexport function generateAndPopulateRRplayoffStructures(params) {\n  const stack = 'generateAndPopulateRRplayoffStructures';\n  if (!params.playoffGroups) {\n    return decorateResult({\n      result: { error: MISSING_VALUE },\n      info: 'playoffGroups required',\n      stack,\n    });\n  }\n  const {\n    sourceStructureId,\n    requireSequential,\n    tournamentRecord,\n    drawDefinition,\n    playoffGroups,\n    groupCount,\n    groupSize,\n    event,\n  } = params;\n\n  const {\n    structures: playoffStructures = [],\n    links: playoffLinks = [],\n    finishingPositionTargets,\n    positionRangeMap,\n    error,\n  } = processPlayoffGroups({\n    requireSequential,\n    sourceStructureId,\n    playoffGroups,\n    groupCount,\n    groupSize,\n    ...params,\n  });\n\n  if (error) return { error };\n\n  const positionsPlayedOff = finishingPositionTargets\n    ?.map(({ finishingPositions }) => finishingPositions)\n    .flat()\n    .map((finishingPosition) => positionRangeMap[finishingPosition].finishingPositions)\n    .flat();\n\n  drawDefinition.structures.push(...playoffStructures);\n  drawDefinition.links.push(...playoffLinks);\n\n  const { matchUps: inContextDrawMatchUps, matchUpsMap } = getAllDrawMatchUps({\n    inContext: true,\n    drawDefinition,\n  });\n\n  const newStructureIds = playoffStructures.map(({ structureId }) => structureId);\n  const addedMatchUpIds = inContextDrawMatchUps\n    ?.filter(({ structureId }) => newStructureIds.includes(structureId))\n    .map(getMatchUpId);\n\n  const addedMatchUps = matchUpsMap?.drawMatchUps?.filter(({ matchUpId }) => addedMatchUpIds?.includes(matchUpId));\n\n  if (addedMatchUps?.length) {\n    const tieFormat = resolveTieFormat({ drawDefinition, event })?.tieFormat;\n\n    if (tieFormat) {\n      addedMatchUps.forEach((matchUp) => {\n        const { tieMatchUps } = generateTieMatchUps({\n          isMock: params.isMock,\n          tieFormat,\n          matchUp,\n        });\n        Object.assign(matchUp, { tieMatchUps, matchUpType: TEAM_MATCHUP });\n      });\n    }\n  }\n\n  // TODO: determine participants that are present in each playoffGroup.finishingPositions\n  // OPTIONALLY: populate positionAssignments for newly generated structures\n\n  const { positionAssignments } = getPositionAssignments({\n    structureId: sourceStructureId,\n    drawDefinition,\n  });\n  const finishingPositionParticipantIds = {};\n  positionAssignments?.forEach((assignment) => {\n    const result = findExtension({\n      element: assignment,\n      name: TALLY,\n    });\n    const participantResult = result?.extension?.value;\n    const groupOrder = participantResult?.groupOrder;\n    if (groupOrder) {\n      if (!finishingPositionParticipantIds[groupOrder]) finishingPositionParticipantIds[groupOrder] = [];\n      finishingPositionParticipantIds[groupOrder].push(assignment.participantId);\n    }\n  });\n\n  /*\n   *finishingPositionTargets.forEach((target) => {\n   *  const { finishingPositions, structureId } = target;\n   *  const participantIds = finishingPositions\n   *    .flatMap((position) => finishingPositionParticipantIds[position] || [])\n   *    .sort();\n   *  console.log({ structureId, participantIds });\n   *  const stageEntries = getStageEntries({\n   *    drawDefinition,\n   *    structureId,\n   *    stage: 'PLAY_OFF',\n   *  });\n   *  console.log(stageEntries.map((p) => p.participantId).sort());\n   *});\n   */\n\n  const result = automatedPlayoffPositioning({\n    provisionalPositioning: params.provisionalPositioning,\n    structureId: sourceStructureId,\n    applyPositioning: true,\n    event: params.event,\n    tournamentRecord,\n    drawDefinition,\n  });\n\n  // attempt automated positioning but fail silently if source structure is incomplete\n  if (result.error && result.error?.code !== INCOMPLETE_SOURCE_STRUCTURE.code) {\n    return decorateResult({ result, stack });\n  }\n\n  return {\n    structures: playoffStructures,\n    links: playoffLinks,\n    positionsPlayedOff,\n    drawDefinition,\n    ...SUCCESS,\n  };\n}\n","import { getAllStructureMatchUps } from '../../query/matchUps/getAllStructureMatchUps';\nimport { xa } from '../../utilities/objects';\nimport { addGoesTo } from './matchUpGovernor/addGoesTo';\nimport { addTimeItem } from '../timeItems/addTimeItem';\nimport { addMatchUpsNotice, modifyDrawNotice, modifyMatchUpNotice } from '../notifications/drawNotifications';\nimport { ResultType, decorateResult } from '../../global/functions/decorateResult';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { EXISTING_STRUCTURE, INVALID_VALUES, MISSING_DRAW_DEFINITION } from '../../constants/errorConditionConstants';\nimport { DrawDefinition, DrawLink, Event, Structure, Tournament } from '../../types/tournamentTypes';\n\nexport function attachConsolationStructures(params) {\n  return attachStructures({\n    ...params,\n    itemType: 'attachConsolationStructures',\n  });\n}\n\nexport function attachPlayoffStructures(params) {\n  return attachStructures({ ...params, itemType: 'attachPlayoffStructures' });\n}\n\ntype AttachStructuresArgs = {\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpModifications?: any[];\n  structures: Structure[];\n  links?: DrawLink[];\n  itemType?: string;\n  event?: Event;\n};\nexport function attachStructures({\n  itemType = 'attachStructures',\n  matchUpModifications,\n  tournamentRecord,\n  drawDefinition,\n  structures,\n  links = [],\n  event,\n}: AttachStructuresArgs): ResultType & { addedStructureIds?: string[] } {\n  const stack = 'attachStructures';\n\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!Array.isArray(structures) || !Array.isArray(links))\n    return decorateResult({ result: { error: INVALID_VALUES }, stack });\n\n  const linkHash = (link) =>\n    [\n      link.source.structureId,\n      link.source.roundNumber || link.source.finishingPositions?.join('|'),\n      link.target.roundNumber,\n    ].join('|');\n\n  const existingLinkHashes = drawDefinition.links?.map(linkHash);\n\n  const duplicateLink = links.some((link) => {\n    const hash = linkHash(link);\n    return existingLinkHashes?.includes(hash);\n  });\n\n  if (duplicateLink)\n    return decorateResult({\n      result: { error: EXISTING_STRUCTURE },\n      info: 'playoff structure exists',\n      stack,\n    });\n\n  // TODO: ensure that all links are valid and reference structures that are/will be included in the drawDefinition\n  if (links.length) drawDefinition.links?.push(...links);\n\n  const generatedStructureIds = structures.map(({ structureId }) => structureId);\n  const existingStructureIds = drawDefinition.structures?.map(({ structureId }) => structureId);\n\n  // replace any existing structures with newly generated structures\n  // this is done because it is possible that a structure exists without matchUps\n  drawDefinition.structures = (drawDefinition.structures ?? []).map((structure) => {\n    return generatedStructureIds.includes(structure.structureId)\n      ? structures.find(({ structureId }) => structureId === structure.structureId)\n      : structure;\n  }) as Structure[];\n\n  const newStructures = structures?.filter(({ structureId }) => !existingStructureIds?.includes(structureId));\n  if (newStructures.length) drawDefinition.structures.push(...newStructures);\n\n  addGoesTo({ drawDefinition });\n\n  const matchUps = structures.map((structure) => getAllStructureMatchUps({ structure })?.matchUps || []).flat();\n\n  addMatchUpsNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    eventId: event?.eventId,\n    drawDefinition,\n    matchUps,\n  });\n\n  const structureIds = structures.map(({ structureId }) => structureId);\n  modifyDrawNotice({ drawDefinition, structureIds });\n\n  if (matchUpModifications?.length) {\n    const modifiedMatchUpMap = {};\n    matchUpModifications.forEach((modification) => {\n      const matchUpId = modification.matchUp?.matchUpId;\n      if (matchUpId) {\n        modifiedMatchUpMap[matchUpId] = modification;\n      }\n    });\n\n    // This is necessary to support external data stores in client/server architectures\n    // where the data store, e.g. Mongo, requires additional attributes to be present\n    // for each matchUp for which there are modifications, merge matchUp in state with modifications\n    // also descend into tieMatchUps, when present, with the same logic\n    const modifyStructureMatchUps = (structure) => {\n      structure.matchUps.forEach((matchUp) => {\n        if (modifiedMatchUpMap[matchUp.matchUpId]) {\n          const { tieMatchUps, ...attribs } = modifiedMatchUpMap[matchUp.matchUpId].matchUp;\n          Object.assign(matchUp, attribs);\n          if (tieMatchUps?.length) {\n            const modifiedTieMatchUpsMap = {};\n            tieMatchUps.forEach(\n              (modifiedTieMatchUp) => (modifiedMatchUpMap[modifiedTieMatchUp.matchUpId] = modifiedTieMatchUp),\n            );\n            matchUp.tieMatchUps.forEach((tm) => Object.assign(tm, modifiedTieMatchUpsMap[tm.matchUpId]));\n          }\n          modifiedMatchUpMap[matchUp.matchUpId].matchUp = matchUp;\n          modifyMatchUpNotice(modifiedMatchUpMap[matchUp.matchUpId]);\n        }\n      });\n    };\n\n    // pre-existing structures must be updated if any matchUpModifications were passed into this method\n    drawDefinition.structures.forEach((structure) => {\n      if (existingStructureIds?.includes(structure.structureId)) {\n        if (structure.structures) {\n          for (const subStructure of structure.structures) {\n            modifyStructureMatchUps(subStructure);\n          }\n        } else {\n          modifyStructureMatchUps(structure);\n        }\n      }\n    });\n  }\n\n  const addedStructureIds = newStructures.map(xa('structureId'));\n\n  if (tournamentRecord) {\n    const itemValue = { structureIds, drawId: drawDefinition.drawId };\n    const timeItem = {\n      itemValue,\n      itemType,\n    };\n    addTimeItem({ element: tournamentRecord, timeItem });\n  }\n\n  return { ...SUCCESS, addedStructureIds };\n}\n","import { generateAndPopulatePlayoffStructures } from '../../assemblies/generators/drawDefinitions/generateAndPopulatePlayoffStructures';\nimport { attachPlayoffStructures } from './attachStructures';\n\nexport function addPlayoffStructures(params) {\n  const { structures, links, matchUpModifications, error } =\n    generateAndPopulatePlayoffStructures(params);\n  if (error) return { error };\n\n  const drawDefinition = params.drawDefinition;\n\n  return attachPlayoffStructures({\n    tournamentId: params.tournamentRecord?.tournamentId,\n    eventId: params.event?.eventId || params.eventId,\n    matchUpModifications,\n    drawDefinition,\n    structures,\n    links,\n  });\n}\n","import { parse } from '../matchUpFormatCode/parse';\nimport { isNumeric } from '../../../utilities/math';\n\nimport {\n  ErrorType,\n  MISSING_VALUE,\n} from '../../../constants/errorConditionConstants';\nimport {\n  ABANDONED,\n  DEAD_RUBBER,\n  DEFAULTED,\n  DOUBLE_DEFAULT,\n  DOUBLE_WALKOVER,\n  RETIRED,\n  SUSPENDED,\n  WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\n\ntype GenerateScoreString = {\n  addOutcomeString?: boolean;\n  autoComplete?: boolean;\n  matchUpStatus?: string;\n  matchUpFormat?: string;\n  winnerFirst?: boolean;\n  winningSide?: number;\n  reversed?: boolean;\n  sets: any;\n};\nexport function generateScoreString(\n  params: GenerateScoreString\n): string | { error?: ErrorType; info?: ErrorType | string } {\n  const {\n    winnerFirst = true,\n    addOutcomeString,\n    reversed = false,\n    matchUpStatus,\n    matchUpFormat,\n    autoComplete,\n    winningSide,\n    sets,\n  } = params;\n\n  if (!sets) return { error: MISSING_VALUE, info: 'missing sets' };\n\n  const parsedFormat: any = matchUpFormat && parse(matchUpFormat);\n  const { bestOf, finalSetFormat, setFormat } = parsedFormat ?? {};\n\n  const scoresInSideOrder = !winnerFirst || !winningSide || winningSide === 1;\n  const reverseScores = reversed || !scoresInSideOrder;\n\n  const outcomeString = addOutcomeString\n    ? getOutcomeString({ matchUpStatus })\n    : '';\n\n  const setScores =\n    sets\n      ?.sort(setSort)\n      .map(setString)\n      .filter(Boolean) // handle situation where there are multiple empty set objects\n      .join(' ') || '';\n\n  if (!outcomeString) return setScores;\n  if (winningSide === 2) return `${outcomeString} ${setScores}`;\n  return `${setScores} ${outcomeString}`;\n\n  function setString(currentSet) {\n    const isFinalSet = bestOf && currentSet.setNumber === bestOf;\n    const format = isFinalSet && finalSetFormat ? finalSetFormat : setFormat;\n    const hasGameScores = (set) =>\n      isNumeric(set?.side1Score) || isNumeric(set?.side2Score);\n    const hasTiebreakScores = (set) =>\n      isNumeric(set?.side1TiebreakScore) || isNumeric(set?.side2TiebreakScore);\n\n    const isTiebreakSet =\n      format?.tiebreakSet ||\n      (!hasGameScores(currentSet) && hasTiebreakScores(currentSet));\n\n    const { side1Score, side2Score, side1TiebreakScore, side2TiebreakScore } =\n      currentSet;\n\n    const t1 =\n      side1TiebreakScore ||\n      (isNumeric(side1TiebreakScore) || autoComplete ? 0 : '');\n    const t2 =\n      side2TiebreakScore ||\n      (isNumeric(side2TiebreakScore) || autoComplete ? 0 : '');\n\n    if (isTiebreakSet) {\n      const tiebreakScore = reverseScores ? [t2, t1] : [t1, t2];\n      return `[${tiebreakScore.join('-')}]`;\n    }\n\n    const lowTiebreakScore = Math.min(t1, t2);\n    const tiebreak = lowTiebreakScore ? `(${lowTiebreakScore})` : '';\n\n    const s1 = side1Score || (isNumeric(side1Score) || autoComplete ? 0 : '');\n    const s2 = side2Score || (isNumeric(side2Score) || autoComplete ? 0 : '');\n\n    let scoreString = reverseScores\n      ? `${[s2, s1].join('-')}${tiebreak}`\n      : `${[s1, s2].join('-')}${tiebreak}`;\n\n    if (['-', ' '].includes(scoreString)) scoreString = '';\n    return scoreString;\n  }\n}\n\nfunction getOutcomeString({ matchUpStatus }) {\n  const outcomeStrings = {\n    [RETIRED]: 'RET',\n    [WALKOVER]: 'WO',\n    [DOUBLE_DEFAULT]: 'DF/DF',\n    [DOUBLE_WALKOVER]: 'WO/WO',\n    [SUSPENDED]: 'SUS',\n    [ABANDONED]: 'ABN',\n    [DEFAULTED]: 'DEF',\n    [DEAD_RUBBER]: 'DR',\n  };\n\n  return (matchUpStatus && outcomeStrings[matchUpStatus]) || '';\n}\n\nfunction setSort(a, b) {\n  return a.setNumber - b.setNumber;\n}\n","import { generateScoreString } from './generateScoreString';\n\nexport function matchUpScore(params) {\n  const { matchUpFormat, matchUpStatus, winningSide, score } = params;\n  if (!score) return { sets: [] };\n\n  const sets = score.sets || [];\n\n  let scoreStringSide1 = generateScoreString({\n    winnerFirst: false,\n    matchUpFormat,\n    matchUpStatus,\n    sets,\n  });\n\n  let scoreStringSide2 = generateScoreString({\n    winnerFirst: false,\n    reversed: true,\n    matchUpFormat,\n    matchUpStatus,\n    sets,\n  });\n\n  const winnerPerspective = generateScoreString({\n    matchUpFormat,\n    matchUpStatus,\n    winningSide,\n    sets,\n  });\n\n  const loserPerspective =\n    scoreStringSide1 === winnerPerspective\n      ? scoreStringSide2\n      : scoreStringSide1;\n\n  if (winningSide) {\n    scoreStringSide1 = winningSide === 1 ? winnerPerspective : loserPerspective;\n    scoreStringSide2 = winningSide === 2 ? winnerPerspective : loserPerspective;\n  }\n\n  return {\n    score: {\n      sets,\n      scoreStringSide1,\n      scoreStringSide2,\n    },\n  };\n}\n","import { resolveTournamentRecords } from '../../../parameters/resolveTournamentRecords';\nimport { matchUpScore } from '../../../assemblies/generators/matchUps/matchUpScore';\nimport { setMatchUpMatchUpFormat } from '../matchUpFormat/setMatchUpMatchUpFormat';\nimport { findPolicy } from '../../../acquire/findPolicy';\nimport { findEvent } from '../../../acquire/findEvent';\nimport { setMatchUpState } from './setMatchUpState';\n\nimport {\n  DrawDefinition,\n  Event,\n  Tournament,\n} from '../../../types/tournamentTypes';\nimport { POLICY_TYPE_SCORING } from '../../../constants/policyConstants';\nimport { PolicyDefinitions } from '../../../types/factoryTypes';\nimport {\n  MISSING_DRAW_ID,\n  MISSING_MATCHUP_ID,\n} from '../../../constants/errorConditionConstants';\n\n/**\n * Sets either matchUpStatus or score and winningSide; values to be set are passed in outcome object.\n * Public API for setting matchUpStatus or score and winningSide.\n */\n\ntype SetMatchUpStatusArgs = {\n  tournamentRecords?: { [key: string]: Tournament };\n  policyDefinitions?: PolicyDefinitions;\n  allowChangePropagation?: boolean;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  disableAutoCalc?: boolean;\n  enableAutoCalc?: boolean;\n  matchUpFormat?: string;\n  tournamentId?: string;\n  matchUpId: string;\n  eventId?: string;\n  drawId?: string;\n  schedule?: any;\n  notes?: string;\n  event?: Event;\n  outcome?: any;\n};\nexport function setMatchUpStatus(params: SetMatchUpStatusArgs) {\n  const tournamentRecords = resolveTournamentRecords(params);\n  if (!params.drawDefinition) {\n    const tournamentRecord =\n      params.tournamentRecord ??\n      (params.tournamentId && tournamentRecords[params.tournamentId]);\n    if (!params.tournamentRecord) params.tournamentRecord = tournamentRecord;\n\n    const result = findEvent({\n      eventId: params.eventId,\n      drawId: params.drawId,\n      tournamentRecord,\n    });\n    if (result.error) return result;\n    if (result.drawDefinition) params.drawDefinition = result.drawDefinition;\n    params.event = result.event;\n  }\n\n  const {\n    policyDefinitions,\n    tournamentRecord,\n    disableAutoCalc,\n    enableAutoCalc,\n    drawDefinition,\n    matchUpFormat,\n    matchUpId,\n    schedule,\n    event,\n    notes,\n  } = params;\n\n  if (!drawDefinition) return { error: MISSING_DRAW_ID };\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n\n  const { policy } = findPolicy({\n    policyType: POLICY_TYPE_SCORING,\n    tournamentRecord,\n    event,\n  });\n\n  // whether or not to allow winningSide change propagation\n  const allowChangePropagation =\n    (params.allowChangePropagation !== undefined &&\n      params.allowChangePropagation) ||\n    (policy?.allowChangePropagation !== undefined &&\n      policy.allowChangePropagation) ||\n    undefined;\n\n  const { outcome } = params;\n\n  if (matchUpFormat) {\n    const result = setMatchUpMatchUpFormat({\n      tournamentRecord,\n      drawDefinition,\n      matchUpFormat,\n      matchUpId,\n      event,\n    });\n    if (result.error) return result;\n  }\n\n  if (outcome?.score?.sets && !outcome.score.scoreStringSide1) {\n    const { score: scoreObject } = matchUpScore(outcome);\n    outcome.score = scoreObject;\n    outcome.score.sets = outcome.score.sets.filter(\n      (set) =>\n        set.side1Score ||\n        set.side2Score ||\n        set.side1TiebreakScore ||\n        set.side2TiebreakScore\n    );\n  }\n\n  return setMatchUpState({\n    matchUpStatusCodes: outcome?.matchUpStatusCodes,\n    matchUpStatus: outcome?.matchUpStatus,\n    winningSide: outcome?.winningSide,\n    allowChangePropagation,\n    score: outcome?.score,\n    tournamentRecords,\n    policyDefinitions,\n    tournamentRecord,\n    disableAutoCalc,\n    enableAutoCalc,\n    drawDefinition,\n    matchUpFormat,\n    matchUpId,\n    schedule,\n    event,\n    notes,\n  });\n}\n","import { addMatchUpsNotice, modifyDrawNotice, modifyMatchUpNotice } from '../notifications/drawNotifications';\nimport { generateCollectionMatchUps } from '../../assemblies/generators/drawDefinitions/tieMatchUps';\nimport { validateCollectionDefinition } from '../../validators/validateCollectionDefinition';\nimport { getAllStructureMatchUps } from '../../query/matchUps/getAllStructureMatchUps';\nimport { ResultType, decorateResult } from '../../global/functions/decorateResult';\nimport { copyTieFormat } from '../../query/hierarchical/tieFormats/copyTieFormat';\nimport { calculateWinCriteria } from '../../query/matchUp/calculateWinCriteria';\nimport { getTieFormat } from '../../query/hierarchical/tieFormats/getTieFormat';\nimport { getAppliedPolicies } from '../../query/extensions/getAppliedPolicies';\nimport { tieFormatTelemetry } from '../matchUps/tieFormat/tieFormatTelemetry';\nimport { validateTieFormat } from '../../validators/validateTieFormat';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { validUpdate } from '../../validators/validUpdate';\nimport { UUID } from '../../utilities/UUID';\n\nimport { TIE_FORMAT_MODIFICATIONS } from '../../constants/extensionConstants';\nimport { POLICY_TYPE_MATCHUP_ACTIONS } from '../../constants/policyConstants';\nimport { PolicyDefinitions } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { TEAM } from '../../constants/matchUpTypes';\nimport {\n  CANNOT_MODIFY_TIEFORMAT,\n  DUPLICATE_VALUE,\n  MISSING_DRAW_DEFINITION,\n} from '../../constants/errorConditionConstants';\nimport {\n  Category,\n  CollectionDefinition,\n  DrawDefinition,\n  Event,\n  GenderUnion,\n  MatchUp,\n  TieFormat,\n  Tournament,\n} from '../../types/tournamentTypes';\n\n/*\n * collectionDefinition will be added to an event tieFormat (if present)\n * if a matchUpId is provided, will be added to matchUp.tieFormat\n * if a structureId is provided, will be added to structure.tieFormat\n * TODO: determine whether all contained instances of tieFormat should be updated\n */\n\ntype AddCollectionDefinitionArgs = {\n  collectionDefinition: CollectionDefinition;\n  policyDefinitions?: PolicyDefinitions;\n  updateInProgressMatchUps?: boolean;\n  referenceGender?: GenderUnion;\n  drawDefinition: DrawDefinition;\n  referenceCategory?: Category;\n  tournamentRecord: Tournament;\n  enforceCategory?: boolean;\n  enforceGender?: boolean;\n  tieFormatName?: string;\n  structureId?: string;\n  matchUpId?: string;\n  matchUp?: MatchUp;\n  eventId?: string;\n  uuids?: string[];\n  event?: Event;\n};\n\nexport function addCollectionDefinition({\n  updateInProgressMatchUps = true,\n  collectionDefinition,\n  referenceCategory,\n  tournamentRecord,\n  policyDefinitions,\n  enforceCategory,\n  referenceGender,\n  drawDefinition,\n  tieFormatName,\n  enforceGender,\n  structureId,\n  matchUpId,\n  matchUp,\n  eventId,\n  uuids,\n  event,\n}: AddCollectionDefinitionArgs): ResultType & {\n  tieFormat?: TieFormat;\n  targetMatchUps?: any;\n  addedMatchUps?: any;\n} {\n  const stack = 'addCollectionDefinition';\n  const appliedPolicies =\n    getAppliedPolicies({\n      tournamentRecord,\n      drawDefinition,\n      event,\n    }).appliedPolicies ?? {};\n\n  const matchUpActionsPolicy =\n    policyDefinitions?.[POLICY_TYPE_MATCHUP_ACTIONS] ?? appliedPolicies?.[POLICY_TYPE_MATCHUP_ACTIONS];\n\n  enforceCategory = enforceCategory ?? matchUpActionsPolicy?.participants?.enforceCategory;\n\n  const genderEnforced = (enforceGender ?? matchUpActionsPolicy?.participants?.enforceGender) !== false;\n\n  const checkCategory = !!((referenceCategory ?? event?.category) && enforceCategory !== false);\n  const checkGender = !!((referenceGender ?? event?.gender) && genderEnforced);\n\n  const validationResult = validateCollectionDefinition({\n    referenceCategory: referenceCategory ?? event?.category,\n    collectionDefinition,\n    referenceGender,\n    checkCategory,\n    checkGender,\n    event,\n  });\n  if (validationResult.error) {\n    return decorateResult({ result: validationResult, stack });\n  }\n\n  let result = !matchUp?.tieFormat\n    ? getTieFormat({\n        drawDefinition,\n        structureId,\n        matchUpId,\n        eventId,\n        event,\n      })\n    : undefined;\n\n  if (result?.error) return decorateResult({ result: { error: result.error }, stack });\n\n  const structure = result?.structure;\n  matchUp = matchUp ?? result?.matchUp;\n  const existingTieFormat = matchUp?.tieFormat ?? result?.tieFormat;\n  const tieFormat = copyTieFormat(existingTieFormat);\n\n  result = validateTieFormat({ tieFormat });\n  if (result?.error) {\n    return decorateResult({ result: { error: result.error }, stack });\n  }\n\n  if (!collectionDefinition.collectionId) {\n    collectionDefinition.collectionId = UUID();\n  } else {\n    const collectionIds = tieFormat.collectionDefinitions.map(({ collectionId }) => collectionId);\n    if (collectionIds.includes(collectionDefinition.collectionId))\n      return decorateResult({\n        context: { collectionId: collectionDefinition.collectionId },\n        result: { error: DUPLICATE_VALUE },\n      });\n  }\n\n  tieFormat.collectionDefinitions.push(collectionDefinition);\n  tieFormat.collectionDefinitions\n    .sort((a, b) => (a.collectionOrder || 0) - (b.collectionOrder || 0))\n    .forEach((collectionDefinition, i) => (collectionDefinition.collectionOrder = i + 1));\n\n  // calculate new winCriteria for tieFormat\n  // if existing winCriteria is aggregateValue, retain\n  const { aggregateValue, valueGoal } = calculateWinCriteria(tieFormat);\n  tieFormat.winCriteria = definedAttributes({ aggregateValue, valueGoal });\n\n  // if valueGoal has changed, force renaming of the tieFormat\n  const originalValueGoal = existingTieFormat?.winCriteria.valueGoal;\n  const wasAggregateValue = existingTieFormat?.winCriteria.aggregateValue;\n  if ((originalValueGoal && originalValueGoal !== valueGoal) || (aggregateValue && !wasAggregateValue)) {\n    if (tieFormatName) {\n      tieFormat.tieFormatName = tieFormatName;\n    } else {\n      delete tieFormat.tieFormatName;\n    }\n  }\n\n  const modifiedStructureIds: string[] = [];\n  const addedMatchUps: any[] = [];\n  let targetMatchUps: any[] = [];\n\n  const prunedTieFormat = definedAttributes(tieFormat);\n  result = validateTieFormat({ tieFormat: prunedTieFormat });\n  if (result?.error) {\n    return decorateResult({ result: { error: result.error }, stack });\n  }\n\n  if (eventId && event) {\n    event.tieFormat = prunedTieFormat;\n\n    // all team matchUps in the event which do not have tieFormats and where draws/strucures do not have tieFormats should have matchUps added\n    for (const drawDefinition of event.drawDefinitions ?? []) {\n      if (drawDefinition.tieFormat) continue;\n      for (const structure of drawDefinition.structures ?? []) {\n        if (structure.tieFormat) continue;\n        const result = updateStructureMatchUps({\n          updateInProgressMatchUps,\n          collectionDefinition,\n          structure,\n          uuids,\n        });\n        addedMatchUps.push(...result.newMatchUps);\n        targetMatchUps.push(...result.targetMatchUps);\n        modifiedStructureIds.push(structure.structureId);\n      }\n    }\n\n    queueNoficiations({\n      modifiedMatchUps: targetMatchUps,\n      eventId: event?.eventId,\n      modifiedStructureIds,\n      tournamentRecord,\n      drawDefinition,\n      addedMatchUps,\n      stack,\n    });\n  } else if (structureId && structure) {\n    structure.tieFormat = prunedTieFormat;\n    const result = updateStructureMatchUps({\n      updateInProgressMatchUps,\n      collectionDefinition,\n      structure,\n      uuids,\n    });\n    addedMatchUps.push(...result.newMatchUps);\n    targetMatchUps = result.targetMatchUps;\n\n    queueNoficiations({\n      modifiedMatchUps: targetMatchUps,\n      eventId: event?.eventId,\n      modifiedStructureIds,\n      tournamentRecord,\n      drawDefinition,\n      addedMatchUps,\n      stack,\n    });\n  } else if (matchUpId && matchUp) {\n    if (!validUpdate({ matchUp, updateInProgressMatchUps }))\n      return decorateResult({\n        result: { error: CANNOT_MODIFY_TIEFORMAT },\n        stack,\n      });\n\n    matchUp.tieFormat = prunedTieFormat;\n    const newMatchUps: MatchUp[] = generateCollectionMatchUps({\n      collectionDefinition,\n      matchUp,\n      uuids,\n    });\n\n    if (!Array.isArray(matchUp.tieMatchUps)) matchUp.tieMatchUps = [];\n    matchUp.tieMatchUps.push(...newMatchUps);\n    addedMatchUps.push(...newMatchUps);\n\n    queueNoficiations({\n      modifiedMatchUps: [matchUp],\n      eventId: event?.eventId,\n      modifiedStructureIds,\n      tournamentRecord,\n      drawDefinition,\n      addedMatchUps,\n      stack,\n    });\n  } else if (drawDefinition) {\n    // all team matchUps in the drawDefinition which do not have tieFormats and where strucures do not have tieFormats should have matchUps added\n    drawDefinition.tieFormat = prunedTieFormat;\n\n    for (const structure of drawDefinition.structures ?? []) {\n      const result = updateStructureMatchUps({\n        updateInProgressMatchUps,\n        collectionDefinition,\n        structure,\n        uuids,\n      });\n      modifiedStructureIds.push(structure.structureId);\n      addedMatchUps.push(...result.newMatchUps);\n      targetMatchUps.push(...result.targetMatchUps);\n    }\n\n    queueNoficiations({\n      modifiedMatchUps: targetMatchUps,\n      eventId: event?.eventId,\n      tournamentRecord,\n      drawDefinition,\n      addedMatchUps,\n      stack,\n    });\n  } else {\n    return { error: MISSING_DRAW_DEFINITION };\n  }\n\n  if (appliedPolicies?.audit?.[TIE_FORMAT_MODIFICATIONS]) {\n    const auditData = definedAttributes({\n      drawId: drawDefinition?.drawId,\n      collectionDefinition,\n      action: stack,\n      structureId,\n      matchUpId,\n      eventId,\n    });\n    tieFormatTelemetry({ drawDefinition, auditData });\n  }\n\n  return {\n    tieFormat: prunedTieFormat,\n    targetMatchUps,\n    addedMatchUps,\n    ...SUCCESS,\n  };\n}\n\nfunction updateStructureMatchUps({ updateInProgressMatchUps, collectionDefinition, structure, uuids }) {\n  const newMatchUps: MatchUp[] = [];\n  const matchUps = getAllStructureMatchUps({\n    matchUpFilters: { matchUpTypes: [TEAM] },\n    structure,\n  })?.matchUps;\n\n  // all team matchUps in the structure which are not completed and which have no score value should have matchUps added\n  const targetMatchUps = matchUps.filter(\n    (matchUp) => validUpdate({ matchUp, updateInProgressMatchUps }) && !matchUp.tieFormat,\n  );\n\n  for (const matchUp of targetMatchUps) {\n    const tieMatchUps: MatchUp[] = generateCollectionMatchUps({\n      collectionDefinition,\n      matchUp,\n      uuids,\n    });\n\n    if (!Array.isArray(matchUp.tieMatchUps)) matchUp.tieMatchUps = [];\n    matchUp.tieMatchUps.push(...tieMatchUps);\n    newMatchUps.push(...tieMatchUps);\n  }\n  return { newMatchUps, targetMatchUps };\n}\n\ntype QueueNotificationsArgs = {\n  modifiedStructureIds?: string[];\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  modifiedMatchUps: MatchUp[];\n  addedMatchUps: MatchUp[];\n  eventId?: string;\n  stack: string;\n};\nfunction queueNoficiations({\n  modifiedStructureIds,\n  tournamentRecord,\n  modifiedMatchUps,\n  drawDefinition,\n  addedMatchUps,\n  eventId,\n  stack,\n}: QueueNotificationsArgs) {\n  addMatchUpsNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    matchUps: addedMatchUps,\n    drawDefinition,\n    eventId,\n  });\n  modifiedMatchUps?.forEach((matchUp) => {\n    modifyMatchUpNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      drawDefinition,\n      context: stack,\n      matchUp,\n      eventId,\n    });\n  });\n  modifyDrawNotice({\n    structureIds: modifiedStructureIds,\n    drawDefinition,\n    eventId,\n  });\n}\n","import { checkRequiredParameters } from '../../../parameters/checkRequiredParameters';\nimport { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { modifyDrawNotice } from '../../notifications/drawNotifications';\nimport { addExtension } from '../addExtension';\n\nimport { PolicyDefinitions, TournamentRecords } from '../../../types/factoryTypes';\nimport { DrawDefinition, Event, Tournament } from '../../../types/tournamentTypes';\nimport { APPLIED_POLICIES } from '../../../constants/extensionConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { isObject, isString } from '../../../utilities/objects';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  EXISTING_POLICY_TYPE,\n  INVALID_VALUES,\n  MISSING_POLICY_DEFINITION,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../../constants/errorConditionConstants';\nimport {\n  DRAW_DEFINITION,\n  EVENT,\n  POLICY_DEFINITIONS,\n  TOURNAMENT_RECORD,\n  TOURNAMENT_RECORDS,\n} from '../../../constants/attributeConstants';\n\ntype AttachPoliciesArgs = {\n  tournamentRecords?: TournamentRecords;\n  policyDefinitions: PolicyDefinitions;\n  drawDefinition?: DrawDefinition;\n  tournamentRecord?: Tournament;\n  allowReplacement?: boolean;\n  tournamentId?: string;\n  event?: Event;\n};\n\nexport function attachPolicies(params: AttachPoliciesArgs): ResultType & { applied?: string[] } {\n  const checkParams = checkRequiredParameters(params, [\n    {\n      _anyOf: {\n        [TOURNAMENT_RECORDS]: false,\n        [TOURNAMENT_RECORD]: false,\n        [DRAW_DEFINITION]: false,\n        [EVENT]: false,\n      },\n      [POLICY_DEFINITIONS]: true,\n    },\n  ]);\n  if (checkParams.error) return checkParams;\n\n  const applied: string[] = [];\n\n  const element =\n    params.drawDefinition ??\n    params.event ??\n    ((params.tournamentId || !params.tournamentRecords) && params.tournamentRecord);\n\n  if (element) {\n    const result = policyAttachement(params, element);\n    if (result.error) return result;\n    applied.push(...(result?.applied ?? []));\n\n    if (params.drawDefinition) {\n      modifyDrawNotice({\n        drawDefinition: params.drawDefinition,\n        tournamentId: params.tournamentId,\n      });\n    }\n  } else if (params.tournamentRecords) {\n    const tournamentIds = Object.keys(params.tournamentRecords);\n    if (!tournamentIds.length) return { error: MISSING_TOURNAMENT_RECORD };\n    for (const tournamentId of tournamentIds) {\n      const tournamentRecord = params.tournamentRecords[tournamentId];\n      const result = policyAttachement(params, tournamentRecord);\n      if (result.error) return result;\n      applied.push(...(result?.applied ?? []));\n    }\n  } else {\n    return { error: MISSING_TOURNAMENT_RECORD };\n  }\n\n  return !applied.length ? { error: EXISTING_POLICY_TYPE } : { ...SUCCESS, applied };\n}\n\nfunction policyAttachement(params: any, element: any): ResultType & { applied?: string[] } {\n  const appliedPolicies = getAppliedPolicies(params).appliedPolicies ?? {};\n  if (!element.extensions) element.extensions = [];\n  const applied: string[] = [];\n\n  const policyTypes = Object.keys(params.policyDefinitions);\n  if (!policyTypes.length) return { error: MISSING_POLICY_DEFINITION };\n\n  for (const policyType of policyTypes) {\n    if (!appliedPolicies[policyType] || params.allowReplacement) {\n      const policy = params.policyDefinitions[policyType];\n      if (!policy) continue;\n      if (!isObject(policy)) return { error: INVALID_VALUES };\n      const { policyName, ...values } = policy;\n      if (!values || !Object.keys(values).length || (policyName && !isString(policyName)))\n        return { error: INVALID_VALUES };\n      appliedPolicies[policyType] = params.policyDefinitions[policyType];\n      applied.push(policyType);\n    }\n  }\n\n  if (applied?.length) {\n    const extension = { name: APPLIED_POLICIES, value: appliedPolicies };\n    return { ...addExtension({ element, extension }), applied };\n  }\n\n  return { applied, error: EXISTING_POLICY_TYPE };\n}\n","import { modifyDrawNotice } from '../notifications/drawNotifications';\nimport { addEventExtension } from '../extensions/addRemoveExtensions';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\n\nimport { FLIGHT_PROFILE } from '../../constants/extensionConstants';\nimport { Flight, FlightProfile } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { DrawDefinition, Event, Tournament } from '../../types/tournamentTypes';\nimport {\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n} from '../../constants/errorConditionConstants';\n\ntype ModifyDrawNameArgs = {\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  flightProfile: FlightProfile;\n  drawName: string;\n  drawId: string;\n  event: Event;\n};\nexport function modifyDrawName({\n  tournamentRecord,\n  drawDefinition,\n  flightProfile,\n  drawName,\n  drawId,\n  event,\n}: ModifyDrawNameArgs): ResultType & { flight?: Flight } {\n  if (!drawName || typeof drawName !== 'string')\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      context: { drawName },\n    });\n\n  if (!flightProfile) {\n    flightProfile = getFlightProfile({ event }).flightProfile;\n  }\n\n  const flight = flightProfile?.flights?.find(\n    (flight) => flight.drawId === drawId\n  );\n\n  if (flight) {\n    flight.drawName = drawName;\n    const extension = {\n      name: FLIGHT_PROFILE,\n      value: {\n        ...flightProfile,\n        flights: flightProfile.flights,\n      },\n    };\n\n    addEventExtension({ event, extension });\n  }\n\n  if (drawDefinition) {\n    drawDefinition.drawName = drawName;\n    modifyDrawNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      drawDefinition,\n    });\n  }\n\n  if (!flight && !drawDefinition) {\n    return { error: MISSING_DRAW_DEFINITION };\n  }\n\n  return { ...SUCCESS, flight };\n}\n","import { setMatchUpStatus } from '../matchUps/matchUpStatus/setMatchUpStatus';\nimport { findEvent } from '../../acquire/findEvent';\n\nimport {\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\n\nexport function bulkMatchUpStatusUpdate(params) {\n  if (!params?.outcomes) return { error: MISSING_VALUE };\n  if (!Array.isArray(params.outcomes))\n    return { error: MISSING_VALUE, info: { outcomes: params.outcomes } };\n\n  const tournamentRecords =\n    params.tournamentRecords ||\n    (params.tournamentRecord && {\n      [params.tournamentRecord.tournamentId]: params.tournamentRecord,\n    }) ||\n    {};\n\n  const outcomes = params.outcomes ?? [];\n\n  const tournamentIds = outcomes.reduce(\n    (tournamentIds, outcome) =>\n      !tournamentIds.includes(outcome.tournamentId)\n        ? tournamentIds.concat(outcome.tournamentId)\n        : tournamentIds,\n    []\n  );\n\n  for (const tournamentId of tournamentIds) {\n    const tournamentRecord = tournamentRecords[tournamentId];\n    if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n    const tournamentOutcomes = outcomes.filter(\n      (outcome) => outcome.tournamentId === tournamentId\n    );\n    if (tournamentOutcomes.length) {\n      const result = bulkUpdate({\n        outcomes: tournamentOutcomes,\n        tournamentRecord,\n      });\n      if (result.error) return result;\n    }\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction bulkUpdate(params) {\n  const { tournamentRecords, tournamentRecord, outcomes, policyDefinitions } =\n    params;\n  const events = {};\n\n  // group outcomes by events to optimize\n  outcomes.forEach((outcome) => {\n    const { eventId } = outcome;\n    if (!events[eventId]) events[eventId] = [];\n    events[eventId].push(outcome);\n  });\n\n  for (const eventId of Object.keys(events)) {\n    const { event } = findEvent({ tournamentRecord, eventId });\n\n    for (const outcome of events[eventId]) {\n      const { drawId } = outcome;\n      const drawDefinition = event?.drawDefinitions?.find(\n        (drawDefinition) => drawDefinition.drawId === drawId\n      );\n      if (drawDefinition && drawId) {\n        const { matchUpFormat, matchUpId } = outcome;\n        const result = setMatchUpStatus({\n          schedule: outcome?.schedule,\n          tournamentRecords,\n          policyDefinitions,\n          tournamentRecord,\n          drawDefinition,\n          matchUpFormat,\n          matchUpId,\n          outcome,\n          drawId,\n          event,\n        });\n        if (result.error) {\n          return result;\n        }\n      }\n    }\n  }\n\n  return { ...SUCCESS };\n}\n","import { getStructureDrawPositionProfiles } from '../structure/getStructureDrawPositionProfiles';\nimport { getRoundMatchUps } from '../matchUps/getRoundMatchUps';\nimport { getPositionAssignments } from '../drawDefinition/positionsGetter';\nimport { getStructureGroups } from '../structure/getStructureGroups';\nimport { getStructureLinks } from '../drawDefinition/linkGetter';\nimport { stageOrder } from '../../constants/drawDefinitionConstants';\nimport { ensureInt } from '../../utilities/ensureInt';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\ntype DrawsAnalysis = {\n  positionsNoOutcomes: string[];\n  canBePruned: string[];\n  matchPlay: string[];\n  inactive: string[];\n  drawAnalysis: any;\n};\n\nexport function analyzeDraws({ tournamentRecord }): {\n  error?: ErrorType;\n  drawsAnalysis?: any;\n  success?: boolean;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  const drawsAnalysis: DrawsAnalysis = {\n    positionsNoOutcomes: [], // all positions assigned and no outcomes\n    canBePruned: [], // partially assigned positions with outcomes => drawSizes can be reduced\n    matchPlay: [], // only first round has active matchUps; some unassigned positions\n    inactive: [],\n\n    drawAnalysis: {},\n  };\n\n  const eventsMap = {};\n\n  const eventDraws = tournamentRecord.events\n    ?.map((event) => {\n      const eventId = event.eventId;\n      eventsMap[eventId] = event;\n      return (event?.drawDefinitions || []).map((drawDefinition) => ({\n        drawDefinition,\n        eventId,\n      }));\n    })\n    .flat()\n    .filter(Boolean);\n\n  eventDraws.forEach(({ drawDefinition, eventId }) => {\n    let positionsAssignedCount = 0;\n    let matchUpsWithWinningSideCount = 0;\n    let matchUpsNoOutcomeCount = 0;\n    const { allStructuresLinked } = getStructureGroups({ drawDefinition });\n\n    const event = eventsMap[eventId];\n    const structures = drawDefinition?.structures || [];\n    const structuresData = structures.map((structure) => {\n      const { stage, stageSequence, structureId } = structure;\n      const orderNumber = stageOrder[stage];\n      const { inContextStructureMatchUps } = getStructureDrawPositionProfiles({\n        drawDefinition,\n        structure,\n        event,\n      });\n      const matchUpsWithWinningSide = inContextStructureMatchUps?.filter(\n        ({ winningSide }) => winningSide\n      );\n\n      const winningSideCount =\n        matchUpsWithWinningSide.filter(Boolean).length || 0;\n\n      matchUpsWithWinningSideCount += winningSideCount;\n      matchUpsNoOutcomeCount +=\n        inContextStructureMatchUps.length - matchUpsWithWinningSideCount;\n\n      const maxWinningSideFirstRoundPosition = Math.max(\n        matchUpsWithWinningSide\n          .filter(({ roundNumber }) => roundNumber === 1)\n          .map(({ roundPosition }) => roundPosition)\n      );\n\n      const { positionAssignments } = getPositionAssignments({ structure });\n      const positionsAssigned = positionAssignments?.filter(\n        ({ participantId }) => participantId\n      );\n      positionsAssignedCount += positionsAssigned?.length ?? 0;\n\n      const unassignedPositionsCount =\n        (positionAssignments?.length ?? 0) - (positionsAssigned?.length ?? 0);\n\n      const { roundMatchUps, roundProfile, roundNumbers, maxMatchUpsCount } =\n        getRoundMatchUps({ matchUps: inContextStructureMatchUps });\n\n      const activeRounds =\n        roundProfile &&\n        Object.keys(roundProfile)\n          .filter((roundNumber) => !roundProfile[roundNumber].inactiveRound)\n          .map((roundNumber) => parseInt(roundNumber));\n      const inactiveRounds =\n        roundProfile &&\n        Object.keys(roundProfile)\n          .filter((roundNumber) => roundProfile[roundNumber].inactiveRound)\n          .map((roundNumber) => parseInt(roundNumber));\n      const inactiveStructure =\n        roundProfile &&\n        Object.values(roundProfile).every((profile) => profile.inactiveRound);\n\n      return {\n        positionsAssignedCount: positionsAssigned?.length ?? 0,\n        maxWinningSideFirstRoundPosition,\n        unassignedPositionsCount,\n        inactiveStructure,\n        maxMatchUpsCount,\n        inactiveRounds,\n        roundMatchUps,\n        activeRounds,\n        roundNumbers,\n        roundProfile,\n        structureId,\n\n        stageSequence,\n        orderNumber,\n        stage,\n      };\n    });\n\n    const mainStructure = structuresData.find(\n      (data) => data.orderNumber === 2 && data.stageSequence === 1\n    );\n\n    const activeStructuresCount = structuresData.filter(\n      ({ inactiveStructure }) => !inactiveStructure\n    ).length;\n\n    const { links } = getStructureLinks({\n      structureId: mainStructure.structureId,\n      drawDefinition,\n    });\n\n    const isMatchPlay =\n      ensureInt(mainStructure.activeRounds[0]) === 1 &&\n      mainStructure.activeRounds.length === 1 &&\n      activeStructuresCount === 1;\n\n    const inactiveDraw = structuresData?.every(\n      ({ inactiveStructure }) => inactiveStructure\n    );\n\n    const canBePruned =\n      !links.length &&\n      mainStructure.activeRounds.length &&\n      (mainStructure.roundProfile[1].inactiveCount ||\n        mainStructure.inactiveRounds.length);\n\n    const drawId = drawDefinition.drawId;\n\n    if (positionsAssignedCount && !matchUpsWithWinningSideCount)\n      drawsAnalysis.positionsNoOutcomes.push(drawId);\n    if (inactiveDraw) drawsAnalysis.inactive.push(drawId);\n    if (isMatchPlay) drawsAnalysis.matchPlay.push(drawId);\n    if (canBePruned) drawsAnalysis.canBePruned.push(drawId);\n\n    const drawAnalysis = {\n      matchUpsWithWinningSideCount,\n      matchUpsNoOutcomeCount,\n      positionsAssignedCount,\n      allStructuresLinked,\n      structuresData,\n      inactiveDraw,\n      isMatchPlay,\n      drawId,\n    };\n\n    drawsAnalysis.drawAnalysis[drawId] = drawAnalysis;\n  });\n\n  return { ...SUCCESS, drawsAnalysis };\n}\n","import { addEventExtension } from '../extensions/addRemoveExtensions';\nimport { allDrawMatchUps } from '../../query/matchUps/getAllDrawMatchUps';\nimport { getMatchUpId } from '../../global/functions/extractors';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { ensureInt } from '../../utilities/ensureInt';\nimport {\n  addDrawNotice,\n  addMatchUpsNotice,\n  deleteMatchUpsNotice,\n  modifyDrawNotice,\n} from '../notifications/drawNotifications';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\n\nimport { STRUCTURE_SELECTED_STATUSES } from '../../constants/entryStatusConstants';\nimport { FLIGHT_PROFILE } from '../../constants/extensionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  DRAW_ID_EXISTS,\n  INVALID_DRAW_DEFINITION,\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n  MISSING_EVENT,\n} from '../../constants/errorConditionConstants';\nimport { DrawDefinition, Event, Tournament } from '../../types/tournamentTypes';\n\ntype AddDrawDefinitionArgs = {\n  flight?: { flightNumber: number };\n  suppressNotifications?: boolean;\n  tournamentRecord?: Tournament;\n  modifyEventEntries?: boolean;\n  drawDefinition: DrawDefinition;\n  existingDrawCount?: number;\n  allowReplacement?: boolean;\n  checkEntryStatus?: boolean;\n  tournamentId?: string;\n  event: Event;\n};\n\nexport function addDrawDefinition(\n  params: AddDrawDefinitionArgs\n): ResultType & { modifiedEventEntryStatusCount?: number } {\n  const {\n    flight: flightDefinition,\n    suppressNotifications,\n    modifyEventEntries, // event.entries[{entryStatus}] are modified to match draw.entries[{entryStatus}]\n    existingDrawCount,\n    allowReplacement,\n    checkEntryStatus, // optional boolean to enable checking that flight.drawEntries match event.entries\n    tournamentRecord,\n    drawDefinition,\n    event,\n  } = params;\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!event) return { error: MISSING_EVENT };\n\n  if (!event.drawDefinitions) event.drawDefinitions = [];\n  const { drawId, drawName, entries: drawEntries } = drawDefinition;\n  const { entries: eventEntries } = event;\n  let modifiedEventEntryStatusCount = 0;\n\n  if (\n    existingDrawCount !== undefined &&\n    existingDrawCount !== event.drawDefinitions.length\n  )\n    return { error: INVALID_VALUES, info: 'drawDefintions count mismatch' };\n\n  const { flightProfile } = getFlightProfile({ event });\n  const relevantFlight =\n    flightDefinition &&\n    flightProfile?.flights?.find(\n      (flight) => flight.flightNumber === flightDefinition.flightNumber\n    );\n\n  // if there is a source drawId specified, the source draw must exist\n  const sourceDrawId = flightProfile?.links?.find(\n    (link) => link?.target?.drawId === drawId\n  )?.source?.drawId;\n  const sourceDrawIdError =\n    sourceDrawId &&\n    !event.drawDefinitions.find(\n      (drawDefinition) => drawDefinition.drawId === sourceDrawId\n    );\n\n  if (sourceDrawIdError)\n    return decorateResult({\n      result: { error: MISSING_DRAW_DEFINITION },\n      info: { sourceDrawId },\n    });\n\n  const flightConflict =\n    relevantFlight && relevantFlight.drawId !== drawDefinition.drawId;\n  if (flightConflict) {\n    return decorateResult({\n      result: { error: INVALID_DRAW_DEFINITION },\n      info: { relevantFlight },\n    });\n  }\n\n  const drawEntriesPresentInFlight = drawEntries?.every(\n    ({ participantId, entryStatus }) => {\n      const flightEntry = relevantFlight?.drawEntries.find(\n        (entry) => entry.participantId === participantId\n      );\n      return !entryStatus || flightEntry?.entryStatus === entryStatus;\n    }\n  );\n\n  // check that all drawEntries have equivalent entryStatus to event.entries\n  const matchingEventEntries =\n    !checkEntryStatus ||\n    (eventEntries &&\n      drawEntries?.every(({ participantId, entryStatus, entryStage }) => {\n        const eventEntry = eventEntries.find(\n          (eventEntry) =>\n            eventEntry.participantId === participantId &&\n            (!eventEntry.entryStage || eventEntry.entryStage === entryStage)\n        );\n        return eventEntry?.entryStatus === entryStatus;\n      }));\n\n  if (relevantFlight && !drawEntriesPresentInFlight) {\n    return decorateResult({\n      result: { error: INVALID_DRAW_DEFINITION },\n      context: {\n        drawEntriesPresentInFlight,\n        matchingEventEntries,\n        relevantFlight,\n      },\n      info: 'Draw entries are not present in flight or do not match entryStatuses',\n    });\n  }\n\n  if (modifyEventEntries) {\n    drawEntries?.filter(Boolean).forEach((drawEntry) => {\n      if (\n        drawEntry?.entryStatus &&\n        STRUCTURE_SELECTED_STATUSES.includes(drawEntry?.entryStatus)\n      ) {\n        const eventEntry = eventEntries\n          ?.filter(Boolean)\n          .find(\n            (eventEntry) => eventEntry.participantId === drawEntry.participantId\n          );\n        if (\n          eventEntry &&\n          drawEntry.entryStatus &&\n          eventEntry?.entryStatus !== drawEntry.entryStatus\n        ) {\n          eventEntry.entryStatus = drawEntry.entryStatus;\n          modifiedEventEntryStatusCount += 1;\n        }\n      }\n    });\n  }\n\n  if (eventEntries && !matchingEventEntries)\n    return decorateResult({\n      result: {\n        info: 'Draw entries do not match event entryStatuses',\n        context: { matchingEventEntries, eventEntries },\n        error: INVALID_DRAW_DEFINITION,\n      },\n    });\n\n  const flightNumbers =\n    flightProfile?.flights\n      ?.map(\n        ({ flightNumber }) => !isNaN(flightNumber) && ensureInt(flightNumber)\n      )\n      ?.filter(Boolean) || [];\n\n  const drawOrders =\n    (event.drawDefinitions\n      .map(({ drawOrder }) => drawOrder && ensureInt(drawOrder))\n      ?.filter(Boolean) as number[]) || [];\n\n  let drawOrder = Math.max(0, ...drawOrders, ...flightNumbers) + 1;\n\n  const flight = flightProfile?.flights?.find(\n    (flight) => flight.drawId === drawId\n  );\n\n  let extension;\n  if (flight) {\n    // if this drawId was defined in a flightProfile...\n    // ...update the flight.drawName with the drawName in the drawDefinition\n    flight.drawName = drawDefinition.drawName;\n    extension = {\n      name: FLIGHT_PROFILE,\n      value: {\n        ...flightProfile,\n        flights: flightProfile.flights,\n      },\n    };\n\n    const flightNumber = flight.flightNumber;\n    if (flightNumber && !drawOrders.includes(flightNumber)) {\n      drawOrder = flightNumber;\n    } else {\n      flight.flightNumber = drawOrder;\n    }\n  } else {\n    const flights = flightProfile?.flights || [];\n    flights.push({\n      manuallyAdded: true, // this drawDefinition was not part of automated split\n      flightNumber: drawOrder,\n      drawEntries,\n      drawName,\n      drawId,\n    });\n    extension = {\n      name: FLIGHT_PROFILE,\n      value: {\n        ...(flightProfile || {}),\n        flights,\n      },\n    };\n  }\n\n  addEventExtension({ event, extension });\n  Object.assign(drawDefinition, { drawOrder });\n\n  const existingDrawDefinition = event.drawDefinitions.find(\n    (drawDefinition) => drawDefinition.drawId === drawId\n  );\n  const tournamentId = tournamentRecord?.tournamentId;\n  const eventId: string = event.eventId;\n\n  if (existingDrawDefinition) {\n    if (!allowReplacement) {\n      return { error: DRAW_ID_EXISTS };\n    }\n    // find matchUps added/removed\n    const existingMatchUps = allDrawMatchUps({\n      drawDefinition: existingDrawDefinition,\n    })?.matchUps;\n    const existingMatchUpIds: string[] =\n      existingMatchUps?.map(getMatchUpId) ?? [];\n    const incomingMatchUps = allDrawMatchUps({\n      drawDefinition,\n    })?.matchUps;\n\n    if (!suppressNotifications) {\n      // all existing are deleted and then re-added to handle back-end created Id issues\n      if (existingMatchUpIds?.length) {\n        deleteMatchUpsNotice({\n          matchUpIds: existingMatchUpIds,\n          action: 'modifyDrawDefinition',\n          tournamentId,\n          eventId,\n        });\n      }\n      if (incomingMatchUps?.length) {\n        addMatchUpsNotice({\n          matchUps: incomingMatchUps,\n          tournamentId,\n          eventId,\n        });\n      }\n\n      // replace the existing drawDefinition with the updated version\n      event.drawDefinitions = event.drawDefinitions.map((d) =>\n        d.drawId === drawId ? drawDefinition : d\n      );\n\n      const structureIds = drawDefinition.structures?.map(\n        ({ structureId }) => structureId\n      );\n      modifyDrawNotice({ drawDefinition, tournamentId, structureIds, eventId });\n    }\n  } else {\n    event.drawDefinitions.push(drawDefinition);\n\n    if (!suppressNotifications) {\n      const { matchUps } = allDrawMatchUps({ drawDefinition, event });\n      matchUps &&\n        addMatchUpsNotice({\n          tournamentId: tournamentRecord?.tournamentId,\n          matchUps,\n        });\n\n      addDrawNotice({ drawDefinition, tournamentId, eventId });\n    }\n  }\n\n  return { ...SUCCESS, modifiedEventEntryStatusCount };\n}\n","import { definedAttributes } from '../../utilities/definedAttributes';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { addNotice } from '../../global/state/globalState';\nimport { addParticipant } from './addParticipant';\nimport { UUID } from '../../utilities/UUID';\n\nimport { Participant, Tournament } from '../../types/tournamentTypes';\nimport { ADD_PARTICIPANTS } from '../../constants/topicConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { INDIVIDUAL } from '../../constants/participantConstants';\nimport { MISSING_TOURNAMENT_RECORD, EXISTING_PARTICIPANT } from '../../constants/errorConditionConstants';\n\ntype AddParticipantsType = {\n  allowDuplicateParticipantIdPairs?: boolean;\n  returnParticipants?: boolean;\n  participants?: Participant[];\n  tournamentRecord: Tournament;\n};\n\nexport function addParticipants({\n  allowDuplicateParticipantIdPairs,\n  returnParticipants,\n  tournamentRecord,\n  participants = [],\n}: AddParticipantsType) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!tournamentRecord.participants) tournamentRecord.participants = [];\n  const tournamentParticipants = tournamentRecord.participants;\n\n  const existingParticipantIds = tournamentParticipants.map((p) => p.participantId) || [];\n\n  participants.forEach((participant) => {\n    if (!participant.participantId) participant.participantId = UUID();\n  });\n\n  const newParticipants = participants.filter(\n    (participant) => !existingParticipantIds.includes(participant.participantId),\n  );\n\n  const notAdded = participants.filter((participant) => existingParticipantIds.includes(participant.participantId));\n\n  const individualParticipants = newParticipants.filter((participant) => participant.participantType === INDIVIDUAL);\n\n  const groupedParticipants = newParticipants.filter((participant) => participant.participantType !== INDIVIDUAL);\n\n  // add individual participants first so that grouped participants which include them are valid\n  const participantsToAdd = individualParticipants.concat(...groupedParticipants);\n\n  const addedParticipants: Participant[] = [];\n  if (participantsToAdd.length) {\n    for (const participant of participantsToAdd) {\n      const result = addParticipant({\n        allowDuplicateParticipantIdPairs,\n        returnParticipant: true,\n        disableNotice: true,\n        tournamentRecord,\n        participant,\n      });\n      if (result.error) return result;\n\n      if (result.success && !result.existingParticipant) addedParticipants.push(result.participant);\n    }\n\n    if (addedParticipants.length) {\n      addNotice({\n        topic: ADD_PARTICIPANTS,\n        payload: {\n          tournamentId: tournamentRecord.tournamentId,\n          participants: addedParticipants,\n        },\n      });\n    }\n\n    const result = {\n      participants: returnParticipants && makeDeepCopy(addedParticipants),\n      addedCount: addedParticipants.length,\n      ...SUCCESS,\n    };\n\n    if (notAdded.length) {\n      Object.assign(result, { notAdded, info: EXISTING_PARTICIPANT });\n    }\n\n    return definedAttributes(result);\n  } else {\n    return {\n      info: 'No new participants to add',\n      addedCount: 0,\n      ...SUCCESS,\n    };\n  }\n}\n","import { resolveTieFormat } from '../../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { isConvertableInteger } from '../../../utilities/math';\nimport { generateRange } from '../../../utilities/arrays';\nimport { generateTieMatchUps } from './tieMatchUps';\nimport { UUID } from '../../../utilities/UUID';\n\nimport { DrawDefinition, EntryStatusUnion, Event, MatchUp, Tournament } from '../../../types/tournamentTypes';\nimport { STRUCTURE_SELECTED_STATUSES } from '../../../constants/entryStatusConstants';\nimport { ROUND_OUTCOME } from '../../../constants/drawDefinitionConstants';\nimport { TO_BE_PLAYED } from '../../../constants/matchUpStatusConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { TEAM } from '../../../constants/matchUpTypes';\nimport {\n  INVALID_VALUES,\n  INVALID_STRUCTURE,\n  MISSING_DRAW_DEFINITION,\n  MISSING_STRUCTURE_ID,\n  STRUCTURE_NOT_FOUND,\n  ErrorType,\n} from '../../../constants/errorConditionConstants';\n\ntype GenerateAdHocMatchUpsArgs = {\n  participantIdPairings?: {\n    participantIds: [string | undefined, string | undefined];\n  }[];\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpsCount?: number; // number of matchUps to be generated\n  matchUpIds?: string[];\n  roundNumber?: number;\n  structureId?: string;\n  newRound?: boolean; // optional - whether to auto-increment to the next roundNumber\n  idPrefix?: string;\n  isMock?: boolean;\n  event: Event;\n};\n\nexport function generateAdHocMatchUps(params: GenerateAdHocMatchUpsArgs): {\n  matchUpsCount?: number;\n  matchUps?: MatchUp[];\n  error?: ErrorType;\n  info?: any;\n} {\n  const { matchUpIds = [], drawDefinition, roundNumber, newRound, isMock, event } = params;\n  if (typeof drawDefinition !== 'object') return { error: MISSING_DRAW_DEFINITION };\n  let { participantIdPairings, matchUpsCount } = params;\n\n  const structureId =\n    params.structureId ?? (drawDefinition.structures?.length === 1 && drawDefinition.structures?.[0]?.structureId);\n\n  if (typeof structureId !== 'string') return { error: MISSING_STRUCTURE_ID };\n\n  // if drawDefinition and structureId are provided it is possible to infer roundNumber\n  const structure = drawDefinition.structures?.find((structure) => structure.structureId === structureId);\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  let structureHasRoundPositions;\n  const existingMatchUps = structure.matchUps ?? [];\n  const lastRoundNumber = existingMatchUps?.reduce((roundNumber: number, matchUp: any) => {\n    if (matchUp.roundPosition) structureHasRoundPositions = true;\n    return (matchUp?.roundNumber || 0) > roundNumber ? matchUp.roundNumber : roundNumber;\n  }, 0);\n\n  if (!matchUpsCount) {\n    const selectedEntries =\n      drawDefinition?.entries?.filter((entry) => {\n        const entryStatus = entry.entryStatus as EntryStatusUnion;\n        return STRUCTURE_SELECTED_STATUSES.includes(entryStatus);\n      }) ?? [];\n    const roundMatchUpsCount = Math.floor(selectedEntries?.length / 2) || 1;\n\n    if (newRound) {\n      matchUpsCount = roundMatchUpsCount;\n    } else {\n      const targetRoundNumber = roundNumber ?? lastRoundNumber ?? 1;\n      const existingRoundMatchUps =\n        structure.matchUps?.filter((matchUp) => matchUp.roundNumber === targetRoundNumber)?.length ?? 0;\n      const maxRemaining = roundMatchUpsCount - existingRoundMatchUps;\n      if (maxRemaining > 0) matchUpsCount = maxRemaining;\n    }\n  }\n\n  if (\n    (participantIdPairings && !Array.isArray(participantIdPairings)) ||\n    (matchUpsCount && !isConvertableInteger(matchUpsCount)) ||\n    (matchUpIds && !Array.isArray(matchUpIds)) ||\n    (!participantIdPairings && !matchUpsCount)\n  ) {\n    return { error: INVALID_VALUES, info: 'matchUpsCount or pairings error' };\n  }\n\n  // structure must not be a container of other structures\n  // structure must not contain matchUps with roundPosition\n  // structure must not determine finishingPosition by ROUND_OUTCOME\n  if (structure.structures || structureHasRoundPositions || structure.finishingPosition === ROUND_OUTCOME) {\n    return { error: INVALID_STRUCTURE };\n  }\n\n  if (roundNumber && roundNumber - 1 > (lastRoundNumber || 0))\n    return { error: INVALID_VALUES, info: 'roundNumber error' };\n\n  const nextRoundNumber = roundNumber ?? ((newRound && (lastRoundNumber ?? 0) + 1) || lastRoundNumber || 1);\n\n  participantIdPairings =\n    participantIdPairings ??\n    generateRange(0, matchUpsCount).map(() => ({\n      participantIds: [undefined, undefined],\n    }));\n\n  const getPrefixedId = (index: number) => {\n    if (!params.idPrefix && !isMock) return undefined;\n    const drawId = drawDefinition.drawId;\n    const idPrefix = params.idPrefix ?? 'ah';\n    return `${drawId}-${idPrefix}-${nextRoundNumber}-${index}`;\n  };\n\n  const matchUps = participantIdPairings?.map((pairing, i) => {\n    const idStack = pairing?.participantIds ?? [undefined, undefined];\n    // ensure there are always 2 sides in generated matchUps\n    idStack.push(...[undefined, undefined]);\n    const participantIds = idStack.slice(0, 2);\n    const sides = participantIds.map((participantId, i) =>\n      definedAttributes({\n        sideNumber: i + 1,\n        participantId,\n      }),\n    );\n\n    const matchUpId = matchUpIds[i] ?? getPrefixedId(i) ?? UUID();\n\n    return {\n      roundNumber: nextRoundNumber,\n      matchUpStatus: TO_BE_PLAYED,\n      matchUpId,\n      sides,\n    };\n  });\n\n  if (matchUps?.length) {\n    const tieFormat = resolveTieFormat({ drawDefinition, event })?.tieFormat;\n\n    if (tieFormat) {\n      matchUps.forEach((matchUp) => {\n        const { tieMatchUps } = generateTieMatchUps({\n          tieFormat,\n          matchUp,\n          isMock,\n        });\n        Object.assign(matchUp, { tieMatchUps, matchUpType: TEAM });\n      });\n    }\n  }\n\n  return { matchUpsCount: matchUps?.length ?? 0, matchUps, ...SUCCESS };\n}\n","import { stringSort } from '../../../../functions/sorters/stringSort';\nimport {\n  chunkArray,\n  randomPop,\n  shuffleArray,\n} from '../../../../utilities/arrays';\n\ntype GenerateCandidateArgs = {\n  valueSortedPairings: { [key: string]: number }[];\n  deltaObjects: { [key: string]: number };\n  valueObjects: { [key: string]: number };\n  maxIterations: number;\n  pairingValues: any;\n};\n\nexport function generateCandidate({\n  maxIterations = 4000, // cap the processing intensity of the candidate generator\n  valueSortedPairings, // pairings sorted by value from low to high\n  pairingValues,\n  valueObjects,\n  deltaObjects,\n}: GenerateCandidateArgs) {\n  const pairingValueMap = Object.assign(\n    {},\n    ...valueSortedPairings.map((rm) => ({ [rm.pairing]: rm.value }))\n  );\n\n  const actors = Object.keys(pairingValues);\n  let proposedCandidates: any[] = [];\n\n  // generate an initial candidate value with no stipulated pairings\n  const initialProposal = roundCandidate({\n    actorsCount: actors.length,\n    valueSortedPairings,\n    pairingValueMap,\n    deltaObjects,\n    valueObjects,\n  });\n\n  const candidateHashes: any[] = [candidateHash(initialProposal)];\n  proposedCandidates.push(initialProposal);\n  let lowCandidateValue = initialProposal.value;\n  let deltaCandidate = initialProposal;\n\n  // iterations is the number of loops over valueSortedPairings\n  let candidatesCount = 0;\n  let iterations = 0;\n\n  let opponentCount = actors.length;\n  let calculatedIterations;\n\n  // calculate the number of opponents to consider for each participantId\n  do {\n    opponentCount -= 1;\n    calculatedIterations = actors.length * pairingValues[actors[0]].length;\n  } while (calculatedIterations > maxIterations && opponentCount > 5);\n\n  // keep track of proposed pairings\n  const stipulatedPairs: string[] = [];\n\n  // for each actor generate a roundCandidate using opponentCount of pairing values\n  actors.forEach((actor) => {\n    const participantIdPairings = pairingValues[actor];\n\n    // opponentCount limits the number of opponents to consider\n    participantIdPairings.slice(0, opponentCount).forEach((pairing) => {\n      iterations += 1;\n      const stipulatedPair = pairingHash(actor, pairing.opponent);\n\n      if (!stipulatedPairs.includes(stipulatedPair)) {\n        const proposed = roundCandidate({\n          // each roundCandidate starts with stipulated pairings\n          stipulated: [[actor, pairing.opponent]],\n          actorsCount: actors.length,\n          valueSortedPairings,\n          pairingValueMap,\n          deltaObjects,\n          valueObjects,\n        });\n\n        // ensure no duplicate candidates are considered\n        if (!candidateHashes.includes(candidateHash(proposed))) {\n          candidateHashes.push(candidateHash(proposed));\n          proposedCandidates.push(proposed);\n\n          const { maxDelta, value } = proposed;\n\n          if (maxDelta < deltaCandidate.maxDelta) deltaCandidate = proposed;\n\n          if (\n            value < lowCandidateValue ||\n            (value === lowCandidateValue && Math.round(Math.random())) // randomize if equivalent values\n          ) {\n            lowCandidateValue = value;\n          }\n\n          stipulatedPairs.push(stipulatedPair);\n          candidatesCount += 1;\n        }\n      }\n    });\n    proposedCandidates = proposedCandidates.filter(\n      (proposed) => Math.abs(proposed.value - lowCandidateValue) < 5\n    );\n  });\n\n  proposedCandidates.sort((a, b) => a.maxDiff - b.maxDiff);\n  const candidate = randomPop(proposedCandidates);\n\n  return {\n    candidatesCount,\n    deltaCandidate,\n    maxIterations,\n    iterations,\n    candidate,\n  };\n}\n\nfunction candidateHash(candidate) {\n  return candidate.participantIdPairings\n    .map(({ participantIds }) => participantIds.sort().join('|'))\n    .sort()\n    .join('/');\n}\n\ntype RoundCandiateArgs = {\n  pairingValueMap: any;\n  valueSortedPairings: any;\n  actorsCount: number;\n  stipulated?: any[];\n  deltaObjects: any;\n  valueObjects: any;\n};\nfunction roundCandidate({\n  valueSortedPairings,\n  stipulated = [],\n  pairingValueMap,\n  deltaObjects,\n  valueObjects,\n  actorsCount,\n}: RoundCandiateArgs) {\n  // roundPlayers starts with the stipulated pairing\n  const roundPlayers: any[] = [].concat(...stipulated);\n\n  // aggregates the pairings generated for a roundCandidate\n  const participantIdPairings: any[] = [];\n\n  // candidateValue is the sum of all participantIdPairings in a roundCandidate\n  // the winning candidate has the LOWEST total value\n  let candidateValue = 0;\n\n  // candidateValue is initialized with any stipulated pairings\n  stipulated.filter(Boolean).forEach((participantIds) => {\n    const [p1, p2] = participantIds;\n    const pairing = pairingHash(p1, p2);\n    const value = pairingValueMap[pairing];\n    participantIdPairings.push({ participantIds, value });\n    candidateValue += pairingValueMap[pairing];\n  });\n\n  // valueSortedPairings is an array sorted from lowest value to highest value\n  // introduce random shuffling of chunks of valueSortedPairings\n  const consideredPairings = chunkArray(valueSortedPairings, actorsCount)\n    .map((pairings) =>\n      shuffleArray(pairings).map((pairing) => ({\n        ...pairing,\n        value: pairing.value + Math.random() * Math.round(Math.random()),\n      }))\n    )\n    .flat();\n\n  // go through the valueSortedPairings (of all possible unique pairings)\n  consideredPairings.forEach((rankedPairing) => {\n    const participantIds = rankedPairing.pairing.split('|');\n    const opponentExists = participantIds.reduce(\n      (p, c) => roundPlayers.includes(c) || p,\n      false\n    );\n\n    if (!opponentExists) {\n      roundPlayers.push(...participantIds);\n      const value = rankedPairing.value;\n      candidateValue += value;\n      participantIdPairings.push({ participantIds, value });\n    }\n  });\n\n  // sort the candidate's proposed pairings by value\n  participantIdPairings.sort((a, b) => a.value - b.value);\n\n  // determine the greatest delta in the candidate's pairings\n  const maxDelta = participantIdPairings.reduce((p, c) => {\n    const [p1, p2] = c.participantIds;\n    const hash = pairingHash(p1, p2);\n    const delta = deltaObjects[hash];\n    return delta > p ? delta : p;\n  }, 0);\n\n  // determine the greatest delta in the candidate's pairings\n  const maxDiff = participantIdPairings.reduce((p, c) => {\n    const [p1, p2] = c.participantIds;\n    const hash = pairingHash(p1, p2);\n    const diff = valueObjects[hash];\n    return diff > p ? diff : p;\n  }, 0);\n\n  return { value: candidateValue, participantIdPairings, maxDelta, maxDiff };\n}\n\nexport function pairingHash(id1, id2) {\n  return [id1, id2].sort(stringSort).join('|');\n}\n","import { pairingHash } from './generateCandidate';\n\nexport function getPairingsData({ participantIds }) {\n  const possiblePairings = {};\n  const uniquePairings: any = [];\n\n  participantIds.forEach((participantId) => {\n    possiblePairings[participantId] = participantIds.filter(\n      (id) => id !== participantId\n    );\n    possiblePairings[participantId].forEach((id) => {\n      const pairing = pairingHash(id, participantId);\n      if (!uniquePairings.includes(pairing)) uniquePairings.push(pairing);\n    });\n  });\n\n  const deltaObjects = Object.assign(\n    {},\n    ...uniquePairings.map((pairing) => ({ [pairing]: 0 }))\n  );\n  return { uniquePairings, possiblePairings, deltaObjects };\n}\n","export const ELO = 'ELO';\nexport const NTRP = 'NTRP';\nexport const TRN = 'TRN';\nexport const UTR = 'UTR';\nexport const WTN = 'WTN';\n\nexport const ratingConstants = {\n  ELO,\n  NTRP,\n  TRN,\n  UTR,\n  WTN,\n};\n\nexport default ratingConstants;\n","import { ELO, NTRP, UTR, WTN } from '../../constants/ratingConstants';\n\nexport const ratingsParameters = {\n  [ELO]: {\n    defaultInitialization: 1500,\n    decimalsCount: 0,\n    range: [0, 3000],\n    ascending: true,\n  },\n  [NTRP]: {\n    accessors: ['ntrpRating', 'dntrpRatingHundredths'],\n    attributes: { ustaRatingType: '' },\n    accessor: 'dntrpRatingHundredths',\n    defaultInitialization: 3,\n    decimalsCount: 1,\n    ascending: true,\n    range: [1, 7],\n  },\n  [UTR]: {\n    defaultInitialization: 6,\n    accessors: ['utrRating'],\n    accessor: 'utrRating',\n    decimalsCount: 2,\n    ascending: true,\n    range: [1, 16],\n  },\n  [WTN]: {\n    attributes: { confidence: { generator: true, range: [60, 100] } },\n    accessors: ['wtnRating', 'confidence'],\n    defaultInitialization: 23,\n    accessor: 'wtnRating',\n    ascending: false,\n    decimalsCount: 2,\n    range: [40, 1],\n  },\n};\n\nexport default ratingsParameters;\n","import ratingsParameters from '../../../../fixtures/ratings/ratingsParameters';\nimport { DOUBLES } from '../../../../constants/eventConstants';\n\nconst DEFAULT_RATING = 0;\n\nexport function getSideRatings({\n  tournamentParticipants,\n  adHocRatings,\n  eventType,\n  scaleName,\n  pairing,\n}) {\n  const defaultRating =\n    ratingsParameters[scaleName]?.defaultInitialization ?? DEFAULT_RATING;\n  return pairing.split('|').map((participantId) => {\n    if (eventType === DOUBLES) {\n      const individualParticipantIds = tournamentParticipants?.find(\n        (participant) => participant.participantId === participantId\n      )?.individualParticipantIds;\n      return !individualParticipantIds\n        ? defaultRating * 2\n        : individualParticipantIds?.map(\n            (participantId) => adHocRatings[participantId] || defaultRating\n          );\n    } else {\n      return adHocRatings[participantId] || defaultRating;\n    }\n  });\n}\n","import { getParticipantPairingValues } from './getParticipantPairingValues';\nimport { generateCandidate } from './generateCandidate';\nimport { getSideRatings } from './getSideRatings';\n\nexport function getPairings({\n  tournamentParticipants,\n  adHocRatings = {},\n  possiblePairings, // participant keyed; provides array of possible opponents\n  uniquePairings, // hashes of all possible participantId pairings\n  maxIterations,\n  deltaObjects, // difference in rating between paired participants\n  valueObjects, // calculated value of a pairing of participants, used for sorting pairings\n  eventType,\n  scaleName,\n  salted,\n}) {\n  // modify valueObjects by ratings ratingsDifference squared\n  // update deltaObjects to reflect the current difference between participant's ratings\n  uniquePairings.forEach((pairing) => {\n    const ratings = getSideRatings({\n      tournamentParticipants,\n      adHocRatings,\n      scaleName,\n      eventType,\n      pairing,\n    });\n\n    const salting = (typeof salted === 'number' && salted) || 0.5;\n    const salt =\n      (salted && (Math.round(Math.random()) ? salting : salting * -1)) || 0;\n    const ratingsDifference = Math.abs(ratings[0] - ratings[1]) + salt;\n    const pairingDelta = Math.abs(ratings[0] - ratings[1]);\n    deltaObjects[pairing] = pairingDelta;\n\n    if (!valueObjects[pairing]) valueObjects[pairing] = 0;\n    valueObjects[pairing] += ratingsDifference\n      ? Math.pow(ratingsDifference, 2)\n      : 0;\n  });\n\n  /**\n   * valueSortedPairings are uniquePairings sorted by the ratings difference of the pairings, lowest to highest\n   */\n  const valueSortedPairings = uniquePairings\n    .map((pairing) => ({ pairing, value: valueObjects[pairing] }))\n    .sort((a, b) => a.value - b.value);\n\n  /**\n   * pairingValues is keyed by participantId and provides a value-sorted array of pairings for each participantId\n   * 'actorId': [\n        { opponent: 'potentialId1', value: 1 },\n        { opponent: 'potentialId2', value: 1 },\n   */\n  const { pairingValues } = getParticipantPairingValues({\n    possiblePairings,\n    valueObjects,\n  });\n\n  const { candidate, candidatesCount, deltaCandidate, iterations } =\n    generateCandidate({\n      valueSortedPairings,\n      maxIterations,\n      pairingValues,\n      deltaObjects,\n      valueObjects,\n    });\n\n  const { participantIdPairings } = candidate;\n\n  return {\n    participantIdPairings,\n    candidatesCount,\n    deltaCandidate,\n    iterations,\n    candidate,\n  };\n}\n","import { pairingHash } from './generateCandidate';\n\nexport function getParticipantPairingValues({\n  possiblePairings,\n  valueObjects,\n}) {\n  const pairingValues = {};\n\n  for (const participantId of Object.keys(possiblePairings)) {\n    const participantValues = possiblePairings[participantId].map((opponent) =>\n      pairingValue(participantId, opponent)\n    );\n    pairingValues[participantId] = participantValues.sort(\n      (a, b) => a.value - b.value\n    );\n  }\n\n  function pairingValue(participantId, opponent) {\n    const key = pairingHash(participantId, opponent);\n    return { opponent, value: valueObjects[key] };\n  }\n  return { pairingValues };\n}\n","import { generateAdHocMatchUps } from '../generateAdHocMatchUps';\nimport { findStructure } from '../../../../acquire/findStructure';\nimport { isObject } from '../../../../utilities/objects';\nimport { getPairingsData } from './getPairingsData';\nimport { getEncounters } from './getEncounters';\nimport { getPairings } from './getPairings';\n\nimport { DrawDefinition, MatchUp, Structure, EventTypeUnion, Event } from '../../../../types/tournamentTypes';\nimport { ResultType } from '../../../../global/functions/decorateResult';\nimport { TEAM } from '../../../../constants/participantConstants';\nimport { HydratedParticipant } from '../../../../types/hydrated';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport {\n  MISSING_DRAW_DEFINITION,\n  MISSING_PARTICIPANT_IDS,\n  MISSING_STRUCTURE,\n  NO_CANDIDATES,\n  STRUCTURE_NOT_FOUND,\n} from '../../../../constants/errorConditionConstants';\n\n// this should be in policyDefinitions\nconst ENCOUNTER_VALUE = 100;\nconst SAME_TEAM_VALUE = 100;\n\nconst MAX_ITERATIONS = 4000;\n\ntype GenerateDrawMaticRoundArgs = {\n  tournamentParticipants?: HydratedParticipant[];\n  adHocRatings?: { [key: string]: number };\n  restrictEntryStatus?: boolean;\n  drawDefinition: DrawDefinition;\n  generateMatchUps?: boolean;\n  eventType?: EventTypeUnion;\n  salted?: number | boolean;\n  participantIds?: string[];\n  encounterValue?: number;\n  sameTeamValue?: number;\n  maxIterations?: number;\n  matchUpIds?: string[];\n  structure?: Structure;\n  structureId?: string;\n  scaleName?: string;\n  idPrefix?: string;\n  isMock?: boolean;\n  drawId?: string;\n  event: Event;\n};\n\nexport type DrawMaticRoundResult = {\n  participantIdPairings?: string[][];\n  candidatesCount?: number;\n  matchUps?: MatchUp[];\n  iterations?: number;\n  success?: boolean;\n  maxDelta?: number;\n  maxDiff?: number;\n};\n\nexport function generateDrawMaticRound({\n  encounterValue = ENCOUNTER_VALUE,\n  sameTeamValue = SAME_TEAM_VALUE,\n  maxIterations = MAX_ITERATIONS,\n  generateMatchUps = true,\n  tournamentParticipants,\n  participantIds,\n  drawDefinition,\n  adHocRatings,\n  structureId,\n  salted = 0.5,\n  matchUpIds,\n  eventType,\n  structure,\n  scaleName,\n  idPrefix,\n  isMock,\n  event,\n}: GenerateDrawMaticRoundArgs): ResultType & DrawMaticRoundResult {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structure && !structureId) return { error: STRUCTURE_NOT_FOUND };\n  if (!structure) {\n    structure = findStructure({ drawDefinition, structureId }).structure;\n  }\n  if (!isObject(structure)) return { error: MISSING_STRUCTURE };\n\n  if (!participantIds?.length) {\n    return { error: MISSING_PARTICIPANT_IDS };\n  }\n\n  // create valueObject for each previous encounter within the structure\n  const { encounters } = getEncounters({ matchUps: structure?.matchUps ?? [] });\n  // valueObjects provide \"weighting\" to each possible pairing of participants\n  // {\n  //  'P-I-0|P-I-1': 1,\n  //  'P-I-0|P-I-2': 1,\n  //  'P-I-0|P-I-3': 1\n  // }\n\n  const valueObjects: any = {};\n  for (const pairing of encounters) {\n    if (!valueObjects[pairing]) valueObjects[pairing] = 0;\n    valueObjects[pairing] += encounterValue;\n  }\n\n  const teamParticipants = tournamentParticipants?.filter(({ participantType }) => participantType === TEAM);\n  if (teamParticipants) {\n    // add SAME_TEAM_VALUE for participants who appear on the same team\n    for (const teamParticipant of teamParticipants) {\n      const participantIds = teamParticipant.individualParticipantIds ?? [];\n      const { uniquePairings } = getPairingsData({ participantIds });\n      for (const pairing of uniquePairings) {\n        if (!valueObjects[pairing]) valueObjects[pairing] = 0;\n        valueObjects[pairing] += sameTeamValue;\n      }\n    }\n  }\n\n  // deltaObjects contain the difference in ratings between two participants\n  // {\n  //  'P-I-0|P-I-1': 0,\n  //  'P-I-0|P-I-2': 0,\n  //  'P-I-0|P-I-3': 0\n  // }\n  const { uniquePairings, possiblePairings, deltaObjects } = getPairingsData({\n    participantIds,\n  });\n\n  const params = {\n    tournamentParticipants,\n    possiblePairings,\n    drawDefinition,\n    participantIds,\n    uniquePairings,\n    maxIterations,\n    adHocRatings,\n    deltaObjects,\n    valueObjects,\n    eventType,\n    scaleName,\n    structure,\n    salted,\n  };\n\n  const { candidatesCount, participantIdPairings, iterations, candidate } = getPairings(params);\n\n  if (!candidatesCount) return { error: NO_CANDIDATES };\n\n  let matchUps;\n  if (generateMatchUps) {\n    const result = generateAdHocMatchUps({\n      structureId: structure?.structureId,\n      participantIdPairings,\n      newRound: true,\n      drawDefinition,\n      matchUpIds,\n      idPrefix,\n      isMock,\n      event,\n    });\n    if (result.error) return result;\n    matchUps = result.matchUps;\n  }\n\n  const { maxDelta, maxDiff } = candidate;\n\n  return {\n    ...SUCCESS,\n    participantIdPairings,\n    candidatesCount,\n    iterations,\n    matchUps,\n    maxDelta,\n    maxDiff,\n  };\n}\n","import { xa } from '../../../../utilities/objects';\nimport { pairingHash } from './generateCandidate';\n\nexport function getEncounters({ matchUps }) {\n  const encounters: any = [];\n\n  for (const matchUp of matchUps) {\n    const participantIds = matchUp.sides.map(xa('participantId'));\n    if (participantIds.length === 2) {\n      const [p1, p2] = participantIds;\n      const pairing = pairingHash(p1, p2);\n      if (!encounters.includes(pairing)) encounters.push(pairing);\n    }\n  }\n\n  return { encounters };\n}\n","import { participantScaleItem } from '../../../../query/participant/participantScaleItem';\nimport { generateDrawMaticRound, DrawMaticRoundResult } from './generateDrawMaticRound';\nimport { getParticipantId } from '../../../../global/functions/extractors';\nimport { isAdHoc } from '../../../../query/drawDefinition/isAdHoc';\nimport { isObject } from '../../../../utilities/objects';\n\nimport { STRUCTURE_SELECTED_STATUSES } from '../../../../constants/entryStatusConstants';\nimport { ResultType, decorateResult } from '../../../../global/functions/decorateResult';\nimport { AD_HOC, stageOrder } from '../../../../constants/drawDefinitionConstants';\nimport { DYNAMIC, RATING } from '../../../../constants/scaleConstants';\nimport { SINGLES_EVENT } from '../../../../constants/eventConstants';\nimport { ScaleAttributes } from '../../../../types/factoryTypes';\nimport {\n  DrawDefinition,\n  EntryStatusUnion,\n  Event,\n  Structure,\n  Tournament,\n  EventTypeUnion,\n} from '../../../../types/tournamentTypes';\nimport {\n  INVALID_DRAW_DEFINITION,\n  INVALID_PARTICIPANT_ID,\n  INVALID_VALUES,\n  STRUCTURE_NOT_FOUND,\n} from '../../../../constants/errorConditionConstants';\n\nexport type DrawMaticArgs = {\n  adHocRatings?: { [key: string]: number };\n  restrictEntryStatus?: boolean;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  generateMatchUps?: boolean;\n  eventType?: EventTypeUnion;\n  salted?: number | boolean;\n  participantIds?: string[];\n  encounterValue?: number;\n  sameTeamValue?: number;\n  maxIterations?: number;\n  structure?: Structure;\n  matchUpIds?: string[];\n  structureId?: string;\n  idPrefix?: string;\n  isMock?: boolean;\n  event: Event;\n\n  scaleAccessor?: string;\n  scaleName?: string;\n};\n\nexport function drawMatic(params: DrawMaticArgs): ResultType & DrawMaticRoundResult {\n  const {\n    restrictEntryStatus,\n    adHocRatings = {},\n    generateMatchUps,\n    tournamentRecord,\n    encounterValue,\n    sameTeamValue,\n    drawDefinition,\n    scaleAccessor,\n    maxIterations,\n    matchUpIds,\n    scaleName, // custom rating name to seed dynamic ratings\n    idPrefix,\n    salted,\n    event,\n  } = params;\n\n  if (typeof drawDefinition !== 'object' || (drawDefinition.drawType && drawDefinition.drawType !== AD_HOC)) {\n    return { error: INVALID_DRAW_DEFINITION };\n  }\n\n  let { participantIds, structureId } = params;\n  const isMock = tournamentRecord?.isMock ?? params.isMock;\n\n  if (!Array.isArray(drawDefinition?.entries) && participantIds && !Array.isArray(participantIds)) {\n    return { error: INVALID_VALUES, info: 'Missing Entries' };\n  }\n\n  const eventType = params.eventType ?? event?.eventType;\n\n  const enteredParticipantIds = drawDefinition?.entries\n    ?.filter((entry) => {\n      const entryStatus = entry.entryStatus as EntryStatusUnion;\n      return !restrictEntryStatus || STRUCTURE_SELECTED_STATUSES.includes(entryStatus);\n    })\n    .map(getParticipantId);\n\n  if (participantIds) {\n    // ensure all participantIds are in drawDefinition.entries\n    const invalidParticipantIds = participantIds.filter(\n      (participantId) => !enteredParticipantIds?.includes(participantId),\n    );\n\n    if (invalidParticipantIds?.length)\n      return decorateResult({\n        result: { error: INVALID_PARTICIPANT_ID },\n        info: { invalidParticipantIds },\n      });\n  } else {\n    participantIds = enteredParticipantIds;\n  }\n\n  // if no structureId is specified find the latest AD_HOC stage which has matchUps\n  if (!structureId) {\n    const targetStructure = drawDefinition?.structures\n      ?.filter((structure) => structure.stageSequence === 1)\n      ?.reduce((targetStructure: any, structure: any) => {\n        const orderNumber = structure.stage && stageOrder[structure.stage];\n        const structureIsAdHoc = isAdHoc({ drawDefinition, structure });\n\n        return structureIsAdHoc && orderNumber > (stageOrder[targetStructure?.stage] || 1)\n          ? structure\n          : targetStructure;\n      }, undefined);\n    structureId = targetStructure?.structureId;\n  }\n\n  const structure = drawDefinition?.structures?.find((structure) => structure.structureId === structureId);\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  // an AD_HOC structure is one that has no child structures and in which no matchUps have roundPosition\n  const structureIsAdHoc = isAdHoc({ drawDefinition, structure });\n  if (!structureIsAdHoc) return { error: INVALID_DRAW_DEFINITION };\n\n  const tournamentParticipants = tournamentRecord.participants ?? [];\n  for (const participantId of participantIds ?? []) {\n    const participant = tournamentParticipants?.find((participant) => participant.participantId === participantId);\n    // first see if there is already a dynamic value\n    let scaleValue = getScaleValue({\n      scaleName: `${scaleName}.${DYNAMIC}`,\n      scaleAccessor,\n      participant,\n      eventType,\n    });\n    // if no dynamic value found and a seeding scaleValue is provided...\n    if (!scaleValue && scaleName) {\n      scaleValue = getScaleValue({\n        scaleAccessor,\n        participant,\n        scaleName,\n        eventType,\n      });\n    }\n\n    if (scaleValue && !adHocRatings[participantId]) adHocRatings[participantId] = scaleValue;\n  }\n\n  // TODO: update dynamic ratings based on matchUps present from last played round\n  // use scaleEngine.generateDynamicRatings(); see dynamicCalculations.test.ts\n\n  return generateDrawMaticRound({\n    tournamentParticipants,\n    generateMatchUps,\n    participantIds,\n    encounterValue,\n    sameTeamValue,\n    drawDefinition,\n    maxIterations,\n    adHocRatings,\n    matchUpIds,\n    structure,\n    eventType,\n    idPrefix,\n    salted,\n    isMock,\n    event,\n  });\n}\n\ntype GetScaleValueArgs = {\n  scaleAccessor?: string;\n  eventType?: EventTypeUnion;\n  scaleType?: string;\n  scaleName: string;\n  participant: any;\n};\n\nfunction getScaleValue({ scaleType = RATING, scaleAccessor, participant, scaleName, eventType }: GetScaleValueArgs) {\n  const scaleAttributes: ScaleAttributes = {\n    eventType: eventType ?? SINGLES_EVENT,\n    scaleType,\n    scaleName,\n  };\n  const result =\n    participant &&\n    participantScaleItem({\n      scaleAttributes,\n      participant,\n    });\n\n  const scaleValue = result?.scaleItem?.scaleValue;\n  return scaleAccessor && isObject(scaleValue) ? scaleValue[scaleAccessor] : scaleValue;\n}\n","import { allTournamentMatchUps } from '../../query/matchUps/getAllTournamentMatchUps';\nimport { getMatchUpId } from '../../global/functions/extractors';\nimport { mustBeAnArray } from '../../utilities/mustBeAnArray';\nimport { validMatchUps } from '../../validators/validMatchUp';\nimport { overlap } from '../../utilities/arrays';\nimport {\n  addMatchUpsNotice,\n  modifyDrawNotice,\n} from '../notifications/drawNotifications';\n\nimport { ROUND_OUTCOME } from '../../constants/drawDefinitionConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  INVALID_STRUCTURE,\n  MISSING_DRAW_DEFINITION,\n  MISSING_STRUCTURE_ID,\n  STRUCTURE_NOT_FOUND,\n  EXISTING_MATCHUP_ID,\n} from '../../constants/errorConditionConstants';\n\nexport function addAdHocMatchUps({\n  tournamentRecord,\n  drawDefinition,\n  structureId,\n  matchUps,\n}): ResultType {\n  if (typeof drawDefinition !== 'object')\n    return { error: MISSING_DRAW_DEFINITION };\n\n  if (!structureId && drawDefinition.structures?.length === 1)\n    structureId = drawDefinition.structures?.[0]?.structureId;\n\n  if (typeof structureId !== 'string') return { error: MISSING_STRUCTURE_ID };\n\n  if (!validMatchUps(matchUps))\n    return { error: INVALID_VALUES, info: mustBeAnArray('matchUps') };\n\n  const structure = drawDefinition.structures?.find(\n    (structure) => structure.structureId === structureId\n  );\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  const existingMatchUps = structure?.matchUps;\n  const structureHasRoundPositions = existingMatchUps.find(\n    (matchUp) => !!matchUp.roundPosition\n  );\n\n  if (\n    structure.structures ||\n    structureHasRoundPositions ||\n    structure.finishingPosition === ROUND_OUTCOME\n  ) {\n    return { error: INVALID_STRUCTURE };\n  }\n\n  const existingMatchUpIds =\n    allTournamentMatchUps({\n      tournamentRecord,\n      inContext: false,\n    })?.matchUps?.map(getMatchUpId) ?? [];\n\n  const newMatchUpIds = matchUps.map(getMatchUpId);\n\n  if (overlap(existingMatchUpIds, newMatchUpIds)) {\n    return {\n      error: EXISTING_MATCHUP_ID,\n      info: 'One or more matchUpIds already present in tournamentRecord',\n    };\n  }\n\n  structure.matchUps.push(...matchUps);\n\n  addMatchUpsNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    drawDefinition,\n    matchUps,\n  });\n  modifyDrawNotice({ drawDefinition, structureIds: [structureId] });\n\n  return { ...SUCCESS };\n}\n","import { addEventExtension } from '../extensions/addRemoveExtensions';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\n\nimport { FLIGHT_PROFILE } from '../../constants/extensionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  EXISTING_DRAW_DEFINITIONS,\n  EXISTING_PROFILE,\n  MISSING_EVENT,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\nexport function attachFlightProfile({ deleteExisting, event, flightProfile }) {\n  const stack = 'attachFlightProfile';\n  if (!flightProfile)\n    return decorateResult({ result: { error: MISSING_VALUE }, stack });\n  if (!event)\n    return decorateResult({ result: { error: MISSING_EVENT }, stack });\n\n  const { flightProfile: existingFlightProfile } = getFlightProfile({ event });\n  if (existingFlightProfile && !deleteExisting)\n    return decorateResult({ result: { error: EXISTING_PROFILE }, stack });\n\n  if (event.drawDefinitions?.length)\n    return decorateResult({\n      result: { error: EXISTING_DRAW_DEFINITIONS },\n      stack,\n    });\n\n  const extension = {\n    name: FLIGHT_PROFILE,\n    value: flightProfile,\n  };\n\n  addEventExtension({ event, extension });\n\n  return {\n    flightProfile: makeDeepCopy(flightProfile, false, true),\n    ...SUCCESS,\n  };\n}\n","import { removeParticipantsScaleItems } from '../participants/removeScaleItems';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { getParticipantId } from '../../global/functions/extractors';\nimport { mustBeAnArray } from '../../utilities/mustBeAnArray';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\n\nimport {\n  INVALID_VALUES,\n  MISSING_EVENT,\n} from '../../constants/errorConditionConstants';\n\n/**\n *\n * @param {object} tournamentRecord - passed automatically if tournamentEngine.setState()\n * @param {string} eventId - resolves to event\n * @param {string} drawId - OPTIONAL - resolves drawDefinition - scopes participants to clear to drawDefinition.entries or flightProfile.flight.drawEntries\n * @param {string} scaleAttributes - { scaleType, scaleName, eventType }\n * @param {string} stage - OPTIONAL - filter event or draw entries by stage\n * @returns {boolean} { success: true } or { error }\n */\nexport function removeScaleValues({\n  tournamentRecord,\n  scaleAttributes,\n  drawDefinition,\n  entryStatuses,\n  drawId,\n  event,\n  stage,\n}) {\n  if (!event) return { error: MISSING_EVENT };\n  if (entryStatuses && !Array.isArray(entryStatuses))\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      info: mustBeAnArray('entryStatus'),\n      stack: 'removeScaleValues',\n    });\n\n  let entries = event.entries;\n\n  if (drawId) {\n    const { flightProfile } = getFlightProfile({ event });\n    const flight = flightProfile?.flights?.find(\n      (flight) => flight.drawId === drawId\n    );\n    if (flight) {\n      entries = flight.drawEntries;\n    } else {\n      entries = drawDefinition?.entries;\n    }\n  }\n\n  const stageEntries = (entries || []).filter(\n    (entry) =>\n      (!stage || !entry.entryStage || entry.entryStage === stage) &&\n      (!entryStatuses || entryStatuses.includes(entry.entryStatus))\n  );\n\n  const participantIds = stageEntries.map(getParticipantId);\n\n  return removeParticipantsScaleItems({\n    tournamentRecord,\n    scaleAttributes,\n    participantIds,\n  });\n}\n","import { SUCCESS } from '../../constants/resultConstants';\nimport { SCALE } from '../../constants/timeItemConstants';\nimport {\n  MISSING_PARTICIPANT_IDS,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\n/**\n *\n * @param {object} tournamentRecord - passed automatically if tournamentEngine.setState()\n * @param {string[]} participantIds\n * @param {string} scaleAttributes - { scaleType, scaleName, eventType }\n * @returns {boolean} { success: true } or { error }\n */\nexport function removeParticipantsScaleItems({\n  tournamentRecord,\n  scaleAttributes,\n  participantIds,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!participantIds) return { error: MISSING_PARTICIPANT_IDS };\n  if (!scaleAttributes)\n    return { error: MISSING_VALUE, info: 'scaleAttributes required' };\n\n  const { scaleType, eventType, scaleName } = scaleAttributes;\n  const itemType = [SCALE, scaleType, eventType, scaleName].join('.');\n  tournamentRecord.participants?.forEach((participant) => {\n    if (\n      participantIds.includes(participant.participantId) &&\n      participant.timeItems\n    ) {\n      participant.timeItems = participant.timeItems.filter((timeItem) => {\n        return timeItem && timeItem?.itemType !== itemType;\n      });\n    }\n  });\n\n  return { ...SUCCESS };\n}\n","import { resolveTieFormat } from '../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { generateCollectionMatchUps } from '../../assemblies/generators/drawDefinitions/tieMatchUps';\nimport { checkRequiredParameters } from '../../parameters/checkRequiredParameters';\nimport { resolveFromParameters } from '../../parameters/resolveFromParameters';\nimport { getMatchUpId } from '../../global/functions/extractors';\nimport { addMatchUpsNotice, deleteMatchUpsNotice, modifyMatchUpNotice } from '../notifications/drawNotifications';\n\nimport { TO_BE_PLAYED } from '../../constants/matchUpStatusConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { ERROR, MATCHUP, MATCHUP_ID, PARAM, TOURNAMENT_RECORD } from '../../constants/attributeConstants';\nimport { ResultType, decorateResult } from '../../global/functions/decorateResult';\nimport { INVALID_MATCHUP, NOT_FOUND } from '../../constants/errorConditionConstants';\nimport { DrawDefinition, Event, MatchUp, Tournament } from '../../types/tournamentTypes';\n\n/**\n * remove the tieFormat from a TEAM matchUp if there is a tieFormat further up the hierarchy\n * modify the matchUp's tieMatchUps to correspond to the tieFormat found further up the hierarchy\n */\n\n// TODO: if a reference to a tieFormat is removed (tieFormatId), check whether tieFormat can be excised from { tieFormats }\n\ntype ResetTieFormatArgs = {\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpId: string;\n  uuids?: string[];\n  event?: Event;\n};\nexport function resetTieFormat(params: ResetTieFormatArgs): ResultType & {\n  deletedMatchUpIds?: string[];\n  newMatchUps?: MatchUp[];\n  success?: boolean;\n} {\n  const stack = 'resetTieFormat';\n  const { drawDefinition, event, uuids } = params;\n\n  const paramCheck = checkRequiredParameters(params, [{ [TOURNAMENT_RECORD]: true, [MATCHUP_ID]: true }], stack);\n  if (paramCheck.error) return paramCheck;\n\n  const resolutions = resolveFromParameters(params, [{ [PARAM]: MATCHUP }]);\n  if (resolutions[ERROR]) return resolutions;\n\n  const tournamentId = params.tournamentRecord?.tournamentId;\n\n  const { matchUp, structure } = resolutions?.matchUp ?? {};\n\n  if (!matchUp?.tieMatchUps)\n    return decorateResult({\n      result: { error: INVALID_MATCHUP },\n      info: 'Must be a TEAM matchUp',\n      stack,\n    });\n\n  // if there is no tieFormat there is nothing to do\n  if (!matchUp.tieFormat) return { ...SUCCESS };\n\n  const tieFormat = resolveTieFormat({\n    structure,\n    drawDefinition,\n    event,\n  })?.tieFormat;\n\n  if (!tieFormat)\n    return decorateResult({\n      result: { error: NOT_FOUND },\n      info: 'No inherited tieFormat',\n      stack,\n    });\n\n  const deletedMatchUpIds: string[] = [];\n  const collectionIds: string[] = [];\n  const tieMatchUps: any[] = [];\n  const newMatchUps: any[] = [];\n\n  for (const collectionDefinition of tieFormat.collectionDefinitions) {\n    // delete any matchUp.tieMatchUps that are not found in the ancestor tieFormat collectionDefinitions\n    const { matchUpCount, collectionId } = collectionDefinition;\n    collectionIds.push(collectionId);\n\n    const existingCollectionMatchUps = (matchUp.tieMatchUps || []).filter(\n      (matchUp) => matchUp.collectionId === collectionId,\n    );\n\n    if (existingCollectionMatchUps.length > matchUpCount) {\n      // sort by matchUpStatus to prioritize active or completed matchUpsA\n      existingCollectionMatchUps.sort(\n        (a, b) => (a.matchUpStatus === TO_BE_PLAYED ? 1 : 0) - (b.matchUpStatus === TO_BE_PLAYED ? 1 : 0),\n      );\n      tieMatchUps.push(...existingCollectionMatchUps.slice(0, matchUpCount));\n      deletedMatchUpIds.push(...existingCollectionMatchUps.slice(3).map(getMatchUpId));\n    } else {\n      tieMatchUps.push(...existingCollectionMatchUps);\n\n      if (existingCollectionMatchUps.length < matchUpCount) {\n        const matchUpsLimit = matchUpCount - existingCollectionMatchUps.length;\n        const matchUps = generateCollectionMatchUps({\n          collectionDefinition,\n          matchUpsLimit,\n          matchUp,\n          uuids,\n        });\n        newMatchUps.push(...matchUps);\n      }\n    }\n  }\n\n  for (const tieMatchUp of matchUp?.tieMatchUps || []) {\n    if (tieMatchUp.collectionId && !collectionIds.includes(tieMatchUp.collectionId))\n      deletedMatchUpIds.push(tieMatchUp.matchUpId);\n  }\n\n  if (newMatchUps.length) {\n    tieMatchUps.push(...newMatchUps);\n    addMatchUpsNotice({\n      eventId: event?.eventId,\n      matchUps: newMatchUps,\n      drawDefinition,\n      tournamentId,\n    });\n  }\n\n  if (deletedMatchUpIds.length) {\n    deleteMatchUpsNotice({\n      matchUpIds: deletedMatchUpIds,\n      eventId: event?.eventId,\n      drawDefinition,\n      tournamentId,\n    });\n  }\n\n  if (matchUp) {\n    matchUp.tieMatchUps = tieMatchUps;\n    matchUp.tieFormatId = undefined;\n    matchUp.tieFormat = undefined;\n\n    modifyMatchUpNotice({\n      structureId: structure?.structureId,\n      eventId: event?.eventId,\n      context: stack,\n      drawDefinition,\n      tournamentId,\n      matchUp,\n    });\n  }\n\n  return { ...SUCCESS, newMatchUps, deletedMatchUpIds };\n}\n","import { nextPowerOf2 } from '../../utilities/math';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\n\nimport { INVALID_VALUES } from '../../constants/errorConditionConstants';\n\ntype GetDrawSizeArgs = {\n  participantsCount?: number;\n  participantCount?: number;\n};\nexport function getEliminationDrawSize({\n  participantsCount,\n  participantCount, // TODO: to be deprecated\n}: GetDrawSizeArgs): ResultType & { drawSize?: number } {\n  participantsCount = participantsCount ?? participantCount;\n  if (!participantsCount) return { error: INVALID_VALUES };\n\n  const drawSize = nextPowerOf2(participantsCount);\n\n  if (!drawSize)\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      stack: 'getEliminationDrawSize',\n      context: { participantsCount },\n    });\n\n  return { drawSize };\n}\n","import { getEliminationDrawSize } from '../participants/getEliminationDrawSize';\nimport { getPolicyDefinitions } from '../extensions/getAppliedPolicies';\nimport { isConvertableInteger } from '../../utilities/math';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\n\nimport { POLICY_TYPE_SEEDING } from '../../constants/policyConstants';\nimport { PolicyDefinitions } from '../../types/factoryTypes';\nimport {\n  MISSING_DRAW_SIZE,\n  MISSING_PARTICIPANT_COUNT,\n  INVALID_POLICY_DEFINITION,\n  MISSING_SEEDCOUNT_THRESHOLDS,\n  PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE,\n  INVALID_VALUES,\n} from '../../constants/errorConditionConstants';\nimport { DrawDefinition, Event, Tournament } from '../../types/tournamentTypes';\n\ntype GetSeedsCountArgs = {\n  policyDefinitions?: PolicyDefinitions;\n  requireParticipantCount?: boolean;\n  drawSizeProgression?: boolean;\n  tournamentRecord?: Tournament;\n  drawDefinition?: DrawDefinition;\n  participantsCount?: number;\n  participantCount?: number;\n  drawSize?: any;\n  event?: Event;\n};\n\nexport function getSeedsCount(\n  params: GetSeedsCountArgs\n): ResultType & { seedsCount?: number } {\n  let {\n    drawSizeProgression = false,\n    policyDefinitions,\n    drawSize,\n  } = params || {};\n  const {\n    requireParticipantCount = true,\n    tournamentRecord,\n    drawDefinition,\n    event,\n  } = params || {};\n  const stack = 'getSeedsCount';\n\n  const participantsCount =\n    params?.participantsCount ?? params?.participantCount;\n\n  if (!policyDefinitions) {\n    const result = getPolicyDefinitions({\n      tournamentRecord,\n      drawDefinition,\n      event,\n    });\n    if (result.error) return decorateResult({ result, stack });\n    policyDefinitions = result.policyDefinitions;\n  }\n  const validParticpantCount = isConvertableInteger(participantsCount);\n\n  if (participantsCount && !validParticpantCount)\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      context: { participantsCount },\n      stack,\n    });\n  if (requireParticipantCount && !validParticpantCount)\n    return decorateResult({\n      result: { error: MISSING_PARTICIPANT_COUNT },\n      stack,\n    });\n\n  if (isNaN(drawSize)) {\n    if (participantsCount) {\n      ({ drawSize } = getEliminationDrawSize({\n        participantsCount,\n      }));\n    } else {\n      return decorateResult({ result: { error: MISSING_DRAW_SIZE }, stack });\n    }\n  }\n\n  const consideredParticipantCount =\n    (requireParticipantCount && participantsCount) || drawSize;\n  if (consideredParticipantCount && consideredParticipantCount > drawSize)\n    return { error: PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE };\n\n  const policy = policyDefinitions?.[POLICY_TYPE_SEEDING];\n  if (!policy) return { error: INVALID_POLICY_DEFINITION };\n\n  const seedsCountThresholds = policy.seedsCountThresholds;\n  if (!seedsCountThresholds) return { error: MISSING_SEEDCOUNT_THRESHOLDS };\n  if (policy.drawSizeProgression !== undefined)\n    drawSizeProgression = policy.drawSizeProgression;\n\n  const relevantThresholds = seedsCountThresholds.filter((threshold) => {\n    return drawSizeProgression\n      ? threshold.drawSize <= drawSize\n      : drawSize === threshold.drawSize;\n  });\n\n  const seedsCount = relevantThresholds.reduce((seedsCount, threshold) => {\n    return participantsCount &&\n      participantsCount >= threshold.minimumParticipantCount\n      ? threshold.seedsCount\n      : seedsCount;\n  }, 0);\n\n  return { seedsCount };\n}\n","import { getEliminationDrawSize } from '../participants/getEliminationDrawSize';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { getStageEntries } from '../drawDefinition/getStageEntries';\nimport { getSeedsCount } from '../drawDefinition/getSeedsCount';\n\nimport { PolicyDefinitions } from '../../types/factoryTypes';\nimport { ErrorType, MISSING_EVENT } from '../../constants/errorConditionConstants';\nimport { DrawDefinition, Event, Entry, StageTypeUnion } from '../../types/tournamentTypes';\n\ntype GetEntriesAndSeedsCountArgs = {\n  policyDefinitions: PolicyDefinitions;\n  drawDefinition: DrawDefinition;\n  stage: StageTypeUnion;\n  drawSize?: number;\n  drawId?: string;\n  event: Event;\n};\nexport function getEntriesAndSeedsCount({\n  policyDefinitions,\n  drawDefinition,\n  drawSize,\n  drawId,\n  event,\n  stage,\n}: GetEntriesAndSeedsCountArgs): {\n  stageEntries?: Entry[];\n  seedsCount?: number;\n  entries?: Entry[];\n  error?: ErrorType;\n} {\n  if (!event) return { error: MISSING_EVENT };\n\n  const { entries, stageEntries } = getStageEntries({\n    drawDefinition,\n    drawId,\n    stage,\n    event,\n  });\n  const participantsCount = stageEntries.length;\n\n  const { drawSize: eliminationDrawSize } = getEliminationDrawSize({\n    participantsCount,\n  });\n  const result = getSeedsCount({\n    drawSize: drawSize ?? eliminationDrawSize,\n    participantsCount,\n    policyDefinitions,\n  });\n  if (result.error) return decorateResult({ result, stack: 'getEntriesAndSeedsCount' });\n\n  const { seedsCount } = result;\n  return { entries, seedsCount, stageEntries };\n}\n","import { ScaleAttributes } from '../../../types/factoryTypes';\nimport { SEEDING } from '../../../constants/scaleConstants';\nimport { Entry } from '../../../types/tournamentTypes';\nimport {\n  ErrorType,\n  MISSING_VALUE,\n} from '../../../constants/errorConditionConstants';\n\ntype ScaleItemsWithParticipantId = {\n  participantId: string;\n  scaleItems: any[];\n};\ntype GenerateSeedingScaleItemsArgs = {\n  scaleAttributes?: ScaleAttributes;\n  stageEntries: Entry[];\n  scaledEntries: any[];\n  seedsCount: number;\n  scaleName: string;\n};\nexport function generateSeedingScaleItems({\n  scaleAttributes,\n  scaledEntries,\n  stageEntries,\n  seedsCount,\n  scaleName,\n}: GenerateSeedingScaleItemsArgs): {\n  scaleItemsWithParticipantIds?: ScaleItemsWithParticipantId[];\n  error?: ErrorType;\n  info?: any;\n} {\n  if (!scaleAttributes)\n    return { error: MISSING_VALUE, info: 'missing scaleAttributes' };\n\n  const seededEntries = Object.assign(\n    {},\n    ...(scaledEntries || [])\n      .slice(0, seedsCount)\n      .map(({ participantId }, index) => ({ [participantId]: index + 1 }))\n  );\n\n  scaleName = scaleName || scaleAttributes.scaleName;\n  const scaleDate = new Date().toISOString();\n\n  const scaleItemsWithParticipantIds = stageEntries.map(({ participantId }) => {\n    const scaleItem = {\n      scaleValue: seededEntries[participantId],\n      eventType: scaleAttributes.eventType,\n      scaleType: SEEDING,\n      scaleName,\n      scaleDate,\n    };\n    return {\n      scaleItems: [scaleItem],\n      participantId,\n    };\n  });\n\n  return { scaleItemsWithParticipantIds };\n}\n","import { findTournamentParticipant } from '../../acquire/findTournamentParticipant';\nimport { participantScaleItem } from './participantScaleItem';\n\nimport { Tournament } from '../../types/tournamentTypes';\nimport {\n  ScaleAttributes,\n  ScaleItem,\n  TournamentRecords,\n} from '../../types/factoryTypes';\nimport {\n  ErrorType,\n  MISSING_PARTICIPANT_ID,\n  PARTICIPANT_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\ntype GetParticipantScaleItemArgs = {\n  tournamentRecords?: TournamentRecords;\n  scaleAttributes: ScaleAttributes;\n  tournamentRecord?: Tournament;\n  participantId: string;\n};\nexport function getParticipantScaleItem(params: GetParticipantScaleItemArgs): {\n  tournamentId?: string;\n  scaleItem?: ScaleItem;\n  error?: ErrorType;\n} {\n  const { tournamentRecord, scaleAttributes, participantId } = params;\n\n  const tournamentRecords =\n    params.tournamentRecords ||\n    (tournamentRecord && {\n      [tournamentRecord.tournamentId]: tournamentRecord,\n    }) ||\n    {};\n\n  if (!participantId) return { error: MISSING_PARTICIPANT_ID };\n\n  const { participant, tournamentId } = findTournamentParticipant({\n    tournamentRecords,\n    tournamentRecord,\n    participantId,\n  });\n\n  if (!participant) return { error: PARTICIPANT_NOT_FOUND };\n  return {\n    ...participantScaleItem({ participant, scaleAttributes }),\n    tournamentId,\n  };\n}\n","import { getParticipantScaleItem } from '../participant/getParticipantScaleItem';\n\nimport { STRUCTURE_SELECTED_STATUSES } from '../../constants/entryStatusConstants';\nimport { Entry, Event, Tournament } from '../../types/tournamentTypes';\nimport { ScaleAttributes } from '../../types/factoryTypes';\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\n/**\n *\n * @param {object} tournamentRecord - passed in automatically by tournamentEngine\n * @param {object} event - OPTIONAL - will be passed in automatically if tournamentEngine is passed drawId or eventId\n * @param {object} entries - OPTIONAL - provide entries rather than using event.entries\n * @param {string} stage - OPTIONAL - filters entries matching stage, if present\n * @param {object} scaleAttributes - { scaleName, scaleType, eventType }\n * @param {function} scaleSortMethod - OPTIONAL - function(a, b) {} - custom sorting function\n * @param {boolean} sortDescending - OPTIONL - default sorting method is ASCENDING; only applies to default sorting method\n */\ntype GetScaledEntriesArgs = {\n  scaleAttributes: ScaleAttributes;\n  tournamentRecord: Tournament;\n  sortDescending?: boolean;\n  stageSequence?: number;\n  scaleSortMethod?: any;\n  entries?: Entry[];\n  stage?: string;\n  event?: Event;\n};\nexport function getScaledEntries({\n  sortDescending = false,\n  tournamentRecord,\n  scaleAttributes,\n  scaleSortMethod,\n  stageSequence,\n  entries,\n  event,\n  stage,\n}: GetScaledEntriesArgs): { error?: ErrorType; scaledEntries?: any[] } {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  entries = entries ?? event?.entries ?? [];\n\n  const stageEntries = entries.filter(\n    (entry: any) =>\n      (!stage || !entry.entryStage || entry.entryStage === stage) &&\n      (!stageSequence ||\n        !entry.entryStageSequence ||\n        entry.entryStageSequence === stageSequence) &&\n      STRUCTURE_SELECTED_STATUSES.includes(entry.entryStatus)\n  );\n\n  const scaledEntries = stageEntries\n    .map((entry) => {\n      const { participantId } = entry;\n      const { scaleItem } = getParticipantScaleItem({\n        tournamentRecord,\n        scaleAttributes,\n        participantId,\n      });\n      // return a new object so original entry is untouched\n      return { ...entry, ...scaleItem };\n    })\n    .filter((scaledEntry) => {\n      const scaleValue = scaledEntry.scaleValue;\n      // if a custom sort method is not provided, filter out entries with non-float values\n      if (!scaleSortMethod && (isNaN(scaleValue) || !parseFloat(scaleValue)))\n        return false;\n      return scaleValue;\n    })\n    .sort(scaleSortMethod || defaultScaleValueSort);\n\n  return { scaledEntries };\n\n  function defaultScaleValueSort(a, b) {\n    return sortDescending\n      ? scaleItemValue(b) - scaleItemValue(a)\n      : scaleItemValue(a) - scaleItemValue(b);\n  }\n\n  function scaleItemValue(scaleItem) {\n    return parseFloat(scaleItem.scaleValue || (sortDescending ? -1 : 1e5));\n  }\n}\n","import { addEventExtension } from '../extensions/addRemoveExtensions';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { xa } from '../../utilities/objects';\nimport { intersection } from '../../utilities/arrays';\nimport { ensureInt } from '../../utilities/ensureInt';\nimport { UUID } from '../../utilities/UUID';\n\nimport { FLIGHT_PROFILE } from '../../constants/extensionConstants';\nimport { Entry, Event } from '../../types/tournamentTypes';\nimport { EXISTING_FLIGHT, INVALID_VALUES, MISSING_EVENT, MISSING_VALUE } from '../../constants/errorConditionConstants';\n\ntype AddFlightArgs = {\n  qualifyingPositions?: number;\n  drawEntries?: Entry[];\n  drawName?: string;\n  drawId: string;\n  stage?: string;\n  event: Event;\n};\nexport function addFlight({\n  qualifyingPositions,\n  drawEntries = [], // [{ entryPosition, entryStatus, participantId }]\n  drawName,\n  drawId,\n  event,\n  stage,\n}: AddFlightArgs) {\n  const stack = 'addFlight';\n  if (!event) return decorateResult({ result: { error: MISSING_EVENT }, stack });\n  if (!drawName) return decorateResult({ result: { error: MISSING_VALUE }, stack });\n\n  if (drawEntries?.length) {\n    // check that all drawEntries are in event.entries\n    const enteredParticipantIds = (event.entries ?? []).map(xa('participantId'));\n    const flightParticipantIds = drawEntries.map(xa('participantId'));\n    if (intersection(flightParticipantIds, enteredParticipantIds).length !== flightParticipantIds.length) {\n      return decorateResult({ result: { error: INVALID_VALUES }, stack });\n    }\n  }\n\n  const flightProfile = getFlightProfile({ event })?.flightProfile;\n\n  const flightNumbers =\n    flightProfile?.flights\n      ?.map(({ flightNumber }) => !isNaN(flightNumber) && ensureInt(flightNumber))\n      ?.filter(Boolean) || [];\n\n  const flightNumber = Math.max(0, ...flightNumbers) + 1;\n\n  const flightDrawId = drawId || UUID();\n  const flight: any = {\n    drawId: flightDrawId,\n    flightNumber,\n    drawEntries,\n    drawName,\n  };\n\n  if (stage) flight.stage = stage;\n  if (qualifyingPositions) flight.qualifyingPositions = qualifyingPositions;\n\n  const flightExists = (flightProfile?.flights || []).find(({ drawId }) => drawId === flight.drawId);\n  if (flightExists) return decorateResult({ result: { error: EXISTING_FLIGHT }, stack });\n\n  const flights = (flightProfile?.flights || []).concat(flight);\n\n  const extension = {\n    name: FLIGHT_PROFILE,\n    value: {\n      ...(flightProfile || {}),\n      flights,\n    },\n  };\n\n  return addEventExtension({ event, extension });\n}\n","export const COLLEGE_DEFAULT = 'COLLEGE_DEFAULT';\nexport const COLLEGE_JUCO = 'COLLEGE_JUCO';\nexport const COLLEGE_D3 = 'COLLEGE_D3';\nexport const DOMINANT_DUO = 'DOMINANT_DUO';\nexport const DOMINANT_DUO_MIXED = 'DOMINANT_DUO_MIXED';\nexport const LAVER_CUP = 'LAVER_CUP';\nexport const TEAM_DOUBLES_3_AGGREGATION = 'TEAM_DOUBLES_3_AGGREGATION';\nexport const TIME_TENNIS_DUAL = 'TIME_TENNIS_DUAL';\nexport const TIME_TENNIS_PRO_CIRCUIT = 'TIME_TENNIS_PRO_CIRCUIT';\nexport const USTA_BREWER_CUP = 'USTA_BREWER_CUP';\nexport const USTA_OZAKI_CUP = 'USTA_OZAKI_CUP';\nexport const USTA_COLLEGE = 'USTA_COLLEGE';\nexport const USTA_GOLD_TEAM_CHALLENGE = 'USTA_GOLD_TEAM_CHALLENGE';\nexport const USTA_LEVEL_1 = 'USTA_LEVEL_1';\nexport const USTA_INTERSECTIONAL = 'USTA_INTERSECTIONAL';\nexport const USTA_SECTION_BATTLE = 'USTA_SECTION_BATTLE';\nexport const USTA_SOUTHERN_LEVEL_5 = 'USTA_SOUTHERN_LEVEL_5';\nexport const USTA_TOC = 'USTA_TOC';\nexport const USTA_WTT_ITT = 'USTA_WTT_ITT';\nexport const USTA_ZONAL = 'USTA_ZONAL';\n\nexport const tieFormatConstants = {\n  COLLEGE_D3,\n  COLLEGE_DEFAULT,\n  COLLEGE_JUCO,\n  DOMINANT_DUO,\n  DOMINANT_DUO_MIXED,\n  LAVER_CUP,\n  TEAM_DOUBLES_3_AGGREGATION,\n  TIME_TENNIS_DUAL,\n  TIME_TENNIS_PRO_CIRCUIT,\n  USTA_BREWER_CUP,\n  USTA_OZAKI_CUP,\n  USTA_COLLEGE,\n  USTA_GOLD_TEAM_CHALLENGE,\n  USTA_INTERSECTIONAL,\n  USTA_LEVEL_1,\n  USTA_SECTION_BATTLE,\n  USTA_SOUTHERN_LEVEL_5,\n  USTA_TOC,\n  USTA_WTT_ITT,\n  USTA_ZONAL,\n};\n\nexport default tieFormatConstants;\n","import { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { UUID } from '../../../utilities/UUID';\n\nimport USTA_GOLD_TEAM_CHALLENGE_FORMAT from '../../../fixtures/scoring/tieFormats/USTA_GOLD_TEAM_CHALLENGE.json';\nimport TEAM_AGGREGATION_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/TEAM_DOUBLES_3_AGGREGATION.json';\nimport USTA_SOUTHERN_LEVEL_5_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/USTA_SOUTHERN_LEVEL_5.json';\nimport USTA_SECTION_BATTLE_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/USTA_SECTION_BATTLE.json';\nimport USTA_INTERSECTIONAL_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/USTA_INTERSECTIONAL.json';\nimport TIME_TENNIS_PRO_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/TIME_TENNIS_PRO_CIRCUIT.json';\nimport DOMINANT_DUO_MIXED_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/DOMINANT_DUO_MIXED.json';\nimport TIME_TENNIS_DUAL_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/TIME_TENNIS_DUAL.json';\nimport USTA_BREWER_CUP_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/USTA_BREWER_CUP.json';\nimport USTA_OZAKI_CUP_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/USTA_OZAKI_CUP.json';\nimport DOMINANT_DUO_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/DOMINANT_DUO.json';\nimport USTA_COLLEGE_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/USTA_COLLEGE.json';\nimport USTA_LEVEL_1_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/USTA_LEVEL_1.json';\nimport USTA_WTT_ITT_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/USTA_WTT_ITT.json';\nimport USTA_ZONAL_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/USTA_ZONAL.json';\nimport LAVER_CUP_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/LAVER_CUP.json';\nimport USTA_TOC_TIE_FORMAT from '../../../fixtures/scoring/tieFormats/USTA_TOC.json';\nimport { FORMAT_ATP_DOUBLES, FORMAT_STANDARD } from '../../../fixtures/scoring/matchUpFormats';\nimport {\n  COLLEGE_D3,\n  COLLEGE_DEFAULT,\n  COLLEGE_JUCO,\n  DOMINANT_DUO,\n  DOMINANT_DUO_MIXED,\n  LAVER_CUP,\n  TEAM_DOUBLES_3_AGGREGATION,\n  USTA_BREWER_CUP,\n  USTA_OZAKI_CUP,\n  USTA_COLLEGE,\n  USTA_GOLD_TEAM_CHALLENGE,\n  USTA_INTERSECTIONAL,\n  USTA_TOC,\n  USTA_WTT_ITT,\n  USTA_LEVEL_1,\n  USTA_SECTION_BATTLE,\n  USTA_SOUTHERN_LEVEL_5,\n  USTA_ZONAL,\n  TIME_TENNIS_DUAL,\n  TIME_TENNIS_PRO_CIRCUIT,\n} from '../../../constants/tieFormatConstants';\n\nimport { DOUBLES, SINGLES } from '../../../constants/matchUpTypes';\nimport { Event } from '../../../types/tournamentTypes';\n\nconst STANDARD = 'STANDARD';\n\nconst namedFormats = {\n  [STANDARD]: {\n    hydrate: true,\n    doubles: { matchUpCount: 3, matchUpValue: 1 },\n    singles: { matchUpCount: 6, matchUpValue: 1 },\n    valueGoal: 5,\n  },\n  [COLLEGE_D3]: {\n    hydrate: true,\n    doubles: {\n      matchUpCount: 3,\n      matchUpValue: 1,\n      matchUpFormat: 'SET1-S:8/TB7@7',\n    },\n    singles: {\n      matchUpFormat: FORMAT_STANDARD,\n      matchUpCount: 6,\n      matchUpValue: 1,\n    },\n    tieFormatName: COLLEGE_D3,\n    valueGoal: 5,\n  },\n  [COLLEGE_DEFAULT]: {\n    hydrate: true,\n    doubles: {\n      matchUpCount: 3,\n      collectionValue: 1,\n      matchUpFormat: FORMAT_STANDARD,\n    },\n    singles: {\n      matchUpCount: 6,\n      matchUpValue: 1,\n      matchUpFormat: FORMAT_STANDARD,\n    },\n    tieFormatName: COLLEGE_DEFAULT,\n    valueGoal: 4,\n  },\n  [COLLEGE_JUCO]: {\n    hydrate: true,\n    doubles: {\n      matchUpCount: 3,\n      matchUpValue: 1,\n      matchUpFormat: 'SET1-S:8/TB7',\n    },\n    singles: {\n      matchUpCount: 6,\n      matchUpValue: 1,\n      matchUpFormat: FORMAT_STANDARD,\n    },\n    tieFormatName: COLLEGE_JUCO,\n    valueGoal: 5,\n  },\n  [LAVER_CUP]: LAVER_CUP_TIE_FORMAT,\n  [DOMINANT_DUO]: DOMINANT_DUO_TIE_FORMAT,\n  [DOMINANT_DUO_MIXED]: DOMINANT_DUO_MIXED_TIE_FORMAT,\n  [TEAM_DOUBLES_3_AGGREGATION]: TEAM_AGGREGATION_TIE_FORMAT,\n  [TIME_TENNIS_DUAL]: TIME_TENNIS_DUAL_TIE_FORMAT,\n  [TIME_TENNIS_PRO_CIRCUIT]: TIME_TENNIS_PRO_TIE_FORMAT,\n  [USTA_BREWER_CUP]: USTA_BREWER_CUP_TIE_FORMAT,\n  [USTA_OZAKI_CUP]: USTA_OZAKI_CUP_TIE_FORMAT,\n  [USTA_COLLEGE]: USTA_COLLEGE_TIE_FORMAT,\n  [USTA_GOLD_TEAM_CHALLENGE]: USTA_GOLD_TEAM_CHALLENGE_FORMAT,\n  [USTA_INTERSECTIONAL]: USTA_INTERSECTIONAL_TIE_FORMAT,\n  [USTA_LEVEL_1]: USTA_LEVEL_1_TIE_FORMAT,\n  [USTA_SECTION_BATTLE]: USTA_SECTION_BATTLE_TIE_FORMAT,\n  [USTA_SOUTHERN_LEVEL_5]: USTA_SOUTHERN_LEVEL_5_TIE_FORMAT,\n  [USTA_WTT_ITT]: USTA_WTT_ITT_TIE_FORMAT,\n  [USTA_TOC]: USTA_TOC_TIE_FORMAT,\n  [USTA_ZONAL]: USTA_ZONAL_TIE_FORMAT,\n};\n\ntype TieFormatDefaultArgs = {\n  hydrateCollections?: boolean;\n  namedFormat?: string;\n  isMock?: boolean;\n  uuids?: string[];\n  event?: Event;\n};\n\nexport const tieFormatDefaults = (params?: TieFormatDefaultArgs) => {\n  const namedFormat =\n    params?.namedFormat && Object.keys(namedFormats).includes(params.namedFormat) ? params.namedFormat : STANDARD;\n\n  const uuids = Array.isArray(params?.uuids) ? params?.uuids : [];\n\n  let tieFormat;\n  const { category, gender } = params?.event ?? {};\n  const template = makeDeepCopy(namedFormats[namedFormat], false, true);\n\n  const getCollectionId = (index) => {\n    if ((!params?.isMock && !params?.event?.isMock) || !params.event) return uuids?.pop() ?? UUID();\n    const eventId = params?.event?.eventId;\n    return uuids.pop() ?? `${eventId}-COL-${index + 1}`;\n  };\n  if (!template.hydrate) {\n    template.collectionDefinitions.forEach(\n      (collectionDefinition, i) => (collectionDefinition.collectionId = getCollectionId(i)),\n    );\n    tieFormat = template;\n  } else {\n    tieFormat = {\n      winCriteria: {\n        valueGoal: template.valueGoal,\n      },\n      collectionDefinitions: [\n        {\n          collectionId: getCollectionId(0),\n          matchUpFormat: FORMAT_ATP_DOUBLES,\n          collectionName: 'Doubles',\n          matchUpType: DOUBLES,\n          ...template.doubles,\n        },\n        {\n          collectionId: getCollectionId(1),\n          matchUpFormat: FORMAT_STANDARD,\n          collectionName: 'Singles',\n          matchUpType: SINGLES,\n          ...template.singles,\n        },\n      ],\n    };\n\n    if (template.tieFormatName) tieFormat.tieFormatName = template.tieFormatName;\n  }\n\n  if (params?.hydrateCollections) {\n    tieFormat.collectionDefinitions.forEach((collectionDefinition) => {\n      if (category && !collectionDefinition.category) collectionDefinition.category = category;\n      if (gender && !collectionDefinition.gender) collectionDefinition.gender = gender;\n    });\n  }\n\n  return tieFormat;\n};\n\nexport default tieFormatDefaults;\n","import COLLEGE_D3 from './COLLEGE_D3.json';\nimport COLLEGE_DEFAULT from './COLLEGE_DEFAULT.json';\nimport COLLEGE_JUCO from './COLLEGE_JUCO.json';\nimport DOMINANT_DUO from './DOMINANT_DUO.json';\nimport DOMINANT_DUO_MIXED from './DOMINANT_DUO_MIXED.json';\nimport LAVER_CUP from './LAVER_CUP.json';\nimport TEAM_DOUBLES_3_AGGREGATION from './TEAM_DOUBLES_3_AGGREGATION.json';\nimport TIME_TENNIS_DUAL from './TIME_TENNIS_DUAL.json';\nimport TIME_TENNIS_PRO_CIRCUIT from './TIME_TENNIS_PRO_CIRCUIT.json';\nimport USTA_BREWER_CUP from './USTA_BREWER_CUP.json';\nimport USTA_OZAKI_CUP from './USTA_OZAKI_CUP.json';\nimport USTA_COLLEGE from './USTA_COLLEGE.json';\nimport USTA_GOLD_TEAM_CHALLENGE from './USTA_GOLD_TEAM_CHALLENGE.json';\nimport USTA_INTERSECTIONAL from './USTA_INTERSECTIONAL.json';\nimport USTA_LEVEL_1 from './USTA_LEVEL_1.json';\nimport USTA_SECTION_BATTLE from './USTA_SECTION_BATTLE.json';\nimport USTA_SOUTHERN_LEVEL_5 from './USTA_SOUTHERN_LEVEL_5.json';\nimport USTA_TOC from './USTA_TOC.json';\nimport USTA_WTT_ITT from './USTA_WTT_ITT.json';\nimport USTA_ZONAL from './USTA_ZONAL.json';\n\nexport const tieFormats = {\n  COLLEGE_D3,\n  COLLEGE_DEFAULT,\n  COLLEGE_JUCO,\n  DOMINANT_DUO,\n  DOMINANT_DUO_MIXED,\n  LAVER_CUP,\n  TEAM_DOUBLES_3_AGGREGATION,\n  TIME_TENNIS_DUAL,\n  TIME_TENNIS_PRO_CIRCUIT,\n  USTA_BREWER_CUP,\n  USTA_OZAKI_CUP,\n  USTA_COLLEGE,\n  USTA_GOLD_TEAM_CHALLENGE,\n  USTA_INTERSECTIONAL,\n  USTA_LEVEL_1,\n  USTA_SECTION_BATTLE,\n  USTA_SOUTHERN_LEVEL_5,\n  USTA_TOC,\n  USTA_WTT_ITT,\n  USTA_ZONAL,\n};\n","import tieFormatDefaults from '../../assemblies/generators/templates/tieFormatDefaults';\nimport { addDrawNotice, addMatchUpsNotice } from '../notifications/drawNotifications';\nimport { allEventMatchUps } from '../../query/matchUps/getAllEventMatchUps';\nimport { validateTieFormat } from '../../validators/validateTieFormat';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { getTopics } from '../../global/state/globalState';\nimport { UUID } from '../../utilities/UUID';\n\nimport { SINGLES_EVENT, TEAM_EVENT } from '../../constants/eventConstants';\nimport { Event, Tournament } from '../../types/tournamentTypes';\nimport { ADD_MATCHUPS } from '../../constants/topicConstants';\nimport { tieFormats } from '../../fixtures/scoring/tieFormats';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  EVENT_EXISTS,\n  ErrorType,\n  INVALID_VALUES,\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\ntype AddEventArgs = {\n  suppressNotifications?: boolean;\n  tournamentRecord: Tournament;\n  internalUse?: boolean;\n  event: any; // any because eventId need not be present\n};\nexport function addEvent({ suppressNotifications, tournamentRecord, internalUse, event }: AddEventArgs): {\n  context?: { [key: string]: any };\n  error?: ErrorType;\n  event?: Event;\n  info?: any;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!tournamentRecord.events) tournamentRecord.events = [];\n  if (!event) return { error: MISSING_EVENT };\n\n  // set default startDate, endDate based on tournamentRecord\n  const { startDate, endDate } = tournamentRecord;\n\n  // if not internal use disallow passing entries and drawDefinitions\n  if (!internalUse && (event.entries?.length || event.drawDefinitions?.length)) {\n    const context = definedAttributes({\n      drawDefinitions: !!event.drawDefinitions?.length,\n      entries: !!event.entries?.length,\n    });\n    return {\n      info: 'entries/drawDefinitions cannot exist',\n      error: INVALID_VALUES,\n      context,\n    };\n  }\n\n  const eventRecord = {\n    eventType: SINGLES_EVENT,\n    drawDefinitions: [],\n    entries: [],\n    startDate,\n    endDate,\n    ...event,\n  };\n\n  if (event.eventType === TEAM_EVENT) {\n    if (event.tieFormat) {\n      const result = validateTieFormat({ tieFormat: event.tieFormat });\n      if (result.error) return result;\n    } else if (event.tieFormatName) {\n      if (!tieFormats[event.tieFormatName]) {\n        return {\n          context: { tieFormatName: event.tieFormatName },\n          error: INVALID_VALUES,\n        };\n      }\n      const tieFormat = tieFormatDefaults({\n        isMock: tournamentRecord?.isMock,\n        namedFormat: event.tieFormatName,\n        event,\n      });\n      eventRecord.tieFormat = tieFormat;\n    }\n  }\n\n  if (!eventRecord.eventId) eventRecord.eventId = UUID();\n\n  const eventExists = tournamentRecord.events.reduce((exists: any, event) => {\n    return exists || event.eventId === eventRecord.eventId;\n  }, undefined);\n\n  if (!eventExists) {\n    const newEvent = eventRecord as Event;\n    tournamentRecord.events.push(newEvent);\n\n    if (!suppressNotifications) {\n      const { topics } = getTopics();\n      if (topics.includes(ADD_MATCHUPS)) {\n        const matchUps = allEventMatchUps({ event }).matchUps ?? [];\n        addMatchUpsNotice({\n          tournamentId: tournamentRecord?.tournamentId,\n          eventId: event.eventId,\n          matchUps,\n        });\n      }\n\n      for (const drawDefinition of event.drawDefinitions || []) {\n        addDrawNotice({ drawDefinition });\n      }\n    }\n\n    return { ...SUCCESS, event: eventRecord };\n  } else {\n    return { error: EVENT_EXISTS };\n  }\n}\n","import { decorateResult } from '../../global/functions/decorateResult';\nimport { ensureInt } from '../../utilities/ensureInt';\n\nimport { MAIN } from '../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_EVENT,\n  INVALID_ENTRY_STATUS,\n  MISSING_TOURNAMENT_RECORD,\n  PARTICIPANT_ENTRY_NOT_FOUND,\n  PARTICIPANT_NOT_FOUND_IN_STAGE,\n  PARTICIPANT_NOT_ENTERED_IN_STAGE,\n  INVALID_VALUES,\n} from '../../constants/errorConditionConstants';\nimport {\n  ALTERNATE,\n  DIRECT_ACCEPTANCE,\n} from '../../constants/entryStatusConstants';\n\nexport function promoteAlternate(params) {\n  const { participantId } = params;\n  if (participantId && typeof participantId !== 'string')\n    return { error: INVALID_VALUES, participantId };\n\n  return promoteAlternates({\n    ...params,\n    participantIds: [participantId].filter(Boolean),\n  });\n}\n\nexport function promoteAlternates({\n  tournamentRecord,\n  drawDefinition,\n  participantIds,\n  stageSequence,\n  stage = MAIN,\n  eventId,\n  event,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!Array.isArray(participantIds))\n    return { error: INVALID_VALUES, participantIds };\n  if (!event) return { error: MISSING_EVENT };\n  const stack = 'promoteAlternates';\n\n  if (event) {\n    const result = promoteWithinElement({\n      element: event,\n      participantIds,\n      stageSequence,\n      stage,\n    });\n    if (result.error) return result;\n  }\n\n  if (drawDefinition) {\n    const result = promoteWithinElement({\n      element: drawDefinition,\n      participantIds,\n      stageSequence,\n      stage,\n    });\n    if (result.error) {\n      if (eventId) {\n        // if successful promoting within the event do not fail if not found in drawDefinition.entries\n        // the reasoning here is that with split draws alternates may or may not appear in drawDefinition.entries\n        return decorateResult({\n          context: {\n            drawPromotionError: result.error,\n            drawId: drawDefinition.drawId,\n          },\n          result: { ...SUCCESS },\n          stack,\n        });\n      } else {\n        return result;\n      }\n    }\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction promoteWithinElement({\n  participantIds,\n  stageSequence,\n  element,\n  stage,\n}) {\n  const alternates = (element.entries || []).filter(\n    (entry) => entry.entryStatus === ALTERNATE\n  );\n\n  const targetedEntries = (element.entries || []).filter((entry) =>\n    participantIds.includes(entry.participantId)\n  );\n\n  // if no participantId is provided, take the alternate with the lowest entryPosition\n  const alternateEntry = alternates.reduce((participantEntry, entry) => {\n    const { entryPosition } = entry;\n    return (\n      (isNaN(entryPosition) && participantEntry) ||\n      ((!participantEntry || entryPosition < participantEntry.entryPosition) &&\n        entry) ||\n      participantEntry\n    );\n  }, undefined);\n\n  const participantEntries = targetedEntries.length\n    ? targetedEntries\n    : [alternateEntry].filter(Boolean);\n\n  if (!participantEntries?.length)\n    return { error: PARTICIPANT_ENTRY_NOT_FOUND };\n\n  const invalidEntryStatus = participantEntries.filter(\n    ({ entryStatus }) => entryStatus !== ALTERNATE\n  );\n\n  if (invalidEntryStatus.length)\n    return { error: INVALID_ENTRY_STATUS, invalidEntryStatus };\n\n  const invalidStage = participantEntries.filter(\n    ({ entryStage }) => entryStage && entryStage !== stage\n  );\n  if (invalidStage.length)\n    return { error: PARTICIPANT_NOT_ENTERED_IN_STAGE, invalidStage };\n\n  const invalidStageSequence =\n    stageSequence &&\n    participantEntries.filter((entry) => entry.stageSequence !== stageSequence);\n  if (invalidStageSequence?.length)\n    return { error: PARTICIPANT_NOT_FOUND_IN_STAGE, invalidStageSequence };\n\n  for (const participantEntry of participantEntries) {\n    participantEntry.entryStatus = DIRECT_ACCEPTANCE;\n\n    // cleanUp\n    const entryPosition = participantEntry?.entryPosition;\n\n    if (!isNaN(entryPosition)) {\n      // if promoted participant has an entryPosition, adjust all other alternates with an entryPosition higher than promoted participant\n      element.entries.forEach((entry) => {\n        if (\n          entry.entryStatus === ALTERNATE &&\n          entry.entryPosition > entryPosition\n        ) {\n          entry.entryPosition = entry.entryPosition - 1;\n        }\n      });\n    }\n\n    const maxEntryPosition = Math.max(\n      ...element.entries\n        .filter(\n          (entry) =>\n            entry.entryStatus === DIRECT_ACCEPTANCE &&\n            !isNaN(entry.entryPosition)\n        )\n        .map(({ entryPosition }) => ensureInt(entryPosition || 0)),\n      0\n    );\n    participantEntry.entryPosition = maxEntryPosition || 0;\n  }\n\n  return { ...SUCCESS };\n}\n","import { refreshEntryPositions } from './refreshEntryPositions';\nimport { decorateResult } from '../../global/functions/decorateResult';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_PARTICIPANT_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\nexport function setEntryPosition({\n  tournamentRecord,\n  drawDefinition,\n  participantId,\n  entryPosition,\n  skipRefresh,\n  event,\n}) {\n  const stack = 'setEntryPositions';\n\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!participantId)\n    return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack });\n\n  if (entryPosition !== undefined && !Number.isSafeInteger(entryPosition))\n    return { error: INVALID_VALUES, entryPosition };\n\n  (event?.entries || []).forEach((entry) => {\n    if (entry.participantId === participantId) {\n      entry.entryPosition = entryPosition;\n    }\n  });\n\n  (drawDefinition?.entries || []).forEach((entry) => {\n    if (entry.participantId === participantId) {\n      entry.entryPosition = entryPosition;\n    }\n  });\n\n  // if there are other entries with equivalent entryPosition, incremnt to differentiate\n  // decimal values will be replaced with whole numbers by refreshEntryPositions()\n  const differentiateDuplicates = (obj) => {\n    obj.entries.forEach((entry) => {\n      if (\n        entry.entryPosition === entryPosition &&\n        entry.participantId !== participantId\n      ) {\n        entry.entryPosition += 0.1;\n      }\n    });\n  };\n\n  if (!skipRefresh) {\n    if (event?.entries) {\n      differentiateDuplicates(event);\n      event.entries = refreshEntryPositions({ entries: event.entries });\n    }\n    if (drawDefinition?.entries) {\n      differentiateDuplicates(drawDefinition);\n      drawDefinition.entries = refreshEntryPositions({\n        entries: drawDefinition.entries,\n      });\n    }\n  }\n\n  return { ...SUCCESS };\n}\n\nexport function setEntryPositions({\n  tournamentRecord,\n  entryPositions,\n  drawDefinition,\n  event,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!Array.isArray(entryPositions)) return { error: INVALID_VALUES };\n\n  for (const positioning of entryPositions) {\n    const { participantId, entryPosition } = positioning;\n    const result = setEntryPosition({\n      skipRefresh: true, // avoid redundant processing\n      tournamentRecord,\n      drawDefinition,\n      participantId,\n      entryPosition,\n      event,\n    });\n    if (result.error) return result;\n  }\n\n  if (event?.entries) {\n    event.entries = refreshEntryPositions({ entries: event.entries });\n  }\n  if (drawDefinition?.entries) {\n    drawDefinition.entries = refreshEntryPositions({\n      entries: drawDefinition.entries,\n    });\n  }\n\n  return { ...SUCCESS };\n}\n","import { ResultType, decorateResult } from '../../global/functions/decorateResult';\nimport { dateValidation } from '../../validators/regex';\nimport { extractDate } from '../../utilities/dateTime';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_DATE,\n  INVALID_TOURNAMENT_DATES,\n  INVALID_VALUES,\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\nexport function setEventStartDate({ tournamentRecord, event, startDate }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n  if (!dateValidation.test(startDate)) return { error: INVALID_DATE };\n  const result = getTournamentDates(tournamentRecord);\n  if (result.error) return result;\n  const { tournamentStartDate, tournamentEndDate } = result;\n\n  // use extractDate() to ensure that only the YYYY-MM-DD part of date is used for comparison\n  const newEventStartDate = new Date(extractDate(startDate)).getTime();\n  if (\n    !tournamentStartDate ||\n    !tournamentEndDate ||\n    newEventStartDate < tournamentStartDate ||\n    newEventStartDate > tournamentEndDate\n  )\n    return { error: INVALID_DATE };\n\n  // use extractDate() to ensure that only the YYYY-MM-DD part of date is used for comparison\n  const eventEndDate = event.endDate && new Date(extractDate(event.endDate)).getTime();\n  if (eventEndDate && newEventStartDate > eventEndDate) {\n    // if the new startDate is after an existing endDate set the endDate to the startDate\n    event.endDate = startDate;\n  }\n\n  event.startDate = startDate;\n\n  return { ...SUCCESS };\n}\n\nexport function setEventEndDate({ tournamentRecord, event, endDate }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n  if (!dateValidation.test(endDate)) return { error: INVALID_DATE };\n  const result = getTournamentDates(tournamentRecord);\n  if (result.error) return result;\n  const { tournamentStartDate, tournamentEndDate } = result;\n\n  // use extractDate() to ensure that only the YYYY-MM-DD part of date is used for comparison\n  const newEventEndDate = new Date(extractDate(endDate)).getTime();\n  if (\n    !tournamentStartDate ||\n    !tournamentEndDate ||\n    newEventEndDate < tournamentStartDate ||\n    newEventEndDate > tournamentEndDate\n  )\n    return { error: INVALID_DATE };\n\n  // use extractDate() to ensure that only the YYYY-MM-DD part of date is used for comparison\n  const eventStartDate = event.startDate && new Date(extractDate(event.startDate)).getTime();\n  if (eventStartDate && newEventEndDate < eventStartDate) {\n    // if the new endDate is before an existing startDate set the startDate to the endDate\n    event.startDate = endDate;\n  }\n\n  event.endDate = endDate;\n  return { ...SUCCESS };\n}\n\nexport function setEventDates({ tournamentRecord, event, startDate, endDate }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n  if (!startDate && !endDate) return { error: MISSING_VALUE, info: 'missing date' };\n  if (startDate && !dateValidation.test(startDate)) return { error: INVALID_DATE };\n  if (endDate && !dateValidation.test(endDate)) return { error: INVALID_DATE };\n\n  if (startDate && endDate) {\n    const newStartDate = new Date(extractDate(startDate)).getTime();\n    const newEndDate = new Date(extractDate(endDate)).getTime();\n    if (newStartDate > newEndDate) return { error: INVALID_VALUES };\n  }\n\n  if (startDate) {\n    const result = setEventStartDate({ tournamentRecord, event, startDate });\n    if (result.error) return result;\n  }\n\n  if (endDate) {\n    const result = setEventEndDate({ tournamentRecord, event, endDate });\n    if (result.error) return result;\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction getTournamentDates(\n  tournamentRecord,\n): ResultType & { tournamentStartDate?: number; tournamentEndDate?: number } {\n  const { startDate, endDate } = tournamentRecord;\n  if (!dateValidation.test(startDate) || !dateValidation.test(endDate)) {\n    return decorateResult({\n      result: { error: INVALID_TOURNAMENT_DATES },\n      context: { startDate, endDate },\n    });\n  }\n\n  // use extractDate() to ensure that only the YYYY-MM-DD part of date is used for comparison\n  return {\n    tournamentStartDate: new Date(extractDate(startDate)).getTime(),\n    tournamentEndDate: new Date(extractDate(endDate)).getTime(),\n  };\n}\n","import { setDrawParticipantRepresentativeIds } from '../../../mutate/drawDefinitions/setDrawParticipantRepresentativeIds';\nimport { getAvailablePlayoffProfiles } from '../../../mutate/drawDefinitions/structureGovernor/getAvailablePlayoffProfiles';\nimport { resetVoluntaryConsolationStructure } from '../../../mutate/drawDefinitions/resetVoluntaryConsolationStructure';\nimport { withdrawParticipantAtDrawPosition } from '../../../mutate/drawDefinitions/withdrawParticipantAtDrawPosition';\nimport { addVoluntaryConsolationStructure } from '../../../mutate/drawDefinitions/addVoluntaryConsolationStructure';\nimport { deleteFlightProfileAndFlightDraws } from '../../../mutate/drawDefinitions/deleteFlightProfileAndFlightDraws';\nimport { assignMatchUpSideParticipant } from '../../../mutate/matchUps/drawPositions/assignMatchUpSideParticipant';\nimport { luckyLoserDrawPositionAssignment } from '../../../mutate/drawDefinitions/luckyLoserDrawPositionAssignment';\nimport { toggleParticipantCheckInState } from '../../../mutate/matchUps/timeItems/toggleParticipantCheckInState';\nimport { alternateDrawPositionAssignment } from '../../../mutate/drawDefinitions/alternateDrawPositionAssignment';\nimport { qualifierDrawPositionAssignment } from '../../../mutate/drawDefinitions/qualifierDrawPositionAssignment';\nimport { replaceTieMatchUpParticipantId } from '../../../mutate/matchUps/lineUps/replaceTieMatchUpParticipant';\nimport { assignTieMatchUpParticipantId } from '../../../mutate/matchUps/lineUps/assignTieMatchUpParticipant';\nimport { removeTieMatchUpParticipantId } from '../../../mutate/matchUps/lineUps/removeTieMatchUpParticipant';\nimport { removeMatchUpSideParticipant } from '../../../mutate/matchUps/sides/removeMatchUpSideParticipant';\nimport { removeDrawPositionAssignment } from '../../../mutate/drawDefinitions/removeDrawPositionAssignment';\nimport { modifyCollectionDefinition } from '../../../mutate/matchUps/tieFormat/modifyCollectionDefinition';\nimport { swapDrawPositionAssignments } from '../../../mutate/drawDefinitions/swapDrawPositionAssignments';\nimport { automatedPlayoffPositioning } from '../../../mutate/drawDefinitions/automatedPlayoffPositioning';\nimport { setStructureOrder } from '../../../mutate/drawDefinitions/structureGovernor/setStructureOrder';\nimport { attachQualifyingStructure } from '../../../mutate/drawDefinitions/attachQualifyingStructure';\nimport { enableTieAutoCalc } from '../../../mutate/drawDefinitions/matchUpGovernor/enableTieAutoCalc';\nimport { renameStructures } from '../../../mutate/drawDefinitions/structureGovernor/renameStructures';\nimport { assignDrawPositionBye } from '../../../mutate/matchUps/drawPositions/assignDrawPositionBye';\nimport { deleteFlightAndFlightDraw } from '../../../mutate/drawDefinitions/deleteFlightAndFlightDraw';\nimport { removeDelegatedOutcome } from '../../../mutate/matchUps/extensions/removeDelegatedOutcome';\nimport { addDrawDefinitionTimeItem } from '../../../mutate/drawDefinitions/addDrawDefinitionTimeItem';\nimport { removeStructure } from '../../../mutate/drawDefinitions/structureGovernor/removeStructure';\nimport { addVoluntaryConsolationStage } from '../../../mutate/events/addVoluntaryConsolationStage';\nimport { removeCollectionGroup } from '../../../mutate/matchUps/tieFormat/removeCollectionGroup';\nimport { removeSeededParticipant } from '../../../mutate/drawDefinitions/removeSeededParticipant';\nimport { orderCollectionDefinitions } from '../../../mutate/tieFormat/orderCollectionDefinitions';\nimport { removeCollectionDefinition } from '../../../mutate/tieFormat/removeCollectionDefinition';\nimport { setPositionAssignments } from '../../../mutate/drawDefinitions/setPositionAssignments';\nimport { addQualifyingStructure } from '../../../mutate/drawDefinitions/addQualifyingStructure';\nimport { refreshEventDrawOrder } from '../../../mutate/drawDefinitions/refreshEventDrawOrder';\nimport { substituteParticipant } from '../../../mutate/drawDefinitions/substituteParticipant';\nimport { checkOutParticipant } from '../../../mutate/matchUps/timeItems/checkOutParticipant';\nimport { disableTieAutoCalc } from '../../../mutate/matchUps/extensions/disableTieAutoCalc';\nimport { modifyPairAssignment } from '../../../mutate/drawDefinitions/modifyPairAssignment';\nimport { setMatchUpFormat } from '../../../mutate/matchUps/matchUpFormat/setMatchUpFormat';\nimport { checkInParticipant } from '../../../mutate/matchUps/timeItems/checkInParticipant';\nimport { resetMatchUpLineUps } from '../../../mutate/matchUps/lineUps/resetMatchUpLineUps';\nimport { addPlayoffStructures } from '../../../mutate/drawDefinitions/addPlayoffStructures';\nimport { automatedPositioning } from '../../../mutate/drawDefinitions/automatedPositioning';\nimport { addCollectionGroup } from '../../../mutate/matchUps/tieFormat/addCollectionGroup';\nimport { setMatchUpStatus } from '../../../mutate/matchUps/matchUpStatus/setMatchUpStatus';\nimport { addCollectionDefinition } from '../../../mutate/tieFormat/addCollectionDefinition';\nimport { modifyDrawDefinition } from '../../../mutate/drawDefinitions/modifyDrawDefinition';\nimport { setDelegatedOutcome } from '../../../mutate/drawDefinitions/setDelegatedOutcome';\nimport { bulkMatchUpStatusUpdate } from '../../../mutate/events/bulkMatchUpStatusUpdate';\nimport { resetDrawDefinition } from '../../../mutate/drawDefinitions/resetDrawDefinition';\nimport { pruneDrawDefinition } from '../../../mutate/drawDefinitions/pruneDrawDefinition';\nimport { updateTieMatchUpScore } from '../../../mutate/matchUps/score/tieMatchUpScore';\nimport { updateDrawIdsOrder } from '../../../mutate/drawDefinitions/updateDrawIdsOrder';\nimport { assignDrawPosition } from '../../../mutate/drawDefinitions/assignDrawPosition';\nimport { deleteAdHocMatchUps } from '../../../mutate/structures/deleteAdHocMatchUps';\nimport { removeDrawEntries } from '../../../mutate/drawDefinitions/removeDrawEntries';\nimport { modifyTieFormat } from '../../../mutate/matchUps/tieFormat/modifyTieFormat';\nimport { removeRoundMatchUps } from '../../../mutate/structures/removeRoundMatchUps';\nimport { aggregateTieFormats } from '../../../mutate/tieFormat/aggregateTieFormats';\nimport { updateTeamLineUp } from '../../../mutate/drawDefinitions/updateTeamLineUp';\nimport { setOrderOfFinish } from '../../../mutate/drawDefinitions/setOrderOfFinish';\nimport { modifySeedAssignment } from '../../../mutate/events/modifySeedAssignment';\nimport { addDrawDefinition } from '../../../mutate/drawDefinitions/addDrawDefinition';\nimport { deleteDrawDefinitions } from '../../../mutate/events/deleteDrawDefinitions';\nimport { modifyEntriesStatus } from '../../../mutate/entries/modifyEntriesStatus';\nimport { assignSeedPositions } from '../../../mutate/events/assignSeedPositions';\nimport { addEventEntryPairs } from '../../../mutate/entries/addEventEntryPairs';\nimport { removeEventEntries } from '../../../mutate/entries/removeEventEntries';\nimport { modifyEventEntries } from '../../../mutate/entries/modifyEventEntries';\nimport { drawMatic } from '../../generators/drawDefinitions/drawMatic/drawMatic';\nimport { addAdHocMatchUps } from '../../../mutate/structures/addAdHocMatchUps';\nimport { modifyDrawName } from '../../../mutate/drawDefinitions/modifyDrawName';\nimport { attachFlightProfile } from '../../../mutate/events/attachFlightProfile';\nimport { addDrawEntries } from '../../../mutate/drawDefinitions/addDrawEntries';\nimport { removeScaleValues } from '../../../mutate/entries/removeScaleValues';\nimport { applyLineUps } from '../../../mutate/matchUps/lineUps/applyLineUps';\nimport { addEventEntries } from '../../../mutate/entries/addEventEntries';\nimport { resetTieFormat } from '../../../mutate/tieFormat/resetTieFormat';\nimport { resetScorecard } from '../../../mutate/matchUps/resetScorecard';\nimport { removeSeeding } from '../../../mutate/entries/removeSeeding';\nimport { setSubOrder } from '../../../mutate/structures/setSubOrder';\nimport { deleteEvents } from '../../../mutate/events/deleteEvent';\nimport { autoSeeding } from '../../../mutate/entries/autoSeeding';\nimport { modifyEvent } from '../../../mutate/events/modifyEvent';\nimport { addFlight } from '../../../mutate/events/addFlight';\nimport { addEvent } from '../../../mutate/events/addEvent';\nimport { destroyPairEntries, destroyPairEntry } from '../../../mutate/entries/destroyPairEntry';\nimport { promoteAlternate, promoteAlternates } from '../../../mutate/entries/promoteAlternate';\n\nimport { setEntryPosition, setEntryPositions } from '../../../mutate/entries/setEntryPositions';\n\nimport {\n  attachConsolationStructures,\n  attachPlayoffStructures,\n  attachStructures,\n} from '../../../mutate/drawDefinitions/attachStructures';\nimport { setEventDates, setEventEndDate, setEventStartDate } from '../../../mutate/events/setEventDates';\n\nexport const eventGovernor = {\n  addAdHocMatchUps,\n  addCollectionDefinition,\n  addCollectionGroup,\n  addDrawDefinition,\n  addDrawDefinitionTimeItem,\n  addDrawEntries,\n  addEvent,\n  addEventEntries,\n  addEventEntryPairs,\n  addFlight,\n  addPlayoffStructures,\n  addQualifyingStructure,\n  addVoluntaryConsolationStage,\n  addVoluntaryConsolationStructure,\n  aggregateTieFormats,\n  alternateDrawPositionAssignment,\n  applyLineUps,\n  assignDrawPosition,\n  assignDrawPositionBye,\n  assignMatchUpSideParticipant,\n  assignSeedPositions,\n  assignTieMatchUpParticipantId,\n  attachConsolationStructures,\n  attachFlightProfile,\n  attachPlayoffStructures,\n  attachQualifyingStructure,\n  attachStructures,\n  automatedPlayoffPositioning,\n  automatedPositioning,\n  autoSeeding,\n  bulkMatchUpStatusUpdate,\n  checkInParticipant,\n  checkOutParticipant,\n  deleteAdHocMatchUps,\n  deleteDrawDefinitions,\n  deleteEvents,\n  deleteFlightAndFlightDraw,\n  deleteFlightProfileAndFlightDraws,\n  destroyPairEntries,\n  destroyPairEntry,\n  disableTieAutoCalc,\n  drawMatic,\n  enableTieAutoCalc,\n  getAvailablePlayoffProfiles,\n  getAvailablePlayoffRounds: getAvailablePlayoffProfiles, // to be deprecated\n  luckyLoserDrawPositionAssignment,\n  modifyCollectionDefinition,\n  modifyDrawDefinition,\n  modifyDrawName,\n  modifyEntriesStatus,\n  modifyEvent,\n  modifyEventEntries,\n  modifyPairAssignment,\n  modifySeedAssignment,\n  modifyTieFormat,\n  orderCollectionDefinitions,\n  promoteAlternate,\n  promoteAlternates,\n  pruneDrawDefinition,\n  qualifierDrawPositionAssignment,\n  refreshEventDrawOrder,\n  removeCollectionDefinition,\n  removeCollectionGroup,\n  removeDelegatedOutcome,\n  removeDrawEntries,\n  removeDrawPositionAssignment,\n  removeEventEntries,\n  removeMatchUpSideParticipant,\n  removeRoundMatchUps,\n  removeScaleValues,\n  removeSeededParticipant,\n  removeSeeding,\n  removeStructure,\n  removeTieMatchUpParticipantId,\n  renameStructures,\n  replaceTieMatchUpParticipantId,\n  resetDrawDefinition,\n  resetMatchUpLineUps,\n  resetScorecard,\n  resetTieFormat,\n  resetVoluntaryConsolationStructure,\n  setDelegatedOutcome,\n  setDrawParticipantRepresentativeIds,\n  setEntryPosition,\n  setEntryPositions,\n  setEventDates,\n  setEventEndDate,\n  setEventStartDate,\n  setMatchUpFormat,\n  setMatchUpStatus,\n  setOrderOfFinish,\n  setPositionAssignments,\n  setStructureOrder,\n  setSubOrder,\n  substituteParticipant,\n  swapDrawPositionAssignments,\n  toggleParticipantCheckInState,\n  updateDrawIdsOrder,\n  updateTeamLineUp,\n  updateTieMatchUpScore,\n  withdrawParticipantAtDrawPosition,\n};\n\nexport default eventGovernor;\n","import { decorateResult } from '../../../global/functions/decorateResult';\nimport { collectionGroupUpdate } from './collectionGroupUpdate';\nimport { getTieFormat } from '../../../query/hierarchical/tieFormats/getTieFormat';\nimport { validateTieFormat } from '../../../validators/validateTieFormat';\nimport { copyTieFormat } from '../../../query/hierarchical/tieFormats/copyTieFormat';\n\nimport {\n  INVALID_VALUES,\n  MISSING_VALUE,\n} from '../../../constants/errorConditionConstants';\n\nexport function addCollectionGroup({\n  updateInProgressMatchUps = true,\n  tournamentRecord,\n  groupDefinition,\n  drawDefinition,\n  collectionIds,\n  tieFormatName,\n  structureId,\n  matchUpId,\n  matchUp,\n  eventId,\n  event,\n}) {\n  const stack = 'addCollectionGroup';\n  if (!Array.isArray(collectionIds))\n    return decorateResult({ result: { error: MISSING_VALUE }, stack });\n\n  // TODO: validate groupDefinition\n\n  let result = !matchUp\n    ? getTieFormat({\n        drawDefinition,\n        structureId,\n        matchUpId,\n        eventId,\n        event,\n      })\n    : undefined;\n  if (result?.error) return decorateResult({ result, stack });\n\n  const structure = result?.structure;\n  matchUp = matchUp || result?.matchUp;\n  const existingTieFormat = result?.tieFormat;\n  const originalValueGoal = existingTieFormat?.winCriteria.valueGoal;\n  const tieFormat = copyTieFormat(existingTieFormat);\n\n  result = validateTieFormat({ tieFormat });\n  if (result.error) return decorateResult({ result, stack });\n\n  // if any of the collectionIds are already part of a different collectionGroup, throw an error\n  for (const collectionDefinition of tieFormat.collectionDefinitions) {\n    const { collectionId, collectionGroupNumber } = collectionDefinition;\n    if (collectionGroupNumber && collectionIds.includes(collectionId))\n      return decorateResult({\n        info: 'collectionIds cannot be part of other collectionGroups',\n        result: { error: INVALID_VALUES },\n        stack,\n      });\n    // TODO: calculate the total value of the collectionDefinition\n    // either matchUpCount * matchUpValue or collectionValue or collectionValueProfiles total\n    // if not gropuDEfinition.winCriteria.aggregateValue then caluculate valueGoal automatically\n  }\n\n  const maxGroupNumber = (tieFormat.collectionGroups || []).reduce(\n    (max, group) => (group.groupNumber > max ? group.groupNumber : max),\n    0\n  );\n  const collectionGroupNumber = maxGroupNumber + 1;\n  groupDefinition.groupNumber = collectionGroupNumber;\n\n  // add collectionGroupNumber to all targeted collectionDefinitions\n  tieFormat.collectionDefinitions = tieFormat.collectionDefinitions.map(\n    (collectionDefinition) => {\n      if (collectionIds.includes(collectionDefinition.collectionId)) {\n        return { ...collectionDefinition, collectionGroupNumber };\n      } else {\n        return collectionDefinition;\n      }\n    }\n  );\n\n  tieFormat.collectionGroups = [\n    ...(tieFormat.collecitonGroups || []),\n    groupDefinition,\n  ];\n\n  return collectionGroupUpdate({\n    updateInProgressMatchUps,\n    originalValueGoal,\n    tournamentRecord,\n    drawDefinition,\n    tieFormatName,\n    structureId,\n    structure,\n    tieFormat,\n    matchUpId,\n    matchUp,\n    eventId,\n    event,\n  });\n}\n","import { getPairedParticipant } from '../../query/participant/getPairedParticipant';\nimport { getParticipantId } from '../../global/functions/extractors';\nimport { addParticipants } from '../participants/addParticipants';\nimport { stringSort } from '../../functions/sorters/stringSort';\nimport { addNotice } from '../../global/state/globalState';\nimport { intersection } from '../../utilities/arrays';\nimport { addEventEntries } from './addEventEntries';\nimport { UUID } from '../../utilities/UUID';\n\nimport { INDIVIDUAL, PAIR } from '../../constants/participantConstants';\nimport { ADD_PARTICIPANTS } from '../../constants/topicConstants';\nimport { ALTERNATE } from '../../constants/entryStatusConstants';\nimport { COMPETITOR } from '../../constants/participantRoles';\nimport { MAIN } from '../../constants/drawDefinitionConstants';\nimport { DOUBLES } from '../../constants/matchUpTypes';\nimport {\n  INVALID_EVENT_TYPE,\n  INVALID_PARTICIPANT_IDS,\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  EntryStatusUnion,\n  Event,\n  StageTypeUnion,\n  Tournament,\n} from '../../types/tournamentTypes';\nimport { ANY, FEMALE, MALE, MIXED } from '../../constants/genderConstants';\n\n/**\n * Add PAIR participant to an event\n * Creates new { participantType: PAIR } participants if necessary\n */\n\ntype AddEventEntryPairsArgs = {\n  allowDuplicateParticipantIdPairs?: boolean;\n  participantIdPairs?: string[][];\n  entryStatus?: EntryStatusUnion;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  entryStage?: StageTypeUnion;\n  uuids?: string[];\n  event: Event;\n};\nexport function addEventEntryPairs({\n  allowDuplicateParticipantIdPairs,\n  entryStage = MAIN,\n  entryStatus = ALTERNATE,\n  participantIdPairs = [],\n  tournamentRecord,\n  drawDefinition,\n  event,\n  uuids,\n}: AddEventEntryPairsArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n  if (event.eventType !== DOUBLES) return { error: INVALID_EVENT_TYPE };\n\n  const existingParticipantIdPairs: string[][] = [];\n  const genderMap = new Map<string, string>();\n\n  for (const participant of tournamentRecord.participants ?? []) {\n    const { participantType, participantId, person, individualParticipantIds } =\n      participant;\n    if (participantType === INDIVIDUAL && person?.sex) {\n      genderMap.set(participantId, person.sex);\n    } else if (participantType === PAIR && individualParticipantIds) {\n      existingParticipantIdPairs.push(individualParticipantIds);\n    }\n  }\n\n  // ensure all participantIdPairs have two individual participantIds\n  const invalidParticipantIdPairs = participantIdPairs.filter((pair) => {\n    // invalid if not two participantIds\n    if (pair.length !== 2) return true;\n    // invalid if either participantId does not exist\n    if (!genderMap.has(pair[0]) || !genderMap.has(pair[1])) return true;\n    // NOT invalid if event.gender is ANY or no gender is specified\n    if (!event.gender || event.gender === ANY) return false;\n\n    const participantGenders = pair.map((id) => genderMap.get(id));\n    // invalid if event.gender is MALE/FEMALE and both participants do not match\n    let invalidParticiapntGenders =\n      (event.gender === MALE &&\n        (participantGenders[0] !== MALE || participantGenders[1] !== MALE)) ||\n      (event.gender === FEMALE &&\n        (participantGenders[0] !== FEMALE || participantGenders[1] !== FEMALE));\n\n    // invalid if event.gender is MIXED and participant genders are not different\n    if (event.gender === MIXED) {\n      participantGenders.sort(stringSort);\n      if (participantGenders[0] !== FEMALE || participantGenders[1] !== MALE)\n        invalidParticiapntGenders = true;\n    }\n\n    return invalidParticiapntGenders;\n  });\n\n  if (invalidParticipantIdPairs.length)\n    return { error: INVALID_PARTICIPANT_IDS, invalidParticipantIdPairs };\n\n  // create provisional participant objects\n  const provisionalParticipants: any[] = participantIdPairs.map(\n    (individualParticipantIds) => ({\n      participantId: uuids?.pop() ?? UUID(),\n      participantRole: COMPETITOR,\n      individualParticipantIds,\n      participantType: PAIR,\n    })\n  );\n\n  // filter out existing participants unless allowDuplicateParticipantIdPairs is true\n  const newParticipants = allowDuplicateParticipantIdPairs\n    ? provisionalParticipants\n    : provisionalParticipants.filter((participant) => {\n        return !existingParticipantIdPairs.find(\n          (existing) =>\n            intersection(existing, participant.individualParticipantIds)\n              .length === 2\n        );\n      });\n\n  let info;\n  let addedParticipants: any[] = [];\n  if (newParticipants) {\n    const result = addParticipants({\n      allowDuplicateParticipantIdPairs,\n      participants: newParticipants,\n      returnParticipants: true,\n      tournamentRecord,\n    });\n    if (result.error) return result;\n    addedParticipants = result.participants || [];\n    info = result.info;\n  }\n\n  const pairParticipantIds = participantIdPairs\n    .map((participantIds) => {\n      const addedParticipant = addedParticipants.find(\n        (addedPair) =>\n          intersection(addedPair.individualParticipantIds, participantIds)\n            .length === 2\n      );\n      if (addedParticipant) return addedParticipant;\n\n      const { participant } = getPairedParticipant({\n        tournamentRecord,\n        participantIds,\n      });\n      return participant;\n    })\n    .map((participant) => participant.participantId);\n\n  const result = addEventEntries({\n    participantIds: pairParticipantIds,\n    tournamentRecord,\n    drawDefinition,\n    entryStatus,\n    entryStage,\n    event,\n  });\n\n  if (newParticipants.length) {\n    addNotice({\n      payload: { participants: newParticipants },\n      topic: ADD_PARTICIPANTS,\n    });\n  }\n\n  const newParticipantIds = newParticipants.map(getParticipantId);\n\n  return { ...result, info, newParticipantIds };\n}\n","import { generateQualifyingStructure } from '../../assemblies/generators/drawDefinitions/drawTypes/generateQualifyingStructure';\nimport { addTournamentTimeItem } from '../timeItems/addTimeItem';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { attachQualifyingStructure } from './attachQualifyingStructure';\n\nimport { DrawDefinition, Event, Tournament } from '../../types/tournamentTypes';\nimport {\n  MISSING_TOURNAMENT_RECORD,\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n  MISSING_STRUCTURE_ID,\n} from '../../constants/errorConditionConstants';\n\ntype AddQualifyingstructureArgs = {\n  qualifyingRoundNumber: number;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  qualifyingPositions: number;\n  targetStructureId: string;\n  roundTarget: number;\n  structureName: string;\n  matchUpType: string;\n  drawSize: number;\n  drawType: string;\n  eventId: string;\n  event: Event;\n};\n\nexport function addQualifyingStructure(params: AddQualifyingstructureArgs) {\n  const tournamentRecord = params.tournamentRecord;\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const result = addQualifying(params);\n  if (result.error) return result;\n\n  const {\n    qualifyingRoundNumber,\n    qualifyingPositions,\n    targetStructureId,\n    drawDefinition,\n    structureName,\n    matchUpType,\n    drawSize,\n    drawType,\n  } = params;\n\n  const qualifyingDetails = definedAttributes({\n    drawId: drawDefinition.drawId,\n    qualifyingRoundNumber,\n    qualifyingPositions,\n    targetStructureId,\n    structureName,\n    matchUpType,\n    drawSize,\n    drawType,\n  });\n\n  const timeItem = {\n    itemType: 'addQualifyingStructures',\n    itemValue: qualifyingDetails,\n  };\n  addTournamentTimeItem({ tournamentRecord, timeItem });\n\n  return result;\n}\n\ntype AddQualifyingArgs = {\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  targetStructureId: string;\n  qualifyingRoundNumber: number;\n  roundTarget: number;\n  eventId: string;\n  event: Event;\n};\n\nexport function addQualifying(params: AddQualifyingArgs) {\n  if (!params.drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!params.targetStructureId) return { error: MISSING_STRUCTURE_ID };\n  const result = generateQualifyingStructure(params);\n  if (result.error) return result;\n  const { structure, link } = result;\n  if (!structure || !link) return { error: INVALID_VALUES };\n\n  return attachQualifyingStructure({\n    tournamentRecord: params.tournamentRecord,\n    drawDefinition: params.drawDefinition,\n    structure,\n    link,\n  });\n}\n","import { addVoluntaryConsolationStage as addVoluntary } from '../drawDefinitions/addVoluntaryConsolationStage';\n\nexport function addVoluntaryConsolationStage(params) {\n  return addVoluntary(params);\n}\n","import { modifyDrawNotice } from '../notifications/drawNotifications';\nimport { setStageDrawSize } from './entryGovernor/stageEntryCounts';\n\nimport { MISSING_DRAW_DEFINITION } from '../../constants/errorConditionConstants';\nimport { VOLUNTARY_CONSOLATION } from '../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\n\nexport function addVoluntaryConsolationStage({ drawDefinition, drawSize }) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  const result = setStageDrawSize({\n    stage: VOLUNTARY_CONSOLATION,\n    stageSequence: 1,\n    drawDefinition,\n    drawSize,\n  });\n  if (result.error) return result;\n\n  modifyDrawNotice({ drawDefinition });\n\n  return { ...SUCCESS };\n}\n","import { compareTieFormats } from '../../query/hierarchical/tieFormats/compareTieFormats';\nimport { allEventMatchUps } from '../../query/matchUps/getAllEventMatchUps';\nimport { modifyMatchUpNotice } from '../notifications/drawNotifications';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { UUID } from '../../utilities/UUID';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { TEAM_MATCHUP } from '../../constants/matchUpTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { Tournament } from '../../types/tournamentTypes';\n\ntype AggreateTieFormatsArgs = {\n  tournamentRecord: Tournament;\n};\nexport function aggregateTieFormats({\n  tournamentRecord,\n}: AggreateTieFormatsArgs): ResultType & { addedCount?: number } {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  let addedCount = 0;\n\n  for (const event of tournamentRecord.events ?? []) {\n    const tieFormats = event.tieFormats ?? [];\n\n    const checkTieFormat = (obj) => {\n      if (!obj.tieFormat) return;\n\n      let identifiedTieFormatId;\n      for (const tieFormat of tieFormats) {\n        const different = compareTieFormats({\n          descendant: obj.tieFormat,\n          ancestor: tieFormat,\n        }).different;\n        if (!different) identifiedTieFormatId = tieFormat.tieFormatId;\n      }\n\n      if (identifiedTieFormatId) {\n        obj.tieFormatId = identifiedTieFormatId;\n        delete obj.tieFormat;\n      } else {\n        const newTieFormat = makeDeepCopy(obj.tieFormat, undefined, true);\n        if (!newTieFormat.tieFormatId) newTieFormat.tieFormatId = UUID();\n\n        obj.tieFormatId = newTieFormat.tieFormatId;\n        delete obj.tieFormat;\n\n        tieFormats.push(newTieFormat);\n        addedCount += 1;\n      }\n    };\n\n    const eventType = event.eventType;\n    checkTieFormat({ tieFormat: event.tieFormat, eventType });\n\n    for (const drawDefinition of event.drawDefinitions ?? []) {\n      checkTieFormat({ tieFormat: drawDefinition.tieFormat, eventType });\n      for (const structure of drawDefinition.structures ?? []) {\n        checkTieFormat({ tieFormat: structure.tieFormat, eventType });\n      }\n    }\n\n    const setTieFormatId = (matchUpId, tieFormatId) => {\n      const matchUp = eventMatchUpResult.matchUps?.find(\n        (matchUp) => matchUp.matchUpId === matchUpId\n      );\n      if (matchUp) {\n        matchUp.tieFormatId = tieFormatId;\n        delete matchUp.tieFormat;\n        modifyMatchUpNotice({\n          tournamentId: tournamentRecord?.tournamentId,\n          eventId: event.eventId,\n          matchUp,\n        });\n      }\n    };\n    const addNewTieFormat = (inContextMatchUp) => {\n      const newTieFormat = makeDeepCopy(\n        inContextMatchUp.tieFormat,\n        undefined,\n        true\n      );\n      if (!newTieFormat.tieFormatId) newTieFormat.tieFormatId = UUID();\n      tieFormats.push(newTieFormat);\n      addedCount += 1;\n\n      setTieFormatId(inContextMatchUp.matchUpId, newTieFormat.tieFormatId);\n    };\n\n    const eventMatchUpResult = allEventMatchUps({\n      matchUpFilters: { matchUpTypes: [TEAM_MATCHUP] },\n      event,\n    });\n\n    const inContextMatchUps = eventMatchUpResult.matchUps ?? [];\n\n    for (const inContextMatchUp of inContextMatchUps) {\n      let identifiedTieFormatId;\n      for (const tieFormat of tieFormats) {\n        const different =\n          inContextMatchUp.tieFormat &&\n          compareTieFormats({\n            descendant: inContextMatchUp.tieFormat,\n            ancestor: tieFormat,\n          }).different;\n        if (!different) identifiedTieFormatId = tieFormat.tieFormatId;\n      }\n      if (identifiedTieFormatId) {\n        setTieFormatId(inContextMatchUp.matchUpId, identifiedTieFormatId);\n      } else {\n        addNewTieFormat(inContextMatchUp);\n      }\n    }\n    if (tieFormats.length) event.tieFormats = tieFormats;\n  }\n\n  return { ...SUCCESS, addedCount };\n}\n","import { alternateDrawPositionAssignment as positionAlternate } from '../matchUps/drawPositions/positionAlternate';\n\n/**\n *\n * @param {string} drawId - id of drawDefinition within which structure is found\n * @param {string} structureId - id of structure of drawPosition\n * @param {number} drawPosition - drawPosition where alternate participantId will be assigned\n * @param {string} alternateParticipantId - id of participant\n *\n */\nexport function alternateDrawPositionAssignment(params) {\n  return positionAlternate(params);\n}\n","import { positionParticipantAction } from './positionParticipantAction';\n\nexport function alternateDrawPositionAssignment({\n  alternateParticipantId,\n  tournamentRecord,\n  drawDefinition,\n  drawPosition,\n  structureId,\n}) {\n  return positionParticipantAction({\n    positionActionName: 'alternateDrawPositionAssignment',\n    participantIdAttributeName: 'alternateParticipantid',\n    participantId: alternateParticipantId,\n    tournamentRecord,\n    drawDefinition,\n    drawPosition,\n    structureId,\n  });\n}\n","import { resolveTieFormat } from '../../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { getPairedParticipant } from '../../../query/participant/getPairedParticipant';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { addParticipant } from '../../participants/addParticipant';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { instanceCount } from '../../../utilities/arrays';\n\nimport { INDIVIDUAL, PAIR } from '../../../constants/participantConstants';\nimport { DOUBLES, SINGLES, TEAM } from '../../../constants/matchUpTypes';\nimport { COMPETITOR } from '../../../constants/participantRoles';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  DRAW_DEFINITION_NOT_FOUND,\n  INVALID_MATCHUP,\n  INVALID_PARTICIPANT_TYPE,\n  INVALID_VALUES,\n  MATCHUP_NOT_FOUND,\n  MISSING_DRAW_POSITIONS,\n  MISSING_TOURNAMENT_RECORD,\n  PARTICIPANT_NOT_FOUND,\n  VALUE_UNCHANGED,\n} from '../../../constants/errorConditionConstants';\n\nexport function applyLineUps({\n  tournamentRecord,\n  drawDefinition,\n  matchUpId,\n  lineUps,\n  event,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!drawDefinition) return { error: DRAW_DEFINITION_NOT_FOUND };\n  if (typeof matchUpId !== 'string') return { error: INVALID_MATCHUP };\n  if (!Array.isArray(lineUps)) return { error: INVALID_VALUES, lineUps };\n  const stack = 'applyLineUps';\n\n  const tournamentParticipants = tournamentRecord.participants || [];\n  let result = findDrawMatchUp({\n    tournamentParticipants,\n    inContext: true,\n    drawDefinition,\n    matchUpId,\n  });\n  if (result.error) return result;\n  if (!result.matchUp) return { error: MATCHUP_NOT_FOUND };\n\n  const { matchUp: inContextMatchUp, structure } = result;\n  const { drawPositions, matchUpType } = inContextMatchUp;\n  if (matchUpType !== TEAM) return { error: INVALID_MATCHUP };\n  if (!drawPositions?.length) return { error: MISSING_DRAW_POSITIONS };\n\n  const tieFormat = resolveTieFormat({\n    matchUp: inContextMatchUp,\n    drawDefinition,\n    structure,\n    event,\n  })?.tieFormat;\n\n  // verify integrity of lineUps...\n  // 1. all participantIds must be valid individualParticipantIds\n  // 2. there should be at most one participantId for a given collectionPosition in singles\n  // 3. there should be at most two participantIds for a given collectionPosition in doubles\n\n  const sideAssignments: { [key: string]: any } = {};\n\n  for (const lineUp of lineUps) {\n    if (!Array.isArray(lineUp)) return { error: INVALID_VALUES, lineUp };\n\n    // maintain mapping of collectionId|collectionPosition to the participantIds assigned\n    const collectionParticipantIds = {};\n    const sideNumbers: number[] = [];\n\n    for (const lineUpAssignment of lineUp) {\n      if (typeof lineUpAssignment !== 'object')\n        return { error: INVALID_VALUES, lineUpAssignment };\n\n      const { participantId, collectionAssignments = [] } = lineUpAssignment;\n      if (!Array.isArray(collectionAssignments))\n        return { error: INVALID_VALUES, collectionAssignments };\n\n      const participant = tournamentParticipants.find(\n        (participant) => participant.participantId === participantId\n      );\n      if (!participant) return { error: PARTICIPANT_NOT_FOUND };\n      if (participant.participantType !== INDIVIDUAL)\n        return { error: INVALID_PARTICIPANT_TYPE };\n\n      const sideNumber = inContextMatchUp.sides?.find(\n        (side: any) =>\n          side.participant?.individualParticipantIds?.includes(participantId)\n      )?.sideNumber;\n      if (sideNumber) sideNumbers.push(sideNumber);\n\n      for (const collectionAssignment of collectionAssignments) {\n        if (typeof collectionAssignment !== 'object')\n          return { error: INVALID_VALUES, collectionAssignment };\n\n        const { collectionId, collectionPosition } = collectionAssignment;\n\n        const collectionDefinition = tieFormat?.collectionDefinitions?.find(\n          (collectionDefinition) =>\n            collectionDefinition.collectionId === collectionId\n        );\n        // all collectionIds in the lineUp must be present in the tieFormat collectionDefinitions\n        if (!collectionDefinition)\n          return { error: INVALID_VALUES, collectionId };\n\n        const aggregator = `${collectionId}-${collectionPosition}`;\n        if (!collectionParticipantIds[aggregator]) {\n          collectionParticipantIds[aggregator] = [];\n        }\n\n        const participantsCount = collectionParticipantIds[aggregator].length;\n\n        if (\n          (collectionDefinition.matchUpType === SINGLES && participantsCount) ||\n          (collectionDefinition.matchUpType === DOUBLES &&\n            participantsCount > 1)\n        ) {\n          // cannot have more than one assignment for singles or two for doubles\n          return {\n            info: 'Excessive collectionPosition assignments',\n            error: INVALID_VALUES,\n          };\n        }\n\n        collectionParticipantIds[aggregator].push(participantId);\n      }\n    }\n\n    // ensure that doubles pair participants exist, otherwise create\n    const collectionParticipantIdPairs: string[][] = Object.values(\n      collectionParticipantIds\n    );\n    for (const participantIds of collectionParticipantIdPairs) {\n      if (participantIds.length === 2) {\n        const { participant: pairedParticipant } = getPairedParticipant({\n          tournamentParticipants,\n          participantIds,\n        });\n        if (!pairedParticipant) {\n          // create pair participant\n          const newPairParticipant = {\n            participantType: PAIR,\n            participantRole: COMPETITOR,\n            individualParticipantIds: participantIds,\n          };\n          const result = addParticipant({\n            participant: newPairParticipant,\n            pairOverride: true,\n            tournamentRecord,\n          });\n          if (result.error) return result;\n        }\n      }\n    }\n\n    // determine sideNumber based on instances of participants appearing in team participants assigned to sides\n    // allows for some team members to be \"borrowed\"\n    const instances = instanceCount(sideNumbers);\n    const sideNumber =\n      ((instances[1] || 0) > (instances[2] || 0) && 1) ||\n      ((instances[2] || 0) > (instances[1] || 0) && 2) ||\n      undefined;\n\n    // if side not previously assigned, map sideNumber to lineUp\n    const sideAssignmentKeys = Object.keys(sideAssignments).map((key) =>\n      parseInt(key)\n    );\n    if (sideNumber && !sideAssignmentKeys.includes(sideNumber)) {\n      sideAssignments[sideNumber] = lineUp;\n    }\n  }\n\n  if (!Object.keys(sideAssignments).length) return { error: VALUE_UNCHANGED };\n\n  result = findDrawMatchUp({ drawDefinition, matchUpId });\n  if (result.error) return result;\n  if (!result.matchUp) return { error: MATCHUP_NOT_FOUND };\n\n  const { matchUp } = result;\n  if (!matchUp.sides) matchUp.sides = [];\n\n  for (const sideNumber of [1, 2]) {\n    const side = matchUp.sides.find((side) => side.sideNumber === sideNumber);\n    const assignment = sideAssignments[sideNumber];\n    if (!assignment) {\n      continue;\n    } else if (!side) {\n      matchUp.sides.push({ lineUp: assignment, sideNumber });\n    } else {\n      side.lineUp = assignment;\n    }\n  }\n\n  modifyMatchUpNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    context: stack,\n    drawDefinition,\n    matchUp,\n  });\n\n  return { ...SUCCESS };\n}\n","import { assignDrawPositionBye as assignPositionBye } from '../matchUps/drawPositions/assignDrawPositionBye';\nimport { assignDrawPosition as assignPosition } from '../matchUps/drawPositions/positionAssignment';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_DRAW_DEFINITION,\n  MISSING_DRAW_POSITION,\n  MISSING_STRUCTURE_ID,\n  NOT_IMPLEMENTED,\n} from '../../constants/errorConditionConstants';\n\nexport function assignDrawPosition({\n  tournamentRecord,\n  drawDefinition,\n  participantId,\n  drawPosition,\n  structureId,\n  qualifier,\n  event,\n  bye,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!drawPosition) return { error: MISSING_DRAW_POSITION };\n  if (!structureId) return { error: MISSING_STRUCTURE_ID };\n\n  if (bye) {\n    const result = assignPositionBye({\n      tournamentRecord,\n      drawDefinition,\n      drawPosition,\n      structureId,\n      event,\n    });\n    if (result.error) return result;\n  } else if (qualifier) {\n    return { error: NOT_IMPLEMENTED };\n  } else {\n    const result = assignPosition({\n      tournamentRecord,\n      drawDefinition,\n      participantId,\n      drawPosition,\n      structureId,\n      event,\n    });\n    if (result.error) return result;\n  }\n\n  return { ...SUCCESS };\n}\n","import { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../../global/functions/decorateResult';\n\nimport { AD_HOC } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  CANNOT_REMOVE_PARTICIPANTS,\n  INVALID_DRAW_TYPE,\n  INVALID_PARTICIPANT_ID,\n  INVALID_VALUES,\n  MATCHUP_NOT_FOUND,\n  MISSING_DRAW_DEFINITION,\n  MISSING_MATCHUP_ID,\n} from '../../../constants/errorConditionConstants';\nimport {\n  completedMatchUpStatuses,\n  DOUBLE_DEFAULT,\n  DOUBLE_WALKOVER,\n} from '../../../constants/matchUpStatusConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype AssignMatchUpSideParticipantArgs = {\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  participantId: string;\n  sideNumber: number;\n  matchUpId: string;\n  event: Event;\n};\n\n// method only currently used for AD_HOC matchUps where there are no drawPositions\nexport function assignMatchUpSideParticipant({\n  tournamentRecord,\n  drawDefinition,\n  participantId,\n  sideNumber,\n  matchUpId,\n  event,\n}: AssignMatchUpSideParticipantArgs): ResultType & { sidesSwapped?: boolean } {\n  if (participantId && typeof participantId !== 'string')\n    return { error: INVALID_PARTICIPANT_ID };\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n\n  const noSideNumberProvided = sideNumber === undefined;\n  if (noSideNumberProvided) sideNumber = 1;\n\n  if (![1, 2].includes(sideNumber))\n    return decorateResult({\n      result: { error: INVALID_VALUES, context: { sideNumber } },\n    });\n\n  const { matchUp, structure } = findDrawMatchUp({\n    drawDefinition,\n    matchUpId,\n    event,\n  });\n\n  if (!matchUp) return { error: MATCHUP_NOT_FOUND };\n\n  const isAdHoc =\n    !structure?.structures &&\n    !(drawDefinition.drawType && drawDefinition.drawType !== AD_HOC) &&\n    !structure?.matchUps?.find(({ roundPosition }) => !!roundPosition);\n\n  if (!isAdHoc) return { error: INVALID_DRAW_TYPE };\n\n  // if no participantId / participant is being un-assigned, there cannot be a score or completed outcome\n  if (\n    !participantId &&\n    (matchUp?.score?.scoreStringSide1 ||\n      completedMatchUpStatuses.includes(matchUp?.matchUpstatus) ||\n      (matchUp?.matchUpStatus &&\n        [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUp.matchUpStatus)))\n  )\n    return {\n      error: CANNOT_REMOVE_PARTICIPANTS,\n      info: 'matchUp has completed status or score',\n    };\n\n  if (matchUp) {\n    matchUp.sides = [1, 2].map((currentSideNumber) => {\n      const existingSide = matchUp.sides?.find(\n        (side) => side.sideNumber === currentSideNumber\n      ) ?? { sideNumber: currentSideNumber };\n\n      return sideNumber === currentSideNumber\n        ? { ...existingSide, participantId }\n        : existingSide;\n    });\n\n    // makes it possible to use this method with no sideNumber provided\n    // each time a participant is assigned the sides are swapped\n    if (noSideNumberProvided) {\n      for (const side of matchUp.sides) {\n        if (side.sideNumber) side.sideNumber = 3 - side.sideNumber;\n      }\n    }\n\n    modifyMatchUpNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      context: 'assignSideParticipant',\n      drawDefinition,\n      matchUp,\n    });\n  }\n\n  return { ...SUCCESS, sidesSwapped: noSideNumberProvided };\n}\n","import { getStructureSeedAssignments } from '../../query/structure/getStructureSeedAssignments';\nimport { assignSeed } from '../drawDefinitions/entryGovernor/seedAssignment';\nimport { uniqueValues } from '../../utilities/arrays';\n\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { SeedingProfile } from '../../types/factoryTypes';\nimport {\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_DRAW_ID,\n  MISSING_ASSIGNMENTS,\n  NO_MODIFICATIONS_APPLIED,\n  INVALID_PARTICIPANT_SEEDING,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  SeedAssignment,\n  Tournament,\n} from '../../types/tournamentTypes';\n\n/*\n * Provides the ability to assign seedPositions *after* a structure has been generated\n * To be used *before* participants are positioned\n */\n\ntype AssignSeedPositionsArgs = {\n  provisionalPositioning?: boolean;\n  useExistingSeedLimit?: boolean;\n  seedingProfile?: SeedingProfile;\n  assignments: SeedAssignment[];\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  structureId: string;\n  drawId: string;\n  event: Event;\n};\nexport function assignSeedPositions(\n  params: AssignSeedPositionsArgs\n): ResultType | { modifications?: number; success?: boolean } {\n  const {\n    provisionalPositioning,\n    useExistingSeedLimit,\n    tournamentRecord,\n    drawDefinition,\n    seedingProfile,\n    structureId,\n    assignments,\n    drawId,\n    event,\n  } = params;\n\n  let modifications = 0;\n\n  if (!assignments?.length) return { error: MISSING_ASSIGNMENTS };\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!drawId) return { error: MISSING_DRAW_ID };\n\n  const result = getStructureSeedAssignments({\n    provisionalPositioning,\n    drawDefinition,\n    structureId,\n  });\n  if (result.error) return result;\n  const { seedAssignments, seedLimit } = result;\n\n  /**\n   * mergeObject and seedLimit ensure that new assignments do not go beyond already established number of seeds\n   */\n  const mergeObject = Object.assign(\n    {},\n    ...(seedAssignments ?? [])\n      .filter((assignment) => assignment.seedNumber)\n      .map((assignment) => ({ [assignment.seedNumber]: assignment }))\n  );\n\n  assignments.forEach((newAssignment) => {\n    const { seedNumber } = newAssignment;\n    if (\n      seedLimit &&\n      seedNumber <= seedLimit &&\n      (!useExistingSeedLimit || mergeObject[seedNumber])\n    ) {\n      mergeObject[seedNumber] = newAssignment;\n    }\n  });\n\n  /**\n   * ensure that no participantId is assigned to multiple seedNumbers\n   */\n  const updatedAssignments: any[] = Object.values(mergeObject);\n  const participantIds = updatedAssignments\n    .map((assignment) => assignment?.participantId)\n    .filter(Boolean);\n\n  if (participantIds.length !== uniqueValues(participantIds).length) {\n    return {\n      error: INVALID_PARTICIPANT_SEEDING,\n    };\n  }\n\n  for (const assignment of updatedAssignments) {\n    const result = assignSeed({\n      ...assignment,\n      provisionalPositioning,\n      tournamentRecord,\n      drawDefinition,\n      seedingProfile,\n      structureId,\n      event,\n    });\n    if (result?.error) {\n      return result;\n    } else if (result?.success) {\n      modifications++;\n    }\n  }\n\n  return modifications\n    ? { ...SUCCESS, modifications }\n    : { error: NO_MODIFICATIONS_APPLIED };\n}\n","import { getEntriesAndSeedsCount } from '../../query/entries/getEntriesAndSeedsCount';\nimport { generateSeedingScaleItems } from '../../assemblies/generators/drawDefinitions/generateSeedingScaleItems';\nimport { getScaledEntries } from '../../query/event/getScaledEntries';\n\nimport { INVALID_VALUES } from '../../constants/errorConditionConstants';\n\n/**\n *\n * @param {object} tournamentRecord - passed automatically if tournamentEngine.setState() has been called\n * @param {string} eventId - resolved by tournamentEngine to the event object\n *\n * @param {object} policyDefinitions - seeding policyDefinitions determines the # of seeds for given participantsCount/drawSize\n * @param {object} scaleAttributes -\n * @param {string} scaleName - OPTIONAL - defaults to scaleAttributes.scaleName\n * @param {number} drawSize - OPTIONAL - defaults to calculation based on # of entries\n * @param {string} drawId - OPTIONAL - will use flight.drawEntries or drawDefinition.entries rather than event.entries\n * @param {string} stage - OPTIONAL - filters entries by specified stage\n *\n * @param {boolean} sortDescending - OPTIONAL - defaults to false\n * @param {function} scaleSortMethod - OPTIONAL - user defined sorting method\n *\n * @returns {object} - { success: true } or { error }\n */\nexport function autoSeeding({\n  tournamentRecord,\n  drawDefinition,\n\n  policyDefinitions,\n  scaleAttributes,\n  scaleName,\n  drawSize,\n  drawId,\n  event,\n  stage,\n\n  sortDescending,\n  scaleSortMethod,\n}) {\n  const result = getEntriesAndSeedsCount({\n    policyDefinitions,\n    drawDefinition,\n    drawSize,\n    drawId,\n    event,\n    stage,\n  });\n\n  if (result.error) return result;\n\n  const { entries, seedsCount, stageEntries } = result;\n  if (!stageEntries || !seedsCount) return { error: INVALID_VALUES };\n\n  const scaledEntries =\n    getScaledEntries({\n      tournamentRecord,\n      scaleAttributes,\n      scaleSortMethod,\n      sortDescending,\n      entries,\n      stage,\n    }).scaledEntries ?? [];\n\n  const { scaleItemsWithParticipantIds } = generateSeedingScaleItems({\n    scaleAttributes,\n    scaledEntries,\n    stageEntries,\n    seedsCount,\n    scaleName,\n  });\n\n  return { scaleItemsWithParticipantIds };\n}\n","import { updateAssignmentParticipantResults } from '../drawDefinitions/matchUpGovernor/updateAssignmentParticipantResults';\nimport { checkScoreHasValue } from '../../query/matchUp/checkScoreHasValue';\nimport { getMissingSequenceNumbers, unique } from '../../utilities/arrays';\nimport { xa } from '../../utilities/objects';\nimport { deleteMatchUpsNotice, modifyDrawNotice, modifyMatchUpNotice } from '../notifications/drawNotifications';\n\nimport { DrawDefinition, Event, Tournament } from '../../types/tournamentTypes';\nimport { ROUND_OUTCOME } from '../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_STRUCTURE,\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n  MISSING_STRUCTURE_ID,\n  STRUCTURE_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\ntype DeleteAdHocMatchUpsArgs = {\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpIds?: string[];\n  structureId: string;\n  event?: Event;\n};\nexport function deleteAdHocMatchUps({\n  tournamentRecord,\n  matchUpIds = [],\n  drawDefinition,\n  structureId,\n  event,\n}: DeleteAdHocMatchUpsArgs) {\n  if (typeof drawDefinition !== 'object') return { error: MISSING_DRAW_DEFINITION };\n  if (typeof structureId !== 'string') return { error: MISSING_STRUCTURE_ID };\n\n  if (!Array.isArray(matchUpIds)) return { error: INVALID_VALUES };\n\n  const structure = drawDefinition.structures?.find((structure) => structure.structureId === structureId);\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  const existingMatchUps = structure?.matchUps;\n  const structureHasRoundPositions = existingMatchUps?.find((matchUp) => !!matchUp.roundPosition);\n\n  if (structure.structures || structureHasRoundPositions || structure.finishingPosition === ROUND_OUTCOME) {\n    return { error: INVALID_STRUCTURE };\n  }\n\n  const matchUpIdsWithScoreValue: string[] = [];\n  const matchUpsToDelete =\n    existingMatchUps?.filter(({ matchUpId, score }) => {\n      if (checkScoreHasValue({ score })) matchUpIdsWithScoreValue.push(matchUpId);\n      return matchUpIds.includes(matchUpId);\n    }) ?? [];\n  const matchUpIdsToDelete = matchUpsToDelete.map(xa('matchUpId'));\n\n  if (matchUpIdsToDelete.length) {\n    structure.matchUps = (structure.matchUps ?? []).filter(({ matchUpId }) => !matchUpIdsToDelete.includes(matchUpId));\n\n    deleteMatchUpsNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      matchUpIds: matchUpIdsToDelete,\n      action: 'deleteAdHocMatchUps',\n      eventId: event?.eventId,\n      drawDefinition,\n    });\n\n    const roundNumbers = unique(structure.matchUps.map(xa('roundNumber')));\n    const missingRoundNumbers = getMissingSequenceNumbers(roundNumbers);\n    if (missingRoundNumbers.length) {\n      missingRoundNumbers.reverse();\n      for (const roundNumber of missingRoundNumbers) {\n        structure.matchUps.forEach((matchUp) => {\n          if (matchUp.roundNumber && matchUp.roundNumber > roundNumber) {\n            matchUp.roundNumber -= 1;\n            modifyMatchUpNotice({\n              tournamentId: tournamentRecord?.tournamentId,\n              context: ['adHoc round deletion'],\n              eventId: event?.eventId,\n              drawDefinition,\n              matchUp,\n            });\n          }\n        });\n      }\n    }\n\n    if (matchUpIdsWithScoreValue.length) {\n      structure.positionAssignments = unique(\n        structure.matchUps\n          .flatMap((matchUp) => (matchUp.sides ?? []).map((side) => side.participantId))\n          .filter(Boolean),\n      ).map((participantId) => ({ participantId }));\n\n      const matchUpFormat = structure?.matchUpFormat ?? drawDefinition?.matchUpFormat ?? event?.matchUpFormat;\n\n      const result = updateAssignmentParticipantResults({\n        positionAssignments: structure.positionAssignments,\n        matchUps: structure.matchUps,\n        tournamentRecord,\n        drawDefinition,\n        matchUpFormat,\n        event,\n      });\n      if (result.error) console.log(result);\n    }\n\n    modifyDrawNotice({\n      structureIds: [structureId],\n      eventId: event?.eventId,\n      drawDefinition,\n    });\n  }\n\n  return { ...SUCCESS };\n}\n","import { checkAndUpdateSchedulingProfile } from '../tournaments/schedulingProfile';\nimport { addTournamentTimeItem } from '../timeItems/addTimeItem';\nimport { mustBeAnArray } from '../../utilities/mustBeAnArray';\nimport { addNotice } from '../../global/state/globalState';\n\nimport { UNGROUPED } from '../../constants/entryStatusConstants';\nimport { DELETE_EVENTS } from '../../constants/auditConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { DOUBLES } from '../../constants/eventConstants';\nimport { AUDIT } from '../../constants/topicConstants';\nimport {\n  EVENT_NOT_FOUND,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\nexport function deleteEvents({\n  removePairParticipants,\n  tournamentRecord,\n  eventIds,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!tournamentRecord.events) return { error: EVENT_NOT_FOUND };\n  if (!Array.isArray(eventIds))\n    return { error: MISSING_VALUE, info: mustBeAnArray('drawIds') };\n\n  const auditTrail: any[] = [];\n  const deletedEventDetails: any[] = [];\n\n  const activePairParticipantIds: string[] = [];\n  const pairParticipantIds: string[] = [];\n\n  tournamentRecord.events = (tournamentRecord.events || []).filter((event) => {\n    if (eventIds.includes(event.eventId)) {\n      const auditData = {\n        action: DELETE_EVENTS,\n        payload: { events: [event] },\n      };\n      auditTrail.push(auditData);\n      deletedEventDetails.push({\n        tournamentId: tournamentRecord.tournamentId,\n        eventName: event.eventName,\n        eventType: event.eventType,\n        category: event.category,\n        eventId: event.eventId,\n        gender: event.gender,\n      });\n    }\n\n    const enteredPairParticipantIds =\n      event.eventType === DOUBLES\n        ? (event.entries || [])\n            .map(\n              ({ entryStatus, participantId }) =>\n                entryStatus !== UNGROUPED && participantId\n            )\n            .filter(Boolean)\n        : [];\n\n    const deleteEvent = eventIds.includes(event.eventId);\n\n    if (deleteEvent) {\n      pairParticipantIds.push(...enteredPairParticipantIds);\n    } else {\n      activePairParticipantIds.push(...enteredPairParticipantIds);\n    }\n\n    return !deleteEvent;\n  });\n\n  if (removePairParticipants) {\n    const particiapntIdsToRemove = pairParticipantIds.filter(\n      (participantId) => !activePairParticipantIds.includes(participantId)\n    );\n    tournamentRecord.participants = tournamentRecord.participants.filter(\n      ({ participantId }) => !particiapntIdsToRemove.includes(participantId)\n    );\n  }\n\n  // cleanup references to eventId in schedulingProfile extension\n  checkAndUpdateSchedulingProfile({ tournamentRecord });\n\n  if (auditTrail.length) {\n    addNotice({ topic: AUDIT, payload: auditTrail });\n    const timeItem = {\n      itemType: DELETE_EVENTS,\n      itemValue: deletedEventDetails,\n    };\n    addTournamentTimeItem({ tournamentRecord, timeItem });\n  }\n\n  return { ...SUCCESS };\n}\n","import { addEventExtension } from '../extensions/addRemoveExtensions';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { refreshEventDrawOrder } from './refreshEventDrawOrder';\nimport { deleteDrawDefinitions } from '../events/deleteDrawDefinitions';\n\nimport { FLIGHT_PROFILE } from '../../constants/extensionConstants';\nimport {\n  MISSING_DRAW_ID,\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\nexport function deleteFlightAndFlightDraw({\n  autoPublish = true,\n  tournamentRecord,\n  auditData,\n  drawId,\n  event,\n  force,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!drawId) return { error: MISSING_DRAW_ID };\n  if (!event) return { error: MISSING_EVENT };\n\n  const { flightProfile } = getFlightProfile({ event });\n\n  if (flightProfile) {\n    const flight = flightProfile.flights?.find(\n      (flight) => flight.drawId === drawId\n    );\n\n    if (flight) {\n      const flights = flightProfile.flights.filter((flight) => {\n        return flight.drawId !== drawId;\n      });\n\n      const extension = {\n        name: FLIGHT_PROFILE,\n        value: {\n          ...flightProfile,\n          flights,\n        },\n      };\n\n      addEventExtension({ event, extension });\n    }\n  }\n\n  const drawWasGenerated = event.drawDefinitions?.find(\n    (drawDefinition) => drawDefinition.drawId === drawId\n  );\n  if (drawWasGenerated) {\n    const result = deleteDrawDefinitions({\n      drawIds: [drawId],\n      eventId: event.eventId,\n      tournamentRecord,\n      autoPublish,\n      auditData,\n      event,\n      force,\n    });\n    if (result.error) return result;\n  }\n\n  return refreshEventDrawOrder({ tournamentRecord, event });\n}\n","import { removeEventExtension } from '../extensions/addRemoveExtensions';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { deleteDrawDefinitions } from '../events/deleteDrawDefinitions';\n\nimport { FLIGHT_PROFILE } from '../../constants/extensionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\nexport function deleteFlightProfileAndFlightDraws({\n  autoPublish = true,\n  tournamentRecord,\n  auditData,\n  event,\n  force,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n\n  const { flightProfile } = getFlightProfile({ event });\n\n  if (flightProfile) {\n    const drawIds = flightProfile.flights\n      ?.map(({ drawId }) => drawId)\n      .filter(Boolean);\n\n    const result = deleteDrawDefinitions({\n      eventId: event.eventId,\n      tournamentRecord,\n      autoPublish,\n      auditData,\n      drawIds,\n      event,\n      force,\n    });\n    if (result.error) return result;\n\n    return removeEventExtension({ event, name: FLIGHT_PROFILE });\n  }\n\n  return { ...SUCCESS };\n}\n","import { addExtension } from '../../extensions/addExtension';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\n\nimport { MISSING_DRAW_DEFINITION } from '../../../constants/errorConditionConstants';\nimport { DISABLE_AUTO_CALC } from '../../../constants/extensionConstants';\n\nexport function disableTieAutoCalc({ drawDefinition, matchUpId, event }) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const { matchUp } = findDrawMatchUp({\n    drawDefinition,\n    matchUpId,\n    event,\n  });\n\n  return addExtension({\n    extension: { name: DISABLE_AUTO_CALC, value: true },\n    element: matchUp,\n  });\n}\n","import { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { setMatchUpState } from '../../matchUps/matchUpStatus/setMatchUpState';\n\nimport { TEAM_MATCHUP } from '../../../constants/matchUpTypes';\nimport {\n  INVALID_MATCHUP,\n  MISSING_DRAW_DEFINITION,\n} from '../../../constants/errorConditionConstants';\n\nexport function enableTieAutoCalc({\n  tournamentRecord,\n  drawDefinition,\n  matchUpId,\n  event,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const { matchUp } = findDrawMatchUp({\n    drawDefinition,\n    matchUpId,\n    event,\n  });\n\n  if (matchUp?.matchUpType !== TEAM_MATCHUP) return { error: INVALID_MATCHUP };\n\n  return setMatchUpState({\n    enableAutoCalc: true,\n    tournamentRecord,\n    drawDefinition,\n    matchUpId,\n    event,\n  });\n}\n","import { luckyLoserDrawPositionAssignment as positionLuckyLoser } from '../matchUps/drawPositions/positionLuckyLoser';\n\n/**\n *\n * @param {string} drawId - id of drawDefinition within which structure is found\n * @param {string} structureId - id of structure of drawPosition\n * @param {number} drawPosition - drawPosition where lucky loser participantId will be assigned\n * @param {string} luckyLoserParticipantId - id of participant\n *\n */\nexport function luckyLoserDrawPositionAssignment(params) {\n  return positionLuckyLoser(params);\n}\n","import { positionParticipantAction } from './positionParticipantAction';\n\nexport function luckyLoserDrawPositionAssignment({\n  luckyLoserParticipantId,\n  tournamentRecord,\n  drawDefinition,\n  drawPosition,\n  structureId,\n}) {\n  return positionParticipantAction({\n    positionActionName: 'luckyLoserDrawPositionAssignment',\n    participantId: luckyLoserParticipantId,\n    tournamentRecord,\n    drawDefinition,\n    drawPosition,\n    structureId,\n  });\n}\n","import { attachPolicies } from '../extensions/policies/attachPolicies';\nimport { modifyDrawNotice } from '../notifications/drawNotifications';\nimport { addEventExtension } from '../extensions/addRemoveExtensions';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { isObject } from '../../utilities/objects';\nimport { modifyDrawName } from './modifyDrawName';\n\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { FLIGHT_PROFILE } from '../../constants/extensionConstants';\nimport { PolicyDefinitions } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { DrawDefinition, Event, Tournament } from '../../types/tournamentTypes';\nimport {\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n} from '../../constants/errorConditionConstants';\n\ntype ModifyDrawArgs = {\n  drawUpdates: { drawName: string; policyDefinitions: PolicyDefinitions };\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  drawId: string;\n  event: Event;\n};\nexport function modifyDrawDefinition({\n  tournamentRecord,\n  drawDefinition,\n  drawUpdates,\n  drawId,\n  event,\n}: ModifyDrawArgs): ResultType {\n  if (!isObject(drawUpdates)) return { error: INVALID_VALUES };\n\n  const flightProfile = getFlightProfile({ event }).flightProfile;\n\n  const nameResult: any =\n    drawUpdates.drawName &&\n    modifyDrawName({\n      drawName: drawUpdates.drawName,\n      tournamentRecord,\n      drawDefinition,\n      flightProfile,\n      drawId,\n      event,\n    });\n  if (nameResult?.error) return nameResult?.error;\n\n  const flight =\n    nameResult?.flight ||\n    flightProfile?.flights?.find((flight) => flight.drawId === drawId);\n\n  if (!flight && !drawDefinition) {\n    return { error: MISSING_DRAW_DEFINITION };\n  }\n\n  if (flight) {\n    // TODO: any relevant changes to flightProfile\n    const extension = {\n      name: FLIGHT_PROFILE,\n      value: {\n        ...flightProfile,\n        flights: flightProfile.flights,\n      },\n    };\n\n    addEventExtension({ event, extension });\n  }\n\n  if (drawDefinition) {\n    if (drawUpdates.policyDefinitions) {\n      attachPolicies({\n        policyDefinitions: drawUpdates.policyDefinitions,\n        drawDefinition,\n      });\n    }\n    // TODO: any relevant changes to drawDefinition\n    modifyDrawNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      drawDefinition,\n    });\n  }\n\n  return { ...SUCCESS };\n}\n","import { getParticipants } from '../../query/participants/getParticipants';\nimport { isObject, isString } from '../../utilities/objects';\nimport { unique } from '../../utilities/arrays';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\n\nimport { DOUBLES, SINGLES, TEAM } from '../../constants/eventConstants';\nimport { INDIVIDUAL, PAIR } from '../../constants/participantConstants';\nimport { ANY, MIXED } from '../../constants/genderConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\nimport {\n  ALTERNATE,\n  STRUCTURE_SELECTED_STATUSES,\n} from '../../constants/entryStatusConstants';\nimport {\n  // Category,\n  Event,\n  Tournament,\n  EventTypeUnion,\n  GenderUnion,\n} from '../../types/tournamentTypes';\n\ntype ModifyEventArgs = {\n  tournamentRecord: Tournament;\n  eventUpdates: {\n    eventType?: EventTypeUnion;\n    gender?: GenderUnion;\n    /**\n     TODO: logic to determine if category can be changed\n     Considerations:\n     1) all collectionDefinitions can be contained\n     2) all particiapnts have valid ages\n     */\n    // category?: Category;\n    eventName?: string;\n  };\n  eventId: string;\n  event: Event;\n};\n\nexport function modifyEvent({\n  tournamentRecord,\n  eventUpdates,\n  eventId,\n  event,\n}: ModifyEventArgs): ResultType {\n  const stack = 'modifyEvent';\n\n  if (!tournamentRecord)\n    return decorateResult({\n      result: { error: MISSING_TOURNAMENT_RECORD },\n      stack,\n    });\n  if (!isString(eventId))\n    return decorateResult({\n      result: { error: MISSING_EVENT },\n      context: { eventId },\n      stack,\n    });\n  if (!isObject(eventUpdates))\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      context: { eventUpdates },\n      stack,\n    });\n\n  const enteredParticipantIds: string[] =\n    event?.entries\n      ?.filter(({ entryStatus }) => {\n        const status: any = entryStatus;\n        return [...STRUCTURE_SELECTED_STATUSES, ALTERNATE].includes(status);\n      })\n      .map(({ participantId }) => participantId) ?? [];\n\n  const enteredParticipants = enteredParticipantIds\n    ? getParticipants({\n        participantFilters: { participantIds: enteredParticipantIds },\n        withIndividualParticipants: true,\n        tournamentRecord,\n      }).participants ?? []\n    : [];\n\n  const genderAccumulator: string[] = [];\n  const enteredParticipantTypes = enteredParticipants.reduce(\n    (types: any[], participant) => {\n      const genders = participant.person?.sex\n        ? [participant.person.sex]\n        : participant.individualParticpants?.map((p) => p.person?.sex) || [];\n      genderAccumulator.push(...genders);\n      return !types.includes(participant.participantType)\n        ? types.concat(participant.participantType)\n        : types;\n    },\n    []\n  );\n\n  const enteredParticipantGenders = unique(genderAccumulator);\n\n  const validGender =\n    !enteredParticipantGenders.length ||\n    [MIXED, ANY].includes(eventUpdates.gender ?? '') ||\n    (enteredParticipantGenders.length === 1 &&\n      enteredParticipantGenders[0] === eventUpdates.gender);\n\n  if (eventUpdates.gender && !validGender)\n    return decorateResult({\n      context: { gender: eventUpdates.gender, validGender },\n      result: { error: INVALID_VALUES },\n      stack,\n    });\n\n  const validEventTypes = (enteredParticipantTypes.includes(TEAM) && [TEAM]) ||\n    (enteredParticipantTypes.includes(INDIVIDUAL) && [SINGLES]) ||\n    (enteredParticipantTypes.includes(PAIR) && [DOUBLES]) || [\n      DOUBLES,\n      SINGLES,\n      TEAM,\n    ];\n\n  const validEventType = validEventTypes.includes(eventUpdates.eventType ?? '');\n\n  if (eventUpdates.eventType && !validEventType)\n    return decorateResult({\n      context: { participantType: eventUpdates.eventType, validEventType },\n      result: { error: INVALID_VALUES },\n      stack,\n    });\n\n  if (eventUpdates.eventType) event.eventType = eventUpdates.eventType;\n  if (eventUpdates.eventName) event.eventName = eventUpdates.eventName;\n  if (eventUpdates.gender) event.gender = eventUpdates.gender;\n\n  return { ...SUCCESS };\n}\n","import { getPairedParticipant } from '../../query/participant/getPairedParticipant';\nimport { addParticipants } from '../participants/addParticipants';\nimport { intersection } from '../../utilities/arrays';\n\nimport { INDIVIDUAL, PAIR } from '../../constants/participantConstants';\nimport { MAIN } from '../../constants/drawDefinitionConstants';\nimport { COMPETITOR } from '../../constants/participantRoles';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n  INVALID_PARTICIPANT_IDS,\n} from '../../constants/errorConditionConstants';\n\nimport {\n  DIRECT_ACCEPTANCE,\n  UNGROUPED,\n} from '../../constants/entryStatusConstants';\nimport {\n  EntryStatusUnion,\n  Event,\n  Tournament,\n} from '../../types/tournamentTypes';\n\n// should NOT remove entries that are present in drawDefinition.entries\n// if those entries are assigned positions in any structures...\ntype ModifyEventEntriesArgs = {\n  unpairedParticipantIds?: string[];\n  participantIdPairs?: string[][];\n  entryStatus?: EntryStatusUnion;\n  tournamentRecord: Tournament;\n  entryStage?: string;\n  event: Event;\n};\nexport function modifyEventEntries({\n  entryStatus = DIRECT_ACCEPTANCE,\n  unpairedParticipantIds = [],\n  participantIdPairs = [],\n  entryStage = MAIN,\n  tournamentRecord,\n  event,\n}: ModifyEventEntriesArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n\n  const tournamentParticipants = tournamentRecord.participants ?? [];\n  const individualParticipantIds = tournamentParticipants\n    .filter((participant) => participant.participantType === INDIVIDUAL)\n    .map((participant) => participant.participantId);\n\n  // concat all incoming INDIVIDUAL participantIds\n  const incomingIndividualParticipantIds = unpairedParticipantIds\n    .concat(...participantIdPairs)\n    .flat(Infinity);\n\n  // ensure all participants are present in the tournament record\n  const invalidParticipantIds = incomingIndividualParticipantIds.filter(\n    (participantId) => !individualParticipantIds.includes(participantId)\n  );\n  if (invalidParticipantIds.length)\n    return { error: INVALID_PARTICIPANT_IDS, invalidParticipantIds };\n\n  // ensure all participantIdPairs have two individual participantIds\n  const invalidParticipantIdPairs = participantIdPairs.filter(\n    (pair) => pair.length !== 2\n  );\n  if (invalidParticipantIdPairs.length)\n    return { error: INVALID_PARTICIPANT_IDS, invalidParticipantIdPairs };\n\n  // make an array of all existing PAIR participantIds\n  const existingParticipantIdPairs = tournamentParticipants\n    .filter((participant) => participant.participantType === PAIR)\n    .map((participant) => participant.individualParticipantIds);\n\n  // determine participantIdPairs which do not already exist\n  const newParticipantIdPairs = participantIdPairs.filter(\n    (incoming) =>\n      !existingParticipantIdPairs.find(\n        (existing) => intersection(existing, incoming).length === 2\n      )\n  );\n\n  // create new participant objects\n  const newParticipants: any[] = newParticipantIdPairs.map(\n    (individualParticipantIds) => ({\n      participantType: PAIR,\n      participantRole: COMPETITOR,\n      individualParticipantIds,\n    })\n  );\n\n  const result = addParticipants({\n    participants: newParticipants,\n    tournamentRecord,\n  });\n\n  if (result.error) return result;\n\n  // get all participantIds for PAIR participants\n  const pairParticipantEntries: any[] = participantIdPairs\n    .map((participantIds: string[]) => {\n      const { participant } = getPairedParticipant({\n        tournamentRecord,\n        participantIds,\n      });\n      return participant;\n    })\n    .map((participantId) => ({\n      participantId,\n      entryStatus,\n      entryStage,\n    }));\n\n  const unpairedParticipantEntries: any[] = unpairedParticipantIds.map(\n    (participantId) => ({\n      entryStatus: UNGROUPED,\n      participantId,\n      entryStage,\n    })\n  );\n\n  // remove all entries matching the stage which has been modified\n  event.entries = (event.entries ?? []).filter(\n    (entry) => entry.entryStage === entryStage\n  );\n\n  event.entries = event.entries.concat(\n    ...pairParticipantEntries,\n    ...unpairedParticipantEntries\n  );\n\n  return { ...SUCCESS };\n}\n","import { getPairedParticipant } from '../../query/participant/getPairedParticipant';\nimport { deleteParticipants } from '../participants/deleteParticipants';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { addParticipant } from '../participants/addParticipant';\n\nimport { COMPETITOR } from '../../constants/participantRoles';\nimport { PAIR } from '../../constants/participantConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { DOUBLES } from '../../constants/eventConstants';\nimport {\n  INVALID_EVENT_TYPE,\n  INVALID_PARTICIPANT,\n  INVALID_PARTICIPANT_ID,\n  INVALID_VALUES,\n  MISSING_EVENT,\n  MISSING_PARTICIPANT_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\nimport { UNGROUPED, UNPAIRED } from '../../constants/entryStatusConstants';\n\nexport function modifyPairAssignment({\n  replacementIndividualParticipantId,\n  existingIndividualParticipantId,\n  tournamentRecord,\n  drawDefinition,\n  participantId,\n  event,\n  uuids,\n}) {\n  if (!event) return { error: MISSING_EVENT };\n  if (event?.eventType !== DOUBLES) return { error: INVALID_EVENT_TYPE };\n  if (uuids && !Array.isArray(uuids)) return { error: INVALID_VALUES };\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (\n    ![\n      replacementIndividualParticipantId,\n      existingIndividualParticipantId,\n      participantId,\n    ].every((id) => typeof id === 'string')\n  ) {\n    return { error: MISSING_PARTICIPANT_ID };\n  }\n\n  // ensure that replacementIndividualPartiicpant is UNPAIRED\n  const availableIndividualParticipantIds =\n    event?.entries\n      ?.filter(({ entryStatus }) => [UNGROUPED, UNPAIRED].includes(entryStatus))\n      .map(({ participantId }) => participantId) || [];\n  if (\n    !availableIndividualParticipantIds.includes(\n      replacementIndividualParticipantId\n    )\n  ) {\n    return { error: INVALID_PARTICIPANT_ID };\n  }\n\n  const participant = (tournamentRecord.participants || []).find(\n    (participant) => participant.participantId === participantId\n  );\n\n  if (participant?.participantType !== PAIR)\n    return { error: INVALID_PARTICIPANT, participant };\n\n  const existingIndividualParticipantIds = participant.individualParticipantIds;\n  const individualParticipantIds: string[] = [\n    replacementIndividualParticipantId,\n    ...existingIndividualParticipantIds.filter(\n      (individualParticipantId) =>\n        individualParticipantId !== existingIndividualParticipantId\n    ),\n  ];\n\n  const { participant: existingPairParticipant } = getPairedParticipant({\n    participantIds: individualParticipantIds,\n    tournamentRecord,\n  });\n\n  // if no existing pair participant, add new pair participant\n  let newPairParticipantId;\n  if (!existingPairParticipant) {\n    const newPairParticipant = {\n      participantId: uuids?.pop(),\n      participantRole: COMPETITOR,\n      individualParticipantIds,\n      participantType: PAIR,\n    };\n    const result = addParticipant({\n      participant: newPairParticipant,\n      returnParticipant: true,\n      tournamentRecord,\n    });\n    if (result.error) return result;\n    newPairParticipantId = result.participant.participantId;\n  } else {\n    newPairParticipantId = existingPairParticipant.participantId;\n  }\n\n  const { flightProfile } = getFlightProfile({ event });\n  if (drawDefinition) {\n    // modify all positionAssignments in event, drawDefinition and flight\n    const flight = flightProfile?.flights?.find(\n      ({ drawId }) => drawId === drawDefinition.drawId\n    );\n    if (flight) {\n      flight.drawEntries = flight.drawEntries.map((entry) =>\n        entry.participantId === participantId\n          ? { ...entry, participantId: newPairParticipantId }\n          : entry\n      );\n    }\n\n    drawDefinition.entries = drawDefinition.entries.map((entry) =>\n      entry.participantId === participantId\n        ? { ...entry, participantId: newPairParticipantId }\n        : entry\n    );\n\n    // update positionAssignments for all structures within the drawDefinition\n    for (const structure of drawDefinition.structures || []) {\n      if (structure.positionAssignments) {\n        structure.positionAssignments = structure.positionAssignments.map(\n          (assignment) =>\n            assignment.participantId === participantId\n              ? { ...assignment, participantId: newPairParticipantId }\n              : assignment\n        );\n      } else if (structure.structures) {\n        for (const subStructure of structure.structures) {\n          subStructure.positionAssignments =\n            subStructure.positionAssignments.map((assignment) =>\n              assignment.participantId === participantId\n                ? { ...assignment, participantId: newPairParticipantId }\n                : assignment\n            );\n        }\n      }\n    }\n  }\n\n  event.entries = event.entries.map(\n    (entry) =>\n      // replace previous pair participantId with newPairParticipantid\n      // remove replacmentIndividualParticipantId from event.entries\n      (entry.participantId === participantId && {\n        ...entry,\n        participantId: newPairParticipantId,\n      }) ||\n      // add existingIndividualParticipantId removed from original PAIR to event.entries as UNGROUPED\n      (entry.participantId === replacementIndividualParticipantId && {\n        ...entry,\n        participantId: existingIndividualParticipantId,\n      }) ||\n      entry\n  );\n\n  // if participant has no other entries then the pair can be destroyed\n  const participantOtherEntries = tournamentRecord.events.some(\n    ({ entries, eventId, drawDefinitions }) => {\n      if (event.eventId === eventId) {\n        return drawDefinitions.some(({ drawId, entries }) =>\n          drawId === drawDefinition?.drawId\n            ? false\n            : entries?.find((entry) => entry.participantId === participantId)\n        );\n      } else {\n        return entries?.find((entry) => entry.participantId === participantId);\n      }\n    }\n  );\n\n  if (!participantOtherEntries) {\n    const result = deleteParticipants({\n      addIndividualParticipantsToEvents: false,\n      participantIds: [participantId],\n      tournamentRecord,\n    });\n    if (result.error) return result;\n  }\n\n  return { ...SUCCESS, participantOtherEntries, newPairParticipantId };\n}\n","import { modifySeedAssignment as drawEngineModifySeedAssignment } from '../drawDefinitions/entryGovernor/modifySeedAssignment';\n\nimport {\n  INVALID_PARTICIPANT_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\n/**\n *\n * @param {string} drawId - id of drawDefinition within which structure occurs\n * @param {object} drawDefinition - added automatically by tournamentEngine\n * @param {string} participantId - id of participant which will receive the seedValue\n * @param {string} structureId - id of structure within drawDefinition\n * @param {string} seedValue - supports value of e.g. '5-8'\n *\n */\nexport function modifySeedAssignment({\n  tournamentRecord,\n  drawDefinition,\n  participantId,\n  structureId,\n  seedValue,\n  event,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  const participant = (tournamentRecord.participants || []).find(\n    (participant) => participant.participantId === participantId\n  );\n  if (!participant) return { error: INVALID_PARTICIPANT_ID };\n\n  return drawEngineModifySeedAssignment({\n    tournamentRecord,\n    drawDefinition,\n    participantId,\n    structureId,\n    seedValue,\n    event,\n  });\n}\n","import { getStructureSeedAssignments } from '../../../query/structure/getStructureSeedAssignments';\nimport { modifySeedAssignmentsNotice } from '../../notifications/drawNotifications';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { ensureInt } from '../../../utilities/ensureInt';\nimport { isNumeric } from '../../../utilities/math';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n  MISSING_STRUCTURE_ID,\n  STRUCTURE_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype ModifySeedAssignmentArgs = {\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  seedValue?: string | number;\n  participantId: string;\n  validation?: boolean;\n  structureId: string;\n  event?: Event;\n};\nexport function modifySeedAssignment({\n  validation = true,\n  tournamentRecord,\n  drawDefinition,\n  participantId,\n  structureId,\n  seedValue,\n  event,\n}: ModifySeedAssignmentArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structureId) return { error: MISSING_STRUCTURE_ID };\n\n  const { structure } = findStructure({ drawDefinition, structureId });\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  const validValue =\n    !validation ||\n    isNumeric(seedValue) ||\n    seedValue === undefined ||\n    seedValue === '' ||\n    (typeof seedValue === 'string' &&\n      seedValue.split('-').every((v) => isNumeric(v) && ensureInt(v) > 0));\n\n  if (!validValue) return { error: INVALID_VALUES };\n\n  const { seedAssignments } = getStructureSeedAssignments({\n    drawDefinition,\n    structure,\n  });\n  const seedNumbers = seedAssignments?.map(\n    (assignment) => assignment.seedNumber\n  );\n\n  const existingAssginment = seedAssignments?.find(\n    (assignment) => assignment.participantId === participantId\n  );\n\n  if (existingAssginment) {\n    const newValue =\n      typeof seedValue === 'string'\n        ? (seedValue.includes('-') &&\n            seedValue\n              .split('-')\n              .map((v) => parseInt(v))\n              .join('-')) ||\n          (parseInt(seedValue) > 0 && parseInt(seedValue)) ||\n          ''\n        : (seedValue && seedValue > 0 && seedValue) || '';\n    existingAssginment.seedValue = newValue;\n  } else {\n    const seedNumber = Math.max(0, ...(seedNumbers || [])) + 1;\n    const seedAssignment: any = { seedNumber, participantId };\n    if (seedValue) seedAssignment.seedValue = seedValue;\n    if (!structure.seedAssignments) structure.seedAssignments = [];\n    structure.seedAssignments.push(seedAssignment);\n  }\n\n  modifySeedAssignmentsNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    eventId: event?.eventId,\n    drawDefinition,\n    structure,\n  });\n\n  return { ...SUCCESS };\n}\n","import { compareTieFormats } from '../../../query/hierarchical/tieFormats/compareTieFormats';\nimport { removeCollectionDefinition } from '../../tieFormat/removeCollectionDefinition';\nimport { copyTieFormat } from '../../../query/hierarchical/tieFormats/copyTieFormat';\nimport { getTieFormat } from '../../../query/hierarchical/tieFormats/getTieFormat';\nimport { addCollectionDefinition } from '../../tieFormat/addCollectionDefinition';\nimport { validateTieFormat } from '../../../validators/validateTieFormat';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { modifyCollectionDefinition } from './modifyCollectionDefinition';\nimport { xa } from '../../../utilities/objects';\nimport { numericSortValue } from '../../../utilities/arrays';\n\nimport { INVALID_TIE_FORMAT } from '../../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { DrawDefinition, Event, TieFormat, Tournament } from '../../../types/tournamentTypes';\n\ntype ModifyTieFormatArgs = {\n  updateInProgressMatchUps?: boolean;\n  tieFormatComparison?: boolean;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  modifiedTieFormat: TieFormat;\n  structureId?: string;\n  matchUpId?: string;\n  eventId?: string;\n  uuids?: string[];\n  event?: Event;\n};\n\nexport function modifyTieFormat({\n  updateInProgressMatchUps = false,\n  tieFormatComparison,\n  modifiedTieFormat,\n  tournamentRecord,\n  drawDefinition,\n  structureId,\n  matchUpId,\n  eventId,\n  uuids,\n  event,\n}: ModifyTieFormatArgs) {\n  const stack = 'modifyTieFormat';\n\n  if (!validateTieFormat({ tieFormat: modifiedTieFormat }).valid) {\n    return decorateResult({\n      result: { error: INVALID_TIE_FORMAT },\n      info: 'falied validation',\n      stack,\n    });\n  }\n\n  const result = getTieFormat({\n    drawDefinition,\n    structureId,\n    matchUpId,\n    eventId,\n    event,\n  });\n  if (result.error) return decorateResult({ result, stack });\n\n  const { matchUp, tieFormat: existingTieFormat } = result;\n  const tieFormat = copyTieFormat(existingTieFormat);\n\n  const comparison = compareTieFormats({\n    descendant: modifiedTieFormat,\n    ancestor: tieFormat,\n  });\n  if (comparison.invalid) {\n    return decorateResult({\n      context: { invalid: comparison.invalid },\n      result: { error: INVALID_TIE_FORMAT },\n      stack,\n    });\n  }\n  if (!comparison?.different) {\n    return decorateResult({\n      result: { ...SUCCESS },\n      info: 'Nothing to do',\n      stack,\n    });\n  }\n\n  const existingCollectionIds = tieFormat.collectionDefinitions.map(({ collectionId }) => collectionId);\n  const updatedCollectionIds = modifiedTieFormat.collectionDefinitions.map(({ collectionId }) => collectionId);\n  const removedCollectionIds = existingCollectionIds.filter(\n    (collectionId) => !updatedCollectionIds.includes(collectionId),\n  );\n\n  const addedCollectionDefinitions: any[] = modifiedTieFormat.collectionDefinitions.filter(\n    ({ collectionId }) => !existingCollectionIds.includes(collectionId),\n  );\n\n  const addedCollectionIds = addedCollectionDefinitions.map(xa('collectionId'));\n\n  const modifications: any[] = [];\n  let processedTieFormat;\n\n  const tieFormatName = modifiedTieFormat.tieFormatName;\n  // TODO: if gender is changing pre-check for misgendered collectionAssignments\n  for (const collectionDefinition of modifiedTieFormat.collectionDefinitions) {\n    if (addedCollectionIds.includes(collectionDefinition.collectionId)) continue;\n\n    const result = modifyCollectionDefinition({\n      updateInProgressMatchUps,\n      ...collectionDefinition,\n      tournamentRecord,\n      tieFormatName,\n      drawDefinition,\n      structureId,\n      matchUpId,\n      eventId,\n      event,\n    });\n    if (result.modifications) modifications.push(...result.modifications);\n    if (result.error) return decorateResult({ result, stack });\n    if (result.tieFormat) processedTieFormat = result.tieFormat;\n  }\n\n  for (const collectionDefinition of addedCollectionDefinitions) {\n    const result = addCollectionDefinition({\n      updateInProgressMatchUps,\n      collectionDefinition,\n      tournamentRecord,\n      drawDefinition,\n      tieFormatName,\n      structureId,\n      matchUpId,\n      matchUp,\n      eventId,\n      uuids,\n      event,\n    });\n    if (result.error) return decorateResult({ result, stack });\n    if (result.tieFormat) processedTieFormat = result.tieFormat;\n  }\n\n  for (const collectionId of removedCollectionIds) {\n    const result = removeCollectionDefinition({\n      updateInProgressMatchUps,\n      tieFormatComparison,\n      tournamentRecord,\n      drawDefinition,\n      tieFormatName,\n      collectionId,\n      structureId,\n      matchUpId,\n      eventId,\n      matchUp,\n      event,\n    });\n    if (result.error) return decorateResult({ result, stack });\n    if (result.tieFormat) processedTieFormat = result.tieFormat;\n  }\n\n  const changedTieFormatName = existingTieFormat?.tieFormatName !== tieFormatName;\n\n  // if tieFormat has changed, force renaming of the tieFormat\n  if (changedTieFormatName) {\n    processedTieFormat.tieFormatName = tieFormatName;\n    modifications.push({ tieFormatName });\n  } else if (modifications.length || addedCollectionIds.length || removedCollectionIds.length) {\n    delete processedTieFormat.tieFormatName;\n    modifications.push('tieFormatName removed: modifications without new tieFormatName');\n  }\n\n  processedTieFormat.collectionDefinitions = processedTieFormat.collectionDefinitions\n    .sort((a, b) => numericSortValue(a.collectionOrder) - numericSortValue(b.collectionOrder))\n    .map((def, i) => ({ ...def, collectionOrder: i + 1 }));\n\n  return {\n    processedTieFormat: copyTieFormat(processedTieFormat),\n    modifications,\n    ...SUCCESS,\n  };\n}\n","import { getDrawStructures } from '../../acquire/findStructure';\nimport { analyzeDraws } from '../../query/tournaments/analyzeDraws';\nimport { getMatchUpId } from '../../global/functions/extractors';\nimport {\n  deleteMatchUpsNotice,\n  modifyDrawNotice,\n} from '../notifications/drawNotifications';\n\nimport { MAIN } from '../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_DRAW_DEFINITION,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\nimport { MatchUp } from '../../types/tournamentTypes';\n\nexport function pruneDrawDefinition({\n  matchPlayDrawPositions = true, // when simply extracting matchUps for aggregation, drawPositions are unnecessary\n  tournamentRecord,\n  drawDefinition,\n  drawId,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  let relevantMatchUps: MatchUp[] = [];\n\n  const { drawsAnalysis } = analyzeDraws({ tournamentRecord });\n  if (drawsAnalysis.canBePruned.includes(drawId)) {\n    const isMatchPlay = drawsAnalysis.matchPlay.includes(drawId);\n    const drawAnalysis = drawsAnalysis.drawAnalysis[drawId];\n    const {\n      structures: [mainStructure],\n    } = getDrawStructures({\n      stageSequence: 1,\n      drawDefinition,\n      stage: MAIN,\n    });\n\n    const structureData = drawAnalysis.structuresData.find(\n      ({ structureId }) => mainStructure.structureId === structureId\n    );\n\n    const matchUps = mainStructure.matchUps ?? [];\n    relevantMatchUps = matchUps\n      .sort((a: any, b: any) => a.roundPosition - b.roundPosition)\n      .filter(\n        ({ roundNumber }) => !structureData.inactiveRounds.includes(roundNumber)\n      );\n    const relevantMatchUpIds = relevantMatchUps.map(getMatchUpId);\n    const deletedMatchUpIds = matchUps\n      .map(getMatchUpId)\n      .filter((matchUpId) => !relevantMatchUpIds.includes(matchUpId));\n\n    // only ifMatchPlay can the positionAssignments be reallocated\n    if (isMatchPlay) {\n      const matchPlayMatchUps = relevantMatchUps\n        .sort((a: any, b: any) => a.roundPosition - b.roundPosition)\n        .filter(\n          ({ roundNumber }) =>\n            !structureData.inactiveRounds.includes(roundNumber)\n        )\n        .filter(({ winningSide }) => winningSide);\n\n      const matchPlayMatchUpIds = matchPlayMatchUps.map(getMatchUpId);\n      const matchUpIdsToDelete = relevantMatchUpIds.filter(\n        (matchUpId) => !matchPlayMatchUpIds.includes(matchUpId)\n      );\n      deletedMatchUpIds.push(...matchUpIdsToDelete);\n\n      const existingDrawPositionPairings = matchPlayMatchUps\n        .flatMap((matchUp) => matchUp.drawPositions ?? [])\n        .filter(Boolean);\n      const existingDrawPositions: number[] =\n        existingDrawPositionPairings.flat();\n      const drawPositionsMap = Object.assign(\n        {},\n        ...existingDrawPositions.map((drawPosition, i) => ({\n          [drawPosition]: i + 1,\n        }))\n      );\n\n      matchPlayMatchUps.forEach((matchUp: any) => {\n        if (matchPlayDrawPositions) {\n          matchUp.drawPositions = matchUp.drawPositions.map(\n            (drawPosition) => drawPositionsMap[drawPosition]\n          );\n        } else {\n          delete matchUp.drawPositions;\n        }\n      });\n\n      if (matchPlayDrawPositions) {\n        const updatedPositionAssignments = mainStructure?.positionAssignments\n          ?.filter((assignment) =>\n            existingDrawPositions.includes(assignment.drawPosition)\n          )\n          .map((assignment) => {\n            assignment.drawPosition = drawPositionsMap[assignment.drawPosition];\n            return assignment;\n          });\n\n        mainStructure.positionAssignments = updatedPositionAssignments;\n      } else {\n        mainStructure.positionAssignments = [];\n      }\n      mainStructure.matchUps = matchPlayMatchUps;\n      relevantMatchUps = matchPlayMatchUps;\n    }\n\n    deleteMatchUpsNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      matchUpIds: deletedMatchUpIds,\n      drawDefinition,\n    });\n    modifyDrawNotice({ drawDefinition });\n  }\n\n  return { ...SUCCESS, matchUps: relevantMatchUps };\n}\n","import { qualifierDrawPositionAssignment as positionQualifier } from '../matchUps/drawPositions/positionQualifier';\n\n/**\n *\n * @param {string} drawId - id of drawDefinition within which structure is found\n * @param {string} structureId - id of structure of drawPosition\n * @param {number} drawPosition - drawPosition where lucky loser participantId will be assigned\n * @param {string} qualifierParticipantId - id of participant\n *\n */\nexport function qualifierDrawPositionAssignment(params) {\n  return positionQualifier(params);\n}\n","import { positionParticipantAction } from './positionParticipantAction';\n\nexport function qualifierDrawPositionAssignment({\n  qualifyingParticipantId,\n  tournamentRecord,\n  drawDefinition,\n  drawPosition,\n  structureId,\n}) {\n  return positionParticipantAction({\n    positionActionName: 'qualifierDrawPositionAssignment',\n    participantId: qualifyingParticipantId,\n    isQualifierPosition: true,\n    tournamentRecord,\n    drawDefinition,\n    drawPosition,\n    structureId,\n  });\n}\n","import { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { collectionGroupUpdate } from './collectionGroupUpdate';\nimport { getTieFormat } from '../../../query/hierarchical/tieFormats/getTieFormat';\nimport { tieFormatTelemetry } from './tieFormatTelemetry';\nimport { validateTieFormat } from '../../../validators/validateTieFormat';\nimport { copyTieFormat } from '../../../query/hierarchical/tieFormats/copyTieFormat';\n\nimport { TIE_FORMAT_MODIFICATIONS } from '../../../constants/extensionConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_VALUE,\n} from '../../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  MatchUp,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype RemoveCollectionGroupArgs = {\n  updateInProgressMatchUps?: boolean;\n  collectionGroupNumber: number;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  tieFormatName?: string;\n  structureId: string;\n  matchUpId: string;\n  matchUp?: MatchUp;\n  eventId?: string;\n  event?: Event;\n};\nexport function removeCollectionGroup({\n  updateInProgressMatchUps = true,\n  collectionGroupNumber,\n  tournamentRecord,\n  drawDefinition,\n  tieFormatName,\n  structureId,\n  matchUpId,\n  matchUp,\n  eventId,\n  event,\n}: RemoveCollectionGroupArgs) {\n  if (!collectionGroupNumber) return { error: MISSING_VALUE };\n  if (isNaN(collectionGroupNumber)) return { error: INVALID_VALUES };\n  const stack = 'removeCollectionGroup';\n\n  let result = !matchUp\n    ? getTieFormat({\n        drawDefinition,\n        structureId,\n        matchUpId,\n        eventId,\n        event,\n      })\n    : undefined;\n  if (result?.error) return decorateResult({ result, stack });\n\n  const structure = result?.structure;\n  matchUp = matchUp ?? result?.matchUp;\n  const existingTieFormat = result?.tieFormat;\n  const originalValueGoal = existingTieFormat?.winCriteria.valueGoal;\n  const wasAggregateValue = existingTieFormat?.winCriteria.aggregateValue;\n  const tieFormat = copyTieFormat(existingTieFormat);\n\n  result = validateTieFormat({ tieFormat });\n  if (result.error) return decorateResult({ result, stack });\n\n  const modifiedCollectionIds: string[] = [];\n  // remove the collectionGroup and all references to it in other collectionDefinitions\n  tieFormat.collectionDefinitions = tieFormat.collectionDefinitions.map(\n    (collectionDefinition) => {\n      const { collectionGroupNumber: groupNumber, ...rest } =\n        collectionDefinition;\n      if (groupNumber !== collectionGroupNumber) {\n        return collectionDefinition;\n      } else {\n        modifiedCollectionIds.push(collectionDefinition.collectionId);\n        return rest;\n      }\n    }\n  );\n  tieFormat.collectionGroups = tieFormat.collectionGroups.filter(\n    ({ groupNumber }) => groupNumber !== collectionGroupNumber\n  );\n\n  result = collectionGroupUpdate({\n    updateInProgressMatchUps,\n    originalValueGoal,\n    wasAggregateValue,\n    tournamentRecord,\n    drawDefinition,\n    tieFormatName,\n    structureId,\n    structure,\n    tieFormat,\n    matchUpId,\n    matchUp,\n    eventId,\n    event,\n  });\n\n  if (!result.error) {\n    const { appliedPolicies } = getAppliedPolicies({ tournamentRecord });\n    if (appliedPolicies?.audit?.[TIE_FORMAT_MODIFICATIONS]) {\n      const auditData = definedAttributes({\n        drawId: drawDefinition?.drawId,\n        collectionGroupNumber,\n        action: stack,\n        structureId,\n        matchUpId,\n        eventId,\n      });\n      tieFormatTelemetry({ drawDefinition, auditData });\n    }\n  }\n\n  return decorateResult({\n    result: { ...result, modifiedCollectionIds },\n    stack,\n  });\n}\n","import { removeExtension } from '../../extensions/removeExtension';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\n\nimport { DELEGATED_OUTCOME } from '../../../constants/extensionConstants';\nimport {\n  MATCHUP_NOT_FOUND,\n  MISSING_DRAW_DEFINITION,\n  MISSING_MATCHUP_ID,\n} from '../../../constants/errorConditionConstants';\n\nexport function removeDelegatedOutcome({ drawDefinition, event, matchUpId }) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n\n  const { matchUp } = findDrawMatchUp({ drawDefinition, event, matchUpId });\n  if (!matchUp) return { error: MATCHUP_NOT_FOUND };\n\n  return removeExtension({\n    name: DELEGATED_OUTCOME,\n    element: matchUp,\n  });\n}\n","import { getAssignedParticipantIds } from '../../query/drawDefinition/getAssignedParticipantIds';\nimport { refreshEntryPositions } from '../entries/refreshEntryPositions';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { overlap } from '../../utilities/arrays';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_EVENT,\n  MISSING_PARTICIPANT_IDS,\n  MISSING_DRAW_ID,\n  EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT,\n} from '../../constants/errorConditionConstants';\n\nexport function removeDrawEntries({\n  autoEntryPositions = true,\n  participantIds,\n  drawDefinition,\n  drawId,\n  stages,\n  event,\n}) {\n  if (!event) return { error: MISSING_EVENT };\n  if (!drawId) return { error: MISSING_DRAW_ID };\n  if (!participantIds?.length) return { error: MISSING_PARTICIPANT_IDS };\n\n  const assignedParticipantIds =\n    getAssignedParticipantIds({\n      drawDefinition,\n      stages,\n    }).assignedParticipantIds ?? [];\n  const someAssignedParticipantIds = overlap(\n    assignedParticipantIds,\n    participantIds\n  );\n\n  if (someAssignedParticipantIds)\n    return { error: EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT };\n\n  const filterEntry = (entry) => {\n    const entryId = entry.participantId;\n    return !participantIds.includes(entryId);\n  };\n\n  const { flightProfile } = getFlightProfile({ event });\n  const flight = flightProfile?.flights?.find(\n    (flight) => flight.drawId === drawId\n  );\n  if (flight?.drawEntries) {\n    flight.drawEntries = flight.drawEntries.filter(filterEntry);\n    if (autoEntryPositions) {\n      flight.drawEntries = refreshEntryPositions({\n        entries: flight.drawEntries,\n      });\n    }\n  }\n\n  if (drawDefinition?.entries) {\n    drawDefinition.entries = drawDefinition.entries.filter(filterEntry);\n    if (autoEntryPositions) {\n      drawDefinition.entries = refreshEntryPositions({\n        entries: drawDefinition.entries,\n      });\n    }\n  }\n\n  return { ...SUCCESS };\n}\n","import { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\n\nimport { AD_HOC } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_DRAW_TYPE,\n  INVALID_VALUES,\n  MATCHUP_NOT_FOUND,\n  MISSING_DRAW_DEFINITION,\n  MISSING_MATCHUP_ID,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../../constants/errorConditionConstants';\n\nexport function removeMatchUpSideParticipant({\n  tournamentRecord,\n  drawDefinition,\n  sideNumber,\n  matchUpId,\n  event,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n  if (!sideNumber) return { error: MISSING_VALUE };\n\n  if (![1, 2].includes(sideNumber))\n    return { error: INVALID_VALUES, sideNumber };\n\n  const { matchUp, structure } = findDrawMatchUp({\n    drawDefinition,\n    matchUpId,\n    event,\n  });\n\n  if (!matchUp) return { error: MATCHUP_NOT_FOUND };\n\n  const isAdHoc =\n    !structure?.structures &&\n    !(drawDefinition.drawType && drawDefinition.drawType !== AD_HOC) &&\n    !structure?.matchUps?.find(({ roundPosition }) => !!roundPosition);\n\n  if (!isAdHoc) return { error: INVALID_DRAW_TYPE };\n\n  matchUp.sides?.forEach((side) => {\n    if (side.sideNumber === sideNumber) delete side.participantId;\n  });\n\n  modifyMatchUpNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    context: 'assignSideParticipant',\n    drawDefinition,\n    matchUp,\n  });\n\n  return { ...SUCCESS };\n}\n","import { isAdHoc } from '../../query/drawDefinition/isAdHoc';\nimport { findStructure } from '../../acquire/findStructure';\nimport { numericSort } from '../../utilities/sorting';\nimport {\n  deleteMatchUpsNotice,\n  modifyMatchUpNotice,\n} from '../notifications/drawNotifications';\n\nimport { completedMatchUpStatuses } from '../../constants/matchUpStatusConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_STRUCTURE,\n  MISSING_DRAW_DEFINITION,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\nimport { DrawDefinition, Event, Tournament } from '../../types/tournamentTypes';\n\ntype RemoveRoundMatchUpsArgs = {\n  removeCompletedMatchUps?: boolean;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  structureId: string;\n  roundNumber: number;\n  event: Event;\n};\nexport function removeRoundMatchUps({\n  removeCompletedMatchUps,\n  tournamentRecord,\n  drawDefinition,\n  structureId,\n  roundNumber,\n  event,\n}: RemoveRoundMatchUpsArgs): ResultType & {\n  deletedMatchUpsCount?: number;\n  roundRemoved?: boolean;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!roundNumber)\n    return decorateResult({\n      result: { error: MISSING_VALUE },\n      info: 'roundNumber required',\n    });\n\n  const structureResult = findStructure({ drawDefinition, structureId });\n  if (structureResult.error) return structureResult;\n\n  const structure = structureResult.structure;\n  // cannot be a round robin structure\n  if (structure?.structures) return { error: INVALID_STRUCTURE };\n\n  const isAdHocStructure = isAdHoc({ drawDefinition, structure });\n\n  if (isAdHocStructure) {\n    return removeAdHocRound({\n      tournamentId: tournamentRecord.tournamentId,\n      removeCompletedMatchUps,\n      eventId: event.eventId,\n      drawDefinition,\n      roundNumber,\n      structure,\n    });\n  } else {\n    console.log('not implemented');\n  }\n\n  return { ...SUCCESS };\n}\n\n// TODO: move to drawEngine and passthrough\nfunction removeAdHocRound({\n  removeCompletedMatchUps,\n  drawDefinition,\n  tournamentId,\n  roundNumber,\n  structure,\n  eventId,\n}): ResultType & { deletedMatchUpsCount?: number; roundRemoved?: boolean } {\n  const matchUps = structure?.matchUps ?? [];\n  const deletedMatchUpIds: string[] = [];\n  let roundRemoved = false;\n\n  const roundNumbers: number[] = matchUps\n    .reduce((nums: number[], matchUp) => {\n      const roundNumber = matchUp?.roundNumber;\n      if (!roundNumber) return nums;\n      return nums.includes(roundNumber) ? nums : nums.concat(roundNumber);\n    }, [])\n    .sort(numericSort);\n  if (roundNumbers.includes(roundNumber)) {\n    const updatedMatchUps = matchUps.filter((matchUp) => {\n      const target =\n        matchUp.roundNumber === roundNumber &&\n        (!completedMatchUpStatuses.includes(matchUp.matchUpStatus) ||\n          removeCompletedMatchUps);\n      if (target) deletedMatchUpIds.push(matchUp.matchUpId);\n\n      return !target;\n    });\n\n    if (deletedMatchUpIds.length) {\n      deleteMatchUpsNotice({\n        matchUpIds: deletedMatchUpIds,\n        drawDefinition,\n        tournamentId,\n        eventId,\n      });\n\n      const stillContainsRoundNumber = updatedMatchUps.some(\n        (matchUp) => matchUp.roundNumber === roundNumber\n      );\n\n      if (!stillContainsRoundNumber) {\n        updatedMatchUps.forEach((matchUp) => {\n          if (matchUp.roundNumber > roundNumber) {\n            matchUp.roundNumber -= 1;\n\n            modifyMatchUpNotice({\n              drawDefinition,\n              tournamentId,\n              eventId,\n              matchUp,\n            });\n          }\n        });\n        roundRemoved = true;\n      }\n\n      structure.matchUps = updatedMatchUps;\n    }\n  }\n\n  return {\n    deletedMatchUpsCount: deletedMatchUpIds.length,\n    roundRemoved,\n    ...SUCCESS,\n  };\n}\n","import {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\n\nimport { DrawDefinition, Tournament } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_STRUCTURE,\n  MISSING_DRAW_DEFINITION,\n  MISSING_TOURNAMENT_RECORD,\n  NOT_FOUND,\n  STRUCTURE_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\nimport { MAIN, QUALIFYING } from '../../constants/drawDefinitionConstants';\n\ntype RemoveSeededParticipantArgs = {\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  participantId: string;\n  structureId: string;\n};\n\nexport function removeSeededParticipant({\n  tournamentRecord,\n  drawDefinition,\n  participantId,\n  structureId,\n}: RemoveSeededParticipantArgs): ResultType {\n  const stack = 'removeSeededParticipant';\n\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const structure = (drawDefinition.structures ?? []).find(\n    (structure) => structure.structureId === structureId\n  );\n  if (!structure)\n    return decorateResult({ result: { error: STRUCTURE_NOT_FOUND }, stack });\n\n  if (\n    !structure.stage ||\n    ![MAIN, QUALIFYING].includes(structure.stage) ||\n    (structure.stage === MAIN && structure.stageSequence !== 1)\n  ) {\n    return decorateResult({ result: { error: INVALID_STRUCTURE }, stack });\n  }\n\n  const seedAssignment = structure.seedAssignments?.find(\n    (assignment) => assignment.participantId === participantId\n  );\n\n  if (!seedAssignment)\n    return decorateResult({\n      info: 'participant not seeded',\n      result: { error: NOT_FOUND },\n      context: { participantId },\n    });\n\n  // TODO: implement rotation of seeded players\n\n  return { ...SUCCESS };\n}\n","import { removeScaleValues } from './removeScaleValues';\n\nimport { SEEDING } from '../../constants/scaleConstants';\nimport {\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\nexport function removeSeeding({\n  tournamentRecord,\n  drawDefinition,\n  entryStatuses,\n  scaleName,\n  drawId,\n  event,\n  stage,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n\n  scaleName =\n    scaleName ||\n    event.category?.categoryName ||\n    event.category?.ageCategoryCode;\n\n  const scaleAttributes = {\n    eventType: event.eventType,\n    scaleType: SEEDING,\n    scaleName,\n  };\n\n  return removeScaleValues({\n    tournamentRecord,\n    scaleAttributes,\n    drawDefinition,\n    entryStatuses,\n    drawId,\n    event,\n    stage,\n  });\n}\n","import { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { checkScoreHasValue } from '../../../query/matchUp/checkScoreHasValue';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { getMatchUpIds } from '../../../global/functions/extractors';\nimport { xa } from '../../../utilities/objects';\nimport { resequenceStructures } from './resequenceStructures';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { deleteMatchUpsNotice, modifyDrawNotice } from '../../notifications/drawNotifications';\n\nimport { MAIN, QUALIFYING } from '../../../constants/drawDefinitionConstants';\nimport { POLICY_TYPE_SCORING } from '../../../constants/policyConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  CANNOT_REMOVE_MAIN_STRUCTURE,\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n  MISSING_STRUCTURE_ID,\n  SCORES_PRESENT,\n  STRUCTURE_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\nimport { DrawDefinition, Event, Tournament } from '../../../types/tournamentTypes';\n\ntype RemoveStructureArgs = {\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  structureId: string;\n  force?: boolean;\n  event: Event;\n};\n\nexport function removeStructure({ tournamentRecord, drawDefinition, structureId, event, force }: RemoveStructureArgs) {\n  if (typeof structureId !== 'string') return { error: INVALID_VALUES };\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structureId) return { error: MISSING_STRUCTURE_ID };\n\n  const structures = drawDefinition.structures ?? [];\n  const removedStructureIds: string[] = [];\n\n  const structure = structures.find((structure) => structure.structureId === structureId);\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  // TODO: if structure being rmoved is qualifying structure, ensure no source structures have scored matchUps\n  const structureMatchUps = getAllStructureMatchUps({ structure }).matchUps;\n  const scoresPresent = structureMatchUps.some(({ score }) => checkScoreHasValue({ score }));\n\n  if (scoresPresent) {\n    const appliedPolicies = getAppliedPolicies({\n      tournamentRecord,\n      drawDefinition,\n      structure,\n      event,\n    })?.appliedPolicies;\n\n    const allowDeletionWithScoresPresent =\n      force ?? appliedPolicies?.[POLICY_TYPE_SCORING]?.allowDeletionWithScoresPresent?.structures;\n\n    if (!allowDeletionWithScoresPresent) return { error: SCORES_PRESENT };\n  }\n\n  const mainStageSequence1 = structures.find(({ stage, stageSequence }) => stage === MAIN && stageSequence === 1);\n  const isMainStageSequence1 = structureId === mainStageSequence1?.structureId;\n  const qualifyingStructureIds = structures.filter(({ stage }) => stage === QUALIFYING).map(xa('structureId'));\n\n  if (isMainStageSequence1 && !qualifyingStructureIds.length) {\n    return { error: CANNOT_REMOVE_MAIN_STRUCTURE };\n  }\n\n  const structureIds: string[] = structures.map(xa('structureId'));\n  const removedMatchUpIds: string[] = [];\n\n  const getTargetedStructureIds = (structureId) =>\n    drawDefinition.links\n      ?.map(\n        (link) =>\n          link.source.structureId === structureId &&\n          link.target.structureId !== mainStageSequence1?.structureId &&\n          link.target.structureId,\n      )\n      .filter(Boolean) ?? [];\n\n  const getQualifyingSourceStructureIds = (structureId) =>\n    drawDefinition.links\n      ?.map(\n        (link) =>\n          qualifyingStructureIds.includes(link.source.structureId) &&\n          link.target.structureId === structureId &&\n          link.source.structureId,\n      )\n      .filter(Boolean) ?? [];\n\n  const isQualifyingStructure = qualifyingStructureIds.includes(structureId);\n  const relatedStructureIdsMap = new Map<string, string[]>();\n  structureIds.forEach((id) =>\n    relatedStructureIdsMap.set(\n      id,\n      isQualifyingStructure\n        ? (getQualifyingSourceStructureIds(id) as string[])\n        : (getTargetedStructureIds(id) as string[]),\n    ),\n  );\n\n  const idsToRemove = isMainStageSequence1 ? relatedStructureIdsMap.get(structureId) : [structureId];\n\n  while (idsToRemove?.length) {\n    const idBeingRemoved = idsToRemove.pop();\n    const { structure } = findStructure({\n      structureId: idBeingRemoved,\n      drawDefinition,\n    });\n    const { matchUps } = getAllStructureMatchUps({ structure });\n    const matchUpIds = getMatchUpIds(matchUps);\n    removedMatchUpIds.push(...matchUpIds);\n\n    drawDefinition.links =\n      drawDefinition.links?.filter(\n        (link) => link.source.structureId !== idBeingRemoved && link.target.structureId !== idBeingRemoved,\n      ) ?? [];\n\n    if (\n      !isMainStageSequence1 ||\n      (isMainStageSequence1 && qualifyingStructureIds.length) ||\n      idBeingRemoved !== structureId\n    ) {\n      drawDefinition.structures = (drawDefinition.structures ?? []).filter((structure) => {\n        if (idBeingRemoved && idBeingRemoved === structure.structureId) removedStructureIds.push(idBeingRemoved);\n        return structure.structureId !== idBeingRemoved;\n      });\n    }\n\n    const targetedStructureIds =\n      idBeingRemoved &&\n      relatedStructureIdsMap.get(idBeingRemoved)?.filter(\n        (id: string) =>\n          // IMPORTANT: only delete MAIN stageSequence: 1 if specified to protect against DOUBLE_ELIMINATION scenario\n          id !== mainStageSequence1?.structureId || structureId === mainStageSequence1.structureId,\n      );\n    if (targetedStructureIds?.length) idsToRemove.push(...targetedStructureIds);\n  }\n\n  // now get all remaining matchUps in the draw\n  const { matchUps } = getAllDrawMatchUps({ drawDefinition });\n  matchUps?.forEach((matchUp) => {\n    if (matchUp.winnerMatchUpId && removedMatchUpIds.includes(matchUp.winnerMatchUpId)) {\n      delete matchUp.winnerMatchUpId;\n    }\n    if (matchUp.loserMatchUpId && removedMatchUpIds.includes(matchUp.loserMatchUpId)) {\n      delete matchUp.loserMatchUpId;\n    }\n  });\n\n  // if this is MAIN stageSequence: 1 there must be qualifying, return to empty state\n  if (isMainStageSequence1) {\n    const mainStageSequence1MatchUpIds = (mainStageSequence1.matchUps ?? [])?.map(xa('matchUpId'));\n    removedMatchUpIds.push(...mainStageSequence1MatchUpIds);\n\n    mainStageSequence1.positionAssignments = [];\n    mainStageSequence1.seedAssignments = [];\n    mainStageSequence1.matchUps = [];\n    if (mainStageSequence1.extensions) {\n      mainStageSequence1.extensions = [];\n    }\n  }\n\n  isQualifyingStructure && resequenceStructures({ drawDefinition });\n\n  deleteMatchUpsNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    matchUpIds: removedMatchUpIds,\n    action: 'removeStructure',\n    eventId: event?.eventId,\n    drawDefinition,\n  });\n  modifyDrawNotice({ drawDefinition, eventId: event?.eventId });\n\n  return { ...SUCCESS, removedMatchUpIds, removedStructureIds };\n}\n","import { removeCollectionAssignments } from '../../events/removeCollectionAssignments';\nimport { getPairedParticipant } from '../../../query/participant/getPairedParticipant';\nimport { ResultType, decorateResult } from '../../../global/functions/decorateResult';\nimport { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { checkScoreHasValue } from '../../../query/matchUp/checkScoreHasValue';\nimport { getParticipants } from '../../../query/participants/getParticipants';\nimport { deleteParticipants } from '../../participants/deleteParticipants';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { modifyParticipant } from '../../participants/modifyParticipant';\nimport { updateTeamLineUp } from '../../drawDefinitions/updateTeamLineUp';\nimport { getTieMatchUpContext } from '../../events/getTieMatchUpContext';\nimport { addParticipant } from '../../participants/addParticipant';\nimport { ensureSideLineUps } from './ensureSideLineUps';\n\nimport POLICY_MATCHUP_ACTIONS_DEFAULT from '../../../fixtures/policies/POLICY_MATCHUP_ACTIONS_DEFAULT';\nimport { DrawDefinition, Event, Tournament } from '../../../types/tournamentTypes';\nimport { POLICY_TYPE_MATCHUP_ACTIONS } from '../../../constants/policyConstants';\nimport { INDIVIDUAL, PAIR } from '../../../constants/participantConstants';\nimport { LineUp, PolicyDefinitions } from '../../../types/factoryTypes';\nimport { DOUBLES, SINGLES } from '../../../constants/matchUpTypes';\nimport { COMPETITOR } from '../../../constants/participantRoles';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  EXISTING_OUTCOME,\n  INVALID_PARTICIPANT,\n  INVALID_PARTICIPANT_IDS,\n  MISSING_MATCHUP,\n  MISSING_PARTICIPANT_ID,\n  PARTICIPANT_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\n\ntype RemoveTieMatchUpParticipantIdArgs = {\n  policyDefinitions?: PolicyDefinitions;\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  participantId: string;\n  tieMatchUpId: string;\n  event: Event;\n};\n\nexport function removeTieMatchUpParticipantId(\n  params: RemoveTieMatchUpParticipantIdArgs,\n): ResultType & { modifiedLineUp?: LineUp } {\n  const { tournamentRecord, drawDefinition, participantId, event } = params;\n  const stack = 'removeTieMatchUpParticiapantId';\n\n  if (!participantId) return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack });\n\n  const matchUpContext = getTieMatchUpContext(params);\n  if (matchUpContext.error) return matchUpContext;\n\n  const { appliedPolicies } = getAppliedPolicies({\n    tournamentRecord,\n    drawDefinition,\n    event,\n  });\n\n  const matchUpActionsPolicy =\n    params.policyDefinitions?.[POLICY_TYPE_MATCHUP_ACTIONS] ??\n    appliedPolicies?.[POLICY_TYPE_MATCHUP_ACTIONS] ??\n    POLICY_MATCHUP_ACTIONS_DEFAULT[POLICY_TYPE_MATCHUP_ACTIONS];\n\n  const substitutionProcessCodes = matchUpActionsPolicy?.processCodes?.substitution;\n\n  const {\n    inContextDualMatchUp,\n    inContextTieMatchUp,\n    relevantAssignments,\n    collectionPosition,\n    teamParticipants,\n    collectionId,\n    matchUpType,\n    dualMatchUp,\n    tieMatchUp,\n    tieFormat,\n  } = matchUpContext;\n\n  if (!dualMatchUp) return decorateResult({ result: { error: MISSING_MATCHUP }, stack });\n\n  const side: any = inContextTieMatchUp?.sides?.find(\n    (side: any) =>\n      side.participant?.participantId === participantId ||\n      side.participant?.individualParticipantIds?.includes(participantId),\n  );\n  if (!side) return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack });\n\n  if (\n    !side.substitutions?.length &&\n    (checkScoreHasValue({ score: inContextTieMatchUp?.score }) || inContextTieMatchUp?.winningSide)\n  )\n    return decorateResult({ result: { error: EXISTING_OUTCOME }, stack });\n\n  const teamParticipantId = inContextDualMatchUp?.sides?.find(({ sideNumber }) => sideNumber === side.sideNumber)\n    ?.participantId;\n\n  if (!teamParticipantId) return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack });\n\n  const participantToRemove = getParticipants({\n    participantFilters: { participantIds: [participantId] },\n    tournamentRecord,\n  })?.participants?.[0];\n\n  if (!participantToRemove) {\n    return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack });\n  }\n\n  if (matchUpType === SINGLES && participantToRemove.participantType === PAIR) {\n    return decorateResult({ result: { error: INVALID_PARTICIPANT }, stack });\n  }\n\n  const participantIds =\n    participantToRemove.participantType === INDIVIDUAL ? [participantId] : participantToRemove.individualParticipantIds;\n\n  ensureSideLineUps({\n    tournamentId: tournamentRecord.tournamentId,\n    eventId: event.eventId,\n    inContextDualMatchUp,\n    drawDefinition,\n    dualMatchUp,\n  });\n\n  let dualMatchUpSide = dualMatchUp.sides?.find(({ sideNumber }) => sideNumber === side.sideNumber);\n\n  if (!dualMatchUpSide && (dualMatchUp.sides?.filter(({ lineUp }) => !lineUp).length || 0) < 2) {\n    const drawPositionMap = teamParticipants?.map(({ participantId: teamParticipantId }) => ({\n      drawPosition: relevantAssignments?.find((assignment) => assignment.participantId === teamParticipantId)\n        ?.drawPosition,\n      teamParticipantId,\n    }));\n\n    dualMatchUpSide = dualMatchUp.sides?.find(\n      (side: any) =>\n        drawPositionMap?.find(({ drawPosition }) => drawPosition === side.drawPosition)?.teamParticipantId ===\n        teamParticipantId,\n    );\n  }\n\n  if (!dualMatchUpSide) {\n    return decorateResult({\n      result: { error: PARTICIPANT_NOT_FOUND, context: { participantId } },\n    });\n  }\n\n  const { modifiedLineUp, previousParticipantIds } = removeCollectionAssignments({\n    collectionPosition,\n    teamParticipantId,\n    dualMatchUpSide,\n    participantIds,\n    drawDefinition,\n    collectionId,\n  });\n\n  dualMatchUpSide.lineUp = modifiedLineUp;\n\n  teamParticipantId &&\n    tieFormat &&\n    updateTeamLineUp({\n      participantId: teamParticipantId,\n      lineUp: modifiedLineUp,\n      drawDefinition,\n      tieFormat,\n    });\n\n  // if an INDIVIDUAL participant is being removed from a DOUBLES matchUp\n  // ...then the PAIR participant may need to be modified\n  if (matchUpType === DOUBLES && participantToRemove.participantType === INDIVIDUAL) {\n    const tieMatchUpSide = inContextTieMatchUp?.sides?.find((side) => side.sideNumber === dualMatchUpSide?.sideNumber);\n\n    const { participantId: pairParticipantId } = tieMatchUpSide ?? {};\n\n    const pairParticipant =\n      pairParticipantId &&\n      getParticipants({\n        participantFilters: { participantIds: [pairParticipantId] },\n        tournamentRecord,\n        withDraws: true,\n      })?.participants?.[0];\n\n    if (pairParticipant) {\n      const individualParticipantIds: string[] =\n        pairParticipant?.individualParticipantIds?.filter((currentId) => currentId !== participantId) ?? [];\n\n      if (previousParticipantIds) individualParticipantIds.push(...previousParticipantIds);\n\n      if (individualParticipantIds.length > 2) {\n        return decorateResult({\n          result: { error: INVALID_PARTICIPANT_IDS },\n          stack,\n        });\n      }\n\n      // don't modify pair participant that is part of other events/draws\n      if (!pairParticipant.draws?.length) {\n        if (individualParticipantIds.length) {\n          pairParticipant.individualParticipantIds = individualParticipantIds;\n          const result = modifyParticipant({\n            participant: pairParticipant,\n            pairOverride: true,\n            tournamentRecord,\n          });\n          if (result.error) return decorateResult({ result, stack });\n        } else {\n          const result = deleteParticipants({\n            participantIds: [pairParticipantId],\n            tournamentRecord,\n          });\n          if (result.error) console.log('cleanup', { result });\n        }\n      } else if (individualParticipantIds.length === 1) {\n        const { participant: existingParticipant } = getPairedParticipant({\n          participantIds: individualParticipantIds,\n          tournamentRecord,\n        });\n        if (!existingParticipant) {\n          const newPairParticipant = {\n            participantRole: COMPETITOR,\n            individualParticipantIds,\n            participantType: PAIR,\n          };\n          const result = addParticipant({\n            participant: newPairParticipant,\n            pairOverride: true,\n            tournamentRecord,\n          });\n          if (result.error) return decorateResult({ result, stack });\n        }\n      }\n    } else {\n      return decorateResult({\n        result: { error: PARTICIPANT_NOT_FOUND },\n        stack,\n      });\n    }\n  }\n\n  // if there was only one subsitution on target side and there are no substiutions on other side\n  if (side.substitutions?.length === 1) {\n    const otherSide: any = inContextTieMatchUp?.sides?.find((s) => s.sideNumber !== side.sideNumber);\n    if (!otherSide?.substitutions?.length && tieMatchUp?.processCodes?.length) {\n      // remove processCode(s)\n      for (const substitutionProcessCode of substitutionProcessCodes || []) {\n        const codeIndex = tieMatchUp.processCodes.lastIndexOf(substitutionProcessCode);\n        // remove only one instance of substitutionProcessCode\n        tieMatchUp.processCodes.splice(codeIndex, 1);\n      }\n\n      modifyMatchUpNotice({\n        tournamentId: tournamentRecord?.tournamentId,\n        matchUp: tieMatchUp,\n        context: stack,\n        drawDefinition,\n      });\n    }\n  }\n\n  modifyMatchUpNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    matchUp: dualMatchUp,\n    context: stack,\n    drawDefinition,\n  });\n\n  return { ...SUCCESS, modifiedLineUp };\n}\n","import { isObject } from '../../../utilities/objects';\n\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { DrawDefinition } from '../../../types/tournamentTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n  MISSING_VALUE,\n} from '../../../constants/errorConditionConstants';\n\ntype RenameStructuresArgs = {\n  drawDefinition: DrawDefinition;\n  structureDetails: { structureId: string; structureName: string }[];\n};\n\nexport function renameStructures({\n  drawDefinition,\n  structureDetails,\n}: RenameStructuresArgs): ResultType {\n  if (!Array.isArray(structureDetails)) return { error: INVALID_VALUES };\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const detailMap = Object.assign(\n    {},\n    ...structureDetails\n      .map((detail) => {\n        if (!isObject(detail)) return;\n        const { structureId, structureName } = detail || {};\n        if (!structureId || !structureName) return;\n        return { [structureId]: structureName };\n      })\n      .filter(Boolean)\n  );\n\n  if (!Object.values(detailMap).length) {\n    return { error: MISSING_VALUE };\n  }\n\n  for (const structure of drawDefinition.structures || []) {\n    const structureName = detailMap[structure.structureId];\n    if (structureName) {\n      structure.structureName = structureName;\n    }\n  }\n\n  return { ...SUCCESS };\n}\n","import { getAllStructureMatchUps } from '../../query/matchUps/getAllStructureMatchUps';\nimport { getMatchUpsMap } from '../../query/matchUps/getMatchUpsMap';\nimport {\n  modifyDrawNotice,\n  modifyMatchUpNotice,\n} from '../notifications/drawNotifications';\n\nimport { MISSING_DRAW_DEFINITION } from '../../constants/errorConditionConstants';\nimport { toBePlayed } from '../../fixtures/scoring/outcomes/toBePlayed';\nimport { BYE } from '../../constants/matchUpStatusConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { MAIN, QUALIFYING } from '../../constants/drawDefinitionConstants';\nimport {\n  ASSIGN_COURT,\n  ASSIGN_VENUE,\n  ASSIGN_OFFICIAL,\n  SCHEDULED_DATE,\n  SCHEDULED_TIME,\n  ALLOCATE_COURTS,\n} from '../../constants/timeItemConstants';\nimport { TimeItem } from '../../types/tournamentTypes';\n\nexport function resetDrawDefinition({\n  tournamentRecord,\n  removeScheduling,\n  drawDefinition,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  // for matchups in all structures:\n  // remove all drawPositions which are not first round or fed\n  // remove all extensions\n  // if removeScheudling, remove all scheduling timeItems\n\n  // for all structures which are NOT QUALIFYING or MAIN { stageSequence: 1 }\n  // remove all positionAssignments that are not BYE\n\n  const matchUpsMap = getMatchUpsMap({ drawDefinition });\n\n  const getRawMatchUp = (matchUpId) =>\n    matchUpsMap?.drawMatchUps?.find(\n      (matchUp) => matchUp.matchUpId === matchUpId\n    );\n\n  for (const structure of drawDefinition.structures || []) {\n    const { positionAssignments, stage, stageSequence } = structure;\n\n    // reset positionAssignments and seedAssignments where appropriate\n    if (\n      positionAssignments &&\n      (stageSequence !== 1 || ![QUALIFYING, MAIN].includes(stage))\n    ) {\n      structure.positionAssignments = positionAssignments.map((assignment) => {\n        delete assignment.participantId;\n        return assignment;\n      });\n      structure.seedAssignments = [];\n    }\n\n    const { matchUps: inContextMatchUps } = getAllStructureMatchUps({\n      afterRecoveryTimes: false,\n      inContext: true,\n      matchUpsMap,\n      structure,\n    });\n\n    // reset all matchUps to initial state\n    for (const inContextMatchUp of inContextMatchUps) {\n      const { matchUpId, roundNumber, sides } = inContextMatchUp;\n      const matchUp = getRawMatchUp(matchUpId);\n      if (matchUp) {\n        delete matchUp.extensions;\n        delete matchUp.notes;\n\n        if (matchUp.matchUpStatus !== BYE) {\n          Object.assign(matchUp, toBePlayed);\n        }\n\n        if (roundNumber && roundNumber > 1 && matchUp.drawPositions) {\n          const fedDrawPositions = sides\n            ?.map(\n              ({ drawPosition, participantFed }) =>\n                !participantFed && drawPosition\n            )\n            .filter(Boolean);\n          const drawPositions = matchUp.drawPositions.map((drawPosition) =>\n            !fedDrawPositions.includes(drawPosition) ? drawPosition : undefined\n          ) as number[];\n          matchUp.drawPositions = drawPositions;\n        }\n\n        if (removeScheduling) {\n          delete matchUp.timeItems;\n        } else if (matchUp.timeItems?.length) {\n          matchUp.timeItems = matchUp.timeItems.filter(\n            (timeItem: TimeItem) =>\n              timeItem.itemType &&\n              ![\n                ALLOCATE_COURTS,\n                ASSIGN_COURT,\n                ASSIGN_VENUE,\n                ASSIGN_OFFICIAL,\n                SCHEDULED_DATE,\n                SCHEDULED_TIME,\n              ].includes(timeItem.itemType)\n          );\n        }\n\n        modifyMatchUpNotice({\n          tournamentId: tournamentRecord?.tournamentId,\n          context: 'resetDrawDefiniton',\n          drawDefinition,\n          matchUp,\n        });\n      }\n    }\n  }\n\n  const structureIds = (drawDefinition.structures || []).map(\n    ({ structureId }) => structureId\n  );\n\n  modifyDrawNotice({ drawDefinition, structureIds });\n\n  return { ...SUCCESS };\n}\n","import { updateTeamLineUp } from '../../drawDefinitions/updateTeamLineUp';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_MATCHUP,\n  MISSING_DRAW_DEFINITION,\n} from '../../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\ntype ResetMatchUpLineUps = {\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  inheritance?: boolean;\n  matchUpId: string;\n  event?: Event;\n};\nexport function resetMatchUpLineUps({\n  inheritance = true,\n  tournamentRecord,\n  drawDefinition,\n  matchUpId,\n  event,\n}: ResetMatchUpLineUps) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const matchUp = findDrawMatchUp({\n    drawDefinition,\n    matchUpId,\n  })?.matchUp;\n\n  if (!matchUp?.tieMatchUps) return { error: INVALID_MATCHUP };\n\n  const inContextMatchUp = findDrawMatchUp({\n    inContext: true,\n    drawDefinition,\n    matchUpId,\n    event,\n  })?.matchUp;\n\n  let modificationsCount = 0;\n\n  (matchUp?.sides || []).forEach((side) => {\n    if (side.lineUp) delete side.lineUp;\n  });\n\n  (inContextMatchUp?.sides || []).forEach((side) => {\n    modificationsCount += 1;\n\n    if (inheritance === false) {\n      const tieFormat = inContextMatchUp?.tieFormat;\n      const participantId = side.participantId;\n\n      if (tieFormat && participantId) {\n        updateTeamLineUp({\n          drawDefinition,\n          participantId,\n          lineUp: [],\n          tieFormat,\n        });\n      }\n    }\n\n    modifyMatchUpNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      context: 'resetMatchUpLineUps',\n      eventId: event?.eventId,\n      drawDefinition,\n      matchUp,\n    });\n  });\n\n  return { ...SUCCESS, modificationsCount };\n}\n","import { isActiveDownstream } from '../drawDefinitions/matchUpGovernor/isActiveDownstream';\nimport { compareTieFormats } from '../../query/hierarchical/tieFormats/compareTieFormats';\nimport { resolveTieFormat } from '../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { getAllDrawMatchUps } from '../../query/matchUps/drawMatchUps';\nimport { getMatchUpsMap } from '../../query/matchUps/getMatchUpsMap';\nimport { positionTargets } from './drawPositions/positionTargets';\nimport { setMatchUpState } from './matchUpStatus/setMatchUpState';\nimport { updateTieMatchUpScore } from './score/tieMatchUpScore';\nimport { resetTieFormat } from '../tieFormat/resetTieFormat';\nimport { findStructure } from '../../acquire/findStructure';\nimport { isString } from '../../utilities/objects';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\n\nimport { DrawDefinition, Event, Tournament } from '../../types/tournamentTypes';\nimport { TEAM_EVENT } from '../../constants/eventConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MATCHUP_NOT_FOUND,\n  MISSING_DRAW_DEFINITION,\n  INVALID_VALUES,\n  CANNOT_CHANGE_WINNING_SIDE,\n  MISSING_MATCHUP_ID,\n  INVALID_MATCHUP,\n} from '../../constants/errorConditionConstants';\n\n/**\n *\n * @param {string} drawDefinition - required to collect all draw matchUps for scenario analysis\n * @param {string} matchUpId - id of the matchUp to be modified\n * @param {object} score - score object { sets: [] }\n * @param {string} matchUpStatus - optional - new matchUpStatus\n * @param {number} winningSide - optional - new winningSide; 1 or 2\n * @param {object} tournamentRecord - optional - used to discover relevant policyDefinitions or to modify scheduling information (integrity checks)\n * @param {boolean} tiebreakReset - optional - check for tiebreak scenarios and reset tieFormat\n * @returns\n */\n\ntype ResetScoreCardArgs = {\n  score?: { sets: { side1Score: number; side2Score: number }[] };\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  tiebreakReset?: boolean;\n  matchUpStatus?: string;\n  winningSide?: number;\n  matchUpId: string;\n  event?: Event;\n};\n\nexport function resetScorecard(params: ResetScoreCardArgs): ResultType {\n  const { tournamentRecord, drawDefinition, matchUpId, event } = params;\n  const stack = 'resetScorecard';\n\n  // Check for missing parameters ---------------------------------------------\n  if (!drawDefinition)\n    return decorateResult({\n      result: { error: MISSING_DRAW_DEFINITION },\n      stack,\n    });\n  if (!matchUpId)\n    return decorateResult({ result: { error: MISSING_MATCHUP_ID }, stack });\n  if (!isString(matchUpId))\n    return decorateResult({\n      result: { error: INVALID_VALUES, matchUpId },\n      stack,\n    });\n\n  // Get map of all drawMatchUps and inContextDrawMatchUPs ---------------------\n  const matchUpsMap = getMatchUpsMap({ drawDefinition });\n  const { matchUps: inContextDrawMatchUps } = getAllDrawMatchUps({\n    nextMatchUps: true,\n    inContext: true,\n    drawDefinition,\n    matchUpsMap,\n  });\n\n  // Find target matchUp ------------------------------------------------------\n  const matchUp = matchUpsMap.drawMatchUps.find(\n    (matchUp) => matchUp.matchUpId === matchUpId\n  );\n\n  const inContextMatchUp = inContextDrawMatchUps?.find(\n    (matchUp) => matchUp.matchUpId === matchUpId\n  );\n\n  if (!matchUp || !inContextDrawMatchUps) return { error: MATCHUP_NOT_FOUND };\n\n  // only accept matchUpType: TEAM\n  if (matchUp.matchUpType !== TEAM_EVENT) return { error: INVALID_MATCHUP };\n\n  // Get winner/loser position targets ----------------------------------------\n  const targetData = positionTargets({\n    inContextDrawMatchUps,\n    drawDefinition,\n    matchUpId,\n  });\n\n  const structureId = inContextMatchUp?.structureId;\n  const { structure } = findStructure({ drawDefinition, structureId });\n\n  Object.assign(params, {\n    inContextDrawMatchUps,\n    inContextMatchUp,\n    matchUpsMap,\n    targetData,\n    structure,\n    matchUp,\n  });\n\n  // with propagating winningSide changes, activeDownstream only applies to eventType: TEAM\n  const activeDownstream = isActiveDownstream(params);\n  if (activeDownstream) return { error: CANNOT_CHANGE_WINNING_SIDE };\n\n  if (matchUp.tieMatchUps?.length) {\n    for (const tieMatchUp of matchUp.tieMatchUps) {\n      const result = setMatchUpState({\n        matchUpId: tieMatchUp.matchUpId,\n        matchUpTieId: matchUpId,\n        winningSide: undefined,\n        removeScore: true,\n        tournamentRecord,\n        drawDefinition,\n        event,\n      });\n      if (result.error) return decorateResult({ result, stack });\n    }\n  }\n\n  const result = updateTieMatchUpScore({\n    event: params.event,\n    removeScore: true,\n    tournamentRecord,\n    drawDefinition,\n    matchUpsMap,\n    matchUpId,\n  });\n  if (result.error) return decorateResult({ result, stack });\n\n  if (params.tiebreakReset && !result.tieFormatRemoved) {\n    // check for scenarios where an added \"Tiebreaker\" collectionDefinition/matchUp has been added\n    const inheritedTieFormat = resolveTieFormat({\n      drawDefinition,\n      structure,\n      event,\n    })?.tieFormat;\n\n    if (matchUp.tieFormat && inheritedTieFormat) {\n      const {\n        matchUpCountDifference,\n        descendantDifferences,\n        ancestorDifferences,\n        valueDifference,\n      } = compareTieFormats({\n        descendant: matchUp.tieFormat,\n        ancestor: inheritedTieFormat,\n      });\n\n      if (\n        descendantDifferences.collectionIds.length === 1 &&\n        !ancestorDifferences.collectionIds.length &&\n        !ancestorDifferences.groupsCount &&\n        matchUpCountDifference === 1 &&\n        valueDifference === 1\n      ) {\n        const result = resetTieFormat({\n          tournamentRecord,\n          drawDefinition,\n          matchUpId,\n          event,\n        });\n        if (result.error) return result;\n      }\n    }\n  }\n\n  return { ...SUCCESS };\n}\n","import {\n  deleteMatchUpsNotice,\n  modifyDrawNotice,\n} from '../notifications/drawNotifications';\n\nimport { VOLUNTARY_CONSOLATION } from '../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_DRAW_DEFINITION,\n  STRUCTURE_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\nexport function resetVoluntaryConsolationStructure({\n  tournamentRecord,\n  drawDefinition,\n  resetEntries,\n  event,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const structure = drawDefinition.structures?.find(\n    (structure) => structure.stage === VOLUNTARY_CONSOLATION\n  );\n\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  const removedMatchUpIds =\n    structure.matchUps?.map(({ matchUpId }) => matchUpId) || [];\n\n  structure.positionAssignments = [];\n  structure.seedAssignments = [];\n  structure.matchUps = [];\n\n  deleteMatchUpsNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    action: 'resetVoluntaryConsolationStructure',\n    matchUpIds: removedMatchUpIds,\n    drawDefinition,\n  });\n\n  // TODO: add modifyPositionAssignmentsNotice, modifySeedAssignmentsNotice\n\n  if (resetEntries) {\n    drawDefinition.entries = drawDefinition.entries.filter(\n      (entry) => entry.entryStage !== VOLUNTARY_CONSOLATION\n    );\n  }\n\n  modifyDrawNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    eventId: event?.eventId,\n    drawDefinition,\n    structureIds: [structure.structureId],\n  });\n\n  return { ...SUCCESS };\n}\n","import { setDelegatedOutcome as setDelegated } from './matchUpGovernor/setDelegatedOutcome';\n\nexport function setDelegatedOutcome(params) {\n  return setDelegated(params);\n}\n","import { addExtension } from '../../extensions/addExtension';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\n\nimport { DELEGATED_OUTCOME } from '../../../constants/extensionConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n  MISSING_MATCHUP,\n  MISSING_VALUE,\n} from '../../../constants/errorConditionConstants';\n\nexport function setDelegatedOutcome({\n  drawDefinition,\n  matchUpId,\n  outcome,\n  matchUp,\n}) {\n  if (!matchUp && !drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!outcome) return { error: MISSING_VALUE, info: 'missing outcome' };\n  if (!matchUp && !matchUpId) return { error: MISSING_MATCHUP };\n\n  if (!matchUp) {\n    const result = findDrawMatchUp({\n      drawDefinition,\n      matchUpId,\n    });\n    if (result.error) return result;\n    matchUp = result.matchUp;\n  }\n\n  if (\n    typeof outcome !== 'object' ||\n    !outcome.score?.scoreStringSide1 ||\n    !outcome.score?.scoreStringSide2\n  ) {\n    return { error: INVALID_VALUES };\n  }\n\n  // TODO: check validity of outcome\n  const extension = {\n    name: DELEGATED_OUTCOME,\n    value: outcome,\n  };\n\n  return addExtension({ element: matchUp, extension });\n}\n","import { addDrawDefinitionExtension } from '../extensions/addRemoveExtensions';\nimport { getParticipantIds } from '../../global/functions/extractors';\nimport { intersection } from '../../utilities/arrays';\n\nimport { PARTICIPANT_REPRESENTATIVES } from '../../constants/extensionConstants';\nimport {\n  DRAW_DEFINITION_NOT_FOUND,\n  INVALID_VALUES,\n} from '../../constants/errorConditionConstants';\n\nexport function setDrawParticipantRepresentativeIds({\n  representativeParticipantIds,\n  drawDefinition,\n}) {\n  if (!drawDefinition) return { error: DRAW_DEFINITION_NOT_FOUND };\n  if (!Array.isArray(representativeParticipantIds))\n    return { error: INVALID_VALUES };\n\n  const enteredParticipantIds = getParticipantIds(\n    drawDefinition?.entries || []\n  );\n\n  // An empty array is valid; if ids provided...\n  // check that all representativeParticipantIds are enteredParticipantIds\n  if (\n    representativeParticipantIds.length &&\n    intersection(representativeParticipantIds, enteredParticipantIds).length <\n      representativeParticipantIds.length\n  ) {\n    return { error: INVALID_VALUES };\n  }\n\n  const extension = {\n    name: PARTICIPANT_REPRESENTATIVES,\n    value: representativeParticipantIds,\n  };\n\n  return addDrawDefinitionExtension({ drawDefinition, extension });\n}\n","import { setMatchUpMatchUpFormat } from './setMatchUpMatchUpFormat';\nimport { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { isValidMatchUpFormat } from '../../../validators/isValidMatchUpFormat';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { getMatchUpId } from '../../../global/functions/extractors';\nimport {\n  modifyDrawNotice,\n  modifyMatchUpNotice,\n} from '../../notifications/drawNotifications';\n\nimport { DOUBLES, SINGLES, TEAM } from '../../../constants/eventConstants';\nimport { TO_BE_PLAYED } from '../../../constants/matchUpStatusConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  INVALID_EVENT_TYPE,\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n  MISSING_MATCHUP_FORMAT,\n  MISSING_TOURNAMENT_RECORD,\n  NO_MODIFICATIONS_APPLIED,\n  UNRECOGNIZED_MATCHUP_FORMAT,\n} from '../../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\n// external use; set matchUpFormat for a events, draws, structures or matchUp\n\ntype SetMatchUpStatusArgs = {\n  tournamentRecord?: Tournament;\n  drawDefinition?: DrawDefinition;\n  scheduledDates?: string[];\n  stageSequences?: number[];\n  structureIds?: string[];\n  matchUpFormat: string;\n  structureId?: string;\n  eventIds?: string[];\n  eventType?: string;\n  matchUpId?: string;\n  drawIds?: string[];\n  stages?: string[];\n  eventId?: string;\n  drawId?: string;\n  force?: boolean;\n  event?: Event;\n};\n\nexport function setMatchUpFormat(params: SetMatchUpStatusArgs) {\n  const stack = 'setMatchUpFormat';\n\n  const {\n    tournamentRecord,\n    drawDefinition,\n    scheduledDates,\n    stageSequences,\n    matchUpFormat,\n    structureId,\n    eventType, // only SINGLES or DOUBLES\n    matchUpId,\n    eventId,\n    stages,\n    drawId,\n    event,\n    force, // strip matchUpFormat from scoped matchUps which have not been scored\n  } = params;\n\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!matchUpFormat) return { error: MISSING_MATCHUP_FORMAT };\n  if (matchUpFormat && !isValidMatchUpFormat({ matchUpFormat }))\n    return decorateResult({\n      result: { error: UNRECOGNIZED_MATCHUP_FORMAT, matchUpFormat },\n      stack,\n    });\n  if (scheduledDates && !Array.isArray(scheduledDates))\n    return decorateResult({\n      result: { error: INVALID_VALUES, scheduledDates },\n      stack,\n    });\n  if (eventType && ![SINGLES, DOUBLES].includes(eventType))\n    return decorateResult({ result: { error: INVALID_EVENT_TYPE }, stack });\n\n  let modificationsCount = 0;\n  const structureIds: string[] =\n    params.structureIds || (structureId && [structureId].filter(Boolean)) || [];\n  const eventIds =\n    params.eventIds || (eventId && [eventId].filter(Boolean)) || [];\n  const drawIds = params.drawIds || (drawId && [drawId].filter(Boolean)) || [];\n\n  if ((structureId || structureIds?.length) && !drawDefinition) {\n    return decorateResult({\n      result: { error: MISSING_DRAW_DEFINITION },\n      stack,\n    });\n  }\n\n  if (drawId && matchUpId && drawDefinition) {\n    const result = setMatchUpMatchUpFormat({\n      tournamentRecord,\n      drawDefinition,\n      matchUpFormat,\n      structureIds,\n      structureId,\n      matchUpId,\n    });\n    if (result.error) return result;\n    modificationsCount += 1;\n  }\n\n  const processStructures = (drawDefinition) => {\n    const modifiedStructureIds: string[] = [];\n\n    for (const structure of drawDefinition.structures || []) {\n      if (\n        (Array.isArray(stages) && !stages.includes(structure.stage)) ||\n        (Array.isArray(stageSequences) &&\n          !stageSequences.includes(structure.stageSequence)) ||\n        (structureIds?.length && !structureIds.includes(structure.structureId))\n      )\n        continue;\n\n      if (structureIds?.length && structure.matchUpFormat !== matchUpFormat) {\n        structure.matchUpFormat = matchUpFormat;\n        modifiedStructureIds.push(structure.structureId);\n        modificationsCount += 1;\n      }\n\n      const matchUps: HydratedMatchUp[] =\n        (force || scheduledDates) &&\n        getAllStructureMatchUps({\n          matchUpFilters: { matchUpStatuses: [TO_BE_PLAYED] },\n          structure,\n        }).matchUps;\n\n      const inContextMatchUps =\n        scheduledDates &&\n        getAllStructureMatchUps({\n          matchUpFilters: { matchUpStatuses: [TO_BE_PLAYED] },\n          contextFilters: { scheduledDates },\n          afterRecoveryTimes: false,\n          inContext: true,\n          structure,\n        }).matchUps;\n\n      if (matchUps?.length) {\n        const matchUpIdsToModify = inContextMatchUps\n          ? inContextMatchUps.map(getMatchUpId)\n          : matchUps.map(getMatchUpId);\n\n        for (const matchUp of matchUps) {\n          if (matchUpIdsToModify.includes(matchUp.matchUpId)) {\n            matchUp.matchUpFormat = scheduledDates?.length\n              ? matchUpFormat\n              : undefined; // force to inherit structure matchUpFormat\n\n            modifyMatchUpNotice({\n              tournamentId: tournamentRecord?.tournamentId,\n              eventId: event?.eventId,\n              context: stack,\n              drawDefinition,\n              matchUp,\n            });\n          }\n        }\n      }\n    }\n\n    if (\n      !modifiedStructureIds.length &&\n      drawDefinition.matchUpFormat !== matchUpFormat\n    ) {\n      drawDefinition.matchUpFormat = matchUpFormat;\n      modificationsCount += 1;\n    }\n\n    return modifiedStructureIds;\n  };\n\n  for (const event of tournamentRecord.events || []) {\n    if (\n      (eventIds?.length && !eventIds.includes(event.eventId)) ||\n      (eventType && eventType !== event.eventType) ||\n      eventType === TEAM\n    ) {\n      continue;\n    }\n\n    if (\n      Array.isArray(stageSequences) ||\n      Array.isArray(stages) ||\n      structureIds?.length ||\n      drawIds?.length\n    ) {\n      for (const drawDefinition of event.drawDefinitions || []) {\n        if (Array.isArray(drawIds) && !drawIds.includes(drawDefinition.drawId))\n          continue;\n        const modifiedStructureIds = processStructures(drawDefinition);\n        modifyDrawNotice({\n          structureIds: modifiedStructureIds,\n          drawDefinition,\n        });\n      }\n    } else if (event.matchUpFormat !== matchUpFormat) {\n      event.matchUpFormat = matchUpFormat;\n      modificationsCount += 1;\n    }\n  }\n\n  if (!modificationsCount)\n    return { ...SUCCESS, info: NO_MODIFICATIONS_APPLIED };\n\n  return { ...SUCCESS, modificationsCount };\n}\n","import { setOrderOfFinish as setOrder } from './matchUpGovernor/setOrderOfFinish';\n\nexport function setOrderOfFinish(params) {\n  return setOrder(params);\n}\n","import { getStructureMatchUps } from '../../../query/structure/getStructureMatchUps';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { getDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { getMatchUpId } from '../../../global/functions/extractors';\nimport { mustBeAnArray } from '../../../utilities/mustBeAnArray';\nimport { isConvertableInteger } from '../../../utilities/math';\nimport { uniqueValues } from '../../../utilities/arrays';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_MATCHUP_STATUS,\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n} from '../../../constants/errorConditionConstants';\nimport { DrawDefinition } from '../../../types/tournamentTypes';\n\n/**\n *\n * @param {object} drawDefinition - provided by drawEngine\n * @param {object[]} finishingOrder - [{ matchUpId, orderOfFinish }] where order of finish is whole number\n * @returns { success, error }\n */\n\ntype SetOrderOfFinishArgs = {\n  finishingOrder: { matchUpId: string; orderOfFinish: number }[];\n  drawDefinition: DrawDefinition;\n};\nexport function setOrderOfFinish({\n  drawDefinition,\n  finishingOrder,\n}: SetOrderOfFinishArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  const stack = 'setOrderOfFinish';\n\n  if (!Array.isArray(finishingOrder))\n    return decorateResult({\n      info: mustBeAnArray('finishingOrder'),\n      result: { error: INVALID_VALUES },\n      stack,\n    });\n\n  const { completedMatchUps, matchUpsMap } = getDrawMatchUps({\n    inContext: true,\n    drawDefinition,\n  });\n\n  const matchUpIds: string[] = completedMatchUps?.map(getMatchUpId) ?? [];\n  const targetMatchUpIds = finishingOrder.map(getMatchUpId);\n\n  const { matchUpTypes, roundNumbers, structureIds, matchUpTieIds } = (\n    completedMatchUps ?? []\n  )\n    .filter(({ matchUpId }) => targetMatchUpIds.includes(matchUpId))\n    .reduce(\n      (aggregator: any, matchUp) => {\n        const { matchUpTieId, matchUpType, roundNumber, structureId } = matchUp;\n        if (!aggregator.matchUpTypes.includes(matchUpType))\n          aggregator.matchUpTypes.push(matchUpType);\n        if (!aggregator.roundNumbers.includes(roundNumber))\n          aggregator.roundNumbers.push(roundNumber);\n        if (!aggregator.structureIds.includes(structureId))\n          aggregator.structureIds.push(structureId);\n        if (!aggregator.matchUpTieIds.includes(matchUpTieId))\n          aggregator.matchUpTieIds.push(matchUpTieId);\n        return aggregator;\n      },\n      {\n        matchUpTypes: [],\n        roundNumbers: [],\n        structureIds: [],\n        matchUpTieIds: [],\n      }\n    );\n\n  // targeted matchUps must all be of the same matchUpType and have the same roundNumber and structureId\n  if (\n    matchUpTypes.length > 1 ||\n    matchUpTieIds.length > 1 ||\n    roundNumbers.length > 1 ||\n    structureIds.length > 1\n  ) {\n    return decorateResult({\n      info: 'matchUpType, structureId and roundNumber must be equivalent',\n      result: { error: INVALID_VALUES },\n      stack,\n    });\n  }\n\n  // targetedMatchUps must all be in draws completedMatchUps and orderOfFinish values must be integers\n  let validMatchUpId, validOrderOfFinish;\n  const valuesMap = {};\n  const targetedMatchUpIds: string[] = [];\n  const orderOfFinishValues: number[] = [];\n  const validValues = finishingOrder.every(({ orderOfFinish, matchUpId }) => {\n    targetedMatchUpIds.push(matchUpId);\n    if (orderOfFinish) orderOfFinishValues.push(orderOfFinish);\n    valuesMap[matchUpId] = orderOfFinish;\n    validMatchUpId = matchUpIds.includes(matchUpId);\n    validOrderOfFinish =\n      orderOfFinish === undefined ||\n      (isConvertableInteger(orderOfFinish) && Math.floor(orderOfFinish) > 0);\n    return validMatchUpId && validOrderOfFinish;\n  });\n\n  if (!validValues) {\n    return decorateResult({\n      result: {\n        error: !validMatchUpId ? INVALID_MATCHUP_STATUS : INVALID_VALUES,\n      },\n      info:\n        (!validMatchUpId && 'matchUps must be completed') ||\n        (!validOrderOfFinish &&\n          'orderOfFinish must be integer > 0 or undefined') ||\n        undefined,\n      stack,\n    });\n  }\n\n  // get other matchUps in the same logical grouping\n  const otherCohortMatchUps = completedMatchUps?.filter(\n    (matchUp) =>\n      matchUp.structureId === structureIds[0] &&\n      matchUp.roundNumber === roundNumbers[0] &&\n      matchUp.matchUpType === matchUpTypes[0] &&\n      matchUp.matchUpTieId === matchUpTieIds[0] &&\n      !targetedMatchUpIds.includes(matchUp.matchUpId)\n  );\n\n  // throw an error if an existing matchUp has an invalid orderOfFinish value\n  for (const matchUp of otherCohortMatchUps ?? []) {\n    const { orderOfFinish } = matchUp || {};\n    if (orderOfFinish) {\n      if (!isConvertableInteger(orderOfFinish))\n        return decorateResult({\n          context: { orderOfFinish, matchUp },\n          result: { error: INVALID_VALUES },\n          stack,\n        });\n      orderOfFinishValues.push(orderOfFinish);\n    }\n  }\n\n  // order of finish values must be unique and no value greater than the number of values\n  if (\n    uniqueValues(orderOfFinishValues).length !== orderOfFinishValues.length ||\n    Math.max(...orderOfFinishValues) > orderOfFinishValues.length\n  ) {\n    return decorateResult({\n      info: 'Values not unique or greater than expected number of values',\n      result: { error: INVALID_VALUES },\n      stack,\n    });\n  }\n\n  if (structureIds.length) {\n    // get the matchUp objects to modify (not inContext)\n    const result = getStructureMatchUps({\n      matchUpFilters: { matchUpIds: targetMatchUpIds },\n      structureId: structureIds[0],\n      drawDefinition,\n      matchUpsMap,\n    });\n    if (result.error) return decorateResult({ result, stack });\n\n    // apply the new values to targeted matchUps\n    result.completedMatchUps?.forEach(\n      (matchUp) => (matchUp.orderOfFinish = valuesMap[matchUp.matchUpId])\n    );\n  }\n\n  return { ...SUCCESS };\n}\n","import { setPositionAssignments as drawEngineSetPositionAssignments } from './positionGovernor/setPositionAssignments';\n\nexport function setPositionAssignments(params) {\n  return drawEngineSetPositionAssignments(params);\n}\n","import { assignDrawPositionBye } from '../../matchUps/drawPositions/assignDrawPositionBye';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { assignDrawPosition } from '../../matchUps/drawPositions/positionAssignment';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { getMatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { intersection } from '../../../utilities/arrays';\nimport {\n  modifyDrawNotice,\n  modifyPositionAssignmentsNotice,\n} from '../../notifications/drawNotifications';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n  STRUCTURE_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\n\nexport function setPositionAssignments({\n  structurePositionAssignments,\n  provisionalPositioning,\n  tournamentRecord,\n  drawDefinition,\n  event,\n}) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!Array.isArray(structurePositionAssignments))\n    return { error: INVALID_VALUES };\n\n  const stack = 'setPositionAssignments';\n\n  for (const structureAssignments of structurePositionAssignments) {\n    const { structureId, positionAssignments } = structureAssignments;\n    if (!positionAssignments) continue;\n\n    const result = findStructure({ drawDefinition, structureId });\n    if (result.error) return result;\n    const structure = result.structure;\n\n    if (!structure) return { error: STRUCTURE_NOT_FOUND };\n    const structureDrawPositions = getPositionAssignments({\n      structure,\n    }).positionAssignments?.map(({ drawPosition }) => drawPosition);\n\n    const submittedDrawPositions = positionAssignments?.map(\n      ({ drawPosition }) => drawPosition\n    );\n\n    if (\n      intersection(structureDrawPositions, submittedDrawPositions).length !==\n      structureDrawPositions?.length\n    ) {\n      return decorateResult({\n        result: { error: INVALID_VALUES },\n        info: 'drawPositions do not match',\n        stack,\n      });\n    }\n\n    const matchUpsMap = getMatchUpsMap({ drawDefinition });\n    const { matchUps: inContextDrawMatchUps } = getAllDrawMatchUps({\n      inContext: true,\n      drawDefinition,\n      matchUpsMap,\n    });\n\n    for (const assignment of positionAssignments || []) {\n      const { drawPosition, participantId, bye, qualifier } = assignment;\n\n      if (bye) {\n        const result = assignDrawPositionBye({\n          tournamentRecord,\n          drawDefinition,\n          drawPosition,\n          matchUpsMap,\n          structureId,\n          structure,\n          event,\n        });\n        if (result?.error) return result;\n      } else if (qualifier) {\n        positionAssignments.forEach((assignment) => {\n          if (assignment.drawPosition === drawPosition) {\n            assignment.qualifier = true;\n            delete assignment.participantId;\n            delete assignment.bye;\n          }\n        });\n      } else if (participantId) {\n        const result = assignDrawPosition({\n          provisionalPositioning,\n          inContextDrawMatchUps,\n          tournamentRecord,\n          drawDefinition,\n          participantId,\n          drawPosition,\n          matchUpsMap,\n          structureId,\n          event,\n        });\n        if (result?.error) return result;\n      }\n    }\n    modifyPositionAssignmentsNotice({\n      tournamentId: tournamentRecord?.tournamentId,\n      drawDefinition,\n      structure,\n      event,\n    });\n  }\n\n  const structureIds = structurePositionAssignments.map(\n    ({ structureId }) => structureId\n  );\n  modifyDrawNotice({\n    tournamentId: tournamentRecord?.tournamentId,\n    eventId: event?.eventId,\n    drawDefinition,\n    structureIds,\n  });\n\n  return { ...SUCCESS };\n}\n","import { isConvertableInteger } from '../../../utilities/math';\nimport { numericSortValue } from '../../../utilities/arrays';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../../global/functions/decorateResult';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n} from '../../../constants/errorConditionConstants';\n\nexport function setStructureOrder({ drawDefinition, orderMap }): ResultType {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (\n    typeof orderMap !== 'object' ||\n    !Object.values(orderMap).every((val) => isConvertableInteger(val))\n  )\n    decorateResult({\n      result: { error: INVALID_VALUES },\n      context: { orderMap },\n    });\n\n  if (!drawDefinition.structures) drawDefinition.structures = [];\n  drawDefinition.structures.forEach((structure) => {\n    const structureOrder = orderMap[structure.structureId];\n    if (structureOrder) structure.structureOrder = structureOrder;\n  });\n\n  drawDefinition.structures.sort(\n    (a, b) =>\n      numericSortValue(a.structureOrder) - numericSortValue(b.structureOrder)\n  );\n\n  return { ...SUCCESS };\n}\n","import { updateAssignmentParticipantResults } from '../drawDefinitions/matchUpGovernor/updateAssignmentParticipantResults';\nimport { getAllStructureMatchUps } from '../../query/matchUps/getAllStructureMatchUps';\nimport { addExtension } from '../extensions/addExtension';\nimport { modifyDrawNotice } from '../notifications/drawNotifications';\nimport { findStructure } from '../../acquire/findStructure';\n\nimport { CONTAINER } from '../../constants/drawDefinitionConstants';\nimport { SUB_ORDER } from '../../constants/extensionConstants';\n\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { TEAM } from '../../constants/matchUpTypes';\nimport {\n  MISSING_DRAW_DEFINITION,\n  MISSING_DRAW_POSITION,\n  MISSING_STRUCTURE_ID,\n  STRUCTURE_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Structure,\n  Tournament,\n} from '../../types/tournamentTypes';\n\n/**\n *\n * Used to order ROUND_ROBIN participants when finishingPosition ties cannot be broken algorithmically.\n * Assigns a subOrder value to a participant within a structure by drawPosition.\n */\n\ntype SetSubOrderArgs = {\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  drawPosition: number;\n  structureId: string;\n  subOrder: number;\n  event?: Event;\n};\n\nexport function setSubOrder({\n  tournamentRecord,\n  drawDefinition,\n  drawPosition,\n  structureId,\n  subOrder,\n  event,\n}: SetSubOrderArgs): ResultType {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!structureId) return { error: MISSING_STRUCTURE_ID };\n  if (!drawPosition) return { error: MISSING_DRAW_POSITION };\n\n  const { structure } = findStructure({ drawDefinition, structureId });\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n  let targetStructure: Structure | undefined = structure;\n\n  if (structure.structures && structure.structureType === CONTAINER) {\n    targetStructure = structure.structures?.find(\n      (currentStructure) =>\n        currentStructure.positionAssignments?.find(\n          (assignment) => assignment.drawPosition === drawPosition\n        )\n    );\n  }\n\n  const positionAssignments = targetStructure?.positionAssignments;\n\n  const assignment = positionAssignments?.find(\n    (assignment) => assignment.drawPosition === drawPosition\n  );\n\n  const extension = {\n    name: SUB_ORDER,\n    value: subOrder,\n  };\n  assignment && addExtension({ element: assignment, extension });\n\n  const isDualMatchUp =\n    event?.eventType === TEAM ||\n    drawDefinition.matchUpType === TEAM ||\n    (event?.tieFormat ?? drawDefinition?.tieFormat ?? structure?.tieFormat);\n  const matchUpFilters = isDualMatchUp && { matchUpTypes: [TEAM] };\n  const { matchUps } = getAllStructureMatchUps({\n    structure: targetStructure,\n    afterRecoveryTimes: false,\n    inContext: true,\n    matchUpFilters,\n    event,\n  });\n  const matchUpFormat =\n    structure?.matchUpFormat ?? drawDefinition.matchUpFormat;\n\n  updateAssignmentParticipantResults({\n    positionAssignments,\n    tournamentRecord,\n    drawDefinition,\n    matchUpFormat,\n    matchUps,\n    event,\n  });\n\n  modifyDrawNotice({ drawDefinition, structureIds: [structureId] });\n\n  return { ...SUCCESS };\n}\n","import { substituteParticipant as participantSubstitution } from './positionGovernor/substituteParticipant';\n\nexport function substituteParticipant(params) {\n  return participantSubstitution(params);\n}\n","import { replaceTieMatchUpParticipantId } from '../../matchUps/lineUps/replaceTieMatchUpParticipant';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { getMatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { getParticipantId } from '../../../global/functions/extractors';\n\nimport {\n  INVALID_MATCHUP,\n  INVALID_PARTICIPANT_ID,\n  MATCHUP_NOT_FOUND,\n  MISSING_DRAW_DEFINITION,\n  MISSING_MATCHUP_ID,\n  MISSING_PARTICIPANT_ID,\n} from '../../../constants/errorConditionConstants';\nimport { HydratedSide } from '../../../types/hydrated';\n\nexport function substituteParticipant({\n  substituteParticipantId,\n  existingParticipantId,\n  tournamentRecord,\n  drawDefinition,\n  sideNumber,\n  matchUpId,\n  event,\n}) {\n  const stack = 'substituteParticipant';\n\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n  if (!existingParticipantId || !substituteParticipantId)\n    return decorateResult({ result: { error: MISSING_PARTICIPANT_ID }, stack });\n\n  const { matchUp } = findDrawMatchUp({\n    drawDefinition,\n    matchUpId,\n    event,\n  });\n\n  if (!matchUp) return { error: MATCHUP_NOT_FOUND };\n  if (!matchUp.collectionId)\n    return decorateResult({ result: { error: INVALID_MATCHUP }, stack });\n\n  const matchUpsMap = getMatchUpsMap({ drawDefinition });\n\n  const { matchUps: inContextDrawMatchUps } = getAllDrawMatchUps({\n    tournamentParticipants: tournamentRecord?.participants,\n    inContext: true,\n    drawDefinition,\n    matchUpsMap,\n  });\n\n  const inContextMatchUp = inContextDrawMatchUps?.find(\n    (drawMatchUp) => drawMatchUp.matchUpId === matchUpId\n  );\n\n  const inContextDualMatchUp = inContextDrawMatchUps?.find(\n    (drawMatchUp) => drawMatchUp.matchUpId === inContextMatchUp?.matchUpTieId\n  );\n\n  // ensure that existingParticipantId and substituteParticipantId are on the same team\n  const relevantSide = inContextDualMatchUp?.sides?.find((side: any) =>\n    side.participant.individualParticipants.some(\n      ({ participantId }) => participantId === existingParticipantId\n    )\n  ) as HydratedSide & { [key: string]: any };\n\n  if (!relevantSide || (sideNumber && relevantSide.sideNumber !== sideNumber))\n    return { error: INVALID_PARTICIPANT_ID };\n\n  // if no sideNumber is provided, segregate available by sideNumber and specify sideNumber\n  const availableParticipantIds =\n    relevantSide.participant?.individualParticipants\n      ?.map(getParticipantId)\n      .filter((participantId) => participantId !== existingParticipantId);\n\n  if (!availableParticipantIds?.includes(substituteParticipantId))\n    return decorateResult({ result: { error: INVALID_PARTICIPANT_ID }, stack });\n\n  return replaceTieMatchUpParticipantId({\n    newParticipantId: substituteParticipantId,\n    tieMatchUpId: matchUpId,\n    existingParticipantId,\n    substitution: true,\n    tournamentRecord,\n    drawDefinition,\n    event,\n  });\n}\n","import { swapDrawPositionAssignments as positionSwap } from '../matchUps/drawPositions/positionSwap';\n\n/**\n *\n * @param {string} drawId - id of drawDefinition within which structure is found\n * @param {string} structureId - id of structure of drawPosition\n * @param {number[]} drawPositions - drawPositions for which participants will be swapped\n *\n */\nexport function swapDrawPositionAssignments(params) {\n  return positionSwap(params);\n}\n","import { removeDrawPositionAssignment } from './removeDrawPositionAssignment';\n\nimport { WITHDRAWN } from '../../constants/entryStatusConstants';\n\n/*\n *\n * @param {string} drawId - id of drawDefinition within which structure is found\n * @param {string} structureId - id of structure of drawPosition\n * @param {number} drawPosition - number of drawPosition for which actions are to be returned\n * @param {boolean} replaceWithBye - boolean whether or not to replace with BYE\n * @param {boolean} destroyPair - if { participantType: PAIR } it is possible to destroy pair entry before modifying entryStatus\n *\n */\n\nexport function withdrawParticipantAtDrawPosition(params) {\n  Object.assign(params, { entryStatus: WITHDRAWN });\n  return removeDrawPositionAssignment(params);\n}\n","import { generateQualifyingLink } from '../links/generateQualifyingLink';\nimport { addExtension } from '../../../../mutate/extensions/addExtension';\nimport { coerceEven, isConvertableInteger } from '../../../../utilities/math';\nimport structureTemplate from '../../templates/structureTemplate';\nimport { generateRoundRobin } from './roundRobin/roundRobin';\nimport { treeMatchUps } from './eliminationTree';\nimport { constantToString } from '../../../../utilities/strings';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../../../global/functions/decorateResult';\n\nimport { MISSING_DRAW_SIZE } from '../../../../constants/errorConditionConstants';\nimport { DrawLink, Structure } from '../../../../types/tournamentTypes';\nimport { ROUND_TARGET } from '../../../../constants/extensionConstants';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport {\n  POSITION,\n  QUALIFYING,\n  ROUND_ROBIN,\n  WINNER,\n} from '../../../../constants/drawDefinitionConstants';\n\nexport function generateQualifyingStructures({\n  qualifyingProfiles,\n  appliedPolicies,\n  idPrefix,\n  isMock,\n  uuids,\n}): ResultType & {\n  qualifyingDrawPositionsCount?: number;\n  structures?: Structure[];\n  qualifiersCount?: number;\n  qualifyingDetails?: any;\n  links?: DrawLink[];\n  success?: boolean;\n} {\n  const stack = 'generateQualifyingSTructures';\n  const qualifyingDetails: any[] = [];\n  const structures: Structure[] = [];\n  const links: DrawLink[] = [];\n\n  const sequenceSort = (a, b) => a.stageSequence - b.stageSequence;\n  const roundTargetSort = (a, b) => a.roundTarget - b.roundTarget;\n\n  let qualifyingDrawPositionsCount = 0,\n    totalQualifiersCount = 0,\n    finishingPositions,\n    roundTarget: number = 1;\n\n  for (const roundTargetProfile of qualifyingProfiles.sort(roundTargetSort)) {\n    const structureProfiles = roundTargetProfile.structureProfiles || [];\n    roundTarget = roundTargetProfile.roundTarget || roundTarget;\n\n    let stageSequence = 1,\n      targetRoundQualifiersCount = 0,\n      finalQualifyingRoundNumber,\n      finalQualifyingStructureId,\n      linkType;\n\n    for (const structureProfile of (structureProfiles || []).sort(\n      sequenceSort\n    )) {\n      let drawSize = coerceEven(\n        structureProfile.drawSize || structureProfile.participantsCount\n      );\n      const {\n        qualifyingRoundNumber,\n        structureOptions,\n        matchUpFormat,\n        structureName,\n        structureId,\n        drawType,\n      } = structureProfile;\n      const matchUpType = structureProfile.matchUpType;\n\n      const qualifyingPositions =\n        structureProfile.qualifyingPositions ||\n        deriveQualifyingPositions({ drawSize, qualifyingRoundNumber });\n\n      let roundLimit, structure, matchUps;\n\n      if (!isConvertableInteger(drawSize)) {\n        return decorateResult({\n          result: { error: MISSING_DRAW_SIZE },\n          stack,\n        });\n      }\n      const roundTargetName =\n        qualifyingProfiles.length > 1 ? `${roundTarget}-` : '';\n      const stageSequenceName =\n        structureProfiles.length > 1 || roundTargetName ? stageSequence : '';\n\n      const qualifyingStructureName =\n        structureName ||\n        (roundTargetName || stageSequenceName\n          ? `${constantToString(\n              QUALIFYING\n            )} ${roundTargetName}${stageSequenceName}`\n          : constantToString(QUALIFYING));\n\n      if (drawType === ROUND_ROBIN) {\n        const { structures, groupCount, maxRoundNumber /*, groupSize*/ } =\n          generateRoundRobin({\n            structureName:\n              structureProfile.structureName || qualifyingStructureName,\n            structureId: structureId || uuids?.pop(),\n            // qualifyingPositions,\n            stage: QUALIFYING,\n            structureOptions,\n            appliedPolicies,\n            stageSequence,\n            matchUpType,\n            roundTarget,\n            drawSize,\n            idPrefix,\n            isMock,\n            uuids,\n          });\n        targetRoundQualifiersCount = groupCount;\n        roundLimit = maxRoundNumber;\n        structure = structures[0];\n        finishingPositions = [1];\n      } else {\n        ({ drawSize, matchUps, roundLimit } = treeMatchUps({\n          qualifyingRoundNumber,\n          qualifyingPositions,\n          matchUpType,\n          drawSize,\n          idPrefix,\n          isMock,\n          uuids,\n        }));\n\n        structure = structureTemplate({\n          structureName:\n            structureProfile.structureName || qualifyingStructureName,\n          structureId: structureId || uuids?.pop(),\n          qualifyingRoundNumber: roundLimit,\n          stage: QUALIFYING,\n          matchUpFormat,\n          stageSequence,\n          matchUpType,\n          roundLimit, // redundant\n          matchUps,\n        });\n\n        if (roundTarget) {\n          addExtension({\n            extension: { name: ROUND_TARGET, value: roundTarget },\n            element: structure,\n          });\n        }\n\n        // always set to the final round of the last generated qualifying structure\n        targetRoundQualifiersCount =\n          matchUps?.filter((matchUp) => matchUp.roundNumber === roundLimit)\n            ?.length || 0;\n      }\n\n      if (stageSequence > 1) {\n        const { link } = generateQualifyingLink({\n          sourceStructureId: finalQualifyingStructureId,\n          sourceRoundNumber: finalQualifyingRoundNumber,\n          targetStructureId: structure.structureId,\n          finishingPositions: linkType === POSITION ? [1] : undefined,\n          linkType,\n        });\n        links.push(link);\n        // if more than one qualifying stageSequence, remove last stageSequence qualifier positions from count\n        qualifyingDrawPositionsCount +=\n          (drawSize || 0) - targetRoundQualifiersCount;\n      } else {\n        qualifyingDrawPositionsCount += drawSize || 0;\n      }\n\n      // IMPORTANT: order of operations is important here!!\n      linkType = drawType === ROUND_ROBIN ? POSITION : WINNER;\n\n      // always set to the final round of the last generated qualifying structure\n      finalQualifyingStructureId = structure.structureId;\n      finalQualifyingRoundNumber = roundLimit;\n\n      structures.push(structure);\n      stageSequence += 1;\n    }\n\n    totalQualifiersCount += targetRoundQualifiersCount;\n    qualifyingDetails.push({\n      qualifiersCount: targetRoundQualifiersCount,\n      finalQualifyingRoundNumber,\n      finalQualifyingStructureId,\n      finishingPositions,\n      roundTarget,\n      linkType,\n    });\n\n    roundTarget += 1;\n  }\n\n  return {\n    qualifiersCount: totalQualifiersCount,\n    qualifyingDrawPositionsCount,\n    qualifyingDetails,\n    structures,\n    ...SUCCESS,\n    links,\n  };\n}\n\nfunction deriveQualifyingPositions({ drawSize, qualifyingRoundNumber }) {\n  let qualifyingPositions = drawSize;\n  let divisionsCount = 0;\n\n  while (divisionsCount < qualifyingRoundNumber) {\n    qualifyingPositions = Math.floor(qualifyingPositions / 2);\n    divisionsCount += 1;\n  }\n  return qualifyingPositions;\n}\n","import { POLICY_TYPE_DRAWS } from '../../../constants/policyConstants';\nimport { PolicyDefinitions } from '../../../types/factoryTypes';\n\ntype getDrawTypeCoercionArgs = {\n  policyDefinitions?: PolicyDefinitions;\n  appliedPolicies?: PolicyDefinitions;\n  drawType?: string;\n};\nexport function getDrawTypeCoercion({\n  policyDefinitions,\n  appliedPolicies,\n  drawType,\n}: getDrawTypeCoercionArgs) {\n  const policyDefined =\n    policyDefinitions?.[POLICY_TYPE_DRAWS]?.drawTypeCoercion;\n  const policyApplied = appliedPolicies?.[POLICY_TYPE_DRAWS]?.drawTypeCoercion;\n\n  return (\n    (typeof policyDefined === 'boolean' ? policyDefined : undefined) ??\n    (drawType && policyDefined?.[drawType]) ??\n    (typeof policyApplied === 'boolean' ? policyApplied : undefined) ??\n    (drawType && policyApplied?.[drawType]) ??\n    true\n  );\n}\n","import { doubleEliminationLinks } from '../links/doubleEliminationLinks';\nimport { constantToString } from '../../../../utilities/strings';\nimport { structureTemplate } from '../../templates/structureTemplate';\nimport { feedInMatchUps } from '../feedInMatchUps';\nimport { treeMatchUps } from './eliminationTree';\n\nimport { Structure } from '../../../../types/tournamentTypes';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport {\n  MAIN,\n  BACKDRAW,\n  DECIDER,\n  CONSOLATION,\n  PLAY_OFF,\n} from '../../../../constants/drawDefinitionConstants';\n\nexport function generateDoubleElimination({\n  structureName,\n  matchUpType,\n  idPrefix,\n  drawSize,\n  isMock,\n  uuids,\n}) {\n  const structures: Structure[] = [];\n\n  // feedIn MAIN structure needs 1st round feed and final round feed\n  const { matchUps } = feedInMatchUps({\n    linkFedFinishingRoundNumbers: [1],\n    drawSize: drawSize + 1,\n    matchUpType,\n    idPrefix,\n    isMock,\n  });\n  const mainStructure = structureTemplate({\n    structureName: structureName || constantToString(MAIN),\n    structureId: uuids?.pop(),\n    stageSequence: 1,\n    stage: MAIN,\n    matchUpType,\n    matchUps,\n  });\n\n  structures.push(mainStructure);\n\n  const consolationDrawPositions = drawSize / 2;\n\n  const { matchUps: consolationMatchUps } = feedInMatchUps({\n    finishingPositionOffset: consolationDrawPositions,\n    idPrefix: idPrefix && `${idPrefix}-c`,\n    drawSize: drawSize - 1,\n    isConsolation: true,\n    matchUpType,\n    isMock,\n    uuids,\n  });\n\n  const consolationStructure = structureTemplate({\n    structureName: constantToString(BACKDRAW),\n    matchUps: consolationMatchUps,\n    structureId: uuids?.pop(),\n    stage: CONSOLATION,\n    stageSequence: 2,\n    matchUpType,\n  });\n\n  structures.push(consolationStructure);\n\n  const { matchUps: deciderMatchUps } = treeMatchUps({\n    idPrefix: idPrefix && `${idPrefix}-p1t2`,\n    drawSize: 2,\n    matchUpType,\n    isMock,\n  });\n  const deciderStructure = structureTemplate({\n    structureName: constantToString(DECIDER),\n    matchUps: deciderMatchUps,\n    structureId: uuids?.pop(),\n    stageSequence: 3,\n    stage: PLAY_OFF,\n    matchUpType,\n  });\n\n  structures.push(deciderStructure);\n\n  const links = doubleEliminationLinks({\n    mainStructure,\n    consolationStructure,\n    deciderStructure,\n  });\n\n  return {\n    structures,\n    links: links,\n    ...SUCCESS,\n  };\n}\n","import {\n  BOTTOM_UP,\n  TOP_DOWN,\n  LOSER,\n  WINNER,\n} from '../../../../constants/drawDefinitionConstants';\n\nexport function doubleEliminationLinks({\n  mainStructure,\n  consolationStructure,\n  deciderStructure,\n}) {\n  const consolationMatchUps = consolationStructure.matchUps;\n\n  // roundsFed are those rounds which are generated with drawPositions (not undefined or undefined)\n  const roundsFed = consolationMatchUps.reduce((rf, matchUp) => {\n    const drawPositions = (matchUp.drawPositions || []).filter(Boolean);\n    return drawPositions.length && !rf.includes(matchUp.roundNumber)\n      ? rf.concat(matchUp.roundNumber)\n      : rf;\n  }, []);\n\n  const mainFinalRound = mainStructure.matchUps.reduce(\n    (finalRound, matchUp) => {\n      return !finalRound || matchUp.roundNumber > finalRound\n        ? matchUp.roundNumber\n        : finalRound;\n    },\n    undefined\n  );\n\n  const consolationFinalRound = consolationStructure.matchUps.reduce(\n    (finalRound, matchUp) => {\n      return !finalRound || matchUp.roundNumber > finalRound\n        ? matchUp.roundNumber\n        : finalRound;\n    },\n    undefined\n  );\n\n  /*\n  const initialRounds = [1, 2].map((roundNumber) => {\n    const feedProfile = roundNumber % 2 ? TOP_DOWN : BOTTOM_UP;\n    return {\n      linkType: LOSER,\n      source: {\n        roundNumber,\n        structureId: mainStructure.structureId,\n      },\n      target: {\n        feedProfile,\n        roundNumber: 1,\n        positionInterleave: { offset: roundNumber - 1, interleave: 1 },\n        structureId: consolationStructure.structureId,\n      },\n    };\n  });\n  */\n\n  const fedRounds = roundsFed.map((roundNumber, i) => {\n    const roundsFedIndex = roundsFed.indexOf(roundNumber);\n    const feedProfile = roundsFedIndex % 2 ? TOP_DOWN : BOTTOM_UP;\n    const sourceRoundNumber = 1 + i;\n\n    return {\n      linkType: LOSER,\n      source: {\n        roundNumber: sourceRoundNumber,\n        structureId: mainStructure.structureId,\n      },\n      target: {\n        feedProfile,\n        roundNumber,\n        structureId: consolationStructure.structureId,\n      },\n    };\n  });\n\n  const finalistsLink = {\n    linkType: WINNER,\n    source: {\n      roundNumber: consolationFinalRound,\n      structureId: consolationStructure.structureId,\n    },\n    target: {\n      feedProfile: TOP_DOWN,\n      roundNumber: mainFinalRound,\n      structureId: mainStructure.structureId,\n    },\n  };\n\n  const deciderLinks = [\n    {\n      linkType: WINNER,\n      source: {\n        roundNumber: mainFinalRound,\n        structureId: mainStructure.structureId,\n      },\n      target: {\n        feedProfile: TOP_DOWN,\n        roundNumber: 1,\n        structureId: deciderStructure.structureId,\n      },\n    },\n    {\n      linkType: LOSER,\n      source: {\n        roundNumber: mainFinalRound,\n        structureId: mainStructure.structureId,\n      },\n      target: {\n        feedProfile: TOP_DOWN,\n        roundNumber: 1,\n        structureId: deciderStructure.structureId,\n      },\n    },\n  ];\n\n  // return [...initialRounds, ...fedRounds, finalistsLink, ...deciderLinks];\n  return [...fedRounds, finalistsLink, ...deciderLinks];\n}\n","import { isConvertableInteger, isPowerOf2 } from '../../../../utilities/math';\nimport { generateRange } from '../../../../utilities/arrays';\nimport { ensureInt } from '../../../../utilities/ensureInt';\nimport { addFinishingRounds } from '../addFinishingRounds';\nimport { generateMatchUpId } from '../generateMatchUpId';\nimport { treeMatchUps } from './eliminationTree';\nimport { buildRound } from '../buildRound';\n\nexport function luckyDraw(params) {\n  const {\n    qualifyingRoundNumber, // round at which participants qualify\n    finishingPositionOffset,\n    qualifyingPositions, // number of positions which qualify\n    matchUpType,\n    idPrefix,\n    drawSize,\n    isMock,\n    uuids,\n  } = params;\n\n  if (!isConvertableInteger(drawSize) || drawSize < 2) {\n    return { matchUps: [], roundsCount: 0 };\n  }\n\n  if (isPowerOf2(drawSize)) return treeMatchUps(params);\n\n  const roundProfiles = luckyRoundProfiles(drawSize);\n\n  const firstRound = roundProfiles.shift();\n  const nodes = generateRange(1, (firstRound?.participantsCount || 0) + 1).map(\n    (drawPosition) => ({\n      drawPosition,\n    })\n  );\n\n  let matchUps: any[] = [];\n  let roundNumber = 1;\n\n  ({ matchUps } = buildRound({\n    roundNumber,\n    matchUpType,\n    idPrefix,\n    matchUps,\n    isMock,\n    nodes,\n    uuids,\n  }));\n  roundNumber++;\n\n  let roundLimit = params.roundLimit || qualifyingRoundNumber;\n\n  for (const roundProfile of roundProfiles) {\n    const roundMatchUpsCount = roundProfile.participantsCount / 2;\n    const roundPositionRange = generateRange(1, roundMatchUpsCount + 1);\n\n    if (qualifyingPositions && roundMatchUpsCount === qualifyingPositions) {\n      roundLimit = roundNumber - 1;\n    }\n\n    const roundMatchUps = roundPositionRange.map((roundPosition) => {\n      const matchUpId = generateMatchUpId({\n        roundPosition: roundPosition,\n        roundNumber,\n        idPrefix,\n        uuids,\n      });\n\n      return {\n        roundPosition,\n        roundNumber,\n        matchUpId,\n      };\n    });\n\n    matchUps.push(...roundMatchUps);\n    roundNumber++;\n  }\n\n  const roundsCount = roundNumber - 1; // because roundNumber was incremented at the end of the while loop\n\n  matchUps = addFinishingRounds({\n    finishingPositionOffset,\n    lucky: true,\n    roundsCount,\n    roundLimit,\n    matchUps,\n  });\n\n  if (roundLimit) {\n    matchUps = matchUps.filter((matchUp) => matchUp.roundNumber <= roundLimit);\n  }\n\n  return { matchUps, roundsCount, roundLimit };\n}\n\nfunction luckyRoundProfiles(drawSize) {\n  const intDrawSize = ensureInt(drawSize);\n  let participantsCount = intDrawSize % 2 ? intDrawSize + 1 : intDrawSize;\n  const preFeedRound = !!(Math.ceil(participantsCount / 2) % 2);\n  const rounds: any[] = [{ participantsCount, preFeedRound }];\n  while (participantsCount > 2) {\n    const nextRound = Math.ceil(participantsCount / 2);\n    const nextIsFinal = nextRound === 1;\n    const feedRound = !!(!nextIsFinal && nextRound % 2);\n    participantsCount = !nextIsFinal && feedRound ? nextRound + 1 : nextRound;\n    const preFeedRound = !!(\n      participantsCount !== 2 && Math.ceil(participantsCount / 2) % 2\n    );\n    rounds.push({ participantsCount, preFeedRound, feedRound });\n  }\n  return rounds;\n}\n","import { generateRoundRobinWithPlayOff } from './drawTypes/roundRobin/generateRoundRobinWithPlayoff';\nimport { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { firstRoundLoserConsolation } from './drawTypes/firstRoundLoserConsolation';\nimport { generateDoubleElimination } from './drawTypes/doubleEliminattion';\nimport { generateCurtisConsolation } from './drawTypes/curtisConsolation';\nimport { generatePlayoffStructures } from './drawTypes/playoffStructures';\nimport { generateRoundRobin } from './drawTypes/roundRobin/roundRobin';\nimport structureTemplate from '../templates/structureTemplate';\nimport { constantToString } from '../../../utilities/strings';\nimport { feedInChampionship } from './drawTypes/feedInChamp';\nimport { treeMatchUps } from './drawTypes/eliminationTree';\nimport { feedInMatchUps } from './feedInMatchUps';\nimport { luckyDraw } from './drawTypes/luckyDraw';\n\nimport { POLICY_TYPE_FEED_IN } from '../../../constants/policyConstants';\nimport { ErrorType } from '../../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\n// prettier-ignore\nimport {\n  MAIN, FICQF, FICSF, MFIC, AD_HOC, CURTIS, FICR16, COMPASS,\n  PLAY_OFF, OLYMPIC, FEED_IN, ROUND_ROBIN,\n  COMPASS_ATTRIBUTES, OLYMPIC_ATTRIBUTES,\n  SINGLE_ELIMINATION, DOUBLE_ELIMINATION,\n  FIRST_MATCH_LOSER_CONSOLATION,\n  FIRST_ROUND_LOSER_CONSOLATION,\n  ROUND_ROBIN_WITH_PLAYOFF,\n  FEED_IN_CHAMPIONSHIP,\n  WIN_RATIO,\n  LUCKY_DRAW,\n} from '../../../constants/drawDefinitionConstants';\n\nexport function getGenerators(params): { generators?: any; error?: ErrorType } {\n  const { playoffAttributes, stageSequence = 1, stage = MAIN, matchUpType, drawSize, uuids } = params;\n\n  const getPrefixedStructureId = () => {\n    if (!params.isMock && !params.idPrefix) return undefined;\n    const drawId = params.drawDefinition.drawId;\n    return `${drawId}-s-0`;\n  };\n  const structureId = params.structureId || getPrefixedStructureId() || uuids?.pop();\n\n  const { appliedPolicies } = getAppliedPolicies(params);\n  const feedPolicy = params.policyDefinitions?.[POLICY_TYPE_FEED_IN] || appliedPolicies?.[POLICY_TYPE_FEED_IN];\n\n  // disable feeding from MAIN final unless policy specifies\n  params.skipRounds = params.skipRounds || (drawSize <= 4 && (feedPolicy?.feedMainFinal ? 0 : 1)) || 0;\n\n  const structureName = params.structureName ?? playoffAttributes?.['0']?.name ?? constantToString(MAIN);\n\n  const singleElimination = () => {\n    const { matchUps } = treeMatchUps(params);\n    const structure = structureTemplate({\n      stageSequence,\n      structureName,\n      matchUpType,\n      structureId,\n      matchUps,\n      stage,\n    });\n\n    return { structures: [structure], links: [], ...SUCCESS };\n  };\n\n  const generators = {\n    [AD_HOC]: () => {\n      const structure = structureTemplate({\n        finishingPosition: WIN_RATIO,\n        stageSequence,\n        structureName,\n        matchUps: [],\n        matchUpType,\n        structureId,\n        stage,\n      });\n\n      return { structures: [structure], links: [], ...SUCCESS };\n    },\n    [LUCKY_DRAW]: () => {\n      const { matchUps } = luckyDraw(params);\n      const structure = structureTemplate({\n        stageSequence,\n        structureName,\n        matchUpType,\n        structureId,\n        matchUps,\n        stage,\n      });\n\n      return { structures: [structure], links: [], ...SUCCESS };\n    },\n    [SINGLE_ELIMINATION]: () => singleElimination(),\n    [DOUBLE_ELIMINATION]: () => generateDoubleElimination(params),\n    [COMPASS]: () =>\n      generatePlayoffStructures({\n        ...params,\n        roundOffsetLimit: 3,\n        playoffAttributes: playoffAttributes ?? COMPASS_ATTRIBUTES,\n      }),\n    [OLYMPIC]: () =>\n      generatePlayoffStructures({\n        ...params,\n        roundOffsetLimit: 2,\n        playoffAttributes: playoffAttributes ?? OLYMPIC_ATTRIBUTES,\n      }),\n    [PLAY_OFF]: () => {\n      return generatePlayoffStructures(params);\n    },\n\n    [FEED_IN]: () => {\n      const { matchUps } = feedInMatchUps({ drawSize, uuids, matchUpType });\n\n      const structure = structureTemplate({\n        stageSequence,\n        structureName,\n        matchUpType,\n        structureId,\n        stage: MAIN,\n        matchUps,\n      });\n\n      return { structures: [structure], links: [], ...SUCCESS };\n    },\n    [FIRST_ROUND_LOSER_CONSOLATION]: () => firstRoundLoserConsolation(params),\n    [FIRST_MATCH_LOSER_CONSOLATION]: () => feedInChampionship({ ...params, feedRounds: 1, fmlc: true }),\n    [MFIC]: () => feedInChampionship({ ...params, feedRounds: 1 }),\n    [FICSF]: () => feedInChampionship({ ...params, feedsFromFinal: 1 }),\n    [FICQF]: () => feedInChampionship({ ...params, feedsFromFinal: 2 }),\n    [FICR16]: () => feedInChampionship({ ...params, feedsFromFinal: 3 }),\n    [FEED_IN_CHAMPIONSHIP]: () => feedInChampionship(params),\n    [CURTIS]: () => generateCurtisConsolation(params),\n    [ROUND_ROBIN]: () => generateRoundRobin(params),\n    [ROUND_ROBIN_WITH_PLAYOFF]: () => generateRoundRobinWithPlayOff(params),\n  };\n\n  return { generators };\n}\n","// first iteration only links to a single playoff structure\n// future iteration should allow structureOptions to specify\n// groups of finishing drawPositions which playoff\n\nimport { processPlayoffGroups } from '../processPlayoffGroups';\nimport { constantToString } from '../../../../../utilities/strings';\nimport { generateRoundRobin } from './roundRobin';\n\nimport { INVALID_CONFIGURATION } from '../../../../../constants/errorConditionConstants';\nimport {\n  MAIN,\n  PLAY_OFF,\n} from '../../../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../../../constants/resultConstants';\n\nexport function generateRoundRobinWithPlayOff(params) {\n  const { drawDefinition, structureOptions, requireSequential } = params;\n\n  const mainDrawProperties = {\n    structureName: constantToString(MAIN),\n    ...params,\n    stage: MAIN,\n  }; // default structureName\n  const { structures, groupCount, groupSize } =\n    generateRoundRobin(mainDrawProperties);\n\n  if (groupCount < 1) {\n    return { error: INVALID_CONFIGURATION };\n  }\n\n  // define a default playoff group if none specified\n  const playoffGroups = structureOptions?.playoffGroups || [\n    { finishingPositions: [1], structureName: constantToString(PLAY_OFF) },\n  ];\n  const [mainStructure] = structures;\n\n  const { structures: playoffStructures, links } = processPlayoffGroups({\n    sourceStructureId: mainStructure.structureId,\n    requireSequential,\n    drawDefinition,\n    playoffGroups,\n    groupCount,\n    groupSize,\n    ...params,\n  });\n\n  if (playoffStructures) structures.push(...playoffStructures);\n\n  return {\n    ...SUCCESS,\n    structures,\n    links,\n  };\n}\n","import { generateQualifyingStructures } from './drawTypes/generateQualifyingStructures';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { structureSort } from '../../../functions/sorters/structureSort';\nimport { generateQualifyingLink } from './links/generateQualifyingLink';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { getDrawTypeCoercion } from './getDrawTypeCoercion';\nimport { ensureInt } from '../../../utilities/ensureInt';\nimport { isPowerOf2 } from '../../../utilities/math';\nimport { getGenerators } from './getGenerators';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { SINGLES } from '../../../constants/matchUpTypes';\nimport {\n  EXISTING_STAGE,\n  INVALID_DRAW_SIZE,\n  UNRECOGNIZED_DRAW_TYPE,\n} from '../../../constants/errorConditionConstants';\nimport {\n  MAIN,\n  AD_HOC,\n  FEED_IN,\n  ROUND_ROBIN,\n  SINGLE_ELIMINATION,\n  ROUND_ROBIN_WITH_PLAYOFF,\n  MULTI_STRUCTURE_DRAWS,\n  LUCKY_DRAW,\n  QUALIFYING,\n  WINNER,\n  POSITION,\n} from '../../../constants/drawDefinitionConstants';\nimport {\n  DrawDefinition,\n  Structure,\n  TieFormat,\n} from '../../../types/tournamentTypes';\nimport {\n  PlayoffAttributes,\n  PolicyDefinitions,\n} from '../../../types/factoryTypes';\n\ntype GenerateDrawStructuresAndLinksArgs = {\n  playoffAttributes?: PlayoffAttributes;\n  appliedPolicies?: PolicyDefinitions;\n  enforceMinimumDrawSize?: boolean;\n  drawDefinition: DrawDefinition;\n  overwriteExisting?: boolean;\n  drawTypeCoercion?: boolean;\n  staggeredEntry?: boolean;\n  qualifyingProfiles?: any;\n  structureName?: string;\n  tieFormat?: TieFormat;\n  matchUpType?: string;\n  drawType?: string;\n  drawSize?: number;\n  idPrefix?: string;\n  isMock?: boolean;\n  uuids?: string[];\n};\nexport function generateDrawStructuresAndLinks(\n  params: GenerateDrawStructuresAndLinksArgs\n) {\n  const {\n    enforceMinimumDrawSize = true,\n    overwriteExisting,\n    appliedPolicies,\n    staggeredEntry, // optional - specifies main structure FEED_IN for drawTypes CURTIS_CONSOLATION, FEED_IN_CHAMPIONSHIPS, FMLC\n    drawDefinition,\n    tieFormat,\n    drawSize,\n    isMock,\n    uuids,\n  } = params || {};\n\n  const drawTypeCoercion =\n    params.drawTypeCoercion ??\n    getDrawTypeCoercion({ appliedPolicies, drawType: params.drawType });\n\n  const stack = 'generateDrawStructuresAndLinks';\n  let drawType =\n    (drawTypeCoercion && params.drawSize === 2 && SINGLE_ELIMINATION) ||\n    params.drawType ||\n    SINGLE_ELIMINATION;\n\n  const structures: Structure[] = [],\n    links: any[] = [];\n\n  const matchUpType = params?.matchUpType ?? SINGLES;\n\n  const existingQualifyingStructures = drawDefinition?.structures?.filter(\n    ({ stage }) => stage === QUALIFYING\n  );\n  if (existingQualifyingStructures) {\n    structures.push(...existingQualifyingStructures);\n  }\n  const existingQualifyingStructureIds = existingQualifyingStructures?.map(\n    ({ structureId }) => structureId\n  );\n  const existingMainStructure = drawDefinition?.structures?.find(\n    ({ stage, stageSequence }) => stage === MAIN && stageSequence === 1\n  );\n  const existingQualifyingLinks = drawDefinition?.links?.filter(\n    (link) =>\n      link.target.structureId === existingMainStructure?.structureId &&\n      existingQualifyingStructureIds?.includes(link.source.structureId)\n  );\n  const getQualifiersCount = (link, structure) => {\n    if (link.linkType === POSITION && structure?.structures) {\n      const finishingPositions = link.source.finishingPositions || [];\n      return structure.structures.length * finishingPositions.length;\n    } else if (link.linkType === WINNER && structure?.matchUps?.length) {\n      const qualifyingRoundNumber = link.source.roundNumber;\n      const matchUps = structure.matchUps.filter(\n        ({ roundNumber }) => roundNumber === qualifyingRoundNumber\n      );\n      return matchUps.length;\n    }\n  };\n\n  const existingQualifyingDrawPositionsCount = existingQualifyingStructures\n    ?.map((structure) => {\n      const relevantLink = existingQualifyingLinks?.find(\n        (link) => link.target.structureId === structure.structureId\n      );\n      const drawPositionsCount =\n        getPositionAssignments({ structure })?.positionAssignments?.length ?? 0;\n      if (!relevantLink) return drawPositionsCount;\n\n      const sourceStructureId = relevantLink?.source.structureId;\n      const sourceStructure = drawDefinition.structures?.find(\n        (structure) => structure.structureId === sourceStructureId\n      );\n      const sourceQualifiersCount =\n        getQualifiersCount(relevantLink, sourceStructure) || 0;\n      return drawPositionsCount - sourceQualifiersCount;\n    })\n    .filter(Boolean)\n    .reduce((a, b) => a + b, 0);\n  const existingQualifiersCount = existingQualifyingLinks\n    ?.map((link) => {\n      const qualifyingStructureId = link.source.structureId;\n      const structure = existingQualifyingStructures?.find(\n        (structure) => structure.structureId === qualifyingStructureId\n      );\n      return getQualifiersCount(link, structure);\n    })\n    .filter(Boolean)\n    .reduce((a, b) => a + b, 0);\n  const mainStructureIsPlaceholder = !!(\n    existingMainStructure && !existingMainStructure?.matchUps?.length\n  );\n\n  if (existingQualifyingStructures?.length && !mainStructureIsPlaceholder) {\n    return { error: EXISTING_STAGE };\n  }\n\n  const qualifyingProfiles =\n    !existingQualifyingStructures?.length && params.qualifyingProfiles;\n\n  // first generate any qualifying structures and links\n  const qualifyingResult =\n    qualifyingProfiles?.length &&\n    generateQualifyingStructures({\n      idPrefix: params.idPrefix,\n      qualifyingProfiles,\n      appliedPolicies,\n      isMock,\n      uuids,\n    });\n\n  if (qualifyingResult?.error) {\n    return qualifyingResult;\n  }\n\n  const { qualifyingDrawPositionsCount, qualifyingDetails, qualifiersCount } =\n    qualifyingResult || {\n      qualifyingDrawPositionsCount: existingQualifyingDrawPositionsCount,\n      qualifiersCount: existingQualifiersCount,\n    };\n\n  if (qualifyingDrawPositionsCount) {\n    if (qualifyingResult?.structures) {\n      structures.push(...qualifyingResult.structures);\n    }\n    if (qualifyingResult?.links) {\n      links.push(...qualifyingResult.links);\n    }\n  }\n\n  Object.assign(\n    params,\n    definedAttributes({ drawSize, matchUpType, tieFormat })\n  );\n\n  // check that drawSize is a valid value\n  const invalidDrawSize =\n    drawType !== AD_HOC &&\n    (!drawSize ||\n      isNaN(drawSize) ||\n      drawSize < 2 ||\n      (!staggeredEntry &&\n        ![FEED_IN, LUCKY_DRAW].includes(drawType) &&\n        (([ROUND_ROBIN_WITH_PLAYOFF, ROUND_ROBIN].includes(drawType) &&\n          drawSize < 3) ||\n          (![ROUND_ROBIN, ROUND_ROBIN_WITH_PLAYOFF].includes(drawType) &&\n            !isPowerOf2(drawSize)))));\n\n  if (invalidDrawSize && !qualifyingDrawPositionsCount) {\n    return decorateResult({\n      context: { drawSize, invalidDrawSize },\n      result: { error: INVALID_DRAW_SIZE },\n      stack,\n    });\n  }\n\n  const multiStructure = MULTI_STRUCTURE_DRAWS.includes(drawType);\n  if (drawSize && ensureInt(drawSize) < 4 && multiStructure) {\n    if (drawTypeCoercion) {\n      drawType = SINGLE_ELIMINATION;\n    } else if (enforceMinimumDrawSize) {\n      return decorateResult({\n        context: {\n          enforceMinimumDrawSize,\n          invalidDrawSize,\n          drawSize,\n          drawType,\n        },\n        result: { error: INVALID_DRAW_SIZE },\n        stack,\n      });\n    }\n  }\n\n  const { generators, error } = getGenerators(params);\n  if (error) {\n    return { error };\n  }\n\n  const generator = generators[drawType];\n  if (!generator) return { error: UNRECOGNIZED_DRAW_TYPE };\n\n  const generatorResult = generator?.();\n  if (generatorResult.error) return generatorResult;\n\n  const { structures: generatedStructures, links: generatedLinks } =\n    generatorResult;\n\n  if (generatedStructures?.length) {\n    const generatedMainStructure = generatedStructures.find(\n      ({ stage, stageSequence }) => stage === MAIN && stageSequence === 1\n    );\n\n    if (existingMainStructure && generatedMainStructure) {\n      if (mainStructureIsPlaceholder) {\n        const generatedMainStructureId = generatedMainStructure.structureId;\n        generatedMainStructure.structureId = existingMainStructure.structureId;\n        if (generatedLinks?.length) {\n          for (const link of generatedLinks) {\n            if (link.source.structureId === generatedMainStructureId) {\n              link.source.structureId = existingMainStructure.structureId;\n            }\n            if (link.target.structureId === generatedMainStructureId) {\n              link.target.structureId = existingMainStructure.structureId;\n            }\n          }\n        }\n      } else if (!overwriteExisting) {\n        return { error: EXISTING_STAGE };\n      }\n    }\n\n    structures.push(...generatedStructures);\n  }\n  structures.sort(structureSort);\n\n  if (generatedLinks?.length) {\n    links.push(...generatedLinks);\n  }\n\n  const mainStructure = generatorResult.structures.find(\n    ({ stage, stageSequence }) => stage === MAIN && stageSequence === 1\n  );\n\n  for (const qualifyingDetail of qualifyingDetails || []) {\n    const {\n      finalQualifyingRoundNumber: qualifyingRoundNumber,\n      finalQualifyingStructureId: qualifyingStructureId,\n      roundTarget: targetEntryRound,\n      finishingPositions,\n      linkType,\n    } = qualifyingDetail;\n\n    const link =\n      mainStructure &&\n      generateQualifyingLink({\n        targetStructureId: mainStructure.structureId,\n        sourceStructureId: qualifyingStructureId,\n        sourceRoundNumber: qualifyingRoundNumber,\n        finishingPositions,\n        targetEntryRound,\n        linkType,\n      })?.link;\n    if (link?.error) return link;\n\n    if (link) {\n      links.push(link);\n    }\n  }\n\n  if (existingQualifyingLinks) links.push(...existingQualifyingLinks);\n\n  return {\n    ...SUCCESS,\n    qualifyingResult: {\n      qualifyingDrawPositionsCount,\n      qualifiersCount,\n    },\n    structures,\n    links,\n  };\n}\n","import { getStageDrawPositionsCount } from '../../../query/drawDefinition/getStageDrawPositions';\nimport { resolveTieFormat } from '../../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { copyTieFormat } from '../../../query/hierarchical/tieFormats/copyTieFormat';\nimport { ResultType, decorateResult } from '../../../global/functions/decorateResult';\nimport { addGoesTo } from '../../../mutate/drawDefinitions/matchUpGovernor/addGoesTo';\nimport { MatchUpsMap, getMatchUpsMap } from '../../../query/matchUps/getMatchUpsMap';\nimport { generateDrawStructuresAndLinks } from './generateDrawStructuresAndLinks';\nimport { modifyDrawNotice } from '../../../mutate/notifications/drawNotifications';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { validateTieFormat } from '../../../validators/validateTieFormat';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { getMatchUpId } from '../../../global/functions/extractors';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { generateTieMatchUps } from './tieMatchUps';\nimport {\n  setStageDrawSize,\n  setStageQualifiersCount,\n} from '../../../mutate/drawDefinitions/entryGovernor/stageEntryCounts';\n\nimport { MISSING_DRAW_DEFINITION } from '../../../constants/errorConditionConstants';\nimport { MAIN, QUALIFYING } from '../../../constants/drawDefinitionConstants';\nimport { PolicyDefinitions } from '../../../types/factoryTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport { SINGLES } from '../../../constants/matchUpTypes';\nimport {\n  DrawDefinition,\n  DrawLink,\n  Event,\n  MatchUp,\n  Structure,\n  TieFormat,\n  Tournament,\n  EventTypeUnion,\n} from '../../../types/tournamentTypes';\n\ntype GenerateDrawTypeAndModify = {\n  policyDefinitions?: PolicyDefinitions;\n  appliedPolicies?: PolicyDefinitions;\n  finishingPositionLimit?: number;\n  tournamentRecord?: Tournament;\n  matchUpType?: EventTypeUnion;\n  drawDefinition: DrawDefinition;\n  drawTypeCoercion?: boolean;\n  modifyOriginal?: boolean;\n  qualifiersCount?: number;\n  stageSequence?: number;\n  matchUpFormat?: string;\n  structureOptions?: any;\n  tieFormat?: TieFormat;\n  drawType?: string;\n  drawSize?: number;\n  feedPolicy?: any;\n  isMock?: boolean;\n  event?: Event;\n};\n\nexport function generateDrawTypeAndModifyDrawDefinition(params: GenerateDrawTypeAndModify): ResultType & {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  drawDefinition?: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  structures?: Structure[];\n  matchUps?: MatchUp[];\n  links?: DrawLink[];\n  success?: boolean;\n} {\n  const { modifyOriginal = true, stageSequence = 1, isMock } = params || {};\n\n  const stack = 'generateDrawTypeAndModifyDrawDefinition';\n\n  if (!params.drawDefinition)\n    return decorateResult({\n      result: { error: MISSING_DRAW_DEFINITION },\n      stack,\n    });\n\n  const drawDefinition = modifyOriginal ? params.drawDefinition : makeDeepCopy(params.drawDefinition, false, true);\n\n  let { tieFormat, matchUpType } = params;\n  if (tieFormat) {\n    const result = validateTieFormat({ tieFormat });\n    if (result.error) return result;\n  }\n\n  tieFormat = copyTieFormat(tieFormat ?? resolveTieFormat({ drawDefinition })?.tieFormat);\n  matchUpType = matchUpType ?? (drawDefinition.matchUpType || SINGLES);\n  params.tieFormat = tieFormat;\n  params.matchUpType = matchUpType;\n\n  const mainStageDrawPositionsCount = getStageDrawPositionsCount({\n    drawDefinition,\n    stage: MAIN,\n  });\n  params.drawSize = params.drawSize ?? mainStageDrawPositionsCount;\n\n  if (!mainStageDrawPositionsCount && params.drawSize) {\n    setStageDrawSize({\n      drawSize: params.drawSize,\n      drawDefinition,\n      stageSequence,\n      stage: MAIN,\n    });\n  }\n\n  const existingMatchUpIds = getMatchUpsMap({\n    drawDefinition,\n  }).drawMatchUps.map(getMatchUpId);\n\n  const result = generateDrawStructuresAndLinks(params);\n  if (result.error) {\n    return decorateResult({ result, stack });\n  }\n\n  const { structures, links, qualifyingResult } = result;\n  drawDefinition.structures = structures;\n  drawDefinition.links = links;\n\n  const qualifiersCount = Math.max(params.qualifiersCount ?? 0, qualifyingResult?.qualifiersCount || 0);\n\n  if (qualifyingResult?.qualifyingDrawPositionsCount) {\n    const qualifyingStageDrawPositionsCount = getStageDrawPositionsCount({\n      stage: QUALIFYING,\n      drawDefinition,\n    });\n\n    if (!qualifyingStageDrawPositionsCount) {\n      const result = setStageDrawSize({\n        drawSize: qualifyingResult.qualifyingDrawPositionsCount,\n        stage: QUALIFYING,\n        drawDefinition,\n      });\n      if (result.error) return result;\n    }\n  }\n\n  if (qualifiersCount) {\n    const result = setStageQualifiersCount({\n      qualifiersCount,\n      drawDefinition,\n      stage: MAIN,\n    });\n    if (result.error) return result;\n  }\n\n  const drawSize = params.drawSize ?? mainStageDrawPositionsCount;\n\n  Object.assign(params, definedAttributes({ drawSize, matchUpType, tieFormat }));\n\n  const { matchUps, matchUpsMap } = getAllDrawMatchUps({ drawDefinition });\n\n  if (tieFormat) {\n    // if there were exiting matchUps, exclude them from this step\n    matchUps?.forEach((matchUp) => {\n      if (!existingMatchUpIds.includes(matchUp.matchUpId)) {\n        const { tieMatchUps } = generateTieMatchUps({\n          tieFormat,\n          matchUp,\n          isMock,\n        });\n        Object.assign(matchUp, { tieMatchUps, matchUpType });\n      }\n    });\n  }\n\n  const { inContextDrawMatchUps } = addGoesTo({ drawDefinition, matchUpsMap });\n\n  modifyDrawNotice({\n    tournamentId: params.tournamentRecord?.tournamentId,\n    drawDefinition,\n  });\n\n  return {\n    inContextDrawMatchUps,\n    drawDefinition,\n    matchUpsMap,\n    ...SUCCESS,\n    structures,\n    matchUps,\n    links,\n  };\n}\n","import { getAppliedPolicies } from '../extensions/getAppliedPolicies';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\nimport {\n  POLICY_TYPE_SCORING,\n  POLICY_TYPE_DRAWS,\n} from '../../constants/policyConstants';\n\nexport function getAllowedMatchUpFormats({\n  tournamentRecord,\n  categoryName,\n  categoryType,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  const { appliedPolicies } = getAppliedPolicies({ tournamentRecord });\n  const scoringPolicy = appliedPolicies?.[POLICY_TYPE_SCORING];\n  const matchUpFormats = scoringPolicy?.matchUpFormats || [];\n  return matchUpFormats.filter(\n    ({ categoryNames, categoryTypes }) =>\n      (!categoryName && !categoryTypes) ||\n      (categoryName && categoryNames?.includes(categoryName)) ||\n      (categoryType && categoryTypes?.includes(categoryType))\n  );\n}\n\nexport function getAllowedDrawTypes({\n  tournamentRecord,\n  categoryName,\n  categoryType,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  const { appliedPolicies } = getAppliedPolicies({ tournamentRecord });\n  const drawTypesPolicy = appliedPolicies?.[POLICY_TYPE_DRAWS];\n  const drawTypes = drawTypesPolicy?.allowedDrawTypes || [];\n  return drawTypes.filter(\n    ({ categoryNames, categoryTypes }) =>\n      (!categoryName && !categoryTypes) ||\n      (categoryName && categoryNames?.includes(categoryName)) ||\n      (categoryType && categoryTypes?.includes(categoryType))\n  );\n}\n","import { getParticipants } from '../query/participants/getParticipants';\nimport { isUngrouped } from '../query/entries/isUngrouped';\nimport { unique } from '../utilities/arrays';\n\nimport POLICY_MATCHUP_ACTIONS_DEFAULT from '../fixtures/policies/POLICY_MATCHUP_ACTIONS_DEFAULT';\nimport { POLICY_TYPE_MATCHUP_ACTIONS } from '../constants/policyConstants';\nimport { INDIVIDUAL, PAIR, TEAM } from '../constants/participantConstants';\nimport { ParticipantMap, PolicyDefinitions } from '../types/factoryTypes';\nimport { ANY, FEMALE, MALE, MIXED } from '../constants/genderConstants';\nimport { DOUBLES_EVENT, TEAM_EVENT } from '../constants/eventConstants';\nimport { WITHDRAWN } from '../constants/entryStatusConstants';\nimport { SUCCESS } from '../constants/resultConstants';\nimport {\n  INVALID_ENTRIES,\n  INVALID_VALUES,\n  MISSING_EVENT,\n  MISSING_PARTICIPANTS,\n} from '../constants/errorConditionConstants';\nimport {\n  Entry,\n  Event,\n  Participant,\n  Tournament,\n} from '../types/tournamentTypes';\n\ntype CheckValidEntriesArgs = {\n  policyDefinitions?: PolicyDefinitions;\n  appliedPolicies?: PolicyDefinitions;\n  participantMap?: ParticipantMap;\n  tournamentRecord?: Tournament;\n  participants?: Participant[];\n  consideredEntries?: Entry[];\n  enforceGender?: boolean;\n  event: Event;\n};\nexport function checkValidEntries({\n  consideredEntries,\n  policyDefinitions,\n  tournamentRecord,\n  appliedPolicies,\n  participantMap,\n  enforceGender,\n  participants,\n  event,\n}: CheckValidEntriesArgs) {\n  if ((!participants || !participantMap) && tournamentRecord) {\n    ({ participants, participantMap } = getParticipants({\n      tournamentRecord,\n    }));\n  }\n\n  if (!participants) return { error: MISSING_PARTICIPANTS };\n  if (!Array.isArray(participants)) return { error: INVALID_VALUES };\n  if (!event) return { error: MISSING_EVENT };\n\n  const matchUpActionsPolicy =\n    policyDefinitions?.[POLICY_TYPE_MATCHUP_ACTIONS] ??\n    appliedPolicies?.[POLICY_TYPE_MATCHUP_ACTIONS] ??\n    POLICY_MATCHUP_ACTIONS_DEFAULT[POLICY_TYPE_MATCHUP_ACTIONS];\n\n  const genderEnforced =\n    (enforceGender ?? matchUpActionsPolicy?.participants?.enforceGender) !==\n    false;\n\n  const { eventType, gender: eventGender } = event;\n  const isDoubles = eventType === DOUBLES_EVENT;\n  const participantType =\n    (eventType === TEAM_EVENT && TEAM) || (isDoubles && PAIR) || INDIVIDUAL;\n\n  const entryStatusMap = Object.assign(\n    {},\n    ...(consideredEntries ?? event.entries ?? []).map((entry) => ({\n      [entry.participantId]: entry.entryStatus,\n    }))\n  );\n\n  const enteredParticipantIds = Object.keys(entryStatusMap);\n  const enteredParticipants = participants.filter((participant) =>\n    enteredParticipantIds.includes(participant.participantId)\n  );\n\n  const invalidEntries = enteredParticipants.filter((participant) => {\n    const entryStatus = entryStatusMap[participant.participantId];\n    const ungroupedParticipant =\n      eventType &&\n      [DOUBLES_EVENT, TEAM_EVENT].includes(eventType) &&\n      participant.participantType === INDIVIDUAL &&\n      (isUngrouped(entryStatus) || entryStatus === WITHDRAWN);\n    const mismatch =\n      participant.participantType !== participantType && !ungroupedParticipant;\n\n    const pairGender =\n      !mismatch &&\n      isDoubles &&\n      unique(\n        participant?.individualParticipantIds\n          ?.map((id) => participantMap?.[id]?.participant?.person?.sex)\n          .filter(Boolean) ?? []\n      );\n    const validPairGender =\n      !eventGender ||\n      !pairGender?.length ||\n      ANY === eventGender ||\n      ([MALE, FEMALE].includes(eventGender) && pairGender[0] === eventGender) ||\n      (MIXED === eventGender &&\n        ((pairGender.length == 1 &&\n          participant.individualParticipantIds?.length === 1) ||\n          pairGender.length === 2));\n\n    const personGender = participant?.person?.sex as unknown;\n    const validPersonGender =\n      !participant?.person ||\n      !eventGender ||\n      [ANY, MIXED].includes(eventGender) ||\n      ([MALE, FEMALE].includes(eventGender) && personGender === eventGender);\n\n    const validGender =\n      !genderEnforced || (validPairGender && validPersonGender);\n\n    return mismatch || !validGender;\n  });\n\n  if (invalidEntries.length) {\n    const invalidParticipantIds = invalidEntries.map(\n      (participant) => participant.participantId\n    );\n    return { error: INVALID_ENTRIES, invalidParticipantIds };\n  }\n\n  return { ...SUCCESS, valid: true };\n}\n","export const definitionTemplate = () => ({\n  matchUpType: undefined,\n  drawName: undefined,\n  drawId: undefined,\n  structures: [],\n  entries: [],\n  links: [],\n});\n\nexport const keyValidation = ['drawId', 'structures'];\n\nexport default definitionTemplate;\n","import { initializeStructureSeedAssignments } from '../../../mutate/drawDefinitions/positionGovernor/initializeSeedAssignments';\nimport { automatedPositioning } from '../../../mutate/drawDefinitions/automatedPositioning';\nimport { assignSeed } from '../../../mutate/drawDefinitions/entryGovernor/seedAssignment';\nimport { getValidSeedBlocks } from '../../../query/drawDefinition/seedGetter';\nimport { getScaledEntries } from '../../../query/event/getScaledEntries';\nimport { getParticipantId } from '../../../global/functions/extractors';\nimport { getDrawStructures } from '../../../acquire/findStructure';\nimport { findExtension } from '../../../acquire/findExtension';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../../global/functions/decorateResult';\n\nimport { STRUCTURE_NOT_FOUND } from '../../../constants/errorConditionConstants';\nimport { Entry, PositionAssignment } from '../../../types/tournamentTypes';\nimport { DIRECT_ENTRY_STATUSES } from '../../../constants/entryStatusConstants';\nimport { AD_HOC, QUALIFYING } from '../../../constants/drawDefinitionConstants';\nimport { RANKING, SEEDING } from '../../../constants/scaleConstants';\nimport { ROUND_TARGET } from '../../../constants/extensionConstants';\n\nexport function prepareStage(params): ResultType & {\n  positionAssignments?: PositionAssignment[];\n  positioningReport?: any;\n  stageEntries?: Entry[];\n  structureId?: string;\n  seedsCount?: number;\n  conflicts?: any[];\n} {\n  const stack = 'prepareStage';\n\n  let { seedsCount } = params;\n  const preparedStructureIds: string[] = params.preparedStructureIds || [];\n  const {\n    provisionalPositioning,\n    inContextDrawMatchUps,\n    tournamentRecord,\n    appliedPolicies,\n    qualifyingOnly,\n    drawDefinition,\n    seedingProfile,\n    matchUpsMap,\n    automated,\n    placeByes,\n    drawType,\n    drawSize,\n    entries,\n    event,\n\n    enforcePolicyLimits = true,\n    seedAssignmentProfile, // mainly used by mocksEngine for scenario testing\n    seedByRanking = true,\n    seededParticipants,\n    assignSeedsCount, // used for testing bye placement next to seeds\n    seedingScaleName,\n\n    stageSequence = 1,\n    roundTarget,\n    stage,\n  } = params;\n  const eventType = event?.eventType;\n  const stageEntries = entries.filter((entry) => {\n    const entryRoundTarget = findExtension({\n      name: ROUND_TARGET,\n      element: entry,\n    })?.extension?.value;\n\n    return (\n      (!entry.entryStage || entry.entryStage === stage) &&\n      (!stageSequence ||\n        !entry.entryStageSequence ||\n        entry.entryStageSequence === stageSequence) &&\n      (!roundTarget || !entryRoundTarget || entryRoundTarget === roundTarget) &&\n      DIRECT_ENTRY_STATUSES.includes(entry.entryStatus)\n    );\n  });\n\n  if (seededParticipants) seedsCount = seededParticipants.length;\n  if (seedsCount > drawSize) seedsCount = drawSize;\n  if (seedsCount > stageEntries.length) seedsCount = stageEntries.length;\n\n  const { structures } = getDrawStructures({\n    drawDefinition,\n    stageSequence,\n    roundTarget,\n    stage,\n  });\n  const multipleStructures = (structures?.length || 0) > 1;\n\n  const structure = structures?.find(\n    ({ structureId }) => !preparedStructureIds.includes(structureId)\n  );\n  if (!structure)\n    return decorateResult({ result: { error: STRUCTURE_NOT_FOUND }, stack });\n  const structureId = structure?.structureId;\n\n  const seedBlockInfo = structure\n    ? getValidSeedBlocks({\n        provisionalPositioning,\n        appliedPolicies,\n        drawDefinition,\n        seedingProfile,\n        structure,\n      })\n    : undefined;\n\n  const { seedLimit } = initializeStructureSeedAssignments({\n    participantsCount: stageEntries.length,\n    enforcePolicyLimits,\n    appliedPolicies,\n    drawDefinition,\n    seedingProfile,\n    structureId,\n    seedsCount,\n  });\n\n  if (seedLimit && seedLimit < seedsCount) seedsCount = seedLimit;\n\n  const enteredParticipantIds = entries.map(getParticipantId);\n\n  if (seededParticipants) {\n    seededParticipants\n      .filter(({ participantId }) =>\n        enteredParticipantIds.includes(participantId)\n      )\n      .filter(\n        (seededParticipant) =>\n          !seededParticipant.seedNumber ||\n          seededParticipant.seedNumber <= seededParticipants.length\n      )\n      .sort((a, b) => {\n        if (a.seedNumber < b.seedNumber) return -1;\n        if (a.seedNumber < b.seedNumber) return 1;\n        return 0;\n      })\n      .forEach((seededParticipant) => {\n        const { participantId, seedNumber, seedValue } = seededParticipant;\n        assignSeed({\n          provisionalPositioning,\n          tournamentRecord,\n          drawDefinition,\n          seedingProfile,\n          participantId,\n          seedBlockInfo,\n          structureId,\n          seedNumber,\n          seedValue,\n          event,\n        });\n      });\n  } else if (event || seedingScaleName) {\n    // if no seededParticipants have been defined, seed by seeding scale or ranking scale, if present\n\n    const { categoryName, ageCategoryCode } = event?.category || {};\n\n    const seedingScaleAttributes = {\n      scaleType: SEEDING,\n      scaleName:\n        seedingScaleName || categoryName || ageCategoryCode || event.eventId,\n      eventType,\n    };\n\n    let { scaledEntries } = getScaledEntries({\n      scaleAttributes: seedingScaleAttributes,\n      tournamentRecord,\n      stageSequence,\n      entries,\n      stage,\n    });\n\n    if (!scaledEntries?.length && seedByRanking) {\n      const rankingScaleAttributes = {\n        scaleName: categoryName || ageCategoryCode,\n        scaleType: RANKING,\n        eventType,\n      };\n\n      ({ scaledEntries } = getScaledEntries({\n        scaleAttributes: rankingScaleAttributes,\n        tournamentRecord,\n        stageSequence,\n        entries,\n        stage,\n      }));\n    }\n\n    const scaledEntriesCount = scaledEntries?.length ?? 0;\n    if (scaledEntriesCount < seedsCount) seedsCount = scaledEntriesCount;\n\n    scaledEntries\n      ?.filter(({ participantId }) =>\n        enteredParticipantIds.includes(participantId)\n      )\n      .slice(0, assignSeedsCount || seedsCount)\n      .forEach((scaledEntry, index) => {\n        const seedNumber = index + 1;\n        const { participantId, scaleValue } = scaledEntry;\n        const seedValue =\n          seedAssignmentProfile?.[seedNumber] || scaleValue || seedNumber;\n        assignSeed({\n          provisionalPositioning,\n          tournamentRecord,\n          drawDefinition,\n          seedingProfile,\n          participantId,\n          structureId,\n          seedNumber,\n          seedValue,\n          event,\n        });\n      });\n  }\n\n  let conflicts: any[] = [];\n  let positionAssignments;\n  let positioningReport;\n\n  if (\n    automated !== false &&\n    drawType !== AD_HOC &&\n    !(qualifyingOnly && stage !== QUALIFYING)\n  ) {\n    const seedsOnly = typeof automated === 'object' && automated.seedsOnly;\n    // if { seedsOnly: true } then only seeds and an Byes releated to seeded positions are placed\n    const result = automatedPositioning({\n      inContextDrawMatchUps,\n      multipleStructures,\n      tournamentRecord,\n      appliedPolicies,\n      drawDefinition,\n      seedingProfile,\n      structureId,\n      matchUpsMap,\n      placeByes,\n      seedLimit,\n      seedsOnly,\n      drawSize,\n      drawType,\n      event,\n    });\n    if (result.conflicts) conflicts = result?.conflicts;\n    positionAssignments = result?.positionAssignments;\n    positioningReport = result?.positioningReport;\n\n    if (result.error) {\n      return decorateResult({ result, stack });\n    }\n  }\n\n  return {\n    positionAssignments,\n    positioningReport,\n    stageEntries,\n    structureId,\n    seedsCount,\n    conflicts,\n  };\n}\n","import { structureAssignedDrawPositions } from '../../../query/drawDefinition/positionsGetter';\nimport { getSeedsCount } from '../../../query/drawDefinition/getSeedsCount';\nimport { modifyDrawNotice } from '../../notifications/drawNotifications';\nimport { isConvertableInteger } from '../../../utilities/math';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { generateRange } from '../../../utilities/arrays';\nimport { getSeedGroups } from './getSeedBlocks';\n\nimport { PolicyDefinitions, SeedingProfile } from '../../../types/factoryTypes';\nimport { POLICY_TYPE_SEEDING } from '../../../constants/policyConstants';\nimport { DrawDefinition } from '../../../types/tournamentTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  ErrorType,\n  SEEDSCOUNT_GREATER_THAN_DRAW_SIZE,\n  STRUCTURE_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\n\ntype InitializeStructureSeedAssignmentsArgs = {\n  appliedPolicies?: PolicyDefinitions;\n  requireParticipantCount?: boolean;\n  enforcePolicyLimits?: boolean;\n  drawSizeProgression?: boolean;\n  seedingProfile?: SeedingProfile;\n  drawDefinition: DrawDefinition;\n  participantsCount?: number; // TODO: migrate to participantsCount\n  participantCount?: number; // TODO: migrate to participantsCount\n  structureId: string;\n  seedsCount: number;\n};\nexport function initializeStructureSeedAssignments({\n  requireParticipantCount = true,\n  enforcePolicyLimits = true,\n  drawSizeProgression,\n  participantsCount,\n  participantCount,\n  appliedPolicies,\n  drawDefinition,\n  seedingProfile,\n  structureId,\n  seedsCount,\n}: InitializeStructureSeedAssignmentsArgs): {\n  seedLimit?: number;\n  success?: boolean;\n  error?: ErrorType;\n} {\n  participantsCount = participantsCount ?? participantCount;\n  const result = findStructure({ drawDefinition, structureId });\n  if (result.error) return result;\n  const structure = result.structure;\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  const { positionAssignments } = structureAssignedDrawPositions({ structure });\n  const drawSize = positionAssignments?.length || 0;\n\n  if (seedsCount > drawSize)\n    return { error: SEEDSCOUNT_GREATER_THAN_DRAW_SIZE };\n\n  const roundRobinGroupsCount = structure.structures?.length;\n  const groupSeedingThreshold =\n    isConvertableInteger(seedingProfile?.groupSeedingThreshold) &&\n    seedingProfile?.groupSeedingThreshold;\n\n  const seedGroups = getSeedGroups({\n    roundRobinGroupsCount,\n    drawSize,\n  })?.seedGroups;\n\n  const { seedsCount: maxSeedsCount } = getSeedsCount({\n    policyDefinitions: appliedPolicies,\n    requireParticipantCount,\n    drawSizeProgression,\n    participantsCount,\n    drawSize,\n  });\n\n  if (\n    maxSeedsCount &&\n    appliedPolicies?.[POLICY_TYPE_SEEDING] &&\n    seedsCount > maxSeedsCount &&\n    enforcePolicyLimits\n  ) {\n    seedsCount = maxSeedsCount;\n  }\n\n  structure.seedLimit = seedsCount;\n  structure.seedAssignments = generateRange(1, seedsCount + 1).map(\n    (seedNumber) => {\n      const seedGroup = seedGroups?.find((seedGroup) =>\n        seedGroup.includes(seedNumber)\n      );\n      const groupSeedValue = seedGroup && Math.min(...seedGroup);\n      const seedValue =\n        groupSeedingThreshold && seedNumber >= groupSeedingThreshold\n          ? groupSeedValue\n          : seedNumber;\n\n      return {\n        participantId: undefined,\n        seedNumber,\n        seedValue,\n      };\n    }\n  );\n\n  modifyDrawNotice({ drawDefinition, structureIds: [structureId] });\n\n  return { ...SUCCESS, seedLimit: seedsCount };\n}\n","import { POLICY_TYPE_SEEDING } from '../../constants/policyConstants';\nimport {\n  ROUND_ROBIN,\n  ROUND_ROBIN_WITH_PLAYOFF,\n  SEPARATE,\n  WATERFALL,\n} from '../../constants/drawDefinitionConstants';\n\nexport const POLICY_SEEDING_DEFAULT = {\n  [POLICY_TYPE_SEEDING]: {\n    validSeedPositions: { ignore: true },\n    duplicateSeedNumbers: true,\n    drawSizeProgression: true,\n    seedingProfile: {\n      drawTypes: {\n        [ROUND_ROBIN_WITH_PLAYOFF]: { positioning: WATERFALL },\n        [ROUND_ROBIN]: { positioning: WATERFALL },\n      },\n      positioning: SEPARATE,\n    },\n    policyName: 'USTA SEEDING',\n\n    seedsCountThresholds: [\n      { drawSize: 4, minimumParticipantCount: 3, seedsCount: 2 },\n      { drawSize: 16, minimumParticipantCount: 12, seedsCount: 4 },\n      { drawSize: 32, minimumParticipantCount: 24, seedsCount: 8 },\n      { drawSize: 64, minimumParticipantCount: 48, seedsCount: 16 },\n      { drawSize: 128, minimumParticipantCount: 96, seedsCount: 32 },\n      { drawSize: 256, minimumParticipantCount: 192, seedsCount: 64 },\n    ],\n  },\n};\n\nexport default POLICY_SEEDING_DEFAULT;\n","import { addVoluntaryConsolationStructure } from '../../../mutate/drawDefinitions/addVoluntaryConsolationStructure';\nimport { setMatchUpMatchUpFormat } from '../../../mutate/matchUps/matchUpFormat/setMatchUpMatchUpFormat';\nimport { generateDrawTypeAndModifyDrawDefinition } from './generateDrawTypeAndModifyDrawDefinition';\nimport { addDrawEntry } from '../../../mutate/drawDefinitions/entryGovernor/addDrawEntries';\nimport { generateQualifyingStructures } from './drawTypes/generateQualifyingStructures';\nimport { attachPolicies } from '../../../mutate/extensions/policies/attachPolicies';\nimport { getQualifiersCount } from '../../../query/drawDefinition/getQualifiersCount';\nimport { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { addAdHocMatchUps } from '../../../mutate/structures/addAdHocMatchUps';\nimport { getAllowedDrawTypes } from '../../../query/tournaments/allowedTypes';\nimport { getParticipants } from '../../../query/participants/getParticipants';\nimport { isConvertableInteger, nextPowerOf2 } from '../../../utilities/math';\nimport { validateTieFormat } from '../../../validators/validateTieFormat';\nimport { checkTieFormat } from '../../../mutate/tieFormat/checkTieFormat';\nimport { checkValidEntries } from '../../../validators/checkValidEntries';\nimport { generateQualifyingLink } from './links/generateQualifyingLink';\nimport { tieFormatDefaults } from '../templates/tieFormatDefaults';\nimport { DrawMaticArgs, drawMatic } from './drawMatic/drawMatic';\nimport { mustBeAnArray } from '../../../utilities/mustBeAnArray';\nimport { generateAdHocMatchUps } from './generateAdHocMatchUps';\nimport structureTemplate from '../templates/structureTemplate';\nimport { xa } from '../../../utilities/objects';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { constantToString } from '../../../utilities/strings';\nimport { getDrawTypeCoercion } from './getDrawTypeCoercion';\nimport { generateRange } from '../../../utilities/arrays';\nimport { ensureInt } from '../../../utilities/ensureInt';\nimport { newDrawDefinition } from './newDrawDefinition';\nimport { prepareStage } from './prepareStage';\nimport {\n  setStageDrawSize,\n  setStageQualifiersCount,\n} from '../../../mutate/drawDefinitions/entryGovernor/stageEntryCounts';\n\nimport { PlayoffAttributes, PolicyDefinitions, SeedingProfile } from '../../../types/factoryTypes';\nimport { QUALIFIER, STRUCTURE_SELECTED_STATUSES } from '../../../constants/entryStatusConstants';\nimport { ResultType, decorateResult } from '../../../global/functions/decorateResult';\nimport POLICY_SEEDING_DEFAULT from '../../../fixtures/policies/POLICY_SEEDING_DEFAULT';\nimport { FORMAT_STANDARD } from '../../../fixtures/scoring/matchUpFormats';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { TEAM } from '../../../constants/matchUpTypes';\nimport {\n  ErrorType,\n  INVALID_DRAW_TYPE,\n  INVALID_VALUES,\n  MISSING_DRAW_SIZE,\n  MISSING_VALUE,\n} from '../../../constants/errorConditionConstants';\nimport {\n  AD_HOC,\n  DOUBLE_ELIMINATION,\n  FEED_IN,\n  LUCKY_DRAW,\n  MAIN,\n  POSITION,\n  QUALIFYING,\n  ROUND_ROBIN,\n  ROUND_ROBIN_WITH_PLAYOFF,\n  SINGLE_ELIMINATION,\n} from '../../../constants/drawDefinitionConstants';\nimport {\n  POLICY_TYPE_AVOIDANCE,\n  POLICY_TYPE_MATCHUP_ACTIONS,\n  POLICY_TYPE_SEEDING,\n} from '../../../constants/policyConstants';\nimport {\n  DrawDefinition,\n  DrawTypeUnion,\n  Entry,\n  Event,\n  TieFormat,\n  Tournament,\n  EventTypeUnion,\n} from '../../../types/tournamentTypes';\n\ntype GenerateDrawDefinitionArgs = {\n  automated?: boolean | { seedsOnly: boolean };\n  playoffAttributes?: PlayoffAttributes;\n  policyDefinitions?: PolicyDefinitions;\n  voluntaryConsolation?: {\n    structureAbbreviation?: string;\n    structureName?: string;\n    structureId?: string;\n  };\n  ignoreAllowedDrawTypes?: boolean;\n  qualifyingPlaceholder?: boolean;\n  considerEventEntries?: boolean;\n  seedingProfile?: SeedingProfile;\n  hydrateCollections?: boolean;\n  tournamentRecord: Tournament;\n  drawTypeCoercion?: boolean;\n  ignoreStageSpace?: boolean;\n  qualifyingProfiles?: any[];\n  drawMatic?: DrawMaticArgs;\n  qualifyingOnly?: boolean;\n  drawType?: DrawTypeUnion;\n  enforceGender?: boolean;\n  processCodes?: string[];\n  matchUpFormat?: string;\n  matchUpType?: EventTypeUnion;\n  structureName?: string;\n  tieFormatName?: string;\n  tieFormat?: TieFormat;\n  drawEntries?: Entry[];\n  roundsCount?: number;\n  seedsCount?: number;\n  placeByes?: boolean;\n  drawName?: string;\n  drawSize?: number;\n  idPrefix?: string;\n  isMock?: boolean;\n  uuids?: string[];\n  drawId?: string;\n  event: Event;\n};\n\nexport function generateDrawDefinition(params: GenerateDrawDefinitionArgs): ResultType & {\n  existingDrawDefinition?: boolean;\n  qualifyingConflicts?: any[];\n  positioningReports?: any[];\n  drawDefinition?: DrawDefinition;\n  structureId?: string;\n  success?: boolean;\n  error?: ErrorType;\n  conflicts?: any[];\n} {\n  const stack = 'generateDrawDefinition';\n  const {\n    considerEventEntries = true, // in the absence of drawSize and drawEntries, look to event.entries\n    ignoreAllowedDrawTypes,\n    voluntaryConsolation,\n    hydrateCollections,\n    ignoreStageSpace,\n    tournamentRecord,\n    qualifyingOnly,\n    tieFormatName,\n    drawEntries,\n    placeByes,\n    event,\n  } = params;\n\n  const isMock = params.isMock ?? true;\n  const idPrefix = params.idPrefix;\n\n  const appliedPolicies =\n    getAppliedPolicies({\n      tournamentRecord,\n      event,\n    }).appliedPolicies ?? {};\n\n  const policyDefinitions = makeDeepCopy(params.policyDefinitions ?? {}, false, true);\n\n  const drawTypeCoercion =\n    params.drawTypeCoercion ??\n    getDrawTypeCoercion({\n      drawType: params.drawType,\n      policyDefinitions,\n      appliedPolicies,\n    });\n\n  const drawType =\n    (drawTypeCoercion && params.drawSize === 2 && SINGLE_ELIMINATION) || params.drawType || SINGLE_ELIMINATION;\n\n  const seedingPolicy = policyDefinitions?.[POLICY_TYPE_SEEDING] ?? appliedPolicies?.[POLICY_TYPE_SEEDING];\n\n  const seedingProfile =\n    params.seedingProfile ?? seedingPolicy?.seedingProfile?.drawTypes?.[drawType] ?? seedingPolicy?.seedingProfile;\n\n  // extend policyDefinitions only if a seedingProfile was specified in params\n  if (params.seedingProfile) {\n    if (!policyDefinitions[POLICY_TYPE_SEEDING]) {\n      policyDefinitions[POLICY_TYPE_SEEDING] = {\n        ...POLICY_SEEDING_DEFAULT[POLICY_TYPE_SEEDING],\n      };\n    }\n    policyDefinitions[POLICY_TYPE_SEEDING].seedingProfile = seedingProfile;\n  }\n\n  // get participants both for entry validation and for automated placement\n  // automated placement requires them to be \"inContext\" for avoidance policies to work\n  const { participants, participantMap } = getParticipants({\n    withIndividualParticipants: true,\n    convertExtensions: true,\n    internalUse: true,\n    tournamentRecord,\n  });\n\n  const enforceGender =\n    params.enforceGender ??\n    policyDefinitions?.[POLICY_TYPE_MATCHUP_ACTIONS]?.participants?.enforceGender ??\n    appliedPolicies?.[POLICY_TYPE_MATCHUP_ACTIONS]?.participants?.enforceGender;\n\n  // if tournamentRecord is provided, and unless instructed to ignore valid types,\n  // check for restrictions on allowed drawTypes\n  const allowedDrawTypes =\n    !ignoreAllowedDrawTypes &&\n    tournamentRecord &&\n    getAllowedDrawTypes({\n      tournamentRecord,\n      categoryType: event?.category?.categoryType,\n      categoryName: event?.category?.categoryName,\n    });\n  if (allowedDrawTypes?.length && !allowedDrawTypes.includes(drawType)) {\n    return decorateResult({ result: { error: INVALID_DRAW_TYPE }, stack });\n  }\n\n  const eventEntries =\n    event?.entries?.filter(\n      (entry: Entry) => entry.entryStatus && [...STRUCTURE_SELECTED_STATUSES, QUALIFIER].includes(entry.entryStatus),\n    ) ?? [];\n\n  const consideredEntries = (\n    (qualifyingOnly && []) ||\n    drawEntries ||\n    (considerEventEntries ? eventEntries : [])\n  ).filter(({ entryStage }) => !entryStage || entryStage === MAIN);\n\n  // entries participantTypes must correspond with eventType\n  // this is only possible if the event is provided\n  const validEntriesResult =\n    event &&\n    participants &&\n    checkValidEntries({\n      consideredEntries,\n      appliedPolicies,\n      participantMap,\n      enforceGender,\n      participants,\n      event,\n    });\n\n  if (validEntriesResult?.error) return decorateResult({ result: validEntriesResult, stack });\n\n  const derivedDrawSize =\n    !params.drawSize &&\n    consideredEntries.length &&\n    ![AD_HOC, DOUBLE_ELIMINATION, FEED_IN, ROUND_ROBIN, ROUND_ROBIN_WITH_PLAYOFF].includes(drawType) &&\n    nextPowerOf2(consideredEntries.length);\n\n  // coersion of drawSize and seedsCount to integers\n  const drawSize =\n    derivedDrawSize ||\n    (params.drawSize && isConvertableInteger(params.drawSize) && ensureInt(params.drawSize)) ||\n    false; // required for isNaN check\n\n  if (isNaN(drawSize) && drawType !== AD_HOC) {\n    return decorateResult({\n      result: { error: MISSING_DRAW_SIZE },\n      stack,\n    });\n  }\n\n  let seedsCount = typeof params.seedsCount !== 'number' ? ensureInt(params.seedsCount ?? 0) : params.seedsCount ?? 0;\n\n  const eventType = event?.eventType;\n  const matchUpType = params.matchUpType ?? eventType;\n\n  const existingDrawDefinition = params.drawId\n    ? (event?.drawDefinitions?.find((d) => d.drawId === params.drawId) as DrawDefinition)\n    : undefined;\n\n  // drawDefinition cannot have both tieFormat and matchUpFormat\n  let { tieFormat, matchUpFormat } = params;\n\n  // TODO: implement use of tieFormatId and tieFormats array\n  if (matchUpType === TEAM && eventType === TEAM) {\n    // if there is an existingDrawDefinition which has a tieFormat on MAIN structure\n    // use this tieFormat ONLY when no tieFormat is specified in params\n    const existingMainTieFormat = existingDrawDefinition?.structures?.find(({ stage }) => stage === MAIN)?.tieFormat;\n\n    tieFormat =\n      tieFormat ||\n      existingMainTieFormat ||\n      // if tieFormatName is provided and it matches the name of the tieFormat attached to parent event...\n      (tieFormatName && event?.tieFormat?.tieFormatName === tieFormatName && event.tieFormat) ||\n      // if the tieFormatName is not found in the factory then will use default\n      (tieFormatName &&\n        tieFormatDefaults({\n          namedFormat: tieFormatName,\n          hydrateCollections,\n          isMock,\n          event,\n        })) ||\n      // if no tieFormat is found on event then will use default\n      event?.tieFormat ||\n      tieFormatDefaults({ event, isMock, hydrateCollections });\n\n    matchUpFormat = undefined;\n  } else if (!matchUpFormat) {\n    tieFormat = undefined;\n    if (!event?.matchUpFormat) {\n      matchUpFormat = FORMAT_STANDARD;\n    }\n  }\n\n  if (tieFormat) {\n    const result = validateTieFormat({\n      gender: event?.gender,\n      enforceGender,\n      tieFormat,\n    });\n    if (result.error) return decorateResult({ result, stack });\n  }\n\n  const invalidDrawId = params.drawId && typeof params.drawId !== 'string';\n  if (invalidDrawId) return decorateResult({ result: { error: INVALID_VALUES }, stack });\n\n  // ---------------------------------------------------------------------------\n  // Begin construction of drawDefinition\n  if (existingDrawDefinition && drawType !== existingDrawDefinition.drawType)\n    existingDrawDefinition.drawType = drawType;\n\n  let drawDefinition: any =\n    existingDrawDefinition ??\n    newDrawDefinition({\n      drawType,\n      drawId: params.drawId,\n      processCodes: params.processCodes,\n    });\n\n  // if there is a defined matchUpFormat/tieFormat only attach to drawDefinition...\n  // ...when there is not an equivalent definition on the parent event\n  if (matchUpFormat || tieFormat) {\n    const equivalentInScope =\n      (matchUpFormat && event?.matchUpFormat === matchUpFormat) ||\n      (event?.tieFormat && tieFormat && JSON.stringify(event.tieFormat) === JSON.stringify(tieFormat));\n\n    // if an equivalent matchUpFormat or tieFormat is attached to the event\n    // there is no need to attach to the drawDefinition\n    if (!equivalentInScope) {\n      if (tieFormat) {\n        const result = checkTieFormat({ tieFormat });\n        if (result.error) return decorateResult({ result, stack });\n\n        drawDefinition.tieFormat = result.tieFormat ?? tieFormat;\n      } else if (matchUpFormat) {\n        const result = setMatchUpMatchUpFormat({\n          tournamentRecord,\n          drawDefinition,\n          matchUpFormat,\n          event,\n        });\n        if (result.error) {\n          return {\n            error: result.error,\n            info: 'matchUpFormat or tieFormat error',\n          };\n        }\n      }\n\n      if (matchUpType) drawDefinition.matchUpType = matchUpType;\n    }\n  }\n\n  // ---------------------------------------------------------------------------\n  // Attach policies to the drawDefinition\n  // if there is an avoidance policy on the event, it must be preserved in the drawDefinition\n  // if there is an avoidance policy in policyDefinitions, it will override\n  // avoidance policies on the event can be changed (if location used for UI)\n\n  const policiesToAttach = {\n    [POLICY_TYPE_AVOIDANCE]: appliedPolicies[POLICY_TYPE_AVOIDANCE],\n  };\n\n  if (policyDefinitions) {\n    if (typeof policyDefinitions !== 'object') {\n      return decorateResult({\n        info: 'policyDefinitions must be an object',\n        result: { error: INVALID_VALUES },\n        stack,\n      });\n    } else {\n      for (const key of Object.keys(policyDefinitions)) {\n        if (JSON.stringify(appliedPolicies?.[key]) !== JSON.stringify(policyDefinitions[key])) {\n          policiesToAttach[key] = policyDefinitions[key];\n        }\n      }\n\n      if (Object.keys(policiesToAttach).length) {\n        // attach any policyDefinitions which have been provided and are not already present\n        attachPolicies({\n          policyDefinitions: policiesToAttach,\n          drawDefinition,\n        });\n        Object.assign(appliedPolicies, policiesToAttach);\n      }\n    }\n  } else if (policiesToAttach.avoidance) {\n    attachPolicies({ drawDefinition, policyDefinitions: policiesToAttach });\n  }\n\n  if (!appliedPolicies[POLICY_TYPE_SEEDING] && !policyDefinitions[POLICY_TYPE_SEEDING]) {\n    attachPolicies({\n      policyDefinitions: POLICY_SEEDING_DEFAULT,\n      drawDefinition,\n    });\n    Object.assign(appliedPolicies, POLICY_SEEDING_DEFAULT);\n  }\n  // ---------------------------------------------------------------------------\n\n  // find existing MAIN structureId if existingDrawDefinition\n  let structureId = existingDrawDefinition?.structures?.find(\n    (structure) => structure.stage === MAIN && structure.stageSequence === 1,\n  )?.structureId;\n  const entries = drawEntries ?? eventEntries;\n  const positioningReports: any[] = [];\n  let drawTypeResult;\n  let conflicts: any[] = [];\n\n  const generateQualifyingPlaceholder =\n    params.qualifyingPlaceholder && !params.qualifyingProfiles?.length && !existingDrawDefinition;\n\n  const existingQualifyingStructures = existingDrawDefinition\n    ? existingDrawDefinition.structures?.filter((structure) => structure.stage === QUALIFYING)\n    : [];\n  const existingQualifyingPlaceholderStructureId =\n    existingQualifyingStructures?.length === 1 &&\n    !existingQualifyingStructures[0].matchUps?.length &&\n    existingQualifyingStructures[0].structureId;\n\n  if (existingQualifyingPlaceholderStructureId) {\n    const qualifyingProfiles = params.qualifyingProfiles;\n    const qualifyingResult = qualifyingProfiles?.length\n      ? generateQualifyingStructures({\n          uuids: params.uuids,\n          qualifyingProfiles,\n          appliedPolicies,\n          idPrefix,\n          isMock,\n        })\n      : undefined;\n\n    if (qualifyingResult?.error) {\n      return qualifyingResult;\n    }\n\n    drawDefinition.structures = drawDefinition.structures?.filter(\n      ({ structureId }) => structureId !== existingQualifyingPlaceholderStructureId,\n    );\n    drawDefinition.links = drawDefinition.links?.filter(\n      ({ source }) => source.structureId !== existingQualifyingPlaceholderStructureId,\n    );\n\n    const { qualifiersCount, qualifyingDrawPositionsCount, qualifyingDetails } = qualifyingResult ?? {};\n\n    if (qualifyingDrawPositionsCount) {\n      if (qualifyingResult?.structures) {\n        drawDefinition.structures?.push(...qualifyingResult.structures);\n      }\n      if (qualifyingResult?.links) {\n        drawDefinition.links?.push(...qualifyingResult.links);\n      }\n    }\n\n    const mainStructure = drawDefinition.structures?.find(\n      ({ stage, stageSequence }) => stage === MAIN && stageSequence === 1,\n    );\n    const { qualifiersCount: existingQualifiersCount } = getQualifiersCount({\n      stageSequence: 1,\n      drawDefinition,\n      structureId,\n      stage: MAIN,\n    });\n\n    const derivedQualifiersCount = Math.max(qualifiersCount ?? 0, existingQualifiersCount ?? 0);\n\n    let result = setStageQualifiersCount({\n      qualifiersCount: derivedQualifiersCount,\n      drawDefinition,\n      stage: MAIN,\n    });\n    if (result.error) return result;\n\n    result = setStageDrawSize({\n      drawSize: qualifyingDrawPositionsCount,\n      stage: QUALIFYING,\n      drawDefinition,\n    });\n    if (result.error) return result;\n\n    for (const entry of (drawEntries ?? []).filter(({ entryStage }) => entryStage === QUALIFYING)) {\n      const entryData = {\n        ...entry,\n        entryStage: entry.entryStage ?? MAIN,\n        drawDefinition,\n      };\n      // ignore errors (EXITING_PARTICIPANT)\n      addDrawEntry(entryData);\n    }\n\n    for (const qualifyingDetail of qualifyingDetails || []) {\n      const {\n        finalQualifyingRoundNumber: qualifyingRoundNumber,\n        finalQualifyingStructureId: qualifyingStructureId,\n        roundTarget: targetEntryRound,\n        finishingPositions,\n        linkType,\n      } = qualifyingDetail;\n\n      const link =\n        mainStructure &&\n        generateQualifyingLink({\n          targetStructureId: mainStructure.structureId,\n          sourceStructureId: qualifyingStructureId,\n          sourceRoundNumber: qualifyingRoundNumber,\n          finishingPositions,\n          targetEntryRound,\n          linkType,\n        })?.link;\n      if (link?.error) return link;\n\n      if (link) {\n        if (!drawDefinition.links) drawDefinition.links = [];\n        drawDefinition.links.push(link);\n      }\n    }\n\n    drawTypeResult = { drawDefinition };\n  } else {\n    drawTypeResult = generateDrawTypeAndModifyDrawDefinition({\n      ...params,\n      modifyOriginal: false,\n      tournamentRecord,\n      appliedPolicies,\n      drawDefinition,\n      matchUpFormat,\n      matchUpType,\n      tieFormat,\n      drawSize,\n      isMock,\n    });\n    if (drawTypeResult.error) {\n      return decorateResult({ result: drawTypeResult, stack });\n    }\n    drawDefinition = drawTypeResult.drawDefinition;\n\n    // add all entries to the draw\n    for (const entry of entries) {\n      // if drawEntries and entryStage !== stage ignore\n      if (drawEntries && entry.entryStage && entry.entryStage !== MAIN) continue;\n\n      const entryData = {\n        ...entry,\n        ignoreStageSpace: ignoreStageSpace ?? drawType === AD_HOC,\n        entryStage: entry.entryStage ?? MAIN,\n        drawDefinition,\n        drawType,\n      };\n      const result = addDrawEntry(entryData);\n      if (drawEntries && result.error) {\n        // only report errors with drawEntries\n        // if entries are taken from event.entries assume stageSpace is not available\n        return decorateResult({ result, stack });\n      }\n    }\n\n    // temporary until seeding is supported in LUCKY_DRAW\n    if (drawType === LUCKY_DRAW) seedsCount = 0;\n\n    const structureResult = prepareStage({\n      ...drawTypeResult,\n      ...params,\n      qualifyingOnly: !drawSize || qualifyingOnly, // ooo!! If there is no drawSize then MAIN is not being generated\n      appliedPolicies,\n      drawDefinition,\n      seedingProfile,\n      participants,\n      stage: MAIN,\n      seedsCount,\n      placeByes,\n      drawSize,\n      entries,\n    });\n\n    if (structureResult.error && !structureResult.conflicts) {\n      return structureResult;\n    }\n\n    if (structureResult.positioningReport?.length)\n      positioningReports.push({ [MAIN]: structureResult.positioningReport });\n\n    structureId = structureResult.structureId;\n    if (structureResult.conflicts) conflicts = structureResult.conflicts;\n\n    if (drawType === AD_HOC && params.roundsCount) {\n      const entries = event?.entries?.filter(\n        ({ entryStage, entryStatus }) =>\n          (!entryStage || entryStage === MAIN) && entryStatus && STRUCTURE_SELECTED_STATUSES.includes(entryStatus),\n      );\n      const participantIds = entries?.map(xa('participantId'));\n      const matchUpsCount = entries ? Math.floor(entries.length / 2) : 0;\n      generateRange(1, params.roundsCount + 1).forEach(() => {\n        if (params.automated) {\n          const { restrictEntryStatus, generateMatchUps, structureId, matchUpIds, scaleName } = params.drawMatic ?? {};\n\n          const matchUps = drawMatic({\n            eventType: params.drawMatic?.eventType ?? matchUpType,\n            generateMatchUps: generateMatchUps ?? true,\n            restrictEntryStatus,\n            tournamentRecord,\n            participantIds,\n            drawDefinition,\n            structureId,\n            matchUpIds,\n            scaleName, // custom rating name to seed dynamic ratings\n            idPrefix,\n            isMock,\n            event,\n          }).matchUps;\n          addAdHocMatchUps({\n            tournamentRecord,\n            drawDefinition,\n            structureId,\n            matchUps,\n          });\n        } else {\n          const { matchUps } = generateAdHocMatchUps({\n            newRound: true,\n            drawDefinition,\n            matchUpsCount,\n            idPrefix,\n            isMock,\n            event,\n          });\n          addAdHocMatchUps({\n            tournamentRecord,\n            drawDefinition,\n            structureId,\n            matchUps,\n          });\n        }\n      });\n    }\n  }\n\n  const qualifyingConflicts: any[] = [];\n\n  if (params.qualifyingProfiles) {\n    const sequenceSort = (a, b) => a.stageSequence - b.stageSequence;\n    const roundTargetSort = (a, b) => a.roundTarget - b.roundTarget;\n\n    // keep track of structures already prepared in case of multiple matching structures\n    const preparedStructureIds: string[] = [];\n    let roundTarget = 1;\n\n    params.qualifyingProfiles.sort(roundTargetSort);\n\n    for (const roundTargetProfile of params.qualifyingProfiles) {\n      if (!Array.isArray(roundTargetProfile.structureProfiles))\n        return decorateResult({\n          info: mustBeAnArray('structureProfiles'),\n          result: { error: MISSING_VALUE },\n          stack,\n        });\n\n      roundTarget = roundTargetProfile.roundTarget || roundTarget;\n\n      const sortedStructureProfiles = roundTargetProfile.structureProfiles?.sort(sequenceSort) || [];\n\n      let sequence = 1;\n      for (const structureProfile of sortedStructureProfiles) {\n        const {\n          qualifyingRoundNumber,\n          qualifyingPositions,\n          seededParticipants,\n          seedingScaleName,\n          seedsCount = 0,\n          seedByRanking,\n          placeByes,\n          drawSize,\n        } = structureProfile;\n\n        const qualifyingStageResult = prepareStage({\n          ...drawTypeResult,\n          ...params,\n          seedingProfile: structureProfile.seedingProfile ?? seedingProfile,\n          stageSequence: sequence,\n          qualifyingRoundNumber,\n          preparedStructureIds,\n          qualifyingPositions,\n          seededParticipants,\n          stage: QUALIFYING,\n          seedingScaleName,\n          appliedPolicies,\n          drawDefinition,\n          qualifyingOnly,\n          seedByRanking,\n          participants,\n          roundTarget,\n          seedsCount,\n          placeByes,\n          drawSize,\n          entries,\n        });\n\n        if (qualifyingStageResult.error) {\n          return qualifyingStageResult;\n        }\n\n        if (qualifyingStageResult.structureId) {\n          preparedStructureIds.push(qualifyingStageResult.structureId);\n        }\n\n        sequence += 1;\n\n        if (qualifyingStageResult.conflicts?.length) qualifyingConflicts.push(...qualifyingStageResult.conflicts);\n\n        if (qualifyingStageResult.positioningReport?.length)\n          positioningReports.push({\n            [QUALIFYING]: qualifyingStageResult.positioningReport,\n          });\n      }\n\n      roundTarget += 1;\n    }\n  } else if (structureId && generateQualifyingPlaceholder) {\n    const qualifyingStructure = structureTemplate({\n      structureName: constantToString(QUALIFYING),\n      stage: QUALIFYING,\n    });\n    const { link } = generateQualifyingLink({\n      sourceStructureId: qualifyingStructure.structureId,\n      targetStructureId: structureId,\n      sourceRoundNumber: 0,\n      linkType: POSITION,\n    });\n    if (!drawDefinition.structures) drawDefinition.structures = [];\n    drawDefinition.structures.push(qualifyingStructure);\n    if (!drawDefinition.links) drawDefinition.links = [];\n    drawDefinition.links.push(link);\n  }\n\n  drawDefinition.drawName = params.drawName ?? (drawType && constantToString(drawType));\n\n  if (typeof voluntaryConsolation === 'object' && drawSize >= 4) {\n    addVoluntaryConsolationStructure({\n      ...voluntaryConsolation,\n      drawDefinition,\n      matchUpType,\n    });\n  }\n\n  return {\n    existingDrawDefinition: !!existingDrawDefinition,\n    qualifyingConflicts,\n    positioningReports,\n    drawDefinition,\n    structureId,\n    ...SUCCESS,\n    conflicts,\n  };\n}\n","import definitionTemplate from '../templates/drawDefinitionTemplate';\nimport { UUID } from '../../../utilities/UUID';\n\ntype NewDrawDefinitionArgs = {\n  processCodes?: string[];\n  matchUpType?: string;\n  drawType?: string;\n  drawId?: string;\n};\nexport function newDrawDefinition(params?: NewDrawDefinitionArgs) {\n  const { drawId = UUID(), processCodes, matchUpType, drawType } = params ?? {};\n  const drawDefinition = definitionTemplate();\n  return Object.assign(drawDefinition, {\n    processCodes,\n    matchUpType,\n    drawType,\n    drawId,\n  });\n}\n","import { validateTieFormat } from '../../validators/validateTieFormat';\nimport { UUID } from '../../utilities/UUID';\n\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { TieFormat } from '../../types/tournamentTypes';\n\ntype CheckTieFormatArgs = {\n  tieFormat: TieFormat;\n};\n// add collectionIds if missing\nexport function checkTieFormat({\n  tieFormat,\n}: CheckTieFormatArgs): ResultType & { tieFormat?: TieFormat } {\n  const result = validateTieFormat({\n    checkCollectionIds: false,\n    tieFormat,\n  });\n  if (result.error) return result;\n\n  for (const collectionDefinition of tieFormat.collectionDefinitions) {\n    if (!collectionDefinition.collectionId)\n      collectionDefinition.collectionId = UUID();\n  }\n\n  return { tieFormat };\n}\n","/*\n * Flights are created by splitting event entries into groups.\n * The following split methods are supported.\n * In all cases event.entries are first sorted by some scaleValue.\n * scaleValue is derived from rankings or ratings or seedings.\n */\nexport const SPLIT_LEVEL_BASED = 'splitLevelBased'; // Evenly chunk sorted entries\nexport const SPLIT_WATERFALL = 'splitWaterfall'; // 1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4\nexport const SPLIT_SHUTTLE = 'splitShuttle'; // 1,2,3,4,4,3,2,1,1,2,3,4,4,3,2,1\n\nexport const flightConstants = {\n  SPLIT_LEVEL_BASED,\n  SPLIT_WATERFALL,\n  SPLIT_SHUTTLE,\n};\n","export const ASC = 'ASC';\nexport const ASCENDING = 'ASC';\nexport const DESC = 'DESC';\nexport const DESCENDING = 'DESC';\n\nexport const sortingConstants = { ASC, ASCENDING, DESC, DESCENDING };\n","import { resolveTieFormat } from '../../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { getPairedParticipant } from '../../../query/participant/getPairedParticipant';\nimport { getParticipants } from '../../../query/participants/getParticipants';\nimport { addParticipant } from '../../../mutate/participants/addParticipant';\nimport { validateTieFormat } from '../../../validators/validateTieFormat';\nimport { getParticipantId } from '../../../global/functions/extractors';\nimport { addExtension } from '../../../mutate/extensions/addExtension';\nimport { generateRange } from '../../../utilities/arrays';\nimport { isNumeric } from '../../../utilities/math';\n\nimport { CollectionAssignment, DrawDefinition, Event, TieFormat, Tournament } from '../../../types/tournamentTypes';\nimport { DOUBLES_MATCHUP, SINGLES_MATCHUP } from '../../../constants/matchUpTypes';\nimport { DIRECT_ACCEPTANCE } from '../../../constants/entryStatusConstants';\nimport { FEMALE, MALE, MIXED } from '../../../constants/genderConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { COMPETITOR } from '../../../constants/participantRoles';\nimport { DESCENDING } from '../../../constants/sortingConstants';\nimport { LINEUPS } from '../../../constants/extensionConstants';\nimport { TEAM_EVENT } from '../../../constants/eventConstants';\nimport { PAIR } from '../../../constants/participantConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { RANKING } from '../../../constants/scaleConstants';\nimport { LineUp } from '../../../types/factoryTypes';\nimport {\n  DRAW_DEFINITION_NOT_FOUND,\n  INVALID_EVENT_TYPE,\n  INVALID_TIE_FORMAT,\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../../constants/errorConditionConstants';\n\ntype GenerateLineUpsArgs = {\n  useDefaultEventRanking?: boolean;\n  tournamentRecord: Tournament;\n  drawDefinition?: DrawDefinition;\n  scaleAccessor: any;\n  singlesOnly?: boolean;\n  tieFormat?: TieFormat;\n  attach?: boolean;\n  event: Event;\n};\n\n// by default if there are no scaleValues matching the scaleAccessor then participants will be assigned in the array order of [team].individidualParticipantIds\nexport function generateLineUps(params: GenerateLineUpsArgs): ResultType & {\n  lineUps?: { [key: string]: LineUp };\n  participantsToAdd?: any[];\n} {\n  let { tieFormat } = params;\n  const {\n    useDefaultEventRanking,\n    tournamentRecord,\n    drawDefinition,\n    scaleAccessor, // e.g. { scaleType: 'RANKINGS', scaleName: 'U18', accessor: 'wtnRating', sortOrder: 'ASC' }\n    singlesOnly, // use singles scale for doubles events\n    attach, // boolean - when true attach LINEUPS extension to drawDefinition and add new PAIR participants (where necessary)\n    event,\n  } = params;\n\n  if (event?.eventType !== TEAM_EVENT) return { error: INVALID_EVENT_TYPE };\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!tieFormat && !drawDefinition) return { error: DRAW_DEFINITION_NOT_FOUND };\n\n  tieFormat = tieFormat ?? resolveTieFormat({ drawDefinition, event })?.tieFormat;\n\n  if (validateTieFormat({ tieFormat }).error) return { error: INVALID_TIE_FORMAT };\n\n  if (typeof scaleAccessor !== 'object' && !useDefaultEventRanking)\n    return { error: INVALID_VALUES, context: { scaleAccessor } };\n\n  const lineUps: { [key: string]: LineUp } = {};\n\n  const targetEntries = (drawDefinition?.entries ?? event?.entries ?? []).filter(\n    (entry) => entry?.entryStatus === DIRECT_ACCEPTANCE,\n  );\n\n  const participantIds = targetEntries.map(getParticipantId);\n  const { participants = [] } = getParticipants({\n    withIndividualParticipants: true,\n    withScaleValues: true,\n    tournamentRecord,\n  });\n\n  const teamParticipants = participants.filter(({ participantId }) => participantIds.includes(participantId));\n\n  const formatScaleType = (type) => (type === RANKING ? 'rankings' : 'ratings');\n\n  const defaultScaleName = event?.category?.categoryName ?? event?.category?.ageCategoryCode;\n  const { scaleName = defaultScaleName, scaleType = RANKING, sortOrder, accessor } = scaleAccessor || {};\n\n  const formattedScaleType = formatScaleType(scaleType);\n  const getScaleValue = (individualParticipant, matchUpType) => {\n    let matchUpTypeScales = individualParticipant[formattedScaleType]?.[matchUpType];\n\n    // if { userDefaultEventRanking: true } fallback to SINGLES if no values for DOUBLES\n    if (!matchUpTypeScales && useDefaultEventRanking) {\n      matchUpTypeScales = individualParticipant[formattedScaleType]?.[SINGLES_MATCHUP];\n    }\n\n    if (Array.isArray(matchUpTypeScales)) {\n      const scaleValue = matchUpTypeScales.find((scale) => scale.scaleName === scaleName)?.scaleValue;\n      if (isNumeric(scaleValue)) {\n        return scaleValue;\n      } else if (accessor && typeof scaleValue === 'object') return scaleValue[accessor];\n    }\n    return 0;\n  };\n\n  const sortMethod = (a, b, matchUpType) => {\n    const x = sortOrder === DESCENDING ? b : a;\n    const y = sortOrder === DESCENDING ? a : b;\n    return getScaleValue(x, matchUpType) - getScaleValue(y, matchUpType);\n  };\n  const singlesScaleSort = (a, b) => sortMethod(a, b, SINGLES_MATCHUP);\n  const doublesScaleSort = (a, b) => sortMethod(a, b, DOUBLES_MATCHUP);\n\n  const participantIdPairs: string[][] = [];\n  const collectionDefinitions = tieFormat?.collectionDefinitions ?? [];\n  for (const teamParticipant of teamParticipants) {\n    const singlesSort = teamParticipant.individualParticipants?.sort(singlesScaleSort) ?? [];\n    const doublesSort = singlesOnly\n      ? singlesSort\n      : teamParticipant.individualParticipants?.sort(doublesScaleSort) ?? [];\n\n    const participantAssignments: { [key: string]: CollectionAssignment[] } = {};\n    for (const collectionDefinition of collectionDefinitions) {\n      const collectionParticipantIds: string[] = [];\n      const { collectionId, matchUpCount, matchUpType, gender } = collectionDefinition;\n      const singlesMatchUp = matchUpType === SINGLES_MATCHUP;\n\n      generateRange(0, matchUpCount).forEach((i) => {\n        const typeSort = singlesMatchUp ? singlesSort : doublesSort ?? [];\n        const collectionPosition = i + 1;\n\n        const participantIds: string[] = [];\n        generateRange(0, singlesMatchUp ? 1 : 2).forEach((i) => {\n          const nextParticipantId = typeSort?.find((participant) => {\n            const targetGender =\n              gender && (([MALE, FEMALE].includes(gender) && gender) || (gender === MIXED && [MALE, FEMALE][i]));\n            return (\n              (!targetGender || targetGender === participant.person?.sex) &&\n              !collectionParticipantIds.includes(participant.participantId)\n            );\n          })?.participantId;\n\n          // keep track of participantIds which have already been assigned\n          if (nextParticipantId) {\n            participantIds.push(nextParticipantId);\n            collectionParticipantIds.push(nextParticipantId);\n            if (!participantAssignments[nextParticipantId]) participantAssignments[nextParticipantId] = [];\n            participantAssignments[nextParticipantId].push({\n              collectionPosition,\n              collectionId,\n            });\n          }\n        });\n        if (!singlesMatchUp) participantIdPairs.push(participantIds);\n      });\n    }\n\n    const lineUp: LineUp = Object.keys(participantAssignments).map((participantId) => ({\n      collectionAssignments: participantAssignments[participantId],\n      participantId,\n    }));\n\n    lineUps[teamParticipant.participantId] = lineUp;\n  }\n\n  const participantsToAdd: any[] = [];\n  for (const pairParticipantIds of participantIdPairs) {\n    const { participant: existingPairParticipant } = getPairedParticipant({\n      tournamentParticipants: participants,\n      participantIds: pairParticipantIds,\n    });\n    if (!existingPairParticipant) {\n      const newPairParticipant = {\n        individualParticipantIds: pairParticipantIds,\n        participantRole: COMPETITOR,\n        participantType: PAIR,\n      };\n      participantsToAdd.push(newPairParticipant);\n    }\n  }\n\n  if (attach) {\n    while (participantsToAdd.length) {\n      addParticipant({\n        participant: participantsToAdd.pop(),\n        tournamentRecord,\n      });\n    }\n    const extension = { name: LINEUPS, value: lineUps };\n    addExtension({ element: drawDefinition, extension });\n  }\n\n  return { ...SUCCESS, lineUps, participantsToAdd };\n}\n","import { sameDay } from '../../utilities/dateTime';\n\nexport function getCourtDateAvailability({ court, date }) {\n  const targetDateAvailability =\n    date &&\n    court.dateAvailability.find((availability) =>\n      sameDay(availability.date, date)\n    );\n  const defaultAvailability = court.dateAvailability.find(\n    (availability) => !availability.date\n  );\n\n  return targetDateAvailability || defaultAvailability;\n}\n","import { timeToDate, extractTime, tidyTime } from '../../../utilities/dateTime';\n\ntype GenerateTimeSlotsArgs = {\n  includeBookingTypes?: string[];\n  courtDate: any;\n};\n\nexport function generateTimeSlots({\n  includeBookingTypes = [],\n  courtDate,\n}: GenerateTimeSlotsArgs) {\n  const timeSlots: any[] = [];\n  let startTime = timeToDate(courtDate.startTime);\n\n  (courtDate.bookings || [])\n    .filter(\n      (booking) =>\n        !booking.bookingType ||\n        !includeBookingTypes.includes(booking.bookingType)\n    )\n    .sort((a, b) => tidyTime(a.startTime).localeCompare(tidyTime(b.startTime)))\n    .forEach((booking) => {\n      const timeSlot = {\n        startTime: extractTime(startTime.toISOString()),\n        endTime: booking.startTime,\n      };\n      if (timeToDate(booking.startTime) > startTime) {\n        timeSlots.push(timeSlot);\n      }\n      if (timeToDate(booking.endTime) > startTime) {\n        startTime = timeToDate(booking.endTime);\n      }\n    });\n\n  const timeSlot = {\n    startTime: extractTime(startTime.toISOString()),\n    endTime: courtDate.endTime,\n  };\n  if (timeToDate(courtDate.endTime) > startTime) {\n    timeSlots.push(timeSlot);\n  }\n\n  return timeSlots;\n}\n","import { Court } from '../../types/tournamentTypes';\nimport { addMinutes, timeToDate } from '../../utilities/dateTime';\nimport { getCourtDateAvailability } from './getCourtDateAvailability';\nimport { getEnoughTime } from './getEnoughTime';\n\ntype GetCourtsAvailableAtPeriodStartArgs = {\n  averageMatchUpMinutes: number;\n  includeBookingTypes?: boolean;\n  periodStart: string;\n  courts: any[];\n  date: string;\n};\nexport function getCourtsAvailableAtPeriodStart(\n  params: GetCourtsAvailableAtPeriodStartArgs\n) {\n  const { averageMatchUpMinutes, includeBookingTypes, periodStart, date } =\n    params;\n  const courts = params.courts as Court[];\n  const periodStartTime = timeToDate(periodStart);\n  const periodEndTime = addMinutes(periodStartTime, averageMatchUpMinutes);\n\n  const { enoughTime } = getEnoughTime({\n    averageMatchUpMinutes,\n    includeBookingTypes,\n    periodStartTime,\n    periodEndTime,\n  });\n\n  const availableCourts =\n    courts?.filter((court) => {\n      if (!Array.isArray(court.dateAvailability)) return false;\n      const courtDate = getCourtDateAvailability({ date, court });\n      return !!(courtDate && enoughTime(courtDate));\n    }) || [];\n\n  return {\n    availableToScheduleCount: availableCourts.length,\n  };\n}\n","import { minutesDifference, timeToDate } from '../../utilities/dateTime';\nimport { generateTimeSlots } from '../../assemblies/generators/scheduling/generateTimeSlots';\n\nexport function getEnoughTime({\n  averageMatchUpMinutes,\n  includeBookingTypes,\n  periodStartTime,\n  periodEndTime,\n}) {\n  const enoughTime = (courtDate) => {\n    const timeSlots = generateTimeSlots({\n      includeBookingTypes,\n      courtDate,\n    });\n    const availableTimeSlots = timeSlots.filter(validTimeSlot);\n    return !!availableTimeSlots.length;\n  };\n\n  function validTimeSlot(timeSlot) {\n    const slotStartTime = timeToDate(timeSlot.startTime);\n    const slotEndTime = timeToDate(timeSlot.endTime);\n    if (slotStartTime > periodStartTime) return false;\n    if (slotEndTime < periodEndTime) return false;\n\n    const timeSlotMinutes = minutesDifference(periodStartTime, slotEndTime);\n    return timeSlotMinutes >= averageMatchUpMinutes;\n  }\n\n  return { enoughTime };\n}\n","import { generateRange } from '../../../utilities/arrays';\n\ntype CourtGeneratorArgs = {\n  startTime?: string;\n  endTime?: string;\n  count?: number;\n  date?: string;\n};\nexport function courtGenerator(params?: CourtGeneratorArgs) {\n  const {\n    startTime = '8:00',\n    endTime = '20:30',\n    count = 10,\n    date,\n  } = params ?? {};\n  return generateRange(0, count).map(() => ({\n    dateAvailability: [{ date, startTime, endTime }],\n  }));\n}\n","import { generateTimeSlots } from '../../../../../assemblies/generators/scheduling/generateTimeSlots';\nimport { getCourtDateAvailability } from '../../../../../query/venues/getCourtDateAvailability';\nimport { makeDeepCopy } from '../../../../../utilities/makeDeepCopy';\nimport {\n  isValidDateString,\n  timeStringMinutes,\n} from '../../../../../utilities/dateTime';\n\nimport {\n  INVALID_BOOKINGS,\n  INVALID_DATE,\n  INVALID_VALUES,\n} from '../../../../../constants/errorConditionConstants';\n\nexport function generateVirtualCourts(params) {\n  const {\n    remainingScheduleTimes = [],\n    clearScheduleDates,\n    periodLength = 30,\n    scheduleDate,\n    courts = [],\n  } = params;\n  let { bookings = [] } = params;\n\n  if (!Array.isArray(courts) || !courts.length)\n    return { error: INVALID_VALUES, courts };\n  if (!Array.isArray(bookings)) return { error: INVALID_BOOKINGS };\n  if (!isValidDateString(scheduleDate)) return { error: INVALID_DATE };\n\n  if (clearScheduleDates) {\n    if (Array.isArray(clearScheduleDates)) {\n      if (clearScheduleDates.includes(scheduleDate)) bookings = [];\n    } else {\n      bookings = [];\n    }\n  }\n\n  const { courtBookings, unassignedBookings } = bookings.reduce(\n    (accumulator: any, booking) => {\n      const { courtId } = booking;\n      if (courtId) {\n        if (!accumulator.courtBookings[courtId]) {\n          accumulator.courtBookings[courtId] = [booking];\n        } else {\n          accumulator.courtBookings[courtId].push(booking);\n        }\n      } else {\n        accumulator.unassignedBookings.push(booking);\n      }\n      return accumulator;\n    },\n    { courtBookings: {}, unassignedBookings: [] }\n  );\n\n  const inProcessCourts = courts.map((court, index) => {\n    const { courtId, courtName } = court;\n    const bookingsThisCourt = courtBookings[courtId] || [];\n    const availability =\n      getCourtDateAvailability({ date: scheduleDate, court }) || {};\n    const {\n      bookings: existingBookings = [],\n      startTime,\n      endTime,\n      date,\n    } = availability;\n\n    const allocatedTimeBooking = remainingScheduleTimes[index] && {\n      startTime,\n      endTime: remainingScheduleTimes[index],\n    };\n\n    const amendedBookings = [\n      allocatedTimeBooking,\n      ...makeDeepCopy(existingBookings, false, true),\n      ...bookingsThisCourt,\n    ].filter(Boolean);\n\n    return {\n      courtId,\n      courtName,\n      dateAvailability: {\n        bookings: amendedBookings,\n        startTime,\n        endTime,\n        date,\n      },\n    };\n  });\n\n  unassignedBookings.sort(\n    (a, b) => timeStringMinutes(a.startTime) - timeStringMinutes(b.startTime)\n  );\n\n  const getCourtTimeSlots = () =>\n    inProcessCourts\n      .map((court) => {\n        const courtDate = court.dateAvailability;\n        const timeSlots = generateTimeSlots({ courtDate });\n        return {\n          courtName: court.courtName,\n          courtId: court.courtId,\n          timeSlots,\n        };\n      })\n      .flat();\n\n  const assignedBookings: any[] = [];\n\n  for (const unassignedBooking of unassignedBookings) {\n    const { startTime, endTime, averageMinutes, recoveryMinutes, matchUpId } =\n      unassignedBooking;\n    const startMinutes = timeStringMinutes(startTime);\n    const endMinutes = timeStringMinutes(endTime);\n    const courtTimeSlots = getCourtTimeSlots();\n    const bestCourt = courtTimeSlots.reduce(\n      (best: any, { courtId, courtName, timeSlots }) => {\n        let startDifference;\n        const timeSlot = timeSlots.find(({ startTime, endTime }) => {\n          startDifference = timeStringMinutes(startTime) - startMinutes;\n          const startFits = startMinutes >= timeStringMinutes(startTime);\n          const endFits = endMinutes <= timeStringMinutes(endTime);\n          return (\n            endFits &&\n            best.startDifference !== 0 &&\n            (((startDifference === 0 || startDifference + periodLength >= 0) &&\n              (best.startDifference === undefined ||\n                startDifference < best.startDifference)) ||\n              startFits)\n          );\n        });\n        return timeSlot ? { courtName, courtId, startDifference } : best;\n      },\n      {}\n    );\n\n    if (bestCourt.courtId) {\n      const booking = {\n        averageMinutes,\n        recoveryMinutes,\n        matchUpId,\n        startTime,\n        endTime,\n      };\n      assignedBookings.push(booking);\n      const virtualCourt = inProcessCourts.find(\n        ({ courtId }) => courtId === bestCourt.courtId\n      );\n      virtualCourt?.dateAvailability.bookings.push(booking);\n    } else {\n      console.log({ unassignedBooking });\n    }\n  }\n\n  const virtualCourts: any[] = inProcessCourts.map(\n    ({ courtId, courtName, dateAvailability }) => ({\n      dateAvailability: [dateAvailability],\n      courtName,\n      courtId,\n    })\n  );\n\n  return { virtualCourts, assignedBookings };\n}\n","type CalculatePeriodLengthArgs = {\n  averageMatchUpMinutes?: number;\n  periodLength?: number;\n  recoveryMinutes?: number;\n};\nexport function calculatePeriodLength({\n  averageMatchUpMinutes,\n  periodLength = 30,\n  recoveryMinutes,\n}: CalculatePeriodLengthArgs) {\n  const combinedMinutes =\n    (averageMatchUpMinutes || 90) + (recoveryMinutes || 0);\n  return periodLength > combinedMinutes ? combinedMinutes : periodLength || 30;\n}\n","import { getCourtDateAvailability } from '../../../../../query/venues/getCourtDateAvailability';\nimport { timeStringMinutes } from '../../../../../utilities/dateTime';\nimport { Court } from '../../../../../types/tournamentTypes';\n\ntype GetTimeBoundaryArgs = {\n  scheduleDate: string;\n  startTime?: boolean;\n  endTime?: boolean;\n  courts: Court[];\n};\nexport function getDateTimeBoundary({\n  scheduleDate,\n  startTime,\n  endTime,\n  courts,\n}: GetTimeBoundaryArgs) {\n  const accessor =\n    (startTime && 'startTime') || (endTime && 'endTime') || undefined;\n  return courts.reduce((boundaryTime, court) => {\n    const dateAvailability = getCourtDateAvailability({\n      date: scheduleDate,\n      court,\n    });\n\n    const comparisonTime =\n      accessor && (dateAvailability?.[accessor] || court[accessor]);\n\n    return comparisonTime &&\n      (!boundaryTime ||\n        (startTime &&\n          timeStringMinutes(comparisonTime) <\n            timeStringMinutes(boundaryTime)) ||\n        (endTime &&\n          timeStringMinutes(comparisonTime) > timeStringMinutes(boundaryTime)))\n      ? comparisonTime\n      : boundaryTime;\n  }, undefined);\n}\n\nexport function getCourtsTimeBoundary({ startTime, endTime, courts }) {\n  return courts.reduce((boundaryTime, court) => {\n    const comparisonTime = getCourtTimeBoundary({ startTime, endTime, court });\n    return comparisonTime &&\n      (!boundaryTime ||\n        (startTime &&\n          timeStringMinutes(comparisonTime) <\n            timeStringMinutes(boundaryTime)) ||\n        (endTime &&\n          timeStringMinutes(comparisonTime) > timeStringMinutes(boundaryTime)))\n      ? comparisonTime\n      : boundaryTime;\n  }, undefined);\n}\n\nexport function getCourtTimeBoundary({ startTime, endTime, court }) {\n  const accessor =\n    (startTime && 'startTime') || (endTime && 'endTime') || undefined;\n  return court.dateAvailability?.reduce((boundary, availability) => {\n    const candidate = availability?.[accessor];\n\n    if (!candidate) return boundary;\n    if (!boundary) return candidate;\n\n    if (startTime) {\n      if (timeStringMinutes(candidate) < timeStringMinutes(boundary))\n        boundary = candidate;\n    } else if (timeStringMinutes(boundary) > timeStringMinutes(candidate)) {\n      boundary = candidate;\n    }\n\n    return boundary;\n  }, undefined);\n}\n","import { generateVirtualCourts } from '../../mutate/matchUps/schedule/schedulers/utils/generateVirtualCourts';\nimport { calculatePeriodLength } from '../../mutate/matchUps/schedule/schedulers/utils/calculatePeriodLength';\nimport { courtGenerator } from '../../assemblies/generators/scheduling/courtGenerator';\nimport { getCourtsAvailableAtPeriodStart } from './getCourtsAvailableAtPeriodStart';\nimport { getFirstTimeSlotStartTime } from './getFirstTimeSlotStartTime';\nimport { generateRange } from '../../utilities/arrays';\nimport {\n  getUTCdateString,\n  extractTime,\n  extractDate,\n  timeStringMinutes,\n  dayMinutesToTimeString,\n} from '../../utilities/dateTime';\n\nimport { ScheduleTimesResult } from '../../types/factoryTypes';\nimport { ensureInt } from '../../utilities/ensureInt';\n\nexport function getScheduleTimes(params): {\n  scheduleTimes: ScheduleTimesResult[];\n  totalMatchUps: number;\n  timingProfile: any;\n} {\n  let {\n    date = getUTCdateString(),\n    startTime = '08:00',\n    endTime = '19:00',\n    periodLength,\n    courts,\n  } = params;\n\n  const {\n    calculateStartTimeFromCourts = true,\n    remainingScheduleTimes, // times remaining from previous scheduling iteration\n    averageMatchUpMinutes,\n    clearScheduleDates,\n    courtsCount,\n    bookings,\n  } = params;\n\n  periodLength =\n    periodLength || calculatePeriodLength({ averageMatchUpMinutes });\n\n  // standardize date as YYYY-MM-DD\n  date = extractDate(date);\n\n  // standardize time as 00:00\n  startTime = extractTime(startTime);\n  endTime = extractTime(endTime);\n\n  // keeps track of value of calculation after previous iteration\n  let previousCalculation = 0;\n\n  // keeps track of # of courts available during previous iteration\n  let previousAvailableCourts = 0;\n\n  // cumulativeMatches (float) number of matchUps possible for averageCourts\n  // over # of periods of length periodLength\n  let cumulativeMatches = 0;\n\n  // accumulated matchUps which have been scheduled\n  let totalMatchUps = 0;\n\n  // accumulated time periods when a court was available for scheduling\n  let cumulativePeriods = 0;\n\n  if (!courts && courtsCount) {\n    courts = courtGenerator({ startTime, endTime, count: courtsCount, date });\n  }\n\n  const { virtualCourts } = generateVirtualCourts({\n    remainingScheduleTimes,\n    clearScheduleDates,\n    scheduleDate: date,\n    periodLength,\n    bookings,\n    courts,\n  });\n\n  const { firstTimeSlotStartTime } = getFirstTimeSlotStartTime({\n    averageMinutes: averageMatchUpMinutes,\n    courts: virtualCourts,\n    startTime,\n    endTime,\n    date,\n  });\n\n  if (calculateStartTimeFromCourts && firstTimeSlotStartTime) {\n    startTime = firstTimeSlotStartTime ? firstTimeSlotStartTime : startTime;\n  }\n\n  // startTime, endTime and periodLength are used to calculate periodCount\n  const dayStartMinutes = timeStringMinutes(startTime);\n  const dayEndMinutes = timeStringMinutes(endTime);\n  const dayMinutes = dayEndMinutes - dayStartMinutes;\n  const periodCount = Math.floor(dayMinutes / periodLength);\n  const periods = generateRange(0, periodCount + 1);\n\n  const timingProfile = periods.map((period) => {\n    const periodStartMinutes = dayStartMinutes + period * periodLength;\n    const periodStart = dayMinutesToTimeString(periodStartMinutes);\n\n    // availableToScheduleCount calculated from periodStartTime and averageMatchUpMinutes\n    // a court is only available if it can accommodate matchUps of duration averageMatchUpMinutes\n    const { availableToScheduleCount } = getCourtsAvailableAtPeriodStart({\n      courts: virtualCourts || [],\n      averageMatchUpMinutes,\n      periodStart,\n      date,\n    });\n\n    // newCourts are courts which have become available for the start of current time period\n    const newCourts =\n      availableToScheduleCount > previousAvailableCourts\n        ? availableToScheduleCount - previousAvailableCourts\n        : 0;\n\n    cumulativePeriods += period ? availableToScheduleCount : 0;\n    const averageCourts = period\n      ? cumulativePeriods / period\n      : availableToScheduleCount;\n\n    // calculatedTotal uses Revised Garman Formula to calculate total number of matchUps\n    // which should be possible given a number of periods and an average number of courts\n    // available over the accumulated time\n    const accumulatedTime = periodLength * averageCourts;\n    const matchesCalculation = accumulatedTime / averageMatchUpMinutes;\n    const calculatedTotal = period\n      ? matchesCalculation * (period - 1) + averageCourts\n      : averageCourts;\n\n    // used to increment cumulativeMatches\n    // difference between current calculation and previous calculation\n    // if no available courts then Zero so that cumulativeMatches does not increase\n    // if available courts but no previously available courts then newCourts;\n    const calculationDifference = !availableToScheduleCount\n      ? 0\n      : (previousAvailableCourts && calculatedTotal - previousCalculation) ||\n        newCourts;\n\n    previousCalculation = calculatedTotal;\n    previousAvailableCourts = availableToScheduleCount;\n    cumulativeMatches += calculationDifference;\n\n    const addToSchedule = ensureInt(cumulativeMatches) - totalMatchUps;\n    totalMatchUps += addToSchedule;\n\n    return {\n      periodStart,\n      add: addToSchedule,\n      availableToScheduleCount,\n      newCourts,\n      totalMatchUps,\n    };\n  });\n\n  const scheduleTimes = timingProfile\n    .reduce((scheduleTimes, profile) => {\n      const stRange: number[] = generateRange(0, profile.add);\n      const newTimes: any[] = stRange.map(() => {\n        const scheduleTime = profile.periodStart;\n        return { scheduleTime };\n      });\n      return scheduleTimes.concat(...newTimes);\n    }, [])\n    .flat();\n\n  return { scheduleTimes, timingProfile, totalMatchUps };\n}\n","import { getDateTimeBoundary } from '../../mutate/matchUps/schedule/schedulers/utils/getTimeBoundary';\nimport { getCourtDateAvailability } from './getCourtDateAvailability';\nimport { generateTimeSlots } from '../../assemblies/generators/scheduling/generateTimeSlots';\nimport {\n  extractTime,\n  minutesDifference,\n  timeToDate,\n} from '../../utilities/dateTime';\n\nexport function getFirstTimeSlotStartTime({\n  averageMinutes,\n  startTime,\n  endTime,\n  courts,\n  date,\n}) {\n  // find the first timeSlot across all courts between startTime and endTime that can accommodate averageMatchUpMinutes\n  startTime =\n    startTime ||\n    getDateTimeBoundary({ courts, scheduleDate: date, startTime: true });\n  endTime =\n    endTime ||\n    getDateTimeBoundary({ courts, scheduleDate: date, endTime: true });\n\n  let firstTimeSlotStartTime;\n  if (startTime && endTime) {\n    const dateStartTime = timeToDate(startTime);\n    const dateEndTime = timeToDate(endTime);\n    for (const court of courts || []) {\n      if (!Array.isArray(court.dateAvailability)) continue;\n      const courtDate = getCourtDateAvailability({ court, date });\n      const timeSlots = generateTimeSlots({ courtDate });\n      timeSlots.forEach((timeSlot) => {\n        const timeSlotStartTime = timeToDate(timeSlot.startTime);\n        const timeSlotEndTime = timeToDate(timeSlot.endTime);\n        if (\n          timeSlotStartTime > dateEndTime ||\n          timeSlotStartTime < dateStartTime\n        )\n          return false;\n        if (timeSlotEndTime < dateStartTime) return false;\n        const timeSlotMinutes = minutesDifference(\n          timeSlotStartTime,\n          timeSlotEndTime\n        );\n        const available = timeSlotMinutes >= averageMinutes;\n        if (available) {\n          const timeString = extractTime(timeSlotStartTime.toISOString());\n          if (!firstTimeSlotStartTime || timeString < firstTimeSlotStartTime) {\n            firstTimeSlotStartTime = timeString;\n          }\n        }\n        return undefined;\n      });\n    }\n  }\n\n  return { firstTimeSlotStartTime };\n}\n","import { getCourtsAvailableAtPeriodStart } from '../../../../query/venues/getCourtsAvailableAtPeriodStart';\nimport { generateTimeSlots } from '../generateTimeSlots';\nimport { courtGenerator } from '../courtGenerator';\nimport { getScheduleTimes } from '../../../../query/venues/getScheduleTimes';\n\nexport const garman = {\n  getCourtsAvailableAtPeriodStart,\n  generateTimeSlots,\n  getScheduleTimes,\n  courtGenerator,\n};\n\nexport default garman;\n","import { generateDrawTypeAndModifyDrawDefinition } from '../../../assemblies/generators/drawDefinitions/generateDrawTypeAndModifyDrawDefinition';\nimport { generateAndPopulatePlayoffStructures } from '../../../assemblies/generators/drawDefinitions/generateAndPopulatePlayoffStructures';\nimport { generateVoluntaryConsolation } from '../../../assemblies/generators/drawDefinitions/drawTypes/generateVoluntaryConsolation';\nimport { generateDrawStructuresAndLinks } from '../../../assemblies/generators/drawDefinitions/generateDrawStructuresAndLinks';\nimport { generateDrawMaticRound } from '../../../assemblies/generators/drawDefinitions/drawMatic/generateDrawMaticRound';\nimport { generateSeedingScaleItems } from '../../../assemblies/generators/drawDefinitions/generateSeedingScaleItems';\nimport { generateQualifyingStructure } from '../../generators/drawDefinitions/drawTypes/generateQualifyingStructure';\nimport { generateDrawDefinition } from '../../../assemblies/generators/drawDefinitions/generateDrawDefinition';\nimport { generateAdHocMatchUps } from '../../../assemblies/generators/drawDefinitions/generateAdHocMatchUps';\nimport { generateFlightProfile } from '../../../assemblies/generators/drawDefinitions/generateFlightProfile';\nimport { generateLineUps } from '../../generators/participants/generateLineUps';\nimport { generateCourts } from '../../generators/venues/generateCourts';\nimport garman from '../../generators/scheduling/garman/garman';\n\nexport const generationGovernor = {\n  garman,\n  generateAdHocMatchUps,\n  generateAndPopulatePlayoffStructures,\n  generateCourts,\n  generateDrawDefinition,\n  generateDrawMaticRound,\n  generateDrawStructuresAndLinks,\n  generateDrawTypeAndModifyDrawDefinition,\n  generateFlightProfile,\n  generateLineUps,\n  generateQualifyingStructure,\n  generateSeedingScaleItems,\n  generateVoluntaryConsolation,\n};\n\nexport default generationGovernor;\n","import { generateDateRange, isTimeString, isValidDateString } from '../../../utilities/dateTime';\nimport { checkRequiredParameters } from '../../../parameters/checkRequiredParameters';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { generateRange } from '../../../utilities/arrays';\nimport { isString } from '../../../utilities/objects';\nimport { isNumeric } from '../../../utilities/math';\nimport { UUID } from '../../../utilities/UUID';\n\nimport { MISSING_VALUE } from '../../../constants/errorConditionConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { Court, Tournament } from '../../../types/tournamentTypes';\nimport { VALIDATE } from '../../../constants/attributeConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\ntype GenerateCourtsArgs = {\n  tournamentRecord?: Tournament;\n  courtNames?: string[];\n  namePrefix?: string;\n  startTime?: string;\n  endTime?: string;\n  idPrefix?: string;\n  uuids?: string[];\n  dates?: string[];\n  count: number;\n};\n\ntype GenerateCourtsResult = {\n  courts?: Court[];\n};\n\nexport function generateCourts(params: GenerateCourtsArgs): ResultType & GenerateCourtsResult {\n  if (!params) return { error: MISSING_VALUE };\n\n  const paramCheck = checkRequiredParameters(params, [\n    { dates: false, [VALIDATE]: (value) => Array.isArray(value) && value.every(isValidDateString) },\n    { uuids: false, [VALIDATE]: (value) => Array.isArray(value) && value.every(isString) },\n    { startTime: false, endTime: false, [VALIDATE]: isTimeString },\n    { idPrefix: false, namePrefix: false, [VALIDATE]: isString },\n    { count: true, [VALIDATE]: isNumeric },\n  ]);\n  if (paramCheck.error) return paramCheck;\n\n  const { startDate, endDate } = params.tournamentRecord ?? {};\n  const dates = params.dates || (startDate && endDate && generateDateRange(startDate, endDate)) || [];\n\n  const courts: Court[] = generateRange(1, params.count + 1).map((courtNumber) =>\n    definedAttributes({\n      courtId: params.uuids?.pop() ?? (params.idPrefix && `${params.idPrefix}-${courtNumber}`) ?? UUID(),\n      courtName: params.courtNames?.pop() ?? (params.namePrefix && `${params.namePrefix} ${courtNumber}`),\n      dateAvailability: dates.map((date) => ({\n        startTime: params.startTime ?? '08:00',\n        endTime: params.endTime ?? '20:00',\n        date,\n      })),\n    }),\n  );\n\n  return { ...SUCCESS, courts };\n}\n","import { attachFlightProfile as attachProfile } from '../../../mutate/events/attachFlightProfile';\nimport { getScaledEntries } from '../../../query/event/getScaledEntries';\nimport { getParticipantId } from '../../../global/functions/extractors';\nimport { getFlightProfile } from '../../../query/event/getFlightProfile';\nimport { getDevContext } from '../../../global/state/globalState';\nimport { UUID } from '../../../utilities/UUID';\nimport {\n  chunkArray,\n  chunkByNth,\n  generateRange,\n  shuffleArray,\n} from '../../../utilities/arrays';\n\nimport { DIRECT_ENTRY_STATUSES } from '../../../constants/entryStatusConstants';\nimport { FlightProfile, ScaleAttributes } from '../../../types/factoryTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  EXISTING_PROFILE,\n  ErrorType,\n  MISSING_EVENT,\n} from '../../../constants/errorConditionConstants';\nimport {\n  SPLIT_SHUTTLE,\n  SPLIT_WATERFALL,\n} from '../../../constants/flightConstants';\nimport {\n  Entry,\n  Event,\n  StageTypeUnion,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\n/**\n * @param {object} event - automatically retrieved by tournamentEngine given eventId\n * @param {string} eventId - unique identifier for event\n * @param {string} splitMethod - one of the supported methods for splitting entries\n * @param {object} scaleAttributes - { scaleName, scaleType, eventType }\n * @param {object[]} scaledEntries - pre-sorted entries\n * @param {function} scaleSortMethod - ignored if scaledEntries present\n * @param {boolean} sortDescending - ignored if scaledEntries present\n * @param {number} flightsCount - number of flights to create from existing entries\n * @param {object[]} flightValues - optional - [{ flightNumber: 1, matchUpValue: 1, flightNumber: 2, matchUpValue: 2 }]\n * @param {string[]} drawNames - array of names to be used when generating flights\n * @param {string} drawNameRoot - root word for generating flight names\n * @param {boolean} deleteExisting - if flightProfile exists then delete\n * @param {string} stage - OPTIONAL - only consider event entries matching stage\n */\n\ntype GenerateFlightProfileArgs = {\n  scaleAttributes: ScaleAttributes;\n  attachFlightProfile?: boolean;\n  tournamentRecord: Tournament;\n  deleteExisting?: boolean;\n  sortDescending?: boolean;\n  drawNameRoot?: string;\n  scaleSortMethod?: any;\n  stage?: StageTypeUnion;\n  drawNames?: string[];\n  scaledEntries?: any;\n  flightsCount: number;\n  splitMethod: string;\n  uuids?: string[];\n  event: Event;\n};\n\nexport function generateFlightProfile(params: GenerateFlightProfileArgs): {\n  flightProfile?: FlightProfile;\n  splitEntries?: Entry[][];\n  success?: boolean;\n  error?: ErrorType;\n} {\n  const {\n    drawNameRoot = 'Flight',\n    attachFlightProfile,\n    tournamentRecord,\n    scaleAttributes,\n    scaleSortMethod,\n    deleteExisting,\n    sortDescending,\n    drawNames = [],\n    flightsCount,\n    splitMethod,\n    uuids = [],\n    event,\n    stage,\n  } = params;\n  if (!event) return { error: MISSING_EVENT };\n  const eventEntries = event.entries ?? [];\n\n  const { flightProfile } = getFlightProfile({ event });\n  if (flightProfile && attachFlightProfile && !deleteExisting) {\n    return { error: EXISTING_PROFILE };\n  }\n\n  const scaledEntries =\n    params.scaledEntries ??\n    getScaledEntries({\n      tournamentRecord,\n      scaleAttributes,\n      scaleSortMethod,\n      sortDescending,\n      event,\n      stage,\n    }).scaledEntries;\n\n  const scaledEntryParticipantIds = scaledEntries.map(getParticipantId);\n  const unscaledEntries = shuffleArray(\n    eventEntries\n      .filter(\n        ({ participantId }) =>\n          !scaledEntryParticipantIds.includes(participantId)\n      )\n      .filter(\n        (entry: Entry) =>\n          (!stage || !entry.entryStage || entry.entryStage === stage) &&\n          (!entry.entryStatus || // absence of entryStatus is equivalent to DIRECT_ACCEPTANCE\n            DIRECT_ENTRY_STATUSES.includes(entry.entryStatus))\n      )\n  );\n\n  const flightEntries = scaledEntries.concat(...unscaledEntries);\n  const entriesCount = flightEntries.length;\n\n  // default is SPLIT_LEVEL_BASED - Evenly chunk sorted entries\n  const chunkSize = Math.ceil(entriesCount / flightsCount);\n  let splitEntries = chunkArray(flightEntries, chunkSize);\n\n  if (splitMethod === SPLIT_WATERFALL) {\n    // e.g. 1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4\n    splitEntries = chunkByNth(flightEntries, flightsCount);\n  } else if (splitMethod === SPLIT_SHUTTLE) {\n    // e.g. 1,2,3,4,4,3,2,1,1,2,3,4,4,3,2,1\n    splitEntries = chunkByNth(flightEntries, flightsCount, true);\n  }\n\n  function getDrawEntries(entriesChunk) {\n    return (entriesChunk || [])\n      .map(({ participantId, scaleValue }) => {\n        const entry = eventEntries.find(\n          (entry: Entry) => entry.participantId === participantId\n        );\n        if (entry?.scaleValue && scaleValue) entry.scaleValue = scaleValue;\n        return entry;\n      })\n      .sort((a, b) => a.scaleValue - b.scaleValue)\n      .map((entry, i) => {\n        if (entry.scaleValue) entry.seedNumber = i + 1;\n        return entry;\n      });\n  }\n\n  const flights = generateRange(0, flightsCount).map((index) => {\n    const flightNumber = index + 1;\n    return {\n      flightNumber,\n      drawId: uuids?.pop() ?? UUID(),\n      drawEntries: getDrawEntries(splitEntries[index]),\n      drawName:\n        (drawNames?.length && drawNames[index]) ||\n        `${drawNameRoot} ${flightNumber}`,\n    };\n  });\n\n  const updatedFlightProfile = {\n    scaleAttributes,\n    splitMethod,\n    flights,\n  };\n\n  if (attachFlightProfile) {\n    const result = attachProfile({\n      flightProfile: updatedFlightProfile,\n      deleteExisting,\n      event,\n    });\n    return {\n      splitEntries: (getDevContext() && splitEntries) || undefined,\n      ...result,\n    };\n  } else {\n    return { flightProfile: updatedFlightProfile, ...SUCCESS };\n  }\n}\n","import { resolveTieFormat } from '../../../../query/hierarchical/tieFormats/resolveTieFormat';\nimport { getAllStructureMatchUps } from '../../../../query/matchUps/getAllStructureMatchUps';\nimport { automatedPositioning } from '../../../../mutate/drawDefinitions/automatedPositioning';\nimport { copyTieFormat } from '../../../../query/hierarchical/tieFormats/copyTieFormat';\nimport { modifyDrawNotice } from '../../../../mutate/notifications/drawNotifications';\nimport { getStageEntries } from '../../../../query/drawDefinition/stageGetter';\nimport { validateTieFormat } from '../../../../validators/validateTieFormat';\nimport { definedAttributes } from '../../../../utilities/definedAttributes';\nimport { getDrawStructures } from '../../../../acquire/findStructure';\nimport { makeDeepCopy } from '../../../../utilities/makeDeepCopy';\nimport { constantToString } from '../../../../utilities/strings';\nimport { nextPowerOf2 } from '../../../../utilities/math';\nimport { generateTieMatchUps } from '../tieMatchUps';\nimport { getGenerators } from '../getGenerators';\n\nimport { PlayoffAttributes, SeedingProfile } from '../../../../types/factoryTypes';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport { SINGLES } from '../../../../constants/matchUpTypes';\nimport {\n  EXISTING_STRUCTURE,\n  ErrorType,\n  INVALID_DRAW_SIZE,\n  MISSING_DRAW_DEFINITION,\n  STAGE_SEQUENCE_LIMIT,\n  UNRECOGNIZED_DRAW_TYPE,\n} from '../../../../constants/errorConditionConstants';\nimport {\n  DOUBLE_ELIMINATION,\n  FEED_IN,\n  ROUND_ROBIN,\n  ROUND_ROBIN_WITH_PLAYOFF,\n  SINGLE_ELIMINATION,\n  VOLUNTARY_CONSOLATION,\n} from '../../../../constants/drawDefinitionConstants';\nimport {\n  DrawDefinition,\n  DrawLink,\n  Event,\n  Structure,\n  TieFormat,\n  Tournament,\n  EventTypeUnion,\n} from '../../../../types/tournamentTypes';\n\ntype GenerateVoluntaryConsolationArgs = {\n  playoffAttributes?: PlayoffAttributes;\n  tournamentRecord: Tournament;\n  seedingProfile?: SeedingProfile;\n  drawDefinition: DrawDefinition;\n  matchUpType?: EventTypeUnion;\n  attachConsolation?: boolean;\n  applyPositioning?: boolean;\n  staggeredEntry?: boolean;\n  structureName?: string;\n  tieFormat?: TieFormat;\n  automated?: boolean;\n  placeByes?: boolean;\n  drawType?: string;\n  isMock?: boolean;\n  event?: Event;\n};\nexport function generateVoluntaryConsolation(params: GenerateVoluntaryConsolationArgs): {\n  structures?: Structure[];\n  links?: DrawLink[];\n  success?: boolean;\n  error?: ErrorType;\n} {\n  const {\n    drawType = SINGLE_ELIMINATION,\n    attachConsolation = true,\n    applyPositioning = true,\n    tournamentRecord,\n    staggeredEntry, // optional - specifies main structure FEED_IN for drawTypes CURTIS_CONSOLATION, FEED_IN_CHAMPIONSHIPS, FMLC\n    automated,\n    placeByes,\n    isMock,\n    event,\n  } = params;\n\n  let drawDefinition = params?.drawDefinition;\n\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const stage = VOLUNTARY_CONSOLATION;\n  const entries = getStageEntries({\n    stageSequence: 1,\n    drawDefinition,\n    stage,\n  });\n  const drawSize = ![ROUND_ROBIN, DOUBLE_ELIMINATION, ROUND_ROBIN_WITH_PLAYOFF].includes(drawType)\n    ? nextPowerOf2(entries.length)\n    : entries.length;\n\n  if (\n    (!staggeredEntry && drawType === FEED_IN && entries.length < 2) ||\n    (drawType === ROUND_ROBIN && entries.length < 3)\n  )\n    return { error: INVALID_DRAW_SIZE };\n\n  let { tieFormat, matchUpType } = params;\n  if (tieFormat) {\n    const result = validateTieFormat({ tieFormat });\n    if (result.error) return result;\n  }\n\n  tieFormat = copyTieFormat(tieFormat ?? resolveTieFormat({ drawDefinition })?.tieFormat);\n  matchUpType = matchUpType ?? drawDefinition.matchUpType ?? SINGLES;\n\n  const { structures: stageStructures } = getDrawStructures({\n    stageSequence: 1,\n    drawDefinition,\n    stage,\n  });\n\n  // invalid to have more than one existing VOLUNTARY_CONSOLATION structure\n  const structureCount = stageStructures.length;\n  if (structureCount > 1) return { error: STAGE_SEQUENCE_LIMIT };\n\n  // invalid to already have matchUps generated for any existing structure\n  if (stageStructures?.[0]?.matchUps?.length) return { error: EXISTING_STRUCTURE };\n  const structureId = stageStructures?.[0]?.structureId;\n\n  Object.assign(\n    params,\n    definedAttributes({\n      structureName: params.structureName ?? constantToString(VOLUNTARY_CONSOLATION),\n      structureId,\n      matchUpType,\n      tieFormat,\n      drawSize,\n      stage,\n    }),\n  );\n\n  const result = getGenerators(params);\n  if (result.error) return result;\n\n  const generator = result.generators[drawType];\n  if (!generator) return { error: UNRECOGNIZED_DRAW_TYPE };\n\n  const generatorResult = generator?.();\n  if (generatorResult.error) return generatorResult;\n\n  const { structures, links } = generatorResult;\n\n  const matchUps = structures.map((structure) => getAllStructureMatchUps({ structure }).matchUps).flat();\n\n  if (tieFormat) {\n    matchUps.forEach((matchUp) => {\n      const { tieMatchUps } = generateTieMatchUps({ matchUp, tieFormat, isMock });\n      Object.assign(matchUp, { tieMatchUps, matchUpType });\n    });\n  }\n\n  if (!applyPositioning || !attachConsolation) {\n    drawDefinition = makeDeepCopy(drawDefinition, false, true);\n  }\n\n  if (!drawDefinition.links) drawDefinition.links = [];\n  if (links.length) drawDefinition.links.push(...links);\n  const generatedStructureIds = structures.map(({ structureId }) => structureId);\n  if (!drawDefinition.structures) drawDefinition.structures = [];\n  const existingStructureIds = drawDefinition.structures.map(({ structureId }) => structureId);\n\n  // replace any existing structures with newly generated structures\n  // this is done because it is possible that a consolation structure exists without matchUps\n  drawDefinition.structures = drawDefinition.structures.map((structure) => {\n    return generatedStructureIds.includes(structure.structureId)\n      ? structures.find(({ structureId }) => structureId === structure.structureId)\n      : structure;\n  });\n\n  const newStructures = structures.filter(({ structureId }) => !existingStructureIds.includes(structureId));\n  if (newStructures.length) drawDefinition.structures.push(...newStructures);\n\n  if (automated) {\n    automatedPositioning({\n      seedingProfile: params.seedingProfile,\n      applyPositioning,\n      tournamentRecord,\n      drawDefinition,\n      structureId,\n      placeByes,\n      drawSize,\n      event,\n    });\n  }\n\n  if (attachConsolation) modifyDrawNotice({ drawDefinition });\n\n  return { links, structures, ...SUCCESS };\n}\n","import statesData from '../../../fixtures/data/territories.json';\nimport citiesData from '../../../fixtures/data/cities.json';\nimport { randomInt } from '../../../utilities/math';\nimport {\n  generateRange,\n  randomMember,\n  shuffleArray,\n} from '../../../utilities/arrays';\n\nexport function address() {\n  return {\n    city: cityMocks().cities[0],\n    state: stateMocks().states[0],\n    postalCode: postalCodeMocks().postalCodes[0],\n  };\n}\n\nexport function cityMocks({ count = 1, participantsCount = 32 } = {}) {\n  const shuffledCities = shuffleArray(citiesData);\n  const candidateCities = shuffledCities.slice(0, count);\n\n  // the following ensures that all of the generated items are used at least once\n  const cities = generateRange(0, participantsCount).map((i) =>\n    i < Math.min(count, shuffledCities.length)\n      ? candidateCities[i]\n      : randomMember(candidateCities)\n  );\n  return { cities };\n}\n\nexport function stateMocks({ count = 1, participantsCount = 32 } = {}) {\n  const shuffledStates = shuffleArray(statesData);\n  const candidateStates = shuffledStates\n    .slice(0, count)\n    .map((state) => Object.keys(state))\n    .flat();\n\n  // the following ensures that all of the generated items are used at least once\n  const states = generateRange(0, participantsCount).map((i) =>\n    i < Math.min(count, shuffledStates.length)\n      ? candidateStates[i]\n      : randomMember(candidateStates)\n  );\n  return { states };\n}\n\nexport function postalCodeMocks({ count = 1, participantsCount = 32 } = {}) {\n  const candidatePostalCodes = generateRange(0, count).map(() =>\n    generateRange(0, 5)\n      .map(() => randomInt(0, 9))\n      .join('')\n  );\n\n  // the following ensures that all of the generated items are used at least once\n  const postalCodes = generateRange(0, participantsCount).map((i) =>\n    i < count ? candidatePostalCodes[i] : randomMember(candidatePostalCodes)\n  );\n  return { postalCodes };\n}\n","import { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { countries } from '../../../fixtures/countryData';\nimport namesData from '../../../fixtures/data/names.json';\nimport {\n  generateRange,\n  randomMember,\n  randomPop,\n} from '../../../utilities/arrays';\n\nimport { FEMALE, MALE } from '../../../constants/genderConstants';\nimport {\n  ErrorType,\n  INVALID_VALUES,\n} from '../../../constants/errorConditionConstants';\n\nexport function generatePersonData(params?): {\n  personData?: any[];\n  error?: ErrorType;\n} {\n  const { count = 100, sex } = params || {};\n  if (!count || (sex && ![MALE, FEMALE].includes(sex)))\n    return { personData: [], error: INVALID_VALUES };\n\n  // generate 30% more than count to account for duplicated firstName/lastName\n  const buffer = Math.ceil(count * 1.3);\n\n  const { lastNames, firstFemale, firstMale } = namesData;\n  const ISOs = countries.map(({ iso }) => iso).filter(Boolean);\n\n  const lastNameDupeCount = Math.ceil(buffer / lastNames.length);\n  const femaleDupeCount = Math.ceil(buffer / firstFemale.length);\n  const maleDupeCount = Math.ceil(buffer / firstMale.length);\n\n  const lastNameDupes = generateRange(0, lastNameDupeCount).flatMap(() => {\n    const n = makeDeepCopy(lastNames, false, true); // internal use\n    return generateRange(0, lastNames.length).map(() => randomPop(n));\n  });\n  const femaleDupes = generateRange(0, femaleDupeCount).flatMap(() => {\n    const n = makeDeepCopy(firstFemale, false, true); // internal use\n    return generateRange(0, firstFemale.length).map(() => randomPop(n));\n  });\n  const maleDupes = generateRange(0, maleDupeCount).flatMap(() => {\n    const n = makeDeepCopy(firstMale, false, true); // internal use\n    return generateRange(0, firstMale.length).map(() => randomPop(n));\n  });\n\n  const candidates = {};\n  for (let i = 0; i < buffer; i++) {\n    const lastName = lastNameDupes.pop();\n    const personSex = sex || randomMember([MALE, FEMALE]);\n    const firstName = personSex === MALE ? maleDupes.pop() : femaleDupes.pop();\n    const nationalityCode = randomMember(ISOs);\n    candidates[`${firstName}${lastName}`] = {\n      nationalityCode,\n      sex: personSex,\n      firstName,\n      lastName,\n    };\n  }\n\n  const personData = Object.values(candidates).slice(0, count);\n\n  return { personData };\n}\n","import { getCategoryAgeDetails } from '../../../query/event/getCategoryAgeDetails';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { generatePersonData } from './generatePersonData';\nimport { dateFromDay } from '../../../utilities/dateTime';\nimport { countries } from '../../../fixtures/countryData';\nimport { ensureInt } from '../../../utilities/ensureInt';\nimport {\n  generateRange,\n  randomMember,\n  randomPop,\n  shuffleArray,\n} from '../../../utilities/arrays';\n\nimport { INVALID_VALUES } from '../../../constants/errorConditionConstants';\nimport { MALE, FEMALE } from '../../../constants/genderConstants';\n\n/**\n * @param {integer} count - number of persons to generate\n * @param {string} sex - optional - MALE or FEMALE\n * @param {object[]} personData - optional array of persons to seed generator [{ firstName, lastName, sex, nationalityCode }]\n * @param {object} personExtensions - optional array of extentsions to apply to all persons\n */\nexport function generatePersons(params?) {\n  let count = params?.count || 1;\n  const {\n    personExtensions,\n    consideredDate,\n    isMock = true,\n    gendersCount,\n    personData,\n    category,\n    sex,\n  } = params || {};\n  if (isNaN(count)) return { error: INVALID_VALUES };\n\n  const maleCount = gendersCount?.[MALE] || (sex === MALE && count) || 0;\n  const femaleCount = gendersCount?.[FEMALE] || (sex === FEMALE && count) || 0;\n  count = Math.max(count, maleCount + femaleCount);\n  const defaultCount = count - (maleCount + femaleCount);\n\n  const defaultMalePersonData =\n    (maleCount &&\n      generatePersonData({\n        count: maleCount,\n        sex: MALE,\n      }).personData) ||\n    [];\n\n  const defaultFemalePersonData =\n    (femaleCount &&\n      generatePersonData({\n        count: femaleCount,\n        sex: FEMALE,\n      }).personData) ||\n    [];\n\n  const defaultPersonData = [\n    ...defaultMalePersonData,\n    ...defaultFemalePersonData,\n    ...((defaultCount &&\n      generatePersonData({\n        count: defaultCount,\n      }).personData) ||\n      []),\n  ];\n\n  let validPersonData = defaultPersonData.filter(\n    (person) => !sex || (maleCount && femaleCount) || person.sex === sex\n  );\n\n  const nationalityCodes: string[] = [];\n\n  if (Array.isArray(personData)) {\n    const validatedPersonData = personData.filter((person) => {\n      if (typeof person.firstName !== 'string') return false;\n      if (typeof person.lastName !== 'string') return false;\n      if (person.sex && ![MALE, FEMALE].includes(person.sex)) return false;\n      if (\n        person.nationalityCode &&\n        (typeof person.nationalityCode !== 'string' ||\n          person.nationalityCode.length > 3 ||\n          !countries.find(({ iso, ioc }) =>\n            [iso, ioc].includes(person.nationalityCode)\n          ))\n      )\n        return false;\n\n      if (person.nationalityCode) nationalityCodes.push(person.nationalityCode);\n\n      return true;\n    });\n\n    if (validatedPersonData.length) {\n      validPersonData = validatedPersonData;\n    } else {\n      return { error: INVALID_VALUES };\n    }\n  }\n\n  const shuffledPersons = personData\n    ? validPersonData\n    : shuffleArray(validPersonData);\n\n  if (shuffledPersons.length < count) {\n    const {\n      maleFirstNames,\n      maleLastNames,\n      femaleFirstNames,\n      femaleLastNames,\n      nationalityCodes,\n    } = defaultPersonData.reduce(\n      (a, person) => {\n        const { firstName, lastName, nationalityCode } = person;\n        if (person.sex === MALE) {\n          if (!a.maleFirstNames.includes(firstName))\n            a.maleFirstNames.push(firstName);\n          if (!a.maleLastNames.includes(lastName))\n            a.maleLastNames.push(lastName);\n        } else {\n          if (!a.femaleFirstNames.includes(firstName))\n            a.femaleFirstNames.push(firstName);\n          if (!a.femaleLastNames.includes(lastName))\n            a.femaleLastNames.push(lastName);\n        }\n        if (!a.nationalityCodes.includes(nationalityCode))\n          a.nationalityCodes.push(nationalityCode);\n        return a;\n      },\n      {\n        maleFirstNames: [],\n        maleLastNames: [],\n        femaleFirstNames: [],\n        femaleLastNames: [],\n        nationalityCodes: [],\n      }\n    );\n\n    generateRange(0, count - shuffledPersons.length).forEach(() => {\n      const personSex = sex || randomMember([MALE, FEMALE]);\n      const nationalityCode = randomMember(nationalityCodes);\n      const firstName =\n        personSex === MALE\n          ? randomMember(maleFirstNames)\n          : randomMember(femaleFirstNames);\n      const lastName =\n        personSex === MALE\n          ? randomMember(maleLastNames)\n          : randomMember(femaleLastNames);\n      const person = {\n        firstName,\n        lastName,\n        sex: personSex,\n        nationalityCode,\n      };\n      shuffledPersons.push(person);\n    });\n  }\n\n  const { ageMinDate, ageMaxDate } = getCategoryAgeDetails({\n    consideredDate,\n    category,\n  });\n\n  const rangeStart =\n    ensureInt(ageMinDate?.slice(0, 4) || 0) ||\n    ensureInt(ageMaxDate?.slice(0, 4) || 0) - 3;\n\n  const rangeEnd =\n    ensureInt(ageMaxDate?.slice(0, 4) || 0) ||\n    ensureInt(ageMinDate?.slice(0, 4) || 0) + 3;\n\n  const yearRange = (ageMinDate || ageMaxDate) && [rangeStart, rangeEnd];\n\n  const persons = shuffledPersons.slice(0, count).map((person, i) => {\n    const [start, end] = yearRange || [];\n    const birthYear = yearRange && randomPop(generateRange(start, end));\n    const birthDay = randomPop(generateRange(0, 365));\n    const birthDate = birthYear && dateFromDay(birthYear, birthDay);\n\n    return Object.assign(\n      definedAttributes({\n        extensions: personExtensions || [{ name: 'regionCode', value: i + 1 }],\n        birthDate,\n        isMock,\n      }),\n      person\n    );\n  });\n\n  return {\n    persons: (persons.length && persons) || shuffledPersons[0],\n    nationalityCodes,\n  };\n}\n","export function generateAddress(addressAttributes) {\n  const { cities, states, postalCodes, nationalityCode, participantIndex } =\n    addressAttributes;\n  return {\n    postalCode: postalCodes?.[participantIndex],\n    state: states?.[participantIndex],\n    city: cities?.[participantIndex],\n    countryCode: nationalityCode,\n  };\n}\n","import { generateRange, shuffleArray } from '../../../utilities/arrays';\nimport namesData from '../../../fixtures/data/teams.json';\n\nexport function nameMocks({ nameRoot = 'TEAM', count = 1 } = {}) {\n  const shuffledTeamNames = shuffleArray(namesData);\n  const names = shuffledTeamNames.slice(0, count);\n  if (names.length < count) {\n    generateRange(0, count - names.length).forEach((i) =>\n      names.push(`${nameRoot} ${i + 1}`)\n    );\n  }\n  return { names };\n}\n","import { ensureInt } from '../../utilities/ensureInt';\n\ntype SetComplementArgs = {\n  lowValue?: string | number;\n  tiebreakAt?: number;\n  isSide1?: boolean;\n  NoAD?: boolean;\n  setTo: number;\n};\n\nexport const getSetComplement = (\n  params: SetComplementArgs\n): number[] | false => {\n  const { isSide1, lowValue, setTo, tiebreakAt, NoAD } = params;\n  if (lowValue === undefined) return false;\n  let valueAsNumber = ensureInt(lowValue);\n\n  // Not necessary?\n  if (valueAsNumber?.toString().length > 2) {\n    valueAsNumber = parseInt(valueAsNumber.toString().slice(0, 2));\n  }\n\n  if (tiebreakAt && tiebreakAt < setTo && valueAsNumber > tiebreakAt) {\n    valueAsNumber = tiebreakAt;\n  }\n\n  let calculatedValue;\n  if (NoAD && !tiebreakAt) {\n    calculatedValue = valueAsNumber < setTo ? setTo : setTo - 1;\n  } else {\n    calculatedValue =\n      (valueAsNumber + 1 < setTo && setTo) ||\n      (tiebreakAt &&\n        tiebreakAt < setTo &&\n        valueAsNumber === tiebreakAt &&\n        setTo) ||\n      (!tiebreakAt && valueAsNumber + 2) ||\n      setTo + 1;\n  }\n\n  const side1Result = isSide1 ? valueAsNumber : calculatedValue;\n  const side2Result = !isSide1 ? valueAsNumber : calculatedValue;\n\n  return [side1Result, side2Result];\n};\n\ntype TiebreakComplementArgs = {\n  lowValue?: number | string;\n  tiebreakNoAd?: boolean;\n  tiebreakTo: number;\n  isSide1?: boolean;\n};\n\nexport const getTiebreakComplement = (\n  params: TiebreakComplementArgs\n): number[] | false => {\n  const { isSide1, lowValue, tiebreakTo, tiebreakNoAd } = params;\n  if (lowValue === undefined) return false;\n  let valueAsNumber =\n    typeof lowValue === 'string' ? parseInt(lowValue) : lowValue;\n\n  // Not necessary?\n  // do not accept low values greater than two digits;\n  if (valueAsNumber?.toString().length > 2) {\n    valueAsNumber = parseInt(valueAsNumber.toString().slice(0, 2));\n  }\n\n  // If NOAD low lowValue cannot be greater than tiebreakTo - 1\n  if (tiebreakNoAd && valueAsNumber > tiebreakTo - 1) {\n    valueAsNumber = tiebreakTo - 1;\n  }\n\n  const highValue = getHighTiebreakValue({\n    lowValue: valueAsNumber,\n    NoAD: tiebreakNoAd,\n    tiebreakTo,\n  });\n  const side1Result = isSide1 ? valueAsNumber : highValue;\n  const side2Result = !isSide1 ? valueAsNumber : highValue;\n  return [side1Result, side2Result];\n};\n\ntype HighTiebreakValueArgs = {\n  tiebreakTo: number;\n  lowValue: number;\n  NoAD?: boolean;\n};\n\nfunction getHighTiebreakValue(params: HighTiebreakValueArgs): number {\n  const { lowValue, NoAD, tiebreakTo } = params;\n  const winBy = NoAD ? 1 : 2;\n  if (lowValue + 1 >= tiebreakTo) {\n    return lowValue + winBy;\n  }\n  return tiebreakTo;\n}\n","import { getTiebreakComplement } from '../query/matchUp/getComplement';\n\ntype ParseScoreArgs = {\n  scoreString: string;\n  tiebreakTo?: number;\n};\n\ntype ParsedSetString = {\n  winningSide: number | undefined;\n  side1TiebreakScore?: number;\n  side2TiebreakScore?: number;\n  side1Score?: number;\n  side2Score?: number;\n  setNumber: number;\n};\n\ntype ParseSetArgs = {\n  setNumber: number;\n  set: string;\n};\n\n// utility function just to allow testing with string score entry\nexport function parseScoreString({\n  tiebreakTo = 7,\n  scoreString,\n}: ParseScoreArgs) {\n  return scoreString\n    .split(' ')\n    .filter(Boolean)\n    .map((set, index) => parseSet({ set, setNumber: index + 1 }));\n\n  function parseSet({ set, setNumber }: ParseSetArgs): ParsedSetString {\n    const matchTiebreak =\n      set?.startsWith('[') &&\n      set\n        .split('[')[1]\n        .split(']')[0]\n        .split('-')\n        .map((sideScore) => parseInt(sideScore));\n    const setString =\n      (set.includes('(') && set.split('(')[0]) ||\n      (set.includes('[') && set.split('[')[0]) ||\n      set;\n    const setScores =\n      !matchTiebreak &&\n      setString.split('-').map((sideScore) => parseInt(sideScore));\n\n    const winningSide = matchTiebreak\n      ? (matchTiebreak[0] > matchTiebreak[1] && 1) ||\n        (matchTiebreak[0] < matchTiebreak[1] && 2) ||\n        undefined\n      : (setScores[0] > setScores[1] && 1) ||\n        (setScores[0] < setScores[1] && 2) ||\n        undefined;\n\n    const setTiebreakLowScore = set.includes('(')\n      ? set.split('(')[1].split(')')[0]\n      : undefined;\n\n    const side1TiebreakPerspective =\n      setTiebreakLowScore &&\n      getTiebreakComplement({\n        lowValue: setTiebreakLowScore,\n        isSide1: winningSide === 2,\n        tiebreakTo,\n      });\n\n    const setTiebreak = side1TiebreakPerspective ?? [];\n\n    const [side1Score, side2Score] = setScores || [];\n    const [side1TiebreakScore, side2TiebreakScore] =\n      matchTiebreak || setTiebreak || [];\n\n    return {\n      side1Score,\n      side2Score,\n      side1TiebreakScore,\n      side2TiebreakScore,\n      winningSide,\n      setNumber,\n    };\n  }\n}\n","import { generateScoreString } from '../matchUps/generateScoreString';\nimport { toBePlayed } from '../../../fixtures/scoring/outcomes/toBePlayed';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { parseScoreString } from '../../../utilities/parseScoreString';\n\nimport { INVALID_VALUES } from '../../../constants/errorConditionConstants';\n\n/**\n *\n * Generates TODS score object from parseable score string\n *\n * @param {string} scoreString - parseable score string, e.g. '6-0 6-0'\n * @param {number} winningSide - optional - valid values are [1, 2, undefined]\n * @param {string=} matchUpFormat\n * @param {string=} matchUpStatus\n *\n */\nexport function generateOutcomeFromScoreString(params) {\n  const { matchUpFormat, matchUpStatus, winningSide, scoreString } = params;\n  if (!scoreString)\n    return {\n      outcome: {\n        ...toBePlayed,\n        winningSide,\n        matchUpStatus,\n      },\n    };\n  if (winningSide && ![1, 2, undefined].includes(winningSide))\n    return { error: INVALID_VALUES, winningSide };\n\n  const neutralParsedSets = scoreString && parseScoreString({ scoreString });\n  const score: any = {};\n  const winningScoreString = generateScoreString({\n    sets: neutralParsedSets,\n    matchUpFormat,\n  });\n  const losingScoreString = generateScoreString({\n    sets: neutralParsedSets,\n    reversed: true,\n    matchUpFormat,\n  });\n  if (winningSide === 2) {\n    score.scoreStringSide1 = losingScoreString;\n    score.scoreStringSide2 = winningScoreString;\n  } else {\n    score.scoreStringSide1 = winningScoreString;\n    score.scoreStringSide2 = losingScoreString;\n  }\n  score.sets = parseScoreString({ scoreString: score.scoreStringSide1 });\n\n  return definedAttributes({\n    outcome: {\n      matchUpStatus,\n      winningSide,\n      score,\n    },\n  });\n}\n","import { checkRequiredParameters } from '../../parameters/checkRequiredParameters';\nimport { findExtension } from '../../acquire/findExtension';\n\nimport { MISSING_TOURNAMENT_RECORDS } from '../../constants/errorConditionConstants';\nimport { POLICY_TYPE_SCHEDULING } from '../../constants/policyConstants';\nimport { TOURNAMENT_RECORD } from '../../constants/attributeConstants';\nimport { SCHEDULE_LIMITS } from '../../constants/extensionConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { Tournament } from '../../types/tournamentTypes';\nimport { findPolicy } from '../../acquire/findPolicy';\n\ntype GetMatchUpDailyLimitsArgs = {\n  tournamentRecords: { [key: string]: Tournament };\n  tournamentId?: string;\n};\nexport function getMatchUpDailyLimits({\n  tournamentRecords,\n  tournamentId,\n}: GetMatchUpDailyLimitsArgs): ResultType & {\n  matchUpDailyLimits?: any;\n} {\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const tournamentIds = Object.keys(tournamentRecords).filter(\n    (currentTournamentId) =>\n      !tournamentId || currentTournamentId === tournamentId\n  );\n\n  let dailyLimits;\n  tournamentIds.forEach((tournamentId) => {\n    const tournamentRecord = tournamentRecords[tournamentId];\n\n    const { matchUpDailyLimits } = getDailyLimit({\n      tournamentRecord,\n    });\n    dailyLimits = matchUpDailyLimits;\n  });\n\n  return { matchUpDailyLimits: dailyLimits };\n}\n\nexport function getDailyLimit(params): ResultType & {\n  matchUpDailyLimits?: number;\n} {\n  const paramCheck = checkRequiredParameters(params, [\n    { [TOURNAMENT_RECORD]: true },\n  ]);\n  if (paramCheck.error) return paramCheck;\n\n  const { tournamentRecord } = params;\n  const { policy } = findPolicy({\n    policyType: POLICY_TYPE_SCHEDULING,\n    tournamentRecord,\n  });\n\n  const { extension } = findExtension({\n    element: tournamentRecord,\n    name: SCHEDULE_LIMITS,\n  });\n\n  const tournamentDailyLimits = extension?.value?.dailyLimits;\n  const policyDailyLimits = policy?.defaultDailyLimits;\n\n  return { matchUpDailyLimits: tournamentDailyLimits || policyDailyLimits };\n}\n","export function checkDependenciesScheduled({\n  matchUpScheduleTimes,\n  matchUpDependencies,\n  allDateMatchUpIds,\n  matchUp,\n}) {\n  // only those dependencies that are part of the date scheduling profile are important to consider\n  const matchUpIdDependencies = (\n    matchUpDependencies?.[matchUp.matchUpId]?.matchUpIds || []\n  ).filter((matchUpId) => allDateMatchUpIds.includes(matchUpId));\n\n  const remainingDependencies = matchUpIdDependencies.filter(\n    (matchUpId) => !matchUpScheduleTimes[matchUpId]\n  );\n\n  // when true all the matchUps on which this matchUp is dependent have already been scheduled\n  const dependenciesScheduled = !remainingDependencies?.length;\n\n  return { dependenciesScheduled, remainingDependencies };\n}\n","import { findTournamentId } from './findTournamentId';\nimport { findEvent } from './findEvent';\nimport { decorateResult } from '../global/functions/decorateResult';\nimport { DrawDefinition, Event, Tournament } from '../types/tournamentTypes';\n\nimport { SUCCESS } from '../constants/resultConstants';\nimport {\n  DRAW_DEFINITION_NOT_FOUND,\n  ErrorType,\n  MISSING_DRAW_ID,\n  MISSING_TOURNAMENT_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../constants/errorConditionConstants';\n\ntype GetDrawDefinitionArgs = {\n  tournamentRecords?: { [key: string]: Tournament };\n  tournamentRecord?: Tournament;\n  tournamentId?: string;\n  drawId: string;\n};\n\nexport function findDrawDefinition({\n  tournamentRecords,\n  tournamentRecord,\n  tournamentId,\n  drawId,\n}: GetDrawDefinitionArgs): {\n  drawDefinition?: DrawDefinition;\n  tournamentRecord?: Tournament;\n  error?: ErrorType;\n  event?: Event;\n} {\n  if (!tournamentRecord && !tournamentRecords)\n    return { error: MISSING_TOURNAMENT_RECORD };\n  if (!drawId) return { error: MISSING_DRAW_ID };\n\n  if (!tournamentRecord && tournamentRecords) {\n    if (typeof tournamentId !== 'string') {\n      // find tournamentId by brute force if not provided\n      tournamentId = findTournamentId({ tournamentRecords, drawId });\n      if (!tournamentId) return { error: MISSING_TOURNAMENT_ID };\n    }\n\n    tournamentRecord = tournamentRecords[tournamentId];\n    if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  }\n\n  const result = tournamentRecord && findEvent({ tournamentRecord, drawId });\n  if (!result?.drawDefinition) {\n    return decorateResult({\n      result: { error: DRAW_DEFINITION_NOT_FOUND },\n      stack: 'findDrawDefinition',\n    });\n  }\n\n  return {\n    drawDefinition: result.drawDefinition,\n    event: result.event,\n    tournamentRecord,\n    ...SUCCESS,\n  };\n}\n","import { getIndividualParticipantIds } from './getIndividualParticipantIds';\nimport { HydratedMatchUp } from '../../../../types/hydrated';\nimport { unique } from '../../../../utilities/arrays';\n\ntype ProcessNextMatchUpsArgs = {\n  matchUpPotentialParticipantIds: { [key: string]: string[] };\n  matchUpNotBeforeTimes: { [key: string]: any };\n  timeAfterRecovery?: number;\n  matchUp: HydratedMatchUp;\n};\nexport function processNextMatchUps({\n  matchUpPotentialParticipantIds,\n  matchUpNotBeforeTimes,\n  timeAfterRecovery,\n  matchUp,\n}: ProcessNextMatchUpsArgs) {\n  const { individualParticipantIds } = getIndividualParticipantIds(matchUp);\n  timeAfterRecovery = timeAfterRecovery ?? matchUp.schedule?.timeAfterRecovery;\n\n  const addPotentialParticipantIds = (targetMatchUpId) => {\n    if (!matchUpPotentialParticipantIds[targetMatchUpId])\n      matchUpPotentialParticipantIds[targetMatchUpId] = [];\n\n    // push potentials as an array so that if any have progressed to target matchUp\n    // others in the array can be identfied as no longer potentials\n    matchUpPotentialParticipantIds[targetMatchUpId] = unique(\n      matchUpPotentialParticipantIds[targetMatchUpId].concat(\n        ...individualParticipantIds\n      )\n    );\n  };\n\n  // It is necessary to only update timeAfterRecovery if value is greater...\n  // ...to account for source matchUps having earlier timeAfterRecovery\n  // e.g. roundPosition 1 matchUp timeAfterRecovery is 11:00 but\n  // roundPosition 2 matchUp timeAfterRecovery is 9:30\n  // and the last one to be processed shouldn't overwrite later value\n  const updateNotBeforeTime = (matchUpId) => {\n    if (\n      timeAfterRecovery &&\n      (!matchUpNotBeforeTimes[matchUpId] ||\n        timeAfterRecovery > matchUpNotBeforeTimes[matchUpId])\n    ) {\n      matchUpNotBeforeTimes[matchUpId] = timeAfterRecovery;\n    }\n  };\n\n  const winnerMatchUpId =\n    matchUp.winnerTo?.matchUpId || matchUp.winnerMatchUpId;\n  if (winnerMatchUpId) {\n    timeAfterRecovery && updateNotBeforeTime(winnerMatchUpId);\n    addPotentialParticipantIds(winnerMatchUpId);\n  }\n  const loserMatchUpId = matchUp.loserTo?.matchUpId || matchUp.loserMatchUpId;\n  if (loserMatchUpId) {\n    timeAfterRecovery && updateNotBeforeTime(loserMatchUpId);\n    addPotentialParticipantIds(loserMatchUpId);\n  }\n  if (matchUp.sidesTo?.length) {\n    matchUp.sidesTo.forEach(({ matchUpId }) => {\n      if (matchUpId) {\n        timeAfterRecovery && updateNotBeforeTime(matchUpId);\n        addPotentialParticipantIds(matchUpId);\n      }\n    });\n  }\n}\n","export function checkParticipantProfileInitialization({\n  individualParticipantProfiles,\n  participantId,\n}) {\n  if (!individualParticipantProfiles[participantId]) {\n    individualParticipantProfiles[participantId] = {\n      typeChangeTimeAfterRecovery: undefined,\n      timeAfterRecovery: undefined,\n      priorMatchUpType: undefined,\n      potentialRecovery: {}, // { [drawId]: [timeString] } - timeAfterRecovery for potential matchUps by drawId\n      potentialCounted: {}, // whether a potential matchUp has been counted for daily limits for a specific drawId\n      potentialBookings: {},\n      bookings: [],\n      counters: {},\n    };\n  }\n}\n\nexport function addParticipantPotentialRecovery({\n  individualParticipantProfiles,\n  recoveryValue,\n  participantId,\n  scheduleTime,\n  drawId,\n}) {\n  if (!individualParticipantProfiles[participantId].potentialRecovery[drawId]) {\n    individualParticipantProfiles[participantId].potentialRecovery[drawId] = [];\n  }\n  individualParticipantProfiles[participantId].potentialRecovery[drawId].push(\n    recoveryValue\n  );\n\n  if (!individualParticipantProfiles[participantId].potentialBookings[drawId]) {\n    individualParticipantProfiles[participantId].potentialBookings[drawId] = [];\n  }\n  individualParticipantProfiles[participantId].potentialBookings[drawId].push({\n    timeAfterRecovery: recoveryValue,\n    scheduleTime,\n  });\n}\n","import { processNextMatchUps } from './processNextMatchUps';\nimport { ensureInt } from '../../../../utilities/ensureInt';\nimport {\n  addParticipantPotentialRecovery,\n  checkParticipantProfileInitialization,\n} from './checkParticipantProfileInitialization';\nimport {\n  addMinutesToTimeString,\n  extractTime,\n} from '../../../../utilities/dateTime';\n\nimport { HydratedMatchUp } from '../../../../types/hydrated';\n\ntype UpdateTimeAfterRecoveryArgs = {\n  matchUpPotentialParticipantIds: { [key: string]: string[] };\n  matchUpNotBeforeTimes: { [key: string]: any };\n  matchUpDependencies: { [key: string]: any };\n  typeChangeRecoveryMinutes?: string;\n  individualParticipantProfiles: any;\n  averageMatchUpMinutes?: number;\n  recoveryMinutes?: number;\n  scheduleTime: string;\n  matchUp: HydratedMatchUp;\n};\nexport function updateTimeAfterRecovery({\n  matchUpPotentialParticipantIds,\n  individualParticipantProfiles,\n  typeChangeRecoveryMinutes,\n  averageMatchUpMinutes = 0,\n  matchUpNotBeforeTimes,\n  matchUpDependencies,\n  recoveryMinutes = 0,\n  scheduleTime,\n  matchUp,\n}: UpdateTimeAfterRecoveryArgs) {\n  const endTime = extractTime(matchUp?.schedule?.endTime);\n  const timeAfterRecovery = endTime\n    ? addMinutesToTimeString(endTime, ensureInt(recoveryMinutes))\n    : addMinutesToTimeString(\n        scheduleTime,\n        ensureInt(averageMatchUpMinutes) + ensureInt(recoveryMinutes)\n      );\n\n  const typeChangeTimeAfterRecovery =\n    typeChangeRecoveryMinutes &&\n    (endTime\n      ? addMinutesToTimeString(extractTime(endTime), typeChangeRecoveryMinutes)\n      : addMinutesToTimeString(\n          scheduleTime,\n          ensureInt(averageMatchUpMinutes) +\n            ensureInt(typeChangeRecoveryMinutes)\n        ));\n  const participantIdDependencies =\n    matchUpDependencies?.[matchUp.matchUpId]?.participantIds || [];\n\n  const potentialIndividualParticipantIds = (\n    (matchUp.roundPosition &&\n      matchUpPotentialParticipantIds[matchUp.matchUpId]) ||\n    []\n  ).flat();\n\n  participantIdDependencies.forEach((participantId) => {\n    checkParticipantProfileInitialization({\n      individualParticipantProfiles,\n      participantId,\n    });\n\n    const matchUpTypeChange =\n      individualParticipantProfiles[participantId].priorMatchUpType !==\n      matchUp.matchUpType;\n\n    // if matchUpType of previous matchUp is different, use typeChangeTimeAfterRecovery (if available)\n    const recoveryValue = matchUpTypeChange\n      ? typeChangeTimeAfterRecovery || timeAfterRecovery\n      : timeAfterRecovery;\n\n    // check whether this participantId is potential or actual for this matchUp\n    if (potentialIndividualParticipantIds.includes(participantId)) {\n      addParticipantPotentialRecovery({\n        individualParticipantProfiles,\n        drawId: matchUp.drawId,\n        recoveryValue,\n        participantId,\n        scheduleTime,\n      });\n    } else {\n      individualParticipantProfiles[participantId].timeAfterRecovery =\n        recoveryValue;\n\n      individualParticipantProfiles[participantId].bookings.push({\n        scheduleTime,\n        timeAfterRecovery: recoveryValue,\n      });\n    }\n  });\n\n  processNextMatchUps({\n    matchUpPotentialParticipantIds,\n    matchUpNotBeforeTimes,\n    timeAfterRecovery,\n    matchUp,\n  });\n}\n","import {\n  addMinutesToTimeString,\n  timeStringMinutes,\n} from '../../../../utilities/dateTime';\n\nexport function checkDependendantTiming({\n  matchUpScheduleTimes,\n  matchUpDependencies,\n  scheduleTime,\n  matchUpId,\n  details,\n}) {\n  let scheduledDependent;\n\n  const recoveryMinutes = details.minutesMap?.[matchUpId]?.recoveryMinutes;\n  const averageMatchUpMinutes = details.minutesMap?.[matchUpId]?.averageMinutes;\n  const totalMinutes = (averageMatchUpMinutes || 0) + (recoveryMinutes || 0);\n  const dependentNotBeforeTime = addMinutesToTimeString(\n    scheduleTime,\n    totalMinutes\n  );\n\n  const matchUpIdDependents =\n    matchUpDependencies?.[matchUpId]?.dependentMatchUpIds || [];\n\n  if (matchUpIdDependents.length) {\n    const earliestDependent = matchUpIdDependents.reduce(\n      (dependent, candidateId) => {\n        const candidateScheduleTime = matchUpScheduleTimes[candidateId];\n        if (!candidateScheduleTime) return dependent;\n\n        const candidateDependent = {\n          scheduleTime: candidateScheduleTime,\n          matchUpId: candidateId,\n        };\n        if (candidateScheduleTime && !dependent.matchUpId)\n          return candidateDependent;\n\n        return timeStringMinutes(candidateScheduleTime) <\n          timeStringMinutes(dependent.scheduleTime)\n          ? candidateDependent\n          : dependent;\n      },\n      {}\n    );\n    if (\n      earliestDependent.scheduleTime &&\n      timeStringMinutes(dependentNotBeforeTime) >\n        timeStringMinutes(earliestDependent.scheduleTime)\n    ) {\n      scheduledDependent = earliestDependent;\n    }\n  }\n\n  return { scheduledDependent };\n}\n","export const DO_NOT_SCHEDULE = 'DO_NOT_SCHEDULE';\n\nexport const requestConstants = {\n  DO_NOT_SCHEDULE,\n};\n\nexport default requestConstants;\n","import { getIndividualParticipants } from './getIndividualParticipants';\nimport {\n  addMinutes,\n  extractDate,\n  extractTime,\n  sameDay,\n  timeToDate,\n} from '../../../../utilities/dateTime';\n\nimport { DO_NOT_SCHEDULE } from '../../../../constants/requestConstants';\n\n/**\n *\n * @param {string} scheduleDate - 'YYYY-MM-DD' date string\n * @param {object} matchUp - matchUp being checked\n * @param {string} scheduleTime - time being checked\n * @param {number} averageMatchUpMinutes - number of minutes matchUp is expected to last\n *\n * @param {object} requestConflicts - tracks per-matchUp conflicts { [requestId]: { scheduleTimes, matchUpIds }}\n * @param {boolean} potentials - whether to consdier potential participants when determining conflicts\n * @param {object} personRequests - contains personRequests { [personId]: [request] }\n *\n * @returns\n */\nexport function checkRequestConflicts({\n  averageMatchUpMinutes = 90,\n  requestConflicts = {},\n  potentials = true,\n  personRequests,\n  scheduleTime,\n  scheduleDate,\n  matchUp,\n}) {\n  const personIds = getIndividualParticipants(matchUp).map(\n    ({ person }) => person?.personId\n  );\n  if (potentials) {\n    const potentialPersonIds = (matchUp?.potentialParticipants || [])\n      .flat()\n      .map(({ person }) => person?.personId);\n    personIds.push(...potentialPersonIds);\n  }\n\n  const relevantPersonRequests = personIds\n    .map(\n      (personId) =>\n        personRequests[personId]?.map((request) => ({ ...request, personId }))\n    )\n    .filter(Boolean)\n    .flat()\n    .filter(\n      (request) =>\n        request.requestType === DO_NOT_SCHEDULE &&\n        sameDay(scheduleDate, request.date)\n    );\n\n  const conflicts: any[] = [];\n  const matchUpId = matchUp?.matchUpId;\n  const scheduleStart = timeToDate(\n    extractTime(scheduleTime),\n    extractDate(scheduleDate)\n  );\n  const averageEnd = extractTime(\n    addMinutes(scheduleStart, averageMatchUpMinutes).toISOString()\n  );\n\n  // scheduleTime, averageEnd, startTime and endTime are all string format '00:00'\n  // string comparison < > is used to determine...\n  // ...if either schedultTime or averageEnd falls between request startTime and endTime\n  for (const request of relevantPersonRequests) {\n    const { requestId, startTime, endTime } = request;\n    const conflict =\n      (scheduleTime > startTime && scheduleTime < endTime) ||\n      (averageEnd > startTime && averageEnd < endTime);\n    if (conflict) {\n      conflicts.push({ matchUpId, request, scheduleTime });\n      if (!requestConflicts[requestId]) {\n        requestConflicts[requestId] = {\n          request,\n          scheduleTimes: [scheduleTime],\n          matchUpIds: [matchUpId],\n        };\n      } else {\n        if (!requestConflicts[requestId].scheduleTimes.includes(scheduleTime))\n          requestConflicts[requestId].scheduleTimes.push(scheduleTime);\n        if (!requestConflicts[requestId].matchUpIds.includes(matchUpId))\n          requestConflicts[requestId].matchUpIds.push(matchUpId);\n      }\n    }\n  }\n\n  return { conflicts };\n}\n","import { DOUBLES } from '../../../../constants/matchUpTypes';\n\nexport function getIndividualParticipants(matchUp) {\n  const { sides, matchUpType } = matchUp || {};\n  return (sides || [])\n    .map((side) => {\n      return (\n        (matchUpType === DOUBLES &&\n          (side?.participant?.individualParticipants || [])) ||\n        (side?.participant && [side.participant]) ||\n        []\n      );\n    })\n    .flat();\n}\n","import { getMatchUpFormatTiming } from '../query/extensions/matchUpFormatTiming/getMatchUpFormatTiming';\nimport { isValidMatchUpFormat } from '../validators/isValidMatchUpFormat';\nimport { findEvent } from './findEvent';\n\nimport { UNRECOGNIZED_MATCHUP_FORMAT } from '../constants/errorConditionConstants';\nimport { Tournament, EventTypeUnion } from '../types/tournamentTypes';\n\ntype FindMatchUpFormatTiming = {\n  tournamentRecords: { [key: string]: Tournament };\n  defaultRecoveryMinutes?: number;\n  defaultAverageMinutes?: number;\n  matchUpFormat: string;\n  categoryName?: string;\n  categoryType?: string;\n  tournamentId: string;\n  eventType?: EventTypeUnion;\n  eventId?: string;\n};\nexport function findMatchUpFormatTiming({\n  defaultRecoveryMinutes = 0,\n  defaultAverageMinutes,\n  tournamentRecords,\n  matchUpFormat,\n  categoryName,\n  categoryType,\n  tournamentId,\n  eventType,\n  eventId,\n}: FindMatchUpFormatTiming) {\n  if (!isValidMatchUpFormat({ matchUpFormat }))\n    return { error: UNRECOGNIZED_MATCHUP_FORMAT };\n\n  const tournamentIds = Object.keys(tournamentRecords).filter(\n    (currentTournamentId) =>\n      !tournamentId || currentTournamentId === tournamentId\n  );\n\n  let timing;\n  tournamentIds.forEach((currentTournamentId) => {\n    if (timing) return;\n    const tournamentRecord = tournamentRecords[currentTournamentId];\n    const event = eventId\n      ? findEvent({ tournamentRecord, eventId })?.event\n      : undefined;\n    timing = getMatchUpFormatTiming({\n      tournamentRecord,\n      matchUpFormat,\n      categoryName,\n      categoryType,\n      eventType,\n      event,\n    });\n    return timing?.averageMinutes || timing?.recoveryMinutes;\n  });\n\n  return {\n    recoveryMinutes: timing?.recoveryMinutes || defaultRecoveryMinutes,\n    averageMinutes: timing?.averageMinutes || defaultAverageMinutes,\n    typeChangeRecoveryMinutes:\n      timing?.typeChangeRecoveryMinutes ||\n      timing?.recoveryMinutes ||\n      defaultRecoveryMinutes,\n  };\n}\n","import { getContainedStructures } from '../../drawDefinition/getContainedStructures';\nimport { allCompetitionMatchUps } from '../../matchUps/getAllCompetitionMatchUps';\nimport { findMatchUpFormatTiming } from '../../../acquire/findMatchUpFormatTiming';\nimport { isConvertableInteger, isPowerOf2 } from '../../../utilities/math';\nimport { matchUpSort } from '../../../functions/sorters/matchUpSort';\nimport { getMatchUpId } from '../../../global/functions/extractors';\nimport { mustBeAnArray } from '../../../utilities/mustBeAnArray';\nimport { findEvent } from '../../../acquire/findEvent';\nimport { filterMatchUps } from '../../filterMatchUps';\n\nimport { Tournament } from '../../../types/tournamentTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORDS,\n  MISSING_VALUE,\n} from '../../../constants/errorConditionConstants';\nimport {\n  BYE,\n  completedMatchUpStatuses,\n} from '../../../constants/matchUpStatusConstants';\n\n/**\n *\n * @param {object} tournamentRecords - passed in automatically by competitionEngine\n * @param {string[]} containedStructureIds - optional optimization - otherwise created internally\n * @param {integer} periodLength - optional - defaults to 30\n * @param {object[]} matchUps - optional optimization - otherwise created internally\n * @param {object[]} rounds - array of ordered rounds specified as part of a schedulingProfile\n * @returns\n */\n\ntype GetScheduledRoundsDetailsArgs = {\n  tournamentRecords: { [key: string]: Tournament };\n  scheduleCompletedMatchUps?: boolean;\n  containedStructureIds?: string[];\n  matchUps?: HydratedMatchUp[];\n  periodLength?: number;\n  rounds: any[];\n};\ntype RoundsDetailsResult = {\n  greatestAverageMinutes?: number;\n  scheduledRoundsDetails?: any[];\n  orderedMatchUpIds?: string[];\n  matchUpFormatCohorts?: any; // currently unused\n  recoveryMinutesMap?: any;\n  averageMinutesMap?: any;\n  error?: ErrorType;\n  success?: boolean;\n  minutesMap?: any;\n  info?: string;\n};\nexport function getScheduledRoundsDetails({\n  scheduleCompletedMatchUps,\n  containedStructureIds, // optional to support calling method outside of scheduleProfileRounds\n  tournamentRecords,\n  periodLength = 30,\n  matchUps, // optional to support calling method outside of scheduleProfileRounds\n  rounds,\n}: GetScheduledRoundsDetailsArgs): RoundsDetailsResult {\n  if (typeof tournamentRecords !== 'object')\n    return { error: MISSING_TOURNAMENT_RECORDS };\n  if (!Array.isArray(rounds))\n    return { error: MISSING_VALUE, info: mustBeAnArray('rounds') };\n\n  const matchUpFormatCohorts = {};\n  const hashes: string[] = [];\n  const orderedMatchUpIds: string[] = [];\n  rounds.sort((a, b) => (a.sortOrder ?? 0) - (b.sortOrder ?? 0));\n\n  // ---------------------------------------------------------\n  // populate required variables if not provided by parameters\n  containedStructureIds =\n    containedStructureIds ??\n    Object.assign(\n      {},\n      ...Object.values(tournamentRecords).map(\n        (tournamentRecord) =>\n          getContainedStructures({ tournamentRecord }).containedStructures\n      )\n    );\n\n  if (!matchUps) {\n    ({ matchUps } = allCompetitionMatchUps({\n      nextMatchUps: true,\n      tournamentRecords,\n    }));\n  }\n  // ---------------------------------------------------------\n\n  let greatestAverageMinutes = 0;\n  const recoveryMinutesMap = {};\n  const averageMinutesMap = {};\n  const minutesMap = {};\n\n  const scheduledRoundsDetails = rounds.flatMap((round) => {\n    const roundPeriodLength = round.periodLength || periodLength;\n    const structureIds: string[] = [];\n    if (containedStructureIds?.[round.structureId]) {\n      structureIds.push(...containedStructureIds[round.structureId]);\n    } else {\n      structureIds.push(round.structureId);\n    }\n    let roundMatchUps = matchUps\n      ? filterMatchUps({\n          tournamentIds: [round.tournamentId],\n          roundNumbers: [round.roundNumber],\n          matchUpIds: round.matchUpIds,\n          eventIds: [round.eventId],\n          drawIds: [round.drawId],\n          processContext: true,\n          structureIds,\n          matchUps,\n        }).sort(matchUpSort)\n      : [];\n\n    // filter by roundSegment\n    const { segmentNumber, segmentsCount } = round.roundSegment || {};\n\n    if (\n      isConvertableInteger(segmentNumber) &&\n      isPowerOf2(roundMatchUps?.length) &&\n      isPowerOf2(segmentsCount) &&\n      segmentNumber > 0 &&\n      segmentNumber <= segmentsCount &&\n      segmentsCount < roundMatchUps?.length &&\n      !round.matchUpIds?.length\n    ) {\n      const segmentSize = roundMatchUps.length / segmentsCount;\n      const firstSegmentIndex = segmentSize * (segmentNumber - 1);\n      roundMatchUps = roundMatchUps.slice(\n        firstSegmentIndex,\n        firstSegmentIndex + segmentSize\n      );\n    }\n\n    const tournamentRecord = tournamentRecords[round.tournamentId];\n    const event = findEvent({\n      drawId: round.drawId,\n      tournamentRecord,\n    }).event;\n\n    const matchUpFormatOrder: string[] = [];\n    for (const matchUp of roundMatchUps) {\n      const matchUpFormat = matchUp.matchUpFormat;\n      if (matchUpFormat) {\n        if (!matchUpFormatCohorts[matchUpFormat]) {\n          matchUpFormatCohorts[matchUpFormat] = [];\n          matchUpFormatCohorts[matchUpFormat].push(matchUp);\n        }\n        matchUpFormatOrder.push(matchUpFormat);\n      }\n    }\n\n    for (const matchUpFormat of matchUpFormatOrder) {\n      const { eventType, category } = event ?? {};\n      const { categoryName, ageCategoryCode } = category ?? {};\n      const {\n        typeChangeRecoveryMinutes,\n        recoveryMinutes,\n        averageMinutes,\n        error,\n      } = findMatchUpFormatTiming({\n        categoryName: categoryName ?? ageCategoryCode,\n        categoryType: category?.categoryType,\n        tournamentId: round.tournamentId,\n        eventId: round.eventId,\n        tournamentRecords,\n        matchUpFormat,\n        eventType,\n      });\n      if (error) return { error, round };\n\n      const matchUpIds = roundMatchUps\n        .filter(\n          (rm: any) =>\n            // don't attempt to scheduled completed matchUpstatuses unless explicit override\n            (scheduleCompletedMatchUps ||\n              !completedMatchUpStatuses.includes(rm.matchUpStatus)) &&\n            rm.matchUpStatus !== BYE\n        )\n        .map(getMatchUpId);\n\n      matchUpIds.forEach((matchUpId) => {\n        minutesMap[matchUpId] = {\n          typeChangeRecoveryMinutes,\n          recoveryMinutes,\n          averageMinutes,\n        };\n        recoveryMinutesMap[matchUpId] = recoveryMinutes;\n        averageMinutesMap[matchUpId] = averageMinutes;\n      });\n      orderedMatchUpIds.push(...matchUpIds);\n\n      greatestAverageMinutes = Math.max(\n        averageMinutes || 0,\n        greatestAverageMinutes\n      );\n      const hash = `${averageMinutes}|${roundPeriodLength}`;\n      if (!hashes.includes(hash)) hashes.push(hash);\n\n      return {\n        roundPeriodLength,\n        recoveryMinutes,\n        averageMinutes,\n        matchUpIds,\n        hash,\n      };\n    }\n    return undefined;\n  });\n\n  return {\n    scheduledRoundsDetails,\n    greatestAverageMinutes,\n    matchUpFormatCohorts,\n    recoveryMinutesMap,\n    averageMinutesMap,\n    orderedMatchUpIds,\n    minutesMap,\n    ...SUCCESS,\n  };\n}\n","// groups schedule profile rounds where adjacent hashes are equivalent\n// if { garmanSinglePass: true } then group all rounds into a single group\n// if { garmanSinglePass: true } then the one group has greatestAverageMinutes\nexport function getGroupedRounds({\n  scheduledRoundsDetails,\n  greatestAverageMinutes,\n  garmanSinglePass,\n}) {\n  const groupedRounds: any[] = [];\n  let groupedMatchUpIds = [];\n  let roundPeriodLength;\n  let recoveryMinutes;\n  let averageMinutes;\n  let lastHash;\n\n  for (const roundDetails of scheduledRoundsDetails.filter(Boolean)) {\n    if (!lastHash) lastHash = roundDetails.hash;\n    if (roundDetails.hash === lastHash || garmanSinglePass) {\n      groupedMatchUpIds = groupedMatchUpIds.concat(roundDetails.matchUpIds);\n    }\n    if (roundDetails.hash !== lastHash && !garmanSinglePass) {\n      lastHash = roundDetails.hash;\n      groupedRounds.push({\n        averageMinutes,\n        recoveryMinutes,\n        roundPeriodLength,\n        matchUpIds: groupedMatchUpIds,\n      });\n      groupedMatchUpIds = roundDetails.matchUpIds;\n    }\n    averageMinutes = garmanSinglePass\n      ? greatestAverageMinutes\n      : roundDetails.averageMinutes;\n    recoveryMinutes = roundDetails.recoveryMinutes;\n    roundPeriodLength = roundDetails.roundPeriodLength;\n  }\n\n  if (groupedMatchUpIds.length) {\n    groupedRounds.push({\n      matchUpIds: groupedMatchUpIds,\n      roundPeriodLength,\n      recoveryMinutes,\n      averageMinutes,\n    });\n  }\n\n  return { groupedRounds };\n}\n","import { checkParticipantProfileInitialization } from './checkParticipantProfileInitialization';\nimport { getIndividualParticipantIds } from './getIndividualParticipantIds';\nimport { overlap } from '../../../../utilities/arrays';\n\nimport { TOTAL } from '../../../../constants/scheduleConstants';\n\nexport function modifyParticipantMatchUpsCount({\n  matchUpPotentialParticipantIds,\n  individualParticipantProfiles,\n  matchUp,\n  value,\n}) {\n  const { matchUpType } = matchUp;\n\n  // individualParticipantIds represent those participants already present\n  const { individualParticipantIds } = getIndividualParticipantIds(matchUp);\n  // potentialParticipantIds are those who could progress to this matchUp\n  const potentialParticipantIds =\n    matchUpPotentialParticipantIds[matchUp.matchUpId] || [];\n\n  // filteredPotentials exclude potentials if any of the participantIds\n  // are present in individualParticipantIds which ensures that source match losers\n  // do not get considered when incrementing or decrementing matchUp counters\n  const filteredPotentials = potentialParticipantIds\n    .filter((potentials) => !overlap(potentials, individualParticipantIds))\n    .flat();\n  const consideredParticipantIds = [\n    ...individualParticipantIds,\n    ...filteredPotentials,\n  ];\n\n  consideredParticipantIds.forEach((participantId) => {\n    checkParticipantProfileInitialization({\n      individualParticipantProfiles,\n      participantId,\n    });\n\n    if (\n      !individualParticipantProfiles[participantId].potentialCounted[\n        matchUp.drawId\n      ]\n    ) {\n      const counters = individualParticipantProfiles[participantId].counters;\n      if (counters[matchUpType]) counters[matchUpType] += value;\n      else if (value > 0) counters[matchUpType] = value;\n      if (counters[TOTAL]) counters[TOTAL] += value;\n      else if (value > 0) counters[TOTAL] = value;\n      if (filteredPotentials.includes(participantId)) {\n        individualParticipantProfiles[participantId].potentialCounted[\n          matchUp.drawId\n        ] = true;\n      }\n    }\n  });\n}\n","export const hasSchedule = ({\n  scheduleAttributes = ['scheduledDate', 'scheduledTime'],\n  schedule = {},\n}) => {\n  const matchUpScheduleKeys = Object.keys(schedule)\n    .filter((key) => scheduleAttributes.includes(key))\n    .filter((key) => schedule[key]);\n  return !!matchUpScheduleKeys.length;\n};\n","import { modifyParticipantMatchUpsCount } from '../../scheduleMatchUps/modifyParticipantMatchUpsCount';\nimport { updateTimeAfterRecovery } from '../../scheduleMatchUps/updateTimeAfterRecovery';\nimport { getMatchUpId } from '../../../../../global/functions/extractors';\nimport { hasSchedule } from '../../scheduleMatchUps/hasSchedule';\n\nimport { BYE } from '../../../../../constants/matchUpStatusConstants';\nimport { HydratedMatchUp } from '../../../../../types/hydrated';\n\ntype ProcessAlreadyScheduledMatchUpsArgs = {\n  matchUpPotentialParticipantIds: { [key: string]: string[] };\n  matchUpNotBeforeTimes: { [key: string]: any };\n  matchUpScheduleTimes: { [key: string]: any };\n  dateScheduledMatchUps?: HydratedMatchUp[];\n  individualParticipantProfiles: any;\n  dateScheduledMatchUpIds: string[];\n  greatestAverageMinutes?: number;\n  clearScheduleDates?: boolean;\n  matchUps: HydratedMatchUp[];\n  matchUpDependencies: any;\n  scheduleDate: string;\n  minutesMap: any;\n};\nexport function processAlreadyScheduledMatchUps({\n  matchUpPotentialParticipantIds,\n  individualParticipantProfiles,\n  dateScheduledMatchUpIds,\n  greatestAverageMinutes,\n  dateScheduledMatchUps,\n  matchUpNotBeforeTimes,\n  matchUpScheduleTimes,\n  matchUpDependencies,\n  clearScheduleDates,\n  scheduleDate,\n  minutesMap,\n  matchUps,\n}: ProcessAlreadyScheduledMatchUpsArgs) {\n  const byeScheduledMatchUpDetails: {\n    tournamentId: string;\n    matchUpId: string;\n  }[] = [];\n\n  if (!dateScheduledMatchUpIds) {\n    dateScheduledMatchUps = matchUps?.filter((matchUp) => {\n      const schedule = matchUp.schedule || {};\n      const isByeMatchUp = matchUp.matchUpStatus === BYE;\n      if (isByeMatchUp)\n        byeScheduledMatchUpDetails.push({\n          tournamentId: matchUp.tournamentId,\n          matchUpId: matchUp.matchUpId,\n        });\n      return (\n        !isByeMatchUp &&\n        hasSchedule({ schedule }) &&\n        (!scheduleDate || matchUp.schedule.scheduledDate === scheduleDate)\n      );\n    });\n\n    dateScheduledMatchUpIds = dateScheduledMatchUps.map(getMatchUpId);\n  }\n\n  // first build up a map of matchUpNotBeforeTimes and matchUpPotentialParticipantIds\n  // based on already scheduled matchUps\n  const clearDate = Array.isArray(clearScheduleDates)\n    ? clearScheduleDates.includes(scheduleDate)\n    : clearScheduleDates;\n\n  const alreadyScheduled = clearDate\n    ? []\n    : matchUps.filter(({ matchUpId }) =>\n        dateScheduledMatchUpIds.includes(matchUpId)\n      );\n\n  for (const matchUp of alreadyScheduled) {\n    modifyParticipantMatchUpsCount({\n      matchUpPotentialParticipantIds,\n      individualParticipantProfiles,\n      value: 1,\n      matchUp,\n    });\n\n    const scheduleTime = matchUp.schedule?.scheduledTime;\n\n    if (scheduleTime) {\n      matchUpScheduleTimes[matchUp.matchUpId] = scheduleTime;\n      const recoveryMinutes = minutesMap?.[matchUp.matchUpId]?.recoveryMinutes;\n      const averageMatchUpMinutes = greatestAverageMinutes;\n      // minutesMap?.[matchUp.matchUpId]?.averageMinutes; // for the future when variable averageMinutes supported\n\n      updateTimeAfterRecovery({\n        individualParticipantProfiles,\n        matchUpPotentialParticipantIds,\n        matchUpNotBeforeTimes,\n        matchUpDependencies,\n        averageMatchUpMinutes,\n        recoveryMinutes,\n        scheduleTime,\n        matchUp,\n      });\n    }\n  }\n\n  return {\n    dateScheduledMatchUpIds,\n    byeScheduledMatchUpDetails,\n    dateScheduledMatchUps,\n    clearDate,\n  };\n}\n","import { processNextMatchUps } from '../../scheduleMatchUps/processNextMatchUps';\n\nimport {\n  BYE,\n  ABANDONED,\n  DEFAULTED,\n  RETIRED,\n  WALKOVER,\n  COMPLETED,\n  DOUBLE_WALKOVER,\n  DOUBLE_DEFAULT,\n} from '../../../../../constants/matchUpStatusConstants';\n\nexport function getMatchUpsToSchedule({\n  matchUpPotentialParticipantIds,\n  scheduleCompletedMatchUps,\n  dateScheduledMatchUpIds,\n  matchUpNotBeforeTimes,\n  matchUpScheduleTimes,\n  orderedMatchUpIds,\n  clearDate,\n  matchUps,\n}) {\n  const alreadyScheduledMatchUpIds = Object.keys(matchUpScheduleTimes);\n\n  // this must be done to preserve the order of matchUpIds\n  const matchUpsToSchedule = orderedMatchUpIds\n    .map((matchUpId) =>\n      matchUps.find((matchUp) => matchUp.matchUpId === matchUpId)\n    )\n    .filter(Boolean)\n    .filter((matchUp) => {\n      const alreadyScheduled =\n        !clearDate &&\n        (dateScheduledMatchUpIds.includes(matchUp.matchUpId) ||\n          alreadyScheduledMatchUpIds.includes(matchUp.matchUpId));\n\n      const doNotSchedule = [\n        BYE,\n        DEFAULTED,\n        COMPLETED,\n        ABANDONED,\n        RETIRED,\n        WALKOVER,\n        DOUBLE_WALKOVER,\n        DOUBLE_DEFAULT,\n      ].includes(matchUp?.matchUpStatus);\n\n      return (\n        scheduleCompletedMatchUps || // override for mocksEngine\n        (!alreadyScheduled && !matchUp.winningSide && !doNotSchedule)\n      );\n    });\n\n  // for optimization, build up an object for each tournament and an array for each draw with target matchUps\n  // keep track of matchUps counts per participant and don't add matchUps for participants beyond those limits\n  const { matchUpMap } = matchUpsToSchedule.reduce(\n    (aggregator, matchUp) => {\n      const { drawId, tournamentId } = matchUp;\n\n      if (!aggregator.matchUpMap[tournamentId])\n        aggregator.matchUpMap[tournamentId] = {};\n      if (!aggregator.matchUpMap[tournamentId][drawId]) {\n        aggregator.matchUpMap[tournamentId][drawId] = [matchUp];\n      } else {\n        aggregator.matchUpMap[tournamentId][drawId].push(matchUp);\n      }\n\n      // since this matchUp is to be scheduled, update the matchUpPotentialParticipantIds\n      processNextMatchUps({\n        matchUpPotentialParticipantIds,\n        matchUpNotBeforeTimes,\n        matchUp,\n      });\n\n      return aggregator;\n    },\n    { matchUpMap: {} }\n  );\n  return { matchUpsToSchedule, matchUpMap };\n}\n","import { matchUpFormatTimes } from '../../../../../query/extensions/matchUpFormatTiming/getMatchUpFormatTiming';\nimport { getScheduleTiming } from '../../../../../query/extensions/matchUpFormatTiming/getScheduleTiming';\nimport { validMatchUps } from '../../../../../validators/validMatchUp';\nimport { calculatePeriodLength } from './calculatePeriodLength';\nimport { hasSchedule } from '../../scheduleMatchUps/hasSchedule';\nimport {\n  addMinutesToTimeString,\n  extractTime,\n} from '../../../../../utilities/dateTime';\n\nimport { Tournament } from '../../../../../types/tournamentTypes';\nimport { BYE } from '../../../../../constants/matchUpStatusConstants';\nimport { HydratedMatchUp } from '../../../../../types/hydrated';\nimport {\n  MISSING_MATCHUPS,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../../../../constants/errorConditionConstants';\n\ntype GenerateBookingsArgs = {\n  tournamentRecords: { [key: string]: Tournament };\n  dateScheduledMatchUps?: HydratedMatchUp[];\n  defaultRecoveryMinutes?: number;\n  averageMatchUpMinutes?: number;\n  matchUps?: HydratedMatchUp[];\n  periodLength?: number;\n  scheduleDate?: string;\n  venueIds?: string[];\n};\nexport function generateBookings({\n  defaultRecoveryMinutes = 0,\n  averageMatchUpMinutes = 90,\n  dateScheduledMatchUps,\n  tournamentRecords,\n  venueIds = [],\n  periodLength,\n  scheduleDate,\n  matchUps,\n}: GenerateBookingsArgs) {\n  if (typeof tournamentRecords !== 'object')\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  if (!validMatchUps(matchUps) && !Array.isArray(dateScheduledMatchUps))\n    return { error: MISSING_MATCHUPS };\n\n  periodLength =\n    periodLength ??\n    calculatePeriodLength({\n      recoveryMinutes: defaultRecoveryMinutes,\n      averageMatchUpMinutes,\n    });\n\n  // get a mapping of eventIds to category details\n  const eventDetails = Object.assign(\n    {},\n    ...Object.values(tournamentRecords)\n      .map((tournamentRecord) =>\n        (tournamentRecord.events ?? []).map((event) => {\n          const { scheduleTiming } = getScheduleTiming({\n            tournamentRecord,\n            event,\n          });\n\n          return {\n            [event.eventId]: { event, scheduleTiming },\n          };\n        })\n      )\n      .flat()\n  );\n\n  const defaultTiming = {\n    averageTimes: [{ minutes: { default: averageMatchUpMinutes } }],\n    recoveryTimes: [{ minutes: { default: defaultRecoveryMinutes } }],\n  };\n\n  if (!dateScheduledMatchUps) {\n    dateScheduledMatchUps = matchUps?.filter((matchUp) => {\n      const schedule = matchUp.schedule;\n      return (\n        hasSchedule({ schedule }) &&\n        (!scheduleDate || matchUp.schedule.scheduledDate === scheduleDate)\n      );\n    });\n  }\n\n  const relevantMatchUps = dateScheduledMatchUps?.filter(\n    (matchUp) =>\n      (!venueIds.length || venueIds.includes(matchUp.schedule.venueId)) &&\n      matchUp.matchUpStatus !== BYE\n  );\n\n  const bookings = relevantMatchUps\n    ?.map(({ eventId, schedule, matchUpFormat }) => {\n      const { event, scheduleTiming } = eventDetails[eventId];\n      const eventType = event?.eventType;\n      const timingDetails = {\n        ...scheduleTiming,\n        defaultTiming,\n        matchUpFormat,\n      };\n      const { averageMinutes, recoveryMinutes } = matchUpFormatTimes({\n        timingDetails,\n        eventType,\n      });\n      const { courtId, venueId } = schedule;\n      const startTime = extractTime(schedule.scheduledTime);\n      const endTime = addMinutesToTimeString(startTime, averageMinutes);\n      return {\n        recoveryMinutes,\n        averageMinutes,\n        periodLength,\n        startTime,\n        courtId,\n        endTime,\n        venueId,\n      };\n    })\n    .filter(Boolean);\n\n  return { bookings, relevantMatchUps, dateScheduledMatchUps };\n}\n","import { getVenuesAndCourts } from '../../../../../query/venues/venuesAndCourtsGetter';\nimport { getScheduleTimes } from '../../../../../query/venues/getScheduleTimes';\nimport { xa } from '../../../../../utilities/objects';\nimport { calculatePeriodLength } from './calculatePeriodLength';\nimport { getDateTimeBoundary } from './getTimeBoundary';\nimport { generateBookings } from './generateBookings';\n\nimport { ErrorType, MISSING_TOURNAMENT_RECORDS } from '../../../../../constants/errorConditionConstants';\n\nimport { ScheduleTimesResult } from '../../../../../types/factoryTypes';\nimport { Tournament } from '../../../../../types/tournamentTypes';\nimport { HydratedMatchUp } from '../../../../../types/hydrated';\n\ntype GenerateScheduleTimesArgs = {\n  tournamentRecords?: { [key: string]: Tournament };\n  calculateStartTimeFromCourts?: boolean;\n  remainingScheduleTimes?: string[];\n  defaultRecoveryMinutes?: number;\n  averageMatchUpMinutes?: number;\n  tournamentRecord?: Tournament;\n  clearScheduleDates?: boolean;\n  matchUps?: HydratedMatchUp[];\n  periodLength?: number;\n  scheduleDate: string;\n  venueIds: string[];\n  startTime?: string;\n  endTime?: string;\n};\n\nexport function generateScheduleTimes({\n  calculateStartTimeFromCourts = true,\n  remainingScheduleTimes,\n  defaultRecoveryMinutes,\n  averageMatchUpMinutes,\n  clearScheduleDates,\n  tournamentRecords,\n  tournamentRecord,\n  periodLength,\n  scheduleDate,\n  startTime,\n  venueIds,\n  matchUps,\n  endTime,\n}: GenerateScheduleTimesArgs): {\n  dateScheduledMatchUps?: HydratedMatchUp[];\n  scheduleTimes?: ScheduleTimesResult[];\n  dateScheduledMatchUpIds?: string[];\n  error?: ErrorType;\n  venueId?: string;\n} {\n  if (tournamentRecord && !tournamentRecords) {\n    tournamentRecords = { [tournamentRecord.tournamentId]: tournamentRecord };\n  }\n  if (typeof tournamentRecords !== 'object' || !Object.keys(tournamentRecords).length)\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  periodLength =\n    periodLength ??\n    calculatePeriodLength({\n      recoveryMinutes: defaultRecoveryMinutes,\n      averageMatchUpMinutes,\n    });\n\n  const { courts: allCourts, venues } = getVenuesAndCourts({\n    dates: [scheduleDate],\n    ignoreDisabled: true,\n    tournamentRecords,\n  });\n\n  const courts = allCourts?.filter((court) => !venueIds || venueIds.includes(court.venueId)) ?? [];\n\n  startTime = startTime ?? getDateTimeBoundary({ courts, scheduleDate, startTime: true });\n  endTime = endTime ?? getDateTimeBoundary({ courts, scheduleDate, endTime: true });\n\n  const { bookings, dateScheduledMatchUps } = generateBookings({\n    defaultRecoveryMinutes,\n    averageMatchUpMinutes,\n    tournamentRecords,\n    scheduleDate,\n    periodLength,\n    venueIds,\n    matchUps,\n  });\n\n  const timingParameters = {\n    calculateStartTimeFromCourts,\n    remainingScheduleTimes,\n    averageMatchUpMinutes,\n    clearScheduleDates,\n    date: scheduleDate,\n    periodLength,\n    startTime,\n    bookings,\n    endTime,\n    courts,\n  };\n  const { scheduleTimes } = getScheduleTimes(timingParameters);\n\n  // if a single venue specified, or only one venue available, return venueId\n  const venueId = (venueIds?.length === 1 && venueIds[0]) || (venues?.length === 1 && venues[0].venueId) || undefined;\n\n  const dateScheduledMatchUpIds = dateScheduledMatchUps?.map(xa('matchUpId'));\n\n  return {\n    dateScheduledMatchUpIds,\n    dateScheduledMatchUps,\n    scheduleTimes,\n    venueId,\n  };\n}\n","import { getScheduledRoundsDetails } from './getScheduledRoundsDetails';\nimport { getGroupedRounds } from './getGroupedRounds';\nimport { processAlreadyScheduledMatchUps } from '../../../mutate/matchUps/schedule/schedulers/utils/processAlreadyScheduledMatchUps';\nimport { getMatchUpsToSchedule } from '../../../mutate/matchUps/schedule/schedulers/utils/getMatchUpsToSchedule';\nimport { generateScheduleTimes } from '../../../mutate/matchUps/schedule/schedulers/utils/generateScheduleTimes';\nimport { extractDate } from '../../../utilities/dateTime';\n\nimport { Tournament } from '../../../types/tournamentTypes';\nimport { HydratedMatchUp } from '../../../types/hydrated';\n\ntype GetVenueSchedulingDetailsArgs = {\n  matchUpPotentialParticipantIds: { [key: string]: string[] };\n  individualParticipantProfiles: { [key: string]: any };\n  tournamentRecords: { [key: string]: Tournament };\n  matchUpScheduleTimes: { [key: string]: string };\n  matchUpNotBeforeTimes: { [key: string]: any };\n  matchUpDependencies: { [key: string]: any };\n  scheduleCompletedMatchUps?: boolean;\n  containedStructureIds: string[];\n  clearScheduleDates?: boolean;\n  matchUps: HydratedMatchUp[];\n  periodLength?: number;\n  scheduleDate: string;\n  useGarman?: boolean;\n  courts: any[]; // scheduling information; not an actualy court\n  venues: any[]; // scheduling information; not an actualy venue\n};\n\nexport function getVenueSchedulingDetails({\n  matchUpPotentialParticipantIds,\n  individualParticipantProfiles,\n  scheduleCompletedMatchUps,\n  containedStructureIds,\n  matchUpNotBeforeTimes,\n  matchUpScheduleTimes,\n  matchUpDependencies,\n  clearScheduleDates,\n  tournamentRecords,\n  periodLength,\n  scheduleDate,\n  useGarman,\n  matchUps,\n  courts,\n  venues,\n}: GetVenueSchedulingDetailsArgs): {\n  venueScheduledRoundDetails: { [key: string]: any };\n  allDateScheduledByeMatchUpDetails: {\n    tournamentId: string;\n    matchUpId: string;\n  }[];\n  allDateScheduledMatchUpIds: string[];\n  allDateMatchUpIds: string[];\n} {\n  const venueScheduledRoundDetails = {};\n\n  // checking that matchUpDependencies is scoped to only those matchUps that are already or are to be scheduled on the same date\n  const allDateScheduledMatchUpIds: string[] = [];\n  const allDateScheduledByeMatchUpDetails: {\n    tournamentId: string;\n    matchUpId: string;\n  }[] = [];\n  const allDateMatchUpIds: string[] = [];\n\n  // first pass through all venues is to build up an array of all matchUpIds in the schedulingProfile for current scheduleDate\n  for (const venue of venues) {\n    const { rounds = [], venueId } = venue; // rounds derives from dateSchedulingProfile\n    const {\n      scheduledRoundsDetails,\n      greatestAverageMinutes,\n      orderedMatchUpIds,\n      minutesMap,\n    } = getScheduledRoundsDetails({\n      scheduleCompletedMatchUps,\n      containedStructureIds,\n      tournamentRecords,\n      periodLength,\n      matchUps,\n      rounds,\n    });\n\n    allDateMatchUpIds.push(...(orderedMatchUpIds ?? []));\n\n    const { groupedRounds } = getGroupedRounds({\n      scheduledRoundsDetails,\n      greatestAverageMinutes,\n      garmanSinglePass: true,\n    });\n\n    let dateScheduledMatchUpIds;\n    let dateScheduledMatchUps;\n    let scheduleTimes: any = [];\n\n    if (useGarman) {\n      // determines court availability taking into account already scheduled matchUps on the scheduleDate\n      // optimization to pass already retrieved competitionMatchUps to avoid refetch (requires refactor)\n      // on first call pass in the averageMatchUpMiutes of first round to be scheduled\n      ({ scheduleTimes, dateScheduledMatchUpIds, dateScheduledMatchUps } =\n        generateScheduleTimes({\n          averageMatchUpMinutes: groupedRounds[0]?.averageMinutes,\n          scheduleDate: extractDate(scheduleDate),\n          venueIds: [venue.venueId],\n          clearScheduleDates,\n          tournamentRecords,\n          periodLength,\n          matchUps,\n        }));\n    }\n\n    const processResult = processAlreadyScheduledMatchUps({\n      matchUpPotentialParticipantIds,\n      individualParticipantProfiles,\n      dateScheduledMatchUpIds,\n      greatestAverageMinutes,\n      matchUpNotBeforeTimes,\n      matchUpScheduleTimes,\n      matchUpDependencies,\n      clearScheduleDates,\n      scheduleDate,\n      minutesMap,\n      matchUps,\n    });\n\n    ({ dateScheduledMatchUpIds, dateScheduledMatchUps } = processResult);\n    const { byeScheduledMatchUpDetails, clearDate } = processResult;\n    if (byeScheduledMatchUpDetails?.length)\n      allDateScheduledByeMatchUpDetails.push(...byeScheduledMatchUpDetails);\n\n    const { matchUpsToSchedule, matchUpMap } = getMatchUpsToSchedule({\n      matchUpPotentialParticipantIds,\n      scheduleCompletedMatchUps,\n      dateScheduledMatchUpIds,\n      matchUpNotBeforeTimes,\n      matchUpScheduleTimes,\n      orderedMatchUpIds,\n      clearDate,\n      matchUps,\n    });\n\n    const venueCourts = courts.filter((court) => court.venueId === venueId);\n    venueScheduledRoundDetails[venueId] = {\n      previousRemainingScheduleTimes: [], // keep track of sheduleTimes not used on previous iteration\n      courtsCount: venueCourts.length,\n      greatestAverageMinutes,\n      scheduledRoundsDetails,\n      dateScheduledMatchUps,\n      matchUpsToSchedule,\n      scheduleTimes,\n      groupedRounds,\n      venueCourts,\n      minutesMap,\n      matchUpMap,\n    };\n\n    if (!clearScheduleDates) {\n      allDateScheduledMatchUpIds.push(...dateScheduledMatchUpIds);\n    }\n  }\n\n  return {\n    allDateScheduledByeMatchUpDetails,\n    allDateScheduledMatchUpIds,\n    venueScheduledRoundDetails,\n    allDateMatchUpIds,\n  };\n}\n","import { checkParticipantProfileInitialization } from './checkParticipantProfileInitialization';\nimport { analyzeScheduleOverlap } from './analyzeScheduleOverlap';\nimport { ensureInt } from '../../../../utilities/ensureInt';\nimport {\n  addMinutesToTimeString,\n  extractTime,\n  minutesDifference,\n  timeToDate,\n} from '../../../../utilities/dateTime';\nimport { HydratedMatchUp } from '../../../../types/hydrated';\n\ntype CheckRecoveryTimeArgs = {\n  individualParticipantProfiles: { [key: string]: any };\n  matchUpNotBeforeTimes: { [key: string]: any };\n  matchUpDependencies: { [key: string]: any };\n  matchUp: HydratedMatchUp;\n  scheduleTime: string;\n  details?: any;\n};\nexport function checkRecoveryTime({\n  individualParticipantProfiles,\n  matchUpNotBeforeTimes,\n  matchUpDependencies,\n  scheduleTime,\n  matchUp,\n  details,\n}: CheckRecoveryTimeArgs) {\n  const participantIdDependencies = (\n    matchUpDependencies?.[matchUp.matchUpId]?.participantIds || []\n  ).flat();\n\n  const averageMatchUpMinutes =\n    details?.minutesMap?.[matchUp.matchUpId]?.averageMinutes || 0;\n  const recoveryMinutes =\n    details?.minutesMap?.[matchUp.matchUpId]?.recoveryMinutes || 0;\n\n  const sufficientTimeForIndiiduals = participantIdDependencies.every(\n    (participantId) => {\n      checkParticipantProfileInitialization({\n        individualParticipantProfiles,\n        participantId,\n      });\n\n      const profile = individualParticipantProfiles[participantId];\n      if (!profile.timeAfterRecovery) return true;\n\n      // details are provided by jinnScheduler and this enables treating a participant's scheduled matchUps as \"bookings\"\n      // if (details && timeBetween < 0) {\n      const endTime = extractTime(matchUp?.schedule?.endTime);\n      const timeAfterRecovery = endTime\n        ? addMinutesToTimeString(endTime, ensureInt(recoveryMinutes))\n        : addMinutesToTimeString(\n            scheduleTime,\n            ensureInt(averageMatchUpMinutes) + ensureInt(recoveryMinutes)\n          );\n\n      const potentialParticipantBookings = Object.keys(\n        profile.potentialBookings\n      )\n        .filter((drawId) => drawId !== matchUp.drawId)\n        .map((drawId) => profile.potentialBookings[drawId])\n        .flat();\n\n      const participantBookings = [\n        ...potentialParticipantBookings,\n        ...profile.bookings,\n      ];\n\n      const timeOverlap = !!participantBookings.find(\n        (booking) =>\n          analyzeScheduleOverlap({ scheduleTime, timeAfterRecovery }, booking)\n            .hasOverlap\n      );\n\n      return !timeOverlap;\n    }\n  );\n\n  const notBeforeTime = matchUpNotBeforeTimes[matchUp.matchUpId];\n  const timeBetweenMatchUps = notBeforeTime\n    ? minutesDifference(\n        timeToDate(notBeforeTime),\n        timeToDate(scheduleTime),\n        false\n      )\n    : 0;\n  const sufficientTimeBetweenMatchUps = timeBetweenMatchUps >= 0;\n\n  const enoughTime =\n    sufficientTimeForIndiiduals && sufficientTimeBetweenMatchUps;\n\n  return { enoughTime };\n}\n","import { definedAttributes } from '../../../../utilities/definedAttributes';\nimport { timeStringMinutes } from '../../../../utilities/dateTime';\n\nexport function analyzeScheduleOverlap(a, b) {\n  const startA = timeStringMinutes(a.scheduleTime);\n  const endA = timeStringMinutes(a.timeAfterRecovery);\n  const startB = timeStringMinutes(b.scheduleTime);\n  const endB = timeStringMinutes(b.timeAfterRecovery);\n\n  const startOrEndEquivalence = startA === startB || endA === endB;\n  const startAisContained = startA > startB && startA < endB;\n  const startBisContained = startB > startA && startB < endA;\n  const endAisContained = endA > startB && endA < endB;\n  const endBisContained = endB > startA && endB < endA;\n\n  const hasOverlap =\n    startOrEndEquivalence ||\n    startAisContained ||\n    endAisContained ||\n    startBisContained ||\n    endBisContained;\n\n  return definedAttributes(\n    {\n      hasOverlap,\n      startAisContained,\n      endAisContained,\n      startBisContained,\n      endBisContained,\n    },\n    true\n  );\n}\n","import { checkParticipantProfileInitialization } from './checkParticipantProfileInitialization';\nimport { getIndividualParticipantIds } from './getIndividualParticipantIds';\nimport { unique } from '../../../../utilities/arrays';\n\nimport { TOTAL } from '../../../../constants/scheduleConstants';\n\n/**\n * @param {object} matchUp\n * @param {object} matchUpDailyLimits - { SINGLES, DOUBLES, TOTAL } - counters\n * @param {string[]} matchUpPotentialParticipantIds - participantIds are attributes { [participantId]: { counters: { SINGLES, DOUBLES, TOTAL }}}\n * @param {object} individualParticipantProfiles - participantIds are attributes { [participantId]: { counters: { SINGLES, DOUBLES, TOTAL }}}\n * @returns {string[]} participantIdsAtLimit - array of participantIds who are at or beyond daily matchUp limit\n * @returns {string[]} relevantParticipantIds - array of participantIds relevant to current matchUp\n * @modifies individualParticipantProfiles - increments counters\n */\nexport function checkDailyLimits({\n  individualParticipantProfiles,\n  matchUpPotentialParticipantIds,\n  matchUpDailyLimits = {},\n  matchUp,\n}) {\n  const { matchUpId, matchUpType } = matchUp;\n  const { enteredIndividualParticipantIds } =\n    getIndividualParticipantIds(matchUp);\n\n  // don't include potentials if matchUp is in round robin\n  // this is because potentials uses { sidesTo } attribute which must be present for other calculations\n  const potentialParticipantIds = (\n    (matchUp.roundPosition && matchUpPotentialParticipantIds[matchUpId]) ||\n    []\n  ).flat();\n\n  const relevantParticipantIds = unique(\n    enteredIndividualParticipantIds.concat(...potentialParticipantIds)\n  );\n\n  relevantParticipantIds.forEach((participantId) => {\n    checkParticipantProfileInitialization({\n      individualParticipantProfiles,\n      participantId,\n    });\n  });\n\n  const participantIdsAtLimit = relevantParticipantIds.filter(\n    (participantId) => {\n      const profile = individualParticipantProfiles[participantId];\n      if (profile) {\n        return [matchUpType, TOTAL].find((counterName) => {\n          const participantsCount = profile.counters?.[counterName] || 0;\n          const dailyLimit = matchUpDailyLimits[counterName] || 0;\n          return (\n            participantsCount && dailyLimit && participantsCount >= dailyLimit\n          );\n        });\n      }\n    }\n  );\n\n  return { participantIdsAtLimit, relevantParticipantIds };\n}\n","import { getMatchUpDependencies } from '../../../query/matchUps/getMatchUpDependencies';\nimport { addMatchUpScheduleItems } from './scheduleItems';\nimport { findDrawDefinition } from '../../../acquire/findDrawDefinition';\nimport { allTournamentMatchUps } from '../../../query/matchUps/getAllTournamentMatchUps';\nimport { allDrawMatchUps } from '../../../query/matchUps/getAllDrawMatchUps';\n\nimport { Tournament } from '../../../types/tournamentTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  MISSING_SCHEDULE,\n  MISSING_MATCHUP_IDS,\n  MISSING_TOURNAMENT_RECORD,\n  ErrorType,\n} from '../../../constants/errorConditionConstants';\nimport {\n  BYE,\n  completedMatchUpStatuses,\n} from '../../../constants/matchUpStatusConstants';\n\ntype BulkScheduleMachUpsArgs = {\n  tournamentRecords?: { [key: string]: Tournament };\n  scheduleCompletedMatchUps?: boolean;\n  tournamentRecord?: Tournament;\n  scheduleByeMatchUps?: boolean;\n  errorOnAnachronism?: boolean;\n  removePriorValues?: boolean;\n  checkChronology?: boolean;\n  matchUpDependencies?: any;\n  matchUpIds?: string[];\n  matchUpDetails?: any;\n  schedule?: any;\n};\n\nexport function bulkScheduleTournamentMatchUps({\n  scheduleCompletedMatchUps = false,\n  scheduleByeMatchUps = false,\n  errorOnAnachronism = false,\n  checkChronology = true,\n  matchUpDependencies,\n  removePriorValues,\n  tournamentRecords,\n  tournamentRecord,\n  matchUpDetails,\n  matchUpIds,\n  schedule,\n}: BulkScheduleMachUpsArgs): {\n  error?: ErrorType;\n  scheduled?: number;\n  warnings?: any[];\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!matchUpDetails && (!matchUpIds || !Array.isArray(matchUpIds)))\n    return { error: MISSING_MATCHUP_IDS };\n\n  if (!matchUpDetails && (!schedule || typeof schedule !== 'object'))\n    return { error: MISSING_SCHEDULE };\n\n  let inContextMatchUps;\n  const warnings: any[] = [];\n  let scheduled = 0;\n\n  // Optimize getting matchUps for all tournamentRecords\n  // if matchUpDependencies are provided, skip this step\n  if (checkChronology && !matchUpDependencies) {\n    const result = getMatchUpDependencies({\n      tournamentRecords,\n      tournamentRecord,\n    });\n    matchUpDependencies = result.matchUpDependencies;\n    inContextMatchUps = result.matchUps;\n  }\n\n  // Optimize getting matchUps for all tournamentRecords\n  // if inContextMatchUps retrieved in previous step, skip this step\n  if (!inContextMatchUps) {\n    inContextMatchUps =\n      allTournamentMatchUps({\n        tournamentRecord,\n      })?.matchUps ?? [];\n  }\n\n  // first organize matchUpIds by drawId\n  const drawIdMap = inContextMatchUps.reduce((drawIdMap, matchUp) => {\n    const { matchUpId, drawId, matchUpStatus } = matchUp;\n    if (\n      (scheduleByeMatchUps || matchUpStatus !== BYE) &&\n      (scheduleCompletedMatchUps ||\n        !completedMatchUpStatuses.includes(matchUpStatus))\n    ) {\n      if (drawIdMap[drawId]) {\n        drawIdMap[drawId].push(matchUpId);\n      } else {\n        drawIdMap[drawId] = [matchUpId];\n      }\n    }\n    return drawIdMap;\n  }, {});\n\n  const detailMatchUpIds = matchUpDetails?.map((detail) => detail.matchUpId);\n\n  for (const drawId of Object.keys(drawIdMap)) {\n    const { drawDefinition } = findDrawDefinition({\n      tournamentRecord,\n      drawId,\n    });\n    if (!drawDefinition) continue;\n\n    const drawMatchUpIds = drawIdMap[drawId].filter(\n      (matchUpId) =>\n        matchUpIds?.includes(matchUpId) ?? detailMatchUpIds?.includes(matchUpId)\n    );\n\n    // optimize matchUp retrieval\n    const drawMatchUps = allDrawMatchUps({\n      inContext: false,\n      drawDefinition,\n    }).matchUps;\n\n    for (const matchUpId of drawMatchUpIds) {\n      const matchUpSchedule =\n        matchUpDetails?.find((details) => details.matchUpId === matchUpId)\n          ?.schedule || schedule;\n      const result = addMatchUpScheduleItems({\n        schedule: matchUpSchedule,\n        matchUpDependencies,\n        errorOnAnachronism,\n        removePriorValues,\n        inContextMatchUps,\n        tournamentRecords,\n        tournamentRecord,\n        checkChronology,\n        drawDefinition,\n        drawMatchUps,\n        matchUpId,\n      });\n      if (result?.warnings?.length) warnings.push(...result.warnings);\n      if (result?.success) scheduled += 1;\n      if (result.error) return result;\n    }\n  }\n\n  return warnings.length\n    ? { ...SUCCESS, scheduled, warnings }\n    : { ...SUCCESS, scheduled };\n}\n","import { getMatchUpDependencies } from '../../../query/matchUps/getMatchUpDependencies';\nimport { checkRequiredParameters } from '../../../parameters/checkRequiredParameters';\nimport { bulkScheduleTournamentMatchUps } from './bulkScheduleTournamentMatchUps';\nimport { getMatchUpId } from '../../../global/functions/extractors';\n\nimport { ARRAY, INVALID, OF_TYPE, ONE_OF, TOURNAMENT_RECORDS } from '../../../constants/attributeConstants';\nimport { INVALID_VALUES, MISSING_VALUE } from '../../../constants/errorConditionConstants';\nimport { Tournament } from '../../../types/tournamentTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\ntype BulkScheduleMatchUpsArgs = {\n  tournamentRecords: { [key: string]: Tournament };\n  scheduleCompletedMatchUps?: boolean;\n  tournamentRecord?: Tournament;\n  scheduleByeMatchUps?: boolean;\n  errorOnAnachronism?: boolean;\n  removePriorValues?: boolean;\n  checkChronology?: boolean;\n  matchUpContextIds?: any;\n  matchUpIds?: string[];\n  matchUpDetails: any;\n  schedule?: any;\n};\nexport function bulkScheduleMatchUps(params: BulkScheduleMatchUpsArgs) {\n  const {\n    scheduleCompletedMatchUps = false,\n    scheduleByeMatchUps = false,\n    errorOnAnachronism,\n    matchUpContextIds,\n    removePriorValues,\n    tournamentRecords,\n    checkChronology,\n    matchUpDetails,\n    schedule,\n  } = params;\n\n  if (params.matchUpIds && !matchUpContextIds) return bulkScheduleTournamentMatchUps(params);\n\n  const paramsCheck = checkRequiredParameters(params, [\n    { [TOURNAMENT_RECORDS]: true },\n    {\n      [ONE_OF]: { matchUpContextIds: false, matchUpDetails: false },\n      [INVALID]: INVALID_VALUES,\n      [OF_TYPE]: ARRAY,\n    },\n  ]);\n  if (paramsCheck.error) return paramsCheck;\n\n  if ((!matchUpDetails || matchUpContextIds) && !schedule)\n    return { error: MISSING_VALUE, info: 'schedule is required' };\n\n  const warnings: any[] = [];\n  let scheduled = 0;\n\n  const { matchUpDependencies } = getMatchUpDependencies({\n    tournamentRecords,\n  });\n\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const { tournamentId } = tournamentRecord;\n    const matchUpIds = matchUpContextIds\n      ?.filter((contextIds) => contextIds.tournamentId === tournamentId)\n      .map(getMatchUpId);\n\n    const tournamentMatchUpDetails = matchUpDetails?.filter((details) => details?.tournamentId === tournamentId);\n\n    if (matchUpIds?.length || tournamentMatchUpDetails?.length) {\n      const result = bulkScheduleTournamentMatchUps({\n        matchUpDetails: tournamentMatchUpDetails,\n        scheduleCompletedMatchUps,\n        scheduleByeMatchUps,\n        matchUpDependencies,\n        errorOnAnachronism,\n        removePriorValues,\n        tournamentRecords,\n        tournamentRecord,\n        checkChronology,\n        matchUpIds,\n        schedule,\n      });\n      if (result.warnings?.length) warnings.push(...result.warnings);\n      if (result.scheduled) scheduled += result.scheduled;\n      if (result.error) return result;\n    }\n  }\n\n  return warnings.length ? { ...SUCCESS, scheduled, warnings } : { ...SUCCESS, scheduled };\n}\n","import { addTournamentTimeItem } from '../../../timeItems/addTimeItem';\nimport { addNotice } from '../../../../global/state/globalState';\n\nimport { AUTO_SCHEDULING_AUDIT } from '../../../../constants/auditConstants';\nimport { AUDIT } from '../../../../constants/topicConstants';\n\nexport function auditAutoScheduling({\n  autoSchedulingAudit,\n  tournamentRecords,\n}) {\n  addNotice({ topic: AUDIT, payload: autoSchedulingAudit });\n\n  const getCount = (obj) => {\n    if (!obj) return 0;\n    const values: any[] = Object.values(obj);\n    return values.reduce((count, value) => count + value.length || 0, 0);\n  };\n\n  const profileRoundsCount = (\n    autoSchedulingAudit?.schedulingProfile || []\n  ).reduce(\n    (count, dateProfile) =>\n      count +\n      dateProfile.venues.reduce((vc, venue) => vc + venue.rounds.length, 0),\n    0\n  );\n\n  const itemValue = {\n    scheduledDatesCount: autoSchedulingAudit.scheduledDates?.length,\n    noTimeMatchUpIdsCount: getCount(autoSchedulingAudit?.noTimeMatchUpIds),\n    scheduledMatchUpIdsCount: getCount(\n      autoSchedulingAudit?.scheduledMatchUpIds\n    ),\n    overLimitMatchUpIdsCount: getCount(\n      autoSchedulingAudit?.overLimitMatchUpIds\n    ),\n    requestConflictsCount: getCount(autoSchedulingAudit?.requestConflicts),\n    profileRoundsCount,\n  };\n  const timeItem = {\n    itemType: AUTO_SCHEDULING_AUDIT,\n    itemValue,\n  };\n\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    addTournamentTimeItem({ tournamentRecord, timeItem });\n  }\n}\n","import { checkRequiredParameters } from '../../../parameters/checkRequiredParameters';\nimport { findExtension } from '../../../acquire/findExtension';\n\nimport { TOURNAMENT_RECORDS } from '../../../constants/attributeConstants';\nimport { PERSON_REQUESTS } from '../../../constants/extensionConstants';\nimport { ErrorType } from '../../../constants/errorConditionConstants';\nimport { PersonRequests } from '../../../types/factoryTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { Tournament } from '../../../types/tournamentTypes';\n\ntype GetPersonRequestsArgs = {\n  tournamentRecords: { [key: string]: Tournament };\n  requestType?: string;\n};\nexport function getPersonRequests(params: GetPersonRequestsArgs): {\n  personRequests?: PersonRequests;\n  error?: ErrorType;\n} {\n  const { tournamentRecords, requestType } = params;\n\n  const paramsCheck = checkRequiredParameters(params, [{ [TOURNAMENT_RECORDS]: true }]);\n  if (paramsCheck.error) return paramsCheck;\n\n  const personRequests: PersonRequests = {};\n\n  // create merged view of person requests across tournamentRecords\n  // ... possible for a person to be in multiple linked tournamentRecords\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const { extension } = findExtension({\n      element: tournamentRecord,\n      name: PERSON_REQUESTS,\n    });\n\n    const requestObjects = extension?.value || [];\n\n    for (const requestObject of requestObjects) {\n      const { personId, requests } = requestObject || {};\n\n      if (!personRequests[personId]) personRequests[personId] = [];\n      for (const request of requests) {\n        if (requestType && request.requestType !== requestType) continue;\n\n        personRequests[personId].push(request);\n      }\n    }\n  }\n\n  // audit requests and filter out any that are no longer relevant\n  // (tournament dates changed & etc)\n\n  return { personRequests, ...SUCCESS };\n}\n","import { getCourtDateAvailability } from '../../../../../query/venues/getCourtDateAvailability';\nimport { generateTimeSlots } from '../../../../../assemblies/generators/scheduling/generateTimeSlots';\nimport { getDateTimeBoundary } from './getTimeBoundary';\nimport {\n  extractTime,\n  minutesDifference,\n  timeToDate,\n} from '../../../../../utilities/dateTime';\n\nimport { MISSING_VALUE } from '../../../../../constants/errorConditionConstants';\n\ntype GetEarliestCourtTimeArgs = {\n  averageMinutes: number;\n  startTime?: string;\n  endTime?: string;\n  court: any;\n  date: string;\n};\nexport function getEarliestCourtTime({\n  averageMinutes,\n  startTime,\n  endTime,\n  court,\n  date,\n}: GetEarliestCourtTimeArgs) {\n  if (!Array.isArray(court.dateAvailability))\n    return { error: MISSING_VALUE, stack: 'getEarliestCourtTime' };\n\n  const courtStartTime = getDateTimeBoundary({\n    scheduleDate: date,\n    courts: [court],\n    startTime: true,\n  });\n  const courtEndTime = getDateTimeBoundary({\n    scheduleDate: date,\n    courts: [court],\n    endTime: true,\n  });\n\n  startTime = startTime || courtStartTime;\n  endTime = endTime || courtEndTime;\n\n  const courtDate = getCourtDateAvailability({ court, date });\n  const timeSlots = generateTimeSlots({ courtDate });\n  const dateStartTime = timeToDate(startTime);\n  const dateEndTime = timeToDate(endTime);\n\n  const earliestCourtTime = timeSlots.reduce((first, timeSlot) => {\n    const timeSlotStartTime = timeToDate(timeSlot.startTime);\n    const timeSlotEndTime = timeToDate(timeSlot.endTime);\n    if (timeSlotStartTime > dateEndTime || timeSlotEndTime < dateStartTime) {\n      return first;\n    }\n    const consideredStartTime =\n      dateStartTime > timeSlotStartTime ? dateStartTime : timeSlotStartTime;\n    const timeSlotMinutes = minutesDifference(\n      consideredStartTime,\n      timeSlotEndTime\n    );\n    const available = timeSlotMinutes >= averageMinutes;\n    if (available) {\n      const timeString = extractTime(consideredStartTime.toISOString());\n      if (!first || timeString < first) first = timeString;\n    }\n    return first;\n  }, undefined);\n\n  return { earliestCourtTime, courtStartTime, courtEndTime };\n}\n","import { resolveTournamentRecords } from '../../../parameters/resolveTournamentRecords';\nimport { completedMatchUpStatuses } from '../../../constants/matchUpStatusConstants';\nimport { hasSchedule } from './scheduleMatchUps/hasSchedule';\nimport { allTournamentMatchUps } from '../../../query/matchUps/getAllTournamentMatchUps';\nimport { getMatchUpId } from '../../../global/functions/extractors';\nimport { isObject } from '../../../utilities/objects';\n\nimport { MatchUpStatusUnion, Tournament } from '../../../types/tournamentTypes';\nimport { TournamentRecords } from '../../../types/factoryTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  ErrorType,\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../../constants/errorConditionConstants';\nimport {\n  ALLOCATE_COURTS,\n  ASSIGN_COURT,\n  ASSIGN_VENUE,\n  SCHEDULED_DATE,\n  SCHEDULED_TIME,\n} from '../../../constants/timeItemConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\n\ntype ClearScheduledMatchUpsArgs = {\n  ignoreMatchUpStatuses?: MatchUpStatusUnion[];\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  scheduleAttributes?: string[];\n  scheduledDates: string[];\n  venueIds?: string[];\n};\nexport function clearScheduledMatchUps(\n  params: ClearScheduledMatchUpsArgs\n): ResultType & {\n  clearedScheduleCount?: number;\n} {\n  const {\n    scheduleAttributes = ['scheduledDate', 'scheduledTime'],\n    ignoreMatchUpStatuses = completedMatchUpStatuses,\n    scheduledDates,\n    venueIds,\n  } = params;\n\n  const tournamentRecords = resolveTournamentRecords(params);\n\n  const tournamentIds = isObject(tournamentRecords)\n    ? Object.values(tournamentRecords)\n        .map(({ tournamentId }) => tournamentId)\n        .filter(Boolean)\n    : [];\n  if (!tournamentIds?.length) return { error: MISSING_TOURNAMENT_RECORDS };\n\n  let clearedScheduleCount = 0;\n  for (const tournamentId of tournamentIds) {\n    const tournamentRecord = tournamentRecords[tournamentId];\n    const result = clearSchedules({\n      ignoreMatchUpStatuses,\n      scheduleAttributes,\n      tournamentRecord,\n      scheduledDates,\n      venueIds,\n    });\n    if (result.error) return result;\n    clearedScheduleCount += result.clearedScheduleCount || 0;\n  }\n\n  return { ...SUCCESS, clearedScheduleCount };\n}\n\nfunction clearSchedules({\n  scheduleAttributes = ['scheduledDate', 'scheduledTime'],\n  ignoreMatchUpStatuses = completedMatchUpStatuses,\n  tournamentRecord,\n  scheduledDates,\n  venueIds = [],\n}: ClearScheduledMatchUpsArgs): {\n  clearedScheduleCount?: number;\n  success?: boolean;\n  error?: ErrorType;\n} {\n  if (typeof tournamentRecord !== 'object')\n    return { error: MISSING_TOURNAMENT_RECORD };\n\n  if (!Array.isArray(ignoreMatchUpStatuses) || !Array.isArray(venueIds)) {\n    return { error: INVALID_VALUES };\n  }\n  if (venueIds.length) scheduleAttributes.push('venueId');\n\n  const inContextMatchUps =\n    allTournamentMatchUps({\n      matchUpFilters: { scheduledDates },\n      tournamentRecord,\n    }).matchUps ?? [];\n\n  const relevantMatchUpIds = inContextMatchUps\n    .filter(\n      (matchUp) =>\n        matchUp.matchUpStatus &&\n        !ignoreMatchUpStatuses.includes(matchUp.matchUpStatus) &&\n        hasSchedule({ schedule: matchUp.schedule, scheduleAttributes }) &&\n        (!venueIds?.length || venueIds.includes(matchUp.schedule.venueId))\n    )\n    .map(getMatchUpId);\n\n  const matchUps =\n    allTournamentMatchUps({\n      tournamentRecord,\n      inContext: false,\n    }).matchUps ?? [];\n\n  let clearedScheduleCount = 0;\n  for (const matchUp of matchUps) {\n    if (relevantMatchUpIds.includes(matchUp.matchUpId)) {\n      matchUp.timeItems = (matchUp.timeItems ?? []).filter(\n        (timeItem) =>\n          timeItem?.itemType &&\n          ![\n            ALLOCATE_COURTS,\n            ASSIGN_COURT,\n            ASSIGN_VENUE,\n            SCHEDULED_DATE,\n            SCHEDULED_TIME,\n          ].includes(timeItem?.itemType)\n      );\n      clearedScheduleCount += 1;\n    }\n  }\n\n  return { ...SUCCESS, clearedScheduleCount };\n}\n","import { getContainedStructures } from '../../../query/drawDefinition/getContainedStructures';\nimport { allCompetitionMatchUps } from '../../../query/matchUps/getAllCompetitionMatchUps';\nimport { getMatchUpDependencies } from '../../../query/matchUps/getMatchUpDependencies';\nimport { getMatchUpDailyLimits } from '../../../query/extensions/getMatchUpDailyLimits';\nimport { checkRequiredParameters } from '../../../parameters/checkRequiredParameters';\nimport { getVenuesAndCourts } from '../../../query/venues/venuesAndCourtsGetter';\nimport { extractDate, isValidDateString } from '../../../utilities/dateTime';\nimport { getSchedulingProfile } from '../../tournaments/schedulingProfile';\nimport { jinnScheduler } from './schedulers/jinnScheduler/jinnScheduler';\nimport { getPersonRequests } from '../../../query/matchUps/scheduling/getPersonRequests';\nimport { v2Scheduler } from './schedulers/v2Scheduler/v2Scheduler';\nimport { clearScheduledMatchUps } from './clearScheduledMatchUps';\n\nimport { NO_VALID_DATES } from '../../../constants/errorConditionConstants';\nimport { DO_NOT_SCHEDULE } from '../../../constants/requestConstants';\nimport { DOUBLES, SINGLES } from '../../../constants/matchUpTypes';\nimport { TournamentRecords } from '../../../types/factoryTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { ARRAY, OF_TYPE, SCHEDULE_DATES, TOURNAMENT_RECORDS, VALIDATE } from '../../../constants/attributeConstants';\n\ntype ScheduleProfileRoundsArgs = {\n  checkPotentialRequestConflicts?: boolean;\n  tournamentRecords: TournamentRecords;\n  scheduleCompletedMatchUps?: boolean;\n  clearScheduleDates?: boolean;\n  scheduleDates?: string[];\n  periodLength?: number;\n  useGarman?: boolean;\n  dryRun?: boolean;\n  pro?: boolean;\n};\n// abstraction layer to allow other schedulers to be defined at a later time\nexport function scheduleProfileRounds(params: ScheduleProfileRoundsArgs) {\n  const {\n    checkPotentialRequestConflicts = true,\n    scheduleCompletedMatchUps,\n    clearScheduleDates,\n    scheduleDates = [],\n    tournamentRecords,\n    periodLength,\n    useGarman,\n    dryRun,\n    pro,\n  } = params;\n\n  const paramsCheck = checkRequiredParameters(params, [\n    { [TOURNAMENT_RECORDS]: true },\n    {\n      [VALIDATE]: (value) => !value || (Array.isArray(value) && value.every(isValidDateString)),\n      [SCHEDULE_DATES]: false,\n      [OF_TYPE]: ARRAY,\n    },\n  ]);\n  if (paramsCheck.error) return paramsCheck;\n\n  const result = getSchedulingProfile({ tournamentRecords });\n  if (result.error) return result;\n\n  if (!result.schedulingProfile.length) return { ...SUCCESS };\n\n  const {\n    modifications: schedulingProfileModifications,\n    issues: schedulingProfileIssues = [],\n    schedulingProfile = [],\n  } = result;\n\n  // round robin structures contain other structures and the scheduler\n  // needs to reference the containing structure by contained structureIds\n  const containedStructureIds = Object.assign(\n    {},\n    ...Object.values(tournamentRecords).map(\n      (tournamentRecord) => getContainedStructures({ tournamentRecord }).containedStructures,\n    ),\n  );\n\n  // ensure all scheduleDates are valid date strings\n  const validScheduleDates = scheduleDates\n    .map((scheduleDate) => {\n      if (!isValidDateString(scheduleDate)) return;\n      return extractDate(scheduleDate);\n    })\n    .filter(Boolean);\n\n  // filter out any invalid scheduleDates in schedulingProfile\n  const profileDates = schedulingProfile\n    .map((dateSchedulingProfile) => dateSchedulingProfile.scheduleDate)\n    .map((scheduleDate) => isValidDateString(scheduleDate) && extractDate(scheduleDate))\n    .filter((scheduleDate) => scheduleDate && (!scheduleDates.length || validScheduleDates.includes(scheduleDate)));\n\n  // if no valid profileDates remain throw an error\n  if (!profileDates.length) {\n    return { error: NO_VALID_DATES };\n  }\n\n  // if array of clearScheduleDates, clear all matchUps on scheduledDates\n  if (clearScheduleDates && !dryRun) {\n    const scheduledDates = Array.isArray(clearScheduleDates) ? clearScheduleDates : [];\n    clearScheduledMatchUps({ tournamentRecords, scheduledDates });\n  }\n\n  const courts = getVenuesAndCourts({\n    ignoreDisabled: false,\n    tournamentRecords,\n  }).courts as any[];\n\n  const { matchUps } = allCompetitionMatchUps({\n    matchUpFilters: { matchUpTypes: [SINGLES, DOUBLES] },\n    afterRecoveryTimes: true,\n    nextMatchUps: true,\n    tournamentRecords,\n  });\n\n  // build up a map of all matchUp dependencies\n  const { matchUpDependencies } = getMatchUpDependencies({\n    includeParticipantDependencies: true,\n    tournamentRecords,\n    matchUps,\n  });\n\n  const { matchUpDailyLimits } = getMatchUpDailyLimits({ tournamentRecords });\n\n  const { personRequests } = getPersonRequests({\n    requestType: DO_NOT_SCHEDULE,\n    tournamentRecords,\n  });\n\n  // filter out any dates in schedulingProfile which have been excluded and sort\n  const dateSchedulingProfiles = schedulingProfile\n    .filter((dateschedulingProfile) => {\n      const scheduleDate = extractDate(dateschedulingProfile?.scheduleDate);\n      return profileDates.includes(scheduleDate);\n    })\n    .sort((a, b) => {\n      return new Date(a.scheduleDate).getTime() - new Date(b.scheduleDate).getTime();\n    });\n\n  const schedulingParams = {\n    schedulingProfileModifications,\n    checkPotentialRequestConflicts,\n    scheduleCompletedMatchUps,\n    schedulingProfileIssues,\n    dateSchedulingProfiles,\n    containedStructureIds,\n    matchUpDependencies,\n    matchUpDailyLimits,\n    clearScheduleDates,\n    tournamentRecords,\n    schedulingProfile,\n    personRequests,\n    periodLength,\n    useGarman,\n    matchUps,\n    dryRun,\n    courts,\n  };\n\n  if (pro) {\n    return v2Scheduler(schedulingParams);\n  } else {\n    return jinnScheduler(schedulingParams);\n  }\n}\n","import { addMatchUpScheduledTime } from '../../scheduledTime';\nimport { assignMatchUpCourt } from '../../assignMatchUpCourt';\nimport { checkDependenciesScheduled } from '../../scheduleMatchUps/checkDependenciesScheduled';\nimport { findDrawDefinition } from '../../../../../acquire/findDrawDefinition';\nimport { updateTimeAfterRecovery } from '../../scheduleMatchUps/updateTimeAfterRecovery';\nimport { checkDependendantTiming } from '../../scheduleMatchUps/checkDependentTiming';\nimport { checkRequestConflicts } from '../../scheduleMatchUps/checkRequestConflicts';\nimport { processNextMatchUps } from '../../scheduleMatchUps/processNextMatchUps';\nimport { getVenueSchedulingDetails } from '../../../../../query/matchUps/scheduling/getVenueSchedulingDetails';\nimport { checkRecoveryTime } from '../../scheduleMatchUps/checkRecoveryTime';\nimport { checkDailyLimits } from '../../scheduleMatchUps/checkDailyLimits';\nimport { getMatchUpId } from '../../../../../global/functions/extractors';\nimport { generateVirtualCourts } from '../utils/generateVirtualCourts';\nimport { getEarliestCourtTime } from '../utils/getEarliestCourtTime';\nimport { bulkScheduleMatchUps } from '../../bulkScheduleMatchUps';\nimport { auditAutoScheduling } from '../auditAutoScheduling';\nimport { generateBookings } from '../utils/generateBookings';\nimport {\n  addMinutesToTimeString,\n  extractDate,\n  sameDay,\n  timeStringMinutes,\n  timeToDate,\n  zeroPad,\n} from '../../../../../utilities/dateTime';\n\nimport { HydratedCourt, HydratedMatchUp } from '../../../../../types/hydrated';\nimport { SUCCESS } from '../../../../../constants/resultConstants';\nimport { TOTAL } from '../../../../../constants/scheduleConstants';\nimport {\n  PersonRequests,\n  TournamentRecords,\n} from '../../../../../types/factoryTypes';\n\n// NOTE: non-Garman scheduling\n\ntype V2Scheduler = {\n  matchUpDependencies: { [key: string]: any };\n  checkPotentialRequestConflicts?: boolean;\n  tournamentRecords: TournamentRecords;\n  scheduleCompletedMatchUps?: boolean;\n  schedulingProfileModifications: any;\n  personRequests?: PersonRequests;\n  containedStructureIds: string[];\n  schedulingProfileIssues?: any[];\n  dateSchedulingProfiles: any[];\n  matchUps?: HydratedMatchUp[];\n  clearScheduleDates?: boolean;\n  matchUpDailyLimits?: any;\n  courts: HydratedCourt[];\n  schedulingProfile?: any;\n  periodLength?: number;\n  dryRun?: boolean;\n};\n\nexport function v2Scheduler({\n  schedulingProfileModifications,\n  checkPotentialRequestConflicts,\n  scheduleCompletedMatchUps, // override which can be used by mocksEngine\n  schedulingProfileIssues,\n  dateSchedulingProfiles,\n  containedStructureIds,\n  matchUpDependencies,\n  matchUpDailyLimits,\n  clearScheduleDates,\n  tournamentRecords,\n  periodLength = 30,\n  schedulingProfile,\n  personRequests,\n  matchUps = [],\n  courts,\n  dryRun,\n}: V2Scheduler) {\n  const recoveryTimeDeferredMatchUpIds = {};\n  const dependencyDeferredMatchUpIds = {};\n  const scheduleDateRequestConflicts = {};\n  const matchUpScheduleCourtIds = {};\n  const matchUpScheduleTimes = {};\n  const scheduledMatchUpIds = {};\n  const overLimitMatchUpIds = {};\n  const noTimeMatchUpIds = {};\n  const requestConflicts = {};\n\n  // Start SCHEDULING\n  for (const dateSchedulingProfile of dateSchedulingProfiles ?? []) {\n    const scheduleDate = extractDate(dateSchedulingProfile?.scheduleDate);\n    const venues = dateSchedulingProfile?.venues || [];\n    const matchUpPotentialParticipantIds = {};\n    const individualParticipantProfiles = {};\n\n    const bumpLimits = (relevantParticipantIds, matchUpType) => {\n      relevantParticipantIds.forEach((participantId) => {\n        const counters = individualParticipantProfiles[participantId].counters;\n        if (counters[matchUpType]) counters[matchUpType] += 1;\n        else counters[matchUpType] = 1;\n        if (counters[TOTAL]) counters[TOTAL] += 1;\n        else counters[TOTAL] = 1;\n      });\n    };\n\n    recoveryTimeDeferredMatchUpIds[scheduleDate] = {};\n    dependencyDeferredMatchUpIds[scheduleDate] = {};\n    scheduledMatchUpIds[scheduleDate] = []; // will not be in scheduled order\n    overLimitMatchUpIds[scheduleDate] = [];\n    noTimeMatchUpIds[scheduleDate] = [];\n    requestConflicts[scheduleDate] = [];\n\n    // Build up matchUpNotBeforeTimes for all matchUps already scheduled on scheduleDate\n    const matchUpNotBeforeTimes = {};\n    matchUps?.forEach((matchUp) => {\n      if (\n        matchUp.schedule?.scheduledDate &&\n        sameDay(scheduleDate, extractDate(matchUp.schedule.scheduledDate))\n      ) {\n        processNextMatchUps({\n          matchUpPotentialParticipantIds,\n          matchUpNotBeforeTimes,\n          matchUp,\n        });\n      }\n    });\n\n    const {\n      allDateScheduledByeMatchUpDetails,\n      allDateScheduledMatchUpIds,\n      venueScheduledRoundDetails,\n      allDateMatchUpIds,\n    } = getVenueSchedulingDetails({\n      matchUpPotentialParticipantIds,\n      individualParticipantProfiles,\n      scheduleCompletedMatchUps,\n      containedStructureIds,\n      matchUpNotBeforeTimes,\n      matchUpScheduleTimes,\n      matchUpDependencies,\n      clearScheduleDates,\n      tournamentRecords,\n      periodLength,\n      scheduleDate,\n      matchUps,\n      courts,\n      venues,\n    });\n    const dateScheduledMatchUps = matchUps?.filter(({ matchUpId }) =>\n      allDateScheduledMatchUpIds.includes(matchUpId)\n    );\n\n    const { bookings } = generateBookings({\n      dateScheduledMatchUps,\n      tournamentRecords,\n      scheduleDate,\n      periodLength,\n    });\n\n    const { virtualCourts: dateCourts } = generateVirtualCourts({\n      scheduleDate,\n      periodLength,\n      bookings,\n      courts,\n    });\n\n    const venueTimeBoundaries = dateCourts?.reduce((timeBoundaries, court) => {\n      const { earliestCourtTime, courtEndTime } = getEarliestCourtTime({\n        date: scheduleDate,\n        averageMinutes: 0,\n        court,\n      });\n\n      if (\n        !timeBoundaries.startTime ||\n        timeToDate(earliestCourtTime) < timeToDate(timeBoundaries.startTime)\n      ) {\n        timeBoundaries.startTime = earliestCourtTime;\n      }\n\n      if (\n        !timeBoundaries.endTime ||\n        timeToDate(courtEndTime) > timeToDate(timeBoundaries.endTime)\n      ) {\n        timeBoundaries.endTime = courtEndTime;\n      }\n\n      return timeBoundaries;\n    }, {});\n\n    let venueEarliestCourtTime = venueTimeBoundaries.startTime;\n\n    const addDateCourtBooking = ({ courtId, booking }) =>\n      dateCourts\n        ?.find((court) => court.courtId === courtId)\n        ?.dateAvailability[0].bookings.push(booking);\n\n    const failSafe = 10;\n    let schedulingIterations = 0;\n    let schedulingComplete;\n\n    while (!schedulingComplete) {\n      // for each venue schedule a round\n      for (const { venueId } of venues) {\n        const details = venueScheduledRoundDetails[venueId];\n\n        // on each pass attempt to schedule one matchUp per court\n        // when a matchUp is scheduled, add it to details.dateScheduledMatchUps\n\n        const venuePassFailSafe = details.matchUpsToSchedule.length;\n        const matchUpIdsScheduled: string[] = [];\n        const courtIdsScheduled: string[] = [];\n        let venuePassComplete;\n        let passIterations = 0;\n\n        while (!venuePassComplete) {\n          for (const matchUp of details.matchUpsToSchedule) {\n            if (\n              courtIdsScheduled.length === details.courtsCount ||\n              matchUpIdsScheduled.length === details.courtsCount\n            ) {\n              venuePassComplete = true;\n              break;\n            }\n\n            const { matchUpId, matchUpType } = matchUp;\n\n            const { participantIdsAtLimit, relevantParticipantIds } =\n              checkDailyLimits({\n                matchUpPotentialParticipantIds,\n                individualParticipantProfiles,\n                matchUpDailyLimits,\n                matchUp,\n              });\n\n            if (participantIdsAtLimit.length) {\n              if (!overLimitMatchUpIds[scheduleDate].includes(matchUpId))\n                overLimitMatchUpIds[scheduleDate].push(matchUpId);\n              continue;\n            }\n\n            const { dependenciesScheduled, remainingDependencies } =\n              checkDependenciesScheduled({\n                matchUpScheduleTimes,\n                matchUpDependencies,\n                allDateMatchUpIds,\n                matchUp,\n              });\n\n            if (!dependenciesScheduled) {\n              if (!dependencyDeferredMatchUpIds[scheduleDate][matchUpId])\n                dependencyDeferredMatchUpIds[scheduleDate][matchUpId] = [];\n              dependencyDeferredMatchUpIds[scheduleDate][matchUpId].push({\n                remainingDependencies,\n              });\n              continue;\n            }\n\n            const schedulingConflicts: any[] = [];\n            const courtTime = dateCourts?.reduce((courtTime, court) => {\n              if (courtIdsScheduled.includes(court.courtId)) return courtTime;\n\n              const { earliestCourtTime: scheduleTime } = getEarliestCourtTime({\n                averageMinutes: details.greatestAverageMinutes,\n                startTime: venueEarliestCourtTime,\n                date: scheduleDate,\n                court,\n              });\n\n              if (\n                courtTime.scheduleTime &&\n                timeStringMinutes(scheduleTime) >=\n                  timeStringMinutes(courtTime.scheduleTime)\n              ) {\n                return courtTime;\n              }\n\n              const { scheduledDependent } = checkDependendantTiming({\n                matchUpScheduleTimes,\n                matchUpDependencies,\n                scheduleTime,\n                matchUpId,\n                details,\n              });\n              if (scheduledDependent) return courtTime;\n\n              const { enoughTime } = checkRecoveryTime({\n                individualParticipantProfiles,\n                matchUpNotBeforeTimes,\n                matchUpDependencies,\n                scheduleTime,\n                details,\n                matchUp,\n              });\n\n              if (!enoughTime) {\n                if (!recoveryTimeDeferredMatchUpIds[scheduleDate][matchUpId])\n                  recoveryTimeDeferredMatchUpIds[scheduleDate][matchUpId] = [];\n                if (\n                  !recoveryTimeDeferredMatchUpIds[scheduleDate][\n                    matchUpId\n                  ].includes(scheduleTime)\n                ) {\n                  recoveryTimeDeferredMatchUpIds[scheduleDate][matchUpId].push(\n                    scheduleTime\n                  );\n                }\n                return courtTime;\n              }\n\n              const averageMatchUpMinutes =\n                details.minutesMap?.[matchUpId]?.averageMinutes ||\n                details.greatestAverageMinutes;\n\n              const { conflicts } = checkRequestConflicts({\n                potentials: checkPotentialRequestConflicts,\n                averageMatchUpMinutes,\n                requestConflicts,\n                personRequests,\n                scheduleTime,\n                scheduleDate,\n                matchUp,\n              });\n\n              if (conflicts?.length) {\n                schedulingConflicts.push(...conflicts);\n                return false;\n              }\n\n              bumpLimits(relevantParticipantIds, matchUpType);\n\n              const recoveryMinutes =\n                details.minutesMap?.[matchUpId]?.recoveryMinutes;\n\n              updateTimeAfterRecovery({\n                matchUpPotentialParticipantIds,\n                individualParticipantProfiles,\n                matchUpNotBeforeTimes,\n                averageMatchUpMinutes,\n                matchUpDependencies,\n                recoveryMinutes,\n                scheduleTime,\n                matchUp,\n              });\n\n              if (\n                !courtTime.scheduleTime ||\n                timeStringMinutes(scheduleTime) <\n                  timeStringMinutes(courtTime.scheduleTime)\n              ) {\n                courtTime.averageMatchUpMinutes = averageMatchUpMinutes;\n                courtTime.recoveryMinutes = recoveryMinutes;\n                courtTime.scheduleTime = scheduleTime;\n                courtTime.courtName = court.courtName;\n                courtTime.courtId = court.courtId;\n              }\n\n              return courtTime;\n            }, {});\n\n            if (courtTime.scheduleTime) {\n              const {\n                averageMatchUpMinutes,\n                recoveryMinutes,\n                scheduleTime,\n                courtId,\n              } = courtTime;\n              matchUpScheduleTimes[matchUpId] = scheduleTime;\n              matchUpScheduleCourtIds[matchUpId] = courtId;\n              matchUpIdsScheduled.push(matchUpId);\n              courtIdsScheduled.push(courtId);\n\n              const startTime = scheduleTime;\n              const endTime = addMinutesToTimeString(\n                startTime,\n                averageMatchUpMinutes\n              );\n              const booking = {\n                averageMatchUpMinutes,\n                recoveryMinutes,\n                periodLength,\n                matchUpId,\n                startTime,\n                courtId,\n                endTime,\n                venueId,\n              };\n\n              addDateCourtBooking({ courtId, booking });\n\n              details.matchUpsToSchedule = details.matchUpsToSchedule.filter(\n                (matchUp) => matchUp.matchUpId !== matchUpId\n              );\n            } else if (schedulingConflicts?.length) {\n              if (!scheduleDateRequestConflicts[scheduleDate])\n                scheduleDateRequestConflicts[scheduleDate] = [];\n              scheduleDateRequestConflicts[scheduleDate].push(\n                ...schedulingConflicts\n              );\n            }\n          }\n\n          if (\n            courtIdsScheduled.length === details.courtsCount ||\n            matchUpIdsScheduled.length === details.courtsCount ||\n            !details.matchUpsToSchedule.length\n          ) {\n            venuePassComplete = true;\n          }\n          if (\n            details.matchUpsToSchedule.length &&\n            matchUpIdsScheduled < details.courtsCount\n          ) {\n            if (\n              timeToDate(venueEarliestCourtTime) <\n              timeToDate(venueTimeBoundaries.endTime)\n            ) {\n              venueEarliestCourtTime = addMinutesToTimeString(\n                venueEarliestCourtTime,\n                periodLength\n              );\n            } else {\n              venuePassComplete = true;\n              details.complete = true;\n            }\n          }\n\n          // this is necessary for scenarios where there are more courts than matches which can be scheduled at the same time\n          passIterations += 1;\n          if (!venuePassComplete && passIterations >= venuePassFailSafe) {\n            venuePassComplete = true;\n          }\n        }\n\n        if (!details.matchUpsToSchedule?.length) details.complete = true;\n      }\n\n      schedulingIterations += 1;\n      schedulingComplete =\n        venues.every(\n          ({ venueId }) => venueScheduledRoundDetails[venueId].complete\n        ) || schedulingIterations === failSafe;\n    }\n\n    // assign scheduledTime, venueId and courtId to each matchUp\n    // because this is done in an optimized fashion from hash of assignments\n    // scheduledMatchUpIds[scheduleDate] will not be in the order that scheduleTimes were assigned\n    for (const { venueId } of venues) {\n      const matchUpMap = venueScheduledRoundDetails[venueId].matchUpMap;\n\n      Object.keys(matchUpMap).forEach((tournamentId) => {\n        const tournamentRecord = tournamentRecords[tournamentId];\n        if (tournamentRecord) {\n          Object.keys(matchUpMap[tournamentId]).forEach((drawId) => {\n            const { drawDefinition } = findDrawDefinition({\n              tournamentRecord,\n              drawId,\n            });\n            if (drawDefinition) {\n              const drawMatchUps = matchUpMap[tournamentId][drawId];\n\n              drawMatchUps.forEach(({ matchUpId }) => {\n                const scheduleTime = matchUpScheduleTimes[matchUpId];\n                const courtId = matchUpScheduleCourtIds[matchUpId];\n                if (scheduleTime) {\n                  // must include scheduleDate being scheduled to generate proper ISO string\n                  const formatTime = scheduleTime\n                    .split(':')\n                    .map(zeroPad)\n                    .join(':');\n                  const scheduledTime = `${extractDate(\n                    scheduleDate\n                  )}T${formatTime}`;\n\n                  if (dryRun) {\n                    scheduledMatchUpIds[scheduleDate].push(matchUpId);\n                  } else {\n                    addMatchUpScheduledTime({\n                      drawDefinition,\n                      scheduledTime,\n                      matchUpId,\n                    });\n                    assignMatchUpCourt({\n                      courtDayDate: scheduleDate,\n                      tournamentRecords,\n                      tournamentRecord,\n                      drawDefinition,\n                      matchUpId,\n                      courtId,\n                    });\n                    scheduledMatchUpIds[scheduleDate].push(matchUpId);\n                  }\n                }\n              });\n            }\n          });\n        }\n      });\n\n      noTimeMatchUpIds[scheduleDate] =\n        venueScheduledRoundDetails[venueId].matchUpsToSchedule.map(\n          getMatchUpId\n        );\n    }\n\n    if (!dryRun && allDateScheduledByeMatchUpDetails?.length) {\n      // remove scheduling information for BYE matchUps from any rounds that were scheduled\n      bulkScheduleMatchUps({\n        matchUpDetails: allDateScheduledByeMatchUpDetails,\n        scheduleByeMatchUps: true,\n        removePriorValues: true,\n        tournamentRecords,\n        schedule: {\n          scheduledDate: '',\n          scheduledTime: '',\n          courtOrder: '',\n          courtId: '',\n          venueId: '',\n        },\n      });\n    }\n\n    for (const venue of dateSchedulingProfile.venues) {\n      for (const round of venue.rounds) {\n        const matchUpIds = (round.matchUps ?? []).map(\n          ({ matchUpId }) => matchUpId\n        );\n        const canScheduleMatchUpIds = matchUpIds?.filter((matchUpId) =>\n          scheduledMatchUpIds[scheduleDate].includes(matchUpId)\n        );\n        round.canScheduledMatchUpIds = canScheduleMatchUpIds;\n        let possibleToSchedulePct: any =\n          Math.round(\n            ((canScheduleMatchUpIds?.length || 0) / round.matchUpsCount) * 10000\n          ) / 100;\n        if (possibleToSchedulePct === Infinity || isNaN(possibleToSchedulePct))\n          possibleToSchedulePct = undefined;\n        round.possibleToSchedulePct = possibleToSchedulePct;\n        if (round.matchUpsCount === canScheduleMatchUpIds?.length) {\n          round.possibleToSchedule = true;\n        }\n      }\n    }\n  }\n\n  // returns the original form of the dateStrings, before extractDate()\n  const scheduledDates = (dateSchedulingProfiles ?? []).map(\n    ({ scheduleDate }) => scheduleDate\n  );\n\n  const autoSchedulingAudit = {\n    timeStamp: Date.now(),\n    overLimitMatchUpIds,\n    scheduledMatchUpIds,\n    schedulingProfile,\n    noTimeMatchUpIds,\n    requestConflicts,\n    scheduledDates,\n  };\n\n  auditAutoScheduling({ tournamentRecords, autoSchedulingAudit });\n\n  return {\n    ...SUCCESS,\n    schedulingProfileModifications,\n    schedulingProfileIssues,\n    dateSchedulingProfiles,\n\n    recoveryTimeDeferredMatchUpIds,\n    dependencyDeferredMatchUpIds,\n    matchUpScheduleTimes,\n    overLimitMatchUpIds,\n    scheduledMatchUpIds,\n    noTimeMatchUpIds,\n    requestConflicts,\n    scheduledDates,\n  };\n}\n","import { addMatchUpScheduledTime } from '../../scheduledTime';\nimport { assignMatchUpVenue } from '../../assignMatchUpVenue';\nimport { checkDependenciesScheduled } from '../../scheduleMatchUps/checkDependenciesScheduled';\nimport { findDrawDefinition } from '../../../../../acquire/findDrawDefinition';\nimport { updateTimeAfterRecovery } from '../../scheduleMatchUps/updateTimeAfterRecovery';\nimport { checkDependendantTiming } from '../../scheduleMatchUps/checkDependentTiming';\nimport { checkRequestConflicts } from '../../scheduleMatchUps/checkRequestConflicts';\nimport { processNextMatchUps } from '../../scheduleMatchUps/processNextMatchUps';\nimport { getVenueSchedulingDetails } from '../../../../../query/matchUps/scheduling/getVenueSchedulingDetails';\nimport { checkRecoveryTime } from '../../scheduleMatchUps/checkRecoveryTime';\nimport { checkDailyLimits } from '../../scheduleMatchUps/checkDailyLimits';\nimport { getMatchUpId } from '../../../../../global/functions/extractors';\nimport { bulkScheduleMatchUps } from '../../bulkScheduleMatchUps';\nimport { auditAutoScheduling } from '../auditAutoScheduling';\nimport {\n  extractDate,\n  sameDay,\n  timeStringMinutes,\n  zeroPad,\n} from '../../../../../utilities/dateTime';\n\nimport { SUCCESS } from '../../../../../constants/resultConstants';\nimport { TOTAL } from '../../../../../constants/scheduleConstants';\n\nexport function jinnScheduler({\n  schedulingProfileModifications,\n  checkPotentialRequestConflicts,\n  scheduleCompletedMatchUps, // override which can be used by mocksEngine\n  schedulingProfileIssues,\n  dateSchedulingProfiles,\n  containedStructureIds,\n  matchUpDependencies,\n  matchUpDailyLimits,\n  clearScheduleDates,\n  tournamentRecords,\n  schedulingProfile,\n  personRequests,\n  periodLength,\n  matchUps,\n  courts,\n  dryRun,\n}) {\n  const scheduleTimesRemaining = {};\n  const skippedScheduleTimes = {};\n\n  const recoveryTimeDeferredMatchUpIds = {};\n  const dependencyDeferredMatchUpIds = {};\n  const scheduleDateRequestConflicts = {};\n  const matchUpScheduleTimes = {};\n  const scheduledMatchUpIds = {};\n  const overLimitMatchUpIds = {};\n  const noTimeMatchUpIds = {};\n  const requestConflicts = {};\n\n  for (const dateSchedulingProfile of dateSchedulingProfiles) {\n    const scheduleDate = extractDate(dateSchedulingProfile?.scheduleDate);\n    const venues = dateSchedulingProfile?.venues || [];\n    const matchUpPotentialParticipantIds = {};\n    const individualParticipantProfiles = {};\n\n    const bumpLimits = (relevantParticipantIds, matchUpType) => {\n      relevantParticipantIds.forEach((participantId) => {\n        const counters = individualParticipantProfiles[participantId].counters;\n        if (counters[matchUpType]) counters[matchUpType] += 1;\n        else counters[matchUpType] = 1;\n        if (counters[TOTAL]) counters[TOTAL] += 1;\n        else counters[TOTAL] = 1;\n      });\n    };\n\n    recoveryTimeDeferredMatchUpIds[scheduleDate] = {};\n    dependencyDeferredMatchUpIds[scheduleDate] = {};\n    scheduleTimesRemaining[scheduleDate] = {};\n    skippedScheduleTimes[scheduleDate] = {};\n    scheduledMatchUpIds[scheduleDate] = []; // will not be in scheduled order\n    overLimitMatchUpIds[scheduleDate] = [];\n    noTimeMatchUpIds[scheduleDate] = [];\n    requestConflicts[scheduleDate] = [];\n\n    // Build up matchUpNotBeforeTimes for all matchUps already scheduled on scheduleDate\n    const matchUpNotBeforeTimes = {};\n    matchUps.forEach((matchUp) => {\n      if (\n        matchUp.schedule?.scheduledDate &&\n        sameDay(scheduleDate, extractDate(matchUp.schedule.scheduledDate))\n      ) {\n        processNextMatchUps({\n          matchUpPotentialParticipantIds,\n          matchUpNotBeforeTimes,\n          matchUp,\n        });\n      }\n    });\n\n    const {\n      allDateScheduledByeMatchUpDetails,\n      venueScheduledRoundDetails,\n      allDateMatchUpIds,\n    } = getVenueSchedulingDetails({\n      matchUpPotentialParticipantIds,\n      individualParticipantProfiles,\n      scheduleCompletedMatchUps,\n      containedStructureIds,\n      matchUpNotBeforeTimes,\n      matchUpScheduleTimes,\n      matchUpDependencies,\n      clearScheduleDates,\n      tournamentRecords,\n      useGarman: true,\n      periodLength,\n      scheduleDate,\n      matchUps,\n      courts,\n      venues,\n    });\n\n    const maxScheduleTimeAttempts = 10; // TODO: calculate this based on max court start/end range and averageMinutes\n    let schedulingIterations = 0;\n    let schedulingComplete;\n    const failSafe = 10;\n\n    while (!schedulingComplete) {\n      // for each venue schedule a round\n      for (const { venueId } of venues) {\n        let scheduledThisPass = 0;\n        const details = venueScheduledRoundDetails[venueId];\n\n        while (\n          details.courtsCount &&\n          details.scheduleTimes?.length &&\n          details.matchUpsToSchedule?.length &&\n          scheduledThisPass <= details.courtsCount\n        ) {\n          // attempt to schedule a round or at least venue.courts.length matchUps\n          const { scheduleTime, attempts = 0 } = details.scheduleTimes.shift();\n          const scheduledMatchUp = details.matchUpsToSchedule.find(\n            (matchUp) => {\n              const { matchUpId, matchUpType } = matchUp;\n\n              const { participantIdsAtLimit, relevantParticipantIds } =\n                checkDailyLimits({\n                  matchUpPotentialParticipantIds,\n                  individualParticipantProfiles,\n                  matchUpDailyLimits,\n                  matchUp,\n                });\n\n              if (participantIdsAtLimit.length) {\n                if (!overLimitMatchUpIds[scheduleDate].includes(matchUpId))\n                  overLimitMatchUpIds[scheduleDate].push(matchUpId);\n                return false;\n              }\n\n              const { scheduledDependent } = checkDependendantTiming({\n                matchUpScheduleTimes,\n                matchUpDependencies,\n                scheduleTime,\n                matchUpId,\n                details,\n              });\n              if (scheduledDependent) return false;\n\n              const { dependenciesScheduled, remainingDependencies } =\n                checkDependenciesScheduled({\n                  matchUpScheduleTimes,\n                  matchUpDependencies,\n                  allDateMatchUpIds,\n                  matchUp,\n                });\n              if (!dependenciesScheduled) {\n                if (!dependencyDeferredMatchUpIds[scheduleDate][matchUpId])\n                  dependencyDeferredMatchUpIds[scheduleDate][matchUpId] = [];\n                dependencyDeferredMatchUpIds[scheduleDate][matchUpId].push({\n                  scheduleTime,\n                  remainingDependencies,\n                });\n                return false;\n              }\n\n              const { enoughTime } = checkRecoveryTime({\n                individualParticipantProfiles,\n                matchUpNotBeforeTimes,\n                matchUpDependencies,\n                scheduleTime,\n                details,\n                matchUp,\n              });\n\n              if (!enoughTime) {\n                if (!recoveryTimeDeferredMatchUpIds[scheduleDate][matchUpId])\n                  recoveryTimeDeferredMatchUpIds[scheduleDate][matchUpId] = [];\n                recoveryTimeDeferredMatchUpIds[scheduleDate][matchUpId].push({\n                  scheduleTime,\n                });\n                return false;\n              }\n\n              const averageMatchUpMinutes = details.greatestAverageMinutes;\n              // details.minutesMap?.[matchUpId]?.averageMinutes;\n              // TODO: check the previous scheduled matchUp for each participantId/potentialParticipantId\n              // CHECK: if the matchUpType has changed for ALL PARTICIPANTS from SINGLE/DOUBLES use typeChangeRecoveryMinutes\n\n              const { conflicts } = checkRequestConflicts({\n                potentials: checkPotentialRequestConflicts,\n                averageMatchUpMinutes,\n                requestConflicts,\n                personRequests,\n                scheduleTime,\n                scheduleDate,\n                matchUp,\n              });\n\n              if (conflicts?.length) {\n                if (!scheduleDateRequestConflicts[scheduleDate])\n                  scheduleDateRequestConflicts[scheduleDate] = [];\n                scheduleDateRequestConflicts[scheduleDate].push(...conflicts);\n                return false;\n              }\n\n              bumpLimits(relevantParticipantIds, matchUpType);\n\n              const recoveryMinutes =\n                details.minutesMap?.[matchUpId]?.recoveryMinutes;\n\n              updateTimeAfterRecovery({\n                matchUpPotentialParticipantIds,\n                individualParticipantProfiles,\n                matchUpNotBeforeTimes,\n                averageMatchUpMinutes,\n                matchUpDependencies,\n                recoveryMinutes,\n                scheduleTime,\n                matchUp,\n              });\n\n              matchUpScheduleTimes[matchUpId] = scheduleTime;\n\n              return true;\n            }\n          );\n\n          details.matchUpsToSchedule = details.matchUpsToSchedule.filter(\n            ({ matchUpId }) => matchUpId !== scheduledMatchUp?.matchUpId\n          );\n\n          if (!scheduledMatchUp) {\n            if (!skippedScheduleTimes[scheduleDate][venueId])\n              skippedScheduleTimes[scheduleDate][venueId] = [];\n            skippedScheduleTimes[scheduleDate][venueId].push({\n              scheduleTime,\n              attempts: attempts + 1,\n            });\n          } else {\n            scheduledThisPass += 1;\n          }\n        }\n\n        if (details.matchUpsToSchedule?.length) {\n          skippedScheduleTimes[scheduleDate][venueId] = skippedScheduleTimes[\n            scheduleDate\n          ][venueId]?.filter((unused) => {\n            const tryAgain = unused.attempts < maxScheduleTimeAttempts;\n            if (tryAgain) details.scheduleTimes.push(unused);\n            return !tryAgain;\n          });\n        }\n\n        if (\n          !details.scheduleTimes?.length ||\n          !details.matchUpsToSchedule?.length\n        )\n          details.complete = true;\n      }\n\n      schedulingIterations += 1;\n      schedulingComplete =\n        venues.every(\n          ({ venueId }) => venueScheduledRoundDetails[venueId].complete\n        ) || schedulingIterations === failSafe;\n    }\n\n    // assign scheduledTime and venue to each matchUp\n    // because this is done in an optimized fashion from hash of assignments\n    // scheduledMatchUpIds[scheduleDate] will not be in the order that scheduleTimes were assigned\n    for (const { venueId } of venues) {\n      const matchUpMap = venueScheduledRoundDetails[venueId].matchUpMap;\n\n      Object.keys(matchUpMap).forEach((tournamentId) => {\n        const tournamentRecord = tournamentRecords[tournamentId];\n        if (tournamentRecord) {\n          Object.keys(matchUpMap[tournamentId]).forEach((drawId) => {\n            const { drawDefinition } = findDrawDefinition({\n              tournamentRecord,\n              drawId,\n            });\n            if (drawDefinition) {\n              const drawMatchUps = matchUpMap[tournamentId][drawId];\n\n              drawMatchUps.forEach(({ matchUpId }) => {\n                const scheduleTime = matchUpScheduleTimes[matchUpId];\n                if (scheduleTime) {\n                  // must include scheduleDate being scheduled to generate proper ISO string\n                  const formatTime = scheduleTime\n                    .split(':')\n                    .map(zeroPad)\n                    .join(':');\n                  const scheduledTime = `${extractDate(\n                    scheduleDate\n                  )}T${formatTime}`;\n\n                  if (dryRun) {\n                    scheduledMatchUpIds[scheduleDate].push(matchUpId);\n                  } else {\n                    const result = addMatchUpScheduledTime({\n                      drawDefinition,\n                      scheduledTime,\n                      matchUpId,\n                    });\n                    if (result.success)\n                      scheduledMatchUpIds[scheduleDate].push(matchUpId);\n\n                    if (venueId) {\n                      assignMatchUpVenue({\n                        tournamentRecord,\n                        drawDefinition,\n                        matchUpId,\n                        venueId,\n                      });\n                    }\n                  }\n                }\n              });\n            }\n          });\n        }\n      });\n\n      noTimeMatchUpIds[scheduleDate] =\n        venueScheduledRoundDetails[venueId].matchUpsToSchedule.map(\n          getMatchUpId\n        );\n\n      scheduleTimesRemaining[scheduleDate][venueId] =\n        venueScheduledRoundDetails[venueId].scheduleTimes.sort(\n          (a, b) =>\n            timeStringMinutes(a.scheduleTime) -\n            timeStringMinutes(b.scheduleTime)\n        );\n    }\n\n    if (!dryRun && allDateScheduledByeMatchUpDetails?.length) {\n      // remove scheduling information for BYE matchUps from any rounds that were scheduled\n      // remove scheduling information for BYE matchUps from any rounds that were scheduled\n      bulkScheduleMatchUps({\n        matchUpDetails: allDateScheduledByeMatchUpDetails,\n        scheduleByeMatchUps: true,\n        removePriorValues: true,\n        tournamentRecords,\n        schedule: {\n          scheduledDate: '',\n          scheduledTime: '',\n          courtOrder: '',\n          courtId: '',\n          venueId: '',\n        },\n      });\n    }\n\n    for (const venue of dateSchedulingProfile.venues) {\n      for (const round of venue.rounds) {\n        const matchUpIds =\n          round.matchUps?.map(({ matchUpId }) => matchUpId) || [];\n        const canScheduleMatchUpIds = matchUpIds.filter((matchUpId) =>\n          scheduledMatchUpIds[scheduleDate].includes(matchUpId)\n        );\n        round.canScheduledMatchUpIds = canScheduleMatchUpIds;\n        let possibleToSchedulePct =\n          Math.round(\n            (canScheduleMatchUpIds.length / round.matchUpsCount) * 10000\n          ) / 100;\n        if (possibleToSchedulePct === Infinity || isNaN(possibleToSchedulePct))\n          possibleToSchedulePct = 0;\n        round.possibleToSchedulePct = possibleToSchedulePct;\n        if (round.matchUpsCount === canScheduleMatchUpIds.length) {\n          round.possibleToSchedule = true;\n        }\n      }\n    }\n  }\n\n  // returns the original form of the dateStrings, before extractDate()\n  const scheduledDates = dateSchedulingProfiles.map(\n    ({ scheduleDate }) => scheduleDate\n  );\n\n  const autoSchedulingAudit = {\n    timeStamp: Date.now(),\n    overLimitMatchUpIds,\n    scheduledMatchUpIds,\n    schedulingProfile,\n    noTimeMatchUpIds,\n    requestConflicts,\n    scheduledDates,\n  };\n\n  auditAutoScheduling({ tournamentRecords, autoSchedulingAudit });\n\n  return {\n    ...SUCCESS,\n    schedulingProfileModifications,\n    schedulingProfileIssues,\n    scheduleTimesRemaining,\n    dateSchedulingProfiles,\n    skippedScheduleTimes,\n\n    recoveryTimeDeferredMatchUpIds,\n    dependencyDeferredMatchUpIds,\n    matchUpScheduleTimes,\n    overLimitMatchUpIds,\n    scheduledMatchUpIds,\n    noTimeMatchUpIds,\n    requestConflicts,\n    scheduledDates,\n  };\n}\n","import { isValidExtension } from '../../../validators/isValidExtension';\nimport { isISODateString } from '../../../utilities/dateTime';\nimport { validDateString } from '../../../validators/regex';\nimport { UUID } from '../../../utilities/UUID';\n\nimport { INVALID_DATE } from '../../../constants/errorConditionConstants';\n\nexport function newTournamentRecord(params): any {\n  const attributes = params || {};\n  if (!attributes.tournamentId) attributes.tournamentId = UUID();\n  if (\n    attributes.startDate &&\n    !isISODateString(attributes.startDate) &&\n    !validDateString.test(attributes.startDate)\n  ) {\n    return { error: INVALID_DATE };\n  }\n\n  if (\n    attributes.endDate &&\n    !isISODateString(attributes.endDate) &&\n    !validDateString.test(attributes.endDate)\n  ) {\n    return { error: INVALID_DATE };\n  }\n\n  if (attributes.extensions) {\n    attributes.extensions = attributes.extensions.filter(isValidExtension);\n  }\n\n  return { ...attributes };\n}\n","import { getAccessorValue } from '../../utilities/getAccessorValue';\nimport { addNotice } from '../../global/state/globalState';\nimport { addExtension } from '../extensions/addExtension';\nimport { findExtension } from '../../acquire/findExtension';\nimport { UUID } from '../../utilities/UUID';\n\nimport { GROUPING_ATTRIBUTE } from '../../constants/extensionConstants';\nimport { INDIVIDUAL, TEAM } from '../../constants/participantConstants';\nimport { ADD_PARTICIPANTS } from '../../constants/topicConstants';\nimport { COMPETITOR } from '../../constants/participantRoles';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { Tournament } from '../../types/tournamentTypes';\nimport {\n  MISSING_TOURNAMENT_RECORD,\n  NO_PARTICIPANTS_GENERATED,\n} from '../../constants/errorConditionConstants';\n\n/**\n *\n * @param {object} tournamentRecord - passed in automatically by tournamentEngine\n * @param {string} participantAttribute - optional - participant attribute to be used to group individual participants\n * @param {string} personAttribute - optional - person attribute to be used to group individual participants\n * @param {string} accessor - optional - dot delimited string targeting nested value\n * @param {string[]} uuids - optional - array of unique identifiers for genrated team participants\n * @returns { success: true } or { error }\n */\n\ntype GenerateTeamsArgs = {\n  participantAttribute?: string;\n  tournamentRecord: Tournament;\n  addParticipants?: boolean;\n  personAttribute?: string;\n  teamNames?: string[];\n  accessor?: string;\n  uuids?: string[];\n};\nexport function createTeamsFromParticipantAttributes({\n  addParticipants = true, // optional boolean to disable add\n  participantAttribute,\n  tournamentRecord,\n  personAttribute,\n  teamNames,\n  accessor,\n  uuids,\n}: GenerateTeamsArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const teams = {};\n  const individualParticipants = (tournamentRecord.participants ?? []).filter(\n    ({ participantType, participantRole }) =>\n      participantType === INDIVIDUAL && participantRole === COMPETITOR\n  );\n\n  let teamIndex = 0;\n\n  for (const individualParticipant of individualParticipants) {\n    const accessorValue =\n      accessor &&\n      getAccessorValue({\n        element: individualParticipant,\n        accessor,\n      })?.value;\n\n    const attributeValue =\n      accessorValue ||\n      (personAttribute && individualParticipant.person?.[personAttribute]) ||\n      (participantAttribute && individualParticipant[participantAttribute]);\n\n    if (attributeValue) {\n      if (!Object.keys(teams).includes(attributeValue)) {\n        teams[attributeValue] = {\n          participantName: teamNames?.[teamIndex] ?? attributeValue,\n          participantId: uuids?.pop() ?? UUID(),\n          individualParticipantIds: [],\n          participantRole: COMPETITOR,\n          participantType: TEAM,\n        };\n\n        const extension = {\n          value: personAttribute ?? participantAttribute,\n          name: GROUPING_ATTRIBUTE,\n        };\n        addExtension({ element: teams[attributeValue], extension });\n\n        teamIndex += 1;\n      }\n\n      teams[attributeValue].individualParticipantIds.push(\n        individualParticipant.participantId\n      );\n    }\n  }\n\n  const groupingAttributes = Object.keys(teams);\n\n  const overlappingTeamParticipantIds = (tournamentRecord.participants ?? [])\n    .map((participant) => {\n      if (participant.participantType !== TEAM) return undefined;\n      if (participant.participantRole !== COMPETITOR) return undefined;\n\n      const { extension } = findExtension({\n        name: GROUPING_ATTRIBUTE,\n        element: participant,\n      });\n      const groupingAttribute = extension?.value;\n\n      if (groupingAttributes.includes(groupingAttribute)) {\n        return participant.participantId;\n      }\n      return undefined;\n    })\n    .filter(Boolean);\n\n  let participantsAdded = 0;\n  const newParticipants: any[] = [];\n  Object.keys(teams).forEach((attributeValue) => {\n    const participant = teams[attributeValue];\n    const { participantId } = participant;\n    if (!overlappingTeamParticipantIds.includes(participantId)) {\n      if (!tournamentRecord.participants) tournamentRecord.participants = [];\n      if (addParticipants) tournamentRecord.participants.push(participant);\n      newParticipants.push(participant);\n      participantsAdded++;\n    }\n  });\n\n  if (addParticipants && participantsAdded) {\n    addNotice({\n      payload: {\n        tournamentId: tournamentRecord.tournamentId,\n        participants: newParticipants,\n      },\n      topic: ADD_PARTICIPANTS,\n    });\n    return { ...SUCCESS, participantsAdded };\n  } else if (newParticipants.length) {\n    return { ...SUCCESS, newParticipants };\n  } else {\n    return { error: NO_PARTICIPANTS_GENERATED };\n  }\n}\n","import { GROUP, INDIVIDUAL, PAIR, TEAM } from '../../../constants/participantConstants';\nimport { UUID } from '../../../utilities/UUID';\n\nexport function genParticipantId({ idPrefix, participantType, index, uuids }) {\n  const type = participantType === INDIVIDUAL ? 'I' : PAIR ? 'P' : TEAM ? 'T' : GROUP ? 'G' : 'X';\n  return idPrefix ? `${idPrefix}-${type}-${index}` : uuids?.pop() || UUID();\n}\n","import { isNumeric, randomInt, skewedDistribution } from '../../../utilities/math';\nimport { generateRange, shuffleArray } from '../../../utilities/arrays';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { cityMocks, stateMocks, postalCodeMocks } from './address';\nimport { isValidDateString } from '../../../utilities/dateTime';\nimport { countries } from '../../../fixtures/countryData';\nimport { generateAddress } from './generateAddress';\nimport { generatePersons } from './generatePersons';\nimport { nameMocks } from './nameMocks';\nimport { UUID } from '../../../utilities/UUID';\n\nimport defaultRatingsParameters from '../../../fixtures/ratings/ratingsParameters';\nimport { INDIVIDUAL, PAIR, TEAM } from '../../../constants/participantConstants';\nimport { DOUBLES_EVENT, SINGLES_EVENT } from '../../../constants/eventConstants';\nimport { RANKING, RATING, SCALE } from '../../../constants/scaleConstants';\nimport { ErrorType } from '../../../constants/errorConditionConstants';\nimport { DOUBLES_MATCHUP } from '../../../constants/matchUpTypes';\nimport { COMPETITOR } from '../../../constants/participantRoles';\nimport { genParticipantId } from './genParticipantId';\n\nexport function generateParticipants(params): {\n  participants?: any[];\n  error?: ErrorType;\n} {\n  let {\n    rankingRange, // range of ranking positions to generate\n    scaledParticipantsCount, // number of participants to assign rankings/ratings\n  } = params;\n  const {\n    ratingsParameters = defaultRatingsParameters,\n    valuesInstanceLimit,\n    consideredDate,\n    category,\n\n    nationalityCodesCount,\n    nationalityCodeType,\n    nationalityCodes,\n\n    participantsCount = 32,\n    participantType,\n    personIds,\n    idPrefix,\n    uuids,\n\n    personExtensions,\n    addressProps,\n    gendersCount, // used by mocksEngine; internally calculated\n    matchUpType,\n    personData,\n    sex,\n\n    inContext,\n    withISO2,\n    withIOC,\n\n    scaleAllParticipants, // optional boolean\n  } = params;\n\n  const doubles = participantType === PAIR || matchUpType === DOUBLES_MATCHUP;\n  const team = participantType === TEAM || matchUpType === TEAM;\n\n  if (\n    rankingRange &&\n    (!Array.isArray(rankingRange) || !rankingRange.every((r) => isNumeric(r)) || rankingRange.length !== 2)\n  ) {\n    rankingRange = undefined;\n  }\n\n  scaledParticipantsCount = scaleAllParticipants ? participantsCount : scaledParticipantsCount;\n  const defaultRankingRange = 1000;\n  const rankingUpperBound =\n    scaledParticipantsCount && scaledParticipantsCount > defaultRankingRange\n      ? scaledParticipantsCount\n      : defaultRankingRange;\n  rankingRange = rankingRange || [1, rankingUpperBound];\n  rankingRange[1] += 1; // so that behavior is as expected\n\n  const individualParticipantsCount = participantsCount * (doubles ? 2 : team ? 8 : 1);\n\n  const result = generatePersons({\n    count: individualParticipantsCount,\n    personExtensions,\n    consideredDate,\n    gendersCount,\n    personData,\n    category,\n    sex,\n  });\n  if (result.error) return result;\n\n  const { nationalityCodes: personNationalityCodes, persons: mockedPersons } = result;\n\n  // generated arrays of rankings and ratings to be attached as scaleItems\n  let doublesRankings: any[] = [],\n    singlesRankings: any[] = [],\n    singlesRatings: any[] = [],\n    doublesRatings: any[] = [];\n\n  if (typeof category === 'object') {\n    const { categoryName, ageCategoryCode, ratingType } = category;\n    if ((categoryName || ageCategoryCode) && !ratingType) {\n      const [start, end] = rankingRange || [];\n      singlesRankings = shuffleArray(generateRange(start, end)).slice(0, scaledParticipantsCount || randomInt(20, 30));\n\n      if ([PAIR, TEAM].includes(participantType)) {\n        const [start, end] = rankingRange || [];\n        doublesRankings = shuffleArray(generateRange(start, end)).slice(\n          0,\n          scaledParticipantsCount || randomInt(20, 30),\n        );\n      }\n    }\n\n    if (ratingType && ratingsParameters[ratingType]) {\n      // ratingAttributes allows selected attributes of ratingParameters to be overridden\n      const { ratingMax, ratingMin, ratingAttributes } = category;\n\n      const ratingParameters = {\n        ...ratingsParameters[ratingType],\n        ...(ratingAttributes || {}),\n      };\n\n      const { attributes = {}, decimalsCount, accessors, range, step } = ratingParameters;\n\n      const getAttributes = (attributes) => {\n        const generatedAttributes = {};\n\n        const attributeKeys = Object.keys(attributes || {});\n        for (const attribute of attributeKeys) {\n          const attributeValue = attributes[attribute];\n\n          if (typeof attributeValue === 'object' && attributeValue.generator) {\n            const { range } = attributeValue;\n            const [min, max] = range.slice().sort();\n\n            generatedAttributes[attribute] = randomInt(min, max);\n          } else {\n            generatedAttributes[attribute] = attributeValue;\n          }\n        }\n\n        return generatedAttributes;\n      };\n\n      const inverted = range[0] > range[1];\n      const skew = inverted ? 2 : 0.5;\n      const [min, max] = range.slice().sort();\n      const generateRatings = () =>\n        generateRange(0, 2000) // overgenerate because filter and restricted range will impact final count\n          .map(() => skewedDistribution(min, max, skew, step, decimalsCount))\n          .filter((rating) => (!ratingMax || rating <= ratingMax) && (!ratingMin || rating >= ratingMin))\n          .slice(0, scaledParticipantsCount || randomInt(20, 30))\n          .map((scaleValue) => {\n            return !accessors\n              ? scaleValue\n              : Object.assign(\n                  {},\n                  ...accessors.map((accessor) => ({ [accessor]: scaleValue })),\n                  getAttributes(attributes),\n                );\n          });\n\n      singlesRatings = generateRatings();\n      if ([PAIR, TEAM].includes(participantType)) {\n        doublesRatings = generateRatings();\n      }\n    }\n  }\n\n  const countryCodes = countries.filter((country) =>\n    nationalityCodeType === 'IOC' ? country.ioc || country.iso : country.iso,\n  );\n\n  function getMin(count) {\n    const instances = Math.ceil(individualParticipantsCount / count);\n    if (valuesInstanceLimit && instances > valuesInstanceLimit)\n      return Math.ceil(individualParticipantsCount / valuesInstanceLimit);\n    return count;\n  }\n\n  const { postalCodesProfile, postalCodesCount, statesProfile, citiesProfile, citiesCount, statesCount } =\n    addressProps || {};\n\n  const valuesFromProfile = (profile) =>\n    Object.keys(profile)\n      .map((key) => generateRange(0, statesProfile[key]).map(() => key))\n      .flat();\n\n  const cities =\n    (citiesProfile && valuesFromProfile(citiesProfile)) ||\n    addressProps?.cities ||\n    cityMocks({\n      count: citiesCount || individualParticipantsCount,\n      participantsCount: individualParticipantsCount,\n    }).cities;\n  const states =\n    (statesProfile && valuesFromProfile(statesProfile)) ||\n    addressProps?.states ||\n    stateMocks({\n      count: statesCount || individualParticipantsCount,\n      participantsCount: individualParticipantsCount,\n    }).states;\n  const postalCodes =\n    (postalCodesProfile && valuesFromProfile(postalCodesProfile)) ||\n    addressProps?.postalCodes ||\n    postalCodeMocks({\n      count: postalCodesCount || individualParticipantsCount,\n      participantsCount: individualParticipantsCount,\n    }).postalCodes;\n\n  const addressValues = { cities, states, postalCodes };\n\n  const isoMin = getMin(nationalityCodesCount);\n  const isoList = isoMin\n    ? shuffleArray(countryCodes).slice(0, nationalityCodesCount)\n    : nationalityCodes\n      ? countryCodes.filter((isoCountry) => nationalityCodes.includes(isoCountry.iso))\n      : countryCodes;\n\n  const countriesList = shuffleArray(\n    generateRange(0, Math.ceil(individualParticipantsCount / (isoMin || 1)))\n      .map(() => isoList)\n      .flat(Infinity),\n  );\n\n  const teamNames = nameMocks({ count: participantsCount }).names;\n  const participants = generateRange(0, participantsCount)\n    .map((i) => {\n      const sideParticipantsCount = doubles ? 2 : team ? 8 : 1;\n      const individualParticipants = generateRange(0, sideParticipantsCount).map((j) => {\n        const participantIndex = i * sideParticipantsCount + j;\n        return generateIndividualParticipant(participantIndex);\n      });\n\n      const individualParticipantIds = individualParticipants.map((participant) => participant.participantId);\n\n      const pairName = individualParticipants.map((i) => i.person.standardFamilyName).join('/');\n\n      const participantType = doubles ? PAIR : TEAM;\n      const groupParticipant: any = {\n        participantId: genParticipantId({\n          participantType,\n          idPrefix,\n          index: i,\n          uuids,\n        }),\n        participantRole: COMPETITOR,\n        participantName: doubles ? pairName : teamNames[i],\n        individualParticipantIds,\n        participantType,\n      };\n\n      if (inContext) groupParticipant.individualParticipants = individualParticipants;\n\n      return doubles || team ? [groupParticipant, ...individualParticipants] : individualParticipants;\n    })\n    .flat();\n\n  return { participants };\n\n  function generateIndividualParticipant(participantIndex) {\n    const person = mockedPersons[participantIndex];\n    const {\n      nationalityCode: personNationalityCode,\n      participantExtensions,\n      participantTimeItems,\n      extensions,\n      firstName,\n      birthDate,\n      lastName,\n      personId,\n      sex,\n    } = person || {};\n    const standardGivenName = firstName || 'GivenName';\n    const standardFamilyName = lastName || 'FamilyName';\n    const participantName = `${standardGivenName} ${standardFamilyName}`;\n    const country = countriesList[participantIndex];\n    const nationalityCode =\n      (personNationalityCodes?.length && personNationalityCode) ||\n      (country && (nationalityCodeType === 'IOC' ? country.ioc || country.iso : country.iso || country.ioc)) ||\n      personNationalityCode;\n\n    if (countriesList?.length && !nationalityCode && !personNationalityCode) {\n      console.log('%c Invalid Nationality Code', { participantIndex, country });\n    }\n    const address = generateAddress({\n      ...addressValues,\n      participantIndex,\n      nationalityCode,\n    });\n\n    const participant = definedAttributes({\n      participantId: genParticipantId({\n        participantType: INDIVIDUAL,\n        index: participantIndex,\n        idPrefix,\n        uuids,\n      }),\n      extensions: participantExtensions,\n      timeItems: participantTimeItems,\n      participantRole: COMPETITOR,\n      participantType: INDIVIDUAL,\n      participantName,\n      person: {\n        addresses: [address],\n        personId: personId || (personIds?.length && personIds[participantIndex]) || UUID(),\n        standardFamilyName,\n        standardGivenName,\n        nationalityCode,\n        extensions,\n        birthDate: isValidDateString(birthDate) ? birthDate : undefined,\n        sex,\n      },\n    });\n\n    if (withIOC && nationalityCode) {\n      const country = countries.find(({ iso }) => iso === nationalityCode);\n      if (country?.ioc) participant.person.iocNationalityCode = country.ioc;\n      if (country?.label) participant.person.countryName = country.label;\n    }\n    if (withISO2 && nationalityCode) {\n      const country = countries.find(({ iso }) => iso === nationalityCode);\n      if (country?.iso2) participant.person.iso2NationalityCode = country.iso2;\n      if (country?.label) participant.person.countryName = country.label;\n    }\n\n    if (category) {\n      const singlesRanking = singlesRankings[participantIndex];\n      const doublesRanking = doublesRankings[participantIndex];\n\n      addScaleItem({\n        scaleValue: singlesRanking,\n        eventType: SINGLES_EVENT,\n        scaleType: RANKING,\n        participant,\n        category,\n      });\n      addScaleItem({\n        scaleValue: doublesRanking,\n        eventType: DOUBLES_EVENT,\n        scaleType: RANKING,\n        participant,\n        category,\n      });\n\n      const singlesRating = singlesRatings[participantIndex];\n      const doublesRating = doublesRatings[participantIndex];\n\n      addScaleItem({\n        scaleValue: singlesRating,\n        eventType: SINGLES_EVENT,\n        scaleType: RATING,\n        participant,\n        category,\n      });\n      addScaleItem({\n        scaleValue: doublesRating,\n        eventType: DOUBLES_EVENT,\n        scaleType: RATING,\n        participant,\n        category,\n      });\n    }\n\n    return participant;\n  }\n}\n\nfunction addScaleItem({ scaleValue: itemValue, participant, eventType, scaleType, category }) {\n  const scaleName = category.categoryName || category.ratingType || category.ageCategoryCode;\n  const itemType = [SCALE, scaleType, eventType, scaleName].join('.');\n  const timeItem = { itemValue, itemType };\n  if (scaleName && itemValue) {\n    if (!participant.timeItems) participant.timeItems = [];\n    participant.timeItems.push(timeItem);\n  }\n}\n","import tieFormatDefaults from '../templates/tieFormatDefaults';\nimport { UUID } from '../../../utilities/UUID';\n\nimport { DOUBLES, SINGLES } from '../../../constants/matchUpTypes';\nimport {\n  FEMALE,\n  MIXED,\n  OTHER,\n  MALE,\n  ANY,\n} from '../../../constants/genderConstants';\n\nexport function processTieFormat({\n  alternatesCount = 0,\n  tieFormatName,\n  tieFormat,\n  drawSize,\n}) {\n  let maxDoublesCount = 0,\n    maxSinglesCount = 0;\n\n  let singlesMatchUpTotal = 0,\n    doublesMatchUpTotal = 0;\n\n  const categories = {};\n  const genders = { [MALE]: 0, [FEMALE]: 0, [MIXED]: 0, [OTHER]: 0, [ANY]: 0 };\n\n  tieFormat =\n    typeof tieFormat === 'object'\n      ? tieFormat\n      : tieFormatDefaults({ namedFormat: tieFormatName });\n\n  tieFormat?.collectionDefinitions\n    ?.filter(Boolean)\n    .forEach((collectionDefinition) => {\n      const { category, collectionId, matchUpType, matchUpCount, gender } =\n        collectionDefinition;\n\n      if ([MALE, FEMALE].includes(gender)) {\n        const required = matchUpCount * (matchUpType === DOUBLES ? 2 : 1);\n        if (genders[gender] < required) genders[gender] = required;\n      } else if (gender === MIXED) {\n        if (genders[MALE] < matchUpCount) genders[MALE] = matchUpCount;\n        if (genders[FEMALE] < matchUpCount) genders[FEMALE] = matchUpCount;\n      }\n\n      if (category) {\n        const categoryString = JSON.stringify(category);\n        categories[categoryString] = category;\n      }\n\n      // ensure every collectionDefinition has a collectionId\n      if (!collectionId) collectionDefinition.collectionId = UUID();\n\n      if (matchUpType === DOUBLES) {\n        const doublesCount = matchUpCount;\n        doublesMatchUpTotal += matchUpCount;\n        maxDoublesCount = Math.max(maxDoublesCount, doublesCount);\n      }\n\n      if (matchUpType === SINGLES) {\n        const singlescount = matchUpCount;\n        singlesMatchUpTotal += matchUpCount;\n        maxSinglesCount = Math.max(maxSinglesCount, singlescount);\n      }\n    });\n\n  const teamSize = Object.keys(categories).length\n    ? Math.max(singlesMatchUpTotal, doublesMatchUpTotal * 2)\n    : Math.max(maxSinglesCount, maxDoublesCount * 2);\n  const maxDoublesDraw = maxDoublesCount * (drawSize + alternatesCount);\n  const maxSinglesDraw = maxSinglesCount * (drawSize + alternatesCount);\n\n  return {\n    maxDoublesDraw,\n    maxSinglesDraw,\n    teamSize,\n    genders,\n  };\n}\n","import { createTeamsFromParticipantAttributes } from '../../../mutate/participants/createTeamsFromAttributes';\nimport { addParticipants } from '../../../mutate/participants/addParticipants';\nimport { getParticipantId } from '../../../global/functions/extractors';\nimport { generateParticipants } from './generateParticipants';\nimport { getParticipantsCount } from './getParticipantsCount';\nimport { generateRange } from '../../../utilities/arrays';\n\nimport { Participant, Tournament } from '../../../types/tournamentTypes';\nimport { INDIVIDUAL, TEAM } from '../../../constants/participantConstants';\nimport { ParticipantsProfile } from '../../../types/factoryTypes';\nimport { COMPETITOR } from '../../../constants/participantRoles';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { genParticipantId } from './genParticipantId';\n\ntype AddTournamentParticipantsArgs = {\n  participantsProfile?: ParticipantsProfile;\n  tournamentRecord: Tournament;\n  eventProfiles?: any[];\n  drawProfiles?: any[];\n  startDate?: string;\n  uuids?: string[];\n};\nexport function addTournamentParticipants({\n  participantsProfile,\n  tournamentRecord,\n  eventProfiles,\n  drawProfiles,\n  startDate,\n  uuids,\n}: AddTournamentParticipantsArgs) {\n  const { participantsCount, participantType, largestTeamDraw, largestTeamSize, gendersCount } = getParticipantsCount({\n    participantsProfile,\n    eventProfiles,\n    drawProfiles,\n  });\n\n  const teamKey = participantsProfile?.teamKey;\n\n  const participants = generateParticipants({\n    uuids,\n    ...participantsProfile,\n    consideredDate: startDate,\n    participantsCount,\n    participantType,\n    gendersCount,\n  }).participants as Participant[];\n\n  let addedCount = 0;\n  let result = addParticipants({ tournamentRecord, participants });\n  if (result.error) return result;\n  addedCount += result.addedCount;\n\n  if (teamKey) {\n    const result = createTeamsFromParticipantAttributes({\n      tournamentRecord,\n      ...teamKey,\n    });\n    if (result.error) return result;\n  }\n\n  // generate Team participants\n  const allIndividualParticipantIds = participants\n    .filter(({ participantType }) => participantType === INDIVIDUAL)\n    .map(getParticipantId);\n  const idPrefix = participantsProfile?.idPrefix ? `${TEAM}-${participantsProfile.idPrefix}` : undefined;\n  const teamParticipants: any[] = generateRange(0, largestTeamDraw).map((teamIndex) => {\n    const individualParticipantIds = allIndividualParticipantIds.slice(\n      teamIndex * largestTeamSize,\n      (teamIndex + 1) * largestTeamSize,\n    );\n    const participantId = genParticipantId({\n      index: teamIndex,\n      participantType,\n      idPrefix,\n      uuids,\n    });\n\n    return {\n      participantName: `Team ${teamIndex + 1}`,\n      participantRole: COMPETITOR,\n      individualParticipantIds,\n      participantType: TEAM,\n      participantId,\n    };\n  });\n\n  result = addParticipants({\n    participants: teamParticipants,\n    tournamentRecord,\n  });\n  if (result.error) return result;\n  addedCount += result.addedCount;\n\n  return { addedCount, ...SUCCESS };\n}\n","import tieFormatDefaults from '../templates/tieFormatDefaults';\nimport { processTieFormat } from './processTieFormat';\n\nimport { INDIVIDUAL, PAIR } from '../../../constants/participantConstants';\nimport { QUALIFYING } from '../../../constants/drawDefinitionConstants';\nimport { DOUBLES, TEAM } from '../../../constants/eventConstants';\nimport {\n  FEMALE,\n  MIXED,\n  OTHER,\n  MALE,\n  ANY,\n} from '../../../constants/genderConstants';\n\nexport function getParticipantsCount({\n  participantsProfile,\n  eventProfiles,\n  drawProfiles,\n}) {\n  let { participantsCount, participantType = INDIVIDUAL } =\n    participantsProfile || {};\n  const specifiedParicipantsCount = participantsCount || 0; // capture this to ensure calculated participantsCount is not below\n\n  const gendersCount = {\n    [FEMALE]: 0,\n    [MIXED]: 0,\n    [OTHER]: 0,\n    [MALE]: 0,\n    [ANY]: 0,\n  };\n  let largestDoublesDraw = 0,\n    largestSinglesDraw = 0,\n    largestTeamSize = 0,\n    largestTeamDraw = 0,\n    uniqueParticipantsCount = 0;\n\n  const processDrawProfile = ({\n    alternatesCount = 0,\n    uniqueParticipants,\n    tieFormatName,\n    drawSize = 0,\n    eventType,\n    tieFormat,\n    category,\n    gender,\n    stage,\n  }) => {\n    const isDoubles = eventType === DOUBLES;\n    const isTeam = eventType === TEAM;\n    const requiresUniqueParticipants = Boolean(\n      uniqueParticipants || stage === QUALIFYING || category || gender\n    );\n\n    if (isTeam) {\n      largestTeamDraw = Math.max(largestTeamDraw, drawSize + alternatesCount);\n\n      tieFormat =\n        typeof tieFormat === 'object'\n          ? tieFormat\n          : tieFormatDefaults({ namedFormat: tieFormatName });\n\n      const { teamSize, maxDoublesDraw, maxSinglesDraw, genders } =\n        processTieFormat({\n          alternatesCount,\n          tieFormatName,\n          tieFormat,\n          drawSize,\n        });\n      largestTeamSize = Math.max(largestTeamSize, teamSize);\n      largestSinglesDraw = Math.max(largestSinglesDraw, maxSinglesDraw);\n      if (!requiresUniqueParticipants) {\n        largestDoublesDraw = Math.max(largestDoublesDraw, maxDoublesDraw);\n      }\n      Object.keys(genders).forEach(\n        (key) => (gendersCount[key] += genders[key])\n      );\n    } else if (isDoubles) {\n      if (requiresUniqueParticipants) {\n        const additionalParticipantsCount = (drawSize + alternatesCount) * 2;\n        uniqueParticipantsCount += additionalParticipantsCount;\n        if (gender) gendersCount[gender] += additionalParticipantsCount;\n      } else if (\n        drawSize + alternatesCount &&\n        drawSize + alternatesCount > largestDoublesDraw\n      ) {\n        largestDoublesDraw = drawSize + alternatesCount;\n      }\n    } else if (requiresUniqueParticipants) {\n      const additionalParticipantsCount = drawSize + alternatesCount;\n      if (gender) gendersCount[gender] += additionalParticipantsCount;\n      uniqueParticipantsCount += additionalParticipantsCount;\n    } else if (drawSize && drawSize > largestSinglesDraw) {\n      largestSinglesDraw = drawSize + alternatesCount;\n    }\n  };\n\n  /*\n   * TODO: let categories = []; // use when generating participants\n   */\n\n  eventProfiles?.forEach((eventProfile) => {\n    const {\n      tieFormatName: eventTieFormatName,\n      tieFormat: eventTieFormat,\n      drawProfiles,\n      eventType,\n      category,\n      gender,\n    } = eventProfile;\n\n    if (drawProfiles) {\n      for (const drawProfile of drawProfiles) {\n        const { tieFormatName, tieFormat } = drawProfile;\n\n        processDrawProfile({\n          ...drawProfile,\n          tieFormatName: tieFormatName || eventTieFormatName,\n          tieFormat: tieFormat || eventTieFormat,\n          eventType,\n          category,\n          gender,\n        });\n      }\n    } else {\n      /*\n       * if (category) categories.push(category);\n       */\n    }\n  });\n\n  if (Array.isArray(drawProfiles)) {\n    for (const drawProfile of drawProfiles) {\n      processDrawProfile(drawProfile);\n    }\n  }\n  const individualCompetitorsCount = Math.max(\n    largestTeamDraw * largestTeamSize,\n    largestDoublesDraw * 2,\n    largestSinglesDraw\n  );\n\n  if (largestDoublesDraw) participantType = PAIR;\n  if (\n    (participantsCount || specifiedParicipantsCount) <\n    individualCompetitorsCount\n  )\n    participantsCount = individualCompetitorsCount;\n\n  if (\n    participantsCount &&\n    largestDoublesDraw &&\n    [PAIR, TEAM].includes(participantType)\n  ) {\n    // if we are generating PAIRs or TEAMs...\n    if (\n      largestSinglesDraw &&\n      Math.floor(largestSinglesDraw / 2) > largestDoublesDraw\n    ) {\n      // if the half the singles draw is still larger than doubles draw\n      participantsCount = Math.floor(largestSinglesDraw / 2);\n    } else if (\n      !largestSinglesDraw ||\n      largestDoublesDraw * 2 >= largestSinglesDraw\n    ) {\n      // otherwise participantsCount can be cut in half\n      participantsCount = Math.ceil(participantsCount / 2);\n    }\n  }\n\n  // if (participantsCount === undefined) participantsCount = 32;\n  if (participantsCount === undefined) {\n    participantsCount =\n      !eventProfiles?.length && !drawProfiles?.length ? 32 : 0;\n  }\n  if (participantsCount < specifiedParicipantsCount)\n    participantsCount = specifiedParicipantsCount;\n\n  return {\n    uniqueParticipantsCount,\n    participantsCount,\n    largestTeamDraw,\n    largestTeamSize,\n    participantType,\n    gendersCount,\n  };\n}\n","export const courtTemplate = () => ({\n  altitude: undefined,\n  courtId: undefined,\n  courtName: '',\n  courtDimensions: undefined,\n  latitude: undefined,\n  longitude: undefined,\n  surfaceCategory: undefined,\n  surfaceType: undefined,\n  surfacedDate: undefined,\n  dateAvailability: [],\n  onlineResources: [],\n  pace: undefined,\n  notes: undefined,\n});\n\nexport default courtTemplate;\n","import { timeValidation } from './regex';\n\nfunction getInt(value) {\n  return parseInt(value);\n}\n\nexport function validTimePeriod({ startTime = '', endTime = '' } = {}) {\n  if (\n    !startTime ||\n    !endTime ||\n    !timeValidation.test(startTime) ||\n    !timeValidation.test(endTime)\n  )\n    return false;\n\n  const [startHour, startMinute] = startTime.split(':').map(getInt);\n  const [endHour, endMinute] = endTime.split(':').map(getInt);\n\n  if (endHour < startHour) return false;\n  return startHour === endHour && endMinute < startMinute ? false : true;\n}\n\nexport function startTimeSort(a, b) {\n  const [startHourA, startMinuteA] = a.startTime.split(':').map(getInt);\n  const [startHourB, startMinuteB] = b.startTime.split(':').map(getInt);\n  if (startHourA < startHourB) return -1;\n  if (startHourA > startHourB) return 1;\n  if (startMinuteA < startMinuteB) return -1;\n  if (startMinuteA > startMinuteB) return 1;\n  return 0;\n}\n","import { validTimePeriod } from './time';\nimport { dateValidation, timeValidation } from './regex';\n\nimport {\n  INVALID_DATE,\n  INVALID_TIME,\n  INVALID_BOOKINGS,\n  INVALID_DATE_AVAILABILITY,\n  MISSING_DATE_AVAILABILITY,\n} from '../constants/errorConditionConstants';\n\nexport function validDateAvailability({ dateAvailability }) {\n  if (!dateAvailability) return { error: MISSING_DATE_AVAILABILITY };\n  if (!Array.isArray(dateAvailability))\n    return { error: INVALID_DATE_AVAILABILITY };\n\n  const dateNote = 'Dates must be formated => YYYY-MM-DD';\n  const timeNote = 'Times must be 24 hour => 00:00';\n\n  for (const availability of dateAvailability) {\n    if (typeof availability !== 'object') {\n      return { error: INVALID_DATE_AVAILABILITY };\n    }\n\n    const { date, startTime, endTime, bookings = [] } = availability;\n    if (!startTime || !endTime) {\n      return { error: INVALID_DATE_AVAILABILITY };\n    }\n\n    if (date && !dateValidation.test(date)) {\n      return {\n        error: INVALID_DATE,\n        dateAvailability: { date },\n        info: dateNote,\n      };\n    }\n    if (!timeValidation.test(startTime)) {\n      return {\n        error: INVALID_TIME,\n        dateAvailability: { startTime },\n        info: timeNote,\n      };\n    }\n    if (!timeValidation.test(endTime)) {\n      return {\n        error: INVALID_TIME,\n        dateAvailability: { endTime },\n        info: timeNote,\n      };\n    }\n    if (startTime === endTime) {\n      return {\n        error: INVALID_TIME,\n        dateAvailability: { startTime, endTime },\n        info: 'startTime and endTime are equivalent',\n      };\n    }\n    if (!validTimePeriod({ startTime, endTime })) {\n      return {\n        error: INVALID_TIME,\n        dateAvailability: { startTime, endTime },\n        info: 'endTime must be after startTime',\n      };\n    }\n\n    if (bookings) {\n      if (!Array.isArray(bookings)) {\n        return { error: INVALID_BOOKINGS };\n      }\n\n      for (const booking of bookings) {\n        if (typeof booking !== 'object') {\n          return { error: INVALID_BOOKINGS };\n        }\n        const { startTime, endTime } = booking;\n        if (!timeValidation.test(startTime)) {\n          return {\n            error: INVALID_TIME,\n            booking: { startTime },\n            info: timeNote,\n          };\n        }\n        if (!timeValidation.test(endTime)) {\n          return {\n            error: INVALID_TIME,\n            booking: { endTime },\n            info: timeNote,\n          };\n        }\n        if (startTime === endTime) {\n          return {\n            error: INVALID_TIME,\n            dateAvailability: { startTime, endTime },\n            info: 'startTime and endTime are equivalent',\n          };\n        }\n        if (!validTimePeriod({ startTime, endTime })) {\n          return {\n            error: INVALID_TIME,\n            dateAvailability: { startTime, endTime },\n            info: 'endTime must be after startTime',\n          };\n        }\n      }\n    }\n  }\n\n  return { valid: true };\n}\n","import { courtTemplate } from '../../assemblies/generators/templates/courtTemplate';\nimport { validDateAvailability } from '../../validators/validateDateAvailability';\nimport { extractDate, extractTime, formatDate } from '../../utilities/dateTime';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { addNotice } from '../../global/state/globalState';\nimport { generateRange } from '../../utilities/arrays';\nimport { isNumeric } from '../../utilities/math';\nimport { UUID } from '../../utilities/UUID';\nimport { findVenue } from './findVenue';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\n\nimport { Availability, Court, Tournament } from '../../types/tournamentTypes';\nimport { MODIFY_VENUE } from '../../constants/topicConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_VENUE_ID,\n  MISSING_COURTS_INFO,\n  VENUE_NOT_FOUND,\n  COURT_EXISTS,\n  INVALID_VALUES,\n} from '../../constants/errorConditionConstants';\n\ntype AddCourtArgs = {\n  tournamentRecord: Tournament;\n  disableNotice?: boolean;\n  courtId?: string;\n  venueId: string;\n  court?: any; // courtId may not yet be present\n};\nexport function addCourt({\n  tournamentRecord,\n  disableNotice,\n  venueId,\n  courtId,\n  court,\n}: AddCourtArgs) {\n  const { venue } = findVenue({ tournamentRecord, venueId });\n  if (!venue) return { error: VENUE_NOT_FOUND };\n\n  if (!venue.courts) venue.courts = [];\n\n  const courtRecord: any = { ...courtTemplate(), venueId, courtId };\n  if (!courtRecord.courtId) {\n    courtRecord.courtId = UUID();\n  }\n\n  const courtExists = venue.courts.some(\n    (candidate) => candidate.courtId === courtRecord.courtId\n  );\n\n  if (courtExists) {\n    return { error: COURT_EXISTS };\n  } else {\n    // build new dateAvailability object with date/time extraction\n    const dateAvailability = (court?.dateAvailability || []).map(\n      (availabilty: any) => ({\n        ...availabilty,\n        date: extractDate(availabilty.date),\n        startTime: extractTime(availabilty.startTime),\n        endTime: extractTime(availabilty.endTime),\n        bookings: availabilty.bookings?.map(\n          ({ startTime, endTime, bookingType }) => ({\n            startTime: extractTime(startTime),\n            endTime: extractTime(endTime),\n            bookingType,\n          })\n        ),\n      })\n    );\n\n    const attributes = Object.keys(courtRecord);\n    for (const attribute of attributes) {\n      if (court?.[attribute]) {\n        if (attribute === 'dateAvailability') {\n          const result = validDateAvailability({ dateAvailability });\n          if (!result.valid && result.error) return result;\n          courtRecord.dateAvailability = dateAvailability;\n        } else {\n          courtRecord[attribute] = court[attribute];\n        }\n      }\n    }\n\n    const newCourt = courtRecord as Court;\n    venue.courts.push(newCourt);\n\n    if (!disableNotice) {\n      addNotice({\n        payload: { venue, tournamentId: tournamentRecord.tournamentId },\n        topic: MODIFY_VENUE,\n        key: venue.venueId,\n      });\n    }\n\n    return { ...SUCCESS, court: makeDeepCopy(courtRecord), venueId };\n  }\n}\n\ntype ACArgs = AddCourtsArgs & {\n  tournamentRecords?: { [key: string]: Tournament };\n  tournamentRecord?: Tournament;\n  venueId: string;\n};\nexport function addCourts(params: ACArgs) {\n  // if tournamentRecord is not linked to other tournamentRecods, only add to tournamentRecord\n  const { tournamentRecord, venueId } = params;\n\n  if (typeof venueId !== 'string' || !venueId)\n    return { error: MISSING_VENUE_ID };\n\n  const tournamentRecords =\n    params.tournamentRecords ??\n    (tournamentRecord && {\n      [tournamentRecord.tournamentId]: tournamentRecord,\n    }) ??\n    {};\n\n  const courtIds: string[] = [];\n\n  let success;\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const { venue } = findVenue({ tournamentRecord, venueId });\n    if (venue) {\n      // TODO: create courts before adding to each tournamentRecord\n      const result = courtsAdd({ ...params, tournamentRecord });\n      for (const court of result?.courts ?? []) {\n        courtIds.push(court?.courtId);\n      }\n      if (result.error) return result;\n      success = true;\n    }\n  }\n\n  return success ? { ...SUCCESS, courtIds } : { error: VENUE_NOT_FOUND };\n}\n\nexport type AddCourtsArgs = {\n  dateAvailability?: Availability[];\n  venueAbbreviationRoot?: string;\n  tournamentRecord: Tournament;\n  courtNameRoot?: string;\n  courtNames?: string[];\n  courtTimings?: any[];\n  courtsCount?: number;\n  courtIds?: string[];\n  startTime?: string;\n  endTime?: string;\n  idPrefix?: string;\n  venueId: string;\n  dates: string[];\n};\n\nexport function courtsAdd({\n  courtNameRoot = 'Court',\n  dateAvailability = [],\n  venueAbbreviationRoot,\n  tournamentRecord,\n  courtNames = [],\n  courtTimings,\n  courtsCount,\n  startTime,\n  courtIds,\n  endTime,\n  idPrefix,\n  venueId,\n  dates,\n}: AddCourtsArgs): ResultType & { courts?: Court[] } {\n  if (!venueId) return { error: MISSING_VENUE_ID };\n  const result = findVenue({ tournamentRecord, venueId });\n  if (result.error) return result;\n\n  const { venue } = result;\n\n  if (!isNumeric(courtsCount) || !courtNames)\n    return { error: MISSING_COURTS_INFO };\n\n  courtsCount = courtsCount ?? courtNames.length;\n  const courts = generateRange(0, courtsCount).map((i) => {\n    const courtTiming = courtTimings?.[i];\n    const courtAvailability = courtTiming\n      ? dates.map((date) => ({\n          date: formatDate(date),\n          startTime,\n          endTime,\n          ...courtTiming,\n        }))\n      : dateAvailability;\n\n    // when courtTiming is provided, also add default availability\n    if (courtTiming && startTime && endTime)\n      courtAvailability.push({ startTime, endTime });\n\n    return {\n      courtName:\n        courtNames[i] ||\n        (venueAbbreviationRoot &&\n          venue?.venueAbbreviation &&\n          `${venue?.venueAbbreviation} ${i + 1}`) ||\n        `${courtNameRoot} ${i + 1}`,\n      dateAvailability: courtAvailability,\n    };\n  });\n\n  const mapResult: any[] = courts.map((court, i) => {\n    const courtId = courtIds?.pop() || (idPrefix && `${idPrefix}-${i + 1}`);\n    return addCourt({\n      disableNotice: true,\n      tournamentRecord,\n      courtId,\n      venueId,\n      court,\n    });\n  });\n\n  const courtRecords = mapResult\n    .map((outcome) => outcome.court)\n    .filter(Boolean);\n  if (courtRecords.length !== courtsCount) {\n    return decorateResult({\n      info: 'not all courts could be generated',\n      result: { error: INVALID_VALUES },\n    });\n  }\n\n  if (venue)\n    addNotice({\n      payload: { venue, tournamentId: tournamentRecord.tournamentId },\n      topic: MODIFY_VENUE,\n      key: venue.venueId,\n    });\n\n  return { ...SUCCESS, courts: makeDeepCopy(courtRecords) };\n}\n","import { generateDateRange, formatDate } from '../../utilities/dateTime';\nimport { UUID } from '../../utilities/UUID';\nimport { addCourts } from './addCourt';\nimport { addVenue } from './addVenue';\n\nimport { Tournament } from '../../types/tournamentTypes';\n\ntype GenerateVenuesArgs = {\n  tournamentRecord: Tournament;\n  venueProfiles: any[];\n  uuids?: string[];\n};\n\nexport function generateVenues({ tournamentRecord, venueProfiles, uuids }: GenerateVenuesArgs) {\n  const { startDate, endDate } = tournamentRecord;\n  const venueIds: string[] = [];\n\n  for (const [index, venueProfile] of venueProfiles.entries()) {\n    const {\n      venueAbbreviation,\n      venueId = uuids?.pop() ?? UUID(),\n      dateAvailability,\n      startTime = '07:00',\n      endTime = '19:00',\n      courtTimings,\n      courtsCount,\n      courtNames,\n      venueName,\n      idPrefix,\n      courtIds,\n    } = venueProfile;\n\n    const newVenue = {\n      venueName: venueName || `Venue ${index + 1}`,\n      venueAbbreviation,\n      venueId,\n    };\n    const result = addVenue({ tournamentRecord, venue: newVenue });\n    if (result.error) return result;\n\n    venueIds.push(venueId);\n\n    const dates = generateDateRange(startDate, endDate);\n    const generatedDateAvailability =\n      !Array.isArray(dateAvailability) &&\n      [{ startTime, endTime }].concat(\n        dates.map((date) => ({\n          date: formatDate(date),\n          startTime,\n          endTime,\n        })),\n      );\n\n    const addResult = addCourts({\n      dateAvailability: dateAvailability || generatedDateAvailability,\n      tournamentRecord,\n      courtTimings,\n      courtsCount,\n      courtNames,\n      startTime,\n      idPrefix,\n      courtIds,\n      endTime,\n      venueId,\n      dates,\n    });\n    if (addResult.error) return addResult;\n  }\n\n  return venueIds;\n}\n","import { MAIN, QUALIFYING } from '../../constants/drawDefinitionConstants';\n\nexport function getStageParticipantsCount({ drawProfiles, category, gender }) {\n  const uniqueParticipantsCount = {};\n  const stageParticipantsCount = drawProfiles?.reduce(\n    (stageParticipantsCount, drawProfile) => {\n      const {\n        qualifyingPositions = 0,\n        participantsCount = 0,\n        uniqueParticipants,\n        stage = MAIN,\n        drawSize = 0,\n      } = drawProfile || {};\n\n      if (!Object.keys(stageParticipantsCount).includes(stage))\n        stageParticipantsCount[stage] = 0;\n\n      const stageCount = (participantsCount || drawSize) - qualifyingPositions;\n      const requiresUniqueParticipants =\n        uniqueParticipants || gender || category || stage === QUALIFYING;\n\n      if (requiresUniqueParticipants) {\n        if (!Object.keys(uniqueParticipantsCount).includes(stage))\n          uniqueParticipantsCount[stage] = 0;\n        uniqueParticipantsCount[stage] += stageCount;\n      } else {\n        stageParticipantsCount[stage] = Math.max(\n          stageParticipantsCount[stage],\n          stageCount\n        );\n      }\n      return stageParticipantsCount;\n    },\n    {}\n  );\n\n  const uniqueParticipantStages = Object.keys(uniqueParticipantsCount);\n  uniqueParticipantStages.forEach(\n    (stage) => (stageParticipantsCount[stage] += uniqueParticipantsCount[stage])\n  );\n\n  return {\n    stageParticipantsCount,\n    uniqueParticipantsCount,\n    uniqueParticipantStages,\n  };\n}\n","import { MAIN, QUALIFYING } from '../../constants/drawDefinitionConstants';\n\nexport function getStageParticipants({\n  allUniqueParticipantIds,\n  stageParticipantsCount,\n  eventParticipantType,\n  targetParticipants,\n}) {\n  const mainParticipantsCount = stageParticipantsCount[MAIN] || 0;\n  const qualifyingParticipantsCount = stageParticipantsCount[QUALIFYING] || 0;\n\n  // this is only used for non-unique participants\n  const stageParticipants = {\n    QUALIFYING: targetParticipants\n      .filter(({ participantType }) => participantType === eventParticipantType)\n      .filter(\n        ({ participantId }) => !allUniqueParticipantIds.includes(participantId)\n      )\n      .slice(0, qualifyingParticipantsCount),\n    MAIN: targetParticipants\n      .filter(({ participantType }) => participantType === eventParticipantType)\n      .filter(\n        ({ participantId }) => !allUniqueParticipantIds.includes(participantId)\n      )\n      .slice(\n        qualifyingParticipantsCount,\n        qualifyingParticipantsCount + mainParticipantsCount\n      ),\n  };\n\n  return { stageParticipants };\n}\n","import { addDrawDefinitionTimeItem } from '../drawDefinitions/addDrawDefinitionTimeItem';\nimport { participantScaleItem } from '../../query/participant/participantScaleItem';\nimport { addEventTimeItem, addTournamentTimeItem } from '../timeItems/addTimeItem';\nimport { addNotice, getTopics } from '../../global/state/globalState';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { findEvent } from '../../acquire/findEvent';\n\nimport { ADD_SCALE_ITEMS, AUDIT, MODIFY_PARTICIPANTS } from '../../constants/topicConstants';\nimport { Participant, Tournament } from '../../types/tournamentTypes';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { SCALE } from '../../constants/scaleConstants';\nimport { ScaleItem } from '../../types/factoryTypes';\nimport {\n  INVALID_SCALE_ITEM,\n  MISSING_PARTICIPANT,\n  MISSING_PARTICIPANTS,\n  MISSING_TOURNAMENT_RECORD,\n  NO_MODIFICATIONS_APPLIED,\n  PARTICIPANT_NOT_FOUND,\n  VALUE_UNCHANGED,\n} from '../../constants/errorConditionConstants';\n\ntype SetParticipantScaleItemArgs = {\n  tournamentRecord: Tournament;\n  removePriorValues?: boolean;\n  participantId: string;\n  scaleItem?: ScaleItem;\n};\n\nexport function setParticipantScaleItem(params: SetParticipantScaleItemArgs) {\n  const { removePriorValues, tournamentRecord, participantId, scaleItem } = params;\n  let equivalentValue, participant;\n\n  if (!isValidScaleItem({ scaleItem })) return { error: INVALID_SCALE_ITEM };\n\n  if (participantId && Array.isArray(tournamentRecord.participants)) {\n    participant = tournamentRecord.participants.find((participant) => participant.participantId === participantId);\n\n    if (participant) {\n      const result = addParticipantScaleItem({\n        removePriorValues,\n        participant,\n        scaleItem,\n      });\n      if (result.error) return result;\n\n      equivalentValue = !result.valueChanged;\n\n      const { topics } = getTopics();\n      if (topics.includes(MODIFY_PARTICIPANTS)) {\n        addNotice({\n          topic: MODIFY_PARTICIPANTS,\n          payload: {\n            tournamentId: tournamentRecord.tournamentId,\n            participants: [participant],\n          },\n        });\n      }\n    }\n  }\n\n  return (\n    (equivalentValue && {\n      ...SUCCESS,\n      info: VALUE_UNCHANGED,\n      existingValue: scaleItem?.scaleValue,\n    }) ||\n    (participant && { ...SUCCESS, newValue: scaleItem?.scaleValue }) || {\n      error: PARTICIPANT_NOT_FOUND,\n    }\n  );\n}\n\ntype SetParticipantScaleItemsArgs = {\n  scaleItemsWithParticipantIds: {\n    scaleItems: ScaleItem[];\n    participantId: string;\n  }[];\n  context?: { [key: string]: any };\n  tournamentRecord: Tournament;\n  removePriorValues?: boolean;\n  auditData?: any;\n};\n\nexport function setParticipantScaleItems(params: SetParticipantScaleItemsArgs) {\n  const { scaleItemsWithParticipantIds = [], removePriorValues, tournamentRecord, auditData, context } = params;\n\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!tournamentRecord.participants) return { error: MISSING_PARTICIPANTS };\n\n  let modificationsApplied = 0;\n  const participantScaleItemsMap = {};\n\n  const modifiedParticipants: Participant[] = [];\n\n  for (const item of scaleItemsWithParticipantIds) {\n    const participantId = item?.participantId;\n    if (Array.isArray(item?.scaleItems)) {\n      for (const scaleItem of item.scaleItems) {\n        if (isValidScaleItem({ scaleItem })) {\n          if (!Array.isArray(participantScaleItemsMap[participantId])) {\n            participantScaleItemsMap[participantId] = [];\n          }\n          participantScaleItemsMap[participantId].push(scaleItem);\n        } else {\n          return { error: INVALID_SCALE_ITEM };\n        }\n      }\n    }\n  }\n\n  tournamentRecord.participants.forEach((participant) => {\n    const { participantId } = participant || {};\n    if (Array.isArray(participantScaleItemsMap[participantId])) {\n      participantScaleItemsMap[participantId].forEach((scaleItem) => {\n        addParticipantScaleItem({ participant, scaleItem, removePriorValues });\n        modifiedParticipants.push(participant);\n        modificationsApplied++;\n      });\n    }\n  });\n\n  const info = !modificationsApplied ? NO_MODIFICATIONS_APPLIED : undefined;\n  const { topics } = getTopics();\n  if (topics.includes(MODIFY_PARTICIPANTS) && modificationsApplied) {\n    addNotice({\n      topic: MODIFY_PARTICIPANTS,\n      payload: {\n        tournamentId: tournamentRecord.tournamentId,\n        participants: modifiedParticipants,\n      },\n    });\n  }\n\n  if (context) {\n    const { eventId, drawId, ...itemValue } = context;\n    const itemSubTypes = itemValue.scaleAttributes?.scaleType && [itemValue.scaleAttributes.scaleType];\n    if (Object.keys(itemValue).length) {\n      const timeItem: any = {\n        itemType: ADD_SCALE_ITEMS,\n        itemValue,\n      };\n      if (itemSubTypes) timeItem.itemSubTypes = itemSubTypes;\n\n      if (drawId || eventId) {\n        const { drawDefinition, event } = findEvent({\n          tournamentRecord,\n          eventId,\n          drawId,\n        });\n\n        if (drawId) {\n          addDrawDefinitionTimeItem({ drawDefinition, timeItem });\n        }\n        if (eventId) {\n          addEventTimeItem({ event, timeItem });\n        }\n      } else {\n        addTournamentTimeItem({ tournamentRecord, timeItem });\n      }\n    }\n  }\n\n  if (auditData && topics.includes(AUDIT)) {\n    addNotice({ topic: AUDIT, payload: auditData });\n  }\n\n  return definedAttributes({ ...SUCCESS, modificationsApplied, info });\n}\n\nfunction isValidScaleItem({ scaleItem }) {\n  const scaleItemAttributes = scaleItem && Object.keys(scaleItem);\n  const requiredAttributes = ['scaleType', 'eventType', 'scaleName'];\n  const validScaleItem =\n    requiredAttributes.filter((attribute) => scaleItemAttributes?.includes(attribute)).length ===\n    requiredAttributes.length;\n  return !!validScaleItem;\n}\n\nexport function addParticipantScaleItem({ removePriorValues, participant, scaleItem }): ResultType & {\n  valueChanged?: boolean;\n  newValue?: any;\n} {\n  if (!participant) {\n    return { error: MISSING_PARTICIPANT };\n  }\n\n  const scaleItemAttributes = scaleItem && Object.keys(scaleItem);\n  const requiredAttributes = ['scaleType', 'eventType', 'scaleName'];\n  const validScaleItem =\n    requiredAttributes.filter((attribute) => scaleItemAttributes.includes(attribute) && scaleItem[attribute]).length ===\n    requiredAttributes.length;\n\n  if (!validScaleItem) return { error: INVALID_SCALE_ITEM };\n\n  const createdAt = new Date().toISOString();\n  if (!participant.timeItems) participant.timeItems = [];\n\n  const { scaleItem: existingScaleItem } = participantScaleItem({\n    scaleAttributes: scaleItem,\n    participant,\n  });\n\n  const isUndefined = (value) => [undefined, null, ''].includes(value);\n\n  const valueChanged =\n    !(isUndefined(existingScaleItem?.scaleValue) && isUndefined(scaleItem.scaleValue)) &&\n    JSON.stringify(existingScaleItem?.scaleValue) !== JSON.stringify(scaleItem.scaleValue);\n\n  if (valueChanged) {\n    const { scaleType, eventType, scaleName } = scaleItem;\n    const itemType = [SCALE, scaleType, eventType, scaleName].join('.');\n\n    const timeItem = definedAttributes({\n      itemValue: scaleItem.scaleValue,\n      itemDate: scaleItem.scaleDate,\n      createdAt,\n      itemType,\n    });\n\n    // if there is a unique identifier for the scale\n    if (scaleItem.scaleId) {\n      timeItem.itemSubTypes = [scaleItem.scaleId];\n    }\n\n    if (removePriorValues) {\n      participant.timeItems = participant.timeItems.filter((timeItem) => timeItem.itemType !== itemType);\n    }\n\n    participant.timeItems.push(timeItem);\n  }\n\n  return { ...SUCCESS, valueChanged, newValue: scaleItem.scaleValue };\n}\n","import { MISSING_VALUE } from '../../constants/errorConditionConstants';\nimport { parse } from '../../assemblies/generators/matchUpFormatCode/parse';\n\ntype GetSetWinningSideArgs = {\n  matchUpScoringFormat: any;\n  isTiebreakSet?: boolean;\n  isDecidingSet?: boolean;\n  setObject: any;\n};\n\nexport function getSetWinningSide({\n  matchUpScoringFormat,\n  isDecidingSet,\n  isTiebreakSet,\n  setObject,\n}: GetSetWinningSideArgs) {\n  if (!setObject) return undefined;\n  const leadingSide = getLeadingSide({ set: setObject });\n  const setIsComplete = checkSetIsComplete({\n    matchUpScoringFormat,\n    isDecidingSet,\n    isTiebreakSet,\n    set: setObject,\n  });\n  return (setIsComplete && leadingSide) || undefined;\n}\n\ntype CheckSetIsCompleteArgs = {\n  matchUpScoringFormat: any;\n  ignoreTiebreak?: boolean;\n  isDecidingSet?: boolean;\n  isTiebreakSet?: boolean;\n  matchUpFormat?: string;\n  set: any;\n};\n\nexport function checkSetIsComplete({\n  ignoreTiebreak = false,\n  matchUpScoringFormat,\n  matchUpFormat,\n  isTiebreakSet,\n  isDecidingSet,\n  set,\n}: CheckSetIsCompleteArgs) {\n  if (!set) return { error: MISSING_VALUE, info: 'missing set' };\n  matchUpScoringFormat =\n    matchUpScoringFormat || (matchUpFormat && parse(matchUpFormat));\n\n  const setFormat =\n    (isDecidingSet && matchUpScoringFormat.finalSetFormat) ||\n    matchUpScoringFormat?.setFormat ||\n    {};\n  const { side1Score, side2Score } = set;\n\n  const { setTo, tiebreakAt, tiebreakFormat } = setFormat;\n  const NoAD = tiebreakFormat?.NoAd;\n\n  const leadingSide = getLeadingSide({ set });\n  const scoreDiff = Math.abs(side1Score - side2Score);\n  const containsSetTo = side1Score >= setTo || side2Score >= setTo;\n\n  const requiresTiebreak =\n    isTiebreakSet ||\n    (side1Score >= setTo && side2Score >= setTo) ||\n    (tiebreakAt &&\n      tiebreakAt < setTo &&\n      (side1Score === tiebreakAt || side2Score === tiebreakAt));\n\n  const tiebreakIsValid =\n    ignoreTiebreak ||\n    (requiresTiebreak &&\n      ((leadingSide === 1 && set.side1TiebreakScore > set.side2TiebreakScore) ||\n        (leadingSide === 2 &&\n          set.side2TiebreakScore > set.side1TiebreakScore)));\n\n  const winMargin =\n    requiresTiebreak &&\n    ((tiebreakAt && !isTiebreakSet) || (isTiebreakSet && NoAD))\n      ? 1\n      : 2;\n  const hasWinMargin = scoreDiff >= winMargin;\n  const validNormalSetScore =\n    containsSetTo && (hasWinMargin || requiresTiebreak);\n\n  return (\n    (validNormalSetScore || isTiebreakSet) &&\n    (!requiresTiebreak || tiebreakIsValid)\n  );\n}\n\nexport function getLeadingSide({ set }) {\n  if (set.side1Score || set.side2Score) {\n    if (set.side1Score > set.side2Score) return 1;\n    if (set.side2Score > set.side1Score) return 2;\n  } else if (set.side1TiebreakScore || set.side2TiebreakScore) {\n    if (set.side1TiebreakScore > set.side2TiebreakScore) return 1;\n    if (set.side2TiebreakScore > set.side1TiebreakScore) return 2;\n  }\n  return undefined;\n}\n","import { getSetWinningSide } from './getSetWinningSide';\n\nimport {\n  INVALID_GAME_SCORES,\n  INVALID_VALUES,\n  INVALID_WINNING_SIDE,\n  MISSING_SET_OBJECT,\n} from '../../constants/errorConditionConstants';\n\nexport function analyzeSet(params) {\n  const { setObject, matchUpScoringFormat } = params;\n  if (!setObject) return { error: MISSING_SET_OBJECT };\n\n  const { setNumber } = setObject || {};\n  const { bestOf } = matchUpScoringFormat || {};\n  const isDecidingSet = !!(setNumber && bestOf && setNumber === bestOf);\n  const setFormat =\n    (isDecidingSet && matchUpScoringFormat?.finalSetFormat) ||\n    matchUpScoringFormat?.setFormat;\n  const expectTiebreakSet = !!setFormat?.tiebreakSet;\n  const expectTimedSet = !!setFormat?.timed;\n  const expectStandardSet = !expectTiebreakSet && !expectTimedSet;\n\n  const isValidSetNumber = !!(setNumber && bestOf && setNumber <= bestOf);\n\n  const sideGameScores = [setObject?.side1Score, setObject?.side2Score];\n  const sidePointScores = [\n    setObject?.side1PointScore,\n    setObject?.side2PointScore,\n  ];\n  const sideTiebreakScores = [\n    setObject?.side1TiebreakScore,\n    setObject?.side2TiebreakScore,\n  ];\n  const sideGameScoresCount = sideGameScores.filter(\n    (sideScore) => sideScore !== undefined\n  ).length;\n  const sidePointScoresCount = sidePointScores.filter(\n    (sideScore) => sideScore !== undefined\n  ).length;\n  const sideTiebreakScoresCount = sideTiebreakScores.filter(\n    (tiebreakScore) => tiebreakScore !== undefined\n  ).length;\n\n  const gameScoresCount = sideGameScores?.filter((s) => !isNaN(s)).length;\n  const tiebreakScoresCount = sideTiebreakScores?.filter((s) => !isNaN(s))\n    .length;\n\n  const { tiebreakAt } = setFormat || {};\n  const hasTiebreakCondition =\n    tiebreakAt &&\n    sideGameScores.filter((gameScore) => gameScore >= tiebreakAt).length === 2;\n\n  const leadingSide =\n    hasTiebreakCondition &&\n    ((sideGameScores[0] > sideGameScores[1] && 1) ||\n      (sideGameScores[1] > sideGameScores[0] && 2) ||\n      undefined);\n\n  const isTiebreakSet = !!(tiebreakScoresCount && !gameScoresCount);\n\n  const isCompletedSet = !!setObject?.winningSide;\n  const { error: standardSetError, result: isValidStandardSetOutcome } =\n    checkValidStandardSetOutcome({\n      setObject,\n      setFormat,\n      sideGameScores,\n      sideTiebreakScores,\n    });\n\n  const { error: tiebreakSetError, result: isValidTiebreakSetOutcome } =\n    checkValidTiebreakSetOutcome({\n      setObject,\n      setFormat,\n      sideTiebreakScores,\n    });\n\n  const isValidSetOutcome =\n    (expectStandardSet && !isTiebreakSet && isValidStandardSetOutcome) ||\n    (expectTiebreakSet && isTiebreakSet && isValidTiebreakSetOutcome);\n\n  const isValidSet =\n    isValidSetNumber &&\n    !(expectTiebreakSet && !isTiebreakSet) &&\n    !(expectStandardSet && isTiebreakSet) &&\n    (!isCompletedSet || isValidSetOutcome);\n\n  const winningSide = getSetWinningSide({\n    isDecidingSet,\n    isTiebreakSet,\n    matchUpScoringFormat,\n    setObject,\n  });\n\n  const analysis: { [key: string]: any } = {\n    expectTiebreakSet,\n    expectTimedSet,\n    hasTiebreakCondition,\n    isCompletedSet,\n    isDecidingSet,\n    isTiebreakSet,\n    isValidSet,\n    isValidSetNumber,\n    isValidSetOutcome,\n    leadingSide,\n    setFormat,\n    sideGameScores,\n    sideGameScoresCount,\n    sidePointScores,\n    sidePointScoresCount,\n    sideTiebreakScores,\n    sideTiebreakScoresCount,\n    winningSide,\n  };\n\n  if (setObject?.winningSide !== undefined) {\n    if (isTiebreakSet) {\n      analysis.isValidTiebreakSetOutcome = isValidTiebreakSetOutcome;\n      if (!isValidTiebreakSetOutcome) {\n        analysis.tiebreakSetError = tiebreakSetError;\n      }\n    } else {\n      analysis.isValidStandardSetOutcome = isValidStandardSetOutcome;\n      if (!isValidStandardSetOutcome) {\n        analysis.standardSetError = standardSetError;\n      }\n    }\n  }\n\n  return analysis;\n}\n\nfunction checkValidStandardSetOutcome({\n  setObject,\n  setFormat,\n  sideGameScores,\n  sideTiebreakScores,\n}) {\n  if (!setObject) {\n    return { result: false, error: MISSING_SET_OBJECT };\n  }\n  const expectTiebreakSet = !!setFormat?.tiebreakSet;\n  const expectTimedSet = !!setFormat?.timed;\n  if (!setFormat || expectTiebreakSet || expectTimedSet) {\n    return { result: false, error: INVALID_VALUES };\n  }\n\n  const validGameScores = sideGameScores?.filter((s) => !isNaN(s)).length === 2;\n  if (!validGameScores) return { result: false, error: INVALID_GAME_SCORES };\n\n  const { setTo, tiebreakAt, tiebreakFormat, NoAD } = setFormat || {};\n  const meetsSetTo = !!(\n    setTo && sideGameScores?.find((gameScore) => gameScore >= setTo)\n  );\n  if (!meetsSetTo) return { result: false, error: INVALID_GAME_SCORES };\n\n  const isValidWinningSide = [1, 2].includes(setObject?.winningSide);\n  if (!setObject || !isValidWinningSide)\n    return { result: false, error: INVALID_WINNING_SIDE };\n\n  const winningSideIndex = setObject?.winningSide - 1;\n  const losingSideIndex = 1 - winningSideIndex;\n  const winningSideGameScore = sideGameScores[winningSideIndex];\n  const losingSideGameScore = sideGameScores[losingSideIndex];\n  const gamesDifference = winningSideGameScore - losingSideGameScore;\n  const winningSideIsHighGameValue = winningSideGameScore > losingSideGameScore;\n  if (!winningSideIsHighGameValue) {\n    return {\n      result: false,\n      error: { message: 'winningSide game scoreString is not high' },\n    };\n  }\n\n  const setTiebreakDefined = tiebreakAt && tiebreakFormat;\n  const validTiebreakScores =\n    sideTiebreakScores?.filter((s) => !isNaN(s)).length === 2;\n  const winningSideTiebreakScore = sideTiebreakScores?.[winningSideIndex];\n  const losingSideTiebreakScore = sideTiebreakScores?.[losingSideIndex];\n\n  const hasTiebreakCondition =\n    tiebreakAt &&\n    sideGameScores.filter((gameScore) => gameScore >= tiebreakAt).length === 2;\n\n  if (setTiebreakDefined) {\n    const { NoAD: tiebreakNoAD, tiebreakTo } = tiebreakFormat;\n\n    if (hasTiebreakCondition) {\n      if (gamesDifference > 1) {\n        return {\n          result: false,\n          error: { message: 'invalid winning game scoreString (5)' },\n        };\n      }\n      if (!validTiebreakScores) {\n        return {\n          result: false,\n          error: { message: 'invalid tiebreak scores (1)' },\n        };\n      }\n\n      if (isNaN(tiebreakTo)) {\n        return { result: false, error: { message: 'tiebreakTo error' } }; // TODO: test this\n      }\n\n      const meetsTiebreakTo = !!(\n        tiebreakTo &&\n        sideTiebreakScores?.find((tiebreakScore) => tiebreakScore >= tiebreakTo)\n      );\n      if (!meetsTiebreakTo) {\n        return {\n          result: false,\n          error: { message: 'invalid tiebreak scores (2)' },\n        };\n      }\n\n      const maxGameScore = tiebreakAt < setTo ? setTo : setTo + 1;\n      if (winningSideGameScore > maxGameScore) {\n        return {\n          result: false,\n          error: { message: 'invalid winning game scoreString (1)' },\n        };\n      }\n\n      if (\n        !winningSideTiebreakScore ||\n        !losingSideTiebreakScore ||\n        winningSideTiebreakScore < losingSideTiebreakScore\n      ) {\n        return {\n          result: false,\n          error: { message: 'winningSide tiebreak value is not high' },\n        };\n      }\n\n      const minimumTiebreakWinMargin = tiebreakNoAD ? 1 : 2;\n      const tiebreakDifference =\n        winningSideTiebreakScore - losingSideTiebreakScore;\n      const losingSideGameScoreAtTiebreakToThreshold =\n        losingSideTiebreakScore >= tiebreakTo - 1;\n      const invalidTiebreakScore =\n        tiebreakDifference &&\n        losingSideGameScoreAtTiebreakToThreshold &&\n        tiebreakDifference < minimumTiebreakWinMargin;\n\n      if (invalidTiebreakScore) {\n        return {\n          result: false,\n          error: { message: 'invalid tiebreak scores (3)' },\n        };\n      }\n    }\n\n    const hasTiebreakGameScore = winningSideGameScore > setTo;\n    if (hasTiebreakGameScore && !hasTiebreakCondition) {\n      return {\n        result: false,\n        error: { message: 'invalid winning game scoreString (2)' },\n      };\n    }\n  }\n\n  const minimumGamesWinMargin = NoAD ? 1 : 2;\n  const losingSideGameScoreAtSetToThreshold = losingSideGameScore >= setTo - 1;\n  const invalidWinningScore =\n    gamesDifference &&\n    losingSideGameScoreAtSetToThreshold &&\n    !hasTiebreakCondition &&\n    gamesDifference < minimumGamesWinMargin;\n\n  if (invalidWinningScore) {\n    return {\n      result: false,\n      error: { message: 'invalid winning game scoreString (3)' },\n    };\n  }\n\n  if (gamesDifference > minimumGamesWinMargin && winningSideGameScore > setTo) {\n    return {\n      result: false,\n      error: { message: 'invalid winning game scoreString (4)' },\n    };\n  }\n\n  return { result: true };\n}\n\nfunction checkValidTiebreakSetOutcome({\n  setObject,\n  setFormat,\n  sideTiebreakScores,\n}) {\n  if (!setObject) {\n    return { result: false, error: MISSING_SET_OBJECT };\n  }\n  const expectTiebreakSet = !!setFormat?.tiebreakSet;\n  const expectTimedSet = !!setFormat?.timed;\n  if (!setFormat || !expectTiebreakSet || expectTimedSet) {\n    return { result: false, error: { message: 'not tiebreak set' } };\n  }\n\n  const isValidWinningSide = [1, 2].includes(setObject?.winningSide);\n  if (!setObject || !isValidWinningSide)\n    return { result: false, error: INVALID_WINNING_SIDE };\n\n  const { tiebreakSet } = setFormat || {};\n  const { NoAD, tiebreakTo } = tiebreakSet || {};\n\n  const validTiebreakScores =\n    sideTiebreakScores?.filter((s) => !isNaN(s)).length === 2;\n  if (!validTiebreakScores) {\n    return { result: false, error: { message: 'invalid tiebreak scores (1)' } };\n  }\n\n  if (isNaN(tiebreakTo)) {\n    return { result: false, error: { message: 'tiebreakTo error' } }; // TODO: test this\n  }\n\n  const meetsTiebreakTo = !!sideTiebreakScores?.find(\n    (tiebreakScore) => tiebreakScore >= tiebreakTo\n  );\n  if (!meetsTiebreakTo) {\n    return { result: false, error: { message: 'invalid tiebreak scores (2)' } };\n  }\n\n  const winningSideIndex = setObject?.winningSide - 1;\n  const losingSideIndex = 1 - winningSideIndex;\n  const winningSideTiebreakScore = sideTiebreakScores[winningSideIndex];\n  const losingSideTiebreakScore = sideTiebreakScores[losingSideIndex];\n\n  if (\n    !winningSideTiebreakScore ||\n    !losingSideTiebreakScore ||\n    winningSideTiebreakScore < losingSideTiebreakScore\n  ) {\n    return {\n      result: false,\n      error: { message: 'winningSide tiebreak value is not high' },\n    };\n  }\n\n  const minimumTiebreakWinMargin = NoAD ? 1 : 2;\n  const tiebreakDifference = winningSideTiebreakScore - losingSideTiebreakScore;\n  const losingSideGameScoreAtTiebreakToThreshold =\n    losingSideTiebreakScore >= tiebreakTo - 1;\n  const invalidTiebreakScore =\n    tiebreakDifference &&\n    losingSideGameScoreAtTiebreakToThreshold &&\n    tiebreakDifference < minimumTiebreakWinMargin;\n\n  if (invalidTiebreakScore) {\n    return { result: false, error: { message: 'invalid tiebreak scores (3)' } };\n  }\n\n  return { result: true };\n}\n","import { parse } from '../../assemblies/generators/matchUpFormatCode/parse';\nimport { instanceCount } from '../../utilities/arrays';\nimport { analyzeSet } from './analyzeSet';\n\nimport { MISSING_MATCHUP } from '../../constants/errorConditionConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\n\n// TODO: what about checking array of sets are in order? ( setNumber )\n\nexport function analyzeMatchUp(params?): ResultType & {\n  matchUpScoringFormat?: any;\n  validMatchUpOutcome?: boolean;\n  calculatedWinningSide?: number;\n  validMatchUpWinningSide?: boolean;\n  completedSetsHaveValidOutcomes?: boolean;\n  isLastSetWithValues?: boolean;\n  completedSetsCount?: number;\n  isCompletedMatchUp?: boolean;\n  isValidSideNumber?: boolean;\n  hasExistingValue?: boolean;\n  existingValue?: number;\n  expectTimedSet?: boolean;\n  isExistingSet?: boolean;\n  isActiveSet?: boolean;\n  isCompletedSet?: boolean;\n  sideGameScores?: number[];\n  sidePointScores?: number[];\n  sideTiebreakScores?: number[];\n  winningSide?: number;\n} {\n  const { matchUp, sideNumber, setNumber, isTiebreakValue, isPointValue } = params || {};\n  let { matchUpFormat } = params || {};\n  if (!matchUp) return { error: MISSING_MATCHUP };\n\n  matchUpFormat = matchUpFormat || matchUp?.matchUpFormat;\n  const matchUpScoringFormat = parse(matchUpFormat);\n  const isCompletedMatchUp = !!matchUp?.winningSide;\n\n  const sets = matchUp.score?.sets;\n  const setsCount = sets?.length;\n  const setIndex = setNumber && setNumber - 1;\n  const isExistingSet = !!sets?.find((set, index) => set.setNumber === setNumber && index === setIndex);\n  const completedSets = sets?.filter((set) => set?.winningSide) || [];\n  const completedSetsCount = completedSets?.length || 0;\n  const setsFollowingCurrent = (setNumber && sets?.slice(setNumber)) || [];\n  const isLastSetWithValues = !!(\n    setsCount &&\n    setNumber &&\n    // EVERY: is this a candidate for .every?\n    setsFollowingCurrent?.reduce((noValues, set) => {\n      return (\n        (!set ||\n          (!set.side1Score &&\n            !set.side2Score &&\n            !set.side1TiebreakScore &&\n            !set.side2TiebreakScore &&\n            !set.side1PointScore &&\n            !set.side2PointScore)) &&\n        noValues\n      );\n    }, true)\n  );\n\n  const setObject = setNumber <= setsCount && sets.find((set) => set.setNumber === setNumber);\n  const specifiedSetAnalysis = setObject && analyzeSet({ setObject, matchUpScoringFormat });\n\n  const {\n    isCompletedSet,\n    sideGameScores,\n    // sidePointScores,\n    sideTiebreakScores,\n  } = specifiedSetAnalysis || {};\n  const isActiveSet = !!(\n    (setObject && !isCompletedSet && isLastSetWithValues) ||\n    (setNumber && setNumber === setsCount + 1 && !isCompletedMatchUp)\n  );\n\n  const isValidSideNumber = [1, 2].includes(sideNumber);\n  const sideIndex = isValidSideNumber ? sideNumber - 1 : 0;\n\n  const existingValue =\n    setObject &&\n    isValidSideNumber &&\n    ((!isTiebreakValue && !isPointValue && sideGameScores[sideIndex] !== undefined && sideGameScores[sideIndex]) ||\n      (isTiebreakValue && sideTiebreakScores[sideIndex] !== undefined && sideTiebreakScores[sideIndex]));\n  const hasExistingValue = !!existingValue;\n\n  const completedSetsHaveValidOutcomes = completedSets\n    ?.map((setObject) => analyzeSet({ setObject, matchUpScoringFormat }).isValidSetOutcome)\n    .reduce((valid, validOutcome) => valid && validOutcome, true);\n\n  const setsWinCounts = completedSets.reduce(\n    (counts, set) => {\n      const { winningSide } = set;\n      const winningSideIndex = winningSide - 1;\n      counts[winningSideIndex]++;\n      return counts;\n    },\n    [0, 0],\n  );\n  const matchUpWinningSide = matchUp?.winningSide;\n  const matchUpWinningSideIndex = matchUpWinningSide && matchUpWinningSide - 1;\n  const matchUpLosingSideIndex = 1 - matchUpWinningSideIndex;\n  const winningSideSetsCount = setsWinCounts[matchUpWinningSideIndex];\n  const losingSideSetsCount = setsWinCounts[matchUpLosingSideIndex];\n\n  const maxSetsCount = Math.max(...setsWinCounts);\n  const maxSetsInstances = instanceCount(setsWinCounts)[maxSetsCount];\n  const { bestOf } = matchUpScoringFormat ?? {};\n  const setsToWin = (bestOf && Math.ceil(bestOf / 2)) || 1;\n  const calculatedWinningSide =\n    (maxSetsCount === setsToWin && maxSetsInstances === 1 && setsWinCounts.indexOf(maxSetsCount) + 1) || undefined;\n\n  const validMatchUpWinningSide =\n    winningSideSetsCount > losingSideSetsCount && matchUpWinningSide === calculatedWinningSide;\n\n  const validMatchUpOutcome = calculatedWinningSide && completedSetsHaveValidOutcomes && validMatchUpWinningSide;\n\n  return {\n    completedSetsHaveValidOutcomes,\n    validMatchUpWinningSide,\n    calculatedWinningSide,\n    matchUpScoringFormat,\n    validMatchUpOutcome,\n    isLastSetWithValues,\n    completedSetsCount,\n    isCompletedMatchUp,\n    isValidSideNumber,\n    hasExistingValue,\n    existingValue,\n    isExistingSet,\n    isActiveSet,\n    ...specifiedSetAnalysis,\n  };\n}\n","import { isValidMatchUpFormat } from '../../../validators/isValidMatchUpFormat';\nimport { generateRange, randomPop } from '../../../utilities/arrays';\nimport { analyzeMatchUp } from '../../../query/matchUp/analyzeMatchUp';\nimport { randomInt, weightedRandom } from '../../../utilities/math';\nimport { analyzeSet } from '../../../query/matchUp/analyzeSet';\nimport { matchUpScore } from '../matchUps/matchUpScore';\nimport { parse } from '../matchUpFormatCode/parse';\nimport {\n  getSetComplement,\n  getTiebreakComplement,\n} from '../../../query/matchUp/getComplement';\n\nimport { FORMAT_STANDARD } from '../../../fixtures/scoring/matchUpFormats';\nimport {\n  INVALID_MATCHUP_FORMAT,\n  INVALID_VALUES,\n} from '../../../constants/errorConditionConstants';\nimport {\n  COMPLETED,\n  DEFAULTED,\n  DOUBLE_WALKOVER,\n  RETIRED,\n  WALKOVER,\n  INCOMPLETE,\n  SUSPENDED,\n  matchUpStatusConstants,\n  completedMatchUpStatuses,\n  DOUBLE_DEFAULT,\n} from '../../../constants/matchUpStatusConstants';\n\n// percentages rounded to the nearest whole number\nconst defaultStatusProfile = {\n  [WALKOVER]: 2,\n  [DOUBLE_WALKOVER]: 1,\n  [DOUBLE_DEFAULT]: 1,\n  [RETIRED]: 1,\n  [DEFAULTED]: 4,\n};\n\n// TODO: timed sets && NoAd\n\n/**\n *\n * @param {string} matchUpFormat - optional - TODS matchUpFormat code string - defaults to 'SET3-S:6/TB7'\n * @param {object} matchUpStatusProfile - optional - whole number percent for each target matchUpStatus { [matchUpStatus]: percentLikelihood }\n * @param {integer} pointsPerMinute - optional - value used for generating timed sets scores\n * @param {integer} sideWeight - optional - the larger the number the less likely a deciding (e.g. 3rd) set is generated\n * @param {integer} winningSide - optional - 1 or 2 forces the winningSide\n * @param {integer} defaultWithScorePercent - optional - percentage of the time a DEFAULT should include a score\n *\n * @returns {object} outcome - { score, winningSide, matchUpStatus }\n */\nexport function generateOutcome(params) {\n  let { defaultWithScorePercent = 2, winningSide } = params;\n  const {\n    matchUpStatusProfile = defaultStatusProfile, // { matchUpStatusProfile: {} } will always return only { matchUpStatus: COMPLETED }\n    matchUpFormat = FORMAT_STANDARD,\n    pointsPerMinute = 1,\n    sideWeight = 4,\n  } = params;\n\n  if (!isValidMatchUpFormat({ matchUpFormat }))\n    return { error: INVALID_MATCHUP_FORMAT };\n  if (typeof matchUpStatusProfile !== 'object')\n    return { error: INVALID_VALUES };\n  if (defaultWithScorePercent > 100) defaultWithScorePercent = 100;\n  if (\n    isNaN(defaultWithScorePercent) ||\n    isNaN(pointsPerMinute) ||\n    isNaN(sideWeight)\n  )\n    return { error: INVALID_VALUES };\n\n  const matchUpStatuses = Object.keys(matchUpStatusProfile).filter(\n    (matchUpStatus) =>\n      Object.keys(matchUpStatusConstants).includes(matchUpStatus) &&\n      matchUpStatus !== COMPLETED\n  );\n  const matchUpStatusTotals = Object.keys(matchUpStatuses).reduce(\n    (total, key) => total + matchUpStatusProfile[key],\n    0\n  );\n  if (matchUpStatusTotals > 100)\n    return { error: INVALID_VALUES, matchUpStatusProfile };\n\n  const matchUpStatusMap = matchUpStatuses.reduce(\n    (statusMap: { pointer: number; valueMap: any[][] }, matchUpStatus) => {\n      statusMap.pointer =\n        statusMap.pointer + matchUpStatusProfile[matchUpStatus];\n      statusMap.valueMap.push([statusMap.pointer, matchUpStatus]);\n      return statusMap;\n    },\n    { pointer: 0, valueMap: [] }\n  );\n\n  const outcomePointer = randomInt(1, 100);\n  const matchUpStatus: string = (matchUpStatusMap.valueMap.find(\n    (item) => outcomePointer <= item[0]\n  ) ?? [100, COMPLETED])[1];\n\n  const noScore = { sets: [], scoreStringSide1: '', side2ScoreString: '' };\n  if ([WALKOVER, DEFAULTED].includes(matchUpStatus)) {\n    winningSide = winningSide || randomInt(1, 2);\n    const outcome = {\n      score: noScore,\n      winningSide,\n      matchUpStatus,\n    };\n\n    const scoreDefaulted =\n      matchUpStatus === DEFAULTED &&\n      randomInt(1, 100) > 100 - defaultWithScorePercent;\n    if (!scoreDefaulted) return { outcome };\n  } else if ([DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUpStatus)) {\n    return { outcome: { score: noScore, matchUpStatus } };\n  }\n\n  const parsedFormat = parse(matchUpFormat);\n\n  const { bestOf, setFormat, finalSetFormat } = parsedFormat ?? {};\n\n  const sets: any[] = [];\n  const weightedSide = randomInt(0, 1);\n  const weightedRange = winningSide\n    ? [winningSide - 1]\n    : [\n        ...generateRange(0, sideWeight).map(() => weightedSide),\n        1 - weightedSide,\n      ];\n\n  const incompleteSet = [RETIRED, DEFAULTED, INCOMPLETE, SUSPENDED].includes(\n    matchUpStatus\n  );\n\n  // if there is to be an incomplete set randomize which set is incomplete\n  // for 3 sets this will always be setNumber 1 or setNumber 2\n  // because it is not known in advance whether 3 sets will be generated\n  const incompleteAt =\n    incompleteSet && (randomPop(generateRange(1, bestOf)) || 1);\n\n  // used to capture winner by RETIREMENT or DEFAULT\n  let weightedWinningSide;\n\n  for (const setNumber of generateRange(1, (bestOf ?? 0) + 1)) {\n    const isFinalSet = setNumber === bestOf;\n    const { set, incomplete, winningSideNumber } = generateSet({\n      incomplete: incompleteAt === setNumber,\n      matchUpStatus,\n      pointsPerMinute,\n      setFormat: (isFinalSet && finalSetFormat) || setFormat,\n      setNumber,\n      weightedRange,\n    });\n    sets.push(set);\n\n    if (incomplete) {\n      weightedWinningSide = winningSideNumber;\n      break;\n    }\n\n    const analysis = analyzeMatchUp({\n      matchUp: { score: { sets }, matchUpFormat },\n    });\n    if (analysis.calculatedWinningSide) break;\n  }\n\n  const analysis = analyzeMatchUp({\n    matchUp: { score: { sets }, matchUpFormat },\n  });\n\n  const matchUpWinningSide = weightedWinningSide\n    ? winningSide || weightedWinningSide\n    : analysis.calculatedWinningSide;\n\n  // add the side perspective stringScores\n  const { score } = matchUpScore({\n    score: { sets },\n    winningSide: matchUpWinningSide,\n    matchUpStatus,\n  });\n\n  const outcome = {\n    score,\n    winningSide: matchUpWinningSide,\n    matchUpStatus,\n  };\n\n  return { outcome };\n}\n\n/**\n *\n * @param {integer} setNumber\n * @param {object} setFormat\n * @param {integer[]} weightedRange - weights one side to reduce the number of \"deciding sets\", e.g. 3 set matchUps\n * @returns\n */\nfunction generateSet({\n  weightedRange = [0, 1],\n  pointsPerMinute,\n  matchUpStatus,\n  incomplete,\n  setFormat,\n  setNumber,\n}) {\n  const set: any = { setNumber };\n  const { setTo, tiebreakFormat, tiebreakAt, tiebreakSet, timed, minutes } =\n    setFormat;\n\n  // will tend to be more likely to either reverse or not revderse all sets\n  // preserves randomness of winningSide while reducing deciding set outcomes\n  const weightIndex = randomInt(0, weightedRange.length - 1);\n  const reverseScores = weightedRange[weightIndex];\n  let winningSideNumber;\n\n  if (timed) {\n    const calcPoints = minutes * pointsPerMinute;\n    const pointsVariation = Math.round(calcPoints * 0.2);\n    const totalPoints = calcPoints + randomPop([1, -1]) * pointsVariation;\n    // the use of weightedRandom applies a bell curve distribution to the difference in side scores\n    // the larger the second value, the more pronounced the bell curve will be\n    const sidePoints = weightedRandom(totalPoints, 2);\n    const scores = [sidePoints, totalPoints - sidePoints];\n\n    if (reverseScores) scores.reverse();\n    winningSideNumber = weightedRange[weightIndex] + 1;\n\n    // sides could be tied\n    let highSide =\n      (scores[0] > scores[1] && 1) || (scores[1] > scores[0] && 2) || 0;\n\n    if (incomplete) {\n      const [side1Score, side2Score] = scores;\n      Object.assign(set, { side1Score, side2Score });\n      if (completedMatchUpStatuses.includes(matchUpStatus)) {\n        return { set, incomplete, winningSideNumber };\n      }\n\n      return { set, incomplete };\n    }\n\n    if (!highSide) scores[randomInt(0, 1)] += 1;\n    highSide = scores[0] > scores[1] ? 1 : 2; // sides are not tied\n    if (highSide !== winningSideNumber) scores.reverse();\n\n    const [side1Score, side2Score] = scores;\n    Object.assign(set, {\n      side1Score,\n      side2Score,\n      winningSide: winningSideNumber,\n    });\n\n    return { set };\n  } else if (incomplete) {\n    set.side1Score = randomInt(0, tiebreakAt);\n    set.side2Score = randomInt(0, tiebreakAt);\n\n    if (completedMatchUpStatuses.includes(matchUpStatus)) {\n      winningSideNumber = weightedRange[weightIndex] + 1;\n    }\n\n    return { set, incomplete, winningSideNumber };\n  } else {\n    // weight the range of possible low scores such that tiebreak sets are less likely\n    const range = generateRange(1, setTo + 1)\n      .map((value) => generateRange(0, setTo + 2 - value).map(() => value))\n      .flat();\n    const lowValue = range[randomInt(0, range.length - 1)];\n\n    const scores =\n      setTo &&\n      getSetComplement({\n        isSide1: true,\n        tiebreakAt,\n        lowValue,\n        setTo,\n      });\n    const isTiebreakSet = !scores;\n    const specifiedWinningSide =\n      weightedRange.length === 1 && weightedRange[weightIndex] + 1;\n\n    if (!isTiebreakSet) {\n      if (specifiedWinningSide) {\n        const highSide = scores[0] > scores[1] ? 1 : 2; // sides are not tied\n        if (highSide !== specifiedWinningSide) scores.reverse();\n      } else if (reverseScores) {\n        scores.reverse();\n      }\n\n      const [side1Score, side2Score] = scores;\n      Object.assign(set, { side1Score, side2Score });\n    }\n\n    const setAnalysis = analyzeSet({\n      matchUpScoringFormat: { setFormat },\n      setObject: set,\n    });\n\n    let tiebreakWinningSide;\n    if (setAnalysis.hasTiebreakCondition || isTiebreakSet) {\n      const { NoAD: tiebreakNoAd, tiebreakTo } =\n        tiebreakFormat || tiebreakSet || {};\n      const range = generateRange(1, tiebreakTo + 1)\n        .map((value) =>\n          generateRange(0, tiebreakTo + 2 - value).map(() => value)\n        )\n        .flat();\n      const lowValue = range[randomInt(0, range.length - 1)];\n      const scores = getTiebreakComplement({\n        isSide1: true,\n        tiebreakNoAd,\n        tiebreakTo,\n        lowValue,\n      });\n\n      if (scores) {\n        if (isTiebreakSet) {\n          const highSide = scores[0] > scores[1] ? 1 : 2; // sides are not tied\n          if (specifiedWinningSide) {\n            if (highSide !== specifiedWinningSide) scores.reverse();\n          } else if (reverseScores) {\n            scores.reverse();\n          }\n          [set.side1TiebreakScore, set.side2TiebreakScore] = scores;\n          tiebreakWinningSide =\n            (scores[0] > scores[1] && 1) ||\n            (scores[1] > scores[0] && 2) ||\n            undefined;\n        } else if (setAnalysis.leadingSide === 2) {\n          [set.side1TiebreakScore, set.side2TiebreakScore] = scores;\n        } else {\n          [set.side2TiebreakScore, set.side1TiebreakScore] = scores;\n        }\n      }\n    }\n\n    set.winningSide =\n      setAnalysis.winningSide ||\n      setAnalysis.leadingSide ||\n      specifiedWinningSide ||\n      tiebreakWinningSide;\n  }\n  return { set };\n}\n","import { assignTieMatchUpParticipantId } from '../../../mutate/matchUps/lineUps/assignTieMatchUpParticipant';\nimport { setMatchUpStatus } from '../../../mutate/matchUps/matchUpStatus/setMatchUpStatus';\nimport { getAllStructureMatchUps } from '../../../query/matchUps/getAllStructureMatchUps';\nimport { getPositionAssignments } from '../../../query/drawDefinition/positionsGetter';\nimport { generateOutcomeFromScoreString } from './generateOutcomeFromScoreString';\nimport { getParticipants } from '../../../query/participants/getParticipants';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { structureSort } from '../../../functions/sorters/structureSort';\nimport { matchUpSort } from '../../../functions/sorters/matchUpSort';\nimport { getMatchUpId } from '../../../global/functions/extractors';\nimport { generateLineUps } from '../participants/generateLineUps';\nimport { generateOutcome } from './generateOutcome';\n\nimport { BYE, COMPLETED, DOUBLE_DEFAULT, DOUBLE_WALKOVER } from '../../../constants/matchUpStatusConstants';\nimport { ErrorType, MISSING_DRAW_DEFINITION } from '../../../constants/errorConditionConstants';\nimport { addParticipants } from '../../../mutate/participants/addParticipants';\nimport { MAIN, QUALIFYING } from '../../../constants/drawDefinitionConstants';\nimport { DOUBLES, SINGLES, TEAM } from '../../../constants/matchUpTypes';\nimport { addExtension } from '../../../mutate/extensions/addExtension';\nimport { LINEUPS } from '../../../constants/extensionConstants';\nimport { ASCENDING } from '../../../constants/sortingConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { RANKING } from '../../../constants/scaleConstants';\n\nexport function completeDrawMatchUps(params): {\n  completedCount?: number;\n  success?: boolean;\n  error?: ErrorType;\n} {\n  const {\n    matchUpStatusProfile, // { matchUpStatusProfile: {} } will always return only { matchUpStatus: COMPLETED }\n    completeAllMatchUps,\n    // qualifyingProfiles, // CONSIDER: allowing completionGoal per structureProfile\n    randomWinningSide,\n    tournamentRecord,\n    completionGoal,\n    drawDefinition,\n    event,\n  } = params;\n\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const matchUpFormat = params.matchUpFormat || drawDefinition.matchUpFormat || event?.matchUpFormat;\n\n  const sortedStructures = drawDefinition.structures.slice().sort(structureSort);\n\n  let completedCount = 0;\n\n  const { matchUps: firstRoundDualMatchUps, matchUpsMap } = getAllDrawMatchUps({\n    contextFilters: {\n      stages: [MAIN, QUALIFYING],\n    },\n    matchUpFilters: {\n      matchUpTypes: [TEAM],\n      roundNumbers: [1],\n    },\n    inContext: true,\n    drawDefinition,\n  });\n\n  if (firstRoundDualMatchUps?.length) {\n    const categoryName = event?.category?.ageCategoryCode || event?.category?.categoryName;\n    if (categoryName) {\n      const scaleAccessor = {\n        scaleName: categoryName,\n        sortOrder: ASCENDING,\n        scaleType: RANKING,\n      };\n      const result = generateLineUps({\n        singlesOnly: true,\n        tournamentRecord,\n        drawDefinition,\n        scaleAccessor,\n        event,\n      });\n      if (result.error) return result;\n      const { lineUps, participantsToAdd } = result;\n      addParticipants({ tournamentRecord, participants: participantsToAdd });\n      const extension = { name: LINEUPS, value: lineUps };\n      addExtension({ element: drawDefinition, extension });\n    } else {\n      const structureId = firstRoundDualMatchUps[0]?.structureId;\n      const { positionAssignments } = getPositionAssignments({\n        drawDefinition,\n        structureId,\n      });\n      if (positionAssignments?.length) {\n        const { participants: teamParticipants } = getParticipants({\n          participantFilters: { participantTypes: [TEAM] },\n          tournamentRecord,\n        });\n        const assignParticipants = (dualMatchUp) => {\n          const singlesMatchUps = dualMatchUp.tieMatchUps.filter(({ matchUpType }) => matchUpType === SINGLES);\n          const doublesMatchUps = dualMatchUp.tieMatchUps.filter(({ matchUpType }) => matchUpType === DOUBLES);\n\n          singlesMatchUps.forEach((singlesMatchUp, i) => {\n            const tieMatchUpId = singlesMatchUp.matchUpId;\n            singlesMatchUp.sides.forEach((side) => {\n              const { drawPosition } = side;\n              const teamParticipant = teamParticipants?.find((teamParticipant) => {\n                const { participantId } = teamParticipant;\n                const assignment = positionAssignments.find((assignment) => assignment.participantId === participantId);\n                return assignment?.drawPosition === drawPosition;\n              });\n\n              if (teamParticipant) {\n                const individualParticipantId = teamParticipant.individualParticipantIds?.[i];\n\n                individualParticipantId &&\n                  assignTieMatchUpParticipantId({\n                    teamParticipantId: teamParticipant.participantId,\n                    participantId: individualParticipantId,\n                    tournamentRecord,\n                    drawDefinition,\n                    tieMatchUpId,\n                    event,\n                  });\n              }\n            });\n          });\n\n          doublesMatchUps.forEach((doublesMatchUp, i) => {\n            const tieMatchUpId = doublesMatchUp.matchUpId;\n            doublesMatchUp.sides.forEach((side) => {\n              const { drawPosition } = side;\n              const teamParticipant = teamParticipants?.find((teamParticipant) => {\n                const { participantId } = teamParticipant;\n                const assignment = positionAssignments.find((assignment) => assignment.participantId === participantId);\n                return assignment?.drawPosition === drawPosition;\n              });\n\n              if (teamParticipant) {\n                const individualParticipantIds = teamParticipant.individualParticipantIds?.slice(i * 2, i * 2 + 2);\n                individualParticipantIds?.forEach((individualParticipantId) => {\n                  assignTieMatchUpParticipantId({\n                    teamParticipantId: teamParticipant.participantId,\n                    participantId: individualParticipantId,\n                    tournamentRecord,\n                    drawDefinition,\n                    tieMatchUpId,\n                    event,\n                  });\n                });\n              }\n            });\n          });\n        };\n\n        firstRoundDualMatchUps.forEach(assignParticipants);\n      }\n    }\n  }\n\n  // to support legacy tests it is possible to use completeAllMatchUps\n  // to pass a score string that will be applied to all matchUps\n  const scoreString = typeof completeAllMatchUps === 'string' && completeAllMatchUps;\n  const matchUpStatus = scoreString && COMPLETED;\n\n  for (const structure of sortedStructures) {\n    if (completedCount >= completionGoal) break;\n\n    const { matchUps } = getAllStructureMatchUps({\n      matchUpFilters: { matchUpTypes: [DOUBLES, SINGLES] },\n      afterRecoveryTimes: false,\n      tournamentRecord,\n      inContext: true,\n      drawDefinition,\n      matchUpsMap,\n      structure,\n      event,\n    });\n\n    const sortedMatchUpIds = matchUps\n      .filter(({ winningSide }) => !winningSide)\n      .sort(matchUpSort)\n      .map(getMatchUpId);\n\n    for (const matchUpId of sortedMatchUpIds) {\n      if (!isNaN(completionGoal) && completedCount >= completionGoal) break;\n\n      const { matchUps } = getAllStructureMatchUps({\n        matchUpFilters: { matchUpTypes: [DOUBLES, SINGLES] },\n        afterRecoveryTimes: false,\n        tournamentRecord,\n        inContext: true,\n        drawDefinition,\n        matchUpsMap,\n        structure,\n        event,\n      });\n\n      const targetMatchUp = matchUps.find((matchUp) => matchUp.matchUpId === matchUpId);\n\n      const isDoubleExit = [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(targetMatchUp.matchUpStatus);\n\n      if (targetMatchUp?.readyToScore && !isDoubleExit) {\n        const result = smartComplete({\n          winningSide: !randomWinningSide && 1,\n          matchUpStatusProfile,\n          tournamentRecord,\n          drawDefinition,\n          targetMatchUp,\n          matchUpFormat,\n          matchUpStatus,\n          scoreString,\n          event,\n        });\n\n        if (result?.error) return result;\n\n        completedCount += 1;\n      }\n    }\n  }\n\n  return { ...SUCCESS, completedCount };\n}\n\nexport function completeDrawMatchUp(params) {\n  const {\n    matchUpStatusCodes,\n    policyDefinitions,\n    tournamentRecord,\n    drawDefinition,\n    targetMatchUp,\n    matchUpStatus,\n    matchUpFormat,\n    scoreString,\n    winningSide,\n    event,\n  } = params;\n  if (!targetMatchUp || targetMatchUp.matchUpStatus === BYE) {\n    return;\n  }\n  const { matchUpId } = targetMatchUp || {};\n\n  const { outcome } = generateOutcomeFromScoreString({\n    matchUpFormat,\n    matchUpStatus,\n    scoreString,\n    winningSide,\n  });\n\n  if (matchUpStatusCodes) outcome.matchUpStatusCodes = matchUpStatusCodes;\n\n  return setMatchUpStatus({\n    tournamentRecord,\n    policyDefinitions,\n    drawDefinition,\n    matchUpFormat,\n    matchUpId,\n    outcome,\n    event,\n  });\n}\n\n// NOTE: matchUpFormat must come from collectionDefinition in TEAM events\nfunction smartComplete(params) {\n  const {\n    matchUpStatusProfile = {},\n    tournamentRecord,\n    policyDefinitions,\n    drawDefinition,\n    matchUpStatus,\n    matchUpFormat,\n    targetMatchUp,\n    scoreString,\n    winningSide,\n    event,\n  } = params;\n\n  if (scoreString || matchUpStatus) return completeDrawMatchUp(params);\n\n  const { matchUpId } = targetMatchUp || {};\n  const { outcome } = generateOutcome({\n    matchUpStatusProfile,\n    matchUpFormat,\n    winningSide,\n  });\n\n  return setMatchUpStatus({\n    policyDefinitions,\n    tournamentRecord,\n    drawDefinition,\n    matchUpFormat,\n    matchUpId,\n    outcome,\n    event,\n  });\n}\n","import { automatedPlayoffPositioning } from '../../../mutate/drawDefinitions/automatedPlayoffPositioning';\nimport { addPlayoffStructures } from '../../../mutate/drawDefinitions/addPlayoffStructures';\nimport { setParticipantScaleItem } from '../../../mutate/participants/addScaleItems';\nimport { addDrawDefinition } from '../../../mutate/drawDefinitions/addDrawDefinition';\nimport { generateDrawDefinition } from '../drawDefinitions/generateDrawDefinition';\nimport { isValidExtension } from '../../../validators/isValidExtension';\nimport { getFlightProfile } from '../../../query/event/getFlightProfile';\nimport { addExtension } from '../../../mutate/extensions/addExtension';\nimport { xa } from '../../../utilities/objects';\nimport { completeDrawMatchUps } from './completeDrawMatchUps';\nimport { generateRange } from '../../../utilities/arrays';\n\nimport { PARTICIPANT_ID } from '../../../constants/attributeConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { SEEDING } from '../../../constants/scaleConstants';\nimport { DRAW_DEFINITION_NOT_FOUND, ErrorType, STRUCTURE_NOT_FOUND } from '../../../constants/errorConditionConstants';\nimport { MAIN, ROUND_ROBIN_WITH_PLAYOFF } from '../../../constants/drawDefinitionConstants';\n\nexport function generateFlightDrawDefinitions({\n  matchUpStatusProfile,\n  completeAllMatchUps,\n  randomWinningSide,\n  tournamentRecord,\n  drawProfiles,\n  event,\n}): {\n  drawIds?: string[];\n  success?: boolean;\n  error?: ErrorType;\n} {\n  const flightProfile = getFlightProfile({ event }).flightProfile;\n  const { eventName, eventType, category } = event;\n  const { startDate } = tournamentRecord;\n  const drawIds: string[] = [];\n\n  const categoryName = category?.categoryName || category?.ageCategoryCode || category?.ratingType;\n  const existingDrawIds = event.drawDefinitions?.map(({ drawId }) => drawId);\n\n  if (Array.isArray(flightProfile?.flights)) {\n    for (const [index, flight] of flightProfile.flights.entries()) {\n      const { drawId, stage, drawName, drawEntries } = flight;\n      drawIds.push(flight.drawId);\n\n      const drawProfile = drawProfiles[index];\n      const { seedsCount, generate = true } = drawProfile || {};\n\n      if (generate) {\n        const drawParticipantIds = drawEntries.filter(xa(PARTICIPANT_ID)).map(xa(PARTICIPANT_ID));\n\n        const seedingScaleName = categoryName || eventName;\n\n        if (tournamentRecord && seedsCount && seedsCount <= drawParticipantIds.length) {\n          const scaleValues = generateRange(1, seedsCount + 1);\n          scaleValues.forEach((scaleValue, index) => {\n            const scaleItem = {\n              scaleValue,\n              scaleName: seedingScaleName,\n              scaleType: SEEDING,\n              eventType,\n              scaleDate: startDate,\n            };\n\n            const participantId = drawParticipantIds[index];\n            setParticipantScaleItem({\n              tournamentRecord,\n              participantId,\n              scaleItem,\n            });\n          });\n        }\n\n        if (existingDrawIds?.includes(drawId)) break;\n\n        let result = generateDrawDefinition({\n          ...drawProfile,\n          matchUpType: eventType,\n          seedingScaleName,\n          tournamentRecord,\n          isMock: true,\n          drawEntries,\n          drawName,\n          drawId,\n          event,\n          stage,\n        });\n        if (result.error) return { error: result.error, drawIds: [] };\n        const { drawDefinition } = result;\n        if (!drawDefinition) return { error: DRAW_DEFINITION_NOT_FOUND };\n\n        const drawExtensions = drawProfiles[index]?.drawExtensions;\n        if (Array.isArray(drawExtensions)) {\n          drawExtensions\n            .filter(isValidExtension)\n            .forEach((extension) => addExtension({ element: drawDefinition, extension }));\n        }\n\n        result = addDrawDefinition({\n          suppressNotifications: true,\n          tournamentRecord,\n          drawDefinition,\n          event,\n        });\n        if (result.error) return { error: result.error, drawIds: [] };\n\n        if (drawProfile?.withPlayoffs) {\n          const structureId = drawDefinition.structures?.[0].structureId;\n          const result = addPlayoffStructures({\n            idPrefix: drawProfile.idPrefix,\n            ...drawProfile.withPlayoffs,\n            tournamentRecord,\n            drawDefinition,\n            isMock: true,\n            structureId,\n            event,\n          });\n          if (result?.error) return result;\n        }\n\n        // TODO: enable { outcomes: [] } in eventProfile: { drawProfiles }\n\n        const completionGoal = drawProfile?.completionGoal;\n        const manual = drawProfile?.automated === false;\n\n        if (!manual && (completeAllMatchUps || completionGoal)) {\n          const matchUpFormat = drawProfile?.matchUpFormat;\n\n          const result = completeDrawMatchUps({\n            completeAllMatchUps: !completionGoal && completeAllMatchUps,\n            matchUpStatusProfile,\n            randomWinningSide,\n            tournamentRecord,\n            completionGoal,\n            drawDefinition,\n            matchUpFormat,\n            event,\n          });\n          if (result.error) return { error: result.error, drawIds: [] };\n\n          const completedCount = result.completedCount;\n\n          if (drawProfile?.drawType === ROUND_ROBIN_WITH_PLAYOFF) {\n            const mainStructure = drawDefinition.structures?.find((structure) => structure.stage === MAIN);\n            if (!mainStructure) return { error: STRUCTURE_NOT_FOUND };\n            let result = automatedPlayoffPositioning({\n              structureId: mainStructure.structureId,\n              tournamentRecord,\n              drawDefinition,\n              event,\n            });\n            if (result.error) return { error: result.error, drawIds: [] };\n\n            const playoffCompletionGoal = completionGoal ? completionGoal - (completedCount ?? 0) : undefined;\n            result = completeDrawMatchUps({\n              completeAllMatchUps: !completionGoal && completeAllMatchUps,\n              completionGoal: completionGoal ? playoffCompletionGoal : undefined,\n              matchUpStatusProfile,\n              randomWinningSide,\n              tournamentRecord,\n              drawDefinition,\n              matchUpFormat,\n              event,\n            });\n            if (result.error) return { error: result.error, drawIds: [] };\n          }\n        }\n      }\n    }\n  }\n\n  return { ...SUCCESS, drawIds };\n}\n","import { addParticipants } from '../../../mutate/participants/addParticipants';\nimport { getParticipantId } from '../../../global/functions/extractors';\nimport { generateParticipants } from './generateParticipants';\n\nimport { MAIN, QUALIFYING } from '../../../constants/drawDefinitionConstants';\nimport { INDIVIDUAL, PAIR } from '../../../constants/participantConstants';\nimport { DOUBLES, SINGLES } from '../../../constants/eventConstants';\nimport { FEMALE, MALE } from '../../../constants/genderConstants';\nimport { Participant } from '../../../types/tournamentTypes';\n\nexport function generateEventParticipants(params) {\n  const {\n    participantsProfile = {},\n    uniqueParticipantsCount,\n    ratingsParameters,\n    tournamentRecord,\n    eventProfile,\n    eventIndex,\n    event,\n    uuids,\n  } = params;\n\n  const { category, gender, eventType } = event;\n\n  const eventParticipantType =\n    (eventType === SINGLES && INDIVIDUAL) ||\n    (eventType === DOUBLES && PAIR) ||\n    eventType;\n\n  const mainParticipantsCount = uniqueParticipantsCount[MAIN] || 0;\n  const qualifyingParticipantsCount = uniqueParticipantsCount[QUALIFYING] || 0;\n\n  const participantsCount = eventProfile.drawProfiles?.length\n    ? mainParticipantsCount + qualifyingParticipantsCount\n    : eventProfile.participantsProfile?.participantsCount ?? 0;\n\n  const sex = [MALE, FEMALE].includes(gender) ? gender : undefined;\n\n  const idPrefix = participantsProfile?.idPrefix\n    ? `E-${eventIndex}-${participantsProfile?.idPrefix}`\n    : undefined;\n  const { participants: uniqueFlightParticipants } = generateParticipants({\n    uuids: eventProfile.uuids || uuids,\n    ...participantsProfile,\n    scaledParticipantsCount: eventProfile.scaledParticipantsCount,\n    consideredDate: tournamentRecord?.startDate,\n    rankingRange: eventProfile.rankingRange,\n    participantType: eventParticipantType,\n    participantsCount,\n    ratingsParameters,\n    category,\n    idPrefix,\n    sex,\n  });\n\n  const participants = uniqueFlightParticipants as Participant[];\n  const result = addParticipants({\n    tournamentRecord,\n    participants,\n  });\n  if (result.error) return result;\n\n  const uniqueDrawParticipants = uniqueFlightParticipants?.filter(\n    ({ participantType }) => participantType === eventParticipantType\n  );\n  const uniqueParticipantIds = uniqueFlightParticipants?.map(getParticipantId);\n\n  return { uniqueDrawParticipants, uniqueParticipantIds };\n}\n","import { addEventEntries } from '../../../mutate/entries/addEventEntries';\nimport { addFlight } from '../../../mutate/events/addFlight';\nimport { getParticipantId } from '../../../global/functions/extractors';\n\nimport { DIRECT_ACCEPTANCE } from '../../../constants/entryStatusConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  MAIN,\n  SINGLE_ELIMINATION,\n} from '../../../constants/drawDefinitionConstants';\n\nexport function generateFlight({\n  autoEntryPositions,\n  tournamentRecord,\n  drawParticipants,\n  drawProfile,\n  event,\n}) {\n  const {\n    drawType = SINGLE_ELIMINATION,\n    qualifyingPositions = 0,\n    stage = MAIN,\n    drawSize = 0,\n    drawName,\n    drawId,\n  } = drawProfile;\n\n  const entriesCount = drawSize - qualifyingPositions;\n\n  const drawParticipantIds = drawParticipants\n    .slice(0, entriesCount)\n    .map(getParticipantId);\n\n  if (drawParticipantIds.length) {\n    const result = addEventEntries({\n      participantIds: drawParticipantIds,\n      autoEntryPositions,\n      entryStage: stage,\n      tournamentRecord,\n      event,\n    });\n    if (result.error) return result;\n  }\n\n  const drawEntries = drawParticipantIds.map((participantId) => ({\n    entryStatus: DIRECT_ACCEPTANCE,\n    entryStage: stage,\n    participantId,\n  }));\n\n  const result = addFlight({\n    drawName: drawName || drawType,\n    qualifyingPositions,\n    drawEntries,\n    drawId,\n    event,\n    stage,\n  });\n  if (result.error) {\n    return result;\n  }\n\n  return { ...SUCCESS };\n}\n","import { generateFlight } from './generateFlight';\n\nimport { MAIN, QUALIFYING } from '../../../constants/drawDefinitionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\nexport function generateFlights({\n  uniqueDrawParticipants,\n  autoEntryPositions,\n  stageParticipants,\n  tournamentRecord,\n  drawProfiles,\n  category,\n  gender,\n  event,\n}) {\n  let uniqueParticipantsIndex = 0;\n  for (const drawProfile of drawProfiles) {\n    const {\n      qualifyingPositions = 0,\n      uniqueParticipants,\n      stage = MAIN,\n      drawSize = 0,\n    } = drawProfile;\n\n    const entriesCount = drawSize - qualifyingPositions;\n    const requiresUniqueParticipants =\n      uniqueParticipants || gender || category || stage === QUALIFYING;\n\n    // if a drawProfile has specified uniqueParticipants...\n    const drawParticipants = requiresUniqueParticipants\n      ? uniqueDrawParticipants.slice(\n          uniqueParticipantsIndex,\n          uniqueParticipantsIndex + entriesCount\n        )\n      : stageParticipants[stage || MAIN] || [];\n\n    if (requiresUniqueParticipants) uniqueParticipantsIndex += entriesCount;\n\n    const result = generateFlight({\n      autoEntryPositions,\n      drawParticipants,\n      tournamentRecord,\n      drawProfile,\n      event,\n    });\n    if (result.error) return result;\n  }\n\n  return { ...SUCCESS };\n}\n","import { getStageParticipantsCount } from '../../../query/drawDefinition/getStageParticipantsCount';\nimport { getStageParticipants } from '../../../query/drawDefinition/getStageParticipants';\nimport { attachPolicies } from '../../../mutate/extensions/policies/attachPolicies';\nimport { generateFlightDrawDefinitions } from './generateFlightDrawDefinitions';\nimport { addEventEntries } from '../../../mutate/entries/addEventEntries';\nimport { addEventTimeItem } from '../../../mutate/timeItems/addTimeItem';\nimport { generateEventParticipants } from './generateEventParticipants';\nimport { isValidExtension } from '../../../validators/isValidExtension';\nimport { publishEvent } from '../../../mutate/events/publishEvent';\nimport tieFormatDefaults from '../templates/tieFormatDefaults';\nimport { xa } from '../../../utilities/objects';\nimport { addEvent } from '../../../mutate/events/addEvent';\nimport { generateFlights } from './generateFlights';\nimport { UUID } from '../../../utilities/UUID';\n\nimport { SINGLES, DOUBLES, TEAM } from '../../../constants/eventConstants';\nimport { INDIVIDUAL, PAIR } from '../../../constants/participantConstants';\nimport { MAIN } from '../../../constants/drawDefinitionConstants';\n\nexport function generateEventWithFlights(params) {\n  const {\n    allUniqueParticipantIds,\n    matchUpStatusProfile,\n    participantsProfile,\n    completeAllMatchUps,\n    autoEntryPositions,\n    hydrateCollections,\n    randomWinningSide,\n    ratingsParameters,\n    tournamentRecord,\n    eventProfile,\n    eventIndex,\n    publish,\n    isMock,\n    uuids,\n  } = params;\n  let gender = eventProfile.gender;\n  let eventName = eventProfile.eventName;\n\n  const {\n    eventType = SINGLES,\n    policyDefinitions,\n    drawProfiles = [],\n    eventExtensions,\n    surfaceCategory,\n    tieFormatName,\n    processCodes,\n    discipline,\n    eventLevel,\n    timeItems,\n    ballType,\n    category,\n  } = eventProfile;\n\n  const eventId = eventProfile.eventId || UUID();\n  const tieFormat =\n    eventProfile.tieFormat ||\n    (eventType === TEAM\n      ? tieFormatDefaults({\n          namedFormat: tieFormatName,\n          event: { eventId, category, gender },\n          hydrateCollections,\n          isMock,\n        })\n      : undefined);\n\n  const targetParticipants = tournamentRecord.participants;\n\n  for (const drawProfile of drawProfiles) {\n    if (!gender && drawProfile.gender) gender = drawProfile?.gender;\n  }\n\n  const { stageParticipantsCount, uniqueParticipantsCount, uniqueParticipantStages } = getStageParticipantsCount({\n    drawProfiles,\n    category,\n    gender,\n  });\n\n  const eventParticipantType = (eventType === SINGLES && INDIVIDUAL) || (eventType === DOUBLES && PAIR) || eventType;\n\n  const { uniqueDrawParticipants = [], uniqueParticipantIds = [] } = uniqueParticipantStages\n    ? generateEventParticipants({\n        event: { eventType, category, gender },\n        uniqueParticipantsCount,\n        participantsProfile,\n        ratingsParameters,\n        tournamentRecord,\n        eventProfile,\n        eventIndex,\n        uuids,\n      })\n    : {};\n\n  // Create event object -------------------------------------------------------\n  let { eventAttributes } = eventProfile;\n  if (typeof eventAttributes !== 'object') eventAttributes = {};\n\n  const categoryName = category?.categoryName || category?.ageCategoryCode || category?.ratingType;\n\n  eventName = eventName || categoryName || 'Generated Event';\n\n  const newEvent = {\n    ...eventAttributes,\n    surfaceCategory,\n    processCodes,\n    discipline,\n    eventLevel,\n    eventName,\n    eventType,\n    tieFormat,\n    ballType,\n    category,\n    eventId,\n    gender,\n  };\n\n  // attach any valid eventExtensions\n  if (eventExtensions?.length && Array.isArray(eventExtensions)) {\n    const extensions = eventExtensions.filter(isValidExtension);\n    if (extensions?.length) Object.assign(newEvent, { extensions });\n  }\n\n  if (Array.isArray(timeItems)) {\n    timeItems.forEach((timeItem) => addEventTimeItem({ event, timeItem }));\n  }\n\n  if (typeof policyDefinitions === 'object') {\n    for (const policyType of Object.keys(policyDefinitions)) {\n      attachPolicies({\n        policyDefinitions: { [policyType]: policyDefinitions[policyType] },\n        event: newEvent,\n      });\n    }\n  }\n\n  // only update on event since category is used in participant generation\n  if (newEvent.category) newEvent.category.categoryName = categoryName;\n\n  let drawIds;\n  const eventResult: any = addEvent({\n    suppressNotifications: false,\n    internalUse: true,\n    tournamentRecord,\n    event: newEvent,\n  });\n  if (eventResult.error) return eventResult;\n  const event = eventResult?.event;\n\n  // Generate Flights ---------------------------------------------------------\n  const { stageParticipants } = getStageParticipants({\n    allUniqueParticipantIds,\n    stageParticipantsCount,\n    eventParticipantType,\n    targetParticipants,\n  });\n\n  if (drawProfiles?.length) {\n    const flightResult = generateFlights({\n      uniqueDrawParticipants,\n      autoEntryPositions,\n      stageParticipants,\n      tournamentRecord,\n      drawProfiles,\n      category,\n      gender,\n      event,\n    });\n    if (flightResult.error) return flightResult;\n\n    const drawDefinitionResult = generateFlightDrawDefinitions({\n      matchUpStatusProfile,\n      completeAllMatchUps,\n      randomWinningSide,\n      tournamentRecord,\n      drawProfiles,\n      event,\n    });\n    if (drawDefinitionResult.error) return drawDefinitionResult;\n    drawIds = drawDefinitionResult.drawIds;\n  } else if (eventProfile?.participantsProfile?.participantsCount) {\n    const eventParticipantIds = uniqueDrawParticipants.map(xa('participantId'));\n\n    if (eventParticipantIds.length) {\n      const result = addEventEntries({\n        participantIds: eventParticipantIds,\n        autoEntryPositions,\n        tournamentRecord,\n        entryStage: MAIN,\n        event,\n      });\n      if (result.error) return result;\n    }\n  }\n\n  if (publish) {\n    publishEvent({ tournamentRecord, event });\n  }\n\n  return { drawIds, eventId, uniqueParticipantIds };\n}\n","import { getTournamentInfo } from './getTournamentInfo';\nimport { extractDate } from '../../utilities/dateTime';\n\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport {\n  ErrorType,\n  MISSING_DATE,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../constants/errorConditionConstants';\nimport { isObject } from '../../utilities/objects';\n\nexport function getCompetitionDateRange({\n  tournamentRecords,\n}: {\n  tournamentRecords: TournamentRecords;\n}): {\n  startDate?: Date;\n  endDate?: Date;\n  error?: ErrorType;\n} {\n  if (!isObject(tournamentRecords))\n    return { error: MISSING_TOURNAMENT_RECORDS };\n  const tournamentIds = Object.keys(tournamentRecords ?? {});\n  const dateRange: {\n    startDate: Date | undefined;\n    endDate: Date | undefined;\n  } = tournamentIds.reduce(\n    (dateRange, tournamentId) => {\n      const tournamentRecord = tournamentRecords[tournamentId];\n      const {\n        tournamentInfo: { startDate, endDate },\n      } = getTournamentInfo({ tournamentRecord });\n\n      const dateOfStart = startDate && new Date(extractDate(startDate));\n      if (\n        !dateRange.startDate ||\n        (dateOfStart && dateOfStart < dateRange.startDate)\n      ) {\n        dateRange.startDate = dateOfStart;\n      }\n\n      const dateOfEnd = endDate && new Date(extractDate(endDate));\n      if (!dateRange.endDate || (dateOfEnd && dateOfEnd > dateRange.endDate)) {\n        dateRange.endDate = dateOfEnd;\n      }\n\n      return dateRange;\n    },\n    { startDate: undefined, endDate: undefined }\n  );\n\n  const startDate =\n    dateRange.startDate && extractDate(dateRange.startDate.toISOString());\n  const endDate =\n    dateRange.endDate && extractDate(dateRange.endDate.toISOString());\n\n  if (!startDate || !endDate) return { error: MISSING_DATE };\n\n  return { startDate, endDate };\n}\n","import { getCompetitionDateRange } from '../../../query/tournaments/getCompetitionDateRange';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { isValidDateString, sameDay } from '../../../utilities/dateTime';\nimport { findExtension } from '../../../acquire/findExtension';\nimport { setSchedulingProfile } from '../../tournaments/schedulingProfile';\nimport { isObject } from '../../../utilities/objects';\n\nimport { SCHEDULING_PROFILE } from '../../../constants/extensionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  EXISTING_ROUND,\n  INVALID_DATE,\n} from '../../../constants/errorConditionConstants';\n\nexport function addSchedulingProfileRound({\n  tournamentRecords,\n  scheduleDate,\n  venueId,\n  round,\n}) {\n  if (!isValidDateString(scheduleDate)) {\n    return { error: INVALID_DATE };\n  }\n  const stack = 'addSchedulingProfileRound';\n\n  const { extension } = findExtension({\n    name: SCHEDULING_PROFILE,\n    tournamentRecords,\n    discover: true,\n  });\n\n  const schedulingProfile = extension?.value || [];\n  let dateProfile = schedulingProfile.find((dateProfile) =>\n    sameDay(scheduleDate, dateProfile.scheduleDate)\n  );\n\n  if (!dateProfile) {\n    const { startDate, endDate } = getCompetitionDateRange({\n      tournamentRecords,\n    });\n    const dateObject = new Date(scheduleDate);\n    if (\n      (startDate && dateObject < new Date(startDate)) ||\n      (endDate && dateObject > new Date(endDate))\n    ) {\n      return { error: INVALID_DATE };\n    }\n\n    dateProfile = { scheduleDate, venues: [] };\n    schedulingProfile.push(dateProfile);\n  }\n\n  let venueOnDate = dateProfile.venues.find(\n    (venue) => venue.venueId === venueId\n  );\n\n  if (!venueOnDate) {\n    venueOnDate = { venueId, rounds: [] };\n    dateProfile.venues.push(venueOnDate);\n  }\n\n  // ensure round is not already present\n  const excludeKeys = ['notBeforeTime'];\n  const hashRound = (r) =>\n    Object.keys(r)\n      .filter((key) => !excludeKeys.includes(key))\n      .sort()\n      .map((k) => (isObject(r[k]) ? hashRound(r[k]) : r[k]))\n      .flat()\n      .join('|');\n\n  const roundExists = venueOnDate.rounds.find(\n    (existingRound) => hashRound(existingRound) === hashRound(round)\n  );\n  if (roundExists)\n    return decorateResult({ result: { error: EXISTING_ROUND }, stack });\n  venueOnDate.rounds.push(round);\n\n  const result = setSchedulingProfile({ tournamentRecords, schedulingProfile });\n  if (result.error) return result;\n\n  return { ...SUCCESS };\n}\n","import { automatedPlayoffPositioning } from '../../../mutate/drawDefinitions/automatedPlayoffPositioning';\nimport { addPlayoffStructures } from '../../../mutate/drawDefinitions/addPlayoffStructures';\nimport { setParticipantScaleItem } from '../../../mutate/participants/addScaleItems';\nimport { completeDrawMatchUps, completeDrawMatchUp } from './completeDrawMatchUps';\nimport { addDrawDefinition } from '../../../mutate/drawDefinitions/addDrawDefinition';\nimport { generateDrawDefinition } from '../drawDefinitions/generateDrawDefinition';\nimport { addParticipants } from '../../../mutate/participants/addParticipants';\nimport { allDrawMatchUps } from '../../../query/matchUps/getAllDrawMatchUps';\nimport { addEventEntries } from '../../../mutate/entries/addEventEntries';\nimport { addEventTimeItem } from '../../../mutate/timeItems/addTimeItem';\nimport { generateRange, intersection } from '../../../utilities/arrays';\nimport { isValidExtension } from '../../../validators/isValidExtension';\nimport { getParticipantId } from '../../../global/functions/extractors';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { addExtension } from '../../../mutate/extensions/addExtension';\nimport { publishEvent } from '../../../mutate/events/publishEvent';\nimport tieFormatDefaults from '../templates/tieFormatDefaults';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { generateParticipants } from './generateParticipants';\nimport { addFlight } from '../../../mutate/events/addFlight';\nimport { processTieFormat } from './processTieFormat';\nimport { coerceEven } from '../../../utilities/math';\nimport { UUID } from '../../../utilities/UUID';\n\nimport { DRAW_DEFINITION_NOT_FOUND, STRUCTURE_NOT_FOUND } from '../../../constants/errorConditionConstants';\nimport { INDIVIDUAL, PAIR, TEAM } from '../../../constants/participantConstants';\nimport { FORMAT_STANDARD } from '../../../fixtures/scoring/matchUpFormats';\nimport { COMPLETED } from '../../../constants/matchUpStatusConstants';\nimport { SINGLES, DOUBLES } from '../../../constants/eventConstants';\nimport { ALTERNATE } from '../../../constants/entryStatusConstants';\nimport { FEMALE, MALE } from '../../../constants/genderConstants';\nimport { COMPETITOR } from '../../../constants/participantRoles';\nimport { SEEDING } from '../../../constants/timeItemConstants';\nimport { Participant } from '../../../types/tournamentTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  MAIN,\n  QUALIFYING,\n  ROUND_ROBIN_WITH_PLAYOFF,\n  SINGLE_ELIMINATION,\n} from '../../../constants/drawDefinitionConstants';\n\nexport function generateEventWithDraw(params) {\n  const {\n    allUniqueParticipantIds = [],\n    participantsProfile = {},\n    matchUpStatusProfile,\n    completeAllMatchUps,\n    autoEntryPositions,\n    hydrateCollections,\n    randomWinningSide,\n    ratingsParameters,\n    tournamentRecord,\n    isMock = true,\n    drawProfile,\n    startDate,\n    drawIndex,\n    uuids,\n  } = params;\n\n  const drawProfileCopy = makeDeepCopy(drawProfile, false, true);\n\n  const {\n    excessParticipantAlternates = true,\n    matchUpFormat = FORMAT_STANDARD,\n    drawType = SINGLE_ELIMINATION,\n    tournamentAlternates = 0,\n    alternatesCount = 0,\n    qualifyingPositions,\n    qualifyingProfiles,\n    generate = true,\n    eventExtensions,\n    drawExtensions,\n    completionGoal,\n    tieFormatName,\n    seedsCount,\n    timeItems,\n    drawName,\n    category,\n    idPrefix,\n    publish,\n    gender,\n    stage,\n  } = drawProfileCopy;\n\n  const drawSize = drawProfileCopy.drawSize || (drawProfileCopy.ignoreDefaults ? undefined : 32);\n\n  const eventId = drawProfileCopy.eventId || UUID();\n  const eventType = drawProfile.eventType || drawProfile.matchUpType || SINGLES;\n  const participantType = eventType === DOUBLES ? PAIR : INDIVIDUAL;\n\n  const tieFormat =\n    (typeof drawProfile.tieFormat === 'object' && drawProfile.tieFormat) ||\n    (eventType === TEAM &&\n      tieFormatDefaults({\n        event: { eventId, category, gender },\n        namedFormat: tieFormatName,\n        hydrateCollections,\n        isMock,\n      })) ||\n    undefined;\n\n  const categoryName = category?.categoryName || category?.ageCategoryCode || category?.ratingType;\n\n  const eventName = drawProfile.eventName || categoryName || `Generated ${eventType}`;\n  let targetParticipants = tournamentRecord?.participants || [];\n\n  const qualifyingParticipantsCount =\n    (qualifyingProfiles\n      ?.map((profile) => profile.structureProfiles || [])\n      .flat() // in case each profile contains an array of stageSequences\n      .reduce((count, profile) => {\n        const qpc =\n          !profile.participantsCount || profile.participantsCount > profile.drawSize\n            ? profile.drawSize\n            : profile.participantsCount || 0;\n        return count + qpc;\n      }, 0) || 0) * (participantType === PAIR ? 2 : 1);\n\n  const participantsCount =\n    (!drawProfile.participantsCount || drawProfile.participantsCount > drawSize\n      ? drawSize\n      : drawProfile.participantsCount) || 0;\n\n  // TODO: implement use of tieFormats and tieFormatId\n  const event = { eventName, eventType, tieFormat, category, eventId, gender };\n\n  if (Array.isArray(timeItems)) {\n    timeItems.forEach((timeItem) => addEventTimeItem({ event, timeItem }));\n  }\n\n  let { eventAttributes } = drawProfile;\n  if (typeof eventAttributes !== 'object') eventAttributes = {};\n  Object.assign(event, eventAttributes);\n\n  // attach any valid eventExtensions\n  if (eventExtensions?.length && Array.isArray(eventExtensions)) {\n    const extensions = eventExtensions.filter(isValidExtension);\n    if (extensions?.length) Object.assign(event, { extensions });\n  }\n\n  const uniqueParticipantIds: string[] = [];\n  if (qualifyingParticipantsCount || drawProfile.uniqueParticipants || !tournamentRecord || gender || category) {\n    const drawParticipantsCount = (participantsCount || 0) + alternatesCount + qualifyingParticipantsCount;\n    let individualParticipantCount = drawParticipantsCount;\n    const gendersCount = { [MALE]: 0, [FEMALE]: 0 };\n    let teamSize, genders;\n\n    if (eventType === TEAM) {\n      ({ teamSize, genders } = processTieFormat({\n        alternatesCount,\n        tieFormatName,\n        tieFormat,\n        drawSize,\n      }));\n      Object.keys(genders).forEach((key) => {\n        if ([MALE, FEMALE].includes(key) && genders[key]) {\n          gendersCount[key] = drawSize * genders[key];\n        }\n      });\n      individualParticipantCount = teamSize * ((drawSize || 0) + qualifyingParticipantsCount);\n    }\n\n    const idPrefix = participantsProfile?.idPrefix ? `D-${drawIndex}-${participantsProfile?.idPrefix}` : undefined;\n\n    const result = generateParticipants({\n      ...participantsProfile,\n      scaledParticipantsCount: drawProfile.scaledParticipantsCount || participantsProfile.scaledParticipantsCount,\n      participantsCount: individualParticipantCount,\n      consideredDate: tournamentRecord?.startDate,\n      sex: gender || participantsProfile?.sex,\n      rankingRange: drawProfile.rankingRange,\n      uuids: drawProfile.uuids || uuids,\n      ratingsParameters,\n      participantType,\n      gendersCount,\n      idPrefix,\n      category,\n    });\n    const unique = result.participants as Participant[];\n\n    // update categoryName **after** generating participants\n    if (event.category) event.category.categoryName = categoryName;\n\n    if (tournamentRecord) {\n      const result = addParticipants({\n        participants: unique,\n        tournamentRecord,\n      });\n      if (result.error) return result;\n    }\n\n    unique.forEach(({ participantId }) => uniqueParticipantIds.push(participantId));\n    targetParticipants = unique;\n\n    if (eventType === TEAM) {\n      const maleIndividualParticipantIds = genders[MALE]\n        ? unique\n            .filter(({ participantType, person }) => participantType === INDIVIDUAL && person?.sex === MALE)\n            .map(getParticipantId)\n        : [];\n      const femaleIndividualParticipantIds = genders[FEMALE]\n        ? unique\n            .filter(({ participantType, person }) => participantType === INDIVIDUAL && person?.sex === FEMALE)\n            .map(getParticipantId)\n        : [];\n      const remainingParticipantIds = unique\n        .filter(({ participantType }) => participantType === INDIVIDUAL)\n        .map(getParticipantId)\n        .filter(\n          (participantId) =>\n            !maleIndividualParticipantIds.includes(participantId) &&\n            !femaleIndividualParticipantIds.includes(participantId),\n        );\n\n      const mixedCount = teamSize - (genders[MALE] + genders[FEMALE]);\n      // use indices to keep track of positions within pId arrays\n      let fIndex = 0,\n        mIndex = 0,\n        rIndex = 0;\n      const teamParticipants = generateRange(0, drawParticipantsCount).map((teamIndex) => {\n        const fPIDs = femaleIndividualParticipantIds.slice(fIndex, fIndex + genders[FEMALE]);\n        const mPIDs = maleIndividualParticipantIds.slice(mIndex, mIndex + genders[MALE]);\n        const rIDs = remainingParticipantIds.slice(rIndex, rIndex + mixedCount);\n        fIndex += genders[FEMALE];\n        mIndex += genders[MALE];\n        rIndex += mixedCount;\n\n        return {\n          individualParticipantIds: [...fPIDs, ...mPIDs, ...rIDs],\n          participantOtherName: `TM${teamIndex + 1}`,\n          participantName: `Team ${teamIndex + 1}`,\n          participantRole: COMPETITOR,\n          participantType: TEAM,\n          participantId: UUID(),\n        };\n      });\n      const result = addParticipants({\n        participants: teamParticipants as Participant[],\n        tournamentRecord,\n      });\n      if (!result.success) return result;\n      targetParticipants = teamParticipants;\n    }\n  }\n\n  const isEventParticipantType = (participant) => {\n    const { participantType } = participant;\n    if (eventType === SINGLES && participantType === INDIVIDUAL) return true;\n    if (eventType === DOUBLES && participantType === PAIR) return true;\n    return eventType === TEAM && participantType === TEAM;\n  };\n\n  const isEventGender = (participant) => {\n    if (!drawProfile.gender) return true;\n    if (participant.person?.sex === drawProfile.gender) return true;\n    return participant.individualParticipantIds?.some((participantId) => {\n      const individualParticipant = targetParticipants.find((p) => p.participantId === participantId);\n      return individualParticipant && isEventGender(individualParticipant);\n    });\n  };\n\n  const consideredParticipants = targetParticipants\n    .filter(isEventParticipantType)\n    .filter(isEventGender)\n    .filter(({ participantId }) => !allUniqueParticipantIds.includes(participantId));\n\n  const participantIds = consideredParticipants.slice(0, participantsCount).map((p) => p.participantId);\n\n  if (isMock && participantIds?.length) {\n    const result = addEventEntries({\n      autoEntryPositions,\n      entryStage: stage,\n      tournamentRecord,\n      participantIds,\n      event,\n    });\n    if (result.error) return result;\n  }\n\n  const qualifyingParticipantIds = qualifyingParticipantsCount\n    ? consideredParticipants\n        .slice(participantsCount, participantsCount + qualifyingParticipantsCount)\n        .map((p) => p.participantId)\n    : 0;\n\n  if (isMock && qualifyingParticipantIds?.length) {\n    let qualifyingIndex = 0; // used to take slices of participants array\n    let roundTarget = 1;\n\n    const sequenceSort = (a, b) => a.stageSequence - b.stageSequence;\n    const roundTargetSort = (a, b) => a.roundTarget - b.roundTarget;\n\n    for (const roundTargetProfile of qualifyingProfiles.sort(roundTargetSort)) {\n      roundTarget = roundTargetProfile.roundTarget || roundTarget;\n      let entryStageSequence = 1;\n      let qualifyingPositions;\n\n      for (const structureProfile of roundTargetProfile.structureProfiles.sort(sequenceSort)) {\n        const drawSize = structureProfile.drawSize || coerceEven(structureProfile.participantsCount);\n        const participantsCount = drawSize - (qualifyingPositions || 0); // minus qualifyingPositions\n        const participantIds = qualifyingParticipantIds.slice(qualifyingIndex, qualifyingIndex + participantsCount);\n        const result = addEventEntries({\n          entryStage: QUALIFYING,\n          entryStageSequence,\n          autoEntryPositions,\n          tournamentRecord,\n          participantIds,\n          roundTarget,\n          event,\n        });\n\n        if (result.error) {\n          return result;\n        }\n\n        qualifyingPositions = structureProfile.qualifyingPositions;\n        qualifyingIndex += participantsCount;\n        entryStageSequence += 1;\n      }\n\n      roundTarget += 1;\n    }\n  }\n\n  // alternates can still be taken from existing participants\n  // when unique participants are used for DIRECT_ACCEPTANCE entries\n  const alternatesParticipantIds =\n    excessParticipantAlternates &&\n    tournamentRecord?.participants\n      ?.filter(({ participantId }) => !participantIds.includes(participantId))\n      .filter(isEventParticipantType)\n      .filter(isEventGender)\n      .slice(0, alternatesCount || drawSize - participantsCount || tournamentAlternates)\n      .map((p) => p.participantId);\n\n  if (isMock && alternatesParticipantIds?.length) {\n    const result = addEventEntries({\n      participantIds: alternatesParticipantIds,\n      autoEntryPositions: false,\n      entryStatus: ALTERNATE,\n      tournamentRecord,\n      event,\n    });\n    if (result.error) return result.error;\n  }\n\n  // now add seeding information for seedsCount participants\n  const seedingScaleName = categoryName || eventName;\n  if (tournamentRecord && seedsCount && seedsCount <= participantIds.length) {\n    const scaleValues = generateRange(1, seedsCount + 1);\n    scaleValues.forEach((scaleValue, index) => {\n      const scaleItem = {\n        scaleName: seedingScaleName,\n        scaleDate: startDate,\n        scaleType: SEEDING,\n        scaleValue,\n        eventType,\n      };\n      const participantId = participantIds[index];\n      setParticipantScaleItem({ tournamentRecord, participantId, scaleItem });\n    });\n  }\n\n  const result = generateDrawDefinition({\n    ...makeDeepCopy(drawProfile, false, true),\n    tournamentRecord,\n    seedingScaleName,\n    matchUpFormat,\n    eventId,\n    isMock,\n    event,\n  });\n\n  if (result.error) return result;\n  if (!result.drawDefinition) return { error: DRAW_DEFINITION_NOT_FOUND };\n\n  const { drawDefinition } = result;\n  const drawId = drawDefinition.drawId;\n\n  if (Array.isArray(drawExtensions)) {\n    drawExtensions\n      .filter(isValidExtension)\n      .forEach((extension) => addExtension({ element: drawDefinition, extension }));\n  }\n\n  if (generate) {\n    addDrawDefinition({ drawDefinition, event, suppressNotifications: true });\n\n    if (drawProfile.withPlayoffs) {\n      const structureId = drawDefinition.structures?.[0].structureId;\n      const result = addPlayoffStructures({\n        ...drawProfile.withPlayoffs,\n        tournamentRecord,\n        drawDefinition,\n        structureId,\n        idPrefix,\n        isMock,\n        event,\n      });\n      if (result?.error) return result;\n    }\n\n    const manual = drawProfile.automated === false;\n    if (isMock && !manual) {\n      // NOTE: completionGoal needs to come before outcomes array because setMatchUpStatus has integrity checks\n      // ... which may require positionAssignments and/or drawPositions to have been propagated\n      const goComplete = (p) => {\n        const result = completeDrawMatchUps({\n          completeAllMatchUps: p.completeAllMatchUps,\n          completionGoal: p.completionGoal,\n          matchUpStatusProfile,\n          // qualifyingProfiles,\n          randomWinningSide,\n          tournamentRecord,\n          drawDefinition,\n          matchUpFormat,\n          event,\n        });\n        if (result.error) return result;\n        const completedCount = result.completedCount;\n\n        if (drawType === ROUND_ROBIN_WITH_PLAYOFF) {\n          const mainStructure = drawDefinition.structures?.find((structure) => structure.stage === MAIN);\n          if (!mainStructure) return { error: STRUCTURE_NOT_FOUND };\n\n          automatedPlayoffPositioning({\n            structureId: mainStructure.structureId,\n            tournamentRecord,\n            drawDefinition,\n            event,\n          });\n          // ignore when positioning cannot occur because of incomplete source structure\n\n          const playoffCompletionGoal = completionGoal ? completionGoal - (completedCount ?? 0) : undefined;\n          const result = completeDrawMatchUps({\n            completionGoal: completionGoal ? playoffCompletionGoal : undefined,\n            matchUpStatusProfile,\n            completeAllMatchUps,\n            randomWinningSide,\n            tournamentRecord,\n            drawDefinition,\n            matchUpFormat,\n            event,\n          });\n          if (result.error) return result;\n        }\n        // TODO: check if RRWPO & automate & complete\n        return undefined;\n      };\n\n      // NOTE: completionGoal implies something less than \"all matchUps\"\n      // ==> do this first with the assumption that any outcomes must come after\n      if (completionGoal) goComplete({ completionGoal });\n\n      if (drawProfile.outcomes) {\n        const { matchUps } = allDrawMatchUps({\n          inContext: true,\n          drawDefinition,\n          event,\n        });\n        for (const outcomeDef of drawProfile.outcomes) {\n          const {\n            matchUpStatus = COMPLETED,\n            matchUpStatusCodes,\n            stageSequence = 1,\n            matchUpIndex = 0,\n            structureOrder, // like a group number; for RR = the order of the structureType: ITEM within structureType: CONTAINER\n            matchUpFormat,\n            drawPositions,\n            roundPosition,\n            stage = MAIN,\n            roundNumber,\n            winningSide,\n            scoreString,\n          } = outcomeDef;\n\n          const structureMatchUpIds =\n            matchUps?.reduce((sm, matchUp) => {\n              const { structureId, matchUpId } = matchUp;\n              if (sm[structureId]) {\n                sm[structureId].push(matchUpId);\n              } else {\n                sm[structureId] = [matchUpId];\n              }\n              return sm;\n            }, {}) ?? [];\n\n          const orderedStructures = Object.assign(\n            {},\n            ...Object.keys(structureMatchUpIds).map((structureId, index) => ({\n              [structureId]: index + 1,\n            })),\n          );\n\n          const targetMatchUps = matchUps?.filter((matchUp) => {\n            return (\n              (!stage || matchUp.stage === stage) &&\n              (!stageSequence || matchUp.stageSequence === stageSequence) &&\n              (!roundNumber || matchUp.roundNumber === roundNumber) &&\n              (!roundPosition || matchUp.roundPosition === roundPosition) &&\n              (!structureOrder || orderedStructures[matchUp.structureId] === structureOrder) &&\n              (!drawPositions || intersection(drawPositions, matchUp.drawPositions).length === 2)\n            );\n          });\n\n          // targeting only one matchUp, specified by the index in the array of returned matchUps\n          const targetMatchUp = targetMatchUps?.[matchUpIndex];\n\n          const result = completeDrawMatchUp({\n            matchUpStatusCodes,\n            tournamentRecord,\n            drawDefinition,\n            targetMatchUp,\n            matchUpFormat,\n            matchUpStatus,\n            scoreString,\n            winningSide,\n          });\n          // will not throw errors for BYE matchUps\n          if (result?.error) return result;\n        }\n      }\n\n      // NOTE: do this last => complete any matchUps which have not already been completed\n      if (completeAllMatchUps) goComplete({ completeAllMatchUps });\n    }\n\n    if (publish) {\n      publishEvent({ tournamentRecord, event });\n    }\n  } else {\n    const result = addFlight({\n      drawEntries: drawDefinition.entries,\n      drawName: drawName || drawType,\n      qualifyingPositions,\n      drawId,\n      event,\n      stage,\n    });\n    if (result.error) {\n      return result;\n    }\n  }\n\n  return {\n    ...SUCCESS,\n    event: definedAttributes(event),\n    uniqueParticipantIds,\n    targetParticipants,\n    drawDefinition,\n    eventId,\n    drawId,\n  };\n}\n","import { scheduleProfileRounds } from '../../../mutate/matchUps/schedule/scheduleProfileRounds';\nimport { attachPolicies } from '../../../mutate/extensions/policies/attachPolicies';\nimport { newTournamentRecord } from '../tournamentRecords/newTournamentRecord';\nimport { formatDate, isValidDateString } from '../../../utilities/dateTime';\nimport { addTournamentParticipants } from './addTournamentParticipants';\nimport { isValidExtension } from '../../../validators/isValidExtension';\nimport { cycleMutationStatus } from '../../../global/state/globalState';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { generateVenues } from '../../../mutate/venues/generateVenues';\nimport { generateEventWithFlights } from './generateEventWithFlights';\nimport { generateScheduledRounds } from './generateScheduledRounds';\nimport { generateEventWithDraw } from './generateEventWithDraw';\nimport { Extension } from '../../../types/tournamentTypes';\nimport { addEvent } from '../../../mutate/events/addEvent';\nimport { randomPop } from '../../../utilities/arrays';\n\nimport defaultRatingsParameters from '../../../fixtures/ratings/ratingsParameters';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { INVALID_DATE, INVALID_VALUES } from '../../../constants/errorConditionConstants';\n\nconst mockTournamentNames = [\n  'Mock Tournament',\n  'CourtHive Challenge',\n  'Racket Rally',\n  'Generated Tournament',\n  'Factory Follies',\n  'Open Competition',\n];\n\ntype GenerateTournamentRecordArgs = {\n  scheduleCompletedMatchUps?: boolean;\n  tournamentExtensions?: Extension[];\n  completeAllMatchUps?: boolean;\n  tournamentName?: string;\n  autoSchedule?: boolean;\n  startDate?: string;\n  endDate?: string;\n  uuids?: string[];\n\n  [key: string]: any;\n};\n\nexport function generateTournamentRecord(params: GenerateTournamentRecordArgs) {\n  let { tournamentAttributes, startDate, endDate } = params;\n  const {\n    tournamentName = randomPop(mockTournamentNames),\n    ratingsParameters = defaultRatingsParameters,\n    scheduleCompletedMatchUps,\n    tournamentExtensions,\n    matchUpStatusProfile,\n    completeAllMatchUps,\n    participantsProfile,\n    autoEntryPositions,\n    hydrateCollections,\n    randomWinningSide,\n    policyDefinitions,\n    schedulingProfile,\n    periodLength,\n    autoSchedule,\n    eventProfiles,\n    venueProfiles,\n    drawProfiles,\n    uuids,\n  } = params;\n  if ((startDate && !isValidDateString(startDate)) || (endDate && !isValidDateString(endDate)))\n    return { error: INVALID_DATE };\n\n  if (eventProfiles && !Array.isArray(eventProfiles)) return { error: INVALID_VALUES };\n\n  if (!startDate) {\n    const tournamentDate = new Date();\n    startDate = formatDate(endDate ?? tournamentDate);\n    endDate = formatDate(tournamentDate.setDate(tournamentDate.getDate() + 7));\n  }\n  if (!endDate) {\n    const tournamentDate = new Date(startDate);\n    endDate = formatDate(tournamentDate.setDate(tournamentDate.getDate() + 7));\n  }\n\n  if (typeof tournamentAttributes !== 'object') tournamentAttributes = {};\n  const tournamentRecord = newTournamentRecord({\n    ...tournamentAttributes,\n    tournamentName,\n    isMock: true,\n    startDate,\n    endDate,\n  });\n\n  // attach any valid tournamentExtensions\n  if (tournamentExtensions?.length && Array.isArray(tournamentExtensions)) {\n    const extensions = tournamentExtensions.filter((extension) => isValidExtension({ extension }));\n\n    if (extensions?.length) Object.assign(tournamentRecord, { extensions, isMock: true });\n  }\n\n  if (typeof policyDefinitions === 'object') {\n    for (const policyType of Object.keys(policyDefinitions)) {\n      attachPolicies({\n        policyDefinitions: { [policyType]: policyDefinitions[policyType] },\n        tournamentRecord,\n      });\n    }\n  }\n\n  const result = addTournamentParticipants({\n    participantsProfile,\n    tournamentRecord,\n    eventProfiles,\n    drawProfiles,\n    startDate,\n    uuids,\n  });\n  if (!result.success) return result;\n\n  const allUniqueParticipantIds: string[] = [],\n    eventIds: string[] = [],\n    drawIds: string[] = [];\n\n  if (Array.isArray(drawProfiles)) {\n    let drawIndex = 0;\n    for (const drawProfile of drawProfiles) {\n      let result = generateEventWithDraw({\n        allUniqueParticipantIds,\n        matchUpStatusProfile,\n        completeAllMatchUps,\n        autoEntryPositions,\n        hydrateCollections,\n        participantsProfile,\n        randomWinningSide,\n        ratingsParameters,\n        tournamentRecord,\n        isMock: true,\n        drawProfile,\n        startDate,\n        drawIndex,\n        uuids,\n      });\n      if (result.error) return result;\n\n      const { drawId, eventId, event, uniqueParticipantIds } = result;\n\n      result = addEvent({\n        suppressNotifications: false,\n        internalUse: true,\n        tournamentRecord,\n        event,\n      });\n      if (result.error) return result;\n\n      if (drawId) drawIds.push(drawId);\n      eventIds.push(eventId);\n\n      if (uniqueParticipantIds?.length) allUniqueParticipantIds.push(...uniqueParticipantIds);\n\n      drawIndex += 1;\n    }\n  }\n\n  if (eventProfiles) {\n    let eventIndex = 0;\n    for (const eventProfile of eventProfiles) {\n      const result = generateEventWithFlights({\n        allUniqueParticipantIds,\n        matchUpStatusProfile,\n        participantsProfile,\n        completeAllMatchUps,\n        autoEntryPositions,\n        hydrateCollections,\n        randomWinningSide,\n        ratingsParameters,\n        tournamentRecord,\n        eventProfile,\n        eventIndex,\n        startDate,\n        uuids,\n      });\n      if (result.error) return result;\n\n      const { eventId, drawIds: generatedDrawIds, uniqueParticipantIds } = result;\n\n      if (generatedDrawIds) drawIds.push(...generatedDrawIds);\n      eventIds.push(eventId);\n\n      if (uniqueParticipantIds?.length) allUniqueParticipantIds.push(...uniqueParticipantIds);\n\n      eventIndex += 1;\n    }\n  }\n\n  const venueIds = venueProfiles?.length ? generateVenues({ tournamentRecord, venueProfiles, uuids }) : [];\n\n  let scheduledRounds;\n  let schedulerResult = {};\n  if (schedulingProfile) {\n    const result = generateScheduledRounds({\n      schedulingProfile,\n      tournamentRecord,\n    });\n    if (result.error) return result;\n    scheduledRounds = result.scheduledRounds;\n\n    if (autoSchedule) {\n      const { tournamentId } = tournamentRecord;\n      const tournamentRecords = { [tournamentId]: tournamentRecord };\n\n      schedulerResult = scheduleProfileRounds({\n        scheduleCompletedMatchUps,\n        tournamentRecords,\n        periodLength,\n      });\n    }\n  }\n\n  // clear globalState modified flag;\n  cycleMutationStatus();\n\n  return definedAttributes({\n    ...SUCCESS,\n    tournamentRecord,\n    scheduledRounds,\n    schedulerResult,\n    eventIds,\n    venueIds,\n    drawIds,\n  });\n}\n","export function credits(): string {\n  return `\n    This project would not have been possible without the generous input and patience\n    of tournament organizers and directors who worked with early versions of CourtHive/TMX.\n\n    Thanks to Pavel, Ivan, Mladen, Zdenko, Antonia, Jakov, Kreso, Barry, Jeff, Bobby... to name just a few. \n\n    The project would not have even begun without the support of Miro, or the introduction by Sretchko.\n    The project would not have succeeded without the enthusiasm of Randy and Bruce.\n    Thanks to serendipity and Luca and the ensuing TODS conversations with ITF.\n    Thanks to Scott and Jake for sanity checks, suggestions, and camaraderie.\n    Thanks to Zoran for inspiring the async support and getting into the weeds with subscriptions.\n    Thanks to Dave for backing the conversion of TMX 1.x source into the factory repository.\n    Thanks to Vuk and Pavle and Rich and Chris and Deepa for the direct engagement with the APIs.\n    Thanks to Joe for repeatedly challenging me and the many pointers to useful tooling.\n    Thanks to Shannon for the validation of the approach from his deep domain experience.\n    Thanks to Nikola for the ongoing camaraderie and explorations of what we can do with TODS.\n\n    And a special thanks to my family for putting up with the long days and weeks and months of coding\n    and conversations at all hours.\n  `;\n}\n","import { anonymizeTournamentRecord } from '../../generators/tournamentRecords/anonymizeTournamentRecord';\nimport { generateOutcomeFromScoreString } from '../../generators/mocks/generateOutcomeFromScoreString';\nimport { generateTournamentRecord } from '../../generators/mocks/generateTournamentRecord';\nimport { modifyTournamentRecord } from '../../generators/mocks/modifyTournamentRecord';\nimport { generateEventWithDraw } from '../../generators/mocks/generateEventWithDraw';\nimport { generateParticipants } from '../../generators/mocks/generateParticipants';\nimport { generateOutcome } from '../../generators/mocks/generateOutcome';\nimport { parseScoreString } from '../../../utilities/parseScoreString';\nimport { credits } from '../../../fixtures/credits';\n\nexport const mocksGovernor = {\n  generateOutcomeFromScoreString,\n  anonymizeTournamentRecord,\n  generateTournamentRecord,\n  modifyTournamentRecord,\n  generateEventWithDraw,\n  generateParticipants,\n  parseScoreString,\n  generateOutcome,\n  credits,\n};\n\nexport default mocksGovernor;\n","import { postalCodeMocks, stateMocks, cityMocks } from '../mocks/address';\nimport { extractDate, formatDate } from '../../../utilities/dateTime';\nimport { findExtension } from '../../../acquire/findExtension';\nimport { generatePersons } from '../mocks/generatePersons';\nimport { generateAddress } from '../mocks/generateAddress';\nimport { nameMocks } from '../mocks/nameMocks';\nimport { UUID } from '../../../utilities/UUID';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../../constants/errorConditionConstants';\nimport { FEMALE, MALE, OTHER } from '../../../constants/genderConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  FLIGHT_PROFILE,\n  internalExtensions,\n  PERSON_REQUESTS,\n  SCHEDULING_PROFILE,\n} from '../../../constants/extensionConstants';\nimport {\n  GROUP,\n  INDIVIDUAL,\n  PAIR,\n  TEAM,\n} from '../../../constants/participantConstants';\n\nexport function anonymizeTournamentRecord({\n  keepExtensions = [], // e.g. ['level']\n  anonymizeParticipantNames = true,\n  tournamentRecord,\n  tournamentName,\n  personIds = [],\n  tournamentId,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  // if keepExtensions is boolean true then keep all extensions\n  // otherwise, keep any specified extensions along with internal extensions\n  const extensionsToKeep = Array.isArray(keepExtensions)\n    ? internalExtensions.concat(...keepExtensions)\n    : internalExtensions;\n\n  const filterExtensions = (element) => {\n    if (Array.isArray(keepExtensions)) {\n      return element?.extensions?.filter((extension) =>\n        extensionsToKeep.includes(extension.name)\n      );\n    } else {\n      return element?.extensions;\n    }\n  };\n\n  // create mapping from original element IDs to newly generated UUIDs\n  const idMap = {};\n\n  // change the tournamentId and name\n  tournamentRecord.extensions = filterExtensions(tournamentRecord);\n\n  const newTournamentId = tournamentId || UUID();\n  idMap[tournamentRecord.tournamentId] = newTournamentId;\n  tournamentRecord.tournamentId = newTournamentId;\n\n  tournamentRecord.createdAt = new Date().toISOString();\n  tournamentRecord.tournamentName =\n    tournamentName || `Anonymized: ${formatDate(new Date())}`;\n\n  delete tournamentRecord.parentOrganisation;\n\n  for (const participant of tournamentRecord.participants || []) {\n    const newParticipantId = UUID();\n    idMap[participant.participantId] = newParticipantId;\n    participant.participantId = newParticipantId;\n  }\n\n  // update all PAIR, GROUP and TEAM participant individualParticipantIds\n  for (const participant of tournamentRecord.participants || []) {\n    if (Array.isArray(participant.individualParticipantIds)) {\n      participant.individualParticipantIds =\n        participant.individualParticipantIds.map(\n          (individualParticipantId) => idMap[individualParticipantId]\n        );\n    }\n  }\n\n  let venueIndex = 0;\n  for (const venue of tournamentRecord.venues || []) {\n    venue.extensions = filterExtensions(venue);\n    venue.venueName = `Venue #${venueIndex}`;\n    venue.venueAbbreviation = `V${venueIndex}`;\n    const newVenueId = UUID();\n    idMap[venue.venueId] = newVenueId;\n    venueIndex += 1;\n    // venue.eventId = UUID(); eventIds can't be anonymized without updating schedulingProfiles\n  }\n\n  let eventCount = 1;\n  for (const event of tournamentRecord.events || []) {\n    event.extensions = filterExtensions(event);\n\n    const newEventId = UUID();\n    idMap[event.eventId] = newEventId;\n    event.eventId = newEventId;\n    const categoryName =\n      event.category?.categoryName ||\n      event.category?.ageCategoryCode ||\n      event.category?.ratingType ||\n      event.gender;\n    event.eventName = `Event ${eventCount} ${categoryName}`;\n\n    // update all event entries\n    if (Array.isArray(event.entries)) {\n      for (const entry of event.entries) {\n        entry.participantId = idMap[entry.participantId];\n      }\n    }\n\n    for (const drawDefinition of event.drawDefinitions || []) {\n      drawDefinition.extensions = filterExtensions(drawDefinition);\n      const newDrawId = UUID();\n      idMap[drawDefinition.drawId] = newDrawId;\n      drawDefinition.drawId = newDrawId;\n\n      // update all drawDefinition entries\n      if (Array.isArray(drawDefinition.entries)) {\n        for (const entry of drawDefinition.entries) {\n          entry.participantId = idMap[entry.participantId];\n        }\n      }\n\n      const updateStructure = (structure) => {\n        structure.extensions = filterExtensions(structure);\n        const newStructureId = UUID();\n        idMap[structure.structureId] = newStructureId;\n        structure.structureId = newStructureId;\n\n        // update positionAssignments for all structures\n        for (const assignment of structure.positionAssignments || []) {\n          if (assignment.participantId)\n            assignment.participantId = idMap[assignment.participantId];\n        }\n\n        // update seedAssignments for all structures\n        for (const assignment of structure.seedAssignments || []) {\n          if (assignment.participantId)\n            assignment.participantId = idMap[assignment.participantId];\n        }\n\n        // update lineUps in each matchUp\n        for (const matchUp of structure.matchUps || []) {\n          for (const side of matchUp.sides || []) {\n            if (!side.lineUp) continue;\n            side.lineUp = side.lineUp.map(\n              ({ participantId, collectionAssignments }) => ({\n                participantId: idMap[participantId],\n                collectionAssignments,\n              })\n            );\n          }\n        }\n      };\n\n      for (const structure of drawDefinition.structures || []) {\n        updateStructure(structure);\n\n        // account for structureType CONTAINER\n        if (Array.isArray(structure.structures)) {\n          for (const childStructure of structure.structures) {\n            updateStructure(childStructure);\n          }\n        }\n      }\n\n      // use idMap to update all link IDs\n      for (const link of drawDefinition.links || []) {\n        link.source.structureId = idMap[link.source.structureId];\n        link.target.structureId = idMap[link.target.structureId];\n      }\n    }\n\n    const { extension: flightProfile } = findExtension({\n      name: FLIGHT_PROFILE,\n      element: event,\n    });\n\n    // use idMap to update all IDs in flightProfiles\n    if (Array.isArray(flightProfile?.value?.flights)) {\n      flightProfile?.value.flights?.forEach((flight) => {\n        flight.drawId = idMap[flight.drawId];\n        if (Array.isArray(flight.drawEntries)) {\n          for (const entry of flight.drawEntries) {\n            entry.participantId = idMap[entry.participantId];\n          }\n        }\n      });\n    }\n\n    eventCount += 1;\n  }\n\n  const consideredDate = tournamentRecord.startDate || formatDate(new Date());\n\n  const individualParticipants = (tournamentRecord.participants || []).filter(\n    ({ participantType }) => participantType === INDIVIDUAL\n  );\n\n  const gendersCount = individualParticipants.reduce(\n    (counts, participant) => {\n      const gender = participant.person?.sex;\n      if ([MALE, FEMALE].includes(gender)) {\n        counts[gender] += 1;\n      } else {\n        counts[OTHER] += 1;\n      }\n      return counts;\n    },\n    { [MALE]: 0, [FEMALE]: 0, [OTHER]: 0 }\n  );\n\n  const genderedPersons = Object.assign(\n    {},\n    ...Object.keys(gendersCount).map((gender) => ({\n      [gender]:\n        generatePersons({\n          category: { ageCategoryCode: 'O18' }, // ageCategoryCode is unimportant since birthYear will be replaced\n          count: gendersCount[gender],\n          addressProps: { citiesCount: 10 },\n          personExtensions: [],\n          consideredDate,\n          sex: gender,\n        })?.persons || [],\n    }))\n  );\n\n  const genderedIndices = { [MALE]: 0, [FEMALE]: 0, [OTHER]: 0 };\n\n  const individualParticipantsCount = individualParticipants.length;\n\n  const addressComponents = individualParticipants.reduce(\n    (components, participant) => {\n      const address = participant.person?.addresses?.[0] || {};\n      const { city, state, postalCode } = address;\n      if (!components.cities.includes(city)) components.cities.push(city);\n      if (!components.states.includes(state)) components.states.push(state);\n      if (!components.postalCodes.includes(postalCode))\n        components.postalCodes.push(postalCode);\n      return components;\n    },\n    { cities: [], postalCodes: [], states: [] }\n  );\n\n  const postalCodesCount = addressComponents.postalCodes.length;\n  const citiesCount = addressComponents.cities.length;\n  const statesCount = addressComponents.states.length;\n\n  const { cities } = cityMocks({\n    count: citiesCount || individualParticipantsCount,\n    participantsCount: individualParticipantsCount,\n  });\n  const { states } = stateMocks({\n    count: statesCount || individualParticipantsCount,\n    participantsCount: individualParticipantsCount,\n  });\n  const { postalCodes } = postalCodeMocks({\n    count: postalCodesCount || individualParticipantsCount,\n    participantsCount: individualParticipantsCount,\n  });\n  const addressValues = { cities, states, postalCodes };\n\n  individualParticipants.forEach((individualParticipant, participantIndex) => {\n    const person = individualParticipant?.person;\n    const gender = person?.sex || OTHER;\n    const birthYear = extractDate(person?.birthDate)?.split('-')[0];\n\n    const genderedIndex = genderedIndices[gender];\n    const generatedPerson = genderedPersons[gender][genderedIndex];\n    genderedIndices[gender] += 1;\n\n    if (birthYear) {\n      const [, month, day] = generatedPerson?.birthDate?.split('-') || [];\n      const birthDate = [birthYear, month, day].join('-');\n      generatedPerson.birthDate = birthDate;\n    }\n\n    if (person?.addresses) {\n      const address = generateAddress({\n        ...addressValues,\n        participantIndex,\n        nationalityCode: generatedPerson.nationalityCode,\n      });\n\n      generatedPerson.addresses = [address];\n    }\n\n    generatedPerson.personId = personIds?.[participantIndex] || UUID();\n\n    if (anonymizeParticipantNames) {\n      generatedPerson.standardFamilyName = generatedPerson.lastName;\n      generatedPerson.standardGivenName = generatedPerson.firstName;\n      individualParticipant.participantName = `${generatedPerson.standardGivenName} ${generatedPerson.standardFamilyName}`;\n    } else {\n      generatedPerson.standardFamilyName = person?.standardFamilyName;\n      generatedPerson.standardGivenName = person?.standardGivenName;\n    }\n\n    delete generatedPerson.firstName;\n    delete generatedPerson.lastName;\n\n    generatedPerson.extensions = filterExtensions(person);\n    individualParticipant.person = generatedPerson;\n    idMap[person?.personId] = generatedPerson.personId;\n  });\n\n  const pairParticipants = (tournamentRecord.participants || []).filter(\n    ({ participantType }) => participantType === PAIR\n  );\n\n  pairParticipants.forEach((pairParticipant) => {\n    const { individualParticipantIds } = pairParticipant;\n    pairParticipant.participantName = generatePairParticipantName({\n      individualParticipantIds,\n      individualParticipants,\n    });\n  });\n\n  const teamParticipants = (tournamentRecord.participants || []).filter(\n    ({ participantType }) => participantType === TEAM\n  );\n  const teamParticipantsCount = teamParticipants.length;\n  const teamNames = nameMocks({ count: teamParticipantsCount }).names;\n  teamParticipants.forEach((teamParticipant, i) => {\n    teamParticipant.participantName = teamNames[i];\n  });\n\n  const groupParticipants = (tournamentRecord.participants || []).filter(\n    ({ participantType }) => participantType === GROUP\n  );\n  const groupParticipantsCount = groupParticipants.length;\n  const groupNames = nameMocks({\n    count: groupParticipantsCount,\n    nameRoot: 'Group',\n  }).names;\n  groupParticipants.forEach((teamParticipant, i) => {\n    teamParticipant.participantName = groupNames[i];\n  });\n\n  const { extension: schedulingProfile } = findExtension({\n    element: tournamentRecord,\n    name: SCHEDULING_PROFILE,\n  });\n\n  // use idMap to update all IDs in schedulingProfile\n  if (Array.isArray(schedulingProfile?.value)) {\n    schedulingProfile?.value.forEach((round) => {\n      round.tournamentId = idMap[round.tournamentId];\n      round.structureId = idMap[round.structureId];\n      round.eventId = idMap[round.eventId];\n      round.drawId = idMap[round.drawId];\n    });\n  }\n\n  const { extension: personRequests } = findExtension({\n    element: tournamentRecord,\n    name: PERSON_REQUESTS,\n  });\n\n  // use idMap to update all IDs in personRequests\n  if (Array.isArray(personRequests?.value)) {\n    personRequests?.value.forEach((request) => {\n      request.personId = idMap[request.personId];\n    });\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction generatePairParticipantName({\n  individualParticipantIds,\n  individualParticipants,\n}) {\n  let participantName = individualParticipants\n    .filter(({ participantId }) =>\n      individualParticipantIds.includes(participantId)\n    )\n    .map(({ person }) => person?.standardFamilyName)\n    .filter(Boolean)\n    .sort()\n    .join('/');\n\n  if (individualParticipantIds.length === 1) participantName += '/Unknown';\n  return participantName;\n}\n","import { getContainedStructures } from '../../../query/drawDefinition/getContainedStructures';\nimport { allTournamentMatchUps } from '../../../query/matchUps/getAllTournamentMatchUps';\nimport { addSchedulingProfileRound } from '../../../mutate/matchUps/schedule/addSchedulingProfileRound';\nimport { intersection, unique } from '../../../utilities/arrays';\n\nimport { Tournament } from '../../../types/tournamentTypes';\nimport {\n  ErrorType,\n  INVALID_VALUES,\n} from '../../../constants/errorConditionConstants';\n\ntype GenerateSchedulingProfileArgs = {\n  tournamentRecord: Tournament;\n  schedulingProfile: any;\n};\nexport function generateScheduledRounds({\n  schedulingProfile,\n  tournamentRecord,\n}: GenerateSchedulingProfileArgs): {\n  scheduledRounds?: any;\n  error?: ErrorType;\n} {\n  if (typeof schedulingProfile !== 'object') return { error: INVALID_VALUES };\n\n  const containedStructures = getContainedStructures({\n    tournamentRecord,\n  }).containedStructures;\n  const matchUps = allTournamentMatchUps({ tournamentRecord }).matchUps ?? [];\n\n  const { tournamentId } = tournamentRecord;\n  const scheduledRounds: any[] = [];\n\n  for (const dateProfile of schedulingProfile) {\n    const { scheduleDate, venues = [] } = dateProfile;\n\n    for (const venue of venues) {\n      const { rounds, venueId } = venue;\n\n      for (const round of rounds) {\n        const { drawId, winnerFinishingPositionRange, roundSegment } = round;\n\n        const targetMatchUps = matchUps.filter((matchUp) => {\n          const targetRange =\n            winnerFinishingPositionRange?.indexOf('-') > 0 &&\n            winnerFinishingPositionRange.split('-').map((x) => +x);\n          const range = matchUp.finishingPositionRange?.winner;\n\n          return (\n            matchUp.drawId === drawId &&\n            (!round.roundNumber || matchUp.roundNumber === round.roundNumber) &&\n            (!range ||\n              !targetRange ||\n              intersection(range, targetRange).length === 2 ||\n              (unique(range).length === unique(targetRange).length &&\n                intersection(range, targetRange).length ===\n                  unique(range).length))\n          );\n        });\n\n        const targetMatchUp = targetMatchUps[0];\n\n        if (targetMatchUp) {\n          const { eventId, roundNumber, drawName, structureName, roundName } =\n            targetMatchUp;\n          let structureId = targetMatchUp.structureId;\n\n          if (roundNumber && !winnerFinishingPositionRange) {\n            structureId =\n              Object.keys(containedStructures).find((containingStructureId) =>\n                containedStructures[containingStructureId].includes(structureId)\n              ) ?? structureId;\n          }\n\n          const roundToSchedule = {\n            tournamentId,\n            structureId,\n            roundNumber,\n            roundSegment,\n            eventId,\n            drawId,\n          };\n\n          const result = addSchedulingProfileRound({\n            tournamentRecords: { [tournamentId]: tournamentRecord },\n            round: roundToSchedule,\n            scheduleDate,\n            venueId,\n          });\n          if (result.error) return result;\n\n          scheduledRounds.push({\n            structureName,\n            roundName,\n            drawName,\n            ...roundToSchedule,\n          });\n        }\n      }\n    }\n  }\n\n  return { scheduledRounds };\n}\n","import { getStageParticipantsCount } from '../../../query/drawDefinition/getStageParticipantsCount';\nimport { scheduleProfileRounds } from '../../../mutate/matchUps/schedule/scheduleProfileRounds';\nimport { getStageParticipants } from '../../../query/drawDefinition/getStageParticipants';\nimport { setSchedulingProfile } from '../../../mutate/tournaments/schedulingProfile';\nimport { generateFlightDrawDefinitions } from './generateFlightDrawDefinitions';\nimport { addTournamentParticipants } from './addTournamentParticipants';\nimport { generateEventParticipants } from './generateEventParticipants';\nimport { generateEventWithFlights } from './generateEventWithFlights';\nimport { generateVenues } from '../../../mutate/venues/generateVenues';\nimport { publishEvent } from '../../../mutate/events/publishEvent';\nimport { generateEventWithDraw } from './generateEventWithDraw';\nimport { addEvent } from '../../../mutate/events/addEvent';\nimport { generateFlights } from './generateFlights';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../../constants/errorConditionConstants';\nimport defaultRatingsParameters from '../../../fixtures/ratings/ratingsParameters';\nimport { INDIVIDUAL, PAIR } from '../../../constants/participantConstants';\nimport { DOUBLES, SINGLES } from '../../../constants/eventConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\nexport function modifyTournamentRecord(params) {\n  const {\n    ratingsParameters = defaultRatingsParameters,\n    participantsProfile = {},\n    matchUpStatusProfile,\n    completeAllMatchUps,\n    autoEntryPositions,\n    hydrateCollections,\n    randomWinningSide,\n    schedulingProfile,\n    tournamentRecord,\n    eventProfiles,\n    periodLength,\n    venueProfiles,\n    autoSchedule,\n    drawProfiles,\n    uuids,\n  } = params;\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const allUniqueParticipantIds: string[] = [];\n  const eventIds: string[] = [];\n  const drawIds: string[] = [];\n\n  eventProfiles?.forEach((eventProfile) => {\n    const event = tournamentRecord.events?.find(\n      (event, index) =>\n        (eventProfile.eventIndex !== undefined &&\n          index === eventProfile.eventIndex) ||\n        (eventProfile.eventName &&\n          event.eventName === eventProfile.eventName) ||\n        (eventProfile.eventId && event.eventId === eventProfile.eventId)\n    );\n\n    if (event?.gender) {\n      eventProfile.gender = event.gender;\n    }\n  });\n\n  const participantsCount = tournamentRecord.participants?.length || undefined;\n  if (participantsCount && participantsProfile?.idPrefix) {\n    participantsProfile.idPrefix = `${participantsProfile.idPrefix}-${participantsCount}`;\n  }\n\n  const result = addTournamentParticipants({\n    startDate: tournamentRecord.startDate,\n    participantsProfile,\n    tournamentRecord,\n    eventProfiles,\n    drawProfiles,\n    uuids,\n  });\n  if (!result.success) return result;\n\n  if (eventProfiles) {\n    let eventIndex = tournamentRecord.events?.length || 0;\n    for (const eventProfile of eventProfiles) {\n      const { ratingsParameters } = eventProfile;\n\n      const event = tournamentRecord.events?.find(\n        (event, index) =>\n          (eventProfile.eventIndex !== undefined &&\n            index === eventProfile.eventIndex) ||\n          (eventProfile.eventName &&\n            event.eventName === eventProfile.eventName) ||\n          (eventProfile.eventId && event.eventId === eventProfile.eventId)\n      );\n\n      if (!event) {\n        const result: any = generateEventWithFlights({\n          startDate: tournamentRecord.startDate,\n          allUniqueParticipantIds,\n          matchUpStatusProfile,\n          participantsProfile,\n          completeAllMatchUps,\n          autoEntryPositions,\n          randomWinningSide,\n          ratingsParameters,\n          tournamentRecord,\n          eventProfile,\n          eventIndex,\n          uuids,\n        });\n        if (result.error) return result;\n\n        const {\n          eventId,\n          drawIds: generatedDrawIds,\n          uniqueParticipantIds,\n        } = result;\n\n        if (generatedDrawIds) drawIds.push(...generatedDrawIds);\n        eventIds.push(eventId);\n\n        if (uniqueParticipantIds?.length)\n          allUniqueParticipantIds.push(...uniqueParticipantIds);\n\n        eventIndex += 1;\n      } else {\n        const { gender, category, eventType } = event;\n        const { drawProfiles, publish } = eventProfile;\n\n        const eventParticipantType =\n          (eventType === SINGLES && INDIVIDUAL) ||\n          (eventType === DOUBLES && PAIR) ||\n          eventType;\n\n        if (drawProfiles) {\n          const {\n            stageParticipantsCount,\n            uniqueParticipantsCount,\n            uniqueParticipantStages,\n          } = getStageParticipantsCount({\n            drawProfiles,\n            category,\n            gender,\n          });\n\n          const { uniqueDrawParticipants = [], uniqueParticipantIds = [] } =\n            uniqueParticipantStages\n              ? generateEventParticipants({\n                  event: { eventType, category, gender },\n                  uniqueParticipantsCount,\n                  participantsProfile,\n                  ratingsParameters,\n                  tournamentRecord,\n                  eventProfile,\n                  uuids,\n                })\n              : {};\n\n          allUniqueParticipantIds.push(...uniqueParticipantIds);\n\n          const { stageParticipants } = getStageParticipants({\n            targetParticipants: tournamentRecord.participants || [],\n            allUniqueParticipantIds,\n            stageParticipantsCount,\n            eventParticipantType,\n          });\n\n          let result: any = generateFlights({\n            uniqueDrawParticipants,\n            autoEntryPositions,\n            stageParticipants,\n            tournamentRecord,\n            drawProfiles,\n            category,\n            gender,\n            event,\n          });\n          if (result.error) return result;\n\n          result = generateFlightDrawDefinitions({\n            matchUpStatusProfile,\n            completeAllMatchUps,\n            randomWinningSide,\n            tournamentRecord,\n            drawProfiles,\n            event,\n          });\n          if (result.error) return result;\n\n          drawIds.push(...result.drawIds);\n        }\n\n        if (publish) {\n          publishEvent({ tournamentRecord, event });\n        }\n      }\n    }\n  }\n\n  if (drawProfiles) {\n    let drawIndex = (tournamentRecord.events || [])\n      .map((event) => event.drawDefinitions?.map(() => 1) || [])\n      .flat()\n      .reduce((a, b) => a + b, 0);\n\n    for (const drawProfile of drawProfiles) {\n      let result = generateEventWithDraw({\n        startDate: tournamentRecord.startDate,\n        allUniqueParticipantIds,\n        matchUpStatusProfile,\n        participantsProfile,\n        completeAllMatchUps,\n        autoEntryPositions,\n        hydrateCollections,\n        randomWinningSide,\n        ratingsParameters,\n        tournamentRecord,\n        drawProfile,\n        drawIndex,\n        uuids,\n      });\n      if (result.error) return result;\n\n      const { drawId, eventId, event, uniqueParticipantIds } = result;\n\n      result = addEvent({ tournamentRecord, event, internalUse: true });\n      if (result.error) return result;\n\n      if (drawId) drawIds.push(drawId);\n      eventIds.push(eventId);\n\n      if (uniqueParticipantIds?.length)\n        allUniqueParticipantIds.push(...uniqueParticipantIds);\n\n      drawIndex += 1;\n    }\n  }\n\n  const venueIds = venueProfiles?.length\n    ? generateVenues({ tournamentRecord, venueProfiles })\n    : [];\n\n  let scheduledRounds;\n  let schedulerResult = {};\n  if (schedulingProfile?.length) {\n    const tournamentRecords = {\n      [tournamentRecord.tournamentId]: tournamentRecord,\n    };\n    const result = setSchedulingProfile({\n      tournamentRecords,\n      schedulingProfile,\n    });\n    if (result.error) return result;\n\n    if (autoSchedule) {\n      const { tournamentId } = tournamentRecord;\n      const tournamentRecords = { [tournamentId]: tournamentRecord };\n\n      schedulerResult = scheduleProfileRounds({\n        tournamentRecords,\n        periodLength,\n      });\n    }\n  }\n\n  const totalParticipantsCount = tournamentRecord.participants.length;\n\n  return {\n    totalParticipantsCount,\n    scheduledRounds,\n    schedulerResult,\n    ...SUCCESS,\n    eventIds,\n    venueIds,\n    drawIds,\n  };\n}\n","import { capitalizeFirst } from '../../../utilities/strings';\n\nimport { Person } from '../../../types/tournamentTypes';\n\ntype FormatPersonNameArgs = {\n  personFormat: string;\n  person: Person;\n};\n\nexport function formatPersonName({\n  personFormat,\n  person,\n}: FormatPersonNameArgs) {\n  const alpha = (str) => str.replace(/\\W/g, '');\n  const allLowerCase = (str) => /^[a-z]*$/.test(alpha(str));\n  const allUpperCase = (str) => /^[A-Z]*$/.test(alpha(str));\n  const lastUpperCase = (str) => /^[LAST]{4}/.test(alpha(str));\n  const lastFirst = (str) =>\n    str.toLowerCase().indexOf('l') < str.toLowerCase().indexOf('f');\n  const commaSeparated = (str) => str.indexOf(',') >= 0;\n  const firstInital = (str) => str.toLowerCase().indexOf('f.') >= 0;\n  const lastNameOnly = (str) => str.toLowerCase().indexOf('f') < 0;\n  const hasSpacing = (str) => str.indexOf(' ') > 0;\n\n  if (!person) return;\n  const spacer = hasSpacing(personFormat) ? ' ' : '';\n  let firstName = capitalizeFirst(person?.standardGivenName ?? '');\n  let lastName = capitalizeFirst(person?.standardFamilyName ?? '');\n\n  if (!personFormat) return `${firstName}${spacer}${lastName}`;\n\n  if (\n    firstInital(personFormat) &&\n    !commaSeparated(personFormat) &&\n    !lastFirst(personFormat)\n  ) {\n    firstName = `${firstName[0]}.`;\n  }\n\n  if (allLowerCase(personFormat)) {\n    firstName = firstName.toLowerCase();\n    lastName = lastName.toLowerCase();\n  } else if (allUpperCase(personFormat)) {\n    firstName = firstName.toUpperCase();\n    lastName = lastName.toUpperCase();\n  } else if (lastUpperCase(personFormat)) {\n    lastName = lastName.toUpperCase();\n  }\n\n  let participantName = `${firstName}${spacer}${lastName}`;\n  if (lastNameOnly(personFormat)) {\n    participantName = lastName;\n  } else if (lastFirst(personFormat)) {\n    if (commaSeparated(personFormat)) {\n      participantName = `${lastName},${spacer}${firstName}`;\n    } else {\n      participantName = `${lastName}${spacer}${firstName}`;\n    }\n  }\n\n  return participantName;\n}\n","import { formatPersonName } from './formatPersonName';\n\nimport {\n  INDIVIDUAL,\n  PAIR,\n  TEAM_PARTICIPANT,\n} from '../../../constants/participantConstants';\n\nexport function formatParticipantName({\n  participantMap,\n  participant,\n  formats,\n}) {\n  const { participantType, individualParticipantIds, person } = participant;\n  const format = participantType && formats[participantType];\n  if (participantType === TEAM_PARTICIPANT) return;\n\n  if (format) {\n    const { personFormat, doublesJoiner } = format;\n    if (participantType === INDIVIDUAL) {\n      participant.participantName = formatPersonName({ person, personFormat });\n    }\n    if (participantType === PAIR) {\n      participant.participantName = individualParticipantIds\n        ?.map((id) => {\n          const person = participantMap[id]?.person;\n          return formatPersonName({ person, personFormat });\n        })\n        .filter(Boolean)\n        .join(doublesJoiner ?? '/');\n    }\n  }\n}\n","import { addNotice } from '../../../global/state/globalState';\n\nimport { MODIFY_PARTICIPANTS } from '../../../constants/topicConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  PENALTY_NOT_FOUND,\n  MISSING_PENALTY_ID,\n  MISSING_TOURNAMENT_RECORD,\n  ErrorType,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../../constants/errorConditionConstants';\nimport {\n  Participant,\n  Penalty,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\nexport function removePenalty(params) {\n  const { tournamentRecords } = params;\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const result = penaltyRemove({ ...params, tournamentRecord });\n    if (result.error && result.error !== PENALTY_NOT_FOUND) return result;\n  }\n\n  return { ...SUCCESS };\n}\n\ntype RemovePenaltyArgs = {\n  tournamentRecord: Tournament;\n  penaltyId: string;\n};\nfunction penaltyRemove({ tournamentRecord, penaltyId }: RemovePenaltyArgs): {\n  error?: ErrorType;\n  success?: boolean;\n  penalty?: Penalty;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!penaltyId) return { error: MISSING_PENALTY_ID };\n\n  const participants = tournamentRecord?.participants ?? [];\n  const modifiedParticipants: Participant[] = [];\n\n  let penaltyRemoved = false;\n  let removedPenalty;\n  participants.forEach((participant) => {\n    let participantModified = false;\n    participant.penalties = (participant.penalties ?? []).filter((penalty) => {\n      if (penalty.penaltyId === penaltyId) {\n        participantModified = true;\n        if (!penaltyRemoved) {\n          removedPenalty = penalty;\n          penaltyRemoved = true;\n        }\n      }\n      if (participantModified) modifiedParticipants.push(participant);\n      return penalty.penaltyId !== penaltyId;\n    });\n  });\n\n  if (removedPenalty) {\n    addNotice({\n      topic: MODIFY_PARTICIPANTS,\n      payload: {\n        tournamentId: tournamentRecord.tournamentId,\n        participants: modifiedParticipants,\n      },\n    });\n  }\n\n  return removedPenalty\n    ? { ...SUCCESS, penalty: removedPenalty }\n    : { error: PENALTY_NOT_FOUND };\n}\n","import { UUID } from '../../../utilities/UUID';\n\nexport const penaltyTemplate = ({ penaltyId = UUID() } = {}) => ({\n  refereeParticipantId: undefined,\n  penaltyCode: undefined,\n  penaltyType: undefined,\n  extensions: undefined,\n  matchUpId: undefined,\n  createdAt: undefined,\n  issuedAt: undefined,\n  notes: undefined,\n  penaltyId,\n});\n\nexport default penaltyTemplate;\n","import { addNotice } from '../../../global/state/globalState';\n\nimport penaltyTemplate from '../../../assemblies/generators/templates/penaltyTemplate';\nimport { MODIFY_PARTICIPANTS } from '../../../constants/topicConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  PENALTY_NOT_FOUND,\n  MISSING_PENALTY_ID,\n  MISSING_TOURNAMENT_RECORD,\n  NO_VALID_ATTRIBUTES,\n  INVALID_VALUES,\n  ErrorType,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../../constants/errorConditionConstants';\nimport {\n  Participant,\n  Penalty,\n  Tournament,\n} from '../../../types/tournamentTypes';\n\nexport function modifyPenalty(params) {\n  const { tournamentRecords } = params;\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const result = penaltyModify({ ...params, tournamentRecord });\n    if (result.error && result.error !== PENALTY_NOT_FOUND) return result;\n    if (result.success) return result;\n  }\n\n  return { error: PENALTY_NOT_FOUND };\n}\n\ntype ModifyPenaltyArgs = {\n  tournamentRecord: Tournament;\n  modifications: { [key: string]: any };\n  penaltyId;\n  string;\n};\n\nfunction penaltyModify({\n  tournamentRecord,\n  modifications,\n  penaltyId,\n}: ModifyPenaltyArgs): {\n  modifications?: any;\n  error?: ErrorType;\n  success?: boolean;\n  penalty?: Penalty;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!modifications) return { error: INVALID_VALUES, modifications };\n  if (!penaltyId) return { error: MISSING_PENALTY_ID };\n\n  const participants = tournamentRecord?.participants ?? [];\n\n  const validAttributes = Object.keys(penaltyTemplate()).filter(\n    (attribute) => attribute !== 'penaltyId'\n  );\n\n  const validModificationAttributes = Object.keys(modifications).filter(\n    (attribute) => validAttributes.includes(attribute)\n  );\n\n  if (!validModificationAttributes.length)\n    return { error: NO_VALID_ATTRIBUTES };\n\n  let updatedPenalty;\n  const modifiedParticipants: Participant[] = [];\n  participants.forEach((participant) => {\n    let participantModified = false;\n    participant.penalties = (participant.penalties ?? []).map((penalty) => {\n      if (penalty.penaltyId === penaltyId) {\n        participantModified = true;\n        validModificationAttributes.forEach((attribute) =>\n          Object.assign(penalty, { [attribute]: modifications[attribute] })\n        );\n\n        if (!updatedPenalty) updatedPenalty = penalty;\n      }\n\n      return penalty;\n    });\n    if (participantModified) modifiedParticipants.push(participant);\n  });\n\n  if (updatedPenalty) {\n    addNotice({\n      topic: MODIFY_PARTICIPANTS,\n      payload: {\n        tournamentId: tournamentRecord.tournamentId,\n        participants: modifiedParticipants,\n      },\n    });\n  }\n\n  return updatedPenalty\n    ? { ...SUCCESS, penalty: updatedPenalty }\n    : { error: PENALTY_NOT_FOUND };\n}\n","import { unique } from './arrays';\n\n// arrayMerge can be boolean or an array of target attributes which are arrays to merge\nexport function deepMerge(existing, incoming, arrayMerge?) {\n  if (!existing && incoming) return incoming;\n  if (existing && !incoming) return existing;\n  if (typeof existing !== 'object' || typeof incoming !== 'object')\n    return existing;\n\n  const keys = unique(Object.keys(existing).concat(Object.keys(incoming)));\n\n  return keys.reduce((merged, key) => {\n    if (!incoming[key]) {\n      merged[key] = existing[key];\n    } else if (!existing[key]) {\n      merged[key] = incoming[key];\n    } else if (typeof existing[key] !== typeof incoming[key]) {\n      merged[key] = incoming[key];\n    } else if (Array.isArray(existing[key])) {\n      if (\n        arrayMerge === true ||\n        (Array.isArray(arrayMerge) && arrayMerge.includes(key))\n      ) {\n        const mergedArrays = unique(\n          existing[key]\n            .map((e) => JSON.stringify(e))\n            .concat(incoming[key].map((i) => JSON.stringify(i)))\n        ).map((u) => JSON.parse(u));\n        merged[key] = mergedArrays;\n      } else {\n        // default is to overwrite existing array with incoming\n        merged[key] = incoming[key];\n      }\n    } else if (typeof existing[key] === 'object') {\n      merged[key] = deepMerge(existing[key], incoming[key], arrayMerge);\n    } else {\n      merged[key] = incoming[key];\n    }\n    return merged;\n  }, {});\n}\n","import { getParticipants } from '../../../query/participants/getParticipants';\nimport { xa } from '../../../utilities/objects';\nimport { addNotice } from '../../../global/state/globalState';\nimport { addExtension } from '../../extensions/addExtension';\n\nimport penaltyTemplate from '../../../assemblies/generators/templates/penaltyTemplate';\nimport { MODIFY_PARTICIPANTS } from '../../../constants/topicConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { TournamentRecords } from '../../../types/factoryTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  MISSING_PENALTY_TYPE,\n  PARTICIPANT_NOT_FOUND,\n  MISSING_PARTICIPANT_ID,\n  MISSING_TOURNAMENT_RECORD,\n  ErrorType,\n} from '../../../constants/errorConditionConstants';\nimport { Extension, Penalty, PenaltyTypeUnion, Tournament } from '../../../types/tournamentTypes';\n\ntype AddPenaltyArgs = {\n  refereeParticipantId?: string;\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  penaltyType: PenaltyTypeUnion;\n  participantIds: string[];\n  extensions?: Extension[];\n  penaltyCode: string;\n  penaltyId?: string;\n  matchUpId?: string;\n  issuedAt?: string;\n  notes?: string;\n};\n\nexport function addPenalty(params: AddPenaltyArgs): ResultType & { penaltyId?: string } {\n  const { tournamentRecord, participantIds } = params;\n  const tournamentRecords =\n    params.tournamentRecords ??\n    (tournamentRecord && {\n      [tournamentRecord.tournamentId]: tournamentRecord,\n    }) ??\n    {};\n\n  let penaltyId;\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const participants =\n      getParticipants({\n        tournamentRecord,\n      }).participants ?? [];\n\n    const tournamentParticipantIds = participants\n      ?.map(xa('participantId'))\n      .filter((participantId) => participantIds.includes(participantId));\n\n    if (tournamentParticipantIds.length) {\n      const result = penaltyAdd({\n        ...params,\n        penaltyId: params.penaltyId ?? penaltyId,\n        tournamentRecord,\n        participantIds: tournamentParticipantIds,\n      });\n      penaltyId = result.penaltyId;\n    }\n  }\n\n  return penaltyId ? { ...SUCCESS, penaltyId } : { error: PARTICIPANT_NOT_FOUND };\n}\n\nfunction penaltyAdd({\n  refereeParticipantId,\n  tournamentRecord,\n  participantIds,\n  penaltyCode,\n  penaltyType,\n  extensions,\n  penaltyId,\n  matchUpId,\n  issuedAt,\n  notes,\n}: AddPenaltyArgs): {\n  penaltyId?: string;\n  success?: boolean;\n  error?: ErrorType;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!participantIds) return { error: MISSING_PARTICIPANT_ID };\n  if (!penaltyType) return { error: MISSING_PENALTY_TYPE };\n\n  // TODO: add penalty timeItem to matchUp.timeItems[]\n\n  const participants = tournamentRecord?.participants ?? [];\n  const relevantParticipants = participants.filter((participant) => participantIds.includes(participant.participantId));\n  if (!relevantParticipants.length) return { error: PARTICIPANT_NOT_FOUND };\n\n  const createdAt = new Date().toISOString();\n  const penaltyItem: Penalty = Object.assign(penaltyTemplate({ penaltyId }), {\n    refereeParticipantId,\n    penaltyCode,\n    penaltyType,\n    matchUpId,\n    notes,\n\n    issuedAt,\n    createdAt,\n  });\n\n  if (Array.isArray(extensions)) {\n    extensions.forEach((extension) => addExtension({ element: penaltyItem, extension }));\n  }\n\n  relevantParticipants.forEach((participant) => {\n    if (!participant.penalties) participant.penalties = [];\n    participant.penalties.push(penaltyItem);\n  });\n\n  addNotice({\n    topic: MODIFY_PARTICIPANTS,\n    payload: {\n      tournamentId: tournamentRecord.tournamentId,\n      participants: relevantParticipants,\n    },\n  });\n\n  return { ...SUCCESS, penaltyId: penaltyItem.penaltyId };\n}\n","import { modifyIndividualParticipantIds } from '../../../mutate/participants/modifyIndividualParticipantIds';\nimport { createTeamsFromParticipantAttributes } from '../../../mutate/participants/createTeamsFromAttributes';\nimport { modifyParticipantsSignInStatus } from '../../../mutate/participants/modifyParticipantsSignInStatus';\nimport { addIndividualParticipantIds } from '../../../mutate/participants/addIndividualParticipantIds';\nimport { modifyParticipantOtherName } from '../../../mutate/participants/modifyParticipantOtherName';\nimport { regenerateParticipantNames } from '../../../mutate/participants/regenerateParticipantNames';\nimport { createGroupParticipant } from '../../../mutate/participants/createGroupParticipant';\nimport { modifyParticipantName } from '../../../mutate/participants/modifyParticipantName';\nimport { scaledTeamAssignment } from '../../../mutate/participants/scaledTeamAssignment';\nimport { removePenalty } from '../../../mutate/participants/penalties/removePenalty';\nimport { modifyPenalty } from '../../../mutate/participants/penalties/modifyPenalty';\nimport { deleteParticipants } from '../../../mutate/participants/deleteParticipants';\nimport { mergeParticipants } from '../../../mutate/participants/mergeParticipants';\nimport { modifyParticipant } from '../../../mutate/participants/modifyParticipant';\nimport { filterParticipants } from '../../../query/participants/filterParticipants';\nimport { addParticipants } from '../../../mutate/participants/addParticipants';\nimport { addPenalty } from '../../../mutate/participants/penalties/addPenalty';\nimport { addParticipant } from '../../../mutate/participants/addParticipant';\nimport { addPersons } from '../../../mutate/participants/addPersons';\nimport {\n  removeIndividualParticipantIds,\n  removeParticipantIdsFromAllTeams,\n} from '../../../mutate/participants/removeIndividualParticipantIds';\nimport {\n  setParticipantScaleItems,\n  setParticipantScaleItem,\n} from '../../../mutate/participants/addScaleItems';\n\nexport const participantGovernor = {\n  addIndividualParticipantIds,\n  addParticipant,\n  addParticipants,\n  addPenalty,\n  addPersons,\n  createGroupParticipant,\n  createTeamsFromParticipantAttributes,\n  deleteParticipants,\n  filterParticipants,\n  mergeParticipants,\n  modifyIndividualParticipantIds,\n  modifyParticipant,\n  modifyParticipantName,\n  modifyParticipantOtherName,\n  modifyParticipantsSignInStatus,\n  modifyPenalty,\n  regenerateParticipantNames,\n  removeIndividualParticipantIds,\n  removeParticipantIdsFromAllTeams,\n  removePenalty,\n  scaledTeamAssignment,\n  setParticipantScaleItem,\n  setParticipantScaleItems,\n};\n\nexport default participantGovernor;\n","import { getParticipants } from '../../query/participants/getParticipants';\nimport { getParticipantId } from '../../global/functions/extractors';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { findParticipant } from '../../acquire/findParticipant';\nimport { addParticipants } from './addParticipants';\nimport { UUID } from '../../utilities/UUID';\n\nimport { INDIVIDUAL, PAIR } from '../../constants/participantConstants';\nimport { Participant } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { COMPETITOR, participantRoles } from '../../constants/participantRoles';\nimport {\n  INVALID_PARTICIPANT_ROLE,\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\n// add persons to a tournamentRecord and create participants in the process\n// include ability to specify a doubles partner by personId\nexport function addPersons({\n  participantRole = COMPETITOR,\n  tournamentRecord,\n  persons,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!Array.isArray(persons)) return { error: INVALID_VALUES };\n  if (!Object.keys(participantRoles).includes(participantRole))\n    return { error: INVALID_PARTICIPANT_ROLE };\n\n  const existingPersonIds = (tournamentRecord.participants || [])\n    .map(({ person }) => person?.personId)\n    .filter(Boolean);\n\n  const newPersonIds: string[] = [];\n\n  const personsToAdd = persons\n    .filter(\n      (person) =>\n        person &&\n        // don't add a person if their personId is present in tournament.participants\n        (!person.personId || !existingPersonIds.includes(person.personId))\n    )\n    .map((person) => {\n      if (!person.personId) person.personId = UUID();\n      // keep track of all incoming personIds for doubles creation\n      newPersonIds.push(person.personId);\n      return person;\n    });\n\n  // remove top level attributes which are used for participant generation\n  const excludeAttributes = (element, attributes) => {\n    return Object.assign(\n      {},\n      ...Object.keys(element)\n        .filter((key) => !attributes.includes(key))\n        .map((key) => ({ [key]: element[key] }))\n    );\n  };\n\n  const individualParticipants = personsToAdd.map((person) =>\n    definedAttributes({\n      extensions: person.participantExtensions,\n      timeItems: person.participantTimeItems,\n      participantType: INDIVIDUAL,\n      participantRole,\n      person: excludeAttributes(person, [\n        'participantExtensions',\n        'participantTimeItems',\n        'pairedPersons',\n      ]),\n    })\n  );\n\n  let addedPairParticipantsCount = 0;\n  let addedIndividualParticipantsCount = 0;\n\n  let result = addParticipants({\n    participants: individualParticipants,\n    tournamentRecord,\n  });\n  if (result.error) return result;\n  addedIndividualParticipantsCount = result.addedCount || 0;\n\n  const pairParticipants: Participant[] = [];\n\n  const tournamentParticipants =\n    getParticipants({\n      participantFilters: { participantTypes: [INDIVIDUAL] },\n      tournamentRecord,\n    })?.participants ?? [];\n\n  if (participantRole === COMPETITOR) {\n    persons\n      .filter(({ pairedPersons }) => pairedPersons)\n      .forEach(({ personId, pairedPersons }) => {\n        Array.isArray(pairedPersons) &&\n          pairedPersons.forEach((pairing) => {\n            const individualParticipants = [personId, pairing.personId]\n              .map((id) =>\n                findParticipant({ tournamentParticipants, personId: id })\n              )\n              .filter(Boolean);\n            if (individualParticipants.length === 2) {\n              const individualParticipantIds =\n                individualParticipants.map(getParticipantId);\n              pairParticipants.push(\n                definedAttributes({\n                  extensions: pairing.participantExtensions,\n                  timeItems: pairing.timeItems,\n                  participantRole: COMPETITOR,\n                  individualParticipantIds,\n                  participantType: PAIR,\n                })\n              );\n            }\n          });\n      });\n  }\n\n  if (pairParticipants.length) {\n    result = addParticipants({\n      participants: pairParticipants,\n      tournamentRecord,\n    });\n    if (result.error) return result;\n    addedPairParticipantsCount = result.addedCount || 0;\n  }\n\n  const addedCount =\n    addedIndividualParticipantsCount + addedPairParticipantsCount;\n\n  return { ...SUCCESS, addedCount, newPersonIds };\n}\n","import { getParticipants } from '../../query/participants/getParticipants';\nimport { addNotice, getTopics } from '../../global/state/globalState';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { addParticipant } from './addParticipant';\nimport { UUID } from '../../utilities/UUID';\n\nimport { GROUP, INDIVIDUAL } from '../../constants/participantConstants';\nimport { Participant, Tournament } from '../../types/tournamentTypes';\nimport { ADD_PARTICIPANTS } from '../../constants/topicConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { OTHER } from '../../constants/participantRoles';\nimport {\n  ErrorType,\n  INVALID_PARTICIPANT_TYPE,\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\ntype CreateGroupParticipantType = {\n  participantRoleResponsibilities?: string[];\n  individualParticipantIds: string[];\n  tournamentRecord: Tournament;\n  participantRole?: string;\n  participantId: string;\n  groupName: string;\n};\n\nexport function createGroupParticipant({\n  individualParticipantIds = [],\n  participantRoleResponsibilities,\n  participantRole = OTHER,\n  tournamentRecord,\n  participantId,\n  groupName,\n}: CreateGroupParticipantType): {\n  participant?: Participant;\n  participantId?: string;\n  success?: boolean;\n  error?: ErrorType;\n  info?: any;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!groupName) return { error: MISSING_VALUE, info: 'Missing groupName' };\n  if (!Array.isArray(individualParticipantIds))\n    return {\n      info: 'Invalid individualParticipantIds',\n      error: INVALID_VALUES,\n    };\n\n  const participants =\n    getParticipants({\n      participantFilters: { participantTypes: [INDIVIDUAL] },\n      tournamentRecord,\n    }).participants ?? [];\n  const tournamentIndividualParticipantIds = participants.map(\n    (participant) => participant.participantId\n  );\n\n  for (const participantId of individualParticipantIds) {\n    if (!tournamentIndividualParticipantIds.includes(participantId)) {\n      return { error: INVALID_PARTICIPANT_TYPE, participantId };\n    }\n  }\n\n  const groupParticipant = definedAttributes({\n    participantId: participantId || UUID(),\n    participantRoleResponsibilities,\n    participantName: groupName,\n    individualParticipantIds,\n    participantType: GROUP,\n    participantRole,\n  });\n\n  const result = addParticipant({\n    participant: groupParticipant,\n    tournamentRecord,\n  });\n  if (result.error) return result;\n\n  const { topics } = getTopics();\n  if (topics.includes(ADD_PARTICIPANTS)) {\n    addNotice({\n      topic: ADD_PARTICIPANTS,\n      payload: {\n        tournamentId: tournamentRecord.tournamentId,\n        participants: [groupParticipant],\n      },\n    });\n  }\n\n  return { ...SUCCESS, participant: makeDeepCopy(groupParticipant) };\n}\n","import { addNotice, getTopics } from '../../global/state/globalState';\nimport { xa } from '../../utilities/objects';\nimport { deepMerge } from '../../utilities/deepMerge';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\nimport { PARTICIPANT_ID } from '../../constants/attributeConstants';\nimport { Participant } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { ADD_PARTICIPANTS, MODIFY_PARTICIPANTS } from '../../constants/topicConstants';\n\nexport function mergeParticipants({ participants: incomingParticipants = [], tournamentRecord, arraysToMerge }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!tournamentRecord.participants) tournamentRecord.participants = [];\n\n  const mappedParticipants = incomingParticipants\n    .filter(xa(PARTICIPANT_ID))\n    .map((p: any) => ({ [p.participantId]: p }));\n  const incomingIdMap = Object.assign({}, ...mappedParticipants);\n\n  // check for overlap with existing players, add any newly retrieved attributes to existing\n  const modifiedParticipants: Participant[] = [];\n  tournamentRecord.participants = tournamentRecord.participants.map((participant) => {\n    if (incomingIdMap[participant.participantId]) {\n      const mergedParticipant = deepMerge(participant, incomingIdMap[participant.participantId], arraysToMerge);\n      modifiedParticipants.push(mergedParticipant);\n      return mergedParticipant;\n    }\n    return participant;\n  });\n\n  const existingParticipantIds = tournamentRecord.participants.map(xa(PARTICIPANT_ID)) || [];\n  const newParticipants = incomingParticipants.filter(\n    ({ participantId }) => !existingParticipantIds.includes(participantId),\n  );\n\n  const { topics } = getTopics();\n\n  if (newParticipants.length) {\n    tournamentRecord.participants = tournamentRecord.participants.concat(...newParticipants);\n\n    if (topics.includes(ADD_PARTICIPANTS)) {\n      addNotice({\n        topic: ADD_PARTICIPANTS,\n        payload: { participants: newParticipants },\n      });\n    }\n  }\n\n  if (modifiedParticipants.length && topics.includes(MODIFY_PARTICIPANTS)) {\n    addNotice({\n      topic: MODIFY_PARTICIPANTS,\n      payload: {\n        tournamentId: tournamentRecord.tournamentId,\n        participants: modifiedParticipants,\n      },\n    });\n  }\n\n  return {\n    modifiedParticipantsCount: modifiedParticipants.length,\n    newParticipantsCount: newParticipants.length,\n    ...SUCCESS,\n  };\n}\n","import { removeIndividualParticipantIds } from './removeIndividualParticipantIds';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { addIndividualParticipantIds } from './addIndividualParticipantIds';\nimport { addNotice, getTopics } from '../../global/state/globalState';\n\nimport { MODIFY_PARTICIPANTS } from '../../constants/topicConstants';\nimport {\n  INVALID_PARTICIPANT_IDS,\n  INVALID_PARTICIPANT_TYPE,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n  PARTICIPANT_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\nimport { GROUP, INDIVIDUAL, TEAM } from '../../constants/participantConstants';\n\n/**\n *\n * @param {object} tournamentRecord - passed in automatically by tournamentEngine\n * @param {string} groupingParticipantId - grouping participant to which participantIds are to be added\n * @param {string[]} individualParticipantIds - new value for individualParticipantIds array\n *\n */\nexport function modifyIndividualParticipantIds({\n  individualParticipantIds,\n  groupingParticipantId,\n  tournamentRecord,\n}) {\n  const stack = 'modifyIndividualParticipantIds';\n  if (!tournamentRecord)\n    return decorateResult({\n      result: { error: MISSING_TOURNAMENT_RECORD },\n      stack,\n    });\n  if (!groupingParticipantId || !individualParticipantIds)\n    return decorateResult({ result: { error: MISSING_VALUE }, stack });\n\n  const tournamentParticipants = tournamentRecord.participants || [];\n\n  const groupingParticipant = tournamentParticipants.find((participant) => {\n    return participant.participantId === groupingParticipantId;\n  });\n  if (!groupingParticipant)\n    return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND }, stack });\n\n  if (![TEAM, GROUP].includes(groupingParticipant.participantType)) {\n    return decorateResult({\n      result: { error: INVALID_PARTICIPANT_TYPE },\n      context: {\n        participantType: groupingParticipant.participantType,\n      },\n      stack,\n    });\n  }\n\n  // integrity chck to ensure only individuals can be added to groupings\n  const invalidParticipantIds = individualParticipantIds.filter(\n    (participantId) => {\n      const participant = tournamentParticipants.find(\n        (tournamentParticipant) =>\n          tournamentParticipant.participantId === participantId\n      );\n      return participant?.participantType !== INDIVIDUAL;\n    }\n  );\n  if (invalidParticipantIds.length)\n    return decorateResult({\n      result: { error: INVALID_PARTICIPANT_IDS, invalidParticipantIds },\n      stack,\n    });\n\n  const existingIndividualParticipantIds =\n    groupingParticipant.individualParticipantIds || [];\n\n  const individualParticipantIdsToAdd = individualParticipantIds.filter(\n    (participantId) => {\n      return !existingIndividualParticipantIds.includes(participantId);\n    }\n  );\n\n  const individualParticipantIdsToRemove =\n    existingIndividualParticipantIds.filter((participantId) => {\n      return !individualParticipantIds.includes(participantId);\n    });\n\n  const addResult = addIndividualParticipantIds({\n    individualParticipantIds: individualParticipantIdsToAdd,\n    groupingParticipantId,\n    tournamentRecord,\n  });\n  if (addResult.error) return decorateResult({ result: addResult, stack });\n\n  const removeResult = removeIndividualParticipantIds({\n    individualParticipantIds: individualParticipantIdsToRemove,\n    groupingParticipantId,\n    tournamentRecord,\n  });\n  if (removeResult.error)\n    return decorateResult({ result: removeResult, stack });\n\n  const { topics } = getTopics();\n  if (topics.includes(MODIFY_PARTICIPANTS)) {\n    const updatedParticipant = tournamentParticipants.find(\n      ({ participantId }) => participantId === groupingParticipantId\n    );\n\n    addNotice({\n      topic: MODIFY_PARTICIPANTS,\n      payload: {\n        tournamentId: tournamentRecord.tournamentId,\n        participants: [updatedParticipant],\n      },\n    });\n  }\n\n  return { ...addResult, ...removeResult };\n}\n","import { findTournamentParticipant } from '../../acquire/findTournamentParticipant';\nimport { addNotice, getTopics } from '../../global/state/globalState';\n\nimport { MODIFY_PARTICIPANTS } from '../../constants/topicConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_PARTICIPANT_ID,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n  PARTICIPANT_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\nexport function modifyParticipantName({\n  tournamentRecord,\n  participantName,\n  participantId,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!participantId) return { error: MISSING_PARTICIPANT_ID };\n\n  if (!participantName)\n    return { error: MISSING_VALUE, info: 'Missing participantName' };\n\n  const { participant } = findTournamentParticipant({\n    tournamentRecord,\n    participantId,\n  });\n  if (!participant) return { error: PARTICIPANT_NOT_FOUND };\n\n  participant.participantName = participantName;\n\n  const { topics } = getTopics();\n  if (topics.includes(MODIFY_PARTICIPANTS)) {\n    addNotice({\n      topic: MODIFY_PARTICIPANTS,\n      payload: {\n        tournamentId: tournamentRecord.tournamentId,\n        participants: [participant],\n      },\n    });\n  }\n\n  return { ...SUCCESS };\n}\n","import { findTournamentParticipant } from '../../acquire/findTournamentParticipant';\nimport { addNotice, getTopics } from '../../global/state/globalState';\n\nimport {\n  MISSING_PARTICIPANT_ID,\n  MISSING_TOURNAMENT_RECORD,\n  PARTICIPANT_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { MODIFY_PARTICIPANTS } from '../../constants/topicConstants';\n\nexport function modifyParticipantOtherName({\n  tournamentRecord,\n  participantId,\n  participantOtherName,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!participantId) return { error: MISSING_PARTICIPANT_ID };\n\n  const { participant } = findTournamentParticipant({\n    tournamentRecord,\n    participantId,\n  });\n  if (!participant) return { error: PARTICIPANT_NOT_FOUND };\n\n  participant.participantOtherName = participantOtherName;\n\n  const { topics } = getTopics();\n  if (topics.includes(MODIFY_PARTICIPANTS)) {\n    addNotice({\n      topic: MODIFY_PARTICIPANTS,\n      payload: {\n        tournamentId: tournamentRecord.tournamentId,\n        participants: [participant],\n      },\n    });\n  }\n\n  return { ...SUCCESS };\n}\n","import { addParticipantTimeItem } from '../timeItems/addTimeItem';\nimport { addNotice, getTopics } from '../../global/state/globalState';\nimport { getParticipantId } from '../../global/functions/extractors';\n\nimport { MODIFY_PARTICIPANTS } from '../../constants/topicConstants';\nimport { Participant } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_PARTICIPANTS,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\nimport {\n  SIGNED_IN,\n  SIGNED_OUT,\n  SIGN_IN_STATUS,\n} from '../../constants/participantConstants';\n\nexport function modifyParticipantsSignInStatus({\n  tournamentRecord,\n  participantIds,\n  signInState,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!Array.isArray(participantIds)) return { error: MISSING_VALUE };\n\n  const validSignInState = [SIGNED_IN, SIGNED_OUT].includes(signInState);\n  if (!validSignInState) return { error: INVALID_VALUES, signInState };\n\n  const participants = tournamentRecord.participants || [];\n  if (!participants.length) return { error: MISSING_PARTICIPANTS };\n\n  const allParticipantIds = participants.map(getParticipantId);\n  const invalidParticipantIds = participantIds.filter(\n    (participantId) => !allParticipantIds.includes(participantId)\n  );\n  if (invalidParticipantIds.length)\n    return { error: INVALID_VALUES, context: { invalidParticipantIds } };\n\n  const modifiedParticipants: Participant[] = [];\n  const createdAt = new Date().toISOString();\n  for (const participant of participants) {\n    const { participantId } = participant;\n    if (participantIds.includes(participantId)) {\n      const timeItem = {\n        itemType: SIGN_IN_STATUS,\n        itemValue: signInState,\n        createdAt,\n      };\n      const result = addParticipantTimeItem({\n        duplicateValues: false,\n        tournamentRecord,\n        participantId,\n        timeItem,\n      });\n      if (result.error) return result;\n      modifiedParticipants.push(participant);\n    }\n  }\n\n  const { topics } = getTopics();\n  if (modifiedParticipants.length && topics.includes(MODIFY_PARTICIPANTS)) {\n    addNotice({\n      topic: MODIFY_PARTICIPANTS,\n      payload: {\n        tournamentId: tournamentRecord.tournamentId,\n        participants: modifiedParticipants,\n      },\n    });\n  }\n\n  return { ...SUCCESS };\n}\n","import { createMap, isObject } from '../../utilities/objects';\nimport { formatParticipantName } from '../../assemblies/generators/participants/formatParticipantName';\n\nimport { Tournament } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\n/**\n * \"First Last\"\n * \"Last, First\"\n * \"LAST, First\"\n * \"LAST, FIRST\"\n * \"F. Last\"\n * \"first last\"\n * \"Last\"\n */\n\ntype RegenArgs = {\n  formats: { [key: string]: { personFormat: string; doublesJoiner: string } }[];\n  tournamentRecord: Tournament;\n};\n\nexport function regenerateParticipantNames({\n  tournamentRecord,\n  formats,\n}: RegenArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!isObject(formats)) return { error: MISSING_VALUE };\n\n  const participants = tournamentRecord.participants ?? [];\n\n  const participantMap = createMap(participants, 'participantId');\n\n  for (const participant of participants) {\n    formatParticipantName({ participant, participantMap, formats });\n  }\n\n  return { ...SUCCESS };\n}\n","import { participantScaleItem } from '../../query/participant/participantScaleItem';\nimport { getParticipantId } from '../../global/functions/extractors';\nimport { getFlightProfile } from '../../query/event/getFlightProfile';\nimport { isConvertableInteger } from '../../utilities/math';\nimport { generateRange } from '../../utilities/arrays';\nimport { addParticipants } from './addParticipants';\n\nimport { Event, Participant, Tournament } from '../../types/tournamentTypes';\nimport { DIRECT_ACCEPTANCE } from '../../constants/entryStatusConstants';\nimport { COMPETITOR } from '../../constants/participantRoles';\nimport { TEAM_EVENT } from '../../constants/eventConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_EVENT_TYPE,\n  INVALID_PARTICIPANT_TYPE,\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n  NO_CANDIDATES,\n  PARTICIPANT_NOT_FOUND,\n  TEAM_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\nimport {\n  INDIVIDUAL,\n  TEAM_PARTICIPANT,\n} from '../../constants/participantConstants';\n\n/*\nscaledParticipants are equivalent to scaledEntries\n...because it should also be possible to assign INDIVIDUAL participants to teams outside of an event scope,\nthe parameter is generalized... as long as there is a `participantId` and a `scaleValue` is will succeed\n\n{\n  participantId: '60f3e684-b6d2-47fc-a579-d0ab8f020810',\n  scaleValue: 1\n}\n\nscaleAttributes can include { accessor: 'attribute' } which will return scaleItem.scaleValue[accessor] for scaleValue\n*/\n\ntype ScaledTeamAssignmentArgs = {\n  clearExistingAssignments?: boolean;\n  individualParticipantIds?: string[];\n  reverseAssignmentOrder?: boolean;\n  initialTeamIndex?: number;\n  scaledParticipants?: any[];\n  teamParticipantIds?: string[];\n  tournamentRecord: Tournament;\n  scaleAttributes?: any;\n  teamNameBase?: string;\n  teamsCount?: number;\n  eventId?: string;\n  event?: Event;\n};\nexport function scaledTeamAssignment({\n  clearExistingAssignments = true, // by default remove all existing individualParticipantIds from targeted teams\n  individualParticipantIds, // if scaledParticipants are provided, individualParticipants is ignored\n  reverseAssignmentOrder, // optional - reverses team order; useful for sequential assignment of participant groupings to ensure balanced distribution\n  initialTeamIndex = 0, // optional - allows assignment to begin at a specified array index; useful for sequential assignment of groups of scaledParticipants\n  scaledParticipants = [], // optional - either scaledParticipants or (individualParticipantIds and scaleName) must be provided\n  teamParticipantIds, // optional, IF teamsCount is provided then teams will be created\n  tournamentRecord, // supplied automatically by tournamentEngine\n  scaleAttributes, // ignored if scaledParticipants are provided; { scaleName, scaleType, sortOrder, eventType }\n  teamNameBase, // optional - defaults to '[categoryName] TEAM #', where categoryName is derived from eventId (if supplied)\n  teamsCount, // optional - derived from teamParticipantIds (if provided) - create # of teams if teamParticipantIds provided are insufficient\n  eventId, // optional - source teamParticipantIds from DIRECT_ACCEPTANCE participants in a TEAM event\n  event, // supplied automatically by tournamentEngine\n}: ScaledTeamAssignmentArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (\n    (!Array.isArray(teamParticipantIds) &&\n      !isConvertableInteger(teamsCount) &&\n      !eventId) ||\n    !isConvertableInteger(initialTeamIndex) ||\n    (scaledParticipants && !Array.isArray(scaledParticipants)) ||\n    (scaleAttributes &&\n      (typeof scaleAttributes !== 'object' ||\n        !Object.keys(scaleAttributes).length))\n  ) {\n    return { error: INVALID_VALUES };\n  }\n  if (\n    (!scaleAttributes && !scaledParticipants.length) ||\n    (!scaledParticipants && !(individualParticipantIds && scaleAttributes))\n  ) {\n    return { error: MISSING_VALUE, info: 'Missing scaling details' };\n  }\n\n  if (eventId && !teamParticipantIds) {\n    if (event?.eventType !== TEAM_EVENT) return { error: INVALID_EVENT_TYPE };\n    teamParticipantIds = event?.entries\n      ?.filter(({ entryStatus }) => entryStatus === DIRECT_ACCEPTANCE)\n      .map(getParticipantId);\n  }\n\n  if (!teamParticipantIds?.length && !teamsCount) {\n    return {\n      info: 'Missing teamParticipantIds or teamsCount',\n      error: MISSING_VALUE,\n    };\n  }\n\n  let participantIdsToAssign =\n    individualParticipantIds ??\n    scaledParticipants.map(({ participantId }) => participantId);\n\n  if (reverseAssignmentOrder) {\n    teamParticipantIds?.reverse();\n    initialTeamIndex += 1; // ensures that the targeted team remains the first team to receive an assignment\n  }\n  if (initialTeamIndex > (teamParticipantIds?.length || 0) - 1)\n    initialTeamIndex = 0;\n\n  const orderedTeamParticipantIds =\n    teamParticipantIds\n      ?.slice(initialTeamIndex)\n      .concat(...teamParticipantIds.slice(0, initialTeamIndex)) ?? [];\n\n  const relevantTeams: any[] = [];\n  // build up an array of targeted TEAM participants\n  for (const participant of tournamentRecord.participants ?? []) {\n    const { participantId, participantType } = participant;\n    if (!orderedTeamParticipantIds.includes(participantId)) continue;\n    if (participantType !== TEAM_PARTICIPANT)\n      return { error: INVALID_PARTICIPANT_TYPE, participant };\n    relevantTeams.push(participant);\n  }\n\n  if (teamsCount && relevantTeams.length < teamsCount) {\n    const addCount = teamsCount - (relevantTeams?.length || 0);\n    const nameBase = teamNameBase ?? 'Team';\n    const teamParticipants = generateRange(0, addCount).map((i) => ({\n      participantName: `${nameBase} ${i + 1}`,\n      participantType: TEAM_PARTICIPANT,\n      participantRole: COMPETITOR,\n    })) as Participant[];\n\n    const { participants = [] } = addParticipants({\n      participants: teamParticipants,\n      returnParticipants: true,\n      tournamentRecord,\n    });\n    const addedParticipantIds = participants.map(getParticipantId);\n    const addedParticipants =\n      tournamentRecord.participants?.filter(({ participantId }) =>\n        addedParticipantIds.includes(participantId)\n      ) ?? [];\n    relevantTeams.push(...addedParticipants);\n  }\n\n  if (!relevantTeams.length) return { error: TEAM_NOT_FOUND };\n\n  if (clearExistingAssignments) {\n    // clear pre-existing individualParticipantIds\n    for (const relevantTeam of relevantTeams) {\n      relevantTeam.individualParticipantIds = [];\n    }\n  } else {\n    const preAssignedParticipantIds = relevantTeams\n      .map((individualParticipantIds) => individualParticipantIds)\n      .flat();\n\n    if (individualParticipantIds?.length) {\n      participantIdsToAssign = participantIdsToAssign.filter(\n        (participantId) => !preAssignedParticipantIds.includes(participantId)\n      );\n    } else {\n      scaledParticipants = scaledParticipants?.filter(\n        ({ participantId }) =>\n          !preAssignedParticipantIds.includes(participantId)\n      );\n    }\n  }\n\n  if (!individualParticipantIds?.length && !scaledParticipants?.length) {\n    return { error: NO_CANDIDATES, info: 'Nothing to be done' };\n  }\n\n  if (!scaledParticipants.length) {\n    for (const participant of tournamentRecord.participants ?? []) {\n      const { participantId, participantType } = participant;\n      if (!participantIdsToAssign.includes(participantId)) continue;\n      if (participantType !== INDIVIDUAL)\n        return { error: INVALID_PARTICIPANT_TYPE, participant };\n\n      const scaleItem = participantScaleItem({\n        scaleAttributes,\n        participant,\n      })?.scaleItem;\n\n      const scaleValue = scaleAttributes?.accessor\n        ? scaleItem?.scaleValue?.[scaleAttributes?.accessor]\n        : scaleItem?.scaleValue;\n\n      const scaledParticipant = { participantId, scaleValue };\n      scaledParticipants.push(scaledParticipant);\n    }\n\n    if (!scaledParticipants.length) return { error: PARTICIPANT_NOT_FOUND };\n  }\n  scaledParticipants.sort((a, b) =>\n    scaleAttributes?.sortOrder\n      ? (b?.scaleValue || 0) - (a?.scaleValue || 0)\n      : (a?.scaleValue || Infinity) - (b?.scaleValue || Infinity)\n  );\n\n  for (const scaledParticipant of scaledParticipants) {\n    if (!scaledParticipant.participantId)\n      return { error: INVALID_VALUES, scaledParticipant };\n  }\n\n  let index = 0;\n  while (index < scaledParticipants.length) {\n    for (const relevantTeam of relevantTeams) {\n      if (index + 1 > scaledParticipants.length) break;\n      const scaledParticipant = scaledParticipants[index];\n      relevantTeam.individualParticipantIds.push(\n        scaledParticipant.participantId\n      );\n      index++;\n    }\n    relevantTeams.reverse();\n  }\n\n  const relevantTeamParticipantIds = relevantTeams.map(getParticipantId);\n  // for all events, check if any relevant teams are present\n  // if a relevant team is present, remove any UNGROUPED participants that are part of that team\n  for (const event of tournamentRecord.events ?? []) {\n    if (event.eventType !== TEAM_EVENT) continue;\n    const relevantTeamEntries = (event.entries ?? []).filter((entry) =>\n      relevantTeamParticipantIds.includes(entry.participantId)\n    );\n    for (const relevantEntry of relevantTeamEntries) {\n      const relevantTeamParticipantId = relevantEntry.participantId;\n      const relevantTeam = relevantTeams.find(\n        (teamParticipant) =>\n          teamParticipant.participantId === relevantTeamParticipantId\n      );\n      const individualParticipantIds = relevantTeam?.individualParticipantIds;\n      // remove any relevant individualParticipant entries from event.entries\n      event.entries = (event.entries ?? []).filter(\n        (entry) => !individualParticipantIds.includes(entry.participantId)\n      );\n      // also remove any relevant individualParticipant entries from drawDefinition.entries\n      (event.drawDefinitions ?? []).forEach((drawDefinition) => {\n        drawDefinition.entries = (drawDefinition.entries ?? []).filter(\n          (entry) => !individualParticipantIds.includes(entry.participantId)\n        );\n      });\n      // also remove any relevant individualParticipant any flight.drawEntries\n      const { flightProfile } = getFlightProfile({ event });\n      (flightProfile?.flights || []).forEach((flight) => {\n        flight.drawEntries = (flight.drawEntries || []).filter(\n          (entry) => !individualParticipantIds.includes(entry.participantId)\n        );\n      });\n    }\n  }\n\n  return { ...SUCCESS, scaledParticipants };\n}\n","import { checkRequiredParameters } from '../../../parameters/checkRequiredParameters';\nimport { getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { removeExtension } from '../removeExtension';\nimport { addExtension } from '../addExtension';\n\nimport { MISSING_TOURNAMENT_RECORD, POLICY_NOT_FOUND } from '../../../constants/errorConditionConstants';\nimport { DrawDefinition, Event, Tournament } from '../../../types/tournamentTypes';\nimport { APPLIED_POLICIES } from '../../../constants/extensionConstants';\nimport { TournamentRecords } from '../../../types/factoryTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  DRAW_DEFINITION,\n  EVENT,\n  POLICY_TYPE,\n  TOURNAMENT_RECORD,\n  TOURNAMENT_RECORDS,\n} from '../../../constants/attributeConstants';\n\ntype RemovePolicyArgs = {\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  drawDefinition?: DrawDefinition;\n  tournamentId?: string;\n  policyType: string;\n  event?: Event;\n};\nexport function removePolicy(params: RemovePolicyArgs) {\n  const checkParams = checkRequiredParameters(params, [\n    {\n      [POLICY_TYPE]: true,\n      _anyOf: {\n        [TOURNAMENT_RECORDS]: false,\n        [TOURNAMENT_RECORD]: false,\n        [DRAW_DEFINITION]: false,\n        [EVENT]: false,\n      },\n    },\n  ]);\n  if (checkParams.error) return checkParams;\n  let policyRemoved;\n\n  const element =\n    params.drawDefinition ??\n    params.event ??\n    ((params.tournamentId || !params.tournamentRecords) && params.tournamentRecord);\n  if (element) {\n    return policyDeletion(params, element);\n  } else if (params.tournamentRecords) {\n    const tournamentIds = Object.keys(params.tournamentRecords);\n    if (!tournamentIds.length) return { error: MISSING_TOURNAMENT_RECORD };\n    for (const tournamentId of tournamentIds) {\n      const tournamentRecord = params.tournamentRecords[tournamentId];\n      const result = policyDeletion(params, tournamentRecord);\n      if (result.error) return result;\n      policyRemoved = true;\n    }\n  } else {\n    return { error: MISSING_TOURNAMENT_RECORD };\n  }\n\n  return policyRemoved ? { ...SUCCESS } : { error: POLICY_NOT_FOUND };\n}\n\nfunction policyDeletion(params, element) {\n  const appliedPolicies = getAppliedPolicies(params).appliedPolicies ?? {};\n  if (appliedPolicies[params.policyType]) {\n    delete appliedPolicies[params.policyType];\n\n    if (Object.keys(appliedPolicies).length) {\n      const extension = { name: APPLIED_POLICIES, value: appliedPolicies };\n      addExtension({ element, extension });\n    } else {\n      removeExtension({ element, name: APPLIED_POLICIES });\n    }\n    return { ...SUCCESS };\n  }\n\n  return { error: POLICY_NOT_FOUND };\n}\n","import { attachPolicies } from '../../../mutate/extensions/policies/attachPolicies';\nimport { removePolicy } from '../../../mutate/extensions/policies/removePolicy';\n\nexport const policyGovernor = {\n  attachPolicies,\n  removePolicy,\n};\n\nexport default policyGovernor;\n","import { addNotice } from '../../global/state/globalState';\nimport { getTimeItem } from '../../query/base/timeItems';\nimport { addTimeItem } from './addTimeItem';\n\nimport { PUBLIC, PUBLISH, STATUS } from '../../constants/timeItemConstants';\nimport { UNPUBLISH_ORDER_OF_PLAY } from '../../constants/topicConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../constants/errorConditionConstants';\n\nexport function unPublishOrderOfPlay(params) {\n  const tournamentRecords =\n    params?.tournamentRecords ??\n    (params?.tournamentRecord && {\n      [params.tournamentRecord.tournamentId]: params.tournamentRecord,\n    }) ??\n    {};\n\n  if (!Object.keys(tournamentRecords).length)\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const result = unPublishOOP({\n      tournamentRecord,\n      ...params,\n    });\n    if (result.error) return result;\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction unPublishOOP({\n  removePriorValues = true,\n  tournamentRecord,\n  status = PUBLIC,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const itemType = `${PUBLISH}.${STATUS}`;\n  const { timeItem } = getTimeItem({\n    element: tournamentRecord,\n    itemType,\n  });\n\n  const itemValue = timeItem?.itemValue || { [status]: {} };\n\n  if (itemValue[status]) delete itemValue[status].orderOfPlay;\n\n  const updatedTimeItem = {\n    itemValue,\n    itemType,\n  };\n\n  addTimeItem({\n    timeItem: updatedTimeItem,\n    element: tournamentRecord,\n    removePriorValues,\n  });\n  addNotice({\n    topic: UNPUBLISH_ORDER_OF_PLAY,\n    payload: {\n      tournamentId: tournamentRecord.tournamentId,\n    },\n  });\n\n  return { ...SUCCESS };\n}\n","import { resolveTournamentRecords } from '../../parameters/resolveTournamentRecords';\nimport { addNotice } from '../../global/state/globalState';\nimport { getTimeItem } from '../../query/base/timeItems';\nimport { addTimeItem } from './addTimeItem';\n\nimport { PUBLIC, PUBLISH, STATUS } from '../../constants/timeItemConstants';\nimport { PUBLISH_ORDER_OF_PLAY } from '../../constants/topicConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../constants/errorConditionConstants';\n\nexport function publishOrderOfPlay(params) {\n  const tournamentRecords = resolveTournamentRecords(params);\n\n  if (!Object.keys(tournamentRecords).length)\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const result = publishOOP({\n      tournamentRecord,\n      ...params,\n    });\n    if (result.error) return result;\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction publishOOP({\n  scheduledDates = [],\n  removePriorValues,\n  tournamentRecord,\n  status = PUBLIC,\n  eventIds = [],\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const itemType = `${PUBLISH}.${STATUS}`;\n  const { timeItem } = getTimeItem({\n    element: tournamentRecord,\n    itemType,\n  });\n\n  const itemValue = timeItem?.itemValue || { [status]: {} };\n\n  itemValue[status].orderOfPlay = { published: true, scheduledDates, eventIds };\n\n  const updatedTimeItem = {\n    itemValue,\n    itemType,\n  };\n\n  addTimeItem({\n    timeItem: updatedTimeItem,\n    element: tournamentRecord,\n    removePriorValues,\n  });\n\n  addNotice({\n    topic: PUBLISH_ORDER_OF_PLAY,\n    payload: {\n      tournamentId: tournamentRecord.tournamentId,\n      scheduledDates,\n      eventIds,\n    },\n  });\n\n  return { ...SUCCESS };\n}\n","import { unPublishOrderOfPlay } from '../../../mutate/timeItems/unPublishOrderOfPlay';\nimport { publishOrderOfPlay } from '../../../mutate/timeItems/publishOrderOfPlay';\nimport { setEventDisplay } from '../../../mutate/events/setEventDisplay';\nimport { getPublishState } from '../../../query/events/getPublishState';\nimport { unPublishEvent } from '../../../mutate/events/unPublishEvent';\nimport { getAllEventData } from '../../../query/event/getAllEventData';\nimport { getDrawData } from '../../../query/drawDefinition/getDrawData';\nimport { publishEvent } from '../../../mutate/events/publishEvent';\nimport { getVenueData } from '../../../query/venues/getVenueData';\nimport { getCourtInfo } from '../../../query/venues/getCourtInfo';\nimport { getEventData } from '../../../query/event/getEventData';\nimport {\n  publishEventSeeding,\n  unPublishEventSeeding,\n} from '../../../mutate/events/eventSeeding';\n\nexport const publishingGovernor = {\n  getAllEventData,\n  getCourtInfo,\n  getDrawData,\n  getEventData,\n  getPublishState,\n  getVenueData,\n  publishEvent,\n  publishEventSeeding,\n  publishOrderOfPlay,\n  setEventDisplay,\n  unPublishEvent,\n  unPublishEventSeeding,\n  unPublishOrderOfPlay,\n};\n\nexport default publishingGovernor;\n","import { getScheduleTiming } from '../extensions/matchUpFormatTiming/getScheduleTiming';\nimport { getVenuesAndCourts } from '../venues/venuesAndCourtsGetter';\nimport { getTournamentInfo } from '../tournaments/getTournamentInfo';\nimport { getDrawMatchUps } from '../matchUps/drawMatchUps';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\nimport { getEventPublishStatus } from './getEventPublishStatus';\n\nexport function getAllEventData({ tournamentRecord, policyDefinitions }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const events = tournamentRecord.events || [];\n  const tournamentParticipants = tournamentRecord?.participants || [];\n\n  const { tournamentInfo } = getTournamentInfo({ tournamentRecord });\n\n  const { venues: venuesData } = getVenuesAndCourts({\n    tournamentRecord,\n  });\n\n  const eventsData = events.map((event) => {\n    const { eventId } = event;\n    const eventInfo = (({\n      eventId,\n      eventName,\n      eventType,\n      eventLevel,\n      surfaceCategory,\n      matchUpFormat,\n      category,\n      gender,\n      startDate,\n      endDate,\n      ballType,\n      discipline,\n    }) => ({\n      eventId,\n      eventName,\n      eventType,\n      eventLevel,\n      surfaceCategory,\n      matchUpFormat,\n      category,\n      gender,\n      startDate,\n      endDate,\n      ballType,\n      discipline,\n    }))(event);\n\n    const scheduleTiming = getScheduleTiming({\n      tournamentRecord,\n      event,\n    }).scheduleTiming;\n\n    const drawsData = (event.drawDefinitions || []).map((drawDefinition) => {\n      const drawInfo = (({ drawId, drawName, matchUpFormat, updatedAt }) => ({\n        matchUpFormat,\n        updatedAt,\n        drawName,\n        drawId,\n      }))(drawDefinition);\n\n      const {\n        abandonedMatchUps,\n        completedMatchUps,\n        upcomingMatchUps,\n        pendingMatchUps,\n      } = getDrawMatchUps({\n        requireParticipants: true,\n        tournamentParticipants,\n        context: { eventId },\n        policyDefinitions,\n        tournamentRecord,\n        inContext: true,\n        scheduleTiming,\n        drawDefinition,\n        event,\n      });\n\n      return {\n        drawInfo,\n        matchUps: {\n          abandonedMatchUps,\n          completedMatchUps,\n          upcomingMatchUps,\n          pendingMatchUps,\n        },\n      };\n    });\n\n    const publish = getEventPublishStatus({ event });\n\n    Object.assign(eventInfo, {\n      drawsData,\n      publish,\n    });\n\n    return eventInfo;\n  });\n\n  const allEventData = { tournamentInfo, venuesData, eventsData };\n\n  return { allEventData };\n}\n","import { definedAttributes } from '../../utilities/definedAttributes';\nimport { modifyEventPublishStatus } from './modifyEventPublishStatus';\nimport { getEventPublishStatus } from '../../query/event/getEventPublishStatus';\nimport { addNotice } from '../../global/state/globalState';\n\nimport { PUBLIC } from '../../constants/timeItemConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\nimport {\n  PUBLISH_EVENT_SEEDING,\n  UNPUBLISH_EVENT_SEEDING,\n} from '../../constants/topicConstants';\n\nexport function publishEventSeeding({\n  removePriorValues = true,\n  stageSeedingScaleNames,\n  seedingScaleNames,\n  tournamentRecord,\n  status = PUBLIC,\n  drawIds = [],\n  event,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n\n  const eventPubStatus = getEventPublishStatus({ event, status });\n\n  const updatedSeedingScaleNames = (eventPubStatus?.seeding\n    ?.seedingScaleNames ||\n    seedingScaleNames) && {\n    ...eventPubStatus?.seeding?.seedingScaleNames,\n    ...seedingScaleNames,\n  };\n\n  const updatedStageSeedingScaleNames = (eventPubStatus?.seeding\n    ?.stageSeedingScaleNames ||\n    stageSeedingScaleNames) && {\n    ...eventPubStatus?.seeding?.stageSeedingScaleNames,\n    ...stageSeedingScaleNames,\n  };\n\n  const seeding = definedAttributes({\n    stageSeedingScaleNames: updatedStageSeedingScaleNames,\n    seedingScaleNames: updatedSeedingScaleNames,\n    published: true,\n    drawIds,\n  });\n\n  modifyEventPublishStatus({\n    statusObject: { seeding },\n    removePriorValues,\n    status,\n    event,\n  });\n\n  addNotice({\n    topic: PUBLISH_EVENT_SEEDING,\n    payload: {\n      tournamentId: tournamentRecord.tournamentId,\n      eventId: event.eventId,\n      drawIds,\n    },\n  });\n\n  return { ...SUCCESS };\n}\n\nexport function unPublishEventSeeding({\n  removePriorValues = true,\n  seedingScaleNames,\n  tournamentRecord,\n  status = PUBLIC,\n  drawIds,\n  stages,\n  event,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n\n  const eventPubStatus = getEventPublishStatus({ event });\n\n  if (eventPubStatus) {\n    const seeding = eventPubStatus.seeding;\n\n    if (Array.isArray(stages) && seeding.stageSeedingScaleNames) {\n      for (const stage of stages) {\n        if (seeding.stageSeedingScaleNames[stage]) {\n          delete seeding.stageSeedingScaleNames[stage];\n        }\n      }\n    }\n\n    if (Array.isArray(seedingScaleNames) && seeding?.seedingScaleNames) {\n      seeding.seedingScaleNames = seeding.seedingScaleNames.filter(\n        (scaleName) => !seedingScaleNames.includes(scaleName)\n      );\n    }\n\n    if (Array.isArray(drawIds) && seeding?.drawIds) {\n      seeding.drawIds = seeding.drawIds.filter(\n        (drawId) => !drawIds.includes(drawId)\n      );\n    }\n\n    if (\n      (!Object.values(seeding.stageSeedingScaleNames ?? {}).length &&\n        !seeding.seedingScaleNames?.length &&\n        !seeding.drawIds?.length) ||\n      (!stages && !seedingScaleNames && !drawIds?.length)\n    ) {\n      delete seeding.stageSeedingScaleNames;\n      delete seeding.seedingScaleNames;\n      delete seeding.drawIds;\n      seeding.published = false;\n    }\n\n    modifyEventPublishStatus({\n      statusObject: { seeding },\n      removePriorValues,\n      status,\n      event,\n    });\n  }\n\n  addNotice({\n    topic: UNPUBLISH_EVENT_SEEDING,\n    payload: {\n      tournamentId: tournamentRecord.tournamentId,\n      eventId: event.eventId,\n    },\n  });\n\n  return { ...SUCCESS };\n}\n","import { isObject, objShallowEqual } from '../../utilities/objects';\nimport { modifyEventPublishStatus } from './modifyEventPublishStatus';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\n\nimport { Event, Tournament } from '../../types/tournamentTypes';\nimport { PUBLIC } from '../../constants/timeItemConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\ntype ScheduleDetails = {\n  attributes: { [key: string]: boolean }; // true indicates display; false indicates excise from data\n  dates: string[]; // empty array should be fallback for date not found?\n};\ntype DisplayAttributes = {\n  participantAttributes?: { [key: string]: any }; // attributeFilter template: true indicates display; false indicates excise from data\n  scheduleDetails?: ScheduleDetails[];\n  [key: string]: any; // for extensibility and 3rd party use\n  theme?: string;\n};\n\ntype DisplaySettings = {\n  draws: {\n    [key: string]: DisplayAttributes; // drawIds as keys\n    default: DisplayAttributes;\n  };\n  [key: string]: any; // for extensibility and 3rd party use\n};\n\ntype SetEventDisplaySettings = {\n  displaySettings: DisplaySettings;\n  tournamentRecord: Tournament;\n  removePriorValues?: boolean;\n  eventId?: string;\n  status?: string;\n  event: Event;\n};\nexport function setEventDisplay({\n  removePriorValues,\n  tournamentRecord,\n  displaySettings,\n  status = PUBLIC,\n  event,\n}: SetEventDisplaySettings): ResultType {\n  if (!tournamentRecord)\n    return decorateResult({ result: { error: MISSING_TOURNAMENT_RECORD } });\n  if (!event) return decorateResult({ result: { error: MISSING_EVENT } });\n  if (!isObject(displaySettings))\n    return decorateResult({ result: { error: MISSING_VALUE } });\n\n  // combine ScheduleDetails that are equivalent\n  if (isObject(displaySettings.draws)) {\n    for (const key of Object.keys(displaySettings.draws)) {\n      const details = displaySettings.draws[key].scheduleDetails ?? [];\n      if (details.length) {\n        const scheduleDetails: ScheduleDetails[] = [];\n        for (const detail of details) {\n          const existingDetail = scheduleDetails.find((sd) =>\n            objShallowEqual(sd.attributes, detail.attributes)\n          );\n          if (existingDetail?.dates && detail.dates) {\n            existingDetail.dates.push(...detail.dates);\n          } else {\n            scheduleDetails.push(detail);\n          }\n        }\n        displaySettings.draws[key].scheduleDetails = scheduleDetails;\n      }\n    }\n  }\n\n  const result = modifyEventPublishStatus({\n    statusObject: { displaySettings },\n    removePriorValues,\n    status,\n    event,\n  });\n  if (result.error) return result;\n\n  return { ...SUCCESS };\n}\n","import { modifyEventPublishStatus } from './modifyEventPublishStatus';\nimport { addEventTimeItem } from '../timeItems/addTimeItem';\nimport { addNotice } from '../../global/state/globalState';\nimport { getEventTimeItem } from '../../query/base/timeItems';\n\nimport { PUBLIC, PUBLISH, STATUS } from '../../constants/timeItemConstants';\nimport { UNPUBLISH_EVENT } from '../../constants/topicConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\nexport function unPublishEvent({\n  removePriorValues = true,\n  tournamentRecord,\n  status = PUBLIC,\n  event,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n\n  const itemType = `${PUBLISH}.${STATUS}`;\n\n  const { timeItem } = getEventTimeItem({\n    itemType,\n    event,\n  });\n\n  const itemValue = timeItem?.itemValue || { [status]: {} };\n  delete itemValue[status].structureIds; // legacy\n  delete itemValue[status].drawDetails;\n  delete itemValue[status].drawIds; // legacy\n\n  const updatedTimeItem = { itemValue, itemType };\n\n  addEventTimeItem({ event, timeItem: updatedTimeItem, removePriorValues });\n\n  modifyEventPublishStatus({\n    statusObject: {\n      structureIds: undefined,\n      drawIds: undefined,\n      seeding: undefined,\n    },\n    removePriorValues,\n    status,\n    event,\n  });\n\n  addNotice({\n    topic: UNPUBLISH_EVENT,\n    payload: {\n      tournamentId: tournamentRecord.tournamentId,\n      eventId: event.eventId,\n    },\n  });\n\n  return { eventId: event.eventId, ...SUCCESS };\n}\n","import { findExtension } from '../../acquire/findExtension';\n\nimport { QueueMethod, TournamentRecords } from '../../types/factoryTypes';\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../constants/errorConditionConstants';\n\n/**\n * Specific to deployments where both client and server are running competitionEngine.\n *\n * Supports execution model where client makes local updates which are not communicated to server and then...\n * ...when client is ready to communicate extension updates to server it requests an array of update methods\n * This method is \"wrapped\" by other methods which pass in `extensionName`\n */\n\ntype GetExtensionUpdateArgs = {\n  tournamentRecords: TournamentRecords;\n  extensionName: string;\n};\n\nexport function getExtensionUpdate({\n  tournamentRecords,\n  extensionName,\n}: GetExtensionUpdateArgs): { error?: ErrorType } | { methods: QueueMethod[] } {\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const methods: any[] = [];\n  let tournamentExtensionAdded;\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const { extension } = findExtension({\n      element: tournamentRecord,\n      name: extensionName,\n    });\n\n    // only necessary to push this method once to cover both tournaments\n    if (extension && !tournamentExtensionAdded) {\n      methods.push({\n        params: { extension, discover: true },\n        method: 'addExtension',\n      });\n      tournamentExtensionAdded = true;\n    }\n    const tournamentEvents = tournamentRecord.events ?? [];\n\n    for (const event of tournamentEvents) {\n      const { eventId } = event;\n      const { extension } = findExtension({\n        name: extensionName,\n        element: event,\n      });\n      if (extension) {\n        methods.push({\n          params: { eventId, extension },\n          method: 'addEventExtension',\n        });\n      }\n    }\n  }\n\n  return { methods };\n}\n","import { POLICY_TYPE_SCHEDULING } from '../../constants/policyConstants';\nimport { DOUBLES, SINGLES } from '../../constants/matchUpTypes';\nimport { FORMAT_STANDARD } from '../scoring/matchUpFormats';\n\n// categoryTypes\nconst ADULT = 'ADULT';\nconst JUNIOR = 'JUNIOR';\nconst WHEELCHAIR = 'WHEELCHAIR';\n\nexport const POLICY_SCHEDULING_DEFAULT = {\n  [POLICY_TYPE_SCHEDULING]: {\n    allowModificationWhenMatchUpsScheduled: {\n      courts: false,\n      venues: false,\n    },\n    defaultTimes: {\n      averageTimes: [{ categoryNames: [], minutes: { default: 90 } }],\n      recoveryTimes: [{ minutes: { [DOUBLES]: 30, default: 60 } }],\n    },\n    defaultDailyLimits: {\n      [SINGLES]: 2,\n      [DOUBLES]: 2,\n      total: 3,\n    },\n    matchUpAverageTimes: [\n      {\n        matchUpFormatCodes: [FORMAT_STANDARD], // Best of 3 tiebreak sets\n        averageTimes: [\n          {\n            categoryNames: [],\n            minutes: { default: 90 },\n          },\n          {\n            categoryTypes: [WHEELCHAIR],\n            minutes: { default: 120 },\n          },\n        ],\n      },\n      {\n        matchUpFormatCodes: ['SET3-S:6/TB7-F:TB10'], // Two tiebreak sets, 10-point match tiebreak at one set all\n        averageTimes: [{ categoryNames: [], minutes: { default: 85 } }],\n      },\n      {\n        matchUpFormatCodes: ['SET3-S:6/TB7-F:TB7'], // Two tiebreak sets, 7-point match tiebreak at one set all\n        averageTimes: [{ categoryNames: [], minutes: { default: 70 } }],\n      },\n      {\n        matchUpFormatCodes: ['SET3-S:4NOAD-F:TB7'], // Two short sets to 4 with deciding game at 3-3, 7-point match tiebreak at one set all\n        averageTimes: [{ categoryNames: [], minutes: { default: 55 } }],\n      },\n      {\n        matchUpFormatCodes: ['SET3-S:4/TB7'], // Best of 3 sets to 4\n        averageTimes: [{ categoryNames: [], minutes: { default: 60 } }],\n      },\n      {\n        matchUpFormatCodes: ['SET3-S:4/TB7-F:TB7'], // Two short sets to 4, 7-point match tiebreak at one set all\n        averageTimes: [{ categoryNames: [], minutes: { default: 50 } }],\n      },\n      {\n        matchUpFormatCodes: ['SET3-S:4/TB7-F:TB10'], // Two short sets to 4, 10-point match tiebreak at one set all\n        averageTimes: [{ categoryNames: [], minutes: { default: 55 } }],\n      },\n      {\n        matchUpFormatCodes: ['SET3-S:4/TB5@3'], // Two out of three short sets to 4 with 5-point tiebreak at 3 games all\n        averageTimes: [{ categoryNames: [], minutes: { default: 45 } }],\n      },\n      {\n        matchUpFormatCodes: [\n          'SET1-S:8/TB7' /* 8 game pro-set with 7 point tiebreak at 8 games all */,\n          'SET1-S:8/TB7@7' /* 8 game pro-set with 7 point tiebreak at 7 games all */,\n        ],\n        averageTimes: [{ categoryNames: [], minutes: { default: 40 } }],\n      },\n      {\n        matchUpFormatCodes: ['SET1-S:5/TB9@4'], // One no advantage set to 5, tiebreak to 9 at 4-4\n        averageTimes: [{ categoryNames: [], minutes: { default: 30 } }],\n      },\n      {\n        matchUpFormatCodes: ['SET1-S:6/TB7'], // One standard tiebreak set to 6, 7-point tiebreak at 6 games all\n        averageTimes: [{ categoryNames: [], minutes: { default: 30 } }],\n      },\n      {\n        matchUpFormatCodes: ['SET1-S:6NOAD'], // One set to 6 with deciding game at 5 games all\n        averageTimes: [{ categoryNames: [], minutes: { default: 30 } }],\n      },\n      {\n        matchUpFormatCodes: [\n          'SET1-S:4/TB7' /* One short set to 4, 7-point tiebreak at 4 games all */,\n          'SET1-S:4/TB5@3' /* One short set to 4, 5-point tiebreak at 3 games all */,\n          'SET3-S:TB10' /* Best of 3 10-point tiebreak games */,\n          'SET1-S:T20' /* Timed 20 minute game - game based' */,\n        ],\n        averageTimes: [{ categoryNames: [], minutes: { default: 20 } }],\n      },\n      {\n        matchUpFormatCodes: ['SET1-S:4NOAD'], // One short set to 4, deciding game is played at 3 games all\n        averageTimes: [{ categoryNames: [], minutes: { default: 20 } }],\n      },\n      {\n        matchUpFormatCodes: ['SET1-S:TB10'], // One 10-point tiebreak game\n        averageTimes: [{ categoryNames: [], minutes: { default: 10 } }],\n      },\n    ],\n    matchUpRecoveryTimes: [\n      {\n        matchUpFormatCodes: [\n          'SET3-S:6/TB7' /* Best of 3 tiebreak sets */,\n          'SET3-S:6/TB7-F:TB10' /* Two tiebreak sets, 10-point match tiebreak at one set all */,\n          'SET3-S:6/TB7-F:TB7' /* Two tiebreak sets, 7-point match tiebreak at one set all */,\n        ],\n        recoveryTimes: [\n          {\n            categoryTypes: [ADULT, WHEELCHAIR],\n            minutes: { default: 60, [DOUBLES]: 30 },\n          },\n          {\n            categoryTypes: [JUNIOR],\n            minutes: { default: 60, [DOUBLES]: 60 },\n          },\n        ],\n      },\n      {\n        matchUpFormatCodes: [\n          'SET3-S:4/TB7-F:TB7' /* Two short sets to 4, 7-point match tiebreak at one set all */,\n          'SET3-S:4/TB7-F:TB10' /* Two short sets to 4, 10-point match tiebreak at one set all */,\n          'SET3-S:4NOAD-F:TB7' /* Two short sets to 4 with deciding game at 3-3, 7-point match tiebreak at one set all */,\n          'SET3-S:4/TB7' /* Best of 3 sets to 4 */,\n          'SET3-S:4/TB5@3' /* Two out of three short sets to 4 with 5-point tiebreak at 3 games all */,\n        ],\n        recoveryTimes: [\n          {\n            categoryTypes: [ADULT, WHEELCHAIR],\n            minutes: { default: 30 },\n          },\n          {\n            categoryTypes: [JUNIOR],\n            minutes: { default: 60 },\n          },\n        ],\n      },\n      {\n        matchUpFormatCodes: [\n          'SET1-S:8/TB7' /* 8 game pro-set with 7 point tiebreak at 8 games all */,\n          'SET1-S:8/TB7@7' /* 8 game pro-set with 7 point tiebreak at 7 games all */,\n          'SET1-S:5/TB9@4' /* One no advantage set to 5, tiebreak to 9 at 4-4 */,\n          'SET1-S:6/TB7' /* One standard tiebreak set to 6, 7-point tiebreak at 6 games all */,\n          'SET1-S:6NOAD' /* One set to 6 with deciding game at 5 games all */,\n          'SET1-S:4/TB7' /* One short set to 4, 7-point tiebreak at 4 games all */,\n          'SET1-S:4NOAD' /* One short set to 4, deciding game is played at 3 games all */,\n          'SET3-S:TB10' /* Best of 3 10-point tiebreak games */,\n          'SET1-S:T20' /* Timed 20 minute game - game based */,\n        ],\n        recoveryTimes: [\n          {\n            categoryNames: [],\n            minutes: { default: 30 },\n          },\n        ],\n      },\n      {\n        matchUpFormatCodes: ['SET1-S:4/TB5@3'], // One short set to 4, 5-point tiebreak at 3 games all\n        recoveryTimes: [\n          {\n            categoryTypes: [ADULT, JUNIOR],\n            minutes: { default: 30 },\n          },\n          {\n            categoryTypes: [WHEELCHAIR],\n            minutes: { default: 15 },\n          },\n        ],\n      },\n      {\n        matchUpFormatCodes: ['SET1-S:TB10'], // One 10-point tiebreak game\n        recoveryTimes: [\n          {\n            categoryNames: [],\n            minutes: { default: 15 },\n          },\n        ],\n      },\n    ],\n    matchUpDailyLimits: [],\n  },\n};\n\nexport default POLICY_SCHEDULING_DEFAULT;\n","import { isValidMatchUpFormat } from '../../../validators/isValidMatchUpFormat';\nimport { checkRequiredParameters } from '../../../parameters/checkRequiredParameters';\nimport { findExtension } from '../../../acquire/findExtension';\nimport {\n  findMatchupFormatAverageTimes,\n  findMatchupFormatRecoveryTimes,\n} from '../../../acquire/findMatchUpFormatTimes';\n\nimport { UNRECOGNIZED_MATCHUP_FORMAT } from '../../../constants/errorConditionConstants';\nimport { SCHEDULE_TIMING } from '../../../constants/extensionConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { Event, Tournament } from '../../../types/tournamentTypes';\nimport {\n  INVALID,\n  MATCHUP_FORMAT,\n  TOURNAMENT_RECORD,\n  VALIDATE,\n} from '../../../constants/attributeConstants';\n\ntype GetModifiedMatchUpFormatTimingArgs = {\n  tournamentRecord: Tournament;\n  matchUpFormat: string;\n  event: Event;\n};\n\nexport function getModifiedMatchUpFormatTiming(\n  params: GetModifiedMatchUpFormatTimingArgs\n): ResultType & {\n  matchUpFormat?: string;\n  recoveryTimes?: any[];\n  averageTimes?: any[];\n} {\n  const paramCheck = checkRequiredParameters(params, [\n    { [TOURNAMENT_RECORD]: true },\n    {\n      [VALIDATE]: (matchUpFormat) => isValidMatchUpFormat({ matchUpFormat }),\n      [INVALID]: UNRECOGNIZED_MATCHUP_FORMAT,\n      [MATCHUP_FORMAT]: true,\n    },\n  ]);\n  if (paramCheck.error) return paramCheck;\n\n  const { tournamentRecord, matchUpFormat, event } = params;\n\n  const { extension: eventExtension } = findExtension({\n    name: SCHEDULE_TIMING,\n    element: event,\n  });\n  const eventScheduling = eventExtension?.value;\n\n  const { extension: tournamentExtension } = findExtension({\n    element: tournamentRecord,\n    name: SCHEDULE_TIMING,\n  });\n  const tournamentScheduling = tournamentExtension?.value;\n\n  const eventAverageTimes =\n    eventScheduling?.matchUpAverageTimes &&\n    findMatchupFormatAverageTimes({\n      ...eventScheduling,\n      matchUpFormat,\n    });\n\n  const tournamentAverageTimes =\n    tournamentScheduling?.matchUpAverageTimes &&\n    findMatchupFormatAverageTimes({\n      ...tournamentScheduling,\n      matchUpFormat,\n    });\n\n  const averageTimes = [eventAverageTimes, tournamentAverageTimes].find(\n    (f) => f\n  );\n\n  const eventRecoveryTimes =\n    eventScheduling?.matchUpRecoveryTimes &&\n    findMatchupFormatRecoveryTimes({\n      ...eventScheduling,\n      matchUpFormat,\n    });\n\n  const tournamentRecoveryTimes =\n    tournamentScheduling?.matchUpRecoveryTimes &&\n    findMatchupFormatRecoveryTimes({\n      ...tournamentScheduling,\n      matchUpFormat,\n    });\n\n  const recoveryTimes = [eventRecoveryTimes, tournamentRecoveryTimes].find(\n    (f) => f\n  );\n\n  return {\n    matchUpFormat,\n    recoveryTimes,\n    averageTimes,\n  };\n}\n","import { Penalty, Tournament } from '../../../types/tournamentTypes';\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../../constants/errorConditionConstants';\n\ntype GetTournamentPenaltiesArgs = {\n  tournamentRecord: Tournament;\n};\nexport function getTournamentPenalties({\n  tournamentRecord,\n}: GetTournamentPenaltiesArgs): { error?: ErrorType; penalties?: Penalty[] } {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  const participants = tournamentRecord?.participants ?? [];\n  const allPenalties = participants.reduce((penalties, participant) => {\n    const { participantId } = participant;\n    (participant.penalties ?? []).forEach((penalty) => {\n      const { penaltyId } = penalty || {};\n      if (penalties[penaltyId]) {\n        penalties[penaltyId].participants.push(participantId);\n      } else {\n        penalties[penaltyId] = {\n          ...penalty,\n          participantIds: [participantId],\n        };\n      }\n    });\n    return penalties;\n  }, {});\n\n  return { penalties: Object.values(allPenalties) };\n}\n","import { HydratedMatchUp } from '../../types/hydrated';\nimport { extractDate, extractTime } from '../../utilities/dateTime';\n\ntype ScheduledSortedMatchUpsArgs = {\n  matchUps: HydratedMatchUp[];\n  schedulingProfile: any[];\n};\nexport function scheduledSortedMatchUps({\n  schedulingProfile,\n  matchUps = [],\n}: ScheduledSortedMatchUpsArgs) {\n  const profileHash = {};\n\n  // hash is used to store a sort order value for scheduled rounds\n  const getHash = ({ eventId, drawId, structureId, roundNumber }) => {\n    return `${eventId}|${drawId}|${structureId}${roundNumber}`;\n  };\n\n  if (schedulingProfile?.length) {\n    const roundsGroupings = schedulingProfile\n      .map(({ venues }) => venues.map(({ rounds }) => rounds))\n      .flat();\n\n    roundsGroupings.forEach((grouping) => {\n      const sortedRounds = grouping.sort(\n        (a, b) => (a.sortOrder || 0) - (b.sortOrder || 0)\n      );\n      sortedRounds.forEach(\n        ({ eventId, drawId, structureId, roundNumber }, index) => {\n          const hash = getHash({ eventId, drawId, structureId, roundNumber });\n          profileHash[hash] = index;\n        }\n      );\n    });\n  }\n\n  const sortedMatchUps: HydratedMatchUp[] = [];\n  const dateGroups = { noScheduledDate: [] };\n\n  // 1. Segregate matchUps by date (date can come from schedule.scheduledDate or schedule.scheduledTime)\n  for (const matchUp of matchUps) {\n    const schedule = matchUp.schedule || {};\n    const scheduledDate =\n      (schedule.scheduledDate && extractDate(schedule.scheduledDate)) ||\n      (schedule.scheduledTime && extractDate(schedule.scheduledTime)) ||\n      'noScheduledDate';\n\n    if (!dateGroups[scheduledDate]) dateGroups[scheduledDate] = [];\n    dateGroups[scheduledDate].push(matchUp);\n  }\n\n  // this works because all dates are strings and 'noScheduledDate' sorts to last after numeric strings\n  const sortedDateKeys = Object.keys(dateGroups).sort();\n\n  // 2. For each date group, sort all matchUps by time\n  for (const scheduledDate of sortedDateKeys) {\n    const dateGroup = dateGroups[scheduledDate];\n\n    const timeGroups = { noScheduledTime: [] };\n\n    for (const matchUp of dateGroup) {\n      const schedule = matchUp.schedule || {};\n      const scheduledTime =\n        (schedule.scheduledTime && extractTime(schedule.scheduledTime)) ||\n        'noScheduledTime';\n\n      if (!timeGroups[scheduledTime]) timeGroups[scheduledTime] = [];\n      timeGroups[scheduledTime].push(matchUp);\n    }\n\n    // this works because all times are strings '00:00' and 'noScheduledTime' sorts to last after numeric strings\n    const sortedTimeKeys = Object.keys(timeGroups).sort();\n\n    // 3. for each time group, sort all matchUps by hash values derived from rounds group order\n    for (const scheduledTime of sortedTimeKeys) {\n      const timeGroup = timeGroups[scheduledTime];\n\n      timeGroup.sort((a, b) => {\n        const sortValueA = profileHash[getHash(a)] || 0;\n        const sortValueB = profileHash[getHash(b)] || 0;\n        return sortValueA - sortValueB;\n      });\n\n      sortedMatchUps.push(...timeGroup);\n    }\n  }\n\n  return sortedMatchUps;\n}\n","import { generateRange } from '../../../utilities/arrays';\n\nimport { INVALID_VALUES } from '../../../constants/errorConditionConstants';\n\nexport function courtGridRows({\n  courtPrefix = 'C|',\n  minRowsCount,\n  courtsData,\n}) {\n  if (!Array.isArray(courtsData)) return { error: INVALID_VALUES };\n  const maxCourtOrder = courtsData?.reduce((order, court) => {\n    const matchUps = court.matchUps || [];\n    const courtOrder = Math.max(\n      0,\n      ...matchUps.map((m) => m.schedule.courtOrder || 0)\n    );\n    return courtOrder > order ? courtOrder : order;\n  }, 1);\n\n  const rowsCount = minRowsCount\n    ? Math.max(minRowsCount, maxCourtOrder)\n    : maxCourtOrder;\n\n  const rowBuilder = generateRange(0, rowsCount).map((rowIndex) => ({\n    matchUps: generateRange(0, courtsData.length).map((courtIndex) => {\n      const courtInfo = courtsData[courtIndex];\n      const { courtId, venueId } = courtInfo;\n      return {\n        schedule: {\n          courtOrder: rowIndex + 1,\n          venueId,\n          courtId,\n        },\n      };\n    }),\n  }));\n\n  courtsData.forEach((courtInfo, i) => {\n    for (const matchUp of courtInfo.matchUps) {\n      const courtOrder = matchUp.schedule?.courtOrder;\n      if (courtOrder) {\n        rowBuilder[courtOrder - 1].matchUps[i] = matchUp;\n      }\n    }\n  });\n\n  return {\n    courtPrefix,\n    rows: rowBuilder.map((row, i) =>\n      Object.assign(\n        { rowId: `rowId-${i + 1}` },\n        ...row.matchUps.map((matchUp, i) => ({\n          [`${courtPrefix}${i}`]: matchUp,\n        }))\n      )\n    ),\n  };\n}\n","import { getEventPublishStatus } from '../event/getEventPublishStatus';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { hydrateParticipants } from '../participants/hydrateParticipants';\nimport { MISSING_EVENT } from '../../constants/errorConditionConstants';\nimport { getContextContent } from '../hierarchical/getContextContent';\nimport { getDrawMatchUps } from './drawMatchUps';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  GetMatchUpsArgs,\n  GroupsMatchUpsResult,\n} from '../../types/factoryTypes';\n\nexport function eventMatchUps(params: GetMatchUpsArgs): GroupsMatchUpsResult {\n  let {\n    participants: tournamentParticipants,\n    contextContent,\n    participantMap,\n  } = params;\n\n  const {\n    tournamentAppliedPolicies,\n    scheduleVisibilityFilters,\n    participantsProfile,\n    afterRecoveryTimes,\n    policyDefinitions,\n    useParticipantMap,\n    tournamentRecord,\n    usePublishState,\n    contextFilters,\n    matchUpFilters,\n    contextProfile,\n    nextMatchUps,\n    tournamentId,\n    inContext,\n    context,\n    event,\n  } = params;\n\n  if (!event) return { error: MISSING_EVENT };\n  const { eventId, eventName, endDate } = event;\n\n  const additionalContext = {\n    ...context,\n    ...definedAttributes({\n      eventId,\n      eventName,\n      endDate: endDate ?? tournamentRecord?.endDate,\n      tournamentId: tournamentId ?? tournamentRecord?.tournamentId,\n      indoorOutDoor: event.indoorOutdoor ?? tournamentRecord?.indoorOutdoor,\n      surfaceCategory:\n        event.surfaceCategory ?? tournamentRecord?.surfaceCategory,\n    }),\n  };\n\n  let groupInfo: undefined | any;\n  if (!tournamentParticipants && tournamentRecord) {\n    ({\n      participants: tournamentParticipants,\n      participantMap,\n      groupInfo,\n    } = hydrateParticipants({\n      participantsProfile,\n      policyDefinitions,\n      useParticipantMap,\n      tournamentRecord,\n      contextProfile,\n      inContext,\n    }));\n  }\n\n  if (contextProfile && !contextContent)\n    contextContent = getContextContent({\n      policyDefinitions,\n      tournamentRecord,\n      contextProfile,\n      event,\n    });\n\n  const publishStatus = getEventPublishStatus({ event });\n  const drawDefinitions = event.drawDefinitions ?? [];\n  const eventResult = drawDefinitions.reduce((results, drawDefinition) => {\n    const drawMatchUpsResult = getDrawMatchUps({\n      context: additionalContext,\n      tournamentAppliedPolicies,\n      scheduleVisibilityFilters,\n      tournamentParticipants,\n      participantsProfile,\n      afterRecoveryTimes,\n      policyDefinitions,\n      tournamentRecord,\n      usePublishState,\n      contextContent,\n      contextFilters,\n      matchUpFilters,\n      participantMap,\n      publishStatus,\n      contextProfile,\n      drawDefinition,\n      nextMatchUps,\n      inContext,\n      event,\n    });\n\n    const keys = Object.keys(drawMatchUpsResult);\n    keys?.forEach((key) => {\n      if (Array.isArray(drawMatchUpsResult[key])) {\n        if (!results[key]) results[key] = [];\n        results[key] = results[key].concat(drawMatchUpsResult[key]);\n      }\n    });\n\n    return results;\n  }, {});\n\n  return { ...eventResult, ...SUCCESS, groupInfo };\n}\n","import { getAppliedPolicies } from '../extensions/getAppliedPolicies';\nimport { hydrateParticipants } from '../participants/hydrateParticipants';\nimport { getContextContent } from '../hierarchical/getContextContent';\nimport { getFlightProfile } from '../event/getFlightProfile';\n\nimport {\n  GetMatchUpsArgs,\n  GroupsMatchUpsResult,\n} from '../../types/factoryTypes';\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\nimport { eventMatchUps } from './getEventMatchUps';\n\nexport function tournamentMatchUps(\n  params: GetMatchUpsArgs\n): GroupsMatchUpsResult {\n  if (!params?.tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  let contextContent = params.contextContent;\n  const {\n    scheduleVisibilityFilters,\n    participantsProfile,\n    afterRecoveryTimes,\n    policyDefinitions,\n    useParticipantMap,\n    tournamentRecord,\n    inContext = true,\n    usePublishState,\n    contextFilters,\n    matchUpFilters,\n    contextProfile,\n    nextMatchUps,\n    context,\n  } = params;\n  const tournamentId = params.tournamentId ?? tournamentRecord.tournamentId;\n  const events = tournamentRecord?.events ?? [];\n\n  const { participants, participantMap, groupInfo } = hydrateParticipants({\n    participantsProfile,\n    policyDefinitions,\n    useParticipantMap,\n    tournamentRecord,\n    contextProfile,\n    inContext,\n  });\n\n  if (contextProfile && !contextContent)\n    contextContent = getContextContent({\n      policyDefinitions,\n      tournamentRecord,\n      contextProfile,\n    });\n\n  const { appliedPolicies: tournamentAppliedPolicies } = getAppliedPolicies({\n    tournamentRecord,\n  });\n  const filteredEventIds = contextFilters?.eventIds ?? [];\n  const eventsDrawsMatchUps = events\n    .filter((event) => !filteredEventIds.includes(event.eventId))\n    .map((event) => {\n      const flightProfile = getFlightProfile({ event }).flightProfile;\n      const additionalContext = {\n        eventDrawsCount:\n          flightProfile?.flights?.length || event.drawDefinitions?.length || 0,\n        ...context,\n      };\n\n      return eventMatchUps({\n        context: additionalContext,\n        tournamentAppliedPolicies,\n        scheduleVisibilityFilters,\n        participantsProfile,\n        afterRecoveryTimes,\n        policyDefinitions,\n        tournamentRecord,\n        usePublishState,\n        contextFilters,\n        contextProfile,\n        contextContent,\n        matchUpFilters,\n        participantMap,\n        participants,\n        tournamentId,\n        nextMatchUps,\n        inContext,\n        event,\n      });\n    });\n\n  const eventsDrawMatchUpsResult = eventsDrawsMatchUps.reduce(\n    (matchUps, eventMatchUps) => {\n      const keys =\n        eventMatchUps &&\n        Object.keys(eventMatchUps).filter(\n          (key) => !['success', 'matchUpsMap'].includes(key)\n        );\n      keys?.forEach((key) => {\n        if (Array.isArray(eventMatchUps[key])) {\n          if (!matchUps[key]) matchUps[key] = [];\n          matchUps[key] = matchUps[key].concat(eventMatchUps[key]);\n          matchUps.matchUpsCount += eventMatchUps[key].length;\n        }\n      });\n\n      return matchUps;\n    },\n    { matchUpsCount: 0 }\n  );\n\n  return { ...eventsDrawMatchUpsResult, groupInfo };\n}\n","import { tournamentMatchUps } from './getTournamentMatchUps';\n\nimport { MISSING_TOURNAMENT_RECORDS } from '../../constants/errorConditionConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport {\n  GroupInfo,\n  MatchUpFilters,\n  ParticipantsProfile,\n  PolicyDefinitions,\n  ScheduleVisibilityFilters,\n  TournamentRecords,\n} from '../../types/factoryTypes';\n\ntype CompetitionMatchUpsArgs = {\n  scheduleVisibilityFilters?: ScheduleVisibilityFilters;\n  participantsProfile?: ParticipantsProfile;\n  tournamentRecords: TournamentRecords;\n  policyDefinitions?: PolicyDefinitions;\n  matchUpFilters?: MatchUpFilters;\n  contextFilters?: MatchUpFilters;\n  afterRecoveryTimes?: boolean;\n  usePublishState?: boolean;\n  nextMatchUps?: boolean;\n  inContext?: boolean;\n};\n\nexport function getCompetitionMatchUps({\n  scheduleVisibilityFilters,\n  participantsProfile,\n  tournamentRecords,\n  policyDefinitions,\n  usePublishState,\n  matchUpFilters,\n  contextFilters,\n  nextMatchUps,\n  inContext,\n}: CompetitionMatchUpsArgs): ResultType & {\n  abandonedMatchUps?: HydratedMatchUp[];\n  completedMatchUps?: HydratedMatchUp[];\n  upcomingMatchUps?: HydratedMatchUp[];\n  pendingMatchUps?: HydratedMatchUp[];\n  byeMatchUps?: HydratedMatchUp[];\n  groupInfo?: GroupInfo;\n} {\n  if (typeof tournamentRecords !== 'object' || !Object.keys(tournamentRecords).length)\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const tournamentIds = Object.keys(tournamentRecords);\n  const tournamentsMatchUps = tournamentIds.map((tournamentId) => {\n    const tournamentRecord = tournamentRecords[tournamentId];\n    return tournamentMatchUps({\n      scheduleVisibilityFilters,\n      participantsProfile,\n      policyDefinitions,\n      tournamentRecord,\n      usePublishState,\n      matchUpFilters,\n      contextFilters,\n      nextMatchUps,\n      inContext,\n    });\n  });\n\n  const groupInfo = {};\n  const competitionMatchUpsResult = tournamentsMatchUps.reduce((groupings, matchUpGroupings) => {\n    const keys = Object.keys(matchUpGroupings);\n    keys.forEach((key) => {\n      if (Array.isArray(matchUpGroupings[key])) {\n        if (!groupings[key]) groupings[key] = [];\n        groupings[key] = groupings[key].concat(matchUpGroupings[key]);\n      }\n      if (key === 'groupInfo') {\n        Object.assign(groupInfo, matchUpGroupings[key]);\n      }\n    });\n\n    return groupings;\n  }, {});\n\n  return { ...competitionMatchUpsResult, groupInfo };\n}\n","import { getCompetitionPublishedDrawDetails } from './getCompetitionPublishedDrawDetails';\nimport { scheduledSortedMatchUps } from '../../functions/sorters/scheduledSortedMatchUps';\nimport { courtGridRows } from '../../assemblies/generators/scheduling/courtGridRows';\nimport { getSchedulingProfile } from '../../mutate/tournaments/schedulingProfile';\nimport { getVenuesAndCourts } from '../venues/venuesAndCourtsGetter';\nimport { getCompetitionMatchUps } from './getCompetitionMatchUps';\nimport { getTournamentId } from '../../global/state/globalState';\nimport { getTournamentTimeItem } from '../base/timeItems';\n\nimport { ErrorType, MISSING_TOURNAMENT_RECORDS } from '../../constants/errorConditionConstants';\nimport { MatchUpFilters, TournamentRecords } from '../../types/factoryTypes';\nimport { PUBLIC, PUBLISH, STATUS } from '../../constants/timeItemConstants';\nimport { COMPLETED } from '../../constants/matchUpStatusConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport { Venue } from '../../types/tournamentTypes';\n\ntype CompetitionScheduleMatchUpsArgs = {\n  tournamentRecords: TournamentRecords;\n  courtCompletedMatchUps?: boolean;\n  alwaysReturnCompleted?: boolean;\n  contextFilters?: MatchUpFilters;\n  matchUpFilters?: MatchUpFilters;\n  withCourtGridRows?: boolean;\n  activeTournamentId?: string;\n  sortDateMatchUps?: boolean;\n  minCourtGridRows?: number;\n  usePublishState?: boolean;\n  sortCourtsData?: boolean;\n  status?: string;\n};\n\nexport function competitionScheduleMatchUps(params: CompetitionScheduleMatchUpsArgs): {\n  completedMatchUps?: HydratedMatchUp[];\n  dateMatchUps?: HydratedMatchUp[];\n  courtPrefix?: string;\n  error?: ErrorType;\n  venues?: Venue[];\n  courtsData?: any;\n  rows?: any[];\n} {\n  if (typeof params?.tournamentRecords !== 'object' || !Object.keys(params?.tournamentRecords).length)\n    return { error: MISSING_TOURNAMENT_RECORDS };\n  const { courts, venues } = getVenuesAndCourts(params);\n  const getResult: any = getSchedulingProfile(params);\n  const schedulingProfile = getResult.schedulingProfile;\n\n  const {\n    sortDateMatchUps = true,\n    courtCompletedMatchUps,\n    alwaysReturnCompleted,\n    activeTournamentId,\n    tournamentRecords,\n    withCourtGridRows,\n    minCourtGridRows,\n    usePublishState,\n    status = PUBLIC,\n    sortCourtsData,\n  } = params;\n\n  // PUBLISH.STATUS is attached at the tournament level by `publishOrderOfPlay`\n  const tournamentPublishStatus = usePublishState\n    ? getTournamentTimeItem({\n        tournamentRecord: tournamentRecords[activeTournamentId ?? getTournamentId()],\n        itemType: `${PUBLISH}.${STATUS}`,\n      }).timeItem?.itemValue?.[status]\n    : undefined;\n\n  const allCompletedMatchUps = alwaysReturnCompleted\n    ? getCompetitionMatchUps({\n        ...params,\n        matchUpFilters: {\n          ...params.matchUpFilters,\n          matchUpStatuses: [COMPLETED],\n        },\n        contextFilters: params.contextFilters,\n      }).completedMatchUps\n    : [];\n\n  // if { usePublishState: true } only return non-completed matchUps if there is orderOfPlay detail\n  if (usePublishState && (!tournamentPublishStatus || !Object.keys(tournamentPublishStatus).length)) {\n    return {\n      completedMatchUps: allCompletedMatchUps,\n      dateMatchUps: [],\n      courtsData: [],\n      venues,\n    };\n  }\n\n  let publishedDrawIds, detailsMap;\n  if (usePublishState) {\n    ({ drawIds: publishedDrawIds, detailsMap } = getCompetitionPublishedDrawDetails({\n      tournamentRecords,\n    }));\n  }\n\n  if (publishedDrawIds?.length) {\n    if (!params.contextFilters) params.contextFilters = {};\n    if (!params.contextFilters?.drawIds) {\n      params.contextFilters.drawIds = publishedDrawIds;\n    } else {\n      params.contextFilters.drawIds = params.contextFilters.drawIds.filter((drawId) =>\n        publishedDrawIds.includes(drawId),\n      );\n    }\n  }\n\n  if (tournamentPublishStatus?.eventIds?.length) {\n    if (!params.matchUpFilters) params.matchUpFilters = {};\n    if (params.matchUpFilters?.eventIds) {\n      if (!params.matchUpFilters.eventIds.length) {\n        params.matchUpFilters.eventIds = tournamentPublishStatus.eventIds;\n      } else {\n        params.matchUpFilters.eventIds = params.matchUpFilters.eventIds.filter((eventId) =>\n          tournamentPublishStatus.eventIds.includes(eventId),\n        );\n      }\n    } else {\n      params.matchUpFilters.eventIds = tournamentPublishStatus.eventIds;\n    }\n  }\n\n  if (tournamentPublishStatus?.scheduledDates?.length) {\n    if (!params.matchUpFilters) params.matchUpFilters = {};\n    if (params.matchUpFilters.scheduledDates) {\n      if (!params.matchUpFilters.scheduledDates.length) {\n        params.matchUpFilters.scheduledDates = tournamentPublishStatus.scheduledDates;\n      } else {\n        params.matchUpFilters.scheduledDates = params.matchUpFilters.scheduledDates.filter((scheduledDate) =>\n          tournamentPublishStatus.scheduledDates.includes(scheduledDate),\n        );\n      }\n    } else {\n      params.matchUpFilters.scheduledDates = tournamentPublishStatus.scheduledDates;\n    }\n  }\n\n  // optimization: if all completed matchUps have already been retrieved, skip the hydration process\n  if (alwaysReturnCompleted) {\n    if (!params.matchUpFilters) params.matchUpFilters = {};\n    if (params.matchUpFilters?.excludeMatchUpStatuses?.length) {\n      if (!params.matchUpFilters.excludeMatchUpStatuses.includes(COMPLETED)) {\n        params.matchUpFilters.excludeMatchUpStatuses.push(COMPLETED);\n      }\n    } else {\n      params.matchUpFilters.excludeMatchUpStatuses = [COMPLETED];\n    }\n  }\n\n  const { completedMatchUps, upcomingMatchUps, pendingMatchUps, groupInfo } = getCompetitionMatchUps({\n    ...params,\n    matchUpFilters: params.matchUpFilters,\n    contextFilters: params.contextFilters,\n  });\n\n  let relevantMatchUps = [...(upcomingMatchUps ?? []), ...(pendingMatchUps ?? [])];\n\n  // add any stage or structure filtering\n  if (detailsMap && Object.keys(detailsMap).length) {\n    relevantMatchUps = relevantMatchUps.filter((matchUp) => {\n      const { drawId, structureId, stage } = matchUp;\n      if (!detailsMap[drawId]) return false;\n      if (detailsMap[drawId].stageDetails) {\n        const stageKeys = Object.keys(detailsMap[drawId].stageDetails);\n        const unpublishedStages = stageKeys.filter((stage) => !detailsMap[drawId].stageDetails[stage].published);\n        const publishedStages = stageKeys.filter((stage) => detailsMap[drawId].stageDetails[stage].published);\n        if (unpublishedStages.length && unpublishedStages.includes(stage)) return false;\n        if (publishedStages.length && publishedStages.includes(stage)) return true;\n        return unpublishedStages.length && !unpublishedStages.includes(stage) && !publishedStages.length;\n      }\n      if (detailsMap[drawId].structureDetails) {\n        const structureIdKeys = Object.keys(detailsMap[drawId].structureDetails);\n        const unpublishedStructureIds = structureIdKeys.filter(\n          (structureId) => !detailsMap[drawId].structureDetails[structureId].published,\n        );\n        const publishedStructureIds = structureIdKeys.filter(\n          (structureId) => detailsMap[drawId].structureDetails[structureId].published,\n        );\n        if (unpublishedStructureIds.length && unpublishedStructureIds.includes(structureId)) return false;\n        if (publishedStructureIds.length && publishedStructureIds.includes(structureId)) return true;\n        return (\n          unpublishedStructureIds.length &&\n          !unpublishedStructureIds.includes(structureId) &&\n          !publishedStructureIds.length\n        );\n      }\n      return true;\n    });\n  }\n\n  const dateMatchUps = sortDateMatchUps\n    ? scheduledSortedMatchUps({ matchUps: relevantMatchUps, schedulingProfile })\n    : relevantMatchUps;\n\n  const courtsData = courts?.map((court) => {\n    const matchUps = getCourtMatchUps(court);\n    return {\n      surfaceCategory: court?.surfaceCategory ?? '',\n      matchUps,\n      ...court,\n    };\n  });\n\n  const result: any = {\n    completedMatchUps: alwaysReturnCompleted ? allCompletedMatchUps : completedMatchUps, // completed matchUps for the filter date\n    dateMatchUps, // all incomplete matchUps for the filter date\n    courtsData,\n    groupInfo,\n    venues,\n  };\n\n  if (withCourtGridRows) {\n    const { rows, courtPrefix } = courtGridRows({\n      minRowsCount: minCourtGridRows,\n      courtsData,\n    });\n    result.courtPrefix = courtPrefix; // pass through for access to internal defaults by consumer\n    result.rows = rows;\n  }\n\n  return { ...result, ...SUCCESS };\n\n  function getCourtMatchUps({ courtId }) {\n    const matchUpsToConsider = courtCompletedMatchUps ? dateMatchUps.concat(completedMatchUps ?? []) : dateMatchUps;\n    const courtMatchUps = matchUpsToConsider.filter(\n      (matchUp) =>\n        matchUp.schedule?.courtId === courtId ||\n        matchUp.schedule?.allocatedCourts?.map(({ courtId }) => courtId).includes(courtId),\n    );\n\n    return sortCourtsData\n      ? scheduledSortedMatchUps({\n          matchUps: courtMatchUps,\n          schedulingProfile,\n        })\n      : courtMatchUps;\n  }\n}\n","import { getEventPublishStatus } from '../event/getEventPublishStatus';\nimport { getDrawPublishStatus } from '../event/getDrawPublishStatus';\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport { isObject } from '../../utilities/objects';\n\nexport function getCompetitionPublishedDrawDetails({\n  tournamentRecords,\n}: {\n  tournamentRecords: TournamentRecords;\n}) {\n  const drawIds: string[] = [];\n  const detailsMap: { [key: string]: any } = {};\n\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    for (const event of tournamentRecord.events ?? []) {\n      const eventPubStatus = getEventPublishStatus({ event });\n      const drawDetails = eventPubStatus?.drawDetails;\n\n      if (isObject(drawDetails)) {\n        Object.assign(detailsMap, drawDetails);\n        drawIds.push(\n          ...Object.keys(drawDetails).filter((drawId) =>\n            getDrawPublishStatus({ drawId, drawDetails })\n          )\n        );\n      } else if (eventPubStatus?.drawIds?.length) {\n        // LEGACY - deprecate\n        drawIds.push(...eventPubStatus.drawIds);\n      }\n    }\n  }\n\n  return { drawIds, detailsMap };\n}\n","import { getStructureLinks } from '../drawDefinition/linkGetter';\nimport { findStructure } from '../../acquire/findStructure';\nimport { DrawDefinition } from '../../types/tournamentTypes';\n\ntype GetSourceStructureDetailArgs = {\n  drawDefinition: DrawDefinition;\n  finishingPosition?: string;\n  targetRoundNumber: number;\n  structureId: string;\n  linkType: string;\n};\nexport function getSourceStructureIdsAndRelevantLinks({\n  targetRoundNumber,\n  finishingPosition,\n  drawDefinition,\n  structureId, // structure for which source and target links are to be found\n  linkType, // only return links which match linkType\n}: GetSourceStructureDetailArgs) {\n  const { links } =\n    getStructureLinks({\n      drawDefinition,\n      structureId,\n    }) || {};\n\n  const sourceLinks = (links?.target || [])\n    .filter(({ linkType: structureLinkType }) => structureLinkType === linkType)\n    // if a target roundNumber is provided, only consider structures with link target matching roundNumber\n    .filter(\n      ({ target }) =>\n        !targetRoundNumber || targetRoundNumber === target.roundNumber\n    );\n\n  const relevantLinks = sourceLinks\n    .map((link) => {\n      const sourceStructureId = link.source.structureId;\n      const { structure: sourceStructure } = findStructure({\n        structureId: sourceStructureId,\n        drawDefinition,\n      });\n\n      // if finishingPosition has been specified and does not match, ignore link\n      if (\n        finishingPosition &&\n        sourceStructure?.finishingPosition !== finishingPosition\n      )\n        return;\n      return link;\n    })\n    .filter(Boolean);\n\n  const sourceStructureIds = relevantLinks.map(\n    ({ source }) => source.structureId\n  );\n\n  return { sourceStructureIds, relevantLinks };\n}\n","export const QUALIFYING_PARTICIPANT_METHOD = 'qualifierDrawPositionAssignment';\nexport const WITHDRAW_PARTICIPANT_METHOD = 'withdrawParticipantAtDrawPosition';\nexport const ALTERNATE_PARTICIPANT_METHOD = 'alternateDrawPositionAssignment';\nexport const LUCKY_PARTICIPANT_METHOD = 'luckyLoserDrawPositionAssignment';\nexport const REMOVE_ASSIGNMENT_METHOD = 'removeDrawPositionAssignment';\nexport const SWAP_PARTICIPANT_METHOD = 'swapDrawPositionAssignments';\nexport const MODIFY_PAIR_ASSIGNMENT_METHOD = 'modifyPairAssignment';\nexport const ADD_NICKNAME_METHOD = 'modifyParticipantOtherName';\nexport const ASSIGN_PARTICIPANT_METHOD = 'assignDrawPosition';\nexport const REMOVE_SEED_METHOD = 'removeSeededParticipant';\nexport const ASSIGN_BYE_METHOD = 'assignDrawPositionBye';\nexport const SEED_VALUE_METHOD = 'modifySeedAssignment';\nexport const ADD_PENALTY_METHOD = 'addPenalty';\n\nexport const MODIFY_PAIR_ASSIGNMENT = 'MODIFY_PAIR';\nexport const QUALIFYING_PARTICIPANT = 'QUALIFIER';\nexport const ALTERNATE_PARTICIPANT = 'ALTERNATE';\nexport const WITHDRAW_PARTICIPANT = 'WITHDRAW';\nexport const ASSIGN_PARTICIPANT = 'ASSIGN';\nexport const REMOVE_ASSIGNMENT = 'REMOVE';\nexport const LUCKY_PARTICIPANT = 'LUCKY';\nexport const REMOVE_SEED = 'REMOVE_SEED';\nexport const SWAP_PARTICIPANTS = 'SWAP';\nexport const ADD_NICKNAME = 'NICKNAME';\nexport const SEED_VALUE = 'SEED_VALUE';\nexport const ADD_PENALTY = 'PENALTY';\nexport const ASSIGN_BYE = 'BYE';\n\nexport const positionActionConstants = {\n  MODIFY_PAIR_ASSIGNMENT,\n  QUALIFYING_PARTICIPANT,\n  ALTERNATE_PARTICIPANT,\n  WITHDRAW_PARTICIPANT,\n  ASSIGN_PARTICIPANT,\n  LUCKY_PARTICIPANT,\n  REMOVE_ASSIGNMENT,\n  SWAP_PARTICIPANTS,\n  ADD_NICKNAME,\n  REMOVE_SEED,\n  ADD_PENALTY,\n  ASSIGN_BYE,\n  SEED_VALUE,\n};\n\nexport default positionActionConstants;\n","import { definedAttributes } from '../../../utilities/definedAttributes';\nimport { getAllPositionedParticipantIds } from '../positionsGetter';\nimport { getFlightProfile } from '../../event/getFlightProfile';\nimport { unique } from '../../../utilities/arrays';\n\nimport { POLICY_TYPE_POSITION_ACTIONS } from '../../../constants/policyConstants';\nimport { PolicyDefinitions } from '../../../types/factoryTypes';\nimport {\n  CONSOLATION,\n  MAIN,\n  PLAY_OFF,\n  QUALIFYING,\n} from '../../../constants/drawDefinitionConstants';\nimport {\n  ALTERNATE_PARTICIPANT,\n  ALTERNATE_PARTICIPANT_METHOD,\n  ASSIGN_PARTICIPANT,\n} from '../../../constants/positionActionConstants';\nimport {\n  ALTERNATE,\n  UNGROUPED,\n  UNPAIRED,\n  WITHDRAWN,\n} from '../../../constants/entryStatusConstants';\nimport {\n  DrawDefinition,\n  Entry,\n  Event,\n  Participant,\n  PositionAssignment,\n  Structure,\n} from '../../../types/tournamentTypes';\n\ntype GetValidAlternatesActionArgs = {\n  positionAssignments: PositionAssignment[];\n  tournamentParticipants?: Participant[];\n  appliedPolicies?: PolicyDefinitions;\n  possiblyDisablingAction?: boolean;\n  activeDrawPositions: number[];\n  returnParticipants?: boolean;\n  drawDefinition: DrawDefinition;\n  drawPosition: number;\n  structureId?: string;\n  structure: Structure;\n  validActions: any[];\n  drawId: string;\n  event?: Event;\n};\n\nexport function getValidAlternatesAction({\n  tournamentParticipants = [],\n  possiblyDisablingAction,\n  activeDrawPositions,\n  positionAssignments,\n  returnParticipants,\n  appliedPolicies,\n  drawDefinition,\n  drawPosition,\n  validActions,\n  structureId,\n  structure,\n  drawId,\n  event,\n}: GetValidAlternatesActionArgs) {\n  if (activeDrawPositions.includes(drawPosition)) return {};\n\n  const validAssignmentParticipantIds = validActions.find(\n    (action) => action.type === ASSIGN_PARTICIPANT\n  )?.availableParticipantIds;\n\n  // TODO: document policy options\n  const otherFlightEntries =\n    appliedPolicies?.[POLICY_TYPE_POSITION_ACTIONS]?.otherFlightEntries;\n  const restrictQualifyingAlternates =\n    appliedPolicies?.[POLICY_TYPE_POSITION_ACTIONS]\n      ?.restrictQualifyingAlternates;\n\n  const drawEnteredParticipantIds = (drawDefinition.entries ?? [])\n    .filter(\n      ({ entryStage }) =>\n        !restrictQualifyingAlternates ||\n        (structure.stage === QUALIFYING\n          ? entryStage === QUALIFYING\n          : entryStage !== QUALIFYING)\n    )\n    .sort(\n      (a, b) => (a.entryPosition ?? Infinity) - (b.entryPosition ?? Infinity)\n    )\n    .map(({ participantId }) => participantId)\n    .filter(Boolean);\n\n  const { allPositionedParticipantIds } = getAllPositionedParticipantIds({\n    drawDefinition,\n  });\n\n  const assignedParticipantIds = positionAssignments\n    .map((assignment) => assignment.participantId)\n    .filter(Boolean);\n\n  const availableDrawEnteredParticipantIds = drawEnteredParticipantIds.filter(\n    (participantId) =>\n      structure.stage && [QUALIFYING, MAIN, PLAY_OFF].includes(structure.stage)\n        ? !allPositionedParticipantIds?.includes(participantId)\n        : !assignedParticipantIds.includes(participantId)\n  );\n\n  const eventEntries = event?.entries ?? [];\n  const availableEventAlternatesParticipantIds = eventEntries\n    .filter(\n      (entry) =>\n        entry.entryStatus === ALTERNATE &&\n        eligibleEntryStage({\n          restrictQualifyingAlternates,\n          structure,\n          entry,\n        }) &&\n        (structure.stage &&\n        [QUALIFYING, MAIN, PLAY_OFF].includes(structure.stage)\n          ? !allPositionedParticipantIds?.includes(entry.participantId)\n          : !assignedParticipantIds.includes(entry.participantId))\n    )\n    .sort(\n      (a, b) => (a.entryPosition ?? Infinity) - (b.entryPosition ?? Infinity)\n    )\n    .map((entry) => entry.participantId);\n\n  let availableAlternatesParticipantIds = unique(\n    availableDrawEnteredParticipantIds.concat(\n      availableEventAlternatesParticipantIds\n    )\n  );\n\n  if (otherFlightEntries) {\n    const flightProfile = event\n      ? getFlightProfile({ event }).flightProfile\n      : undefined;\n    const otherFlightEnteredParticipantIds = flightProfile?.flights\n      ?.filter((flight) => flight.drawId !== drawId)\n      .map((flight) =>\n        flight.drawEntries\n          .filter(\n            (entry) =>\n              entry.participantId &&\n              ![WITHDRAWN, UNGROUPED, UNPAIRED].includes(entry.entryStatus) &&\n              !drawEnteredParticipantIds.includes(entry.participantId)\n          )\n          .map(({ participantId }) => participantId)\n      )\n      .flat()\n      .filter(Boolean);\n\n    if (otherFlightEnteredParticipantIds?.length) {\n      // include direct acceptance participants from other flights\n      availableAlternatesParticipantIds.push(\n        ...otherFlightEnteredParticipantIds\n      );\n    }\n  }\n\n  // ensure that participantId is not available in multiple assignment options\n  if (validAssignmentParticipantIds?.length) {\n    availableAlternatesParticipantIds =\n      availableAlternatesParticipantIds.filter(\n        (id) => !validAssignmentParticipantIds.includes(id)\n      );\n  }\n\n  const availableAlternates = returnParticipants\n    ? tournamentParticipants?.filter((participant: Participant) =>\n        availableAlternatesParticipantIds.includes(participant.participantId)\n      )\n    : undefined;\n  availableAlternates?.forEach((alternate: any) => {\n    const entry = (drawDefinition.entries ?? []).find(\n      (entry: Entry) => entry.participantId === alternate.participantId\n    );\n    alternate.entryPosition = entry?.entryPosition;\n  });\n  availableAlternates?.sort(\n    (a: any, b: any) =>\n      (a.entryPosition || Infinity) - (b.entryPosition || Infinity)\n  );\n\n  if (availableAlternatesParticipantIds.length) {\n    const validAlternatesAction = definedAttributes({\n      payload: { drawId, structureId, drawPosition },\n      willDisableLinks: possiblyDisablingAction,\n      method: ALTERNATE_PARTICIPANT_METHOD,\n      availableAlternatesParticipantIds,\n      type: ALTERNATE_PARTICIPANT,\n      availableAlternates,\n    });\n    return { validAlternatesAction };\n  }\n\n  return {};\n}\n\ntype EligibleEntryStageArgs = {\n  restrictQualifyingAlternates?: boolean;\n  structure: Structure;\n  entry: Entry;\n};\nexport function eligibleEntryStage({\n  restrictQualifyingAlternates,\n  structure,\n  entry,\n}: EligibleEntryStageArgs) {\n  const { stage } = structure;\n  if (\n    !entry.entryStage ||\n    entry.entryStage === stage ||\n    (stage === QUALIFYING && !restrictQualifyingAlternates) ||\n    (entry.entryStage === MAIN && stage === CONSOLATION)\n  )\n    return true;\n  return undefined;\n}\n","import { definedAttributes } from '../../../utilities/definedAttributes';\nimport { xa } from '../../../utilities/objects';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { getDrawMatchUps } from '../../matchUps/drawMatchUps';\nimport { getNumericSeedValue } from '../getNumericSeedValue';\nimport { unique } from '../../../utilities/arrays';\nimport { getNextSeedBlock } from '../seedGetter';\n\nimport { PolicyDefinitions, SeedingProfile } from '../../../types/factoryTypes';\nimport { POLICY_TYPE_SEEDING } from '../../../constants/policyConstants';\nimport { HydratedParticipant } from '../../../types/hydrated';\nimport { TEAM } from '../../../constants/eventConstants';\nimport {\n  ASSIGN_BYE,\n  ASSIGN_BYE_METHOD,\n  ASSIGN_PARTICIPANT,\n  ASSIGN_PARTICIPANT_METHOD,\n} from '../../../constants/positionActionConstants';\nimport { DrawDefinition, Event, PositionAssignment } from '../../../types/tournamentTypes';\n\ntype GetValidAssignmentActionsArgs = {\n  tournamentParticipants?: HydratedParticipant[];\n  positionAssignments: PositionAssignment[];\n  positionSourceStructureIds: string[];\n  unassignedParticipantIds: string[];\n  appliedPolicies?: PolicyDefinitions;\n  possiblyDisablingAction?: boolean;\n  provisionalPositioning?: boolean;\n  isWinRatioFedStructure?: boolean;\n  seedingProfile?: SeedingProfile;\n  returnParticipants?: boolean;\n  drawDefinition: DrawDefinition;\n  isByePosition?: boolean;\n  drawPosition: number;\n  structureId: string;\n  event?: Event;\n};\nexport function getValidAssignmentActions({\n  positionSourceStructureIds,\n  unassignedParticipantIds,\n  possiblyDisablingAction,\n  provisionalPositioning,\n  tournamentParticipants,\n  isWinRatioFedStructure,\n  positionAssignments,\n  returnParticipants,\n  appliedPolicies,\n  drawDefinition,\n  seedingProfile,\n  isByePosition,\n  drawPosition,\n  structureId,\n  event,\n}: GetValidAssignmentActionsArgs) {\n  const { drawId } = drawDefinition;\n  const validAssignmentActions: any[] = [];\n\n  let unplacedSeedParticipantIds,\n    unplacedSeedAssignments,\n    unfilledPositions: number[] = [];\n\n  const ignoreSeedPositions = appliedPolicies?.[POLICY_TYPE_SEEDING]?.validSeedPositions?.ignore;\n\n  if (!ignoreSeedPositions) {\n    const result = getNextSeedBlock({\n      provisionalPositioning,\n      returnAllProxies: true,\n      randomize: true,\n      drawDefinition,\n      seedingProfile,\n      structureId,\n      event,\n    });\n    ({ unplacedSeedParticipantIds, unplacedSeedAssignments, unfilledPositions } = result);\n  }\n\n  // if there are no unfilledPositions for available seeds then return all unfilled positions\n  if (!unfilledPositions?.length) {\n    unfilledPositions = positionAssignments\n      .filter((assignment) => !assignment.participantId && !assignment.bye && !assignment.qualifier)\n      .map((assignment) => assignment.drawPosition);\n  }\n\n  if (!isByePosition) {\n    validAssignmentActions.push({\n      payload: { drawId, structureId, drawPosition, isPositionAction: true },\n      willDisableLinks: possiblyDisablingAction,\n      method: ASSIGN_BYE_METHOD,\n      type: ASSIGN_BYE,\n    });\n  }\n\n  if (isWinRatioFedStructure && ignoreSeedPositions) {\n    const assignedParticipantIds = positionAssignments.map((assignment) => assignment.participantId).filter(Boolean);\n\n    const matchUpFilters = { structureIds: positionSourceStructureIds };\n    const { completedMatchUps } = getDrawMatchUps({\n      inContext: true,\n      matchUpFilters,\n      drawDefinition,\n    });\n\n    const availableParticipantIds = unique(\n      (completedMatchUps ?? [])\n        // filter completedMatchUps to exclude SINGLES/DOUBLES for TEAM events\n        .filter(({ matchUpType }) => event?.eventType !== TEAM || matchUpType === TEAM)\n        ?.map(({ sides }) => sides?.map(xa('participantId')))\n        .flat()\n        .filter((participantId) => participantId && !assignedParticipantIds.includes(participantId)),\n    );\n\n    const participantsAvailable = returnParticipants\n      ? tournamentParticipants\n          ?.filter((participant) => availableParticipantIds?.includes(participant.participantId))\n          .map((participant) => makeDeepCopy(participant, undefined, true))\n      : undefined;\n\n    participantsAvailable?.forEach((participant) => {\n      const entry = (drawDefinition.entries ?? []).find((entry) => entry.participantId === participant.participantId);\n      // TODO: determine if this is in fact used downstream\n      participant.entryPosition = entry?.entryPosition;\n    });\n    if (participantsAvailable?.length) {\n      validAssignmentActions.push(\n        definedAttributes({\n          payload: { drawId, structureId, drawPosition },\n          willDisableLinks: possiblyDisablingAction,\n          method: ASSIGN_PARTICIPANT_METHOD,\n          type: ASSIGN_PARTICIPANT,\n          availableParticipantIds,\n          participantsAvailable,\n        }),\n      );\n    }\n    return { validAssignmentActions };\n  }\n\n  if (unfilledPositions.includes(drawPosition) || isByePosition) {\n    let availableParticipantIds;\n\n    if (unplacedSeedAssignments?.length) {\n      // return any valid seedAssignments\n      const validToAssign = unplacedSeedAssignments.filter(\n        (seedAssignment) => unplacedSeedParticipantIds?.includes(seedAssignment.participantId),\n      );\n\n      validToAssign.sort(validAssignmentsSort);\n      availableParticipantIds = validToAssign.map((assignment) => assignment.participantId);\n    } else {\n      // otherwise look for any unplaced entries\n      availableParticipantIds = unassignedParticipantIds;\n    }\n\n    // add structureId and drawPosition to the payload so the client doesn't need to discover\n    const participantsAvailable = returnParticipants\n      ? tournamentParticipants\n          ?.filter((participant) => availableParticipantIds.includes(participant.participantId))\n          .map((participant) => makeDeepCopy(participant, undefined, true))\n      : undefined;\n    if (participantsAvailable?.length) {\n      validAssignmentActions.push(\n        definedAttributes({\n          payload: { drawId, structureId, drawPosition },\n          willDisableLinks: possiblyDisablingAction,\n          method: ASSIGN_PARTICIPANT_METHOD,\n          type: ASSIGN_PARTICIPANT,\n          availableParticipantIds,\n          participantsAvailable,\n        }),\n      );\n    }\n  }\n\n  return { validAssignmentActions };\n}\n\nfunction validAssignmentsSort(a, b) {\n  if (a.bye) return -1;\n  if (getNumericSeedValue(a.seedValue) < getNumericSeedValue(b.seedValue) || (a.seedValue && !b.seedValue)) return -1;\n  return (a.seedNumber || 0) - (b.seedNumber || 0);\n}\n","import { getAllStructureMatchUps } from '../../matchUps/getAllStructureMatchUps';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { overlap } from '../../../utilities/arrays';\n\nimport { HydratedParticipant } from '../../../types/hydrated';\nimport {\n  SWAP_PARTICIPANTS,\n  SWAP_PARTICIPANT_METHOD,\n} from '../../../constants/positionActionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  PositionAssignment,\n  Structure,\n} from '../../../types/tournamentTypes';\n\ntype GetValidSwapActionArgs = {\n  tournamentParticipants?: HydratedParticipant[];\n  positionAssignments?: PositionAssignment[];\n  possiblyDisablingAction?: boolean;\n  inactiveDrawPositions?: number[];\n  onlyAssignedPositions?: boolean;\n  activeDrawPositions: number[];\n  returnParticipants?: boolean;\n  drawDefinition: DrawDefinition;\n  byeDrawPositions: number[];\n  isByePosition?: boolean;\n  drawPosition: number;\n  structure: Structure;\n  structureId: string;\n  drawId: string;\n  event?: Event;\n};\n\nexport function getValidSwapAction({\n  onlyAssignedPositions = true,\n  possiblyDisablingAction,\n  tournamentParticipants,\n  inactiveDrawPositions,\n  activeDrawPositions,\n  positionAssignments,\n  returnParticipants,\n  byeDrawPositions,\n  drawDefinition,\n  isByePosition,\n  drawPosition,\n  structureId,\n  structure,\n  drawId,\n  event,\n}: GetValidSwapActionArgs) {\n  if (activeDrawPositions.includes(drawPosition)) return {};\n\n  // assignmentCheck is used to filter out unassigned drawPositions\n  const assignmentCheck = (assignment) =>\n    !onlyAssignedPositions ||\n    assignment.participantId ||\n    assignment.qualifier ||\n    assignment.bye;\n\n  // availableDrawPositions filters out selectedDrawPosition\n  // and if selectedDrawPosition is a BYE it filters out other drawPositions which are assigned BYEs\n  const availableDrawPositions = inactiveDrawPositions?.filter(\n    (position) =>\n      position !== drawPosition &&\n      !(isByePosition && byeDrawPositions.includes(position))\n  );\n  // filteredAssignments are all assignements which are availble and pass assignmentCheck\n  const filteredAssignments =\n    positionAssignments?.filter(\n      (assignment) =>\n        assignmentCheck(assignment) &&\n        availableDrawPositions?.includes(assignment.drawPosition)\n    ) ?? [];\n\n  // get relevant drawPositions => relevantMatchUps => sides => sourceDrawPositionRanges\n  const filteredDrawPositions = filteredAssignments.map(\n    ({ drawPosition }) => drawPosition\n  );\n  const { matchUps } = getAllStructureMatchUps({\n    afterRecoveryTimes: false,\n    inContext: true,\n    drawDefinition,\n    structure,\n    event,\n  });\n  const relevantMatchUps = matchUps.filter(({ drawPositions }) =>\n    overlap(drawPositions, filteredDrawPositions)\n  );\n  const sourceDrawPositionRangeMap = Object.assign(\n    {},\n    ...relevantMatchUps\n      .map((matchUp) => {\n        return matchUp.sides\n          ?.filter(({ sourceDrawPositionRange }) => sourceDrawPositionRange)\n          .map(({ drawPosition, sourceDrawPositionRange }) => ({\n            [drawPosition]: sourceDrawPositionRange,\n          }));\n      })\n      .flat()\n  );\n\n  // availableAssignmentsMap is used to attach participant object to all filteredAssignments\n  // which have a participant assginment so the client/UI has all relevant drawPosition details\n  const availableParticipantIds = filteredAssignments\n    .map((assignment) => assignment.participantId)\n    .filter(Boolean);\n  const participantsAvailable = (tournamentParticipants ?? []).filter(\n    (participant) => availableParticipantIds.includes(participant.participantId)\n  );\n  const availableParticipantsMap = Object.assign(\n    {},\n    ...participantsAvailable.map((participant) => ({\n      [participant.participantId]: participant,\n    }))\n  );\n\n  const availableAssignments = filteredAssignments.map((assignment: any) => {\n    const participant = availableParticipantsMap?.[assignment.participantId];\n\n    const sourceDrawPositionRange =\n      sourceDrawPositionRangeMap[assignment.drawPosition];\n\n    return definedAttributes({\n      ...assignment,\n      participant: returnParticipants\n        ? makeDeepCopy(participant, false, true)\n        : undefined,\n      sourceDrawPositionRange,\n    });\n  });\n\n  if (availableAssignments.length) {\n    const validSwapAction = {\n      payload: { drawId, structureId, drawPositions: [drawPosition] },\n      willDisableLinks: possiblyDisablingAction,\n      method: SWAP_PARTICIPANT_METHOD,\n      type: SWAP_PARTICIPANTS,\n      availableAssignments,\n    };\n    return { validSwapAction };\n  }\n\n  return {};\n}\n","import { POLICY_TYPE_POSITION_ACTIONS } from '../../constants/policyConstants';\nimport { MAIN, QUALIFYING } from '../../constants/drawDefinitionConstants';\nimport {\n  ADD_NICKNAME,\n  ADD_PENALTY,\n  QUALIFYING_PARTICIPANT,\n  SEED_VALUE,\n} from '../../constants/positionActionConstants';\n\nexport const POLICY_POSITION_ACTIONS_DEFAULT = {\n  [POLICY_TYPE_POSITION_ACTIONS]: {\n    policyName: 'positionActionsDefault',\n\n    // positionActions will be selectively enabled for structures matching { stages: [], stageSequences: [] }\n    // enabledStructures: [] => all structures are enabled\n    enabledStructures: [\n      {\n        stages: [QUALIFYING, MAIN], // stages to which this policy applies\n        stageSequences: [1], // stageSequences to which this policy applies\n        enabledActions: [], // enabledActions: [] => all actions are enabled\n        disabledActions: [], // disabledActions: [] => no actions are disabled\n      },\n      {\n        stages: [], // stages: [] => applies to all stages\n        stageSequences: [], // stageSequences: [] => applies to all stageSequences\n        enabledActions: [\n          ADD_NICKNAME,\n          ADD_PENALTY,\n          QUALIFYING_PARTICIPANT,\n          SEED_VALUE,\n        ],\n        disabledActions: [], // disabledActions: [] => no actions are disabled\n      },\n    ],\n\n    // positionActions will be completely disabled for any structures matching { stages: [], stageSequences: [] }\n    // disabledStructures: [] => no structures are disabled\n    disbledStructures: [],\n\n    // enables entries in other flights to be accessed as alternates\n    otherFlightEntries: false,\n\n    // enable specific actions even when there are active positions\n    activePositionOverrides: [],\n  },\n};\n\nexport default POLICY_POSITION_ACTIONS_DEFAULT;\n","import { POLICY_POSITION_ACTIONS_DEFAULT } from '../../../fixtures/policies/POLICY_POSITION_ACTIONS_DEFAULT';\nimport { POLICY_MATCHUP_ACTIONS_DEFAULT } from '../../../fixtures/policies/POLICY_MATCHUP_ACTIONS_DEFAULT';\nimport { PolicyDefinitions } from '../../../types/factoryTypes';\nimport {\n  POLICY_TYPE_POSITION_ACTIONS,\n  POLICY_TYPE_MATCHUP_ACTIONS,\n} from '../../../constants/policyConstants';\nimport { DrawDefinition, Structure } from '../../../types/tournamentTypes';\n\nexport const POSITION_ACTION = 'positionAction';\nexport const MATCHUP_ACTION = 'matchUpAction';\n\ntype GetEnabledStructuresArgs = {\n  appliedPolicies?: PolicyDefinitions;\n  drawDefinition: DrawDefinition;\n  structure?: Structure;\n  actionType?: string;\n};\nexport function getEnabledStructures({\n  actionType = POSITION_ACTION,\n  appliedPolicies,\n  drawDefinition,\n  structure,\n}: GetEnabledStructuresArgs) {\n  const policyType =\n    (actionType === POSITION_ACTION && POLICY_TYPE_POSITION_ACTIONS) ||\n    (actionType === MATCHUP_ACTION && POLICY_TYPE_MATCHUP_ACTIONS);\n\n  const defaultPolicy =\n    (actionType === POSITION_ACTION && POLICY_POSITION_ACTIONS_DEFAULT) ||\n    (actionType === MATCHUP_ACTION && POLICY_MATCHUP_ACTIONS_DEFAULT);\n\n  const actionsPolicy =\n    policyType &&\n    (appliedPolicies?.[policyType] || defaultPolicy?.[policyType]);\n\n  const relevantLinks = drawDefinition.links?.filter(\n    (link) => link?.target?.structureId === structure?.structureId\n  );\n  const targetFeedProfiles =\n    relevantLinks?.map(({ target }) => target.feedProfile) ?? [];\n\n  const { enabledStructures, disabledStructures } = actionsPolicy || {};\n  const actionsDisabled = disabledStructures?.find((structurePolicy) => {\n    const { stages, stageSequences, structureTypes, feedProfiles } =\n      structurePolicy;\n    return (\n      (!feedProfiles?.length ||\n        (Array.isArray(feedProfiles) &&\n          feedProfiles.some((feedProfile) =>\n            targetFeedProfiles.includes(feedProfile)\n          ))) &&\n      (!stages?.length ||\n        (Array.isArray(stages) && stages?.includes(structure?.stage))) &&\n      (!structureTypes?.length ||\n        (Array.isArray(structureTypes) &&\n          structureTypes?.includes(structure?.structureType))) &&\n      (!stageSequences?.length ||\n        (Array.isArray(stageSequences) &&\n          stageSequences.includes(structure?.stageSequence)))\n    );\n  });\n\n  return { enabledStructures, actionsDisabled, actionsPolicy };\n}\n\nexport function activePositionsCheck({\n  activePositionOverrides,\n  activeDrawPositions,\n  action,\n}) {\n  if (action && activePositionOverrides.includes(action)) return true;\n  return !activeDrawPositions.length;\n}\n\nexport function getPolicyActions({\n  enabledStructures,\n  drawDefinition,\n  structure,\n}) {\n  if (enabledStructures === false) return {};\n\n  if (!enabledStructures?.length)\n    return { policyActions: { enabledActions: [], disabledActions: [] } };\n\n  const { stage, stageSequence, structureType } = structure || {};\n\n  const relevantLinks = drawDefinition.links?.filter(\n    (link) => link?.target?.structureId === structure?.structureId\n  );\n  const targetFeedProfiles =\n    relevantLinks?.map(({ target }) => target.feedProfile) || [];\n\n  const policyActions = enabledStructures.find((structurePolicy) => {\n    const { stages, stageSequences, structureTypes, feedProfiles } =\n      structurePolicy || {};\n\n    const matchesStage =\n      !stages?.length || (Array.isArray(stages) && stages.includes(stage));\n    const matchesStageSequence =\n      !stageSequences?.length ||\n      (Array.isArray(stageSequences) && stageSequences.includes(stageSequence));\n    const matchesStructureType =\n      !structureTypes?.length ||\n      (Array.isArray(structureTypes) && structureTypes.includes(structureType));\n    const matchesFeedProfile =\n      !feedProfiles?.length ||\n      (Array.isArray(feedProfiles) &&\n        feedProfiles.some((feedProfile) =>\n          targetFeedProfiles.includes(feedProfile)\n        ));\n    return (\n      matchesStageSequence &&\n      matchesStructureType &&\n      matchesFeedProfile &&\n      structurePolicy &&\n      matchesStage\n    );\n  });\n\n  return { policyActions };\n}\n\nexport function isAvailableAction({ action, policyActions }) {\n  const disabled =\n    !policyActions?.enabledActions ||\n    (policyActions?.disabledActions?.length &&\n      policyActions.disabledActions.includes(action));\n  if (disabled) return false;\n\n  const enabled =\n    policyActions?.enabledActions.length === 0 ||\n    policyActions?.enabledActions.includes(action);\n\n  return enabled && !disabled;\n}\n","export const REPLACE_TEAM_POSITION_METHOD = 'replaceTieMatchUpParticipantId';\nexport const ASSIGN_TEAM_POSITION_METHOD = 'assignTieMatchUpParticipantId';\nexport const REMOVE_TEAM_POSITION_METHOD = 'removeTieMatchUpParticipantId';\nexport const ASSIGN_SIDE_METHOD = 'assignMatchUpSideParticipant';\nexport const REMOVE_SIDE_METHOD = 'removeMatchUpSideParticipant';\nexport const SUBSTITUTION_METHOD = 'substituteParticipant';\nexport const REMOVE_SUBSTITUTION = 'REMOVE_SUBSTITUTION';\nexport const REPLACE_PARTICIPANT = 'REPLACE_PARTICIPANT';\nexport const REMOVE_PARTICIPANT = 'REMOVE_PARTICIPANT';\nexport const SCHEDULE_METHOD = 'setMatchUpStatus';\nexport const SUBSTITUTION = 'SUBSTITUTION';\nexport const SCHEDULE = 'SCHEDULE';\nexport const PENALTY = 'PENALTY';\nexport const REFEREE = 'REFEREE';\nexport const STATUS = 'STATUS';\nexport const START = 'START';\nexport const SCORE = 'SCORE';\nexport const END = 'END';\n\nexport const matchUpActionConstants = {\n  REPLACE_TEAM_POSITION_METHOD,\n  ASSIGN_TEAM_POSITION_METHOD,\n  REMOVE_TEAM_POSITION_METHOD,\n  REPLACE_PARTICIPANT,\n  SUBSTITUTION_METHOD,\n  REMOVE_SUBSTITUTION,\n  REMOVE_PARTICIPANT,\n  SCHEDULE_METHOD,\n  SUBSTITUTION,\n  SCHEDULE,\n  PENALTY,\n  REFEREE,\n  STATUS,\n  SCORE,\n  START,\n  END,\n};\n\nexport default matchUpActionConstants;\n","import { getEventAlternateParticipantIds } from './getEventAlternateParticipantids';\nimport { checkScoreHasValue } from '../../matchUp/checkScoreHasValue';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { getFlightProfile } from '../../event/getFlightProfile';\nimport { unique } from '../../../utilities/arrays';\nimport { xa } from '../../../utilities/objects';\n\nimport { ASSIGN_SIDE_METHOD, REMOVE_PARTICIPANT, REMOVE_SIDE_METHOD } from '../../../constants/matchUpActionConstants';\nimport { ASSIGN_PARTICIPANT } from '../../../constants/positionActionConstants';\nimport { HydratedParticipant } from '../../../types/hydrated';\nimport {\n  ALTERNATE,\n  DIRECT_ENTRY_STATUSES,\n  UNGROUPED,\n  UNPAIRED,\n  WITHDRAWN,\n} from '../../../constants/entryStatusConstants';\n\nexport function adHocMatchUpActions({\n  restrictAdHocRoundParticipants,\n  tournamentParticipants,\n  matchUpParticipantIds,\n  otherFlightEntries,\n  drawDefinition,\n  structureId,\n  sideNumber,\n  matchUpId,\n  structure,\n  matchUp,\n  drawId,\n  event,\n}: {\n  restrictAdHocRoundParticipants?: boolean;\n  tournamentParticipants?: HydratedParticipant[];\n  matchUpParticipantIds: string[];\n  otherFlightEntries?: boolean;\n  structureId: string;\n  sideNumber?: number;\n  drawDefinition: any;\n  matchUpId: string;\n  drawId: string;\n  structure: any;\n  matchUp: any;\n  event: any;\n}) {\n  const validActions: any = [];\n\n  const roundMatchUps = (structure?.matchUps ?? []).filter(({ roundNumber }) => roundNumber === matchUp.roundNumber);\n  const enteredParticipantIds =\n    drawDefinition?.entries\n      ?.filter(({ entryStatus }) => entryStatus && DIRECT_ENTRY_STATUSES.includes(entryStatus))\n      .map(xa('participantId')) ?? [];\n\n  const roundAssignedParticipantIds = roundMatchUps\n    .map((matchUp) => (matchUp.sides ?? []).flatMap(xa('participantId')))\n    .flat()\n    .filter(Boolean);\n\n  const availableParticipantIds = enteredParticipantIds.filter(\n    (participantId) =>\n      !matchUpParticipantIds.includes(participantId) &&\n      (!restrictAdHocRoundParticipants || !roundAssignedParticipantIds.includes(participantId)),\n  );\n\n  const participantsAvailable = tournamentParticipants\n    ?.filter((participant) => availableParticipantIds?.includes(participant.participantId))\n    .map((participant) => makeDeepCopy(participant, undefined, true));\n\n  participantsAvailable?.forEach((participant: HydratedParticipant) => {\n    const entry = (drawDefinition.entries ?? []).find((entry) => entry.participantId === participant.participantId);\n    // used to sort available participants\n    participant.entryPosition = entry?.entryPosition;\n  });\n\n  if (availableParticipantIds.length) {\n    validActions.push({\n      payload: { drawId, matchUpId, structureId, sideNumber },\n      method: ASSIGN_SIDE_METHOD,\n      type: ASSIGN_PARTICIPANT,\n      availableParticipantIds,\n      participantsAvailable,\n    });\n  }\n\n  const eventEntries = event?.entries ?? [];\n  const availableEventAlternatesParticipantIds = getEventAlternateParticipantIds({ eventEntries, structure });\n\n  let availableAlternatesParticipantIds = unique(enteredParticipantIds.concat(availableEventAlternatesParticipantIds));\n\n  if (otherFlightEntries) {\n    const flightProfile: any = event ? getFlightProfile({ event }) : undefined;\n    const otherFlightEnteredParticipantIds = flightProfile?.flights\n      ?.filter((flight) => flight.drawId !== drawId)\n      .flatMap((flight) =>\n        flight.drawEntries\n          .filter((entry) => entry.participantId && ![WITHDRAWN, UNGROUPED, UNPAIRED].includes(entry.entryStatus))\n          .map(({ participantId }) => participantId),\n      )\n      .filter(Boolean);\n\n    if (otherFlightEnteredParticipantIds?.length) {\n      // include direct acceptance participants from other flights\n      availableAlternatesParticipantIds.push(...otherFlightEnteredParticipantIds);\n    }\n  }\n\n  availableAlternatesParticipantIds = availableAlternatesParticipantIds.filter(\n    (participantId) =>\n      !matchUpParticipantIds.includes(participantId) &&\n      !availableParticipantIds.includes(participantId) &&\n      (!restrictAdHocRoundParticipants || !roundAssignedParticipantIds.includes(participantId)),\n  );\n\n  const availableAlternates = tournamentParticipants\n    ?.filter((participant) => availableAlternatesParticipantIds.includes(participant.participantId))\n    .map((participant) => makeDeepCopy(participant, undefined, true));\n  availableAlternates?.forEach((alternate: HydratedParticipant) => {\n    const entry = (drawDefinition.entries ?? []).find((entry) => entry.participantId === alternate.participantId);\n    alternate.entryPosition = entry?.entryPosition;\n  });\n  availableAlternates?.sort((a, b) => (a.entryPosition || Infinity) - (b.entryPosition || Infinity));\n\n  if (availableAlternatesParticipantIds.length) {\n    validActions.push({\n      payload: { drawId, matchUpId, structureId, sideNumber },\n      availableParticipantIds: availableAlternatesParticipantIds,\n      participantsAvailable: availableAlternates,\n      method: ASSIGN_SIDE_METHOD,\n      type: ALTERNATE,\n    });\n  }\n\n  if (!checkScoreHasValue(matchUp) && sideNumber) {\n    const side = matchUp.sides?.find((side) => side.sideNumber === sideNumber);\n    if (side?.participantId) {\n      validActions.push({\n        payload: { drawId, matchUpId, structureId, sideNumber },\n        method: REMOVE_SIDE_METHOD,\n        type: REMOVE_PARTICIPANT,\n      });\n    }\n  }\n\n  return validActions;\n}\n","import { eligibleEntryStage } from '../positionActions/getValidAlternatesAction';\nimport { xa } from '../../../utilities/objects';\n\nimport { ALTERNATE } from '../../../constants/entryStatusConstants';\n\nexport function getEventAlternateParticipantIds({ eventEntries, structure }) {\n  const eligibleAlternate = (entry) => entry.entryStatus === ALTERNATE && eligibleEntryStage({ structure, entry });\n  const entryPositionSort = (a, b) => (a.entryPosition || Infinity) - (b.entryPosition || Infinity);\n\n  return eventEntries.filter(eligibleAlternate).sort(entryPositionSort).map(xa('participantId'));\n}\n","import { isDirectingMatchUpStatus } from '../../../mutate/drawDefinitions/matchUpGovernor/checkStatusType';\nimport { isActiveDownstream } from '../../../mutate/drawDefinitions/matchUpGovernor/isActiveDownstream';\nimport { positionTargets } from '../../../mutate/matchUps/drawPositions/positionTargets';\nimport { allTournamentMatchUps } from '../../matchUps/getAllTournamentMatchUps';\nimport { getMatchUpsMap, MatchUpsMap } from '../../matchUps/getMatchUpsMap';\nimport { getAppliedPolicies } from '../../extensions/getAppliedPolicies';\nimport { collectionMatchUpActions } from './collectionMatchUpActions';\nimport { getParticipants } from '../../participants/getParticipants';\nimport { structureAssignedDrawPositions } from '../positionsGetter';\nimport { getAllDrawMatchUps } from '../../matchUps/drawMatchUps';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { adHocMatchUpActions } from './adHocMatchUpActions';\nimport { isCompletedStructure } from '../structureActions';\nimport { isString } from '../../../utilities/objects';\nimport { isAdHoc } from '../isAdHoc';\nimport {\n  getEnabledStructures,\n  getPolicyActions,\n  isAvailableAction,\n  MATCHUP_ACTION,\n} from '../positionActions/actionPolicyUtils';\n\nimport { POLICY_TYPE_MATCHUP_ACTIONS, POLICY_TYPE_POSITION_ACTIONS } from '../../../constants/policyConstants';\nimport POLICY_MATCHUP_ACTIONS_DEFAULT from '../../../fixtures/policies/POLICY_MATCHUP_ACTIONS_DEFAULT';\nimport { BYE, DOUBLE_DEFAULT, DOUBLE_WALKOVER } from '../../../constants/matchUpStatusConstants';\nimport { DrawDefinition, Event, Participant, Tournament } from '../../../types/tournamentTypes';\nimport { ADD_PENALTY, ADD_PENALTY_METHOD } from '../../../constants/positionActionConstants';\nimport { decorateResult, ResultType } from '../../../global/functions/decorateResult';\nimport { PolicyDefinitions, TournamentRecords } from '../../../types/factoryTypes';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  INVALID_VALUES,\n  MATCHUP_NOT_FOUND,\n  MISSING_DRAW_DEFINITION,\n  MISSING_MATCHUP_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../../constants/errorConditionConstants';\nimport {\n  END,\n  REFEREE,\n  SCHEDULE,\n  SCHEDULE_METHOD,\n  SCORE,\n  START,\n  STATUS,\n} from '../../../constants/matchUpActionConstants';\n\ntype MatchUpActionsArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  restrictAdHocRoundParticipants?: boolean;\n  tournamentParticipants?: Participant[];\n  tournamentRecords?: TournamentRecords;\n  policyDefinitions?: PolicyDefinitions;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  enforceGender?: boolean;\n  participantId?: string;\n  tournamentId?: string;\n  sideNumber?: number;\n  matchUpId?: string;\n  eventId?: string;\n  drawId?: string;\n  event?: Event;\n};\nexport function matchUpActions(params?: MatchUpActionsArgs): ResultType & {\n  structureIsComplete?: boolean;\n  isDoubleExit?: boolean;\n  isByeMatchUp?: boolean;\n  validActions?: any[];\n} {\n  if (!params) return { error: INVALID_VALUES };\n  let drawDefinition, event;\n  const {\n    restrictAdHocRoundParticipants = true, // disallow the same participant being in the same round multiple times\n    policyDefinitions: specifiedPolicyDefinitions,\n    enforceGender,\n    participantId,\n    sideNumber,\n    matchUpId,\n  } = params;\n\n  const tournamentRecord =\n    params.tournamentRecord ??\n    (params.tournamentId && isString(params.tournamentId) && params.tournamentRecords?.[params.tournamentId]);\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  if (!matchUpId || !isString(matchUpId)) return { error: MISSING_MATCHUP_ID };\n\n  if (sideNumber && ![1, 2].includes(sideNumber))\n    return decorateResult({\n      result: { error: INVALID_VALUES },\n      context: { sideNumber },\n    });\n\n  if (!drawDefinition) {\n    // if matchUp did not have context, find drawId by brute force\n    const matchUps = allTournamentMatchUps({ tournamentRecord }).matchUps ?? [];\n    const matchUp = matchUps.find((matchUp) => matchUp.matchUpId === matchUpId);\n    event = (tournamentRecord?.events ?? []).find((event) => event.eventId === matchUp?.eventId);\n    drawDefinition = (event?.drawDefinitions ?? []).find((drawDefinition) => drawDefinition.drawId === matchUp?.drawId);\n  }\n\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const tournamentParticipants = getParticipants({\n    tournamentRecord,\n    withIndividualParticipants: true,\n  }).participants;\n\n  const { drawId } = drawDefinition;\n  const { matchUp, structure } = findDrawMatchUp({\n    drawDefinition,\n    matchUpId,\n    event,\n  });\n\n  if (!matchUp) return { error: MATCHUP_NOT_FOUND };\n\n  const appliedPolicies =\n    getAppliedPolicies({\n      tournamentRecord,\n      drawDefinition,\n      structure,\n      event,\n    }).appliedPolicies ?? {};\n\n  Object.assign(appliedPolicies, specifiedPolicyDefinitions ?? {});\n\n  const otherFlightEntries = appliedPolicies?.[POLICY_TYPE_POSITION_ACTIONS]?.otherFlightEntries;\n\n  const matchUpActionsPolicy =\n    appliedPolicies?.[POLICY_TYPE_MATCHUP_ACTIONS] ?? POLICY_MATCHUP_ACTIONS_DEFAULT[POLICY_TYPE_MATCHUP_ACTIONS];\n\n  const { enabledStructures } = getEnabledStructures({\n    actionType: MATCHUP_ACTION,\n    appliedPolicies,\n    drawDefinition,\n    structure,\n  });\n\n  const { policyActions } = getPolicyActions({\n    enabledStructures,\n    drawDefinition,\n    structure,\n  });\n\n  const matchUpsMap = params.matchUpsMap ?? getMatchUpsMap({ drawDefinition });\n\n  const inContextDrawMatchUps =\n    params.inContextDrawMatchUps ??\n    getAllDrawMatchUps({\n      tournamentParticipants,\n      inContext: true,\n      drawDefinition,\n      matchUpsMap,\n      event,\n    }).matchUps;\n\n  const inContextMatchUp = inContextDrawMatchUps?.find((drawMatchUp) => drawMatchUp.matchUpId === matchUpId);\n\n  const side: any = sideNumber && inContextMatchUp?.sides?.find((side) => side.sideNumber === sideNumber);\n\n  const matchUpParticipantIds =\n    inContextMatchUp?.sides\n      ?.map((side: any) => side.participantId || side.participant?.participantid)\n      .filter(Boolean) ?? [];\n\n  const { assignedPositions, allPositionsAssigned } = structureAssignedDrawPositions({ structure });\n  const { structureId } = structure ?? {};\n\n  const validActions: any[] = [];\n  if (!structureId) return { validActions };\n\n  const isAdHocMatchUp = isAdHoc({ drawDefinition, structure });\n  const isCollectionMatchUp = matchUp.collectionId;\n\n  if (isAdHocMatchUp && !isCollectionMatchUp) {\n    const adHocValidActions = adHocMatchUpActions({\n      restrictAdHocRoundParticipants,\n      tournamentParticipants,\n      matchUpParticipantIds,\n      otherFlightEntries,\n      drawDefinition,\n      structureId,\n      sideNumber,\n      matchUpId,\n      structure,\n      matchUp,\n      drawId,\n      event,\n    });\n    validActions.push(...adHocValidActions);\n  }\n\n  const structureIsComplete = isCompletedStructure({\n    drawDefinition,\n    structure,\n  });\n\n  const participantAssignedDrawPositions = assignedPositions\n    ?.filter((assignment) => assignment.participantId)\n    .map((assignment) => assignment.drawPosition);\n\n  const byeAssignedDrawPositions = assignedPositions\n    ?.filter((assignment) => assignment.bye)\n    .map((assignment) => assignment.drawPosition);\n\n  const isByeMatchUp =\n    matchUp.matchUpStatus === BYE ||\n    (!isCollectionMatchUp &&\n      matchUp.drawPositions?.reduce((isByeMatchUp, drawPosition) => {\n        return byeAssignedDrawPositions?.includes(drawPosition) || isByeMatchUp;\n      }, false));\n\n  if (isByeMatchUp) return { validActions, isByeMatchUp };\n\n  // TODO: implement method action and pass participants whose role is REFEREE\n  if (isAvailableAction({ policyActions, action: REFEREE })) {\n    validActions.push({ type: REFEREE, payload: { matchUpId } });\n  }\n\n  const isInComplete = !isDirectingMatchUpStatus({\n    matchUpStatus: matchUp.matchUpStatus,\n  });\n\n  const structureScoringPolicies = appliedPolicies?.scoring?.structures;\n  const stageSpecificPolicies =\n    structure?.stage && structureScoringPolicies?.stage && structureScoringPolicies?.stage[structure.stage];\n  const sequenceSpecificPolicies =\n    structure?.stageSequence &&\n    stageSpecificPolicies?.stageSequence &&\n    stageSpecificPolicies.stageSequence[structure.stageSequence];\n  const requireAllPositionsAssigned =\n    appliedPolicies?.scoring?.requireAllPositionsAssigned ||\n    stageSpecificPolicies?.requireAllPositionsAssigned ||\n    sequenceSpecificPolicies?.requireAllPositionsAssigned;\n  const scoringActive = !requireAllPositionsAssigned || allPositionsAssigned;\n\n  const hasParticipants = matchUp.sides && matchUp.sides.filter((side) => side?.participantId).length === 2;\n\n  const isDoubleExit = matchUp.matchUpStatus && [DOUBLE_WALKOVER, DOUBLE_DEFAULT].includes(matchUp.matchUpStatus);\n\n  const targetData = positionTargets({\n    inContextDrawMatchUps,\n    drawDefinition,\n    matchUpId,\n  });\n  const activeDownstream = isActiveDownstream({\n    inContextDrawMatchUps,\n    drawDefinition,\n    targetData,\n  });\n\n  const matchUpDrawPositionsAreAssigned =\n    inContextMatchUp?.drawPositions?.length === 2 &&\n    inContextMatchUp.drawPositions.every((drawPosition) => participantAssignedDrawPositions?.includes(drawPosition)) &&\n    inContextMatchUp?.sides?.length === 2 &&\n    inContextMatchUp.sides.every(({ participantId }) => participantId);\n\n  const readyToScore = (matchUpDrawPositionsAreAssigned || hasParticipants) && !(isDoubleExit && activeDownstream);\n\n  const addPenaltyAction = {\n    method: ADD_PENALTY_METHOD,\n    type: ADD_PENALTY,\n    payload: {\n      drawId,\n      matchUpId,\n      penaltyCode: undefined,\n      penaltyType: undefined,\n      participantIds: [],\n      notes: undefined,\n    },\n  };\n  if (isInComplete) {\n    validActions.push({\n      payload: { drawId, matchUpId, schedule: {} },\n      method: SCHEDULE_METHOD,\n      type: SCHEDULE,\n    });\n  }\n\n  if (\n    isAvailableAction({ policyActions, action: ADD_PENALTY }) &&\n    (side?.participant || (!sideNumber && matchUpParticipantIds?.length))\n  ) {\n    validActions.push(addPenaltyAction);\n  }\n\n  if (isInComplete && readyToScore) validActions.push({ type: STATUS });\n\n  if (scoringActive && readyToScore) {\n    const { matchUpId, matchUpFormat } = matchUp;\n    const payload = {\n      drawId,\n      matchUpId,\n      matchUpFormat,\n      outcome: {\n        scoreStringSide1: undefined,\n        scoreStringSide2: undefined,\n        sets: [],\n      },\n      winningSide: undefined,\n    };\n    validActions.push({\n      info: 'set outcome and winningSide',\n      method: SCHEDULE_METHOD, // setMatchUpStatus\n      type: SCORE,\n      payload,\n    });\n\n    if (isAvailableAction({ policyActions, action: START })) {\n      validActions.push({ type: START });\n    }\n    if (isAvailableAction({ policyActions, action: END })) {\n      validActions.push({ type: END });\n    }\n  }\n\n  if (isCollectionMatchUp && inContextMatchUp) {\n    const collectionValidActions = collectionMatchUpActions({\n      specifiedPolicyDefinitions,\n      inContextDrawMatchUps,\n      matchUpParticipantIds,\n      matchUpActionsPolicy,\n      inContextMatchUp,\n      policyActions,\n      enforceGender,\n      participantId,\n      sideNumber,\n      matchUpId,\n      matchUp,\n      drawId,\n      side,\n    });\n    validActions.push(...collectionValidActions);\n  }\n\n  return {\n    structureIsComplete,\n    validActions,\n    isDoubleExit,\n  };\n}\n","import { isAvailableAction } from '../positionActions/actionPolicyUtils';\nimport { getParticipantId } from '../../../global/functions/extractors';\nimport { checkScoreHasValue } from '../../matchUp/checkScoreHasValue';\nimport { xa } from '../../../utilities/objects';\n\nimport { completedMatchUpStatuses } from '../../../constants/matchUpStatusConstants';\nimport { DOUBLES_MATCHUP, SINGLES_MATCHUP } from '../../../constants/matchUpTypes';\nimport { POLICY_TYPE_MATCHUP_ACTIONS } from '../../../constants/policyConstants';\nimport { ASSIGN_PARTICIPANT } from '../../../constants/positionActionConstants';\nimport { INDIVIDUAL, PAIR } from '../../../constants/participantConstants';\nimport { HydratedMatchUp, HydratedSide } from '../../../types/hydrated';\nimport { ANY, MIXED } from '../../../constants/genderConstants';\nimport { PolicyDefinitions } from '../../../types/factoryTypes';\nimport { MatchUp } from '../../../types/tournamentTypes';\nimport {\n  ASSIGN_TEAM_POSITION_METHOD,\n  REMOVE_PARTICIPANT,\n  REMOVE_SUBSTITUTION,\n  REMOVE_TEAM_POSITION_METHOD,\n  REPLACE_PARTICIPANT,\n  REPLACE_TEAM_POSITION_METHOD,\n  SUBSTITUTION,\n  SUBSTITUTION_METHOD,\n} from '../../../constants/matchUpActionConstants';\n\nexport function collectionMatchUpActions({\n  specifiedPolicyDefinitions,\n  inContextDrawMatchUps,\n  matchUpParticipantIds,\n  matchUpActionsPolicy,\n  inContextMatchUp,\n  policyActions,\n  enforceGender,\n  participantId,\n  sideNumber,\n  matchUpId,\n  matchUp,\n  drawId,\n  side,\n}: {\n  specifiedPolicyDefinitions?: PolicyDefinitions;\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  inContextMatchUp: HydratedMatchUp;\n  matchUpParticipantIds: string[];\n  matchUpActionsPolicy: any;\n  enforceGender?: boolean;\n  participantId?: string;\n  sideNumber?: number;\n  side: HydratedSide;\n  policyActions: any;\n  matchUpId: string;\n  matchUp: MatchUp;\n  drawId: string;\n}) {\n  const validActions: any = [];\n  const firstFoundSide: any = inContextMatchUp.sides?.find((side: any) => side.participant);\n  const assignedGender =\n    inContextMatchUp.gender === MIXED &&\n    inContextMatchUp.sideNumber &&\n    inContextMatchUp.sides?.filter((side: any) => side.particiapntId).length === 1 &&\n    firstFoundSide?.participant?.person?.sex;\n  const matchUpType = inContextMatchUp.matchUpType;\n  const genderEnforced = (enforceGender ?? matchUpActionsPolicy?.participants?.enforceGender) !== false;\n\n  const gender = genderEnforced ? inContextMatchUp.gender : undefined;\n\n  const allParticipants = inContextMatchUp.sides\n    ?.flatMap((side: any) => side.participant?.individualParticipants || side.participant)\n    .filter(Boolean);\n  const allParticipantIds = allParticipants?.map(xa('participantId'));\n\n  const existingParticipants = inContextMatchUp.sides\n    ?.filter((side) => !sideNumber || side.sideNumber === sideNumber)\n    .flatMap((side: any) => side.participant?.individualParticipants || side.participant)\n    .filter(Boolean);\n  const existingParticipantIds = existingParticipants?.map(xa('participantId'));\n\n  const inContextDualMatchUp = inContextDrawMatchUps?.find(\n    (drawMatchUp) => drawMatchUp.matchUpId === inContextMatchUp.matchUpTieId,\n  );\n  const availableIndividualParticipants = inContextDualMatchUp?.sides?.map(\n    (side: any) =>\n      side.participant?.individualParticipants.filter(\n        ({ participantId, person }) =>\n          !existingParticipantIds?.includes(participantId) &&\n          (!gender ||\n            gender === ANY ||\n            person.sex === gender ||\n            // case where one gendered member has been assigned\n            (gender === MIXED && !assignedGender) ||\n            (assignedGender && person.sex !== assignedGender)),\n      ),\n  );\n\n  // if no sideNumber is provided, segregate available by sideNumber and specify sideNumber\n  const availableParticipants = sideNumber\n    ? availableIndividualParticipants?.[sideNumber - 1]\n    : availableIndividualParticipants?.map((available, i) => ({\n        participants: available,\n        sideNumber: i + 1,\n      }));\n\n  const availableParticipantIds = sideNumber\n    ? availableIndividualParticipants?.[sideNumber - 1]?.map(getParticipantId)\n    : availableIndividualParticipants?.map((available, i) => ({\n        participants: available?.map(getParticipantId),\n        sideNumber: i + 1,\n      }));\n\n  const assignmentAvailable =\n    (sideNumber &&\n      ((matchUpType === SINGLES_MATCHUP && !existingParticipantIds?.length) ||\n        (matchUpType === DOUBLES_MATCHUP && (existingParticipantIds?.length ?? 0) < 2))) ||\n    (!sideNumber &&\n      ((matchUpType === SINGLES_MATCHUP && (existingParticipantIds?.length ?? 0) < 2) ||\n        (matchUpType === DOUBLES_MATCHUP && (existingParticipantIds?.length ?? 0) < 4)));\n\n  // extra step to avoid edge case where individual participant is part of both teams\n  const availableIds = availableParticipantIds?.filter((id) => !allParticipantIds?.includes(id));\n  const available = availableParticipants?.filter(({ participantId }) => availableIds.includes(participantId));\n\n  if (assignmentAvailable && availableIds?.length) {\n    validActions.push({\n      availableParticipantIds: availableIds,\n      method: ASSIGN_TEAM_POSITION_METHOD,\n      availableParticipants: available,\n      type: ASSIGN_PARTICIPANT,\n      payload: {\n        participantId: undefined,\n        tieMatchUpId: matchUpId,\n        sideNumber,\n        drawId,\n      },\n    });\n  }\n\n  if (existingParticipantIds?.length && (!checkScoreHasValue(matchUp) || side?.substitutions?.length)) {\n    validActions.push({\n      method: REMOVE_TEAM_POSITION_METHOD,\n      type: REMOVE_PARTICIPANT,\n      existingParticipantIds,\n      payload: {\n        participantId: undefined,\n        tieMatchUpId: matchUpId,\n        drawId,\n      },\n    });\n  }\n  if (available?.length && ((!sideNumber && existingParticipantIds?.length) || (sideNumber && side?.participant))) {\n    validActions.push({\n      availableParticipantIds: availableIds,\n      method: REPLACE_TEAM_POSITION_METHOD,\n      availableParticipants: available,\n      type: REPLACE_PARTICIPANT,\n      existingParticipantIds,\n      payload: {\n        existingParticipantId: undefined,\n        participantId: undefined,\n        tieMatchUpId: matchUpId,\n        drawId,\n      },\n    });\n  }\n\n  if (isAvailableAction({ policyActions, action: REMOVE_SUBSTITUTION }) && side?.substitutions?.length) {\n    const sideIndividualParticipantIds =\n      (side.participant?.participantType === INDIVIDUAL && [side.participantId]) ||\n      (side.participant?.participantType === PAIR && side.participant.individualParticipantIds) ||\n      [];\n\n    const substitutedParticipantIds = side.substitutions\n      .map((sub) => sub.participantId)\n      .filter((id) => sideIndividualParticipantIds.includes(id));\n\n    if (!participantId || substitutedParticipantIds.includes(participantId)) {\n      validActions.push({\n        method: REMOVE_TEAM_POSITION_METHOD,\n        type: REMOVE_SUBSTITUTION,\n        substitutedParticipantIds,\n        payload: {\n          participantId: undefined,\n          tieMatchUpId: matchUpId,\n          drawId,\n        },\n      });\n    }\n  }\n\n  const matchUpActionPolicy = specifiedPolicyDefinitions?.[POLICY_TYPE_MATCHUP_ACTIONS];\n  const substituteWithoutScore = matchUpActionPolicy?.substituteWithoutScore;\n  const substituteAfterCompleted = matchUpActionPolicy?.substituteAfterCompleted;\n\n  // SUBSTITUTION\n  // substitution is only possible when both sides are present; otherwise => nonsensical\n  if (\n    isAvailableAction({ policyActions, action: SUBSTITUTION }) &&\n    matchUpParticipantIds.length === 2 &&\n    ((!sideNumber && existingParticipantIds?.length) || (sideNumber && side?.participant)) &&\n    (substituteWithoutScore || checkScoreHasValue(matchUp)) &&\n    (substituteAfterCompleted ||\n      (matchUp.matchUpStatus && !completedMatchUpStatuses.includes(matchUp.matchUpStatus))) &&\n    existingParticipants?.length &&\n    availableParticipants.length\n  ) {\n    // action is not valid if there are no existing assignments or no available substitutions\n    const existingParticipantIds = existingParticipants.map(getParticipantId);\n    validActions.push({\n      info: 'list of team players available for substitution',\n      method: SUBSTITUTION_METHOD,\n      availableParticipantIds,\n      existingParticipantIds,\n      availableParticipants,\n      existingParticipants,\n      type: SUBSTITUTION,\n      payload: {\n        substituteParticipantId: undefined,\n        existingParticipantId: undefined,\n        sideNumber,\n        matchUpId,\n        drawId,\n      },\n    });\n  }\n  return validActions;\n}\n","import { checkScoreHasValue } from '../matchUp/checkScoreHasValue';\nimport { validMatchUps } from '../../validators/validMatchUp';\nimport ratingsParameters from '../../fixtures/ratings/ratingsParameters';\nimport { isConvertableInteger } from '../../utilities/math';\nimport { allEventMatchUps } from './getAllEventMatchUps';\nimport { allTournamentMatchUps } from './getAllTournamentMatchUps';\nimport { allDrawMatchUps } from './getAllDrawMatchUps';\n\nimport { COMPETITIVE, DECISIVE, ROUTINE } from '../../constants/statsConstants';\nimport { DOUBLES, SINGLES } from '../../constants/matchUpTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport {\n  DrawDefinition,\n  Event,\n  Tournament,\n  EventTypeUnion,\n} from '../../types/tournamentTypes';\nimport {\n  ABANDONED,\n  DEAD_RUBBER,\n  DEFAULTED,\n  RETIRED,\n  WALKOVER,\n} from '../../constants/matchUpStatusConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\ntype getPredictiveAccuracyArgs = {\n  exclusionRule?: { valueAccessor: string; range: [number, number] };\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  matchUps?: HydratedMatchUp[];\n  singlesForDoubles?: boolean;\n  valueAccessor?: string;\n  excludeMargin?: number;\n  zoneDoubling?: boolean;\n  matchUpType: EventTypeUnion;\n  zoneMargin?: number;\n  ascending?: boolean;\n  scaleName: string;\n  eventId?: string;\n  zonePct?: number;\n  drawId?: string;\n  event?: Event;\n};\n\nexport function getPredictiveAccuracy(params: getPredictiveAccuracyArgs) {\n  let { matchUps } = params;\n  const {\n    singlesForDoubles,\n    tournamentRecord,\n    drawDefinition,\n    excludeMargin,\n    exclusionRule,\n    zoneDoubling,\n    matchUpType,\n    scaleName,\n    eventId,\n    zonePct,\n    drawId,\n    event,\n  } = params;\n\n  if (!tournamentRecord && !matchUps)\n    return { error: MISSING_TOURNAMENT_RECORD };\n\n  if (matchUpType && ![SINGLES, DOUBLES].includes(matchUpType))\n    return { error: INVALID_VALUES, info: { matchUpType } };\n\n  if (matchUps && !validMatchUps(matchUps))\n    return { error: INVALID_VALUES, context: { matchUps } };\n\n  const scaleProfile = ratingsParameters[scaleName];\n  const ascending = scaleProfile?.ascending ?? params.ascending ?? false;\n  const valueAccessor = scaleProfile?.accessor ?? params.valueAccessor;\n\n  const ratingsRangeDifference = Array.isArray(scaleProfile?.range)\n    ? Math.abs(scaleProfile.range[0] - scaleProfile.range[1])\n    : 0;\n\n  const zoneMargin =\n    isConvertableInteger(zonePct) && ratingsRangeDifference\n      ? (zonePct ?? 0 / 100) * ratingsRangeDifference\n      : params.zoneMargin ?? ratingsRangeDifference;\n\n  const contextProfile = { withScaleValues: true, withCompetitiveness: true };\n  const contextFilters = {\n    matchUpTypes: matchUpType ? [matchUpType] : [SINGLES, DOUBLES],\n  };\n  const participants = tournamentRecord?.participants;\n\n  if (matchUps?.[0]?.hasContext) {\n    if (drawId) {\n      matchUps = matchUps.filter((matchUp) => matchUp.drawId === drawId);\n    } else if (eventId) {\n      matchUps = matchUps.filter((matchUp) => matchUp.eventId === eventId);\n    }\n  } else if (matchUps === undefined) {\n    matchUps =\n      (drawId && !drawDefinition && []) ||\n      (!drawId && eventId && !event && []) ||\n      (drawId &&\n        allDrawMatchUps({\n          inContext: true,\n          drawDefinition,\n          contextFilters,\n          contextProfile,\n          participants,\n        })?.matchUps) ||\n      (!drawId &&\n        eventId &&\n        allEventMatchUps({\n          inContext: true,\n          contextFilters,\n          contextProfile,\n          participants,\n          event,\n        })?.matchUps) ||\n      allTournamentMatchUps({\n        tournamentRecord,\n        contextFilters,\n        contextProfile,\n      })?.matchUps ||\n      [];\n  }\n\n  if (matchUpType) {\n    matchUps = matchUps.filter(\n      (matchUp) => matchUp.matchUpType === matchUpType\n    );\n  }\n\n  const relevantMatchUps = matchUps.filter(\n    ({ winningSide, score, sides, matchUpStatus }) =>\n      ![RETIRED, DEFAULTED, WALKOVER, DEAD_RUBBER, ABANDONED].includes(\n        matchUpStatus ?? ''\n      ) &&\n      checkScoreHasValue({ score }) &&\n      sides?.length === 2 &&\n      winningSide\n  );\n\n  const accuracy = getGroupingAccuracy({\n    matchUps: relevantMatchUps,\n    excludeMargin,\n    exclusionRule,\n    valueAccessor,\n    ascending,\n    scaleName,\n  });\n\n  const marginCalc =\n    !zoneDoubling || matchUpType === SINGLES\n      ? zoneMargin\n      : (zoneMargin || 0) * 2;\n\n  const zoneData = zoneMargin\n    ? relevantMatchUps\n        .map(({ competitiveProfile, matchUpType, score, sides }) => {\n          const sideValues = getSideValues({\n            singlesForDoubles,\n            valueAccessor,\n            matchUpType,\n            scaleName,\n            sides,\n          });\n          const valuesGap = Math.abs(sideValues[0].value - sideValues[1].value);\n\n          return {\n            competitiveness: competitiveProfile?.competitiveness,\n            valuesGap,\n            score,\n          };\n        })\n        .filter(({ valuesGap }) => {\n          return valuesGap <= marginCalc;\n        })\n    : [];\n\n  const zoneBands: any = getGroupingBands({ zoneData });\n  const totalZoneMatchUps =\n    zoneBands && [].concat(Object.values(zoneBands)).flat().length;\n\n  const zoneDistribution =\n    totalZoneMatchUps &&\n    Object.assign(\n      {},\n      ...Object.keys(zoneBands).map((key) => ({\n        [key]:\n          Math.round((10000 * zoneBands[key].length) / totalZoneMatchUps) / 100,\n      }))\n    );\n\n  const nonZone = relevantMatchUps.length - (zoneData?.length || 0);\n\n  return {\n    ...SUCCESS,\n    relevantMatchUps,\n    zoneDistribution,\n    zoneData,\n    accuracy,\n    nonZone,\n  };\n}\n\nfunction getGroupingBands({ zoneData }) {\n  const bands = { [COMPETITIVE]: [], [ROUTINE]: [], [DECISIVE]: [] };\n  for (const data of zoneData) {\n    const { competitiveness, score, valuesGap } = data;\n    if (bands[competitiveness]) {\n      bands[competitiveness].push({ score, valuesGap });\n    }\n  }\n\n  return bands;\n}\n\ntype GetSideValuesArgs = {\n  singlesForDoubles?: boolean;\n  valueAccessor: string;\n  matchUpType?: EventTypeUnion;\n  exclusionRule?: any;\n  scaleName: string;\n  sides: any;\n};\nfunction getSideValues({\n  singlesForDoubles,\n  exclusionRule,\n  valueAccessor,\n  matchUpType,\n  scaleName,\n  sides,\n}: GetSideValuesArgs) {\n  const sortedRange = exclusionRule?.range.sort();\n\n  const checkExcludeParticipant = (scaleValue) => {\n    const exclusionValue = scaleValue?.[exclusionRule?.valueAccessor];\n    const exclude =\n      exclusionRule &&\n      exclusionValue >= sortedRange[0] &&\n      exclusionValue <= sortedRange[1];\n    return { exclude, exclusionValue };\n  };\n\n  return sides\n    .sort((a, b) => a.sideNumber - b.sideNumber)\n    .map(({ participant }) => {\n      const exclusionValues: number[] = [];\n      const individualParticipants = participant?.individualParticipants;\n      if (individualParticipants?.length) {\n        const scaleValues: any[] = [];\n        let value: any = 0;\n\n        for (const participant of individualParticipants) {\n          const { scaleValue, value: pValue } = getSideValue({\n            singlesForDoubles,\n            valueAccessor,\n            participant,\n            matchUpType,\n            scaleName,\n          });\n          const { exclude, exclusionValue } =\n            checkExcludeParticipant(scaleValue);\n          if (exclude) exclusionValues.push(exclusionValue);\n          scaleValues.push(scaleValue);\n\n          if (pValue && !isNaN(value)) {\n            value += pValue;\n          } else {\n            value = undefined;\n          }\n        }\n\n        return {\n          participantName: participant.participantName,\n          exclusionValues,\n          scaleValues,\n          value,\n        };\n      } else if (participant) {\n        const { scaleValue, value } = getSideValue({\n          singlesForDoubles,\n          valueAccessor,\n          matchUpType,\n          participant,\n          scaleName,\n        });\n        const { exclude, exclusionValue } = checkExcludeParticipant(scaleValue);\n        if (exclude) exclusionValues.push(exclusionValue);\n\n        return {\n          participantName: participant.participantName,\n          exclusionValues,\n          scaleValue,\n          value,\n        };\n      } else {\n        return {};\n      }\n    });\n}\n\nfunction getSideValue({\n  singlesForDoubles,\n  valueAccessor,\n  matchUpType,\n  participant,\n  scaleName,\n}) {\n  const type = singlesForDoubles ? SINGLES : matchUpType;\n  const ranking = participant?.rankings?.[type]?.find(\n    (ranking) => ranking.scaleName === scaleName\n  );\n  const rating = participant?.ratings?.[type]?.find(\n    (rating) => rating.scaleName === scaleName\n  );\n  const scaleValue = (rating || ranking)?.scaleValue;\n  const value = valueAccessor ? scaleValue?.[valueAccessor] : scaleValue;\n  return { scaleValue, value };\n}\n\n// given a grouping of matchUps, how accurate were the scaleValues in predicting winner\nfunction getGroupingAccuracy({\n  excludeMargin,\n  exclusionRule,\n  valueAccessor,\n  ascending,\n  scaleName,\n  matchUps,\n}) {\n  const accuracy: any = { affirmative: [], negative: [], excluded: [] };\n\n  for (const matchUp of matchUps) {\n    const { matchUpType, sides, score, winningSide } = matchUp;\n    if (!winningSide) continue;\n\n    if (\n      exclusionRule &&\n      (!exclusionRule.valueAccessor || !exclusionRule.range)\n    ) {\n      return {\n        info: 'exclusionRule requires valueAccessor and range',\n        error: MISSING_VALUE,\n      };\n    }\n\n    const winningIndex = winningSide - 1;\n\n    const sideValues = getSideValues({\n      exclusionRule,\n      valueAccessor,\n      matchUpType,\n      scaleName,\n      sides,\n    });\n\n    if (exclusionRule) {\n      const exclusionValues = sideValues\n        .map(({ exclusionValues }) => exclusionValues)\n        .flat();\n\n      if (exclusionValues.length) {\n        accuracy.excluded.push({\n          scoreString: score?.scoreStringSide1,\n          exclusionValues,\n          winningSide,\n          sideValues,\n        });\n        continue;\n      }\n    }\n\n    if (\n      sideValues.filter((value) => ![undefined, '', null].includes(value.value))\n        .length < 2\n    ) {\n      accuracy.excluded.push({\n        scoreString: score?.scoreStringSide1,\n        missingValues: true,\n        winningSide,\n        sideValues,\n      });\n      continue;\n    }\n\n    const valuesGap =\n      sideValues[winningIndex].value - sideValues[1 - winningIndex].value;\n\n    const floatMargin = parseFloat(excludeMargin || 0);\n    const excludeGap = floatMargin && Math.abs(valuesGap) < floatMargin;\n\n    if (excludeGap) {\n      accuracy.excluded.push({\n        scoreString: score?.scoreStringSide1,\n        excludeMargin,\n        winningSide,\n        excludeGap,\n        sideValues,\n        valuesGap,\n      });\n      continue;\n    }\n\n    // when ascending is true winning value will be greater than losing value\n    const signedGap = ascending ? valuesGap : valuesGap * -1;\n\n    const winningScoreString =\n      winningSide === 1 ? score?.scoreStringSide1 : score?.scoreStringSide2;\n\n    if (signedGap > 0) {\n      accuracy.affirmative.push({\n        winningScoreString,\n        winningSide,\n        sideValues,\n        valuesGap,\n        score,\n      });\n    } else {\n      accuracy.negative.push({\n        winningScoreString,\n        winningSide,\n        sideValues,\n        valuesGap,\n        score,\n      });\n    }\n  }\n\n  const denominator = accuracy.affirmative.length + accuracy.negative.length;\n  const percent =\n    denominator && (accuracy.affirmative.length / denominator) * 100;\n\n  accuracy.percent = percent ? Math.round(100 * percent) / 100 : 0;\n\n  return accuracy;\n}\n","import { TEAM } from '../../constants/participantConstants';\n\nexport function checkIsDual(tournamentRecord) {\n  const teamParticipants = tournamentRecord.participants?.filter(\n    ({ participantType }) => participantType === TEAM\n  );\n  const twoTeams = teamParticipants?.length === 2;\n  const event =\n    tournamentRecord.events?.length === 1 && tournamentRecord.events[0];\n  const drawDefinition =\n    event?.drawDefinitions?.length === 1 && event.drawDefinitions[0];\n  const structure =\n    drawDefinition?.structures?.length === 1 && drawDefinition.structures[0];\n  const twoDrawPositions = structure?.positionAssignments?.length === 2;\n\n  return !!(event.tieFormat && twoTeams && twoDrawPositions);\n}\n","import { findMatchUpFormatTiming } from '../../../acquire/findMatchUpFormatTiming';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { instanceCount } from '../../../utilities/arrays';\n\nimport {\n  BYE,\n  completedMatchUpStatuses,\n} from '../../../constants/matchUpStatusConstants';\n\nexport function getRoundId(obj) {\n  const {\n    containerStructureId,\n    roundSegment,\n    isRoundRobin,\n    tournamentId,\n    roundNumber,\n    structureId,\n    eventId,\n    drawId,\n  } = obj;\n  const relevantStructureId = isRoundRobin ? containerStructureId : structureId;\n\n  // retain order\n  const id = [\n    tournamentId, // 1\n    eventId, // 2\n    drawId, // 3\n    relevantStructureId, // 4\n    roundNumber, // 5\n  ].join('|');\n\n  return definedAttributes({\n    structureId: relevantStructureId,\n    roundSegment,\n    tournamentId,\n    roundNumber,\n    eventId,\n    drawId,\n    id,\n  });\n}\n\nexport function getRoundTiming({ round, matchUps, events, tournamentRecords }) {\n  const event = events.find((event) => event.eventId === round.eventId);\n  const { eventType, category, categoryType } = event || {};\n  const { categoryName, ageCategoryCode } = category || {};\n  const formatCounts = instanceCount(\n    matchUps.map(({ matchUpFormat }) => matchUpFormat)\n  );\n\n  let roundMinutes = 0;\n  Object.keys(formatCounts).forEach((matchUpFormat) => {\n    const formatCount = formatCounts[matchUpFormat];\n    const result = findMatchUpFormatTiming({\n      categoryName: categoryName || ageCategoryCode,\n      tournamentId: round.tournamentId,\n      eventId: round.eventId,\n      tournamentRecords,\n      matchUpFormat,\n      categoryType,\n      eventType,\n    });\n    if (result.error) return result;\n    const formatMinutes = result.averageMinutes * formatCount;\n    if (!isNaN(roundMinutes)) roundMinutes += formatMinutes;\n    return undefined;\n  });\n\n  return { roundMinutes };\n}\n\nexport function getFinishingPositionDetails(matchUps) {\n  return (matchUps || []).reduce(\n    (foo, matchUp) => {\n      const sum = (matchUp.finishingPositionRange?.winner || []).reduce(\n        (a, b) => a + b,\n        0\n      );\n      const winnerFinishingPositionRange =\n        (matchUp.finishingPositionRange?.winner || []).join('-') || '';\n      return !foo.minFinishingSum || sum < foo.minFinishingSum\n        ? { minFinishingSum: sum, winnerFinishingPositionRange }\n        : foo;\n    },\n    { minFinishingSum: 0, winnerFinishingPositionRange: '' }\n  );\n}\n\nexport function getRoundProfile(matchUps) {\n  const matchUpsCount = matchUps.length;\n  const byeCount =\n    matchUps.filter(({ sides }) => sides?.some(({ bye }) => bye)).length || 0;\n  const completedCount =\n    matchUps.filter(\n      ({ winningSide, matchUpStatus }) =>\n        winningSide || completedMatchUpStatuses.includes(matchUpStatus)\n    ).length || 0;\n  const scheduledCount =\n    matchUps.filter(\n      ({ schedule, matchUpStatus }) =>\n        schedule?.scheduledDate &&\n        schedule?.scheduledTime &&\n        matchUpStatus !== BYE\n    ).length || 0;\n  const consideredCount = matchUpsCount - byeCount;\n  const isComplete = consideredCount === completedCount;\n  const unscheduledCount = consideredCount - scheduledCount;\n  const incompleteCount = consideredCount - scheduledCount;\n  const isScheduled = consideredCount === scheduledCount;\n  return {\n    unscheduledCount,\n    incompleteCount,\n    scheduledCount,\n    completedCount,\n    matchUpsCount,\n    isScheduled,\n    isComplete,\n    byeCount,\n  };\n}\n","import { validateSchedulingProfile } from '../../../validators/validateSchedulingProfile';\nimport { getRoundId } from '../../../query/matchUps/scheduling/schedulingUtils';\nimport { getSchedulingProfile } from '../../tournaments/schedulingProfile';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\n\nimport { Tournament } from '../../../types/tournamentTypes';\nimport {\n  ErrorType,\n  INVALID_TOURNAMENT_RECORD,\n  NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\n\ntype GetProfileRoundsArgs = {\n  tournamentRecords?: { [key: string]: Tournament };\n  tournamentRecord?: Tournament;\n  schedulingProfile?: any;\n  withRoundId?: boolean;\n};\nexport function getProfileRounds({\n  tournamentRecords,\n  schedulingProfile,\n  tournamentRecord,\n  withRoundId,\n}: GetProfileRoundsArgs): {\n  segmentedRounds?: { [key: string]: any };\n  profileRounds?: any[];\n  error?: ErrorType;\n} {\n  if (tournamentRecord && !tournamentRecords) {\n    if (typeof tournamentRecord !== 'object') {\n      return { error: INVALID_TOURNAMENT_RECORD };\n    } else {\n      tournamentRecords = { [tournamentRecord.tournamentId]: tournamentRecord };\n    }\n  }\n\n  if (schedulingProfile) {\n    const profileValidity = validateSchedulingProfile({\n      tournamentRecords,\n      schedulingProfile,\n    });\n\n    if (profileValidity.error) return profileValidity;\n  }\n\n  if (!schedulingProfile && tournamentRecords) {\n    const result = getSchedulingProfile({ tournamentRecords });\n    if (result.error) return result;\n    schedulingProfile = result.schedulingProfile;\n  }\n\n  if (!schedulingProfile) return { error: NOT_FOUND };\n\n  const segmentedRounds: { [key: string]: any } = {};\n\n  const profileRounds = schedulingProfile\n    .map(({ venues, scheduleDate }) =>\n      venues.map(({ rounds }) =>\n        rounds.map((round) => {\n          const roundRef = getRoundId(round);\n          if (roundRef.roundSegment?.segmentsCount) {\n            segmentedRounds[roundRef.id] = roundRef.roundSegment.segmentsCount;\n          }\n          return definedAttributes({\n            id: withRoundId ? roundRef.id : undefined,\n            scheduleDate,\n            ...roundRef,\n          });\n        })\n      )\n    )\n    .flat(Infinity);\n\n  return { profileRounds, segmentedRounds };\n}\n","import drawDefinitionConstants from '../../constants/drawDefinitionConstants';\n\nconst { stageOrder } = drawDefinitionConstants;\n// Sort rounds by order in which they will be played\nexport function roundSort(a, b) {\n  return (\n    a.eventName.localeCompare(b.eventName) ||\n    a.eventId.localeCompare(b.eventId) ||\n    (stageOrder[a?.stage] || 0) - (stageOrder[b?.stage] || 0) ||\n    b.matchUpsCount - a.matchUpsCount ||\n    `${a.stageSequence}-${a.roundNumber}-${a.minFinishingSum}`.localeCompare(\n      `${b.stageSequence}-${b.roundNumber}-${b.minFinishingSum}`\n    )\n  );\n}\n","import { getEligibleVoluntaryConsolationParticipants } from '../../../query/drawDefinition/getEligibleVoluntaryConsolationParticipants';\nimport { getMatchUpFormatTimingUpdate } from '../../../query/extensions/matchUpFormatTiming/getMatchUpFormatTimingUpdate';\nimport { getDrawParticipantRepresentativeIds } from '../../../mutate/drawDefinitions/getDrawParticipantRepresentativeIds';\nimport { getEventMatchUpFormatTiming } from '../../../query/extensions/matchUpFormatTiming/getEventMatchUpFormatTiming';\nimport { getModifiedMatchUpFormatTiming } from '../../../query/extensions/matchUpFormatTiming/getModifiedMatchUpTiming';\nimport { getValidGroupSizes } from '../../../assemblies/generators/drawDefinitions/drawTypes/roundRobin/roundRobin';\nimport { getMatchUpFormatTiming } from '../../../query/extensions/matchUpFormatTiming/getMatchUpFormatTiming';\nimport { getScheduledRoundsDetails } from '../../../query/matchUps/scheduling/getScheduledRoundsDetails';\nimport { getSchedulingProfileIssues } from '../../../query/matchUps/scheduling/getSchedulingProfileIssues';\nimport { getCompetitionPenalties } from '../../../mutate/participants/penalties/getCompetitionPenalties';\nimport { roundRobinGroups } from '../../generators/drawDefinitions/drawTypes/roundRobin/roundRobinGroups';\nimport { getTournamentPenalties } from '../../../mutate/participants/penalties/getTournamentPenalties';\nimport { getMatchUpDailyLimitsUpdate } from '../../../query/extensions/getMatchUpDailyLimitsUpdate';\nimport { getCompetitionParticipants } from '../../../query/participants/getCompetitionParticipants';\nimport { getParticipantIdFinishingPositions } from '../../../query/drawDefinition/finishingPositions';\nimport { getSeedingThresholds } from '../../../mutate/drawDefinitions/positionGovernor/getSeedBlocks';\nimport { participantScheduledMatchUps } from '../../../query/matchUps/participantScheduledMatchUps';\nimport { getParticipantEventDetails } from '../../../query/participants/getParticipantEventDetails';\nimport { getStructureSeedAssignments } from '../../../query/structure/getStructureSeedAssignments';\nimport { getAssignedParticipantIds } from '../../../query/drawDefinition/getAssignedParticipantIds';\nimport { tallyParticipantResults } from '../../../query/matchUps/roundRobinTally/roundRobinTally';\nimport { competitionScheduleMatchUps } from '../../../query/matchUps/competitionScheduleMatchUps';\nimport { getMatchUpCompetitiveProfile } from '../../../query/matchUp/getMatchUpCompetitiveProfile';\nimport { getParticipantMembership } from '../../../query/participants/getParticipantMembership';\nimport { tieFormatGenderValidityCheck } from '../../../validators/tieFormatGenderValidityCheck';\nimport { bulkUpdatePublishedEventIds } from '../../../query/event/bulkUpdatePublishedEventIds';\nimport { positionActions } from '../../../query/drawDefinition/positionActions/positionActions';\nimport { getParticipantSchedules } from '../../../query/participants/getParticipantSchedules';\nimport { validateCollectionDefinition } from '../../../validators/validateCollectionDefinition';\nimport { getMatchUpScheduleDetails } from '../../../query/matchUp/getMatchUpScheduleDetails';\nimport { getCompetitionDateRange } from '../../../query/tournaments/getCompetitionDateRange';\nimport { getParticipantScaleItem } from '../../../query/participant/getParticipantScaleItem';\nimport { compareTieFormats } from '../../../query/hierarchical/tieFormats/compareTieFormats';\nimport { isValidForQualifying } from '../../../mutate/drawDefinitions/isValidForQualifying';\nimport { getLinkedTournamentIds } from '../../../query/tournaments/getLinkedTournamentIds';\nimport { allCompetitionMatchUps } from '../../../query/matchUps/getAllCompetitionMatchUps';\nimport { getDrawTypeCoercion } from '../../generators/drawDefinitions/getDrawTypeCoercion';\nimport { getEntriesAndSeedsCount } from '../../../query/entries/getEntriesAndSeedsCount';\nimport { allTournamentMatchUps } from '../../../query/matchUps/getAllTournamentMatchUps';\nimport { getPositionAssignments } from '../../../query/structure/getPositionAssignments';\nimport { getPersonRequests } from '../../../query/matchUps/scheduling/getPersonRequests';\nimport { getMatchUpDependencies } from '../../../query/matchUps/getMatchUpDependencies';\nimport { getMatchUpDailyLimits } from '../../../query/extensions/getMatchUpDailyLimits';\nimport { getCompetitionMatchUps } from '../../../query/matchUps/getCompetitionMatchUps';\nimport { participantScaleItem } from '../../../query/participant/participantScaleItem';\nimport { checkMatchUpIsComplete } from '../../../query/matchUp/checkMatchUpIsComplete';\nimport { getPairedParticipant } from '../../../query/participant/getPairedParticipant';\nimport { getTournamentPersons } from '../../../query/tournaments/getTournamentPersons';\nimport { getPredictiveAccuracy } from '../../../query/matchUps/getPredictiveAccuracy';\nimport { getParticipantSignInStatus } from '../../../query/participant/signInStatus';\nimport { tournamentMatchUps } from '../../../query/matchUps/getTournamentMatchUps';\nimport { getCategoryAgeDetails } from '../../../query/event/getCategoryAgeDetails';\nimport { calculateWinCriteria } from '../../../query/matchUp/calculateWinCriteria';\nimport { getMatchUpContextIds } from '../../../query/matchUp/getMatchUpContextIds';\nimport { getMaxEntryPosition } from '../../../query/entries/getMaxEntryPosition';\nimport { analyzeTournament } from '../../../query/tournaments/analyzeTournament';\nimport { getTournamentInfo } from '../../../query/tournaments/getTournamentInfo';\nimport { isValidMatchUpFormat } from '../../../validators/isValidMatchUpFormat';\nimport { getMatchUpFormat } from '../../../query/hierarchical/getMatchUpFormat';\nimport { publicFindParticipant } from '../../../acquire/publicFindParticipant';\nimport { getTournamentIds } from '../../../query/tournaments/getTournamentIds';\nimport { validMatchUp, validMatchUps } from '../../../validators/validMatchUp';\nimport { allEventMatchUps } from '../../../query/matchUps/getAllEventMatchUps';\nimport { getParticipants } from '../../../query/participants/getParticipants';\nimport { allDrawMatchUps } from '../../../query/matchUps/getAllDrawMatchUps';\nimport { categoryCanContain } from '../../../query/event/categoryCanContain';\nimport { matchUpActions } from '../../../query/drawDefinition/matchUpActions/matchUpActions';\nimport { getEventProperties } from '../../../query/event/getEventProperties';\nimport { getTeamLineUp } from '../../../mutate/drawDefinitions/getTeamLineUp';\nimport { getMatchUpsStats } from '../../../query/matchUps/getMatchUpsStats';\nimport { getRoundMatchUps } from '../../../query/matchUps/getRoundMatchUps';\nimport { getScaleValues } from '../../../query/participant/getScaleValues';\nimport { getSeedsCount } from '../../../query/drawDefinition/getSeedsCount';\nimport { getAllDrawMatchUps } from '../../../query/matchUps/drawMatchUps';\nimport { checkValidEntries } from '../../../validators/checkValidEntries';\nimport { getScaledEntries } from '../../../query/event/getScaledEntries';\nimport { eventMatchUps } from '../../../query/matchUps/getEventMatchUps';\nimport { getRounds } from '../../../query/matchUps/scheduling/getRounds';\nimport { validateCategory } from '../../../validators/validateCategory';\nimport { validateLineUp } from '../../../validators/validateTeamLineUp';\nimport { getTieFormat } from '../../../query/hierarchical/getTieFormat';\nimport { getFlightProfile } from '../../../query/event/getFlightProfile';\nimport { getMatchUpType } from '../../../query/matchUp/getMatchUpType';\nimport { analyzeMatchUp } from '../../../query/matchUp/analyzeMatchUp';\nimport { analyzeDraws } from '../../../query/tournaments/analyzeDraws';\nimport { drawMatchUps } from '../../../query/matchUps/getDrawMatchUps';\nimport { getVenuesReport } from '../../../query/venues/venuesReport';\nimport { publicFindMatchUp } from '../../../acquire/findMatchUp';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { isAdHoc } from '../../../query/drawDefinition/isAdHoc';\nimport { findExtension } from '../../../acquire/findExtension';\nimport { getCourts } from '../../../query/venues/getCourts';\nimport { getEvents } from '../../../query/events/getEvents';\nimport { getEvent } from '../../../query/events/getEvent';\nimport { findPolicy } from '../../../acquire/findPolicy';\nimport { credits } from '../../../fixtures/credits';\nimport { allPlayoffPositionsFilled, isCompletedStructure } from '../../../query/drawDefinition/structureActions';\nimport { getPolicyDefinitions, getAppliedPolicies } from '../../../query/extensions/getAppliedPolicies';\nimport { getCompetitionVenues, getVenuesAndCourts } from '../../../query/venues/venuesAndCourtsGetter';\nimport { getEventStructures, getTournamentStructures } from '../../../query/structure/structureGetter';\nimport { getAllowedDrawTypes, getAllowedMatchUpFormats } from '../../../query/tournaments/allowedTypes';\nimport {\n  getTimeItem,\n  getEventTimeItem,\n  getTournamentTimeItem,\n  getParticipantTimeItem,\n  getDrawDefinitionTimeItem,\n} from '../../../query/base/timeItems';\n\nimport { MISSING_DRAW_ID, MISSING_TOURNAMENT_RECORD } from '../../../constants/errorConditionConstants';\n\nfunction findDrawDefinition({ tournamentRecord, drawDefinition }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!drawDefinition) return { error: MISSING_DRAW_ID };\n  return { drawDefinition: makeDeepCopy(drawDefinition) };\n}\n\nexport const queryGovernor = {\n  allCompetitionMatchUps,\n  allDrawMatchUps,\n  allEventMatchUps,\n  allTournamentMatchUps,\n  analyzeDraws,\n  analyzeMatchUp,\n  analyzeTournament,\n  bulkUpdatePublishedEventIds,\n  categoryCanContain,\n  checkMatchUpIsComplete,\n  checkValidEntries,\n  competitionScheduleMatchUps,\n  credits,\n  drawMatchUps,\n  eventMatchUps,\n  findDrawDefinition,\n  findExtension,\n  findMatchUp: publicFindMatchUp,\n  findParticipant: publicFindParticipant,\n  findPolicy,\n  getAllDrawMatchUps,\n  getAllowedDrawTypes,\n  getAllowedMatchUpFormats,\n  getAppliedPolicies,\n  getAssignedParticipantIds,\n  getCompetitionDateRange,\n  getCompetitionMatchUps,\n  getCompetitionParticipants,\n  getCompetitionPenalties, // test\n  getCompetitionVenues,\n  getCourts,\n  getDrawDefinitionTimeItem,\n  getDrawParticipantRepresentativeIds,\n  getDrawTypeCoercion,\n  getEligibleVoluntaryConsolationParticipants,\n  getEntriesAndSeedsCount,\n  getEvent,\n  getEventMatchUpFormatTiming,\n  getEventProperties,\n  getEvents,\n  getEventStructures,\n  getEventTimeItem,\n  getFlightProfile,\n  getLinkedTournamentIds,\n  getMatchUpCompetitiveProfile,\n  getMatchUpDailyLimits, // document\n  getMatchUpDailyLimitsUpdate, // document\n  getMatchUpDependencies,\n  getMatchUpFormat,\n  getMatchUpFormatTiming,\n  getMatchUpFormatTimingUpdate,\n  getMatchUpScheduleDetails,\n  getMatchUpsStats,\n  getMatchUpType,\n  getMaxEntryPosition,\n  getModifiedMatchUpFormatTiming,\n  getPairedParticipant,\n  getParticipantEventDetails,\n  getParticipantIdFinishingPositions,\n  getParticipantMembership,\n  getParticipants,\n  getParticipantScaleItem,\n  getParticipantSchedules,\n  getParticipantSignInStatus,\n  getParticipantTimeItem,\n  getPersonRequests,\n  getPolicyDefinitions,\n  getPositionAssignments,\n  getPredictiveAccuracy,\n  getRoundMatchUps,\n  getRounds,\n  getScaledEntries,\n  getScheduledRoundsDetails,\n  getSchedulingProfileIssues,\n  getSeedsCount,\n  getStructureSeedAssignments,\n  getTeamLineUp,\n  getTieFormat,\n  getTournamentIds,\n  getTournamentInfo,\n  getTournamentPenalties,\n  getTournamentPersons,\n  getTournamentStructures,\n  getTournamentTimeItem,\n  getVenuesAndCourts,\n  getVenuesReport,\n  isValidForQualifying,\n  isValidMatchUpFormat,\n  matchUpActions,\n  participantScaleItem,\n  participantScheduledMatchUps,\n  positionActions,\n  tallyParticipantResults,\n  tournamentMatchUps,\n  validateCollectionDefinition,\n  validateLineUp,\n  validMatchUp,\n  validMatchUps,\n\n  allPlayoffPositionsFilled,\n  getCategoryAgeDetails,\n  calculateWinCriteria,\n  compareTieFormats,\n  getMatchUpContextIds,\n  getScaleValues,\n  getSeedingThresholds,\n  getTimeItem,\n  getValidGroupSizes,\n  isAdHoc,\n  isCompletedStructure,\n  roundRobinGroups,\n  tieFormatGenderValidityCheck,\n  validateCategory,\n};\n\nexport const query = queryGovernor;\nexport default queryGovernor;\n","import { analyzeDraws } from './analyzeDraws';\nimport { checkIsDual } from './checkIsDual';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\n\nexport function analyzeTournament({ tournamentRecord }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const { drawsAnalysis } = analyzeDraws({ tournamentRecord });\n\n  const analysis = {\n    isDual: checkIsDual(tournamentRecord),\n    drawsAnalysis,\n  };\n\n  return { ...SUCCESS, analysis };\n}\n","import { getEventPublishStatus } from './getEventPublishStatus';\nimport { getDrawPublishStatus } from './getDrawPublishStatus';\n\nimport {\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\n\n/**\n *\n * @param {object[]} outcomes - array of outcomes to be applied to matchUps, relevent attributes: { eventId: string; drawId: string; }\n *\n */\nexport function bulkUpdatePublishedEventIds({ tournamentRecord, outcomes }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!outcomes?.length)\n    return { error: MISSING_VALUE, info: 'Missing outcomes' };\n\n  const eventIdsMap = outcomes.reduce((eventIdsMap, outcome) => {\n    const { drawId, eventId } = outcome;\n    if (eventId && drawId) {\n      if (!eventIdsMap[eventId]) {\n        eventIdsMap[eventId] = [drawId];\n      } else if (!eventIdsMap[eventId].includes(drawId)) {\n        eventIdsMap[eventId].push(drawId);\n      }\n    }\n    return eventIdsMap;\n  }, {});\n\n  const relevantEventsIds = Object.keys(eventIdsMap);\n  const relevantEvents = tournamentRecord.events?.filter((event) =>\n    relevantEventsIds.includes(event.eventId)\n  );\n  const publishedEventIds = relevantEvents\n    .filter((event) => {\n      const pubStatus = getEventPublishStatus({ event });\n      const { drawDetails, drawIds } = pubStatus ?? {};\n\n      const { eventId } = event;\n      const publishedDrawIds = eventIdsMap[eventId].filter((drawId) => {\n        const keyedDrawIds = drawDetails\n          ? Object.keys(pubStatus.drawDetails).filter((drawId) =>\n              getDrawPublishStatus({ drawId, drawDetails })\n            )\n          : [];\n        return drawIds?.includes(drawId) || keyedDrawIds.includes(drawId);\n      });\n\n      return publishedDrawIds.length;\n    })\n    .map((event) => event.eventId);\n\n  return { publishedEventIds, eventIdPublishedDrawIdsMap: eventIdsMap };\n}\n","import { definedAttributes } from '../../utilities/definedAttributes';\nimport { hydrateParticipants } from '../participants/hydrateParticipants';\nimport { getContextContent } from '../hierarchical/getContextContent';\nimport { getDrawMatchUps } from './drawMatchUps';\n\nimport { GetMatchUpsArgs } from '../../types/factoryTypes';\n\nexport function drawMatchUps({\n  participants: tournamentParticipants,\n  tournamentAppliedPolicies,\n  scheduleVisibilityFilters,\n  participantsProfile,\n  afterRecoveryTimes,\n  policyDefinitions,\n  useParticipantMap,\n  tournamentRecord,\n  usePublishState,\n  contextFilters,\n  contextContent,\n  matchUpFilters,\n  participantMap,\n  publishStatus,\n  contextProfile,\n  drawDefinition,\n  nextMatchUps,\n  tournamentId,\n  inContext,\n  context,\n  event,\n}: GetMatchUpsArgs) {\n  const { eventId, eventName, endDate } = event ?? {};\n\n  const additionalContext = {\n    ...context,\n    ...definedAttributes({\n      eventId,\n      eventName,\n      endDate: endDate ?? event?.endDate ?? tournamentRecord?.endDate,\n      tournamentId: tournamentId ?? tournamentRecord?.tournamentId,\n      indoorOutDoor: event?.indoorOutdoor ?? tournamentRecord?.indoorOutdoor,\n      surfaceCategory:\n        event?.surfaceCategory ?? tournamentRecord?.surfaceCategory,\n    }),\n  };\n\n  let groupInfo;\n  if (!tournamentParticipants?.length && tournamentRecord) {\n    ({\n      participants: tournamentParticipants,\n      participantMap,\n      groupInfo,\n    } = hydrateParticipants({\n      participantsProfile,\n      policyDefinitions,\n      useParticipantMap,\n      tournamentRecord,\n      contextProfile,\n      inContext,\n    }));\n  }\n\n  if (event && contextProfile && !contextContent)\n    contextContent = getContextContent({\n      policyDefinitions,\n      tournamentRecord,\n      contextProfile,\n      drawDefinition,\n      event,\n    });\n\n  const drawMatchUpsResult = getDrawMatchUps({\n    context: additionalContext,\n    tournamentAppliedPolicies,\n    scheduleVisibilityFilters,\n    tournamentParticipants,\n    participantsProfile,\n    afterRecoveryTimes,\n    policyDefinitions,\n    tournamentRecord,\n    usePublishState,\n    participantMap,\n    contextContent,\n    contextFilters,\n    matchUpFilters,\n    publishStatus,\n    contextProfile,\n    drawDefinition,\n    nextMatchUps,\n    inContext,\n    event,\n  });\n\n  return { ...drawMatchUpsResult, groupInfo };\n}\n","import { findParticipant } from './findParticipant';\n\nimport { ErrorType, MISSING_VALUE } from '../constants/errorConditionConstants';\nimport { HydratedParticipant } from '../types/hydrated';\nimport { SUCCESS } from '../constants/resultConstants';\nimport { Tournament } from '../types/tournamentTypes';\nimport {\n  ContextProfile,\n  PolicyDefinitions,\n  TournamentRecords,\n} from '../types/factoryTypes';\n\ntype PublicFindParticipantArgs = {\n  tournamentRecords?: TournamentRecords;\n  policyDefinitions?: PolicyDefinitions;\n  tournamentRecord?: Tournament;\n  contextProfile?: ContextProfile;\n  participantId?: string;\n  personId?: string;\n};\nexport function publicFindParticipant(params: PublicFindParticipantArgs): {\n  participant?: HydratedParticipant;\n  tournamentId?: string;\n  error?: ErrorType;\n  stack?: any;\n} {\n  const {\n    tournamentRecord,\n    policyDefinitions,\n    contextProfile,\n    participantId,\n    personId,\n  } = params;\n\n  const tournamentRecords =\n    params.tournamentRecords ||\n    (tournamentRecord && {\n      [tournamentRecord.tournamentId]: tournamentRecord,\n    }) ||\n    {};\n\n  if (typeof participantId !== 'string' && typeof personId !== 'string')\n    return { error: MISSING_VALUE, stack: 'publicFindParticipant' };\n\n  let participant, tournamentId;\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    tournamentId = tournamentRecord.tournamentId;\n\n    const tournamentParticipants = tournamentRecord.participants || [];\n    participant = findParticipant({\n      tournamentParticipants,\n      internalUse: true,\n      policyDefinitions,\n      contextProfile,\n      participantId,\n      personId,\n    });\n\n    if (participant) break;\n  }\n\n  return { participant, tournamentId, ...SUCCESS };\n}\n","import { getParticipants as participantGetter } from './getParticipants';\n// import { deepMerge } from '../../utilities/deepMerge';\n\nimport { MISSING_TOURNAMENT_RECORDS } from '../../constants/errorConditionConstants';\nimport { HydratedMatchUp, HydratedParticipant } from '../../types/hydrated';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { ParticipantMap } from '../../types/factoryTypes';\nimport { MatchUp } from '../../types/tournamentTypes';\n\nexport function getCompetitionParticipants(params): ResultType & {\n  mappedMatchUps?: { [key: string]: HydratedMatchUp };\n  participantIdsWithConflicts?: string[];\n  participants?: HydratedParticipant[];\n  participantMap?: ParticipantMap;\n  matchUps?: MatchUp[];\n  derivedEventInfo?: any;\n  derivedDrawInfo?: any;\n  success?: boolean;\n} {\n  const { tournamentRecords } = params || {};\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  ) {\n    return { error: MISSING_TOURNAMENT_RECORDS };\n  }\n\n  const participants: HydratedParticipant[] = [];\n  const participantMap: ParticipantMap = {}; // turn into Map\n  const derivedEventInfo: any = {};\n  const derivedDrawInfo: any = {};\n  const matchUps: MatchUp[] = [];\n  const mappedMatchUps = {};\n\n  const participantIdsWithConflicts: string[] = [];\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const {\n      participantIdsWithConflicts: idsWithConflicts,\n      mappedMatchUps: tournamentMappedMatchUps,\n      participantMap: tournamentParticipantMap,\n      participants: tournamentParticipants,\n      matchUps: tournamentMatchUps,\n      derivedEventInfo: eventInfo,\n      derivedDrawInfo: drawInfo,\n    } = participantGetter({ ...params, tournamentRecord });\n\n    Object.assign(mappedMatchUps, tournamentMappedMatchUps);\n    Object.assign(participantMap, tournamentParticipantMap);\n    Object.assign(derivedEventInfo, eventInfo);\n    Object.assign(derivedDrawInfo, drawInfo);\n\n    /*\n    // fits the use case where participantIds are equivalent to personIds\n    for (const tournamentParticipant of tournamentParticipants ?? []) {\n      const { participantId } = tournamentParticipant;\n      if (!participantMap[participantId]) {\n        participantMap[participantId] = tournamentParticipant;\n      } else {\n        // merge participant record context across tournaments\n        participantMap[participantId] = deepMerge(tournamentParticipant, participantMap[participantId], true);\n      }\n    }\n    */\n    participants.push(...(tournamentParticipants ?? []));\n    matchUps.push(...(tournamentMatchUps ?? []));\n\n    idsWithConflicts?.forEach((participantId) => {\n      if (!participantIdsWithConflicts.includes(participantId))\n        participantIdsWithConflicts.push(participantId);\n    });\n  }\n  return {\n    participantIdsWithConflicts,\n    derivedEventInfo,\n    derivedDrawInfo,\n    participantMap,\n    mappedMatchUps,\n    participants,\n    ...SUCCESS,\n    matchUps,\n  };\n}\n","import { MISSING_TOURNAMENT_RECORDS } from '../../../constants/errorConditionConstants';\nimport { TournamentRecords } from '../../../types/factoryTypes';\nimport { Penalty } from '../../../types/tournamentTypes';\nimport { getTournamentPenalties } from './getTournamentPenalties';\n\ntype GetCompetitionPenaltiesArgs = {\n  tournamentRecords: TournamentRecords;\n};\nexport function getCompetitionPenalties({\n  tournamentRecords,\n}: GetCompetitionPenaltiesArgs) {\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const allPenalties: Penalty[] = [];\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const { penalties } = getTournamentPenalties({ tournamentRecord });\n    allPenalties.push(...(penalties ?? []));\n  }\n\n  return { penalties: allPenalties };\n}\n","import { makeDeepCopy } from '../../utilities/makeDeepCopy';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\n\n/**\n *\n * @param {string} venueId - optional -\n * @param {string[]} venueIds - optional -\n */\nexport function getCourts({ tournamentRecord, venueId, venueIds }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const courts = (tournamentRecord.venues || [])\n    .filter((venue) => {\n      if (venueId) return venue.venueId === venueId;\n      if (venueIds) return venueIds.includes(venue.venueId);\n      return true;\n    })\n    .map((venue) => {\n      const { venueId } = venue;\n      const venueCourts = makeDeepCopy(venue.courts || []);\n      venueCourts.forEach((court) => Object.assign(court, { venueId }));\n      return venueCourts;\n    })\n    .flat();\n\n  return { courts };\n}\n","import { findExtension } from '../../acquire/findExtension';\n\nexport function getDrawParticipantRepresentativeIds({ drawDefinition }) {\n  const result = findExtension({\n    name: 'participantRepresentatives',\n    element: drawDefinition,\n  });\n  if (result.error) return result;\n\n  const representativeParticipantIds = result.extension?.value || [];\n\n  return { representativeParticipantIds };\n}\n","import { getPolicyDefinitions } from '../extensions/getAppliedPolicies';\nimport { getStageEntries } from './stageGetter';\nimport { allDrawMatchUps } from '../matchUps/getAllDrawMatchUps';\nimport { allEventMatchUps } from '../matchUps/getAllEventMatchUps';\n\nimport { POLICY_TYPE_VOLUNTARY_CONSOLATION } from '../../constants/policyConstants';\nimport {\n  MAIN,\n  PLAY_OFF,\n  QUALIFYING,\n  VOLUNTARY_CONSOLATION,\n} from '../../constants/drawDefinitionConstants';\nimport { UNGROUPED, WITHDRAWN } from '../../constants/entryStatusConstants';\nimport { DOUBLE_WALKOVER } from '../../constants/matchUpStatusConstants';\nimport { PolicyDefinitions } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { HydratedSide } from '../../types/hydrated';\nimport {\n  ErrorType,\n  MISSING_DRAW_DEFINITION,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  MatchUpStatusUnion,\n  Participant,\n  StageTypeUnion,\n  Tournament,\n} from '../../types/tournamentTypes';\n\ntype GetEligibleVoluntaryConsolationParticipantsArgs = {\n  excludedMatchUpStatuses?: MatchUpStatusUnion[];\n  policyDefinitions?: PolicyDefinitions;\n  includeEventParticipants?: boolean;\n  includeQualifyingStage?: boolean;\n  tournamentRecord?: Tournament;\n  drawDefinition: DrawDefinition;\n  finishingRoundLimit?: number;\n  roundNumberLimit?: number;\n  matchUpsLimit?: number;\n  requirePlay?: boolean;\n  requireLoss?: boolean;\n  allEntries?: boolean;\n  winsLimit?: number;\n  event?: Event;\n};\n\nexport function getEligibleVoluntaryConsolationParticipants({\n  excludedMatchUpStatuses = [],\n  includeEventParticipants, // boolean - consider event entries rather than draw entries (if event is present)\n  includeQualifyingStage,\n  finishingRoundLimit,\n  policyDefinitions,\n  roundNumberLimit,\n  tournamentRecord,\n  drawDefinition,\n  matchUpsLimit,\n  requirePlay,\n  requireLoss,\n  allEntries, // boolean - consider all entries, regardless of whether placed in draw\n  winsLimit,\n  event,\n}: GetEligibleVoluntaryConsolationParticipantsArgs): {\n  eligibleParticipants?: Participant[];\n  losingParticipantIds?: string[];\n  error?: ErrorType;\n} {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const stages: StageTypeUnion[] = [MAIN, PLAY_OFF];\n  if (includeQualifyingStage) stages.push(QUALIFYING);\n\n  const eventMatchUpFilters = event?.eventType\n    ? { matchUpTypes: [event.eventType] }\n    : undefined;\n  const drawMatchUpFilters = drawDefinition?.matchUpType\n    ? { matchUpTypes: [drawDefinition.matchUpType] }\n    : undefined;\n\n  const matchUps =\n    includeEventParticipants && event\n      ? allEventMatchUps({\n          contextFilters: { stages },\n          matchUpFilters: eventMatchUpFilters,\n          tournamentRecord,\n          inContext: true,\n          event,\n        })?.matchUps ?? []\n      : allDrawMatchUps({\n          contextFilters: { stages },\n          matchUpFilters: drawMatchUpFilters,\n          tournamentRecord,\n          inContext: true,\n          drawDefinition,\n        })?.matchUps ?? [];\n\n  const voluntaryConsolationEntries = getStageEntries({\n    stage: VOLUNTARY_CONSOLATION,\n    drawDefinition,\n  });\n  const voluntaryConsolationEntryIds = voluntaryConsolationEntries.map(\n    ({ participantId }) => participantId\n  );\n\n  const participantMatchUps = {};\n  const losingParticipants = {};\n  const matchUpParticipants = {};\n  const participantWins = {};\n\n  if (!policyDefinitions) {\n    policyDefinitions = getPolicyDefinitions({\n      policyTypes: [POLICY_TYPE_VOLUNTARY_CONSOLATION],\n      tournamentRecord,\n      drawDefinition,\n      event,\n    }).policyDefinitions;\n  }\n\n  // support POLICY_TYPE_VOLUNTARY_CONSOLATION\n  const policy = policyDefinitions?.[POLICY_TYPE_VOLUNTARY_CONSOLATION];\n  excludedMatchUpStatuses =\n    (excludedMatchUpStatuses.length && excludedMatchUpStatuses) ||\n    policy?.excludedMatchUpStatuses ||\n    [];\n\n  includeEventParticipants =\n    includeEventParticipants ?? policy?.includeEventParticipants;\n  allEntries = allEntries ?? policy?.allEntries;\n  finishingRoundLimit = finishingRoundLimit ?? policy?.finishingRoundLimit;\n  roundNumberLimit = roundNumberLimit ?? policy?.roundNumberLimit;\n  matchUpsLimit = matchUpsLimit ?? policy?.matchUpsLimit;\n\n  if (requirePlay === undefined) {\n    requirePlay = policy?.requirePlay !== undefined ? policy.requirePlay : true;\n  }\n\n  if (requireLoss === undefined) {\n    requireLoss = policy?.requireLoss !== undefined ? policy.requireLoss : true;\n  }\n  // end policy support\n\n  winsLimit = winsLimit ?? policy?.winsLimit;\n\n  for (const matchUp of matchUps) {\n    if (\n      requirePlay &&\n      matchUp.winningSide &&\n      ![1, 2].includes(matchUp.winningSide) &&\n      matchUp.matchUpStatus !== DOUBLE_WALKOVER\n    )\n      continue;\n    if (\n      matchUp.finishingRound &&\n      finishingRoundLimit &&\n      matchUp.finishingRound >= finishingRoundLimit\n    )\n      continue;\n    if (\n      matchUp.finishingRound &&\n      roundNumberLimit &&\n      matchUp.finishingRound <= roundNumberLimit\n    )\n      continue;\n\n    const losingSide = matchUp.sides?.find(\n      ({ sideNumber }) =>\n        matchUp.winningSide && sideNumber === 3 - matchUp.winningSide\n    ) as HydratedSide;\n    const winningSide = matchUp.sides?.find(\n      ({ sideNumber }) =>\n        matchUp.winningSide && sideNumber === matchUp.winningSide\n    ) as HydratedSide;\n\n    matchUp.sides?.forEach((side: HydratedSide) => {\n      const participantId = side?.participant?.participantId;\n      if (participantId) {\n        matchUpParticipants[participantId] = side.participant;\n        if (matchUp.matchUpStatus === DOUBLE_WALKOVER && !requirePlay) {\n          losingParticipants[participantId] = side.participant;\n          if (!participantMatchUps[participantId])\n            participantMatchUps[participantId] = 0;\n          if (\n            !matchUp.matchUpStatus ||\n            !excludedMatchUpStatuses.includes(matchUp.matchUpStatus)\n          )\n            participantMatchUps[participantId] += 1;\n        }\n      }\n    });\n\n    if (losingSide?.participant) {\n      const participantId = losingSide.participant.participantId;\n      losingParticipants[participantId] = losingSide.participant;\n\n      if (!participantMatchUps[participantId])\n        participantMatchUps[participantId] = 0;\n\n      if (\n        matchUp.matchUpStatus &&\n        !excludedMatchUpStatuses.includes(matchUp.matchUpStatus)\n      )\n        participantMatchUps[participantId] += 1;\n    }\n\n    if (winningSide?.participant) {\n      const participantId = winningSide.participant.participantId;\n\n      if (!participantWins[participantId]) participantWins[participantId] = 0;\n      participantWins[participantId] += 1;\n\n      if (!participantMatchUps[participantId])\n        participantMatchUps[participantId] = 0;\n\n      if (\n        matchUp.matchUpStatus &&\n        !excludedMatchUpStatuses.includes(matchUp.matchUpStatus)\n      )\n        participantMatchUps[participantId] += 1;\n    }\n  }\n\n  const considerEntered =\n    tournamentRecord?.participants &&\n    !requirePlay &&\n    !requireLoss &&\n    allEntries;\n\n  const enteredParticipantIds = considerEntered\n    ? (\n        (includeEventParticipants && event\n          ? event.entries\n          : drawDefinition.entries) ?? []\n      )\n        .filter(\n          (entry: any) => ![WITHDRAWN, UNGROUPED].includes(entry.entryStatus)\n        )\n        .map(({ participantId }) => participantId)\n    : [];\n\n  const losingParticipantIds = Object.keys(losingParticipants);\n  const consideredParticipants = considerEntered\n    ? (tournamentRecord?.participants ?? []).filter(({ participantId }) =>\n        enteredParticipantIds.includes(participantId)\n      )\n    : (requireLoss && Object.values(losingParticipants)) ||\n      Object.values(matchUpParticipants);\n\n  const satisfiesLoss = (participantId) =>\n    !requireLoss || losingParticipantIds.includes(participantId);\n  const satisfiesPlay = (participantId) =>\n    !requirePlay || (participantMatchUps[participantId] || 0) >= 0;\n  const satisfiesWinsLimit = (participantId) =>\n    !winsLimit || (participantWins[participantId] || 0) <= winsLimit;\n  const satisfiesMatchUpsLimit = (participantId) =>\n    !matchUpsLimit || participantMatchUps[participantId] <= matchUpsLimit;\n  const notPreviouslySelected = (participantId) =>\n    !voluntaryConsolationEntryIds.includes(participantId);\n\n  const eligibleParticipants = consideredParticipants\n    .filter(\n      (participant: any) =>\n        satisfiesLoss(participant.participantId) &&\n        satisfiesPlay(participant.participantId) &&\n        satisfiesWinsLimit(participant.participantId) &&\n        satisfiesMatchUpsLimit(participant.participantId) &&\n        notPreviouslySelected(participant.participantId)\n    )\n    .map((participant: any) => {\n      return {\n        ...participant,\n        individualParticipants: participant.individualParticipantIds?.map(\n          (participantId) =>\n            tournamentRecord?.participants?.find(\n              (individual) => individual.participantId === participantId\n            )\n        ),\n      };\n    });\n\n  // PRESERVED for debugging\n  /*\n  const lossCheck = consideredParticipants.map(({ participantId }) =>\n    satisfiesLoss(participantId)\n  );\n  const playCheck = consideredParticipants.map(({ participantId }) =>\n    satisfiesPlay(participantId)\n  );\n  const winsCheck = consideredParticipants.map(({ participantId }) =>\n    satisfiesWinsLimit(participantId)\n  );\n  const limitCheck = consideredParticipants.map(({ participantId }) =>\n    satisfiesMatchUpsLimit(participantId)\n  );\n  const selectCheck = consideredParticipants.map(({ participantId }) =>\n    notPreviouslySelected(participantId)\n  );\n  console.log(\n    lossCheck.length,\n    playCheck.length,\n    winsCheck.length,\n    limitCheck.length,\n    selectCheck.length,\n    { requireLoss, requirePlay },\n    consideredParticipants.length,\n    losingParticipantIds.length,\n    eligibleParticipants.length\n  );\n  */\n\n  return { eligibleParticipants, losingParticipantIds, ...SUCCESS };\n}\n","import { definedAttributes } from '../../utilities/definedAttributes';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\n\nimport { DrawDefinition, Event, Tournament } from '../../types/tournamentTypes';\nimport {\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\ntype GetEventArgs = {\n  context: { [key: string]: any };\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  event: Event;\n};\n\nexport function getEvent({\n  tournamentRecord,\n  drawDefinition,\n  context,\n  event,\n}: GetEventArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n\n  const eventCopy = makeDeepCopy(event);\n  if (context) Object.assign(eventCopy, context);\n\n  const drawDefinitionCopy =\n    drawDefinition &&\n    eventCopy.drawDefinitions?.find(\n      ({ drawId }) => drawDefinition.drawId === drawId\n    );\n\n  return definedAttributes({\n    drawDefinition: drawDefinitionCopy,\n    event: eventCopy,\n  });\n}\n","import { isValidMatchUpFormat } from '../../../validators/isValidMatchUpFormat';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { getMatchUpFormatTiming } from './getMatchUpFormatTiming';\nimport { findExtension } from '../../../acquire/findExtension';\nimport { findPolicy } from '../../../acquire/findPolicy';\nimport { unique } from '../../../utilities/arrays';\n\nimport POLICY_SCHEDULING_DEFAULT from '../../../fixtures/policies/POLICY_SCHEDULING_DEFAULT';\nimport { SCHEDULE_TIMING } from '../../../constants/extensionConstants';\nimport { Event, Tournament } from '../../../types/tournamentTypes';\nimport {\n  ErrorType,\n  MISSING_EVENT,\n} from '../../../constants/errorConditionConstants';\nimport {\n  POLICY_TYPE_SCHEDULING,\n  POLICY_TYPE_SCORING,\n} from '../../../constants/policyConstants';\n\ntype GetEventMatchUpFormatTimingArgs = {\n  tournamentRecord: Tournament;\n  matchUpFormats?: string[];\n  categoryType?: string;\n  event: Event;\n};\n\nexport function getEventMatchUpFormatTiming({\n  tournamentRecord,\n  matchUpFormats, // optional - can be retrieved from policy\n  categoryType, // optional - categoryType is not part of event attributes\n  event,\n}: GetEventMatchUpFormatTimingArgs): {\n  eventMatchUpFormatTiming?: any;\n  error?: ErrorType;\n  info?: string;\n} {\n  if (!event) return { error: MISSING_EVENT };\n\n  let matchUpFormatDefinitions: any[] = [];\n  let info;\n\n  if (!matchUpFormats?.length) {\n    const { policy } = findPolicy({\n      policyType: POLICY_TYPE_SCORING,\n      tournamentRecord,\n      event,\n    });\n    if (policy?.matchUpFormats) {\n      matchUpFormatDefinitions = policy?.matchUpFormats;\n    } else {\n      const { extension } = findExtension({\n        name: SCHEDULE_TIMING,\n        element: event,\n      });\n      let matchUpAverageTimes, matchUpRecoveryTimes;\n      if (extension?.value) {\n        ({ matchUpAverageTimes, matchUpRecoveryTimes } = extension.value);\n      } else {\n        ({ matchUpAverageTimes, matchUpRecoveryTimes } =\n          POLICY_SCHEDULING_DEFAULT[POLICY_TYPE_SCHEDULING]);\n      }\n      matchUpFormatDefinitions = unique(\n        [\n          ...(matchUpAverageTimes || []).map((at) => at.matchUpFormatCodes),\n          ...(matchUpRecoveryTimes || []).map((at) => at.matchUpFormatCodes),\n        ].flat()\n      ).map((matchUpFormat) => ({ matchUpFormat }));\n      info = 'default scheduling policy in use';\n    }\n  } else {\n    const uniqueMatchUpFormats: any[] = [];\n    matchUpFormatDefinitions = matchUpFormats\n      .map((definition) => {\n        const definitionObject =\n          typeof definition === 'string'\n            ? { matchUpFormat: definition }\n            : definition;\n\n        if (uniqueMatchUpFormats.includes(definitionObject?.matchUpFormat))\n          return;\n        if (\n          !isValidMatchUpFormat({\n            matchUpFormat: definitionObject?.matchUpFormat,\n          })\n        )\n          return;\n        uniqueMatchUpFormats.push(definitionObject.matchUpFormat);\n        return definitionObject;\n      })\n      .filter(Boolean);\n  }\n  const { eventType, eventId, category } = event;\n  const categoryName =\n    category?.categoryName ?? category?.ageCategoryCode ?? eventId;\n\n  if (!eventId) return { error: MISSING_EVENT };\n\n  const eventMatchUpFormatTiming = matchUpFormatDefinitions.map(\n    ({ matchUpFormat, description }) => {\n      const timing = getMatchUpFormatTiming({\n        tournamentRecord,\n        matchUpFormat,\n        categoryName,\n        categoryType,\n        eventType,\n        event,\n      });\n      return {\n        matchUpFormat,\n        description,\n        ...timing,\n      };\n    }\n  );\n\n  return definedAttributes({ eventMatchUpFormatTiming, info });\n}\n","import { participantScaleItem } from '../participant/participantScaleItem';\n\nimport { RANKING, RATING, SEEDING } from '../../constants/timeItemConstants';\nimport {\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\nexport function getEventProperties({ tournamentRecord, event }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!event) return { error: MISSING_EVENT };\n\n  const eventEntries = event.entries || [];\n  const tournamentParticipants = tournamentRecord.participants || [];\n\n  const scaleName =\n    event.category?.categoryName || event.category?.ageCategoryCode;\n  const { eventType } = event;\n\n  const enteredParticipantIds = eventEntries.map(\n    (entry) => entry.participantId\n  );\n  const enteredParticipants = tournamentParticipants.filter((participant) =>\n    enteredParticipantIds.includes(participant.participantId)\n  );\n\n  let hasSeededParticipants, hasRankedParticipants, hasRatedParticipants;\n  const entryScaleAttributes = enteredParticipants.map((participant) => {\n    const { participantId, participantName, name } = participant;\n\n    let scaleAttributes = { scaleType: SEEDING, eventType, scaleName };\n    const seed = participantScaleItem({ participant, scaleAttributes })\n      ?.scaleItem?.scaleValue;\n    scaleAttributes = { scaleType: RANKING, eventType, scaleName };\n    const ranking = participantScaleItem({ participant, scaleAttributes })\n      ?.scaleItem?.scaleValue;\n    scaleAttributes = { scaleType: RATING, eventType, scaleName };\n    const rating = participantScaleItem({ participant, scaleAttributes })\n      ?.scaleItem?.scaleValue;\n\n    hasSeededParticipants = !!(hasSeededParticipants || seed);\n    hasRankedParticipants = !!(hasRankedParticipants || ranking);\n    hasRatedParticipants = !!(hasRatedParticipants || rating);\n    return {\n      participantId,\n      participantName: participantName || name, // support legacy\n      seed,\n      ranking,\n      rating,\n    };\n  });\n\n  return {\n    entryScaleAttributes,\n    hasSeededParticipants,\n    hasRankedParticipants,\n    hasRatedParticipants,\n  };\n}\n","import { getAssignedParticipantIds } from '../drawDefinition/getAssignedParticipantIds';\nimport { definedAttributes } from '../../utilities/definedAttributes';\nimport { xa } from '../../utilities/objects';\nimport { getParticipants } from '../participants/getParticipants';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { getFlightProfile } from '../event/getFlightProfile';\nimport { median } from '../../utilities/math';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\nimport { STRUCTURE_SELECTED_STATUSES } from '../../constants/entryStatusConstants';\nimport { Event, Tournament, EventTypeUnion } from '../../types/tournamentTypes';\nimport ratingsParameters from '../../fixtures/ratings/ratingsParameters';\nimport { PARTICIPANT_ID } from '../../constants/attributeConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { INDIVIDUAL } from '../../constants/participantConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { intersection } from '../../utilities/arrays';\n\nexport type RankingStat = {\n  median: number;\n  avg: number;\n  max: number;\n  min: number;\n};\n\nexport type EventScaleValues = {\n  [key: string]: {\n    ratingsStats: { [key: string]: RankingStat };\n    ratings: { [key: string]: number[] };\n    ranking: { [key: string]: any };\n    draws: {\n      [key: string]: {\n        ratingsStats: { [key: string]: RankingStat };\n        ratings: { [key: string]: number[] };\n        ranking: { [key: string]: any };\n      };\n    };\n  };\n};\n\ntype GetEventsArgs = {\n  tournamentRecord: Tournament;\n  withScaleValues?: boolean;\n  scaleEventType?: EventTypeUnion;\n  inContext?: boolean;\n  eventIds?: string[];\n  drawIds?: string[];\n  context?: any;\n};\n\nexport function getEvents({\n  tournamentRecord,\n  withScaleValues,\n  scaleEventType,\n  inContext, // hydrate with tournamentId\n  eventIds, // only return events with these eventIds\n  drawIds, // only return events with these drawIds, and only drawDefinitions with these drawIds\n  context, // additional context to add to each event\n}: GetEventsArgs): ResultType & {\n  eventScaleValues?: EventScaleValues;\n  events?: Event[];\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const { tournamentId } = tournamentRecord;\n  const eventCopies = (tournamentRecord.events ?? [])\n    .filter(({ eventId }) => !eventIds || (Array.isArray(eventIds) && eventIds.includes(eventId)))\n    .map((event) => {\n      const eventDrawIds = event.drawDefinitions?.map(xa('drawId'));\n      if (drawIds?.length && !intersection(drawIds, eventDrawIds).length) return;\n      const eventCopy = makeDeepCopy(event);\n      if (inContext) Object.assign(eventCopy, { tournamentId });\n      if (context) Object.assign(eventCopy, context);\n      return eventCopy;\n    })\n    .filter(Boolean);\n\n  const eventsMap = {};\n\n  if (withScaleValues) {\n    const participantMap = getParticipants({\n      withScaleValues: true,\n      tournamentRecord,\n    }).participantMap;\n\n    const sum = (values) => values.reduce((total, value) => total + parseFloat(value), 0);\n\n    for (const event of eventCopies) {\n      const eventType = scaleEventType ?? event.eventType;\n      const eventId = event.eventId;\n\n      if (!eventsMap[eventId])\n        eventsMap[eventId] = {\n          ratingsStats: {},\n          ratings: {},\n          ranking: {},\n          draws: {},\n        };\n\n      const selectedEntries = (event.entries ?? []).filter(({ entryStatus }) =>\n        STRUCTURE_SELECTED_STATUSES.includes(entryStatus),\n      );\n      const participantIds = selectedEntries.map(xa(PARTICIPANT_ID));\n\n      const processParticipant = (participant) => {\n        if (participant?.ratings?.[eventType]) {\n          for (const rating of participant?.ratings?.[eventType] ?? []) {\n            const scaleName = rating.scaleName;\n            if (!eventsMap[eventId].ratings[scaleName]) eventsMap[eventId].ratings[scaleName] = [];\n            const accessor = ratingsParameters[scaleName]?.accessor;\n            if (accessor) {\n              const value = parseFloat(rating.scaleValue?.[accessor]);\n              if (value) eventsMap[eventId].ratings[scaleName].push(value);\n            }\n          }\n        }\n        if (participant?.rankings?.[eventType]) {\n          for (const ranking of participant?.rankings?.[eventType] ?? []) {\n            const scaleName = ranking.scaleName;\n            if (!eventsMap[eventId].ranking[scaleName]) eventsMap[eventId].ranking[scaleName] = [];\n            if (ranking.scaleValue) eventsMap[eventId].ranking[scaleName].push(ranking.scaleValue);\n          }\n        }\n      };\n\n      for (const participantId of participantIds) {\n        const participant = participantMap?.[participantId]?.participant;\n        if (participant?.participantType !== INDIVIDUAL) {\n          for (const individualParticipantId of participant?.individualParticipantIds ?? []) {\n            const individualParticipant = participantMap?.[individualParticipantId]?.participant;\n            processParticipant(individualParticipant);\n          }\n        } else {\n          processParticipant(participant);\n        }\n      }\n\n      // add stats for all event-level entries ratings\n      const ratings = eventsMap[eventId].ratings;\n      for (const scaleName of Object.keys(ratings)) {\n        const scaleRating = ratings[scaleName];\n        if (!scaleRating.length) continue;\n        const med = median(scaleRating)?.toFixed(2);\n        eventsMap[eventId].ratingsStats[scaleName] = {\n          avg: parseFloat((sum(scaleRating) / scaleRating.length).toFixed(2)),\n          median: med ? parseFloat(med) : undefined,\n          max: Math.max(...scaleRating),\n          min: Math.min(...scaleRating),\n        };\n      }\n\n      const processFlight = (drawId, participantIds) => {\n        const processParticipant = (participant) => {\n          if (eventsMap[eventId].draws?.[drawId] && participant?.ratings?.[eventType]) {\n            for (const rating of participant?.ratings?.[eventType] ?? []) {\n              const scaleName = rating.scaleName;\n              if (!eventsMap[eventId].draws[drawId]?.ratings[scaleName])\n                eventsMap[eventId].draws[drawId].ratings[scaleName] = [];\n              const accessor = ratingsParameters[scaleName]?.accessor;\n              if (accessor) {\n                const value = parseFloat(rating.scaleValue?.[accessor]);\n                if (value) {\n                  eventsMap[eventId].draws[drawId].ratings[scaleName].push(value);\n                }\n              }\n            }\n          }\n          if (eventsMap[eventId].draws?.[drawId] && participant?.rankings?.[eventType]) {\n            for (const ranking of participant?.rankings?.[eventType] ?? []) {\n              const scaleName = ranking.scaleName;\n              if (!eventsMap[eventId].draws[drawId]?.ranking[scaleName])\n                eventsMap[eventId].draws[drawId].ranking[scaleName] = [];\n              const value = ranking.scaleValue;\n              if (value) {\n                eventsMap[eventId].draws[drawId].ranking[scaleName].push(value);\n              }\n            }\n          }\n        };\n        for (const participantId of participantIds.filter(Boolean)) {\n          const participant = participantMap?.[participantId]?.participant;\n          if (participant?.participantType !== INDIVIDUAL) {\n            for (const individualParticipantId of participant?.individualParticipantIds ?? []) {\n              const individualParticipant = participantMap?.[individualParticipantId]?.participant;\n              processParticipant(individualParticipant);\n            }\n          } else {\n            processParticipant(participant);\n          }\n        }\n      };\n\n      const processedDrawIds: string[] = [];\n      const ignoreDrawId = (drawId) =>\n        (drawIds?.length && drawIds.includes(drawId)) || processedDrawIds.includes(drawId);\n      for (const drawDefinition of event.drawDefinitions ?? []) {\n        const drawId: string = drawDefinition.drawId;\n        if (ignoreDrawId(drawId)) continue;\n\n        const participantIds =\n          getAssignedParticipantIds({\n            drawDefinition,\n          }).assignedParticipantIds ?? [];\n        if (!eventsMap[eventId].draws[drawId])\n          eventsMap[eventId].draws[drawId] = {\n            ratingsStats: {},\n            ratings: {},\n            ranking: {},\n          };\n        processedDrawIds.push(drawId);\n        processFlight(drawId, participantIds);\n      }\n\n      const flightProfile = getFlightProfile({ event }).flightProfile;\n      for (const flight of flightProfile?.flights ?? []) {\n        const drawId = flight.drawId;\n        if (ignoreDrawId(drawId)) continue;\n        const participantIds = flight.drawEntries.map(xa(PARTICIPANT_ID));\n        processFlight(drawId, participantIds);\n      }\n\n      for (const drawId of processedDrawIds) {\n        const ratings = eventsMap[eventId].draws[drawId].ratings;\n        for (const scaleName of Object.keys(ratings)) {\n          const scaleRating = ratings[scaleName];\n          if (!scaleRating.length) continue;\n          const med = median(scaleRating)?.toFixed(2);\n          eventsMap[eventId].draws[drawId].ratingsStats[scaleName] = {\n            avg: parseFloat((sum(scaleRating) / scaleRating.length).toFixed(2)),\n            median: med ? parseFloat(med) : undefined,\n            max: Math.max(...scaleRating),\n            min: Math.min(...scaleRating),\n          };\n        }\n      }\n    }\n  }\n\n  return definedAttributes({\n    eventScaleValues: eventsMap,\n    events: eventCopies,\n    ...SUCCESS,\n  });\n}\n","import { getExtensionUpdate } from './getExtensionUpdate';\n\nimport { SCHEDULE_LIMITS } from '../../constants/extensionConstants';\n\nexport function getMatchUpDailyLimitsUpdate({ tournamentRecords }) {\n  return getExtensionUpdate({\n    extensionName: SCHEDULE_LIMITS,\n    tournamentRecords,\n  });\n}\n","import { checkRequiredParameters } from '../../parameters/checkRequiredParameters';\nimport { resolveFromParameters } from '../../parameters/resolveFromParameters';\nimport { findStructure } from '../../acquire/findStructure';\n\nimport { MISSING_DRAW_ID, MISSING_VALUE } from '../../constants/errorConditionConstants';\nimport { DrawDefinition, Event, Tournament } from '../../types/tournamentTypes';\nimport {\n  ANY_OF,\n  DRAW_ID,\n  ERROR,\n  EVENT,\n  MATCHUP,\n  MATCHUP_ID,\n  PARAM,\n  STRUCTURE_ID,\n  TOURNAMENT_RECORD,\n} from '../../constants/attributeConstants';\n\ntype GetMatchUpFormatArgs = {\n  tournamentRecord: Tournament;\n  drawDefinition?: DrawDefinition;\n  structureId?: string;\n  matchUpId?: string;\n  eventId?: string;\n  drawId?: string;\n  event?: Event;\n};\n\nexport function getMatchUpFormat(params: GetMatchUpFormatArgs) {\n  const { structureId, matchUpId, event } = params;\n  let drawDefinition = params.drawDefinition;\n\n  const paramCheck = checkRequiredParameters(params, [\n    { [TOURNAMENT_RECORD]: true },\n    {\n      [ANY_OF]: {\n        [STRUCTURE_ID]: false,\n        [MATCHUP_ID]: false,\n        [DRAW_ID]: false,\n        [EVENT]: false,\n      },\n    },\n  ]);\n  if (paramCheck[ERROR]) return paramCheck;\n\n  const resolutions = resolveFromParameters(params, [{ [PARAM]: MATCHUP, [ERROR]: MISSING_VALUE }]);\n  const matchUpResult = resolutions?.matchUp;\n\n  if (matchUpId && matchUpResult?.error) {\n    return matchUpResult;\n  } else if (!drawDefinition && matchUpResult?.drawDefinition) {\n    drawDefinition = matchUpResult?.drawDefinition;\n  }\n\n  let structure = matchUpResult?.structure;\n  if (!structure && structureId && !matchUpId) {\n    if (!drawDefinition) return { error: MISSING_DRAW_ID };\n    const structureResult = findStructure({ drawDefinition, structureId });\n    if (structureResult.error) return structureResult;\n    structure = structureResult.structure;\n  }\n\n  const structureDefaultMatchUpFormat = structure?.matchUpFormat;\n  const drawDefaultMatchUpFormat = drawDefinition?.matchUpFormat;\n  const eventDefaultMatchUpFormat = event?.matchUpFormat;\n  const matchUpFormat =\n    matchUpResult?.matchUp?.matchUpFormat ||\n    structureDefaultMatchUpFormat ||\n    drawDefaultMatchUpFormat ||\n    eventDefaultMatchUpFormat;\n\n  return {\n    structureDefaultMatchUpFormat,\n    eventDefaultMatchUpFormat,\n    drawDefaultMatchUpFormat,\n    matchUpFormat,\n  };\n}\n","import { getExtensionUpdate } from '../getExtensionUpdate';\n\nimport { SCHEDULE_TIMING } from '../../../constants/extensionConstants';\n\nexport function getMatchUpFormatTimingUpdate({ tournamentRecords }) {\n  return getExtensionUpdate({\n    extensionName: SCHEDULE_TIMING,\n    tournamentRecords,\n  });\n}\n","import { validMatchUps } from '../../validators/validMatchUp';\nimport {\n  getBand,\n  getScoreComponents,\n  pctSpread,\n} from '../matchUp/scoreComponents';\nimport { findPolicy } from '../../acquire/findPolicy';\n\nimport POLICY_COMPETITIVE_BANDS_DEFAULT from '../../fixtures/policies/POLICY_COMPETITIVE_BANDS_DEFAULT';\nimport { POLICY_TYPE_COMPETITIVE_BANDS } from '../../constants/policyConstants';\nimport { MISSING_MATCHUPS } from '../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  COMPETITIVE,\n  DECISIVE,\n  RETIRED,\n  ROUTINE,\n  WALKOVER,\n} from '../../constants/statsConstants';\n\nexport function getMatchUpsStats({ profileBands, tournamentRecord, matchUps }) {\n  if (!validMatchUps(matchUps)) return { error: MISSING_MATCHUPS };\n\n  const policy =\n    !profileBands &&\n    findPolicy({\n      policyType: POLICY_TYPE_COMPETITIVE_BANDS,\n      tournamentRecord,\n    }).policy;\n\n  const bandProfiles =\n    profileBands ||\n    policy?.profileBands ||\n    POLICY_COMPETITIVE_BANDS_DEFAULT[POLICY_TYPE_COMPETITIVE_BANDS]\n      .profileBands;\n\n  const relevantMatchUps = matchUps.filter(({ winningSide }) => winningSide);\n\n  const gamesMap = relevantMatchUps.map(getScoreComponents);\n\n  const categorize = (p, spread) => {\n    const band = getBand(spread, bandProfiles);\n    p[band] += 1;\n    return p;\n  };\n\n  const pctspd: { [key: string]: number } = pctSpread(gamesMap).reduce(\n    (p, c) => categorize(p, c),\n    {\n      [COMPETITIVE]: 0,\n      [ROUTINE]: 0,\n      [DECISIVE]: 0,\n      [WALKOVER]: 0,\n    }\n  );\n  const total: number = Object.keys(pctspd).reduce(\n    (a, k) => (pctspd[k] || 0) + a,\n    0\n  );\n\n  const competitiveBands: any = Object.keys(pctspd).map((k: any) => {\n    const value = parseFloat((pctspd[k] / total).toFixed(4));\n    return {\n      [k]: value * 100,\n    };\n  });\n\n  const retiredCount = relevantMatchUps.filter(\n    ({ matchUpStatus }) => matchUpStatus === RETIRED\n  ).length;\n\n  competitiveBands.push({\n    [RETIRED]: parseFloat((retiredCount / total).toFixed(4)) * 100,\n  });\n\n  return {\n    competitiveBands: Object.assign({}, ...competitiveBands),\n    ...SUCCESS,\n  };\n}\n","import { ensureInt } from '../../utilities/ensureInt';\n\nexport function getMaxEntryPosition(params) {\n  const { entries = [], entryStatus, stage } = params;\n  return Math.max(\n    ...entries\n      .filter(\n        (entry) =>\n          (!stage || stage === entry.entryStage) &&\n          (!entryStatus || entry.entryStatus === entryStatus) &&\n          !isNaN(entry.entryPosition)\n      )\n      .map(({ entryPosition }) => ensureInt(entryPosition || 0)),\n    0\n  );\n}\n","import { overlap } from '../../utilities/arrays';\n\nimport { PAIR, TEAM } from '../../constants/participantConstants';\nimport {\n  MISSING_PARTICIPANT_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\nimport { Tournament } from '../../types/tournamentTypes';\nimport { ResultType } from '../../global/functions/decorateResult';\n\n/**\n * Returns { eventDetails: { eventName, eventId }} for events in which participantId or TEAM/PAIR including participantId appears\n */\n\ntype getParticipantEventDetailsType = {\n  tournamentRecord: Tournament;\n  participantId: string;\n};\n\nexport function getParticipantEventDetails({\n  tournamentRecord,\n  participantId,\n}: getParticipantEventDetailsType): ResultType & {\n  eventDetails?: { eventName?: string; eventId: string }[];\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!participantId) return { error: MISSING_PARTICIPANT_ID };\n\n  // relveantParticipantIds is the target participantId along with any TEAM or PAIR participantIds to which participantId belongs\n  const relevantParticipantIds = [participantId].concat(\n    (tournamentRecord.participants ?? [])\n      .filter(\n        (participant) =>\n          participant?.participantType &&\n          [TEAM, PAIR].includes(participant.participantType) &&\n          participant.individualParticipantIds?.includes(participantId)\n      )\n      .map((participant) => participant.participantId)\n  );\n\n  const relevantEvents = (tournamentRecord.events ?? [])\n    .filter((event) => {\n      const enteredParticipantIds = (event?.entries ?? []).map(\n        (entry) => entry.participantId\n      );\n      return overlap(enteredParticipantIds, relevantParticipantIds);\n    })\n    .map((event) => ({ eventName: event.eventName, eventId: event.eventId }));\n\n  return { eventDetails: relevantEvents };\n}\n","import { getParticipantIdMatchUps } from './participantIdMatchUps';\n\nimport { MISSING_DRAW_DEFINITION } from '../../constants/errorConditionConstants';\nimport { BYE, COMPLETED } from '../../constants/matchUpStatusConstants';\nimport { DrawDefinition, Tournament } from '../../types/tournamentTypes';\n\ntype GetParticipantIdFinishingPositionsArgs = {\n  tournamentRecord: Tournament;\n  drawDefinition: DrawDefinition;\n  byeAdvancements?: boolean;\n};\nexport function getParticipantIdFinishingPositions({\n  byeAdvancements = false,\n  tournamentRecord,\n  drawDefinition,\n}: GetParticipantIdFinishingPositionsArgs) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const { participantIds, participantIdMatchUps } = getParticipantIdMatchUps({\n    tournamentParticipants: tournamentRecord?.participants,\n    drawDefinition,\n  });\n\n  const participantIdFinishingPositions = participantIds.map(\n    (participantId) => {\n      const matchUps = participantIdMatchUps[participantId];\n      const relevantMatchUps = matchUps.filter(\n        (matchUp) =>\n          [COMPLETED, BYE].includes(matchUp.matchUpStatus) ||\n          matchUp.winningSide\n      );\n      const finishingPositionRanges = relevantMatchUps.map((matchUp) => {\n        const isByeMatchUp = matchUp.sides.find((side) => side.bye);\n        const participantSide = matchUp.sides.find(\n          (side) => side.participantId === participantId\n        ).sideNumber;\n\n        const advancingSide =\n          matchUp.winningSide ||\n          (byeAdvancements && isByeMatchUp && participantSide);\n\n        return advancingSide === participantSide\n          ? matchUp.finishingPositionRange.winner\n          : matchUp.finishingPositionRange.loser;\n      });\n\n      const diff = (range) => Math.abs(range[0] - range[1]);\n      const finishingPositionRange = finishingPositionRanges.reduce(\n        (finishingPositionRange, range) => {\n          if (!finishingPositionRange) return range;\n          return diff(finishingPositionRange) < diff(range)\n            ? finishingPositionRange\n            : range;\n        },\n        undefined\n      );\n\n      return {\n        [participantId]: {\n          relevantMatchUps,\n          finishingPositionRanges,\n          finishingPositionRange,\n        },\n      };\n    }\n  );\n\n  return Object.assign({}, ...participantIdFinishingPositions);\n}\n","import { getAllDrawMatchUps } from '../matchUps/drawMatchUps';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { unique } from '../../utilities/arrays';\n\nimport { MISSING_DRAW_DEFINITION } from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  Participant,\n} from '../../types/tournamentTypes';\n\ntype GetParticipantIdMatchUps = {\n  tournamentParticipants?: Participant[];\n  drawDefinition: DrawDefinition;\n  event?: Event;\n};\nexport function getParticipantIdMatchUps({\n  tournamentParticipants,\n  drawDefinition,\n  event,\n}: GetParticipantIdMatchUps) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const result = getAllDrawMatchUps({\n    tournamentParticipants,\n    inContext: true,\n    drawDefinition,\n    event,\n  });\n\n  const allMatchUps = makeDeepCopy(result.matchUps, false, true);\n\n  const participantIds = unique(\n    allMatchUps.reduce((participantIds, matchUp) => {\n      return participantIds.concat(\n        ...matchUp.sides.map((side) => side.participantId).filter(Boolean)\n      );\n    }, [])\n  );\n\n  const participantIdMatchUps = Object.assign(\n    {},\n    ...participantIds.map((participantId) => {\n      const matchUps = allMatchUps.filter((matchUp) => {\n        const participantIds = matchUp.sides\n          .map((side) => side.participantId)\n          .filter(Boolean);\n        return participantIds.includes(participantId);\n      });\n      return { [participantId]: matchUps };\n    })\n  );\n\n  return { participantIds, participantIdMatchUps };\n}\n","import { getParticipants } from './getParticipants';\n\nimport { GROUP, PAIR, TEAM } from '../../constants/participantConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { Tournament } from '../../types/tournamentTypes';\nimport {\n  MISSING_PARTICIPANT_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\n// Returns all grouping participants which include individual participantId\n\ntype GetMembershipArgs = {\n  tournamentRecord: Tournament;\n  participantId: string;\n};\n\nexport function getParticipantMembership({\n  tournamentRecord,\n  participantId,\n}: GetMembershipArgs): ResultType | { [key: string]: string[] } {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!participantId) return { error: MISSING_PARTICIPANT_ID };\n\n  const { participants } = getParticipants({\n    participantFilters: { participantTypes: [TEAM, PAIR, GROUP] },\n    tournamentRecord,\n  });\n\n  const memberOf = (participants ?? []).filter((participant) => {\n    return participant.individualParticipantIds?.includes(participantId);\n  });\n\n  return memberOf.reduce((groupingTypesMap, participant) => {\n    const participantType = participant.participantType;\n    if (participantType) {\n      if (!groupingTypesMap[participantType])\n        groupingTypesMap[participantType] = [];\n\n      groupingTypesMap[participantType].push(participant);\n    }\n    return groupingTypesMap;\n  }, {});\n}\n","import { getMatchUpDependencies } from '../matchUps/getMatchUpDependencies';\nimport { allTournamentMatchUps } from '../matchUps/getAllTournamentMatchUps';\n\nimport { Tournament } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_OBJECT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\ntype GetParticipantSchedulesArgs = {\n  tournamentRecord: Tournament;\n  participantFilters?: any;\n};\nexport function getParticipantSchedules({\n  participantFilters = {},\n  tournamentRecord,\n}: GetParticipantSchedulesArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  if (typeof participantFilters !== 'object')\n    return { error: INVALID_OBJECT, context: { participantFilters } };\n\n  const contextFilters = { eventIds: participantFilters.eventIds };\n  const matchUps =\n    allTournamentMatchUps({\n      tournamentRecord,\n      contextFilters,\n    }).matchUps ?? [];\n\n  const matchUpsMap = Object.assign(\n    {},\n    ...matchUps.map((matchUp) => ({ [matchUp.matchUpId]: matchUp }))\n  );\n\n  const scheduledMatchUps = matchUps.filter(\n    ({ schedule }) => schedule && Object.keys(schedule).length\n  );\n\n  const sourceMatchUpIds =\n    getMatchUpDependencies({\n      tournamentRecord,\n      matchUps,\n    }).sourceMatchUpIds ?? [];\n\n  const participantAggregator = {};\n  for (const matchUp of scheduledMatchUps) {\n    const { sides } = matchUp;\n    let relevantSourceMatchUps;\n\n    const participants =\n      sides\n        ?.map((side: any) => {\n          if (side.participant) {\n            return [side.participant].concat(\n              ...(side.participant.individualParticipants || [])\n            );\n          } else if (\n            sourceMatchUpIds[matchUp.matchUpId] &&\n            !relevantSourceMatchUps\n          ) {\n            relevantSourceMatchUps = (sourceMatchUpIds[matchUp.matchUpId] || [])\n              .map((matchUpId) => matchUpsMap[matchUpId])\n              .filter(({ winningSide, bye }) => !winningSide && !bye);\n          }\n          return undefined;\n        })\n        .filter(Boolean)\n        .flat() ?? [];\n\n    for (const participant of participants) {\n      const { participantId } = participant;\n      if (!participantAggregator[participantId]) {\n        participantAggregator[participantId] = {\n          potentialMatchUps: [],\n          participant,\n          matchUps: [],\n        };\n      }\n\n      participantAggregator[participantId].matchUps.push(matchUp);\n    }\n\n    const potentialParticipants =\n      relevantSourceMatchUps\n        ?.map(({ sides }) => sides)\n        .flat()\n        .map(\n          ({ participant }) =>\n            participant &&\n            [participant].concat(...(participant.individualParticipants || []))\n        )\n        .filter(Boolean)\n        .flat() || [];\n\n    for (const participant of potentialParticipants) {\n      const { participantId } = participant;\n      if (!participantAggregator[participantId]) {\n        participantAggregator[participantId] = {\n          potentialMatchUps: [],\n          participant,\n          matchUps: [],\n        };\n      }\n\n      participantAggregator[participantId].potentialMatchUps.push(matchUp);\n    }\n  }\n\n  const aggregators: any[] = Object.values(participantAggregator);\n  const participantSchedules = aggregators.filter(({ participant }) => {\n    return !(\n      (participantFilters.participantIds &&\n        !participantFilters.participantIds.includes(\n          participant.participantId\n        )) ||\n      (participantFilters.participantTypes &&\n        !participantFilters.participantTypes.includes(\n          participant.participantType\n        ))\n    );\n  });\n\n  return {\n    participantSchedules,\n    ...SUCCESS,\n  };\n}\n","import { findTournamentParticipant } from '../../acquire/findTournamentParticipant';\nimport { getTimeItem } from '../base/timeItems';\n\nimport {\n  MISSING_PARTICIPANT_ID,\n  MISSING_TOURNAMENT_RECORD,\n  PARTICIPANT_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\nimport {\n  SIGNED_IN,\n  SIGN_IN_STATUS,\n} from '../../constants/participantConstants';\n\nexport function getParticipantSignInStatus({\n  tournamentRecord,\n  participantId,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!participantId) return { error: MISSING_PARTICIPANT_ID };\n\n  const { participant } = findTournamentParticipant({\n    tournamentRecord,\n    participantId,\n  });\n\n  if (!participant) return { error: PARTICIPANT_NOT_FOUND };\n\n  const { timeItem } = getTimeItem({\n    itemType: SIGN_IN_STATUS,\n    element: participant,\n  });\n\n  return timeItem && timeItem.itemValue === SIGNED_IN && SIGNED_IN;\n}\n","import { getFinishingPositionDetails, getRoundId, getRoundProfile, getRoundTiming } from './schedulingUtils';\nimport { allCompetitionMatchUps } from '../../matchUps/getAllCompetitionMatchUps';\nimport { getProfileRounds } from '../../../mutate/matchUps/schedule/profileRounds';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { roundSort } from '../../../functions/sorters/roundSort';\nimport { extractDate } from '../../../utilities/dateTime';\nimport { chunkArray } from '../../../utilities/arrays';\n\nimport { MatchUpFilters } from '../../../types/factoryTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { Tournament } from '../../../types/tournamentTypes';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  INVALID_TOURNAMENT_RECORD,\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../../constants/errorConditionConstants';\n\ntype GetRoundsArgs = {\n  tournamentRecords?: { [key: string]: Tournament };\n  excludeScheduleDateProfileRounds?: string;\n  inContextMatchUps?: HydratedMatchUp[];\n  excludeScheduledRounds?: boolean;\n  excludeCompletedRounds?: boolean;\n  context?: { [key: string]: any };\n  matchUpFilters?: MatchUpFilters;\n  tournamentRecord?: Tournament;\n  withSplitRounds?: boolean;\n  schedulingProfile?: any;\n  scheduleDate?: string;\n  withRoundId?: boolean;\n  venueId?: string;\n};\n\nexport function getRounds({\n  excludeScheduleDateProfileRounds,\n  excludeScheduledRounds,\n  excludeCompletedRounds,\n  inContextMatchUps,\n  tournamentRecords,\n  schedulingProfile,\n  tournamentRecord,\n  withSplitRounds,\n  matchUpFilters,\n  scheduleDate,\n  withRoundId,\n  venueId,\n  context,\n}: GetRoundsArgs) {\n  if (inContextMatchUps && !Array.isArray(inContextMatchUps || typeof inContextMatchUps[0] !== 'object')) {\n    return { error: INVALID_VALUES, inContextMatchUps };\n  }\n\n  if (tournamentRecord && !tournamentRecords) {\n    if (typeof tournamentRecord !== 'object') {\n      return { error: INVALID_TOURNAMENT_RECORD };\n    } else {\n      tournamentRecords = { [tournamentRecord.tournamentId]: tournamentRecord };\n    }\n  }\n\n  const noTournamentRecords = typeof tournamentRecords !== 'object' || !Object.keys(tournamentRecords).length;\n\n  const needsTournamentRecords =\n    venueId ||\n    scheduleDate ||\n    !inContextMatchUps ||\n    (!schedulingProfile &&\n      (excludeScheduleDateProfileRounds || excludeCompletedRounds || schedulingProfile || withSplitRounds));\n\n  if (needsTournamentRecords && noTournamentRecords) return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const tournamentVenueIds = Object.assign(\n    {},\n    ...Object.values(tournamentRecords ?? {}).map(({ venues = [], tournamentId }) => ({\n      [tournamentId]: venues?.map(({ venueId }) => venueId),\n    })),\n  );\n\n  const events = Object.values(tournamentRecords ?? {})\n    .map(({ events = [], tournamentId, startDate, endDate }) =>\n      events.map((event) => ({\n        ...event,\n        validVenueIds: tournamentVenueIds[tournamentId],\n        startDate: event.startDate ?? startDate,\n        endDate: event.endDate ?? endDate,\n      })),\n    )\n    .flat();\n\n  const { segmentedRounds, profileRounds } =\n    (tournamentRecords &&\n      (excludeScheduleDateProfileRounds || excludeCompletedRounds || schedulingProfile || withSplitRounds) &&\n      getProfileRounds({ tournamentRecords, schedulingProfile })) ||\n    {};\n\n  const profileRoundsMap =\n    excludeScheduleDateProfileRounds &&\n    Object.assign({}, ...profileRounds.map((profile) => ({ [profile.id]: profile })));\n\n  const consideredMatchUps =\n    inContextMatchUps ||\n    (tournamentRecords && allCompetitionMatchUps({ tournamentRecords, matchUpFilters })?.matchUps) ||\n    [];\n\n  const excludedRounds: any[] = [];\n\n  const rounds =\n    (consideredMatchUps &&\n      Object.values(\n        consideredMatchUps.reduce((rounds, matchUp) => {\n          const id = getRoundId(matchUp).id;\n          const segmentsCount = segmentedRounds?.[id];\n          const matchUps = [...(rounds[id]?.matchUps ?? []), matchUp];\n          const {\n            containerStructureId,\n            stageSequence,\n            structureName,\n            tournamentId,\n            isRoundRobin,\n            matchUpType,\n            roundNumber,\n            roundOffset,\n            structureId,\n            eventName,\n            roundName,\n            drawName,\n            eventId,\n            drawId,\n          } = matchUp;\n          const relevantStructureId = isRoundRobin ? containerStructureId : structureId;\n          return {\n            ...rounds,\n            [id]: {\n              id: withRoundId ? id : undefined,\n              structureId: relevantStructureId,\n              stageSequence,\n              segmentsCount,\n              structureName,\n              tournamentId,\n              matchUpType,\n              roundNumber,\n              roundOffset,\n              eventName,\n              roundName,\n              drawName,\n              matchUps,\n              eventId,\n              drawId,\n            },\n          };\n        }, {}),\n      )\n        .map((round: any) => {\n          const { minFinishingSum, winnerFinishingPositionRange } = getFinishingPositionDetails(round.matchUps);\n          const segmentsCount = round.segmentsCount;\n\n          if (segmentsCount) {\n            const chunkSize = round.matchUps.length / segmentsCount;\n            const sortedMatchUps = chunkArray(\n              round.matchUps.sort((a, b) => a.roundPosition - b.roundPosition),\n              chunkSize,\n            );\n            return sortedMatchUps.map((matchUps, i) => {\n              const { unscheduledCount, incompleteCount, matchUpsCount, isScheduled, isComplete, byeCount } =\n                getRoundProfile(matchUps);\n\n              const roundTiming = getRoundTiming({\n                matchUps: round.matchUps,\n                tournamentRecords,\n                events,\n                round,\n              });\n\n              return definedAttributes({\n                ...round,\n                ...context,\n                roundSegment: { segmentsCount, segmentNumber: i + 1 },\n                winnerFinishingPositionRange,\n                unscheduledCount,\n                incompleteCount,\n                minFinishingSum,\n                matchUpsCount,\n                isScheduled,\n                roundTiming,\n                isComplete,\n                byeCount,\n                matchUps,\n              });\n            });\n          }\n\n          const { unscheduledCount, incompleteCount, matchUpsCount, isScheduled, isComplete, byeCount } =\n            getRoundProfile(round.matchUps);\n          const roundTiming = getRoundTiming({\n            matchUps: round.matchUps,\n            tournamentRecords,\n            events,\n            round,\n          });\n          return definedAttributes({\n            ...round,\n            ...context,\n            winnerFinishingPositionRange,\n            unscheduledCount,\n            incompleteCount,\n            minFinishingSum,\n            matchUpsCount,\n            isScheduled,\n            roundTiming,\n            isComplete,\n            byeCount,\n          });\n        })\n        .flat()\n        .filter((round) => {\n          if (excludeScheduleDateProfileRounds) {\n            const scheduleDate = extractDate(excludeScheduleDateProfileRounds);\n            const roundId = withRoundId ? round.id : getRoundId(round).id;\n            if (\n              scheduleDate &&\n              profileRoundsMap[roundId] &&\n              extractDate(profileRoundsMap[roundId].scheduleDate) === scheduleDate\n            ) {\n              return false;\n            }\n          }\n          const { isComplete, isScheduled } = round;\n          const keepComplete = !excludeCompletedRounds || !isComplete;\n          const keepScheduled = !excludeScheduledRounds || !isScheduled;\n          const event = venueId || scheduleDate ? events?.find(({ eventId }) => eventId === round.eventId) : undefined;\n\n          const startDate = event?.startDate ?? tournamentRecord?.startDate;\n          const endDate = event?.endDate ?? tournamentRecord?.endDate;\n          const validStartDate = !scheduleDate || !startDate || new Date(scheduleDate) >= new Date(startDate);\n          const validEndDate = !scheduleDate || !endDate || new Date(scheduleDate) <= new Date(endDate);\n          const validDate = validStartDate && validEndDate;\n\n          const validVenue = !venueId || event?.validVenueIds.includes(venueId);\n\n          const keepRound = keepComplete && keepScheduled && validVenue && validDate;\n          if (!keepRound) excludedRounds.push(round);\n\n          return keepRound;\n        })\n        .sort(roundSort)) ||\n    [];\n\n  return { ...SUCCESS, rounds, excludedRounds };\n}\n","import { getSchedulingProfile } from '../../../mutate/tournaments/schedulingProfile';\nimport { allCompetitionMatchUps } from '../../matchUps/getAllCompetitionMatchUps';\nimport { getMatchUpDependencies } from '../../matchUps/getMatchUpDependencies';\nimport { getScheduledRoundsDetails } from './getScheduledRoundsDetails';\nimport { intersection, unique } from '../../../utilities/arrays';\nimport { isValidDateString } from '../../../utilities/dateTime';\n\nimport { TournamentRecords } from '../../../types/factoryTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_DATE,\n  INVALID_TOURNAMENT_RECORD,\n  INVALID_VALUES,\n} from '../../../constants/errorConditionConstants';\n\ntype GetSchedulingProfileIssuesArgs = {\n  tournamentRecords: TournamentRecords;\n  scheduleDates?: string[];\n  periodLength?: number;\n};\nexport function getSchedulingProfileIssues(\n  params?: GetSchedulingProfileIssuesArgs\n) {\n  const {\n    scheduleDates = [],\n    tournamentRecords,\n    periodLength = 30,\n  } = params ?? {};\n\n  if (typeof tournamentRecords !== 'object')\n    return { error: INVALID_TOURNAMENT_RECORD };\n  if (!Array.isArray(scheduleDates)) return { error: INVALID_VALUES };\n\n  const validDates = scheduleDates.every(isValidDateString);\n  if (!validDates) return { error: INVALID_DATE };\n\n  const issues: any[] = [];\n  let issuesCount = 0;\n  const roundIndexShouldBeAfter = {};\n\n  const { schedulingProfile } = getSchedulingProfile({ tournamentRecords });\n  if (!schedulingProfile) return { issues, ...SUCCESS };\n\n  const { matchUps } = allCompetitionMatchUps({\n    nextMatchUps: true,\n    tournamentRecords,\n  });\n\n  // for each date check the rounds for each venue\n  for (const dateProfile of schedulingProfile) {\n    const { scheduleDate, venues = [] } = dateProfile;\n\n    // skip scheduleDates that are not specified; process all if none specified\n    if (!scheduleDates?.length || scheduleDates.includes(scheduleDate)) {\n      for (const venue of venues || []) {\n        if (venue) {\n          const { rounds } = venue;\n          const schedulingErrors: any = [];\n          const { orderedMatchUpIds, scheduledRoundsDetails } =\n            getScheduledRoundsDetails({\n              tournamentRecords,\n              periodLength,\n              matchUps,\n              rounds,\n            });\n          const { matchUpDependencies } = getMatchUpDependencies({\n            tournamentRecords,\n            matchUps,\n          });\n          const getRoundIndex = (matchUpId) => {\n            let roundIndex;\n            scheduledRoundsDetails?.find((round, index) => {\n              const includes = round.matchUpIds.includes(matchUpId);\n              if (includes) roundIndex = index;\n              return includes;\n            });\n            return roundIndex;\n          };\n\n          orderedMatchUpIds?.forEach((matchUpId, index) => {\n            const followingMatchUpIds = orderedMatchUpIds.slice(index + 1);\n            const shouldBeAfter = intersection(\n              followingMatchUpIds,\n              matchUpDependencies?.[matchUpId]?.matchUpIds || []\n            );\n            if (shouldBeAfter.length)\n              schedulingErrors.push({ matchUpId, shouldBeAfter });\n          });\n          if (schedulingErrors.length) {\n            issuesCount += schedulingErrors.length;\n            const errorsDetail = schedulingErrors.map(\n              ({ matchUpId, shouldBeAfter }) => {\n                const matchUpRoundIndex = getRoundIndex(matchUpId);\n                const earlierRoundIndices = unique(\n                  shouldBeAfter.map(getRoundIndex)\n                );\n\n                if (!roundIndexShouldBeAfter[scheduleDate]) {\n                  roundIndexShouldBeAfter[scheduleDate] = {};\n                }\n                if (!roundIndexShouldBeAfter[scheduleDate][matchUpRoundIndex])\n                  roundIndexShouldBeAfter[scheduleDate][matchUpRoundIndex] = [];\n                earlierRoundIndices.forEach((index) => {\n                  if (\n                    !roundIndexShouldBeAfter[scheduleDate][\n                      matchUpRoundIndex\n                    ].includes(index)\n                  ) {\n                    roundIndexShouldBeAfter[scheduleDate][\n                      matchUpRoundIndex\n                    ].push(index);\n                  }\n                });\n\n                return {\n                  matchUpId,\n                  matchUpRoundIndex,\n                  earlierRoundIndices,\n                  shouldBeAfter,\n                };\n              }\n            );\n\n            issues.push(...errorsDetail);\n          }\n        }\n      }\n    }\n  }\n\n  const profileIssues = {\n    matchUpIdShouldBeAfter: Object.assign(\n      {},\n      ...issues.map((issue) => {\n        const { matchUpId, shouldBeAfter, earlierRoundIndices } = issue;\n        return {\n          [matchUpId]: { earlierRoundIndices, shouldBeAfter },\n        };\n      })\n    ),\n  };\n\n  return { issuesCount, profileIssues, roundIndexShouldBeAfter, ...SUCCESS };\n}\n","import { resolveTieFormat } from './tieFormats/resolveTieFormat';\nimport { copyTieFormat } from './tieFormats/copyTieFormat';\nimport { decorateResult } from '../../global/functions/decorateResult';\nimport { publicFindMatchUp } from '../../acquire/findMatchUp';\nimport { findStructure } from '../../acquire/findStructure';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ErrorType,\n  MISSING_DRAW_ID,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n} from '../../constants/errorConditionConstants';\nimport {\n  DrawDefinition,\n  Event,\n  MatchUp,\n  Structure,\n  TieFormat,\n  Tournament,\n} from '../../types/tournamentTypes';\n\n// NOTE: method exclusively for external use\n\ntype GetTieFormatArgs = {\n  tournamentRecord: Tournament;\n  drawDefinition?: DrawDefinition;\n  structure?: Structure;\n  structureId?: string;\n  matchUpId: string;\n  eventId?: string;\n  drawId?: string;\n  event?: Event;\n};\nexport function getTieFormat({\n  tournamentRecord, // passed in automatically by tournamentEngine\n  drawDefinition, // passed in automatically by tournamentEngine when drawId provided\n  structureId, // optional - if only the default matchUpFormat for a structure is required\n  matchUpId, // id of matchUp for which the scoped matchUpFormat(s) are desired\n  structure, // optional optimization - when structure already known\n  eventId, // optional - if only the default matchUpFormat for an event is required\n  drawId, // avoid brute force search for matchUp\n  event, // passed in automatically by tournamentEngine when drawId or eventId provided\n}: GetTieFormatArgs): {\n  structureDefaultTieFormat?: TieFormat;\n  eventDefaultTieFormat?: TieFormat;\n  drawDefaultTieFormat?: TieFormat;\n  tieFormat?: TieFormat;\n  structure?: Structure;\n  error?: ErrorType;\n  success?: boolean;\n  matchUp?: MatchUp;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!drawId && !event && !structureId && !matchUpId)\n    return decorateResult({\n      result: { error: MISSING_VALUE },\n      stack: 'getTieFormat',\n    });\n\n  if (eventId && !event) {\n    event = tournamentRecord.events?.find((event) => event.eventId === eventId);\n  }\n\n  const matchUpResult = publicFindMatchUp({\n    tournamentRecord,\n    drawDefinition,\n    matchUpId,\n    drawId,\n    event,\n  });\n\n  if (matchUpId && matchUpResult?.error) {\n    return matchUpResult;\n  } else if (!drawDefinition && matchUpResult?.drawDefinition) {\n    drawDefinition = matchUpResult?.drawDefinition;\n  }\n\n  structure = structure ?? matchUpResult?.structure;\n  if (!structure && structureId && !matchUpId) {\n    if (!drawDefinition) return { error: MISSING_DRAW_ID };\n    const structureResult = findStructure({ drawDefinition, structureId });\n    if (structureResult.error) return structureResult;\n    structure = structureResult.structure;\n  }\n\n  const structureDefaultTieFormat =\n    (structure?.tieFormat || structure?.tieFormatId) &&\n    resolveTieFormat({ structure, drawDefinition, event })?.tieFormat;\n  const drawDefaultTieFormat =\n    (drawDefinition?.tieFormat || drawDefinition?.tieFormatId) &&\n    resolveTieFormat({\n      drawDefinition,\n      event,\n    })?.tieFormat;\n  const eventDefaultTieFormat = resolveTieFormat({ event })?.tieFormat;\n\n  const tieFormat = resolveTieFormat({\n    matchUp: matchUpResult?.matchUp,\n    drawDefinition,\n    structure,\n    event,\n  })?.tieFormat;\n\n  return {\n    ...SUCCESS,\n    matchUp: matchUpResult?.matchUp,\n    structureDefaultTieFormat: copyTieFormat(structureDefaultTieFormat),\n    eventDefaultTieFormat: copyTieFormat(eventDefaultTieFormat),\n    drawDefaultTieFormat: copyTieFormat(drawDefaultTieFormat),\n    tieFormat: copyTieFormat(tieFormat),\n    structure,\n  };\n}\n","import { filterParticipants } from '../participants/filterParticipants';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\n\nexport function getTournamentPersons({ tournamentRecord, participantFilters }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  let tournamentParticipants = tournamentRecord.participants || [];\n\n  if (participantFilters)\n    tournamentParticipants = filterParticipants({\n      participants: tournamentParticipants,\n      participantFilters,\n      tournamentRecord,\n    });\n\n  const tournamentPersons = {};\n\n  const extractPerson = (participant) => {\n    if (participant.person) {\n      const { personId } = participant.person;\n      if (tournamentPersons[personId]) {\n        // case where personId is used for multiple participants, e.g. COMPETITOR as well as OFFICIAL\n        tournamentPersons[personId].participantIds.push(\n          participant.participantId\n        );\n      } else {\n        tournamentPersons[personId] = {\n          ...participant.person,\n          participantIds: [participant.participantId],\n        };\n      }\n    }\n  };\n\n  tournamentParticipants.forEach((participant) => {\n    if (participant.person) extractPerson(participant);\n  });\n\n  return { tournamentPersons: Object.values(tournamentPersons) };\n}\n","import { generateTimeSlots } from '../../assemblies/generators/scheduling/generateTimeSlots';\nimport { getVenuesAndCourts } from './venuesAndCourtsGetter';\nimport { allCompetitionMatchUps } from '../matchUps/getAllCompetitionMatchUps';\nimport {\n  addMinutesToTimeString,\n  extractTime,\n  isValidDateString,\n  sameDay,\n  timeStringMinutes,\n} from '../../utilities/dateTime';\n\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport {\n  INVALID_DATE,\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../constants/errorConditionConstants';\n\ntype GetVenueReportArgs = {\n  tournamentRecords: TournamentRecords;\n  ignoreDisabled?: boolean;\n  tournamentId?: string;\n  venueIds?: string[];\n  dates?: string[];\n};\nexport function getVenuesReport({\n  ignoreDisabled = true,\n  tournamentRecords,\n  tournamentId,\n  venueIds = [],\n  dates = [],\n}: GetVenueReportArgs) {\n  if (!Array.isArray(dates)) return { error: INVALID_VALUES, dates };\n  if (!Array.isArray(venueIds)) return { error: INVALID_VALUES, venueIds };\n\n  const tournamentIds =\n    (tournamentRecords &&\n      Object.keys(tournamentRecords).filter(\n        (id) => !tournamentId || id === tournamentId\n      )) ||\n    [];\n  if (!tournamentIds.length) return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const validDates = dates.every(isValidDateString);\n  if (!validDates) return { error: INVALID_DATE };\n\n  const result = getVenuesAndCourts({\n    tournamentRecords,\n    ignoreDisabled,\n    dates,\n  });\n  if (result.error) return result;\n\n  const venues = result?.venues?.filter(\n    ({ venueId }) => !venueIds?.length || venueIds.includes(venueId)\n  );\n\n  const courtDates = result.courts\n    ?.reduce((dates: string[], court) => {\n      court.dateAvailability?.forEach((availability: any) => {\n        const date: string = availability.date;\n        if (!dates.includes(date)) dates.push(date);\n      });\n      return dates;\n    }, [])\n    .filter((date) => !dates.length || dates.includes(date));\n\n  const matchUpFilters = { venueIds: venues?.map(({ venueId }) => venueId) };\n  const { matchUps } = allCompetitionMatchUps({\n    afterRecoveryTimes: true,\n    tournamentRecords,\n    matchUpFilters,\n  });\n\n  const venuesReport = venues?.map((venue) =>\n    getVenueReport(courtDates, venue, matchUps)\n  );\n  return { venuesReport };\n}\n\nfunction getVenueReport(dates, venue, matchUps) {\n  const { venueId, courts, venueName } = venue;\n\n  const venueReport = {};\n\n  dates.forEach((date) => {\n    // for each venue court calculate the available minutes on specified date\n    let availableMinutes = 0,\n      scheduledMinutes = 0,\n      availableCourts = 0;\n    for (const court of courts) {\n      const courtDate = court.dateAvailability.find(\n        (availability) => availability.date === date\n      );\n      const timeSlots = courtDate && generateTimeSlots({ courtDate });\n      const courtAvailableMinutes = timeSlots?.reduce((minutes, timeSlot) => {\n        const { startTime, endTime } = timeSlot;\n        const timeSlotMinutes =\n          timeStringMinutes(endTime) - timeStringMinutes(startTime);\n        return minutes + timeSlotMinutes;\n      }, 0);\n      if (courtAvailableMinutes) availableCourts += 1;\n      availableMinutes += courtAvailableMinutes;\n    }\n    const venueMatchUps = matchUps.filter(\n      ({ schedule }) =>\n        schedule.venueId === venueId && sameDay(date, schedule.scheduledDate)\n    );\n    venueMatchUps.forEach(({ schedule }) => {\n      const startTime = extractTime(schedule.scheduledTime);\n      const endTime = addMinutesToTimeString(\n        startTime,\n        schedule.averageMinutes\n      );\n      const matchUpScheduledMinutes =\n        timeStringMinutes(endTime) - timeStringMinutes(startTime);\n      scheduledMinutes += matchUpScheduledMinutes;\n    });\n\n    const percentUtilization = availableMinutes\n      ? ((scheduledMinutes / availableMinutes) * 100).toFixed(2)\n      : '100';\n    venueReport[date] = {\n      scheduledMatchUpsCount: venueMatchUps.length,\n      availableCourts,\n      availableMinutes,\n      scheduledMinutes,\n      percentUtilization,\n    };\n  });\n\n  return {\n    venueId,\n    venueName,\n    venueReport,\n  };\n}\n","import { getStructureLinks } from '../../query/drawDefinition/linkGetter';\nimport { intersection } from '../../utilities/arrays';\nimport { isString } from '../../utilities/objects';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  BOTTOM_UP,\n  RANDOM,\n  TOP_DOWN,\n  WATERFALL,\n} from '../../constants/drawDefinitionConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_DRAW_DEFINITION,\n} from '../../constants/errorConditionConstants';\n\nexport function isValidForQualifying({ structureId, drawDefinition }) {\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!isString(structureId)) return { error: INVALID_VALUES };\n\n  const result = getStructureLinks({\n    drawDefinition,\n    structureId,\n  });\n  if (result.error) return result;\n\n  const targetFeedProfiles = result.links.target\n    .flatMap((t) => t.target.feedProfile)\n    .filter(Boolean);\n\n  const valid = !intersection(\n    [BOTTOM_UP, TOP_DOWN, RANDOM, WATERFALL],\n    targetFeedProfiles\n  ).length;\n\n  return { ...SUCCESS, valid };\n}\n","import { hasSchedule } from '../../mutate/matchUps/schedule/scheduleMatchUps/hasSchedule';\nimport { validMatchUps } from '../../validators/validMatchUp';\nimport { extractDate, extractTime, timeSort } from '../../utilities/dateTime';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport {\n  INVALID_VALUES,\n  MISSING_MATCHUPS,\n} from '../../constants/errorConditionConstants';\n\n/**\n * Retrieves the scheduled matchUps for participants.\n *\n * @param {Object} options - The options for retrieving scheduled match-ups.\n * @param {string[]} options.scheduleAttributes - The attributes to include in the schedule.\n * @param {HydratedMatchUp[]} options.matchUps - The match-ups to filter and sort.\n *\n * @returns {Object} - The scheduled match-ups organized by scheduled date and sorted by scheduled time.\n * @property {Object} scheduledMatchUps - The scheduled match-ups organized by scheduled date and sorted by scheduled time.\n * @property {string[]} scheduledMatchUps[date] - The match-ups scheduled for the specified date.\n */\n\ntype ParticiapntScheduledMatchUps = {\n  scheduleAttributes?: string[];\n  matchUps?: HydratedMatchUp[];\n};\n\nexport function participantScheduledMatchUps({\n  scheduleAttributes = ['scheduledDate', 'scheduledTime'],\n  matchUps = [],\n}: ParticiapntScheduledMatchUps) {\n  if (!validMatchUps(matchUps)) return { error: MISSING_MATCHUPS };\n  if (!Array.isArray(scheduleAttributes)) return { error: INVALID_VALUES };\n\n  const scheduledMatchUps = matchUps\n    .filter(Boolean)\n    .filter(({ schedule }) => hasSchedule({ schedule, scheduleAttributes }))\n    .reduce((dateMatchUps, matchUp) => {\n      const { schedule } = matchUp;\n      const date = extractDate(schedule?.scheduledDate);\n      const time = extractTime(schedule?.scheduledTime);\n      if (date && time) {\n        if (dateMatchUps[date]) {\n          dateMatchUps[date].push(matchUp);\n        } else {\n          dateMatchUps[date] = [matchUp];\n        }\n      }\n      return dateMatchUps;\n    }, {});\n\n  // sort all date matchUps\n  const dates = Object.keys(scheduledMatchUps);\n  dates.forEach((date) => {\n    scheduledMatchUps[date].sort((a, b) =>\n      timeSort(\n        extractTime(a.schedule?.scheduledTime),\n        extractTime(b.schedule?.scheduledTime)\n      )\n    );\n  });\n\n  return { ...SUCCESS, scheduledMatchUps };\n}\n","import { getSourceStructureIdsAndRelevantLinks } from '../../structure/getSourceStructureIdsAndRelevantLinks';\nimport { getStructureDrawPositionProfiles } from '../../structure/getStructureDrawPositionProfiles';\nimport { getAppliedPolicies } from '../../extensions/getAppliedPolicies';\nimport { getStructureSeedAssignments } from '../../structure/getStructureSeedAssignments';\nimport { getAssignedParticipantIds } from '../getAssignedParticipantIds';\nimport { getValidModifyAssignedPairAction } from './getValidModifyAssignedPairAction';\nimport { structureAssignedDrawPositions } from '../positionsGetter';\nimport { MatchUpsMap } from '../../matchUps/getMatchUpsMap';\nimport { getValidLuckyLosersAction } from './getValidLuckyLoserAction';\nimport { getValidAlternatesAction } from './getValidAlternatesAction';\nimport { getValidAssignmentActions } from './participantAssignments';\nimport { getValidQualifiersAction } from './getValidQualifiersAction';\nimport { isValidSeedPosition } from '../seedGetter';\nimport { getStageEntries } from '../stageGetter';\nimport { findStructure } from '../../../acquire/findStructure';\nimport { isCompletedStructure } from '../structureActions';\nimport { getValidSwapAction } from './getValidSwapAction';\nimport { matchUpActions } from '../matchUpActions/matchUpActions';\nimport {\n  activePositionsCheck,\n  getEnabledStructures,\n  getPolicyActions,\n  isAvailableAction,\n  POSITION_ACTION,\n} from './actionPolicyUtils';\n\nimport { DIRECT_ENTRY_STATUSES } from '../../../constants/entryStatusConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { PolicyDefinitions } from '../../../types/factoryTypes';\nimport { PAIR } from '../../../constants/participantConstants';\nimport { HydratedMatchUp } from '../../../types/hydrated';\nimport {\n  INVALID_DRAW_POSITION,\n  MISSING_DRAW_DEFINITION,\n  MISSING_DRAW_POSITION,\n  MISSING_EVENT,\n  MISSING_STRUCTURE_ID,\n  STRUCTURE_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\nimport {\n  ADD_NICKNAME_METHOD,\n  ADD_NICKNAME,\n  ADD_PENALTY_METHOD,\n  ADD_PENALTY,\n  ALTERNATE_PARTICIPANT,\n  ASSIGN_BYE,\n  ASSIGN_PARTICIPANT,\n  LUCKY_PARTICIPANT,\n  REMOVE_ASSIGNMENT_METHOD,\n  REMOVE_ASSIGNMENT,\n  SEED_VALUE_METHOD,\n  SEED_VALUE,\n  SWAP_PARTICIPANTS,\n  WITHDRAW_PARTICIPANT_METHOD,\n  WITHDRAW_PARTICIPANT,\n  QUALIFYING_PARTICIPANT,\n  MODIFY_PAIR_ASSIGNMENT,\n  REMOVE_SEED,\n  REMOVE_SEED_METHOD,\n} from '../../../constants/positionActionConstants';\nimport { CONSOLATION, MAIN, POSITION, QUALIFYING, WIN_RATIO } from '../../../constants/drawDefinitionConstants';\nimport { DrawDefinition, Event, Participant, Tournament } from '../../../types/tournamentTypes';\nimport { getParticipants } from '../../participants/getParticipants';\n\ntype PositionActionsArgs = {\n  inContextDrawMatchUps?: HydratedMatchUp[];\n  restrictAdHocRoundParticipants?: boolean;\n  tournamentParticipants?: Participant[];\n  policyDefinitions?: PolicyDefinitions;\n  provisionalPositioning?: boolean;\n  tournamentRecord?: Tournament;\n  returnParticipants?: boolean;\n  drawDefinition: DrawDefinition;\n  matchUpsMap?: MatchUpsMap;\n  drawPosition: number;\n  structureId: string;\n  matchUpId?: string;\n  event?: Event;\n};\n\n/**\n * Calculates the valid actions for a draw position based on the provided parameters.\n *\n * @param params - The parameters for calculating the position actions.\n * @returns An object containing the valid actions for the draw position.\n */\nexport function positionActions(params: PositionActionsArgs): ResultType & {\n  isActiveDrawPosition?: boolean;\n  hasPositionAssigned?: boolean;\n  isDrawPosition?: boolean;\n  isByePosition?: boolean;\n  validActions?: any[];\n} {\n  const {\n    policyDefinitions: specifiedPolicyDefinitions,\n    returnParticipants = true,\n    provisionalPositioning,\n    tournamentRecord,\n    drawDefinition,\n    drawPosition,\n    event,\n  } = params;\n\n  if (!event) return { error: MISSING_EVENT };\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n  if (!params.structureId) return { error: MISSING_STRUCTURE_ID };\n\n  const tournamentParticipants =\n    params.tournamentParticipants ??\n    (tournamentRecord &&\n      getParticipants({\n        withIndividualParticipants: true,\n        tournamentRecord,\n      }).participants) ??\n    [];\n\n  let result: any = findStructure({\n    structureId: params.structureId,\n    drawDefinition,\n  });\n  if (result.error) return result;\n\n  const structure = result.containingStructure || result.structure;\n  if (!structure) return { error: STRUCTURE_NOT_FOUND };\n\n  const structureId = structure.structureId;\n\n  result = getStructureDrawPositionProfiles({\n    drawDefinition,\n    structureId,\n  });\n\n  if (drawPosition === undefined && !result.isAdHoc) {\n    return { error: MISSING_DRAW_POSITION };\n  }\n\n  if (result.isAdHoc) return matchUpActions(params);\n  if (result.error) return result;\n\n  const {\n    drawPositionInitialRounds,\n    // qualifyingDrawPositions,\n    inactiveDrawPositions,\n    activeDrawPositions,\n    byeDrawPositions,\n  } = result;\n\n  const appliedPolicies =\n    getAppliedPolicies({\n      tournamentRecord,\n      drawDefinition,\n      structure,\n      event,\n    }).appliedPolicies ?? {};\n\n  Object.assign(appliedPolicies, specifiedPolicyDefinitions ?? {});\n\n  const {\n    actionsPolicy: positionActionsPolicy,\n    enabledStructures,\n    actionsDisabled,\n  } = getEnabledStructures({\n    actionType: POSITION_ACTION,\n    appliedPolicies,\n    drawDefinition,\n    structure,\n  });\n\n  const activePositionOverrides = positionActionsPolicy?.activePositionOverrides || [];\n\n  // targetRoundNumber will be > 1 for fed positions\n  const { sourceStructureIds: positionSourceStructureIds } =\n    getSourceStructureIdsAndRelevantLinks({\n      finishingPosition: WIN_RATIO,\n      targetRoundNumber: 1,\n      linkType: POSITION,\n      drawDefinition,\n      structureId,\n    }) || {};\n\n  let sourceStructuresComplete;\n  if (positionSourceStructureIds?.length) {\n    // EVERY: this can probably be changed to .every\n    sourceStructuresComplete = positionSourceStructureIds.reduce((ready, sourceStructureId) => {\n      const completed = isCompletedStructure({\n        structureId: sourceStructureId,\n        drawDefinition,\n      });\n      return completed && ready;\n    }, true);\n  }\n\n  const isWinRatioFedStructure = positionSourceStructureIds.length;\n  const disablePlacementActions = positionSourceStructureIds.length && !sourceStructuresComplete;\n\n  const { policyActions } = getPolicyActions({\n    enabledStructures,\n    drawDefinition,\n    structure,\n  });\n\n  const possiblyDisablingAction = ![QUALIFYING, MAIN].includes(structure.stage) || structure.stageSequence !== 1;\n\n  const { drawId } = drawDefinition;\n  const validActions: any[] = [];\n\n  const { assignedPositions, positionAssignments } = structureAssignedDrawPositions({ structure });\n  const positionAssignment = assignedPositions?.find((assignment) => assignment.drawPosition === drawPosition);\n\n  const drawPositions = positionAssignments?.map((assignment) => assignment.drawPosition);\n\n  if (!drawPositions?.includes(drawPosition)) return { error: INVALID_DRAW_POSITION };\n\n  const { stage, stageSequence } = structure;\n\n  const stages = [stage];\n\n  // allow unassigneParticipantIds from MAIN in positionActions for consolation\n  if (stage === CONSOLATION) stages.push(MAIN);\n  if (stage === MAIN) stages.push(CONSOLATION);\n\n  const stageEntries = getStageEntries({\n    entryStatuses: DIRECT_ENTRY_STATUSES,\n    provisionalPositioning,\n    drawDefinition,\n    stageSequence,\n    structureId,\n    stages,\n  });\n\n  const stageAssignedParticipantIds =\n    getAssignedParticipantIds({\n      drawDefinition,\n      stages,\n    }).assignedParticipantIds ?? [];\n\n  const unassignedParticipantIds = stageEntries\n    .filter((entry) => !stageAssignedParticipantIds.includes(entry.participantId))\n    .map((entry) => entry.participantId);\n\n  const isByePosition = byeDrawPositions.includes(drawPosition);\n  const isActiveDrawPosition = activeDrawPositions.includes(drawPosition);\n\n  if (actionsDisabled)\n    return {\n      hasPositionAssigned: !!positionAssignment,\n      info: 'Actions Disabled for structure',\n      isActiveDrawPosition,\n      isDrawPosition: true,\n      validActions: [],\n      isByePosition,\n    };\n\n  if (\n    isAvailableAction({ policyActions, action: ASSIGN_PARTICIPANT }) &&\n    !isActiveDrawPosition &&\n    positionAssignments &&\n    !disablePlacementActions &&\n    (!positionAssignment || isByePosition)\n  ) {\n    const { validAssignmentActions } = getValidAssignmentActions({\n      positionSourceStructureIds,\n      unassignedParticipantIds,\n      possiblyDisablingAction,\n      isWinRatioFedStructure,\n      tournamentParticipants,\n      positionAssignments,\n      returnParticipants,\n      appliedPolicies,\n      drawDefinition,\n      isByePosition,\n      drawPosition,\n      structureId,\n      event,\n    });\n    validAssignmentActions?.forEach((action) => validActions.push(action));\n  }\n\n  if (isAvailableAction({ policyActions, action: QUALIFYING_PARTICIPANT })) {\n    const { validAssignmentActions } = getValidQualifiersAction({\n      drawPositionInitialRounds,\n      tournamentParticipants,\n      positionAssignments,\n      returnParticipants,\n      appliedPolicies,\n      drawDefinition,\n      drawPosition,\n      structureId,\n      drawId,\n    });\n    validAssignmentActions?.forEach((action) => validActions.push(action));\n  }\n\n  const { participantId } = positionAssignment || {};\n  const participant =\n    participantId && tournamentParticipants.find((participant) => participant.participantId === participantId);\n\n  if (positionAssignment) {\n    if (isAvailableAction({ policyActions, action: REMOVE_ASSIGNMENT }) && !isActiveDrawPosition) {\n      validActions.push({\n        type: REMOVE_ASSIGNMENT,\n        method: REMOVE_ASSIGNMENT_METHOD,\n        payload: { drawId, structureId, drawPosition },\n        willDisableLinks: possiblyDisablingAction,\n      });\n\n      if (!isByePosition) {\n        validActions.push({\n          type: WITHDRAW_PARTICIPANT,\n          method: WITHDRAW_PARTICIPANT_METHOD,\n          payload: { drawId, structureId, drawPosition },\n          willDisableLinks: possiblyDisablingAction,\n        });\n      }\n\n      // in this case the ASSIGN_BYE_METHOD is called after removing assigned participant\n      // option should not be available if exising assignment is a bye\n      if (isAvailableAction({ policyActions, action: ASSIGN_BYE }) && !isByePosition) {\n        validActions.push({\n          type: ASSIGN_BYE,\n          method: REMOVE_ASSIGNMENT_METHOD,\n          payload: { drawId, structureId, drawPosition, replaceWithBye: true },\n          willDisableLinks: possiblyDisablingAction,\n        });\n      }\n    }\n\n    const validToAssignSeed =\n      structure.stage === QUALIFYING || (structure.stage === MAIN && structure.stageSequence === 1);\n\n    if (\n      !isByePosition &&\n      // if any drawPositions are active, action is disabled unless override in policy\n      activePositionsCheck({\n        activePositionOverrides,\n        activeDrawPositions,\n        action: SEED_VALUE,\n      }) &&\n      isAvailableAction({ policyActions, action: SEED_VALUE }) &&\n      isValidSeedPosition({ drawDefinition, structureId, drawPosition }) &&\n      validToAssignSeed\n    ) {\n      const { seedAssignments } = getStructureSeedAssignments({\n        returnAllProxies: true,\n        drawDefinition,\n        structure,\n      });\n      const { seedNumber, seedValue } =\n        seedAssignments?.find((assignment) => assignment.participantId === participantId) ?? {};\n\n      validActions.push({\n        type: SEED_VALUE,\n        method: SEED_VALUE_METHOD,\n        participant,\n        seedNumber,\n        payload: {\n          drawId,\n          structureId,\n          participantId,\n          seedValue,\n        },\n      });\n    }\n\n    if (\n      !isByePosition &&\n      // if any drawPositions are active, action is disabled unless override in policy\n      activePositionsCheck({\n        activePositionOverrides,\n        activeDrawPositions,\n        action: REMOVE_SEED,\n      }) &&\n      isAvailableAction({ policyActions, action: REMOVE_SEED }) &&\n      isValidSeedPosition({ drawDefinition, structureId, drawPosition }) &&\n      validToAssignSeed\n    ) {\n      const { seedAssignments } = getStructureSeedAssignments({\n        returnAllProxies: true,\n        drawDefinition,\n        structure,\n      });\n      const { seedNumber } = seedAssignments?.find((assignment) => assignment.participantId === participantId) ?? {};\n\n      validActions.push({\n        method: REMOVE_SEED_METHOD,\n        type: REMOVE_SEED,\n        participant,\n        seedNumber,\n        payload: {\n          participantId,\n          structureId,\n          drawId,\n        },\n      });\n    }\n\n    if (!isByePosition && participantId) {\n      if (isAvailableAction({ policyActions, action: ADD_PENALTY })) {\n        const addPenaltyAction = {\n          type: ADD_PENALTY,\n          method: ADD_PENALTY_METHOD,\n          participant,\n          payload: {\n            penaltyCode: undefined,\n            penaltyType: undefined,\n            participantIds: [],\n            notes: undefined,\n            drawId,\n          },\n        };\n        validActions.push(addPenaltyAction);\n      }\n      if (isAvailableAction({ policyActions, action: ADD_NICKNAME })) {\n        const addNicknameAction = {\n          type: ADD_NICKNAME,\n          method: ADD_NICKNAME_METHOD,\n          participant,\n          payload: {\n            participantId,\n            otherName: undefined,\n          },\n        };\n        validActions.push(addNicknameAction);\n      }\n    }\n\n    if (isAvailableAction({ policyActions, action: SWAP_PARTICIPANTS })) {\n      const { validSwapAction } = getValidSwapAction({\n        possiblyDisablingAction,\n        tournamentParticipants,\n        inactiveDrawPositions,\n        activeDrawPositions,\n        positionAssignments,\n        returnParticipants,\n        byeDrawPositions,\n        drawDefinition,\n        isByePosition,\n        drawPosition,\n        structureId,\n        structure,\n        drawId,\n      });\n      if (validSwapAction) validActions.push(validSwapAction);\n    }\n  }\n\n  if (isAvailableAction({ policyActions, action: ALTERNATE_PARTICIPANT }) && !disablePlacementActions) {\n    const { validAlternatesAction } = getValidAlternatesAction({\n      possiblyDisablingAction,\n      tournamentParticipants,\n      positionAssignments,\n      activeDrawPositions,\n      returnParticipants,\n      appliedPolicies,\n      drawDefinition,\n      drawPosition,\n      validActions,\n      structureId,\n      structure,\n      drawId,\n      event,\n    });\n    if (validAlternatesAction) validActions.push(validAlternatesAction);\n  }\n\n  if (\n    isAvailableAction({ policyActions, action: LUCKY_PARTICIPANT }) &&\n    !disablePlacementActions &&\n    positionAssignments\n  ) {\n    const { validLuckyLosersAction } = getValidLuckyLosersAction({\n      sourceStructuresComplete,\n      possiblyDisablingAction,\n      isWinRatioFedStructure,\n      tournamentParticipants,\n      activeDrawPositions,\n      positionAssignments,\n      drawDefinition,\n      drawPosition,\n      structureId,\n      structure,\n      drawId,\n    });\n    if (validLuckyLosersAction) validActions.push(validLuckyLosersAction);\n  }\n\n  if (participant?.participantType === PAIR && isAvailableAction({ policyActions, action: MODIFY_PAIR_ASSIGNMENT })) {\n    const { validModifyAssignedPairAction } = getValidModifyAssignedPairAction({\n      tournamentParticipants,\n      returnParticipants,\n      drawPosition,\n      participant,\n      drawId,\n      event,\n    });\n    if (validModifyAssignedPairAction) validActions.push(validModifyAssignedPairAction);\n  }\n\n  return {\n    hasPositionAssigned: !!positionAssignment,\n    isActiveDrawPosition,\n    isDrawPosition: true,\n    isByePosition,\n    validActions,\n  };\n}\n","import { getSourceStructureIdsAndRelevantLinks } from '../../structure/getSourceStructureIdsAndRelevantLinks';\nimport { findExtension } from '../../../acquire/findExtension';\nimport { getAllStructureMatchUps } from '../../matchUps/getAllStructureMatchUps';\nimport { getPositionAssignments } from '../positionsGetter';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { isCompletedStructure } from '../structureActions';\n\nimport { POLICY_TYPE_POSITION_ACTIONS } from '../../../constants/policyConstants';\nimport { BYE } from '../../../constants/matchUpStatusConstants';\nimport { TALLY } from '../../../constants/extensionConstants';\nimport { HydratedParticipant } from '../../../types/hydrated';\nimport {\n  QUALIFYING_PARTICIPANT,\n  QUALIFYING_PARTICIPANT_METHOD,\n} from '../../../constants/positionActionConstants';\nimport {\n  POSITION,\n  QUALIFYING,\n  WINNER,\n} from '../../../constants/drawDefinitionConstants';\n\nexport function getValidQualifiersAction({\n  /*\n  activeDrawPositions,\n  isQualifierPosition, // restrict based on policyDefinition\n  */\n  drawPositionInitialRounds,\n  tournamentParticipants,\n  positionAssignments,\n  returnParticipants,\n  appliedPolicies,\n  drawDefinition,\n  drawPosition,\n  structureId,\n  drawId,\n}) {\n  const qualifyingParticipants: HydratedParticipant[] = [];\n  const qualifyingParticipantIds: string[] = [];\n  const validAssignmentActions: any[] = [];\n  const sourceStructureIds: string[] = [];\n\n  const assignedParticipantIds = positionAssignments\n    .map((assignment) => assignment.participantId)\n    .filter(Boolean);\n\n  const policy = appliedPolicies?.[POLICY_TYPE_POSITION_ACTIONS];\n\n  // get the round number in which the drawPosition initially occurs\n  const targetRoundNumber =\n    !policy?.disableRoundRestrictions &&\n    drawPositionInitialRounds[drawPosition];\n\n  // disallow placing qualifiers until source structure is completed\n  const requireCompletedStructures = policy?.requireCompletedStructures;\n\n  const {\n    sourceStructureIds: eliminationSoureStructureIds,\n    relevantLinks: eliminationSourceLinks,\n  } =\n    getSourceStructureIdsAndRelevantLinks({\n      targetRoundNumber, // look for soure structrues targeting roundNumber\n      linkType: WINNER, // WINNER of qualifying structures will traverse link\n      drawDefinition,\n      structureId,\n    }) || {};\n  if (eliminationSoureStructureIds?.length)\n    sourceStructureIds.push(...eliminationSoureStructureIds);\n\n  const {\n    sourceStructureIds: roundRobinSourceStructureIds,\n    relevantLinks: roundRobinSourceLinks,\n  } =\n    getSourceStructureIdsAndRelevantLinks({\n      targetRoundNumber, // look for soure structrues targeting roundNumber\n      linkType: POSITION, // link will define how many finishingPositions traverse the link\n      drawDefinition,\n      structureId,\n    }) || {};\n  if (roundRobinSourceStructureIds?.length)\n    sourceStructureIds.push(...roundRobinSourceStructureIds);\n\n  for (const sourceLink of eliminationSourceLinks) {\n    const structure = drawDefinition.structures?.find(\n      (structure) => structure.structureId === sourceLink.source.structureId\n    );\n    if (structure?.stage !== QUALIFYING) continue;\n\n    const structureCompleted = isCompletedStructure({\n      structureId: sourceLink.source.structureId,\n      drawDefinition,\n    });\n\n    if (!requireCompletedStructures || structureCompleted) {\n      const qualifyingRoundNumber = structure.qualifyingRoundNumber;\n      const { matchUps } = getAllStructureMatchUps({\n        matchUpFilters: {\n          roundNumbers: [qualifyingRoundNumber],\n          hasWinningSide: true,\n        },\n        afterRecoveryTimes: false,\n        tournamentParticipants,\n        inContext: true,\n        structure,\n      });\n\n      for (const matchUp of matchUps) {\n        const winningSide = matchUp.sides.find(\n          (side) => side?.sideNumber === matchUp.winningSide\n        );\n        const relevantSide =\n          matchUp.matchUpStatus === BYE &&\n          matchUp.sides?.find(({ participantId }) => participantId);\n\n        if (winningSide || relevantSide) {\n          const { participantId, participant } =\n            winningSide || relevantSide || {};\n          if (\n            participantId &&\n            !assignedParticipantIds.includes(participantId)\n          ) {\n            if (participant && returnParticipants)\n              qualifyingParticipants.push(participant);\n            qualifyingParticipantIds.push(participantId);\n          }\n        }\n      }\n    }\n  }\n\n  for (const sourceLink of roundRobinSourceLinks) {\n    const structure = drawDefinition.structures?.find(\n      (structure) => structure.structureId === sourceLink.source.structureId\n    );\n    if (structure?.stage !== QUALIFYING) continue;\n\n    const structureCompleted = isCompletedStructure({\n      structureId: sourceLink.source.structureId,\n      drawDefinition,\n    });\n\n    if (!requireCompletedStructures || structureCompleted) {\n      const { positionAssignments } = getPositionAssignments({ structure });\n      const relevantParticipantIds: any =\n        positionAssignments\n          ?.map((assignment) => {\n            const participantId = assignment.participantId;\n            const results = findExtension({\n              element: assignment,\n              name: TALLY,\n            }).extension?.value;\n\n            return results\n              ? { participantId, groupOrder: results?.groupOrder }\n              : {};\n          })\n          .filter(\n            ({ groupOrder, participantId }) =>\n              // TODO: is this limiting RR qualifiers to groupOrder: 1?\n              groupOrder === 1 &&\n              !assignedParticipantIds.includes(participantId)\n          )\n          .map(({ participantId }) => participantId) ?? [];\n\n      if (relevantParticipantIds)\n        qualifyingParticipantIds.push(...relevantParticipantIds);\n\n      if (returnParticipants) {\n        const relevantParticipants = tournamentParticipants.filter(\n          ({ participantId }) => relevantParticipantIds.includes(participantId)\n        );\n        qualifyingParticipants.push(...relevantParticipants);\n      }\n    }\n  }\n\n  // this should be \"if qualifiers are available\"\n  if (qualifyingParticipantIds.length) {\n    validAssignmentActions.push(\n      definedAttributes({\n        payload: {\n          qualifyingParticipantId: undefined, // to be provided by client\n          drawPosition,\n          structureId,\n          drawId,\n        },\n        method: QUALIFYING_PARTICIPANT_METHOD,\n        type: QUALIFYING_PARTICIPANT,\n        qualifyingParticipantIds,\n        qualifyingParticipants: returnParticipants\n          ? qualifyingParticipants\n          : undefined,\n      })\n    );\n  }\n\n  return { validAssignmentActions, sourceStructureIds };\n}\n\n/**\n  if (sourceStructureIds.length > 1)\n    return decorateResult({\n      stack: 'getValidQualifiersSaction',\n      info: 'too many source structures',\n      result: { error: INVALID_VALUES },\n      context: { sourceStructureIds },\n    });\n  */\n","import { getAllStructureMatchUps } from '../../matchUps/getAllStructureMatchUps';\nimport { getInitialRoundNumber } from '../../matchUps/getInitialRoundNumber';\nimport { getStructureMatchUps } from '../../structure/getStructureMatchUps';\nimport { xa } from '../../../utilities/objects';\nimport { findStructure } from '../../../acquire/findStructure';\n\nimport { ROUND_OUTCOME } from '../../../constants/drawDefinitionConstants';\nimport { HydratedParticipant } from '../../../types/hydrated';\nimport { TEAM } from '../../../constants/eventConstants';\nimport { DrawDefinition, Event, Participant, PositionAssignment, Structure } from '../../../types/tournamentTypes';\nimport { LUCKY_PARTICIPANT, LUCKY_PARTICIPANT_METHOD } from '../../../constants/positionActionConstants';\n\ntype GetValidLuckLoserActionArgs = {\n  tournamentParticipants?: HydratedParticipant[];\n  positionAssignments: PositionAssignment[];\n  sourceStructuresComplete?: boolean;\n  possiblyDisablingAction?: boolean;\n  isWinRatioFedStructure?: boolean;\n  activeDrawPositions: number[];\n  drawDefinition: DrawDefinition;\n  structure: Structure;\n  drawPosition: number;\n  structureId: string;\n  drawId: string;\n  event?: Event;\n};\n\nexport function getValidLuckyLosersAction({\n  tournamentParticipants = [],\n  sourceStructuresComplete,\n  possiblyDisablingAction,\n  isWinRatioFedStructure,\n  activeDrawPositions,\n  positionAssignments,\n  drawDefinition,\n  drawPosition,\n  structureId,\n  structure,\n  drawId,\n  event,\n}: GetValidLuckLoserActionArgs) {\n  if (\n    activeDrawPositions.includes(drawPosition) ||\n    // can't be a lucky loser if still have matches to play in a round robin structure!!\n    (isWinRatioFedStructure && !sourceStructuresComplete)\n  ) {\n    return {};\n  }\n\n  /*\n  Available Lucky Losers are those participants who are assigned drawPositions\n  in source draw structures and have already lost\n\n  If links are by ROUND_OUTCOME, and...\n  If there is only one source structure and only one target structure, then no round restrictions;\n  otherwise restrict the aviailable lucky losers by the source round in the source structure\n  */\n\n  const { sourceStructureIds, targetStructureIds } =\n    drawDefinition.links?.reduce(\n      (ids: any, link) => {\n        const sourceStructureId = link.source?.structureId;\n        const targetStructureId = link.target?.structureId;\n        if (!ids.sourceStructureIds.includes(sourceStructureId)) ids.sourceStructureIds.push(sourceStructureId);\n        if (!ids.targetStructureIds.includes(targetStructureId)) ids.targetStructureIds.push(targetStructureId);\n        return ids;\n      },\n      { sourceStructureIds: [], targetStructureIds: [] },\n    ) || {};\n\n  const availableLuckyLoserParticipantIds: string[] = [];\n\n  const relevantLinks =\n    drawDefinition.links?.filter((link) => link.target?.structureId === structure.structureId) ?? [];\n\n  for (const relevantLink of relevantLinks) {\n    const sourceStructureId = relevantLink?.source?.structureId;\n\n    const { structure: sourceStructure } = findStructure({\n      structureId: sourceStructureId,\n      drawDefinition,\n    });\n\n    const restrictBySourceRound =\n      sourceStructure?.finishingPosition === ROUND_OUTCOME &&\n      (sourceStructureIds?.length !== 1 || targetStructureIds?.length !== 1);\n\n    const matchUpFilters: any = {};\n    if (restrictBySourceRound) {\n      const { matchUps } = getAllStructureMatchUps({\n        drawDefinition,\n        structure,\n        event,\n      });\n      const { initialRoundNumber } = getInitialRoundNumber({\n        drawPosition,\n        matchUps,\n      });\n      const relevantLink = drawDefinition.links?.find(\n        (link) => link.target?.structureId === structure?.structureId && link.target.roundNumber === initialRoundNumber,\n      );\n      const sourceRoundNumber = relevantLink?.source?.roundNumber;\n      matchUpFilters.roundNumbers = [sourceRoundNumber];\n    }\n\n    const { completedMatchUps } = getStructureMatchUps({\n      structureId: sourceStructureId,\n      inContext: true,\n      matchUpFilters,\n      drawDefinition,\n    });\n\n    const assignedParticipantIds = positionAssignments.map((assignment) => assignment.participantId).filter(Boolean);\n\n    const availableParticipantIds = completedMatchUps\n      ?.filter(({ matchUpType, winningSide }) => winningSide && (event?.eventType !== TEAM || matchUpType === TEAM))\n      .map(({ winningSide, sides }) => winningSide && sides?.[1 - (winningSide - 1)])\n      .map(xa('participantId'))\n      .filter((participantId) => participantId && !assignedParticipantIds.includes(participantId));\n\n    availableParticipantIds?.forEach((participantId) => {\n      // ensure if 'restrictBySourceRound' is false and there are multiple links that participants aren't added multiple times\n      if (!availableLuckyLoserParticipantIds.includes(participantId))\n        availableLuckyLoserParticipantIds.push(participantId);\n    });\n  }\n\n  const availableLuckyLosers = tournamentParticipants?.filter(\n    (participant: Participant) => availableLuckyLoserParticipantIds?.includes(participant.participantId),\n  );\n\n  availableLuckyLosers?.forEach((luckyLoser: any) => {\n    const entry = (drawDefinition.entries ?? []).find((entry) => entry.participantId === luckyLoser.participantId);\n    luckyLoser.entryPosition = entry?.entryPosition;\n  });\n\n  if (availableLuckyLoserParticipantIds?.length) {\n    const validLuckyLosersAction = {\n      type: LUCKY_PARTICIPANT,\n      method: LUCKY_PARTICIPANT_METHOD,\n      availableLuckyLosers,\n      availableLuckyLoserParticipantIds,\n      willDisableLinks: possiblyDisablingAction,\n      payload: { drawId, structureId, drawPosition },\n    };\n    return { validLuckyLosersAction };\n  }\n\n  return {};\n}\n","import { definedAttributes } from '../../../utilities/definedAttributes';\n\nimport {\n  MODIFY_PAIR_ASSIGNMENT,\n  MODIFY_PAIR_ASSIGNMENT_METHOD,\n} from '../../../constants/positionActionConstants';\nimport { UNGROUPED, UNPAIRED } from '../../../constants/entryStatusConstants';\n\nexport function getValidModifyAssignedPairAction({\n  tournamentParticipants,\n  returnParticipants,\n  drawPosition,\n  participant,\n  drawId,\n  event,\n}) {\n  // only ungrouped individuals who are event.entries are valid\n  const availableIndividualParticipantIds =\n    event?.entries\n      ?.filter(({ entryStatus }) => [UNGROUPED, UNPAIRED].includes(entryStatus))\n      .map(({ participantId }) => participantId) || [];\n\n  if (availableIndividualParticipantIds.length) {\n    const existingIndividualParticipantIds =\n      participant.individualParticipantIds;\n\n    const availableIndividualParticipants = returnParticipants\n      ? tournamentParticipants.filter(({ participantId }) =>\n          availableIndividualParticipantIds.includes(participantId)\n        )\n      : undefined;\n\n    const existingIndividualParticipants = returnParticipants\n      ? tournamentParticipants.filter(({ participantId }) =>\n          existingIndividualParticipantIds.includes(participantId)\n        )\n      : undefined;\n\n    const validModifyAssignedPairAction = definedAttributes(\n      {\n        payload: {\n          participantId: participant.participantId,\n          replacementIndividualParticipantId: undefined,\n          existingIndividualParticipantId: undefined,\n          drawPosition,\n          drawId,\n        },\n        method: MODIFY_PAIR_ASSIGNMENT_METHOD,\n        availableIndividualParticipantIds,\n        availableIndividualParticipants,\n        existingIndividualParticipantIds,\n        existingIndividualParticipants,\n        type: MODIFY_PAIR_ASSIGNMENT,\n      },\n      false,\n      false,\n      true\n    );\n\n    return { validModifyAssignedPairAction };\n  }\n\n  return {};\n}\n","import { validMatchUps } from '../../validators/validMatchUp';\n\nimport { INVALID_VALUES } from '../../constants/errorConditionConstants';\n\nexport function getMatchUpContextIds({ matchUps, matchUpId }) {\n  if (!validMatchUps(matchUps)) return { error: INVALID_VALUES };\n\n  const matchUp = matchUps.find((matchUp) => matchUp.matchUpId === matchUpId);\n\n  const { drawId, eventId, structureId, tournamentId } = matchUp || {};\n  return { matchUpId, drawId, eventId, structureId, tournamentId };\n}\n","import { WTN } from '../../constants/ratingConstants';\n\nexport function getDetailsWTN({ participant, eventType }) {\n  const personId = participant?.person?.personId;\n  const personOtherId = participant?.person?.personOtherIds?.[0];\n  const tennisId = participant?.person?.tennisId;\n  const scaleItem = participant?.ratings?.[eventType]?.find(\n    ({ scaleName }) => scaleName === WTN\n  );\n  const personWTN = scaleItem?.scaleValue;\n  const { wtnRating, confidence } = personWTN || {};\n  return {\n    timeStamp: scaleItem?.scaleDate,\n    personOtherId,\n    confidence,\n    wtnRating,\n    personId,\n    tennisId,\n  };\n}\n","import { getDetailsWTN } from './getDetailsWTN';\n\nimport { HydratedMatchUp } from '../../types/hydrated';\n\ntype GetAvgWTNArgs = {\n  matchUps: HydratedMatchUp[];\n  eventType?: string;\n  eventId?: string;\n  drawId: string;\n};\nexport function getAvgWTN({\n  eventType,\n  matchUps,\n  eventId,\n  drawId,\n}: GetAvgWTNArgs) {\n  const matchUpFormatCounts = {};\n\n  const countMatchUpFormat = (params) => {\n    const matchUpFormat = params?.matchUpFormat;\n    if (!matchUpFormat) return;\n    if (!matchUpFormatCounts[matchUpFormat])\n      matchUpFormatCounts[matchUpFormat] = 0;\n    matchUpFormatCounts[matchUpFormat] += 1;\n  };\n  const participantsMap = matchUps\n    .filter((matchUp) =>\n      eventId ? matchUp.eventId === eventId : matchUp.drawId === drawId\n    )\n    .reduce((participants, matchUp) => {\n      countMatchUpFormat(matchUp);\n      (matchUp.sides ?? [])\n        .flatMap((side: any) =>\n          (\n            side?.participant?.individualParticipants || [side?.participant]\n          ).filter(Boolean)\n        )\n        .forEach(\n          (participant) =>\n            (participants[participant.participantId] = participant)\n        );\n      return participants;\n    }, {});\n  const eventParticipants = Object.values(participantsMap);\n  const wtnRatings = eventParticipants\n    .map((participant) => getDetailsWTN({ participant, eventType }))\n    .filter(({ wtnRating }) => wtnRating);\n\n  const pctNoRating =\n    ((eventParticipants.length - wtnRatings.length) /\n      eventParticipants.length) *\n    100;\n\n  const wtnTotals = wtnRatings.reduce(\n    (totals, wtnDetails) => {\n      const { wtnRating, confidence } = wtnDetails;\n      totals.totalWTN += wtnRating;\n      totals.totalConfidence += confidence;\n      return totals;\n    },\n    { totalWTN: 0, totalConfidence: 0 }\n  );\n  const avgWTN = wtnRatings?.length\n    ? wtnTotals.totalWTN / wtnRatings.length\n    : 0;\n  const avgConfidence = wtnRatings?.length\n    ? wtnTotals.totalConfidence / wtnRatings.length\n    : 0;\n\n  const counts: number[] = Object.values(matchUpFormatCounts);\n  const matchUpsCount = counts.reduce((p: number, c) => {\n    return p + (c || 0);\n  }, 0);\n\n  return {\n    matchUpFormatCounts,\n    matchUpsCount,\n    avgConfidence,\n    pctNoRating,\n    avgWTN,\n  };\n}\n","import { getEntryStatusReports } from '../../../query/entries/entryStatusReport';\nimport { getParticipantStats } from '../../../query/participant/getParticipantStats';\nimport { getStructureReports } from '../../../query/structure/structureReport';\n\nexport const reportGovernor = {\n  getStructureReports,\n  getEntryStatusReports,\n  getParticipantStats,\n};\n\nexport default reportGovernor;\n","import { getTieFormatDesc } from '../hierarchical/tieFormats/getTieFormatDescription';\nimport { allTournamentMatchUps } from '../matchUps/getAllTournamentMatchUps';\nimport { getAccessorValue } from '../../utilities/getAccessorValue';\nimport { findExtension } from '../../acquire/findExtension';\nimport { getDetailsWTN } from '../scales/getDetailsWTN';\nimport { getTimeItem } from '../base/timeItems';\nimport { getAvgWTN } from '../scales/getAvgWTN';\n\nimport { MISSING_TOURNAMENT_ID } from '../../constants/errorConditionConstants';\nimport { ADD_SCALE_ITEMS } from '../../constants/topicConstants';\nimport { HydratedParticipant } from '../../types/hydrated';\nimport { SEEDING } from '../../constants/scaleConstants';\nimport { Participant, Side, Tournament } from '../../types/tournamentTypes';\nimport {\n  CONSOLATION,\n  MAIN,\n  PLAY_OFF,\n  QUALIFYING,\n} from '../../constants/drawDefinitionConstants';\nimport { PAIR, TEAM_PARTICIPANT } from '../../constants/participantConstants';\nimport {\n  AUDIT_POSITION_ACTIONS,\n  DRAW_DELETIONS,\n  FLIGHT_PROFILE,\n} from '../../constants/extensionConstants';\n\ntype GetStructureReportsArgs = {\n  tournamentRecord: Tournament;\n  extensionProfiles?: any[];\n  firstFlightOnly?: boolean;\n};\n\nexport function getStructureReports({\n  firstFlightOnly = true,\n  extensionProfiles,\n  tournamentRecord,\n}: GetStructureReportsArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_ID };\n\n  const eventStructureReports = {};\n\n  const extensionValues = Object.assign(\n    {},\n    ...(extensionProfiles ?? []).map(({ name, label, accessor }) => {\n      const element = findExtension({\n        element: tournamentRecord,\n        name,\n      })?.extension?.value;\n\n      const value = accessor\n        ? getAccessorValue({ element, accessor })?.value\n        : element;\n\n      return { [label || name]: value };\n    })\n  );\n\n  const tournamentId = tournamentRecord?.tournamentId;\n  const participantsProfile = { withScaleValues: true };\n  const matchUps =\n    allTournamentMatchUps({\n      participantsProfile,\n      tournamentRecord,\n    }).matchUps ?? [];\n\n  const getSeedingBasis = (timeItems) => {\n    const timeItem = getTimeItem({\n      itemType: ADD_SCALE_ITEMS,\n      itemSubTypes: [SEEDING],\n      element: { timeItems },\n    })?.timeItem;\n    return timeItem?.itemValue?.scaleBasis;\n  };\n\n  const tournamentStructureData = tournamentRecord?.events?.flatMap(\n    ({\n      timeItems: eventTimeItems,\n      drawDefinitions = [],\n      extensions,\n      eventType,\n      eventId,\n      category,\n    }) => {\n      const flightProfile = extensions?.find((x) => x.name === FLIGHT_PROFILE);\n      const flightNumbers = flightProfile?.value?.flights?.map((flight) => ({\n        [flight.drawId]: flight.flightNumber,\n      }));\n      const flightMap: any =\n        flightNumbers && Object.assign({}, ...flightNumbers);\n      const drawDeletionsCount =\n        extensions?.find((x) => x.name === DRAW_DELETIONS)?.value?.length || 0;\n\n      const mapValues: number[] = Object.values(flightMap);\n      const minFlightNumber = flightMap && Math.min(...mapValues);\n\n      const eventSeedingBasis = getSeedingBasis(eventTimeItems);\n\n      eventStructureReports[eventId] = {\n        totalPositionManipulations: 0,\n        maxPositionManipulations: 0,\n        generatedDrawsCount: 0,\n        drawDeletionsCount,\n        seedingBasis: eventSeedingBasis\n          ? JSON.stringify(eventSeedingBasis)\n          : undefined,\n        tournamentId,\n        eventId,\n      };\n\n      return (\n        // check whether to only pull data from initial flights & ignore all other flights\n        drawDefinitions\n          .filter(\n            (d: any) =>\n              !firstFlightOnly ||\n              !flightNumbers ||\n              flightMap[d.drawId] === minFlightNumber\n          )\n          .flatMap((dd) => {\n            const {\n              matchUpFormat: drawMatchUpFormat,\n              tieFormat: drawTieFormat,\n              timeItems: drawTimeItems,\n              extensions,\n              structures,\n              drawType,\n              drawId,\n            } = dd;\n            const {\n              matchUpFormatCounts,\n              matchUpsCount,\n              avgConfidence,\n              pctNoRating,\n              avgWTN,\n            } = getAvgWTN({\n              eventType,\n              matchUps,\n              drawId,\n            });\n\n            const seedingBasis =\n              getSeedingBasis(drawTimeItems) || eventSeedingBasis;\n\n            const positionManipulations = getPositionManipulations({\n              extensions,\n            });\n            const manipulationsCount = positionManipulations?.length || 0;\n\n            eventStructureReports[eventId].totalPositionManipulations +=\n              manipulationsCount;\n            eventStructureReports[eventId].generatedDrawsCount += 1;\n\n            if (\n              manipulationsCount >\n              eventStructureReports[eventId].maxPositionManipulations\n            )\n              eventStructureReports[eventId].maxPositionManipulations =\n                manipulationsCount;\n\n            return structures\n              ?.filter(\n                (s: any) =>\n                  s.stageSequence === 1 &&\n                  [QUALIFYING, MAIN, CONSOLATION, PLAY_OFF].includes(s.stage)\n              )\n              .map((s: any) => {\n                const finalMatchUp = [MAIN, PLAY_OFF].includes(s.stage)\n                  ? matchUps.find(\n                      (matchUp) =>\n                        matchUp.structureId === s.structureId &&\n                        matchUp.finishingRound === 1 &&\n                        matchUp.winningSide\n                    )\n                  : undefined;\n\n                const winningSide = finalMatchUp?.sides?.find(\n                  (side: any) => side.sideNumber === finalMatchUp.winningSide\n                ) as Side & { participant?: Participant };\n\n                const winningParticipant =\n                  winningSide?.participant as HydratedParticipant;\n\n                const winningTeamId =\n                  winningParticipant?.participantType === TEAM_PARTICIPANT &&\n                  winningParticipant.participantId;\n\n                const individualParticipants =\n                  winningParticipant?.participantType === PAIR\n                    ? winningParticipant.individualParticipants\n                    : [];\n\n                const winningPersonWTN = getDetailsWTN({\n                  participant:\n                    individualParticipants?.[0] || winningParticipant,\n                  eventType,\n                });\n                const {\n                  personId: winningPersonId,\n                  personOtherId: winningPersonOtherId,\n                  tennisId: winningPersonTennisId,\n                  confidence: confidence1,\n                  wtnRating: wtnRating1,\n                } = winningPersonWTN || {};\n\n                const winningPerson2WTN = getDetailsWTN({\n                  participant: individualParticipants?.[1],\n                  eventType,\n                });\n                const {\n                  personId: winningPerson2Id,\n                  personOtherId: winningPerson2OtherId,\n                  tennisId: winningPerson2TennisId,\n                  confidence: confidence2,\n                  wtnRating: wtnRating2,\n                } = winningPerson2WTN || {};\n\n                const { ageCategoryCode, categoryName, subType } =\n                  category ?? {};\n                const matchUpFormat = s.matchUpFormat || drawMatchUpFormat;\n                const matchUpsInitialFormat =\n                  matchUpFormatCounts[matchUpFormat] || 0;\n                const pctInitialMatchUpFormat =\n                  (matchUpsInitialFormat / matchUpsCount) * 100;\n\n                const {\n                  tieFormatName: drawTieFormatName,\n                  tieFormatDesc: drawTieFormatDesc,\n                } = getTieFormatDesc(drawTieFormat);\n                const {\n                  tieFormatName: structureTieFormatName,\n                  tieFormatDesc: structureTieFormatDesc,\n                } = getTieFormatDesc(s.tieFormat);\n\n                const equivalentTieFormatDesc =\n                  drawTieFormatDesc === structureTieFormatDesc;\n                const tieFormatName =\n                  !equivalentTieFormatDesc && structureTieFormatName;\n                const tieFormatDesc =\n                  s.tieFormat &&\n                  !equivalentTieFormatDesc &&\n                  structureTieFormatDesc;\n\n                const manipulations =\n                  positionManipulations?.filter(\n                    (action) => action.structureId === s.structureId\n                  )?.length || 0;\n\n                return {\n                  ...extensionValues,\n                  tournamentId,\n                  eventId,\n                  structureId: s.structureId,\n                  drawId,\n                  eventType,\n                  category: subType,\n                  categoryName,\n                  ageCategoryCode,\n                  flightNumber: flightMap[drawId],\n                  drawType,\n                  stage: s.stage,\n                  seedingBasis: seedingBasis\n                    ? JSON.stringify(seedingBasis)\n                    : undefined,\n                  winningPersonId,\n                  winningPersonOtherId,\n                  winningPersonTennisId,\n                  winningPersonWTNrating: wtnRating1,\n                  winningPersonWTNconfidence: confidence1,\n                  winningPerson2Id,\n                  winningPerson2OtherId,\n                  winningPerson2TennisId,\n                  winningPerson2WTNrating: wtnRating2,\n                  winningPerson2WTNconfidence: confidence2,\n                  winningTeamId,\n                  positionManipulations: manipulations,\n                  pctNoRating,\n                  matchUpFormat,\n                  pctInitialMatchUpFormat,\n                  matchUpsCount,\n                  drawTieFormatName,\n                  drawTieFormatDesc,\n                  tieFormatName,\n                  tieFormatDesc,\n                  avgConfidence,\n                  avgWTN,\n                };\n              });\n          })\n      );\n    }\n  );\n\n  return {\n    eventStructureReports: Object.values(eventStructureReports),\n    structureReports: tournamentStructureData,\n  };\n}\n\nfunction getPositionManipulations({ extensions }) {\n  return extensions\n    ?.find(({ name }) => name === AUDIT_POSITION_ACTIONS)\n    ?.value?.slice(1);\n}\n","import { allTournamentMatchUps } from '../matchUps/getAllTournamentMatchUps';\nimport { getParticipants } from '../participants/getParticipants';\nimport { getDetailsWTN } from '../scales/getDetailsWTN';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\nimport { STRUCTURE_SELECTED_STATUSES } from '../../constants/entryStatusConstants';\nimport { WITHDRAW_PARTICIPANT } from '../../constants/positionActionConstants';\nimport { MAIN, QUALIFYING } from '../../constants/drawDefinitionConstants';\nimport { INDIVIDUAL } from '../../constants/participantConstants';\nimport { DOUBLES_EVENT } from '../../constants/eventConstants';\nimport { Tournament } from '../../types/tournamentTypes';\nimport { COMPETITOR } from '../../constants/participantRoles';\nimport { DOUBLES_MATCHUP, SINGLES_MATCHUP } from '../../constants/matchUpTypes';\n\ntype GetEntryStatusReportsArgs = {\n  tournamentRecord: Tournament;\n};\nexport function getEntryStatusReports({\n  tournamentRecord,\n}: GetEntryStatusReportsArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const tournamentId = tournamentRecord.tournamentId;\n  const { participantMap } = getParticipants({\n    withScaleValues: true,\n    withEvents: true, // so that event rankings will be present\n    withSeeding: true,\n    tournamentRecord,\n    withDraws: true,\n  });\n\n  const nonTeamMatchUps =\n    allTournamentMatchUps({\n      matchUpFilters: { matchUpTypes: [SINGLES_MATCHUP, DOUBLES_MATCHUP] },\n      tournamentRecord,\n    }).matchUps ?? [];\n\n  const nonTeamEnteredParticipantIds = nonTeamMatchUps\n    .flatMap(\n      ({ sides, matchUpType }) =>\n        sides\n          ?.flatMap((side: any) =>\n            matchUpType === DOUBLES_MATCHUP\n              ? side?.participant?.individualParticipantIds\n              : side?.participant?.participantId || side.participantId\n          )\n          .filter(Boolean)\n    )\n    .filter(Boolean);\n\n  const withDrawnParticipantIds: string[] = [];\n  const participantEntryReports = {};\n  const entryStatusReports = {};\n  const eventReports = {};\n\n  let drawDefinitionsCount = 0;\n\n  const pushEntryReport = ({ id, entry, eventId, eventType }) => {\n    const { qualifyingSeeding, mainSeeding, entryStatus, entryStage, drawId } =\n      entry;\n\n    if (!participantEntryReports[id]) participantEntryReports[id] = [];\n\n    const { participant, events } = participantMap?.[id] ?? {};\n    const entryDetailsWTN = getDetailsWTN({ participant, eventType });\n    const ranking = events?.[eventId]?.ranking;\n\n    if (entryStatus === WITHDRAW_PARTICIPANT) withDrawnParticipantIds.push(id);\n\n    participantEntryReports[id].push({\n      participantType: participant?.participantType,\n      participantId: id,\n      tournamentId,\n      eventType,\n      eventId,\n      drawId,\n      entryStatus,\n      entryStage,\n      ...entryDetailsWTN,\n      ranking,\n      mainSeeding,\n      qualifyingSeeding,\n    });\n  };\n\n  // Who was in a draw and how they got there...\n  for (const event of tournamentRecord.events ?? []) {\n    const entryStatuses: { [key: string]: { count: number; pct?: number } } =\n      {};\n    const countEntryStatus = (entryStatus) => {\n      if (!entryStatuses[entryStatus])\n        entryStatuses[entryStatus] = { count: 0 };\n      entryStatuses[entryStatus].count += 1;\n    };\n\n    const { drawDefinitions = [], eventType, eventId } = event;\n    const entries = drawDefinitions.flatMap((params) => {\n      const { drawId, entries } = params;\n      drawDefinitionsCount += 1;\n\n      // build up assignedParticipantIds array\n      // to ensure that only assignedParticipants are included\n      const stageFilter = ({ stage, stageSequence }) =>\n        (stage === MAIN && stageSequence === 1) || stage === QUALIFYING;\n      const structures: any[] = params.structures ?? [];\n      const assignedParticipantIds = structures\n        .filter(stageFilter)\n        .flatMap(({ positionAssignments }) => positionAssignments)\n        .filter(Boolean)\n        .map(({ participantId }) => participantId);\n\n      const entryFilter = ({ participantId }) =>\n        assignedParticipantIds.includes(participantId);\n\n      const createEntryProfile = (params) => {\n        const { participantId, entryStatus, entryStage } = params;\n        countEntryStatus(entryStatus);\n\n        const mainSeeding =\n          participantMap?.[participantId]?.draws?.[drawId]?.seedAssignments?.[\n            MAIN\n          ];\n        const qualifyingSeeding =\n          participantMap?.[participantId]?.draws?.[drawId]?.seedAssignments?.[\n            QUALIFYING\n          ];\n\n        return {\n          qualifyingSeeding,\n          participantId,\n          mainSeeding,\n          entryStatus,\n          entryStage,\n          drawId,\n        };\n      };\n\n      return entries?.filter(entryFilter).map(createEntryProfile);\n    });\n\n    const createEntryMap = (entry) => {\n      const participantId = entry.participantId;\n      const individualParticipantIds = participantMap?.[\n        participantId\n      ].participant.individualParticipantIds?.filter(\n        // ensure that for TEAM events individuals who did not compete are not included\n        (id) => nonTeamEnteredParticipantIds.includes(id)\n      );\n      return participantId && { [participantId]: { individualParticipantIds } };\n    };\n\n    const processDoublesEvent = () => {\n      const participantEntriesMap = Object.assign(\n        {},\n        ...entries.map(createEntryMap).filter(Boolean)\n      );\n\n      const processIndividuals = (entry) => {\n        participantEntriesMap[\n          entry.participantId\n        ].individualParticipantIds.forEach((individualParticipantId) => {\n          pushEntryReport({\n            id: individualParticipantId,\n            eventType,\n            eventId,\n            entry,\n          });\n        });\n      };\n\n      // add entry details into participantEntryReports\n      entries.forEach(processIndividuals);\n    };\n\n    if (eventType === DOUBLES_EVENT) {\n      processDoublesEvent();\n    } else {\n      // add entry details into participantEntryReports\n      entries.forEach((entry) => {\n        pushEntryReport({\n          id: entry?.participantId,\n          eventType,\n          eventId,\n          entry,\n        });\n      });\n    }\n\n    const totalEntries: number = Object.values(entryStatuses).reduce(\n      (p, c: any) => p + c.count,\n      0\n    );\n    Object.keys(entryStatuses).forEach((key) => {\n      entryStatuses[key].pct = (entryStatuses[key].count / totalEntries) * 100;\n    });\n\n    // for each entry of each event get their WTN and eventRanking\n    eventReports[eventId] = { tournamentId, eventId, entries, entryStatuses };\n\n    const selectedStatuses = Object.assign(\n      {},\n      ...STRUCTURE_SELECTED_STATUSES.flatMap((entryStatus) => {\n        return [\n          {\n            [entryStatus + '_count']: entryStatuses[entryStatus]?.count,\n          },\n          {\n            [entryStatus + '_pct']: entryStatuses[entryStatus]?.pct,\n          },\n        ];\n      })\n    );\n    entryStatusReports[eventId] = {\n      tournamentId,\n      eventId,\n      ...selectedStatuses,\n    };\n  }\n\n  const individualParticipants = Object.values(participantMap ?? {}).filter(\n    ({ participant: { participantType, participantRole } }) =>\n      participantType === INDIVIDUAL && participantRole === COMPETITOR\n  );\n  const nonParticipatingParticipantIds = individualParticipants\n    .filter(\n      ({ participant }) =>\n        !nonTeamEnteredParticipantIds.includes(participant.participantId)\n    )\n    .map(({ participant }) => participant.participantId);\n\n  const tournamentEntryReport = {\n    nonParticipatingEntriesCount: nonParticipatingParticipantIds.length,\n    individualParticipantsCount: individualParticipants.length,\n    eventsCount: Object.values(eventReports).length,\n    nonParticipatingParticipantIds,\n    drawDefinitionsCount,\n    tournamentId,\n  };\n\n  return {\n    entryStatusReports: Object.values(entryStatusReports).flat(),\n    participantEntryReports: Object.values(participantEntryReports).flat(),\n    eventReports: Object.values(eventReports).flat(),\n    withDrawnParticipantIds,\n    tournamentEntryReport,\n  };\n}\n","import { getMatchUpCompetitiveProfile } from '../matchUp/getMatchUpCompetitiveProfile';\nimport { allTournamentMatchUps } from '../matchUps/getAllTournamentMatchUps';\nimport { xa, isObject } from '../../utilities/objects';\nimport { getParticipants } from '../participants/getParticipants';\nimport { intersection } from '../../utilities/arrays';\nimport { ResultType, decorateResult } from '../../global/functions/decorateResult';\nimport { Tally, countGames, countPoints, countSets } from '../matchUps/roundRobinTally/scoreCounters';\n\nimport { ParticipantTypeUnion, Tournament } from '../../types/tournamentTypes';\nimport { TEAM_PARTICIPANT } from '../../constants/participantConstants';\nimport { HydratedMatchUp, HydratedSide } from '../../types/hydrated';\nimport { BYE } from '../../constants/matchUpStatusConstants';\nimport { TEAM_MATCHUP } from '../../constants/matchUpTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_MATCHUP,\n  INVALID_PARTICIPANT_IDS,\n  MISSING_MATCHUPS,\n  MISSING_TOURNAMENT_RECORD,\n  PARTICIPANT_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\n\nexport type StatCounters = {\n  participantName: string;\n  competitorIds: string[];\n  participantId: string;\n\n  matchUpStatuses: { [key: string]: number };\n  competitiveness: { [key: string]: Tally };\n  competitiveRatio?: number;\n  decisiveRatio?: number;\n  routineRatio?: number;\n\n  tiebreaksRatio?: number;\n  matchUpsRatio?: number;\n  pointsRatio?: number;\n  gamesRatio?: number;\n  setsRatio?: number;\n\n  tiebreaksRank?: number;\n  matchUpsRank?: number;\n  pointsRank?: number;\n  gamesRank?: number;\n  setsRank?: number;\n\n  tiebreaks: Tally;\n  matchUps: Tally;\n  points: Tally;\n  games: Tally;\n  sets: Tally;\n};\n\ntype GetTeamStatistics = {\n  withCompetitiveProfiles?: boolean;\n  opponentParticipantId?: string;\n  withIndividualStats?: boolean;\n  tournamentRecord: Tournament;\n  matchUps?: HydratedMatchUp[];\n  teamParticipantId?: string;\n  withScaleValues?: boolean;\n  tallyPolicy?: any;\n};\n\ntype TeamStatsResults = {\n  allParticipantStats?: StatCounters[];\n  relevantMatchUps: HydratedMatchUp[];\n  participatingTeamsCount?: number;\n  opponentStats?: StatCounters;\n  teamStats?: StatCounters;\n  success: boolean;\n};\n\nexport function getParticipantStats({\n  withCompetitiveProfiles,\n  opponentParticipantId,\n  withIndividualStats,\n  teamParticipantId,\n  tournamentRecord,\n  withScaleValues,\n  tallyPolicy,\n  matchUps,\n}: GetTeamStatistics): ResultType | TeamStatsResults {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (matchUps && !Array.isArray(matchUps)) return { error: INVALID_MATCHUP };\n\n  const participantsProfile = withScaleValues ? { withScaleValues } : undefined;\n  matchUps = matchUps ?? allTournamentMatchUps({ tournamentRecord, participantsProfile }).matchUps;\n  if (!matchUps?.length) return { error: MISSING_MATCHUPS };\n\n  const teamParticipantIds: string[] = [];\n  if (opponentParticipantId) teamParticipantIds.push(opponentParticipantId);\n  if (teamParticipantId) teamParticipantIds.push(teamParticipantId);\n\n  const participantFilters = !teamParticipantIds.length\n    ? { participantTypes: [TEAM_PARTICIPANT as ParticipantTypeUnion] }\n    : { participantIds: teamParticipantIds };\n\n  const teamParticipants = getParticipants({ participantFilters, tournamentRecord }).participants ?? [];\n\n  if (!teamParticipants.every(({ participantType }) => participantType === TEAM_PARTICIPANT)) {\n    return { error: INVALID_PARTICIPANT_IDS };\n  }\n\n  if (!teamParticipantIds.length) teamParticipantIds.push(...teamParticipants.map(xa('participantId')));\n\n  const participantDetails = new Map<string, { participantName: string; ratings: any }>();\n  const participantStats = new Map<string, StatCounters>();\n  const participating = new Map<string, boolean>();\n  const teamMap = new Map<string, string[]>();\n\n  const initStats = (participantId, participantName = '') =>\n    participantStats.get(participantId) ||\n    (participantStats.set(participantId, {\n      participantName,\n      participantId,\n\n      competitorIds: [],\n      competitiveness: {},\n      matchUpStatuses: {},\n\n      tiebreaks: [0, 0],\n      matchUps: [0, 0],\n      points: [0, 0],\n      games: [0, 0],\n      sets: [0, 0],\n    }) &&\n      participantStats.get(participantId));\n\n  for (const teamParticipant of teamParticipants) {\n    const { participantId, individualParticipantIds } = teamParticipant;\n    teamMap.set(participantId, individualParticipantIds ?? []);\n    initStats(participantId, teamParticipant.participantName);\n  }\n\n  if (teamParticipantId && !teamMap.get(teamParticipantId))\n    return decorateResult({\n      result: { error: PARTICIPANT_NOT_FOUND },\n      context: { teamParticipantId },\n    });\n\n  if (opponentParticipantId && !teamMap.get(opponentParticipantId))\n    return decorateResult({\n      result: { error: PARTICIPANT_NOT_FOUND },\n      context: { opponentParticipantId },\n    });\n\n  const relevantMatchUps: HydratedMatchUp[] = [];\n\n  const getSideParticipantIds = (sides: HydratedSide[]) => {\n    const sideParticipantIds: [string[], string[]] = [[], []];\n\n    for (const side of sides) {\n      const participant = side.participant;\n      if (participant?.participantName) {\n        participantDetails.set(participant.participantId, {\n          participantName: participant.participantName,\n          ratings: participant.ratings,\n        });\n        const stats = participantStats.get(participant.participantId);\n        if (stats) stats.participantName = participant.participantName;\n      }\n    }\n\n    const getCompetitorIds = ({ side, individualParticipantIds }) => {\n      return (\n        (side.participantId &&\n          (!individualParticipantIds?.length || individualParticipantIds.includes(side.participantId)) && [\n            side.participantId,\n          ]) ||\n        (side.participant?.individualParticipantIds?.length &&\n          (!individualParticipantIds?.length ||\n            intersection(individualParticipantIds, side.participant?.individualParticipantIds).length ===\n              side.participant?.individualParticipantIds?.length) &&\n          side.participant.individualParticipantIds)\n      );\n    };\n\n    if (teamMap.size) {\n      const processSides = (thisTeamId, individualParticipantIds) => {\n        for (const side of sides) {\n          if (!side.participant) continue;\n          const competitorIds = getCompetitorIds({\n            individualParticipantIds,\n            side,\n          });\n          if (competitorIds?.length) {\n            const sideNumber = side.sideNumber;\n            if (!sideNumber) continue;\n            const ids = [thisTeamId];\n            if (withIndividualStats) ids.push(...competitorIds);\n            sideParticipantIds[sideNumber - 1] = ids;\n\n            const stats = participantStats.get(thisTeamId);\n            for (const id of competitorIds.filter(Boolean)) {\n              if (stats && !stats.competitorIds.includes(id)) stats.competitorIds.push(id);\n            }\n          }\n        }\n      };\n\n      if (teamParticipantId) {\n        const processForTeam =\n          !opponentParticipantId ||\n          sides.every((side) => {\n            return (\n              side.participant &&\n              (getCompetitorIds({\n                individualParticipantIds: teamMap.get(teamParticipantId),\n                side,\n              }) ||\n                getCompetitorIds({\n                  individualParticipantIds: teamMap.get(opponentParticipantId),\n                  side,\n                }))\n            );\n          });\n\n        if (processForTeam) {\n          processSides(teamParticipantId, teamMap.get(teamParticipantId));\n        }\n      } else {\n        for (const [thisTeamId, individualParticipantIds] of teamMap) {\n          processSides(thisTeamId, individualParticipantIds);\n        }\n      }\n    } else if (withIndividualStats) {\n      // no teams so process individuals\n      for (const side of sides) {\n        if (!side.participant) continue;\n        const competitorIds = getCompetitorIds({\n          individualParticipantIds: [],\n          side,\n        });\n        const sideNumber = side.sideNumber;\n        if (!sideNumber) continue;\n        sideParticipantIds[sideNumber - 1] = competitorIds;\n      }\n    }\n\n    return sideParticipantIds;\n  };\n\n  for (const matchUp of matchUps) {\n    if (!isObject(matchUp)) return { error: INVALID_MATCHUP };\n\n    const { matchUpStatus, matchUpFormat, matchUpType, winningSide, score, sides } = matchUp;\n\n    if (!sides || !score || matchUpType === TEAM_MATCHUP || matchUpStatus === BYE) continue;\n\n    const sideParticipantIds = getSideParticipantIds(sides);\n    if (!sideParticipantIds.filter(Boolean).length) continue;\n\n    const competitiveness =\n      withCompetitiveProfiles && winningSide && getMatchUpCompetitiveProfile({ matchUp })?.competitiveness;\n\n    relevantMatchUps.push(matchUp);\n\n    const setsTally = countSets({\n      matchUpStatus,\n      matchUpFormat,\n      tallyPolicy,\n      winningSide,\n      score,\n    });\n    const gamesTally = countGames({\n      matchUpStatus,\n      matchUpFormat,\n      tallyPolicy,\n      winningSide,\n      score,\n    });\n    const { pointsTally, tiebreaksTally } = countPoints({\n      matchUpFormat,\n      score,\n    });\n\n    sideParticipantIds.forEach((ids, index) => {\n      for (const id of ids) {\n        const participantName = participantDetails.get(id)?.participantName;\n        const stats = initStats(id, participantName);\n        if (stats) {\n          const teamSumTally = (stat: string, tally: number[]) => tally.forEach((t, i) => (stats[stat][i] += t));\n          const tiebreaks = index ? [...tiebreaksTally].reverse() : tiebreaksTally;\n          const points = index ? [...pointsTally].reverse() : pointsTally;\n          const games = index ? [...gamesTally].reverse() : gamesTally;\n          const sets = index ? [...setsTally].reverse() : setsTally;\n          teamSumTally('tiebreaks', tiebreaks);\n          teamSumTally('points', points);\n          teamSumTally('games', games);\n          teamSumTally('sets', sets);\n          if (winningSide) {\n            const tallyIndex = winningSide - 1 === index ? 0 : 1;\n            stats.matchUps[tallyIndex] += 1;\n          }\n          if (competitiveness) {\n            const attr = competitiveness.toLowerCase();\n            if (!stats.competitiveness[attr]) stats.competitiveness[attr] = [0, 0];\n            stats.competitiveness[attr][index] += 1;\n          }\n          if (matchUpStatus) {\n            const attr = matchUpStatus.toLowerCase();\n            if (!stats.matchUpStatuses[attr]) stats.matchUpStatuses[attr] = 0;\n            stats.matchUpStatuses[attr] += 1;\n          }\n        }\n      }\n    });\n  }\n  const statsattributes = ['tiebreaks', 'matchUps', 'points', 'games', 'sets'];\n  const competitivenessAttributes = ['competitive', 'routine', 'decisive'];\n  const ratio = new Map<string, number[]>();\n\n  const add = (a, b) => (a ?? 0) + (b ?? 0);\n  for (const [participantId, stats] of participantStats.entries()) {\n    for (const attr of statsattributes) {\n      const total = stats[attr].reduce(add);\n      if (total) {\n        const value = stats[attr][0] / total;\n        const accessor = `${attr}Ratio`;\n\n        const fixedValue = parseFloat(value.toFixed(2));\n        stats[accessor] = fixedValue;\n\n        participating.set(participantId, true);\n\n        if (!ratio.has(accessor)) ratio.set(accessor, []);\n        ratio.get(accessor)?.push(fixedValue);\n      }\n    }\n    for (const attr of competitivenessAttributes) {\n      const total = stats.competitiveness?.[attr]?.reduce(add);\n      if (total) {\n        const value = stats.competitiveness[attr][0] / total;\n        const accessor = `${attr}Ratio`;\n\n        const fixedValue = parseFloat(value.toFixed(2));\n        stats[accessor] = fixedValue;\n      }\n    }\n  }\n\n  if (!teamParticipantId) {\n    const highLowSort = (a, b) => b - a;\n    for (const stats of participantStats.values()) {\n      for (const attr of statsattributes) {\n        // now rank each team by their ratio on each attribute\n        const accessor = `${attr}Ratio`;\n        if (typeof stats[accessor] === 'number') {\n          const index = ratio.get(accessor)?.sort(highLowSort).indexOf(stats[accessor]);\n\n          if (typeof index === 'number' && index >= 0) {\n            const rankAccessor = `${attr}Rank`;\n            stats[rankAccessor] = index + 1;\n          }\n        }\n      }\n    }\n  }\n\n  const result: TeamStatsResults = { relevantMatchUps, ...SUCCESS };\n  if (teamParticipantId) {\n    result.teamStats = participantStats.get(teamParticipantId);\n    if (opponentParticipantId) result.opponentStats = participantStats.get(opponentParticipantId);\n  } else {\n    result.participatingTeamsCount = participating.size;\n  }\n  result.allParticipantStats = [...participantStats.values()];\n\n  return result;\n}\n","export function generateTimeCode(index: number = 0): string {\n  const uidate = new Date();\n  uidate.setHours(uidate.getHours() + index);\n  return uidate.getTime().toString(36).slice(-6).toUpperCase();\n}\n","import { extractDate, extractTime } from '../../../../../utilities/dateTime';\nimport { generateTimeCode } from '../../../../../utilities/timeCode';\n\nimport { DO_NOT_SCHEDULE } from '../../../../../constants/requestConstants';\n\n// check whether there is a request for the date with overlapping times\n// extend startTime/endTime rather than creating multiple\n// ... only pertains to { requestType: DO_NOT_SCHEDULE }\nexport function mergePersonRequests({ personRequests, personId, requests }) {\n  if (!personRequests[personId]) personRequests[personId] = [];\n\n  const filteredRequests = requests\n    .filter(({ requestType }) => requestType)\n    .map((request) => {\n      let { date, startTime, endTime } = request;\n\n      // validate requestType\n      if (request.requestType === DO_NOT_SCHEDULE) {\n        date = extractDate(date);\n        startTime = extractTime(startTime);\n        endTime = extractTime(endTime);\n        if (date && startTime && endTime) {\n          return { date, startTime, endTime, requestType: request.requestType };\n        }\n      }\n      return request;\n    })\n    .filter(Boolean);\n\n  // Do not add any request that is missing requestType\n  for (const request of filteredRequests) {\n    request.requestId = generateTimeCode();\n    personRequests[personId].push(request);\n  }\n\n  return { mergeCount: filteredRequests.length };\n}\n","import { checkRequiredParameters } from '../../../../../parameters/checkRequiredParameters';\nimport { addExtension } from '../../../../extensions/addExtension';\nimport { findParticipant } from '../../../../../acquire/findParticipant';\n\nimport { PersonRequests, TournamentRecords } from '../../../../../types/factoryTypes';\nimport { TOURNAMENT_RECORDS } from '../../../../../constants/attributeConstants';\nimport { PERSON_REQUESTS } from '../../../../../constants/extensionConstants';\nimport { SUCCESS } from '../../../../../constants/resultConstants';\n\ntype SavePersonRequestsArgs = {\n  tournamentRecords: TournamentRecords;\n  personRequests?: PersonRequests;\n};\nexport function savePersonRequests(params: SavePersonRequestsArgs) {\n  const { tournamentRecords, personRequests } = params;\n  const paramsCheck = checkRequiredParameters(params, [{ [TOURNAMENT_RECORDS]: true }]);\n  if (paramsCheck.error) return paramsCheck;\n  if (!personRequests) return { ...SUCCESS };\n\n  const tournaments = Object.values(tournamentRecords);\n  for (const tournamentRecord of tournaments) {\n    const tournamentParticipants = tournamentRecord.participants ?? [];\n    const relevantPersonRequests: any[] = [];\n    for (const personId of Object.keys(personRequests)) {\n      if (findParticipant({ tournamentParticipants, personId })) {\n        const requests = personRequests[personId];\n        if (requests.length) relevantPersonRequests.push({ personId, requests });\n      }\n    }\n\n    if (Object.keys(relevantPersonRequests).length) {\n      const extension = {\n        value: relevantPersonRequests,\n        name: PERSON_REQUESTS,\n      };\n      addExtension({ element: tournamentRecord, extension });\n    }\n  }\n\n  return { ...SUCCESS };\n}\n","import { matchUpFormatTimes } from '../../../../query/extensions/matchUpFormatTiming/getMatchUpFormatTiming';\nimport { getScheduleTiming } from '../../../../query/extensions/matchUpFormatTiming/getScheduleTiming';\nimport { competitionScheduleMatchUps } from '../../../../query/matchUps/competitionScheduleMatchUps';\nimport { calculatePeriodLength } from '../schedulers/utils/calculatePeriodLength';\nimport { getVenuesAndCourts } from '../../../../query/venues/venuesAndCourtsGetter';\nimport { getMatchUpId } from '../../../../global/functions/extractors';\nimport { getScheduleTimes } from '../../../../query/venues/getScheduleTimes';\nimport {\n  addMinutesToTimeString,\n  extractTime,\n  sameDay,\n  timeStringMinutes,\n} from '../../../../utilities/dateTime';\n\nimport { Tournament } from '../../../../types/tournamentTypes';\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../../../constants/errorConditionConstants';\n\ntype CalculateScheduleTimesArgs = {\n  tournamentRecords: { [key: string]: Tournament };\n  calculateStartTimeFromCourts?: boolean;\n  remainingScheduleTimes?: string[];\n  defaultRecoveryMinutes?: number;\n  averageMatchUpMinutes?: number;\n  clearScheduleDates?: boolean;\n  periodLength?: number;\n  scheduleDate: string;\n  venueIds?: string[];\n  startTime?: string;\n  endTime?: string;\n};\nexport function calculateScheduleTimes({\n  calculateStartTimeFromCourts = true,\n  defaultRecoveryMinutes = 0,\n  averageMatchUpMinutes = 90,\n  remainingScheduleTimes,\n  clearScheduleDates,\n  tournamentRecords,\n  periodLength,\n  scheduleDate,\n  startTime,\n  venueIds,\n  endTime,\n}: CalculateScheduleTimesArgs): {\n  dateScheduledMatchUpIds?: string[];\n  totalMatchUps?: number;\n  scheduleTimes?: any[];\n  timingProfile?: any;\n  error?: ErrorType;\n  venueId?: string;\n} {\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  periodLength =\n    periodLength ??\n    calculatePeriodLength({\n      recoveryMinutes: defaultRecoveryMinutes,\n      averageMatchUpMinutes,\n    });\n\n  const { courts: allCourts, venues } = getVenuesAndCourts({\n    dates: [scheduleDate],\n    ignoreDisabled: true,\n    tournamentRecords,\n  });\n\n  const courts = allCourts?.filter(\n    (court) => !venueIds || venueIds.includes(court.venueId)\n  );\n\n  if (!startTime) {\n    startTime = courts?.reduce((minStartTime, court) => {\n      const dateAvailability = court.dateAvailability?.find(\n        // if no date is specified consider it to be default for all tournament dates\n        (availability) =>\n          !availability.date || sameDay(scheduleDate, availability.date)\n      );\n      const comparisonStartTime =\n        dateAvailability?.startTime ?? court.startTime;\n\n      return comparisonStartTime &&\n        (!minStartTime ||\n          timeStringMinutes(comparisonStartTime) <\n            timeStringMinutes(minStartTime))\n        ? comparisonStartTime\n        : minStartTime;\n    }, undefined);\n  }\n\n  if (!endTime) {\n    endTime = courts?.reduce((maxEndTime, court) => {\n      const dateAvailability = court.dateAvailability?.find(\n        // if no date is specified consider it to be default for all tournament dates\n        (availability) =>\n          !availability.date || sameDay(scheduleDate, availability.date)\n      );\n      const comparisonEndTime = dateAvailability?.endTime ?? court.endTime;\n\n      return comparisonEndTime &&\n        (!maxEndTime ||\n          timeStringMinutes(comparisonEndTime) > timeStringMinutes(maxEndTime))\n        ? comparisonEndTime\n        : maxEndTime;\n    }, undefined);\n  }\n\n  // get a mapping of eventIds to category details\n  const tournaments = Object.values(tournamentRecords);\n  const eventDetails = Object.assign(\n    {},\n    ...tournaments\n      .map((tournamentRecord) =>\n        (tournamentRecord.events ?? []).map((event) => {\n          const { scheduleTiming } = getScheduleTiming({\n            tournamentRecord,\n            event,\n          });\n\n          return {\n            [event.eventId]: { event, scheduleTiming },\n          };\n        })\n      )\n      .flat()\n  );\n\n  // Get an array of all matchUps scheduled for the date\n  // some of them may have courts assigned and some may only have venueIds\n  // need to reduce courts available for a given time period by the number of matchUps scheduled at a given venue\n  const matchUpFilters = { scheduledDate: scheduleDate, venueIds };\n  const matchUpsWithSchedule = competitionScheduleMatchUps({\n    sortDateMatchUps: false, // unnecessary for extracting bookings; reduce processing overhead;\n    tournamentRecords,\n    matchUpFilters,\n  });\n  const dateMatchUps = matchUpsWithSchedule?.dateMatchUps ?? [];\n  const completedMatchUps = matchUpsWithSchedule?.completedMatchUps ?? [];\n\n  const relevantMatchUps: any[] = [];\n  relevantMatchUps.push(...dateMatchUps);\n  relevantMatchUps.push(...completedMatchUps);\n\n  const defaultTiming = {\n    averageTimes: [{ minutes: { default: averageMatchUpMinutes } }],\n    recoveryTimes: [{ minutes: { default: defaultRecoveryMinutes } }],\n  };\n\n  const bookings = relevantMatchUps?.map(\n    ({ eventId, schedule, matchUpFormat }) => {\n      const { event, scheduleTiming } = eventDetails[eventId];\n      const eventType = event?.eventType;\n      const timingDetails = {\n        ...scheduleTiming,\n        defaultTiming,\n        matchUpFormat,\n      };\n      const { averageMinutes, recoveryMinutes } = matchUpFormatTimes({\n        eventType,\n        timingDetails,\n      });\n      const { courtId, venueId } = schedule;\n      const startTime = extractTime(schedule.scheduledTime);\n      const endTime = addMinutesToTimeString(startTime, averageMinutes);\n      return {\n        recoveryMinutes,\n        averageMinutes,\n        periodLength,\n        startTime,\n        endTime,\n        courtId,\n        venueId,\n      };\n    }\n  );\n\n  const timingParameters = {\n    calculateStartTimeFromCourts,\n    remainingScheduleTimes,\n    averageMatchUpMinutes,\n    date: scheduleDate,\n    clearScheduleDates,\n    periodLength,\n    startTime,\n    endTime,\n    bookings,\n    courts,\n  };\n  const { scheduleTimes } = getScheduleTimes(timingParameters);\n\n  // if a single venue specified, or only one venue available, return venueId\n  const venueId =\n    (venueIds?.length === 1 && venueIds[0]) ||\n    (venues?.length === 1 && venues[0].venueId) ||\n    undefined;\n\n  const dateScheduledMatchUpIds = relevantMatchUps.map(getMatchUpId);\n\n  return { venueId, scheduleTimes, dateScheduledMatchUpIds };\n}\n","import { addExtension } from '../../extensions/addExtension';\nimport { findExtension } from '../../../acquire/findExtension';\nimport { findEvent } from '../../../acquire/findEvent';\n\nimport { SCHEDULE_TIMING } from '../../../constants/extensionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  EVENT_NOT_FOUND,\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../../constants/errorConditionConstants';\n\nexport function modifyMatchUpFormatTiming(params) {\n  const { matchUpFormat, recoveryTimes, averageTimes, tournamentId, eventId } =\n    params;\n\n  const tournamentRecords =\n    params?.tournamentRecords ??\n    (params?.tournamentRecord && {\n      [params.tournamentRecord.tournamentId]: params.tournamentRecord,\n    }) ??\n    {};\n\n  if (!Object.keys(tournamentRecords).length)\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const tournamentIds = Object.keys(tournamentRecords).filter(\n    (currentTournamentId) =>\n      !tournamentId || tournamentId === currentTournamentId\n  );\n\n  if (tournamentId && !tournamentIds.includes(tournamentId))\n    return { error: INVALID_VALUES };\n\n  let eventModified;\n  for (const currentTournamentId of tournamentIds) {\n    const tournamentRecord = tournamentRecords[currentTournamentId];\n    const { event } = findEvent({ tournamentRecord, eventId });\n    if (eventId && event) eventModified = true;\n\n    const result = modifyTiming({\n      tournamentRecord,\n      event,\n\n      matchUpFormat,\n      averageTimes,\n      recoveryTimes,\n    });\n    if (result.error) return result;\n  }\n\n  return !eventId || eventModified\n    ? { ...SUCCESS }\n    : { error: EVENT_NOT_FOUND };\n}\n\nfunction modifyTiming({\n  tournamentRecord,\n  recoveryTimes,\n  matchUpFormat,\n  averageTimes,\n  event,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (averageTimes && !Array.isArray(averageTimes))\n    return { error: INVALID_VALUES };\n  if (recoveryTimes && !Array.isArray(recoveryTimes))\n    return { error: INVALID_VALUES };\n\n  const name = SCHEDULE_TIMING;\n\n  if (event) {\n    const { extension } = findExtension({ element: event, name });\n    const eventScheduling = extension?.value || {};\n    const value = modifyScheduling({\n      ...eventScheduling,\n      matchUpFormat,\n      averageTimes,\n      recoveryTimes,\n    });\n    addExtension({ element: event, extension: { name, value } });\n  } else {\n    const { extension } = findExtension({\n      element: tournamentRecord,\n      name,\n    });\n    const tournamentScheduling = extension?.value || {};\n    const value = modifyScheduling({\n      ...tournamentScheduling,\n      matchUpFormat,\n      averageTimes,\n      recoveryTimes,\n    });\n    addExtension({\n      extension: { name, value },\n      element: tournamentRecord,\n    });\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction modifyScheduling(params) {\n  const {\n    matchUpRecoveryTimes = [],\n    matchUpAverageTimes = [],\n    matchUpFormat,\n  } = params;\n\n  let { averageTimes: formatAverageTimes, recoveryTimes: formatRecoveryTimes } =\n    params;\n\n  // don't allow modification without categoryName\n  formatAverageTimes = (formatAverageTimes || []).filter(\n    (averageTime) =>\n      averageTime?.categoryNames?.length || averageTime?.categoryTypes?.length\n  );\n  // if there are formatAverageTimes specified...\n  const updatedMatchUpAverageTimes =\n    formatAverageTimes?.length &&\n    matchUpAverageTimes\n      .map((definition) =>\n        // filter out any existing definitions for this matchUpFormat\n        definition?.matchUpFormatCodes.includes(matchUpFormat)\n          ? {\n              ...definition,\n              matchUpFormatCodes: definition.matchUpFormatCodes?.filter(\n                (code) => code !== matchUpFormat\n              ),\n            }\n          : definition\n      )\n      // filter out any definitions that no longer have matchUpFormatCodes\n      .filter(({ matchUpFormatCodes }) => matchUpFormatCodes?.length)\n      .concat({\n        matchUpFormatCodes: [matchUpFormat],\n        averageTimes: formatAverageTimes,\n      });\n\n  // don't allow modification without categoryName\n  formatRecoveryTimes = (formatRecoveryTimes || []).filter(\n    (recoveryTime) =>\n      recoveryTime?.categoryNames?.length || recoveryTime?.categoryTypes?.length\n  );\n  // if there are formatRecoveryTimes specified...\n  const updatedMatchUpRecoveryTimes =\n    formatRecoveryTimes?.length &&\n    matchUpRecoveryTimes\n      .map((definition) =>\n        // filter out any existing definitions for this matchUpFormat\n        definition?.matchUpFormatCodes.includes(matchUpFormat)\n          ? {\n              ...definition,\n              matchUpFormatCodes: definition.matchUpFormatCodes?.filter(\n                (code) => code !== matchUpFormat\n              ),\n            }\n          : definition\n      )\n      // filter out any definitions that no longer have matchUpFormatCodes OR averageTimes\n      // recoveryTimes can be keyed to averageTimes instead of matchUpFormats...\n      .filter(\n        ({ matchUpFormatCodes, averageTimes }) =>\n          matchUpFormatCodes?.length || averageTimes\n      )\n      .concat({\n        matchUpFormatCodes: [matchUpFormat],\n        recoveryTimes: formatRecoveryTimes,\n      });\n\n  return {\n    matchUpAverageTimes:\n      (updatedMatchUpAverageTimes?.length && updatedMatchUpAverageTimes) ||\n      matchUpAverageTimes,\n    matchUpRecoveryTimes:\n      (updatedMatchUpRecoveryTimes?.length && updatedMatchUpRecoveryTimes) ||\n      matchUpRecoveryTimes,\n  };\n}\n","import { checkRequiredParameters } from '../../../parameters/checkRequiredParameters';\nimport { removeEventExtension } from '../../extensions/addRemoveExtensions';\nimport { findEvent } from '../../../acquire/findEvent';\n\nimport { EVENT_ID, TOURNAMENT_RECORDS } from '../../../constants/attributeConstants';\nimport { EVENT_NOT_FOUND } from '../../../constants/errorConditionConstants';\nimport { SCHEDULE_TIMING } from '../../../constants/extensionConstants';\nimport { Event, Tournament } from '../../../types/tournamentTypes';\nimport { TournamentRecords } from '../../../types/factoryTypes';\n\ntype RemoveEventMatchUpFormatTimingArgs = {\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  eventId: string;\n  event?: Event;\n};\nexport function removeEventMatchUpFormatTiming(params: RemoveEventMatchUpFormatTimingArgs) {\n  if (params.event) {\n    return removeTiming({ event: params.event });\n  } else {\n    if (params.tournamentRecord && !params.tournamentRecords) {\n      params.tournamentRecords = {\n        [params.tournamentRecord.tournamentId]: params.tournamentRecord,\n      };\n    }\n    const paramCheck = checkRequiredParameters(params, [{ [TOURNAMENT_RECORDS]: true, [EVENT_ID]: true }]);\n    if (paramCheck.error) return paramCheck;\n\n    const { tournamentRecords, eventId } = params;\n    for (const tournamentRecord of Object.values(tournamentRecords ?? {})) {\n      const { event } = findEvent({ tournamentRecord, eventId });\n      if (event) return removeTiming({ event });\n    }\n  }\n\n  return { error: EVENT_NOT_FOUND };\n}\n\nfunction removeTiming({ event }) {\n  return removeEventExtension({ event, name: SCHEDULE_TIMING });\n}\n","import { hasSchedule } from './scheduleMatchUps/hasSchedule';\nimport { addMatchUpScheduledDate } from './scheduleItems';\nimport { addMatchUpScheduledTime } from './scheduledTime';\nimport { allTournamentMatchUps } from '../../../query/matchUps/getAllTournamentMatchUps';\nimport { resolveTournamentRecords } from '../../../parameters/resolveTournamentRecords';\nimport { completedMatchUpStatuses } from '../../../constants/matchUpStatusConstants';\nimport { getTournamentInfo } from '../../../query/tournaments/getTournamentInfo';\nimport { findDrawDefinition } from '../../../acquire/findDrawDefinition';\nimport { getMatchUpIds } from '../../../global/functions/extractors';\nimport {\n  addMinutesToTimeString,\n  dateStringDaysChange,\n  extractDate,\n  extractTime,\n  timeStringMinutes,\n} from '../../../utilities/dateTime';\n\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { TournamentRecords } from '../../../types/factoryTypes';\nimport { Tournament } from '../../../types/tournamentTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_MATCHUP_IDS,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../../constants/errorConditionConstants';\n\ntype BulkRescheduleMatchUpsArgs = {\n  tournamentRecords: TournamentRecords;\n  tournamentRecord: Tournament;\n  matchUpIds: string[];\n  scheduleChange: any;\n  dryRun?: boolean;\n};\nexport function bulkRescheduleMatchUps(\n  params: BulkRescheduleMatchUpsArgs\n): ResultType & {\n  allRescheduled?: boolean;\n  notRescheduled?: any[];\n  rescheduled?: any[];\n} {\n  const { scheduleChange, matchUpIds, dryRun } = params;\n  if (!matchUpIds || !Array.isArray(matchUpIds))\n    return { error: MISSING_MATCHUP_IDS };\n  if (typeof scheduleChange !== 'object') return { error: INVALID_VALUES };\n\n  const tournamentRecords = resolveTournamentRecords(params);\n\n  const rescheduled: any[] = [];\n  let notRescheduled: any[] = [];\n\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const result = bulkReschedule({\n      tournamentRecord,\n      scheduleChange,\n      matchUpIds,\n      dryRun,\n    });\n    if (result.error) return result;\n\n    if (Array.isArray(result.notRescheduled))\n      notRescheduled.push(...result.notRescheduled);\n\n    // this is a check in case something has been rescheduled multiple times in the same call\n    const notRescheduledIds = getMatchUpIds(result.notRescheduled);\n    const removeFromNotScheduledIds: string[] = [];\n    result.rescheduled?.forEach((matchUp) => {\n      const { matchUpId } = matchUp;\n      if (notRescheduledIds.includes(matchUpId)) {\n        removeFromNotScheduledIds.push(matchUpId);\n      }\n      rescheduled.push(matchUp);\n    });\n\n    if (removeFromNotScheduledIds.length) {\n      notRescheduled =\n        result?.notRescheduled?.filter(\n          ({ matchUpId }) => !removeFromNotScheduledIds.includes(matchUpId)\n        ) || [];\n    }\n  }\n\n  const allRescheduled = !!(rescheduled.length && !notRescheduled.length);\n\n  return { ...SUCCESS, rescheduled, notRescheduled, allRescheduled };\n}\n/**\n *\n * @param {object} tournamentRecord - passed in automatically by tournamentEngine\n * @param {string[]} matchUpIds - array of matchUpIds to be scheduled\n * @param {object} scheduleChange - { minutesChange, daysChange }\n *\n */\n\nexport function bulkReschedule({\n  tournamentRecord,\n  scheduleChange,\n  matchUpIds,\n  dryRun,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!matchUpIds || !Array.isArray(matchUpIds))\n    return { error: MISSING_MATCHUP_IDS };\n  if (typeof scheduleChange !== 'object') return { error: INVALID_VALUES };\n\n  const rescheduledMatchUpIds: string[] = [];\n  const notRescheduledMatchUpIds: string[] = [];\n  const { minutesChange, daysChange } = scheduleChange;\n  if (!minutesChange && !daysChange) return { ...SUCCESS };\n\n  if (minutesChange && isNaN(minutesChange)) return { error: INVALID_VALUES };\n  if (daysChange && isNaN(daysChange)) return { error: INVALID_VALUES };\n\n  const { matchUps } = allTournamentMatchUps({\n    matchUpFilters: { matchUpIds },\n    tournamentRecord,\n  });\n\n  const notCompleted = ({ matchUpStatus }) =>\n    !completedMatchUpStatuses.includes(matchUpStatus);\n\n  // return success if there are no scheduled matchUps to reschedule\n  const scheduledNotCompletedMatchUps = matchUps\n    ?.filter((matchUp) => hasSchedule({ schedule: matchUp.schedule }))\n    .filter((matchUp) =>\n      notCompleted({ matchUpStatus: matchUp.matchUpStatus })\n    );\n  if (!scheduledNotCompletedMatchUps?.length) return { ...SUCCESS };\n\n  const { tournamentInfo } = getTournamentInfo({ tournamentRecord });\n  const { startDate, endDate } = tournamentInfo;\n\n  // first organize matchUpIds by drawId\n  const drawIdMap = scheduledNotCompletedMatchUps?.reduce(\n    (drawIdMap, matchUp) => {\n      const { matchUpId, drawId } = matchUp;\n      if (drawIdMap[drawId]) {\n        drawIdMap[drawId].push(matchUpId);\n      } else {\n        drawIdMap[drawId] = [matchUpId];\n      }\n      return drawIdMap;\n    },\n    {}\n  );\n\n  const dayTotalMinutes = 1440;\n  for (const drawId of Object.keys(drawIdMap)) {\n    const result = findDrawDefinition({\n      tournamentRecord,\n      drawId,\n    });\n    if (result.error) return result;\n    const drawDefinition = result.drawDefinition;\n\n    const drawMatchUpIds = drawIdMap[drawId].filter((matchUpId) =>\n      matchUpIds.includes(matchUpId)\n    );\n\n    for (const matchUpId of drawMatchUpIds) {\n      if (matchUpId && drawDefinition) {\n        const inContextMatchUp = scheduledNotCompletedMatchUps.find(\n          (matchUp) => matchUp.matchUpId === matchUpId\n        );\n        const schedule = inContextMatchUp?.schedule;\n        const { scheduledTime, scheduledDate } = schedule;\n\n        let doNotReschedule, newScheduledTime, newScheduledDate;\n        if (!doNotReschedule && daysChange && scheduledDate) {\n          const currentDate = extractDate(scheduledDate);\n          newScheduledDate = dateStringDaysChange(currentDate, daysChange);\n\n          doNotReschedule =\n            new Date(newScheduledDate) < new Date(startDate) ||\n            new Date(newScheduledDate) > new Date(endDate);\n        }\n\n        if (minutesChange && scheduledTime) {\n          const scheduledTimeDate = extractDate(scheduledTime);\n          const currentDayMinutes = timeStringMinutes(\n            extractTime(scheduledTime)\n          );\n          const newTime = currentDayMinutes + minutesChange;\n          doNotReschedule = newTime < 0 || newTime > dayTotalMinutes;\n\n          if (!doNotReschedule) {\n            const timeString = addMinutesToTimeString(\n              scheduledTime,\n              minutesChange\n            );\n\n            const timeStringDate =\n              (scheduledTimeDate && newScheduledDate) ||\n              (scheduledDate === scheduledTimeDate && scheduledTimeDate);\n\n            newScheduledTime = timeStringDate\n              ? `${timeStringDate}T${timeString}`\n              : timeString;\n          }\n        }\n\n        if (doNotReschedule) {\n          notRescheduledMatchUpIds.push(matchUpId);\n        } else {\n          if (!dryRun) {\n            if (newScheduledTime) {\n              const result = addMatchUpScheduledTime({\n                scheduledTime: newScheduledTime,\n                drawDefinition,\n                matchUpId,\n              });\n              if (result.error) return result;\n            }\n            if (newScheduledDate) {\n              const result = addMatchUpScheduledDate({\n                scheduledDate: newScheduledDate,\n                drawDefinition,\n                matchUpId,\n              });\n              if (result.error) return result;\n            }\n          }\n          if (newScheduledTime || newScheduledDate) {\n            rescheduledMatchUpIds.push(matchUpId);\n          }\n        }\n      }\n    }\n  }\n\n  const updatedInContext =\n    allTournamentMatchUps({\n      matchUpFilters: { matchUpIds },\n      tournamentRecord,\n    }).matchUps ?? [];\n\n  const rescheduled = updatedInContext.filter(({ matchUpId }) =>\n    rescheduledMatchUpIds.includes(matchUpId)\n  );\n  const notRescheduled = updatedInContext.filter(({ matchUpId }) =>\n    notRescheduledMatchUpIds.includes(matchUpId)\n  );\n\n  const allRescheduled = rescheduled.length && !notRescheduled.length;\n\n  return { ...SUCCESS, rescheduled, notRescheduled, allRescheduled };\n}\n","import { modifyPersonRequests } from '../../../mutate/matchUps/schedule/scheduleMatchUps/personRequests/modifyPersonRequests';\nimport { removePersonRequests } from '../../../mutate/matchUps/schedule/scheduleMatchUps/personRequests/removePersonRequests';\nimport { addPersonRequests } from '../../../mutate/matchUps/schedule/scheduleMatchUps/personRequests/addPersonRequests';\nimport { calculateScheduleTimes } from '../../../mutate/matchUps/schedule/scheduleMatchUps/calculateScheduleTimes';\nimport { modifyEventMatchUpFormatTiming } from '../../../mutate/events/extensions/modifyEventMatchUpFormatTiming';\nimport { removeEventMatchUpFormatTiming } from '../../../mutate/events/extensions/removeEventMatchUpFormatTiming';\nimport { bulkScheduleTournamentMatchUps } from '../../../mutate/matchUps/schedule/bulkScheduleTournamentMatchUps';\nimport { generateVirtualCourts } from '../../../mutate/matchUps/schedule/schedulers/utils/generateVirtualCourts';\nimport { toggleParticipantCheckInState } from '../../../mutate/matchUps/timeItems/toggleParticipantCheckInState';\nimport { removeMatchUpCourtAssignment } from '../../../mutate/matchUps/schedule/removeMatchUpCourtAssignment';\nimport { proAutoSchedule } from '../../../mutate/matchUps/schedule/schedulers/proScheduler/proAutoSchedule';\nimport { modifyMatchUpFormatTiming } from '../../../mutate/matchUps/extensions/modifyMatchUpFormatTiming';\nimport { bulkUpdateCourtAssignments } from '../../../mutate/matchUps/schedule/bulkUpdateCourtAssignments';\nimport { allocateTeamMatchUpCourts } from '../../../mutate/matchUps/schedule/allocateTeamMatchUpCourts';\nimport { scheduleMatchUps } from '../../../mutate/matchUps/schedule/scheduleMatchUps/scheduleMatchUps';\nimport { generateBookings } from '../../../mutate/matchUps/schedule/schedulers/utils/generateBookings';\nimport { addSchedulingProfileRound } from '../../../mutate/matchUps/schedule/addSchedulingProfileRound';\nimport { proConflicts } from '../../../mutate/matchUps/schedule/schedulers/proScheduler/proConflicts';\nimport { reorderUpcomingMatchUps } from '../../../mutate/matchUps/schedule/reorderUpcomingMatchUps';\nimport { bulkRescheduleMatchUps } from '../../../mutate/matchUps/schedule/bulkRescheduleMatchUps';\nimport { clearScheduledMatchUps } from '../../../mutate/matchUps/schedule/clearScheduledMatchUps';\nimport { matchUpScheduleChange } from '../../../mutate/matchUps/schedule/matchUpScheduleChange';\nimport { bulkScheduleMatchUps } from '../../../mutate/matchUps/schedule/bulkScheduleMatchUps';\nimport { scheduleProfileRounds } from '../../../mutate/matchUps/schedule/scheduleProfileRounds';\nimport { clearMatchUpSchedule } from '../../../mutate/matchUps/schedule/clearMatchUpSchedule';\nimport { addMatchUpScheduledTime } from '../../../mutate/matchUps/schedule/scheduledTime';\nimport { setMatchUpDailyLimits } from '../../../mutate/tournaments/setMatchUpDailyLimits';\nimport { assignMatchUpCourt } from '../../../mutate/matchUps/schedule/assignMatchUpCourt';\nimport { assignMatchUpVenue } from '../../../mutate/matchUps/schedule/assignMatchUpVenue';\nimport { validateSchedulingProfile } from '../../../validators/validateSchedulingProfile';\nimport { findMatchUpFormatTiming } from '../../../acquire/findMatchUpFormatTiming';\nimport { getProfileRounds } from '../../../mutate/matchUps/schedule/profileRounds';\nimport { courtGridRows } from '../../generators/scheduling/courtGridRows';\nimport { publicFindCourt } from '../../../mutate/venues/findCourt';\nimport { findVenue } from '../../../mutate/venues/findVenue';\n\nimport {\n  addMatchUpCourtOrder,\n  addMatchUpScheduledDate,\n  addMatchUpStartTime,\n  addMatchUpEndTime,\n  addMatchUpStopTime,\n  addMatchUpResumeTime,\n  addMatchUpOfficial,\n  addMatchUpScheduleItems,\n} from '../../../mutate/matchUps/schedule/scheduleItems';\nimport {\n  getSchedulingProfile,\n  setSchedulingProfile,\n} from '../../../mutate/tournaments/schedulingProfile';\n\nexport const scheduleGovernor = {\n  addMatchUpCourtOrder,\n  addMatchUpEndTime,\n  addMatchUpOfficial,\n  addMatchUpResumeTime,\n  addMatchUpScheduledDate,\n  addMatchUpScheduledTime,\n  addMatchUpScheduleItems,\n  addMatchUpStartTime,\n  addMatchUpStopTime,\n  addPersonRequests,\n  addSchedulingProfileRound,\n  allocateTeamMatchUpCourts,\n  assignMatchUpCourt,\n  assignMatchUpVenue,\n  bulkRescheduleMatchUps,\n  bulkScheduleMatchUps,\n  bulkScheduleTournamentMatchUps,\n  bulkUpdateCourtAssignments,\n  calculateScheduleTimes,\n  clearMatchUpSchedule,\n  clearScheduledMatchUps,\n  courtGridRows,\n  findCourt: publicFindCourt,\n  findMatchUpFormatTiming,\n  findVenue,\n  generateBookings,\n  generateVirtualCourts,\n  getProfileRounds,\n  getSchedulingProfile,\n  matchUpScheduleChange,\n  modifyEventMatchUpFormatTiming,\n  modifyMatchUpFormatTiming,\n  modifyPersonRequests,\n  proAutoSchedule,\n  proConflicts,\n  removeEventMatchUpFormatTiming,\n  removeMatchUpCourtAssignment,\n  removePersonRequests,\n  reorderUpcomingMatchUps,\n  scheduleMatchUps,\n  scheduleProfileRounds,\n  setMatchUpDailyLimits, // document\n  setSchedulingProfile,\n  toggleParticipantCheckInState,\n  validateSchedulingProfile,\n};\n\nexport default scheduleGovernor;\n","import { checkRequiredParameters } from '../../../../../parameters/checkRequiredParameters';\nimport { mergePersonRequests } from './mergePersonRequests';\nimport { savePersonRequests } from './savePersonRequests';\nimport { getPersonRequests } from '../../../../../query/matchUps/scheduling/getPersonRequests';\n\nimport { INVALID_VALUES } from '../../../../../constants/errorConditionConstants';\nimport { TournamentRecords } from '../../../../../types/factoryTypes';\nimport {\n  ARRAY,\n  INVALID,\n  OF_TYPE,\n  PERSON_ID,\n  TOURNAMENT_RECORDS,\n} from '../../../../../constants/attributeConstants';\n\ntype AddPersonRequestsArgs = {\n  tournamentRecords: TournamentRecords;\n  requests: Request[];\n  personId: string;\n};\nexport function addPersonRequests(params: AddPersonRequestsArgs) {\n  const { tournamentRecords, personId, requests } = params;\n  const paramsCheck = checkRequiredParameters(params, [\n    { [TOURNAMENT_RECORDS]: true, [PERSON_ID]: true },\n    { requests: true, [OF_TYPE]: ARRAY, [INVALID]: INVALID_VALUES },\n  ]);\n  if (paramsCheck.error) return paramsCheck;\n\n  const { personRequests } = getPersonRequests({ tournamentRecords });\n\n  const { mergeCount } = mergePersonRequests({\n    personRequests,\n    personId,\n    requests,\n  });\n\n  if (mergeCount && personRequests) {\n    return savePersonRequests({ tournamentRecords, personRequests });\n  } else {\n    return { error: INVALID_VALUES };\n  }\n}\n","import { checkRequiredParameters } from '../../../parameters/checkRequiredParameters';\nimport { assignMatchUpCourt } from './assignMatchUpCourt';\nimport { findEvent } from '../../../acquire/findEvent';\n\nimport { ARRAY, INVALID, OF_TYPE, TOURNAMENT_RECORDS } from '../../../constants/attributeConstants';\nimport { TournamentRecords } from '../../../types/factoryTypes';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  MISSING_DRAW_DEFINITION,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n  UNABLE_TO_ASSIGN_COURT,\n} from '../../../constants/errorConditionConstants';\n\ntype BulkUpdateCourtAssignmentsParams = {\n  tournamentRecords: TournamentRecords;\n  courtAssignments: any[];\n  courtDayDate: string;\n};\n\nexport function bulkUpdateCourtAssignments(params: BulkUpdateCourtAssignmentsParams) {\n  const { courtDayDate } = params;\n  const paramsCheck = checkRequiredParameters(params, [\n    { courtAssignments: true, [OF_TYPE]: ARRAY, [INVALID]: MISSING_VALUE },\n    { [TOURNAMENT_RECORDS]: true },\n  ]);\n  if (paramsCheck.error) return paramsCheck;\n\n  const tournamentMap = params.courtAssignments.reduce((tournamentMap, assignment) => {\n    const { tournamentId } = assignment;\n    if (!tournamentMap[tournamentId]) tournamentMap[tournamentId] = [];\n    tournamentMap[tournamentId].push(assignment);\n    return tournamentMap;\n  }, {});\n\n  let error;\n  const tournamentIds = Object.keys(tournamentMap);\n  tournamentIds.every((tournamentId) => {\n    const tournamentRecord = params[TOURNAMENT_RECORDS][tournamentId];\n    if (!tournamentRecord) {\n      error = { error: MISSING_TOURNAMENT_RECORD };\n      return false;\n    }\n    const drawMap = tournamentMap[tournamentId].reduce((drawMap, assignment) => {\n      const { drawId } = assignment;\n      if (!drawMap[drawId]) drawMap[drawId] = [];\n      drawMap[drawId].push(assignment);\n      return drawMap;\n    }, {});\n    const drawIds = Object.keys(drawMap);\n    drawIds.every((drawId) => {\n      const { drawDefinition } = findEvent({ tournamentRecord, drawId });\n      if (!drawDefinition) {\n        error = { error: MISSING_DRAW_DEFINITION };\n        return false;\n      }\n      drawMap[drawId].every((assignment) => {\n        const { matchUpId, courtId } = assignment;\n        const result = assignMatchUpCourt({\n          tournamentRecord,\n          drawDefinition,\n          courtDayDate,\n          matchUpId,\n          courtId,\n        });\n        if (result.success) {\n          return result?.success;\n        } else {\n          error = { error: UNABLE_TO_ASSIGN_COURT };\n        }\n        return undefined;\n      });\n\n      return true;\n    });\n    return undefined;\n  });\n\n  return error || SUCCESS;\n}\n","import { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { allTournamentMatchUps } from '../../../query/matchUps/getAllTournamentMatchUps';\nimport { allDrawMatchUps } from '../../../query/matchUps/getAllDrawMatchUps';\n\nimport { MATCHUP_NOT_FOUND } from '../../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  ALLOCATE_COURTS,\n  ASSIGN_COURT,\n  ASSIGN_VENUE,\n  END_TIME,\n  RESUME_TIME,\n  SCHEDULED_DATE,\n  SCHEDULED_TIME,\n  START_TIME,\n  STOP_TIME,\n} from '../../../constants/timeItemConstants';\n\nexport function clearMatchUpSchedule({\n  scheduleAttributes = [\n    ALLOCATE_COURTS,\n    ASSIGN_COURT,\n    ASSIGN_VENUE,\n    SCHEDULED_DATE,\n    SCHEDULED_TIME,\n    START_TIME,\n    END_TIME,\n    RESUME_TIME,\n    STOP_TIME,\n  ],\n  tournamentRecord,\n  drawDefinition,\n  matchUpId,\n}) {\n  const stack = 'clearMatchUpSchedule';\n  const matchUp = drawDefinition\n    ? allDrawMatchUps({\n        matchUpFilters: { matchUpIds: [matchUpId] },\n        inContext: false,\n        drawDefinition,\n      }).matchUps?.[0]\n    : allTournamentMatchUps({\n        matchUpFilters: { matchUpIds: [matchUpId] },\n        tournamentRecord,\n        inContext: false,\n      }).matchUps?.[0];\n\n  if (!matchUp) return { error: MATCHUP_NOT_FOUND };\n\n  const newTimeItems = (matchUp.timeItems ?? []).filter(\n    (timeItem) =>\n      timeItem?.itemType && !scheduleAttributes.includes(timeItem?.itemType)\n  );\n  matchUp.timeItems = newTimeItems;\n\n  modifyMatchUpNotice({\n    tournamentId: tournamentRecord.tournamentId,\n    context: stack,\n    drawDefinition,\n    matchUp,\n  });\n\n  return { ...SUCCESS };\n}\n","import { assignMatchUpCourt } from './assignMatchUpCourt';\nimport { allocateTeamMatchUpCourts } from './allocateTeamMatchUpCourts';\nimport { findDrawDefinition } from '../../../acquire/findDrawDefinition';\nimport { decorateResult } from '../../../global/functions/decorateResult';\nimport { allCompetitionMatchUps } from '../../../query/matchUps/getAllCompetitionMatchUps';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { TEAM } from '../../../constants/matchUpTypes';\nimport {\n  ErrorType,\n  MISSING_TOURNAMENT_RECORDS,\n  MISSING_VALUE,\n  NO_MODIFICATIONS_APPLIED,\n} from '../../../constants/errorConditionConstants';\n\nexport function matchUpScheduleChange(params) {\n  const stack = 'matchUpScheduleChange';\n  const { tournamentRecords } = params;\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  const {\n    sourceMatchUpContextIds,\n    targetMatchUpContextIds,\n    sourceCourtId,\n    targetCourtId,\n    courtDayDate,\n  } = params || {};\n\n  const {\n    drawId: sourceDrawId,\n    matchUpId: sourceMatchUpId,\n    tournamentId: sourceTournamentId,\n  } = sourceMatchUpContextIds || {};\n\n  const {\n    drawId: targetDrawId,\n    matchUpId: targetMatchUpId,\n    tournamentId: targetTournamentId,\n  } = targetMatchUpContextIds || {};\n\n  if (!sourceMatchUpId && !targetMatchUpId)\n    return decorateResult({ result: { error: MISSING_VALUE }, stack });\n\n  const { matchUps } = allCompetitionMatchUps({\n    matchUpFilters: {\n      matchUpIds: [sourceMatchUpId, targetMatchUpId].filter(Boolean),\n      drawIds: [sourceDrawId, targetDrawId].filter(Boolean),\n    },\n    tournamentRecords: params.tournamentRecords,\n  });\n\n  const sourceMatchUp = matchUps?.find(\n    ({ matchUpId }) => matchUpId === sourceMatchUpId\n  );\n  const targetMatchUp = matchUps?.find(\n    ({ matchUpId }) => matchUpId === targetMatchUpId\n  );\n\n  let matchUpsModified = 0;\n\n  if (targetCourtId && sourceMatchUpId && !targetMatchUpId) {\n    const result = assignMatchUp({\n      tournamentId: sourceTournamentId,\n      matchUpId: sourceMatchUpId,\n      courtId: targetCourtId,\n      matchUp: sourceMatchUp,\n      drawId: sourceDrawId,\n      tournamentRecords,\n      sourceCourtId,\n      courtDayDate,\n    });\n    if (result?.success) matchUpsModified++;\n    if (result.error) return decorateResult({ result, stack });\n  } else if (\n    sourceCourtId &&\n    targetCourtId &&\n    sourceMatchUpId &&\n    targetMatchUpId\n  ) {\n    const sourceResult = assignMatchUp({\n      tournamentId: sourceTournamentId,\n      matchUpId: sourceMatchUpId,\n      courtId: targetCourtId,\n      matchUp: sourceMatchUp,\n      drawId: sourceDrawId,\n      tournamentRecords,\n      sourceCourtId,\n      courtDayDate,\n    });\n    if (sourceResult.success) matchUpsModified++;\n    if (sourceResult.error)\n      return decorateResult({ result: sourceResult, stack, info: 'source' });\n\n    const targetResult = assignMatchUp({\n      tournamentId: targetTournamentId,\n      sourceCourtId: targetCourtId,\n      matchUpId: targetMatchUpId,\n      matchUp: targetMatchUp,\n      courtId: sourceCourtId,\n      drawId: targetDrawId,\n      tournamentRecords,\n      courtDayDate,\n    });\n    if (targetResult.success) matchUpsModified++;\n    if (targetResult.error)\n      return decorateResult({ result: targetResult, stack, info: 'target' });\n  } else {\n    return { error: MISSING_VALUE };\n  }\n\n  return matchUpsModified\n    ? SUCCESS\n    : decorateResult({ result: { error: NO_MODIFICATIONS_APPLIED }, stack });\n\n  function assignMatchUp(params): { error?: ErrorType; success?: boolean } {\n    const { tournamentRecords, tournamentId, matchUp, drawId } = params;\n\n    const tournamentRecord = tournamentRecords[tournamentId];\n    const { drawDefinition } = findDrawDefinition({\n      tournamentRecord,\n      drawId,\n    });\n\n    if (matchUp.matchUpType === TEAM) {\n      return allocateCourts({ ...params, tournamentRecord, drawDefinition });\n    } else {\n      return assignMatchUpCourt({\n        ...params,\n        tournamentRecord,\n        drawDefinition,\n      });\n    }\n  }\n\n  function allocateCourts({\n    removePriorValues,\n    tournamentRecords,\n    tournamentRecord,\n    drawDefinition,\n    sourceCourtId,\n    courtDayDate,\n    matchUpId,\n    matchUp,\n    courtId,\n  }) {\n    const courtIds = [courtId].concat(\n      matchUp.schedule.allocatedCourts\n        .map(({ courtId }) => courtId)\n        .filter((courtId) => courtId !== sourceCourtId)\n    );\n    return allocateTeamMatchUpCourts({\n      removePriorValues,\n      tournamentRecords,\n      tournamentRecord,\n      drawDefinition,\n      courtDayDate,\n      matchUpId,\n      courtIds,\n    });\n  }\n}\n","import { isValidMatchUpFormat } from '../../../validators/isValidMatchUpFormat';\nimport { getModifiedMatchUpFormatTiming } from '../../../query/extensions/matchUpFormatTiming/getModifiedMatchUpTiming';\nimport { modifyMatchUpFormatTiming } from '../../matchUps/extensions/modifyMatchUpFormatTiming';\nimport { Event, Tournament } from '../../../types/tournamentTypes';\nimport { ensureInt } from '../../../utilities/ensureInt';\n\nimport { SINGLES } from '../../../constants/matchUpTypes';\nimport {\n  INVALID_VALUES,\n  MISSING_EVENT,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../../constants/errorConditionConstants';\n\ntype ModifyEventMatchUpFormatTimingArgs = {\n  tournamentRecord: Tournament;\n  recoveryMinutes?: number;\n  averageMinutes?: number;\n  matchUpFormat: string;\n  categoryType?: string;\n  tournamentId?: string;\n  eventId: string;\n  event?: Event;\n};\n\nexport function modifyEventMatchUpFormatTiming(\n  params: ModifyEventMatchUpFormatTimingArgs\n) {\n  const {\n    tournamentRecord,\n    recoveryMinutes,\n    averageMinutes,\n    matchUpFormat,\n    categoryType,\n    eventId,\n    event,\n  } = params;\n\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!isValidMatchUpFormat({ matchUpFormat }))\n    return { error: INVALID_VALUES };\n  if (!event) return { error: MISSING_EVENT };\n\n  const { averageTimes = [], recoveryTimes = [] } =\n    getModifiedMatchUpFormatTiming({\n      tournamentRecord,\n      matchUpFormat,\n      event,\n    });\n\n  const category = event.category;\n  const categoryName =\n    category?.categoryName || category?.ageCategoryCode || event?.eventId;\n\n  let currentAverageTime = { categoryNames: [categoryName], minutes: {} };\n  const currentRecoveryTime = { categoryNames: [categoryName], minutes: {} };\n\n  const newTiming = (timing) => {\n    if (timing.categoryTypes?.includes(categoryType)) {\n      // TODO\n      console.log('encountered:', { categoryType });\n    }\n    if (timing.categoryNames?.includes(categoryName)) {\n      timing.categoryNames = timing.categoryNames.filter(\n        (c) => c !== categoryName\n      );\n      currentAverageTime = {\n        minutes: timing.minutes,\n        categoryNames: [categoryName],\n      };\n      if (!timing.categoryNames.length) return;\n    }\n    return timing;\n  };\n\n  const validAverageMinutes =\n    averageMinutes && !isNaN(ensureInt(averageMinutes));\n  const validRecoveryMinutes =\n    recoveryMinutes && !isNaN(ensureInt(recoveryMinutes));\n\n  const newAverageTimes = averageTimes\n    .map(newTiming)\n    .filter((f) => f?.categoryNames?.length);\n  const newRecoveryTimes = recoveryTimes\n    .map(newTiming)\n    .filter((f) => f?.categoryNames?.length);\n\n  if (validAverageMinutes) {\n    Object.assign(currentAverageTime.minutes, {\n      [event?.eventType || SINGLES]: averageMinutes,\n    });\n    newAverageTimes.push(currentAverageTime);\n  }\n\n  if (validRecoveryMinutes) {\n    Object.assign(currentRecoveryTime.minutes, {\n      [event?.eventType || SINGLES]: recoveryMinutes,\n    });\n    newRecoveryTimes.push(currentRecoveryTime);\n  }\n\n  if (!validAverageMinutes && !validRecoveryMinutes)\n    return { error: INVALID_VALUES };\n\n  return modifyMatchUpFormatTiming({\n    averageTimes: validAverageMinutes && newAverageTimes,\n    recoveryTimes: validRecoveryMinutes && newRecoveryTimes,\n    tournamentRecord,\n    matchUpFormat,\n    eventId,\n    event,\n  });\n}\n","import { getPersonRequests } from '../../../../../query/matchUps/scheduling/getPersonRequests';\nimport { checkRequiredParameters } from '../../../../../parameters/checkRequiredParameters';\nimport { mergePersonRequests } from './mergePersonRequests';\nimport { savePersonRequests } from './savePersonRequests';\n\nimport { ARRAY, INVALID, OF_TYPE, TOURNAMENT_RECORDS } from '../../../../../constants/attributeConstants';\nimport { INVALID_VALUES } from '../../../../../constants/errorConditionConstants';\n\n// can be used to both add and remove requests\n// requests which don't have existing requestId will be added\n// requests which don't have requestType will be removed\nexport function modifyPersonRequests(params) {\n  const { tournamentRecords, requests, personId } = params;\n  const paramsCheck = checkRequiredParameters(params, [\n    { [TOURNAMENT_RECORDS]: true },\n    { requests: true, [OF_TYPE]: ARRAY, [INVALID]: INVALID_VALUES },\n  ]);\n  if (paramsCheck.error) return paramsCheck;\n\n  const requestIds = requests.map(({ requestId }) => requestId).filter(Boolean);\n\n  const { personRequests } = getPersonRequests({ tournamentRecords });\n  const modifyRequests = (personId) => {\n    if (personRequests) {\n      personRequests[personId] = personRequests[personId]\n        .map((request) => {\n          // if requestId not in requestIds then return unmodified\n          if (!requestIds.includes(request.requestId)) return request;\n\n          // find the updatedRequest\n          const modification = requests.find((updatedRequest) => updatedRequest.requestId === request.requestId);\n          // FEATURE: returning an updatedRequest without a requestType will remove it\n          if (!modification.requestType) return;\n\n          return Object.assign(request, modification);\n        })\n        .filter(Boolean);\n    }\n  };\n  if (personId && personRequests?.[personId]) {\n    modifyRequests(personId);\n  } else if (personRequests) {\n    for (const personId of Object.keys(personRequests)) {\n      modifyRequests(personId);\n    }\n  }\n\n  const newRequests = requests.filter((request) => !request.requestId);\n  if (newRequests.length) {\n    mergePersonRequests({ personRequests, personId, requests: newRequests });\n  }\n\n  return savePersonRequests({ tournamentRecords, personRequests });\n}\n","import { competitionScheduleMatchUps } from '../../../../../query/matchUps/competitionScheduleMatchUps';\nimport { getMatchUpDependencies } from '../../../../../query/matchUps/getMatchUpDependencies';\nimport { matchUpSort } from '../../../../../functions/sorters/matchUpSort';\nimport { validMatchUps } from '../../../../../validators/validMatchUp';\nimport { bulkScheduleMatchUps } from '../../bulkScheduleMatchUps';\nimport { isObject } from '../../../../../utilities/objects';\n\nimport { Tournament } from '../../../../../types/tournamentTypes';\nimport { HydratedMatchUp } from '../../../../../types/hydrated';\nimport {\n  INVALID_VALUES,\n  MISSING_CONTEXT,\n} from '../../../../../constants/errorConditionConstants';\nimport {\n  BYE,\n  completedMatchUpStatuses,\n} from '../../../../../constants/matchUpStatusConstants';\n\n// NOTE: matchUps are assumed to be { inContext: true, nextMatchUps: true }\n\ntype ProAutoScheduleArgs = {\n  tournamentRecords: { [key: string]: Tournament };\n  scheduleCompletedMatchUps?: boolean;\n  matchUps: HydratedMatchUp[];\n  scheduledDate: string;\n};\nexport function proAutoSchedule({\n  scheduleCompletedMatchUps,\n  tournamentRecords,\n  scheduledDate,\n  matchUps,\n}: ProAutoScheduleArgs) {\n  if (!validMatchUps(matchUps)) return { error: INVALID_VALUES };\n  if (matchUps.some(({ hasContext }) => !hasContext)) {\n    return {\n      info: 'matchUps must have { inContext: true, nextMatchUps: true }',\n      error: MISSING_CONTEXT,\n    };\n  }\n\n  const matchUpFilters = { localPerspective: true, scheduledDate };\n  let result = competitionScheduleMatchUps({\n    courtCompletedMatchUps: true,\n    withCourtGridRows: true,\n    minCourtGridRows: 10,\n    tournamentRecords,\n    matchUpFilters,\n  });\n  if (result.error) return result;\n  const { rows } = result;\n\n  const gridMatchUps: HydratedMatchUp[] = [];\n\n  const getMatchUpParticipantIds = (matchUp) =>\n    [\n      (matchUp.sides || []).map((side) => [\n        side.participantId,\n        side.participant?.individualParticipantIds,\n      ]),\n      (matchUp.potentialParticipants || [])\n        .flat()\n        .map((p) => [p.participantId, p.individualParticipantIds]),\n    ]\n      .flat(Infinity)\n      .filter(Boolean);\n\n  const gridRows = rows?.reduce((gridRows, row) => {\n    const matchUpIds: string[] = [],\n      participantIds: string[] = [];\n    Object.values(row).forEach((c: any) => {\n      if (isObject(c)) {\n        if (c.matchUpId) {\n          matchUpIds.push(c.matchUpId);\n          gridMatchUps.push(c);\n        }\n        if (c.sides) {\n          const matchUpParticipantIds = getMatchUpParticipantIds(c);\n          participantIds.push(...matchUpParticipantIds);\n        }\n      }\n    });\n    const availableCourts = Object.values(row).filter(\n      (c: any) => isObject(c) && !c.matchUpId\n    );\n    return gridRows.concat({\n      matchUpIds,\n      availableCourts,\n      rowId: row.rowId,\n      participantIds,\n    });\n  }, []);\n\n  matchUps\n    .filter(\n      ({ matchUpStatus }) =>\n        matchUpStatus &&\n        matchUpStatus !== BYE &&\n        (scheduleCompletedMatchUps ||\n          !completedMatchUpStatuses.includes(matchUpStatus))\n    )\n    .sort(matchUpSort);\n\n  const deps = getMatchUpDependencies({\n    matchUps: matchUps.concat(gridMatchUps),\n    includeParticipantDependencies: true,\n    tournamentRecords,\n  }).matchUpDependencies;\n\n  const scheduled: HydratedMatchUp[] = [];\n  const previousRowMatchUpIds: string[] = [];\n\n  while (matchUps.length && gridRows.length) {\n    const row = gridRows.shift();\n    const unscheduledMatchUps: HydratedMatchUp[] = [];\n    while (matchUps.length && row.availableCourts.length) {\n      const unscheduledMatchUpIds = matchUps\n        .concat(unscheduledMatchUps)\n        .map((m) => m.matchUpId);\n      const matchUp = matchUps.shift();\n      const matchUpId = matchUp?.matchUpId;\n      const linkedMatchUpIds =\n        matchUpId &&\n        deps[matchUpId].matchUpIds.concat(deps[matchUpId].dependentMatchUpIds);\n\n      const unscheduledContainSource =\n        matchUpId &&\n        unscheduledMatchUpIds.some((id) =>\n          deps[matchUpId].matchUpIds.includes(id)\n        );\n      const previousIncludesDependent =\n        matchUpId &&\n        previousRowMatchUpIds.some((id) =>\n          deps[matchUpId].dependentMatchUpIds.includes(id)\n        );\n      const rowIncludesLinked = row.matchUpIds.some((id) =>\n        linkedMatchUpIds.includes(id)\n      );\n\n      const participantIds = getMatchUpParticipantIds(matchUp);\n      const rowContainsParticipants = row.participantIds.some((id) =>\n        participantIds.includes(id)\n      );\n\n      if (\n        matchUp &&\n        !rowIncludesLinked &&\n        !unscheduledContainSource &&\n        !rowContainsParticipants &&\n        !previousIncludesDependent\n      ) {\n        const court = row.availableCourts.shift();\n        Object.assign(matchUp.schedule, court.schedule);\n        Object.assign(court, matchUp);\n\n        scheduled.push(matchUp);\n\n        row.participantIds.push(...participantIds);\n        row.matchUpIds.push(matchUpId);\n      } else if (matchUp) {\n        unscheduledMatchUps.push(matchUp);\n      }\n    }\n    matchUps.push(...unscheduledMatchUps);\n    previousRowMatchUpIds.push(...row.matchUpIds);\n  }\n\n  const matchUpDetails = scheduled.map(\n    ({ matchUpId, tournamentId, schedule, drawId }) => ({\n      tournamentId,\n      matchUpId,\n      drawId,\n      schedule: {\n        ...schedule,\n        scheduledDate,\n      },\n    })\n  );\n\n  result = bulkScheduleMatchUps({ tournamentRecords, matchUpDetails });\n\n  const notScheduled = matchUps;\n\n  return { ...result, scheduled, notScheduled };\n}\n","import { validMatchUps } from '../../../../../validators/validMatchUp';\nimport { getMatchUpDependencies } from '../../../../../query/matchUps/getMatchUpDependencies';\nimport { matchUpSort } from '../../../../../functions/sorters/matchUpSort';\nimport { ensureInt } from '../../../../../utilities/ensureInt';\nimport {\n  generateRange,\n  instanceCount,\n  unique,\n} from '../../../../../utilities/arrays';\n\nimport { Tournament } from '../../../../../types/tournamentTypes';\nimport { HydratedMatchUp } from '../../../../../types/hydrated';\nimport {\n  ErrorType,\n  MISSING_CONTEXT,\n  MISSING_MATCHUPS,\n} from '../../../../../constants/errorConditionConstants';\nimport {\n  SCHEDULE_ISSUE_IDS,\n  SCHEDULE_CONFLICT,\n  SCHEDULE_WARNING,\n  SCHEDULE_ERROR,\n  SCHEDULE_ISSUE,\n  SCHEDULE_STATE,\n  CONFLICT_MATCHUP_ORDER,\n  CONFLICT_PARTICIPANTS,\n} from '../../../../../constants/scheduleConstants';\n\n// NOTE: matchUps are assumed to be { inContext: true, nextMatchUps: true }\ntype ProConflictsArgs = {\n  tournamentRecords: { [key: string]: Tournament };\n  matchUps: HydratedMatchUp[];\n};\nexport function proConflicts({\n  tournamentRecords,\n  matchUps,\n}: ProConflictsArgs):\n  | { error: ErrorType; info?: any }\n  | { courtIssues: { [key: string]: any }; rowIssues: { [key: string]: any } } {\n  if (!validMatchUps(matchUps)) return { error: MISSING_MATCHUPS };\n  if (matchUps.some(({ matchUpId, hasContext }) => matchUpId && !hasContext)) {\n    return {\n      info: 'matchUps must have { inContext: true, nextMatchUps: true }',\n      error: MISSING_CONTEXT,\n    };\n  }\n\n  const maxCourtOrder = Math.max(\n    ...matchUps\n      .map(({ schedule }) => schedule?.courtOrder || 1)\n      .map((order) => ensureInt(order))\n  );\n  const filteredRows = generateRange(1, maxCourtOrder + 1).map((courtOrder) =>\n    matchUps.filter((m) => ensureInt(m.schedule?.courtOrder) === courtOrder)\n  );\n\n  const rowIndices: { [key: string]: number } = {};\n  const courtIssues: { [key: string]: any } = {};\n  const mappedMatchUps: any = {};\n\n  const sortedFiltered = filteredRows.flat().filter(Boolean).sort(matchUpSort);\n\n  sortedFiltered.forEach(({ schedule }) => delete schedule[SCHEDULE_STATE]);\n\n  const drawIds = unique(matchUps.map(({ drawId }) => drawId));\n  const deps = getMatchUpDependencies({\n    includeParticipantDependencies: true,\n    tournamentRecords,\n    drawIds,\n  }).matchUpDependencies;\n\n  type Profile = {\n    sourceMatchUpIds: string[];\n    targetMatchUpIds: string[];\n    participantIds: string[];\n    matchUpIds: string[];\n  };\n\n  const rowProfiles = filteredRows.map((row, rowIndex) =>\n    row.reduce(\n      (profile: Profile, matchUp) => {\n        if (!matchUp.matchUpId) return profile;\n\n        const {\n          matchUpId,\n          winnerMatchUpId,\n          loserMatchUpId,\n          schedule,\n          sides,\n          potentialParticipants,\n        } = matchUp;\n        const courtId = schedule?.courtId;\n        rowIndices[matchUpId] = rowIndex;\n        courtIssues[courtId] = [];\n\n        profile.matchUpIds.push(matchUpId);\n        mappedMatchUps[matchUpId] = matchUp;\n\n        const sourceMatchUpIds = deps[matchUpId].matchUpIds;\n        sourceMatchUpIds.length &&\n          profile.sourceMatchUpIds.push(...sourceMatchUpIds);\n\n        const matchUpParticipantIds =\n          sides\n            ?.map((side: any) => [\n              side.participant?.individualParticipantIds,\n              side.participantId,\n            ])\n            .flat()\n            .filter(Boolean) ?? [];\n        const potentialMatchUpParticipantIds =\n          potentialParticipants\n            ?.flat()\n            .map(({ individualParticipantIds, participantId }) => [\n              individualParticipantIds,\n              participantId,\n            ])\n            .flat()\n            .filter(Boolean) || [];\n\n        profile.participantIds.push(\n          ...potentialMatchUpParticipantIds,\n          ...matchUpParticipantIds\n        );\n\n        winnerMatchUpId && profile.targetMatchUpIds.push(winnerMatchUpId);\n        loserMatchUpId && profile.targetMatchUpIds.push(loserMatchUpId);\n\n        return profile;\n      },\n      {\n        sourceMatchUpIds: [],\n        targetMatchUpIds: [],\n        participantIds: [],\n        matchUpIds: [],\n      }\n    )\n  );\n\n  const sourceDistance = (a, b) =>\n    deps[a].sources.reduce(\n      (distance, round, index) => (round.includes(b) && index + 1) || distance,\n      0\n    );\n\n  const rowIssues: any[] = rowProfiles.map(() => []);\n  const annotate = (matchUpId, issue, issueType, issueIds) => {\n    if (!mappedMatchUps[matchUpId].schedule[SCHEDULE_STATE]) {\n      // store issue for display below by order of severity\n      mappedMatchUps[matchUpId].schedule[SCHEDULE_STATE] = issue;\n      mappedMatchUps[matchUpId].schedule[SCHEDULE_ISSUE_IDS] = issueIds;\n\n      // update row issues\n      rowIssues[rowIndices[matchUpId]].push({\n        matchUpId,\n        issueType,\n        issueIds,\n        issue,\n      });\n\n      // update court issues\n      const courtId = mappedMatchUps[matchUpId].schedule.courtId;\n      if (!courtIssues[courtId]) courtIssues[courtId] = [];\n      courtIssues[courtId].push({ matchUpId, issue, issueType, issueIds });\n    }\n  };\n\n  rowProfiles.forEach((row, rowIndex) => {\n    const previousRow = rowIndex ? rowProfiles[rowIndex - 1] : undefined;\n    const subsequentRows = rowProfiles.slice(rowIndex + 1);\n\n    const participantConflicts: { [key: string]: any } = {};\n\n    const instances = instanceCount(row.participantIds);\n    const conflictedParticipantIds = Object.keys(instances).filter(\n      (key) => instances[key] > 1\n    );\n    const conflictedMatchUpIds = row.matchUpIds.filter((matchUpId) =>\n      deps[matchUpId].participantIds.some((id) =>\n        conflictedParticipantIds.includes(id)\n      )\n    );\n    conflictedMatchUpIds.forEach((matchUpId) => {\n      if (!participantConflicts[matchUpId])\n        participantConflicts[matchUpId] = {};\n      if (!participantConflicts[matchUpId][SCHEDULE_CONFLICT]) {\n        participantConflicts[matchUpId][SCHEDULE_CONFLICT] =\n          conflictedMatchUpIds.filter((id) => id !== matchUpId);\n      }\n    });\n\n    const previousRowWarnings =\n      previousRow &&\n      row.participantIds.filter((id) =>\n        previousRow.participantIds.includes(id)\n      );\n    if (previousRowWarnings) {\n      previousRowWarnings.forEach((participantId) => {\n        const warnedMatchUpIds = row.matchUpIds\n          .concat(previousRow.matchUpIds)\n          .filter((matchUpId) =>\n            deps[matchUpId].participantIds.includes(participantId)\n          );\n        warnedMatchUpIds.forEach((matchUpId) => {\n          if (!participantConflicts[matchUpId])\n            participantConflicts[matchUpId] = {};\n          if (!participantConflicts[matchUpId][SCHEDULE_WARNING]) {\n            participantConflicts[matchUpId][SCHEDULE_WARNING] =\n              warnedMatchUpIds.filter((id) => id !== matchUpId);\n          }\n        });\n      });\n    }\n\n    row.matchUpIds.forEach((matchUpId) => {\n      const sourceMatchUpIds = deps[matchUpId].matchUpIds;\n\n      // IMPORTANT: maintain order of annotations\n      // SCHEDULE_STATE values progress from ERROR => CONFLICT => WARNING\n\n      // ERRORS Section\n      for (const subsequentRow of subsequentRows) {\n        const sourceAfter = subsequentRow.matchUpIds.filter((id) =>\n          sourceMatchUpIds.includes(id)\n        );\n        if (sourceAfter?.length) {\n          sourceAfter.forEach((id) =>\n            annotate(id, SCHEDULE_ERROR, CONFLICT_MATCHUP_ORDER, [matchUpId])\n          );\n          annotate(\n            matchUpId,\n            SCHEDULE_ERROR,\n            CONFLICT_MATCHUP_ORDER,\n            sourceAfter\n          );\n        }\n      }\n\n      // CONFLICTS Section\n      if (participantConflicts[matchUpId]?.[SCHEDULE_CONFLICT]) {\n        annotate(\n          matchUpId,\n          SCHEDULE_CONFLICT,\n          CONFLICT_PARTICIPANTS,\n          participantConflicts[matchUpId][SCHEDULE_CONFLICT]\n        );\n      }\n\n      // if the matchUpId is part of the sources for other row matchUps => conflict\n      if (row.sourceMatchUpIds.includes(matchUpId)) {\n        const sources = row.matchUpIds.filter((id) =>\n          deps[id].matchUpIds.includes(matchUpId)\n        );\n        annotate(matchUpId, SCHEDULE_CONFLICT, CONFLICT_MATCHUP_ORDER, sources);\n        row.matchUpIds\n          .filter((id) => deps[id].matchUpIds.includes(matchUpId))\n          .forEach((id) =>\n            annotate(id, SCHEDULE_CONFLICT, CONFLICT_MATCHUP_ORDER, [matchUpId])\n          );\n      }\n\n      // ISSUES Section\n      const insufficientGap = previousRow?.matchUpIds?.filter(\n        (id) => sourceDistance(matchUpId, id) > 1\n      );\n      if (insufficientGap?.length) {\n        annotate(\n          matchUpId,\n          SCHEDULE_ISSUE,\n          CONFLICT_MATCHUP_ORDER,\n          insufficientGap\n        );\n        insufficientGap.forEach((id) =>\n          annotate(id, SCHEDULE_ISSUE, CONFLICT_MATCHUP_ORDER, [matchUpId])\n        );\n      }\n\n      // WARNINGS Section\n      if (participantConflicts[matchUpId]?.[SCHEDULE_WARNING]) {\n        annotate(\n          matchUpId,\n          SCHEDULE_WARNING,\n          CONFLICT_PARTICIPANTS,\n          participantConflicts[matchUpId][SCHEDULE_WARNING]\n        );\n      }\n      if (previousRow?.targetMatchUpIds?.includes(matchUpId)) {\n        // IF: connected matchUps are on the same court with sufficient time between them\n        // OR: connected matchUps are on the same court and the target matchUp has 'FOLLOWED_BY'\n        // THEN: no WARNING will be given\n        const consideredCourtId = mappedMatchUps[matchUpId].schedule.courtId;\n        const warningMatchUpIds = sourceMatchUpIds.filter((id) =>\n          previousRow.matchUpIds.includes(id)\n        );\n        const allSameCourt = warningMatchUpIds.some(\n          (id) => mappedMatchUps[id].schedule.courtId === consideredCourtId\n        );\n        if (!allSameCourt) {\n          warningMatchUpIds.forEach((id) =>\n            annotate(id, SCHEDULE_WARNING, CONFLICT_MATCHUP_ORDER, [matchUpId])\n          );\n          annotate(\n            matchUpId,\n            SCHEDULE_WARNING,\n            CONFLICT_MATCHUP_ORDER,\n            warningMatchUpIds\n          );\n        }\n      }\n    });\n  });\n\n  return { courtIssues, rowIssues };\n}\n","import { latestVisibleTimeItemValue } from '../../../query/matchUp/latestVisibleTimeItemValue';\nimport { checkRequiredParameters } from '../../../parameters/checkRequiredParameters';\nimport { findDrawDefinition } from '../../../acquire/findDrawDefinition';\nimport { addMatchUpTimeItem } from '../timeItems/matchUpTimeItems';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { assignMatchUpCourt } from './assignMatchUpCourt';\n\nimport { MISSING_DRAW_DEFINITION, MISSING_TOURNAMENT_RECORD } from '../../../constants/errorConditionConstants';\nimport { TOURNAMENT_RECORDS } from '../../../constants/attributeConstants';\nimport { ALLOCATE_COURTS } from '../../../constants/timeItemConstants';\nimport { TEAM_MATCHUP } from '../../../constants/matchUpTypes';\n\nexport function removeMatchUpCourtAssignment(params) {\n  const paramsCheck = checkRequiredParameters(params, [{ [TOURNAMENT_RECORDS]: true }]);\n  if (paramsCheck.error) return paramsCheck;\n  const { removePriorValues, tournamentRecords, tournamentId, courtDayDate, matchUpId, courtId, drawId } = params;\n\n  const tournamentRecord = tournamentRecords[tournamentId];\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const { drawDefinition, event } = findDrawDefinition({\n    tournamentRecord,\n    drawId,\n  });\n  if (!drawDefinition) return { error: MISSING_DRAW_DEFINITION };\n\n  const result = findDrawMatchUp({ drawDefinition, event, matchUpId });\n  if (result.error) return result;\n\n  if (result?.matchUp?.matchUpType === TEAM_MATCHUP) {\n    const { itemValue: allocatedCourts } = latestVisibleTimeItemValue({\n      timeItems: result.matchUp.timeItems ?? [],\n      itemType: ALLOCATE_COURTS,\n    });\n\n    const itemValue = courtId && allocatedCourts.filter((court) => court.courtId !== courtId);\n\n    const timeItem = { itemType: ALLOCATE_COURTS, itemValue };\n    return addMatchUpTimeItem({\n      duplicateValues: false,\n      removePriorValues,\n      tournamentRecord,\n      drawDefinition,\n      matchUpId,\n      timeItem,\n    });\n  } else {\n    return assignMatchUpCourt({\n      tournamentRecord,\n      drawDefinition,\n      courtDayDate,\n      courtId: '',\n      matchUpId,\n    });\n  }\n}\n","import { checkRequiredParameters } from '../../../../../parameters/checkRequiredParameters';\nimport { removeExtension } from '../../../../extensions/removeExtension';\nimport { getPersonRequests } from '../../../../../query/matchUps/scheduling/getPersonRequests';\nimport { savePersonRequests } from './savePersonRequests';\n\nimport { TOURNAMENT_RECORDS } from '../../../../../constants/attributeConstants';\nimport { PERSON_REQUESTS } from '../../../../../constants/extensionConstants';\nimport { TournamentRecords } from '../../../../../types/factoryTypes';\n\n// personRequests can be removed by date, requestId, or requestType\ntype RemovePersonRequests = {\n  tournamentRecords: TournamentRecords;\n  requestType?: string;\n  requestId?: string;\n  personId?: string;\n  date?: string;\n};\nexport function removePersonRequests(params: RemovePersonRequests) {\n  const { tournamentRecords, requestType, requestId, personId, date } = params;\n  const paramsCheck = checkRequiredParameters(params, [\n    { [TOURNAMENT_RECORDS]: true },\n  ]);\n  if (paramsCheck.error) return paramsCheck;\n\n  const { personRequests } = getPersonRequests({ tournamentRecords });\n  const filterRequests = (personId) => {\n    if (personRequests) {\n      personRequests[personId] = personRequests[personId].filter((request) => {\n        return (\n          (!requestType || request.requestType !== requestType) &&\n          (!requestId || request.requestId !== requestId) &&\n          (!date || request.date !== date)\n        );\n      });\n\n      if (!personRequests?.[personId]?.length) delete personRequests[personId];\n    }\n  };\n\n  const removeAll = !requestType && !requestId && !personId && !date;\n\n  if (!removeAll) {\n    if (personId && personRequests?.[personId]) {\n      filterRequests(personId);\n    } else if (personRequests) {\n      for (const personId of Object.keys(personRequests)) {\n        filterRequests(personId);\n      }\n    }\n  }\n\n  if (removeAll || !personRequests || !Object.keys(personRequests).length) {\n    return removeExtension({\n      name: PERSON_REQUESTS,\n      tournamentRecords,\n      discover: true,\n    });\n  } else {\n    return savePersonRequests({ tournamentRecords, personRequests });\n  }\n}\n","import { addMatchUpScheduledTime } from './scheduledTime';\nimport { findDrawDefinition } from '../../../acquire/findDrawDefinition';\nimport { decorateResult } from '../../../global/functions/decorateResult';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  DRAW_DEFINITION_NOT_FOUND,\n  MISSING_TOURNAMENT_RECORDS,\n  MISSING_VALUE,\n  MODIFICATIONS_FAILED,\n} from '../../../constants/errorConditionConstants';\n\n/**\n * Reorders an array of time-ordered matchUps by re-assigning their times\n * Assumes:\n * 1. that only the matchUps which need to be reordered are present in the matchUpContextIds array\n * 2. that either a match has moved from the bottom of the group to the top or vice-versa\n */\nexport function reorderUpcomingMatchUps(params) {\n  const stack = 'reorderUpcomingMatchUps';\n  const { tournamentRecords } = params;\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return decorateResult({\n      result: { error: MISSING_TOURNAMENT_RECORDS },\n      stack,\n    });\n\n  const { matchUpsContextIds, firstToLast } = params;\n  if (!matchUpsContextIds)\n    return decorateResult({ result: { error: MISSING_VALUE }, stack });\n\n  const matchUpsCount = matchUpsContextIds?.length;\n  if (!matchUpsCount) return { ...SUCCESS };\n\n  let matchUpsModified = 0;\n  matchUpsContextIds.forEach((context, index) => {\n    const { tournamentId, drawId, matchUpId } = context;\n    let calculatedIndex = index + (firstToLast ? -1 : 1);\n    if (calculatedIndex < 0) calculatedIndex = matchUpsCount - 1;\n    if (calculatedIndex === matchUpsCount) calculatedIndex = 0;\n    const scheduledTime =\n      matchUpsContextIds[calculatedIndex].schedule.scheduledTime;\n    const result = assignMatchUpScheduledTime({\n      tournamentId,\n      scheduledTime,\n      matchUpId,\n      drawId,\n    });\n    if (result.success) {\n      matchUpsModified++;\n    } else {\n      return result;\n    }\n  });\n\n  return matchUpsModified === matchUpsCount\n    ? SUCCESS\n    : decorateResult({ result: { error: MODIFICATIONS_FAILED }, stack });\n\n  function assignMatchUpScheduledTime({\n    tournamentId,\n    scheduledTime,\n    matchUpId,\n    drawId,\n  }) {\n    const tournamentRecord = tournamentRecords[tournamentId];\n    const { drawDefinition } = findDrawDefinition({\n      tournamentRecord,\n      drawId,\n    });\n    if (!drawDefinition) return { error: DRAW_DEFINITION_NOT_FOUND };\n\n    return addMatchUpScheduledTime({\n      drawDefinition,\n      scheduledTime,\n      matchUpId,\n    });\n  }\n}\n","import { checkParticipantProfileInitialization } from './checkParticipantProfileInitialization';\nimport { allCompetitionMatchUps } from '../../../../query/matchUps/getAllCompetitionMatchUps';\nimport { getMatchUpDependencies } from '../../../../query/matchUps/getMatchUpDependencies';\nimport { checkRequiredParameters } from '../../../../parameters/checkRequiredParameters';\nimport { modifyParticipantMatchUpsCount } from './modifyParticipantMatchUpsCount';\nimport { checkDependenciesScheduled } from './checkDependenciesScheduled';\nimport { findDrawDefinition } from '../../../../acquire/findDrawDefinition';\nimport { getMatchUpIds } from '../../../../global/functions/extractors';\nimport { updateTimeAfterRecovery } from './updateTimeAfterRecovery';\nimport { calculateScheduleTimes } from './calculateScheduleTimes';\nimport { checkRequestConflicts } from './checkRequestConflicts';\nimport { processNextMatchUps } from './processNextMatchUps';\nimport { addMatchUpScheduledTime } from '../scheduledTime';\nimport { assignMatchUpVenue } from '../assignMatchUpVenue';\nimport { checkRecoveryTime } from './checkRecoveryTime';\nimport { checkDailyLimits } from './checkDailyLimits';\nimport { getPersonRequests } from '../../../../query/matchUps/scheduling/getPersonRequests';\nimport { extractDate, extractTime, isValidDateString, sameDay, zeroPad } from '../../../../utilities/dateTime';\n\nimport { DO_NOT_SCHEDULE } from '../../../../constants/requestConstants';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport { TOTAL } from '../../../../constants/scheduleConstants';\nimport { INVALID_DATE, INVALID_VALUES } from '../../../../constants/errorConditionConstants';\nimport { BYE, ABANDONED, DEFAULTED, RETIRED, WALKOVER, COMPLETED } from '../../../../constants/matchUpStatusConstants';\nimport {\n  AVERAGE_MATCHUP_MINUTES,\n  INVALID,\n  MATCHUP_IDS,\n  PERIOD_LENGTH,\n  RECOVERY_MINUTES,\n  SCHEDULE_DATE,\n  TOURNAMENT_RECORDS,\n  VALIDATE,\n} from '../../../../constants/attributeConstants';\n\n/**\n *\n * @param {object[]} tournamentRecords - provided by competitionEngine\n * @param {string[]} matchUpIds - matchUpIds to schedule\n * @param {string[]} venueIds - venueIds of venues where dateAvailability for courts is found\n * @param {string} scheduleDate - YYYY-MM-DD string representing day on which matchUps should be scheduled\n * @param {string} startTime - 00:00 - military time string\n * @param {string} endTime - 00:00 - military time string\n *\n * @param {number} periodLength - granularity of time blocks to consider, in minutes\n * @param {number} averageMatchUpMinutes - how long the expected matchUps are expected to last, in minutes, on average\n * @param {number} recoveryMinutes - time in minutes that should be alloted for participants to recover between matches\n * @param {object} matchUpDailyLimits - { SINGLES, DOUBLES, TOTAL } - maximum number of matches allowed per participant\n * @param {boolean} checkPotentialRequestConflicts - check personRequests when person is only potentially in matchUp being scheduled\n *\n * @returns scheduledMatchUpIds, individualParticipantProfiles\n */\nexport function scheduleMatchUps(params) {\n  const {\n    tournamentRecords,\n    allDateMatchUpIds = [],\n\n    averageMatchUpMinutes = 90,\n    recoveryMinutes = 0,\n    recoveryMinutesMap, // for matchUpIds batched by averageMatchUpMinutes this enables varying recoveryMinutes\n\n    matchUpPotentialParticipantIds = {},\n    individualParticipantProfiles = {},\n    matchUpNotBeforeTimes = {},\n    matchUpDailyLimits = {},\n\n    checkPotentialRequestConflicts = true,\n    remainingScheduleTimes,\n    clearScheduleDates,\n\n    periodLength = 30,\n    scheduleDate,\n    matchUpIds,\n    venueIds,\n\n    startTime,\n    endTime,\n    dryRun,\n  } = params;\n  const paramCheck = checkRequiredParameters(params, [\n    { [TOURNAMENT_RECORDS]: true, [MATCHUP_IDS]: true },\n    {\n      [VALIDATE]: isValidDateString,\n      [INVALID]: INVALID_DATE,\n      [SCHEDULE_DATE]: true,\n    },\n    {\n      [VALIDATE]: (value) => !value || !isNaN(value),\n      [AVERAGE_MATCHUP_MINUTES]: false,\n      [INVALID]: INVALID_VALUES,\n      [RECOVERY_MINUTES]: false,\n      [PERIOD_LENGTH]: false,\n    },\n  ]);\n  if (paramCheck.error) return paramCheck;\n\n  // if competitionMatchUps not provided as a parameter\n  // scheduleMatchUpProfiles has already called processNextMatchUps for all\n  const competitionMatchUps =\n    params.competitionMatchUps ??\n    allCompetitionMatchUps({\n      nextMatchUps: true,\n      tournamentRecords,\n    }).matchUps ??\n    [];\n\n  const matchUpDependencies =\n    params.matchUpDependencies ??\n    getMatchUpDependencies({\n      includeParticipantDependencies: true,\n      matchUps: competitionMatchUps,\n      tournamentRecords,\n    }).matchUpDependencies;\n\n  competitionMatchUps.forEach((matchUp) => {\n    if (matchUp.schedule?.scheduledDate && sameDay(scheduleDate, extractDate(matchUp.schedule.scheduledDate))) {\n      processNextMatchUps({\n        matchUpPotentialParticipantIds,\n        matchUpNotBeforeTimes,\n        matchUp,\n      });\n    }\n  });\n\n  // this must be done to preserve the order of matchUpIds\n  const targetMatchUps = matchUpIds\n    .map((matchUpId) => competitionMatchUps.find((matchUp) => matchUp.matchUpId === matchUpId))\n    .filter(Boolean);\n\n  // determines court availability taking into account already scheduled matchUps on the scheduleDate\n  // optimization to pass already retrieved competitionMatchUps to avoid refetch (requires refactor)\n  const { venueId, scheduleTimes, dateScheduledMatchUpIds } = calculateScheduleTimes({\n    tournamentRecords,\n    remainingScheduleTimes,\n    startTime: extractTime(startTime),\n    endTime: extractTime(endTime),\n    scheduleDate: extractDate(scheduleDate),\n    averageMatchUpMinutes,\n    clearScheduleDates,\n    periodLength,\n    venueIds,\n  });\n  const requestConflicts = {};\n  const skippedScheduleTimes: string[] = [];\n  const matchUpScheduleTimes = {};\n  const recoveryTimeDeferred = {};\n  const dependencyDeferred = {};\n\n  // first build up a map of matchUpNotBeforeTimes and matchUpPotentialParticipantIds\n  // based on already scheduled matchUps\n  const dateScheduledMatchUps = competitionMatchUps.filter(\n    ({ matchUpId }) => dateScheduledMatchUpIds?.includes(matchUpId),\n  );\n  dateScheduledMatchUps.forEach((matchUp) => {\n    modifyParticipantMatchUpsCount({\n      matchUpPotentialParticipantIds,\n      individualParticipantProfiles,\n      matchUp,\n      value: 1,\n    });\n    const scheduleTime = matchUp.schedule?.scheduledTime;\n    if (scheduleTime) {\n      matchUpScheduleTimes[matchUp.matchUpId] = scheduleTime;\n      const mappedRecoveryMinutes = recoveryMinutesMap?.[matchUp.matchUpId];\n      updateTimeAfterRecovery({\n        recoveryMinutes: mappedRecoveryMinutes || recoveryMinutes,\n        matchUpPotentialParticipantIds,\n        individualParticipantProfiles,\n        matchUpNotBeforeTimes,\n        averageMatchUpMinutes,\n        matchUpDependencies,\n        scheduleTime,\n        matchUp,\n      });\n    }\n  });\n\n  // matchUps are assumed to be in the desired order for scheduling\n  let matchUpsToSchedule = targetMatchUps.filter((matchUp) => {\n    const alreadyScheduled = dateScheduledMatchUpIds?.includes(matchUp.matchUpId);\n\n    const doNotSchedule = [BYE, DEFAULTED, COMPLETED, ABANDONED, RETIRED, WALKOVER].includes(matchUp?.matchUpStatus);\n    return !alreadyScheduled && !matchUp.winningSide && !doNotSchedule;\n  });\n\n  // for optimization, build up an object for each tournament and an array for each draw with target matchUps\n  // keep track of matchUps counts per participant and don't add matchUps for participants beyond those limits\n  const { matchUpMap, overLimitMatchUpIds, participantIdsAtLimit } = matchUpsToSchedule.reduce(\n    (aggregator, matchUp) => {\n      const { drawId, tournamentId, matchUpType } = matchUp;\n\n      const { participantIdsAtLimit, relevantParticipantIds } = checkDailyLimits({\n        individualParticipantProfiles,\n        matchUpPotentialParticipantIds,\n        matchUpDailyLimits,\n        matchUp,\n      });\n\n      if (participantIdsAtLimit?.length) {\n        aggregator.overLimitMatchUpIds.push(matchUp.matchUpId);\n        aggregator.participantIdsAtLimit.push(...participantIdsAtLimit);\n        return aggregator;\n      }\n\n      relevantParticipantIds.forEach((participantId) => {\n        checkParticipantProfileInitialization({\n          individualParticipantProfiles,\n          participantId,\n        });\n        const counters = individualParticipantProfiles[participantId].counters;\n        if (counters[matchUpType]) counters[matchUpType] += 1;\n        else counters[matchUpType] = 1;\n        if (counters[TOTAL]) counters[TOTAL] += 1;\n        else counters[TOTAL] = 1;\n      });\n\n      if (!aggregator.matchUpMap[tournamentId]) aggregator.matchUpMap[tournamentId] = {};\n      if (!aggregator.matchUpMap[tournamentId][drawId]) {\n        aggregator.matchUpMap[tournamentId][drawId] = [matchUp];\n      } else {\n        aggregator.matchUpMap[tournamentId][drawId].push(matchUp);\n      }\n\n      // since this matchUp is to be scheduled, update the matchUpPotentialParticipantIds\n      processNextMatchUps({\n        matchUpPotentialParticipantIds,\n        matchUpNotBeforeTimes,\n        matchUp,\n      });\n\n      return aggregator;\n    },\n    { matchUpMap: {}, overLimitMatchUpIds: [], participantIdsAtLimit: [] },\n  );\n\n  matchUpsToSchedule = matchUpsToSchedule.filter(({ matchUpId }) => !overLimitMatchUpIds.includes(matchUpId));\n\n  let iterations = 0;\n  const failSafe = scheduleTimes?.length ?? 0;\n\n  const { personRequests } = getPersonRequests({\n    tournamentRecords,\n    requestType: DO_NOT_SCHEDULE,\n  });\n\n  // while there are still matchUps to schedule and scheduleTimes, assign scheduleTimes to matchUps;\n  while (scheduleTimes?.length && matchUpsToSchedule.length && iterations <= failSafe) {\n    iterations++;\n    const { scheduleTime } = scheduleTimes.shift();\n\n    // find a matchUp where all individual participants had enough recovery time\n    const scheduledMatchUp = matchUpsToSchedule.find((matchUp) => {\n      const { matchUpId } = matchUp;\n      const { dependenciesScheduled, remainingDependencies } = checkDependenciesScheduled({\n        matchUpScheduleTimes,\n        matchUpDependencies,\n        allDateMatchUpIds,\n        matchUp,\n      });\n      if (!dependenciesScheduled) {\n        if (!dependencyDeferred[matchUpId]) dependencyDeferred[matchUpId] = [];\n        dependencyDeferred[matchUpId].push({\n          scheduleTime,\n          remainingDependencies,\n        });\n        return false;\n      }\n\n      const { enoughTime } = checkRecoveryTime({\n        individualParticipantProfiles,\n        matchUpNotBeforeTimes,\n        matchUpDependencies,\n        scheduleTime,\n        matchUp,\n      });\n      if (!enoughTime) {\n        if (!recoveryTimeDeferred[matchUpId]) recoveryTimeDeferred[matchUpId] = [];\n        recoveryTimeDeferred[matchUpId].push({\n          scheduleTime,\n        });\n        return false;\n      }\n\n      const { conflicts } = checkRequestConflicts({\n        potentials: checkPotentialRequestConflicts,\n        averageMatchUpMinutes,\n        requestConflicts,\n        personRequests,\n        scheduleTime,\n        scheduleDate,\n        matchUp,\n      });\n\n      if (conflicts?.length) return false;\n\n      const mappedRecoveryMinutes = recoveryMinutesMap?.[matchUp.matchUpId];\n\n      updateTimeAfterRecovery({\n        recoveryMinutes: mappedRecoveryMinutes || recoveryMinutes,\n        matchUpPotentialParticipantIds,\n        individualParticipantProfiles,\n        matchUpNotBeforeTimes,\n        averageMatchUpMinutes,\n        matchUpDependencies,\n        scheduleTime,\n        matchUp,\n      });\n\n      matchUpScheduleTimes[matchUp.matchUpId] = scheduleTime;\n      return true;\n    });\n\n    matchUpsToSchedule = matchUpsToSchedule.filter(({ matchUpId }) => matchUpId !== scheduledMatchUp?.matchUpId);\n\n    if (!scheduledMatchUp) {\n      skippedScheduleTimes.push(scheduleTime);\n    }\n  }\n\n  // cleanup limits counters for matchUps which could not be scheduled due to recovery times\n  matchUpsToSchedule.forEach((matchUp) => {\n    modifyParticipantMatchUpsCount({\n      individualParticipantProfiles,\n      matchUpPotentialParticipantIds,\n      value: -1,\n      matchUp,\n    });\n  });\n\n  const scheduledMatchUpIds: string[] = [];\n  Object.keys(matchUpMap).forEach((tournamentId) => {\n    const tournamentRecord = tournamentRecords[tournamentId];\n    if (tournamentRecord) {\n      Object.keys(matchUpMap[tournamentId]).forEach((drawId) => {\n        const { drawDefinition } = findDrawDefinition({\n          tournamentRecord,\n          drawId,\n        });\n        if (drawDefinition) {\n          const drawMatchUps = matchUpMap[tournamentId][drawId];\n          drawMatchUps.forEach(({ matchUpId }) => {\n            const scheduleTime = matchUpScheduleTimes[matchUpId];\n            if (scheduleTime) {\n              // must include scheduleDate being scheduled to generate proper ISO string\n              const formatTime = scheduleTime.split(':').map(zeroPad).join(':');\n              const scheduledTime = `${extractDate(scheduleDate)}T${formatTime}`;\n\n              if (dryRun) {\n                scheduledMatchUpIds.push(matchUpId);\n              } else {\n                const result = addMatchUpScheduledTime({\n                  drawDefinition,\n                  matchUpId,\n                  scheduledTime,\n                });\n                if (result.success) scheduledMatchUpIds.push(matchUpId);\n\n                if (venueId) {\n                  assignMatchUpVenue({\n                    tournamentRecords,\n                    tournamentRecord,\n                    drawDefinition,\n                    matchUpId,\n                    venueId,\n                  });\n                }\n              }\n            }\n          });\n        }\n      });\n    }\n  });\n\n  const noTimeMatchUpIds = getMatchUpIds(matchUpsToSchedule);\n\n  return {\n    ...SUCCESS,\n    requestConflicts: Object.values(requestConflicts),\n    remainingScheduleTimes: scheduleTimes?.map(({ scheduleTime }) => scheduleTime),\n    individualParticipantProfiles,\n    matchUpNotBeforeTimes,\n    participantIdsAtLimit, // at the moment this is only those participants at limit BEFORE scheduling begins\n    skippedScheduleTimes,\n    overLimitMatchUpIds,\n    scheduledMatchUpIds,\n    noTimeMatchUpIds,\n\n    recoveryTimeDeferred,\n    dependencyDeferred,\n  };\n}\n","import { addExtension } from '../extensions/addExtension';\n\nimport { SCHEDULE_LIMITS } from '../../constants/extensionConstants';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { Tournament } from '../../types/tournamentTypes';\nimport {\n  INVALID_OBJECT,\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORDS,\n} from '../../constants/errorConditionConstants';\n\ntype SetMatchUpDailyLimitsArgs = {\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  tournamentId: string;\n  dailyLimits: any;\n};\nexport function setMatchUpDailyLimits(\n  params: SetMatchUpDailyLimitsArgs\n): ResultType {\n  const { tournamentRecord, tournamentId, dailyLimits } = params;\n\n  const tournamentRecords =\n    params.tournamentRecords ||\n    (tournamentRecord && {\n      [tournamentRecord.tournamentId]: tournamentRecord,\n    }) ||\n    {};\n\n  if (\n    typeof tournamentRecords !== 'object' ||\n    !Object.keys(tournamentRecords).length\n  )\n    return { error: MISSING_TOURNAMENT_RECORDS };\n  if (typeof dailyLimits !== 'object') return { error: INVALID_OBJECT };\n\n  const tournamentIds = Object.keys(tournamentRecords).filter(\n    (currentTournamentId) =>\n      !tournamentId || tournamentId === currentTournamentId\n  );\n\n  if (tournamentId && !tournamentIds.includes(tournamentId))\n    return { error: INVALID_VALUES };\n\n  for (const currentTournamentId of tournamentIds) {\n    const tournamentRecord = tournamentRecords[currentTournamentId];\n    const result = addExtension({\n      element: tournamentRecord,\n      extension: { name: SCHEDULE_LIMITS, value: { dailyLimits } },\n    });\n    if (result.error) return result;\n  }\n\n  return { ...SUCCESS };\n}\n","export const standardSet = '\\\\d+-\\\\d+';\nexport const tiebreakSet = '\\\\d+-\\\\d+\\\\(\\\\d+\\\\)';\nexport const matchTiebreak = '\\\\[\\\\d+-\\\\d+\\\\]';\nexport const incompleteSet = '\\\\d+-\\\\d+\\\\(\\\\d+-\\\\d+\\\\)';\n\nexport const standardSetComma = new RegExp(`(${standardSet}),`, 'g');\nexport const tiebreakSetComma = new RegExp(`(${tiebreakSet}),`, 'g');\n\nconst setTypes = [standardSet, tiebreakSet, matchTiebreak, incompleteSet];\n// prettier-ignore\nconst patternGenerator = [\n  '0', '1', '2', '00', '01', '10', '11',\n  '002', '012', '102', '112', \n  '000', '001', '010', '100', '011', '101',\n  '110', '111', '002', '012', '102', '112',\n  '0002', '0012', '0102', '1002',\n  '0112', '1012', '1102', '1112',\n  // retired matchUpStatus\n  '3', '03', '13', '013', '103'\n];\nconst regularExpressions = patternGenerator.map((pattern) => {\n  const arrayIndices = pattern.split('');\n  const expression = arrayIndices.map((index) => setTypes[index]).join(' ');\n  return new RegExp(`^${expression}$`);\n});\n\nexport function isValidPattern(score) {\n  return !score || regularExpressions.some((re) => re.test(score));\n}\n","export function isTiebreakScore(part) {\n  return /^\\(\\d+\\)$/.test(part) || /^\\(\\d+$/.test(part);\n}\n\nexport function isBracketScore(part) {\n  return /^\\(\\d+-\\d+\\)$/.test(part) || /^\\[\\d+-\\d+\\]$/.test(part);\n}\n\nexport function isDiffOne(score) {\n  const strip = (value) => value?.split('-').join('').split('/').join('');\n  const stripped = strip(score);\n  if (/^\\d+$/.test(stripped) && stripped.length === 2) {\n    const scores = stripped.split('');\n    const diff = Math.abs(scores.reduce((a, b) => +a - +b));\n    return diff === 1;\n  }\n  return false;\n}\n\nexport function getSuper(values, index) {\n  const parts = [\n    values.slice(index, index + 2),\n    index ? values.slice(0, 1) : values.slice(2),\n  ].map((n) => parseInt(n.join('')));\n  // preserve order\n  if (index) parts.reverse();\n  const scores = parts;\n\n  const diff = Math.abs(scores.reduce((a, b) => +a - +b));\n  if (diff >= 2) return scores.join('-');\n  return undefined;\n}\n\nexport function dashJoin(part) {\n  if (part.length === 2) {\n    return part.split('').join('-');\n  }\n  [', ', ',', '/', ' '].forEach(\n    (separator) => (part = part.split(separator).join('-'))\n  );\n  part = part.replace(/-{2,}/, '-'); // handle repeating '-'\n  return part;\n}\n\nexport function isContained(part) {\n  return part.startsWith('(') && part.endsWith(')');\n}\n","import { arrayIndices } from '../../utilities/arrays';\n\nexport function dashMash(segment) {\n  if (!/^[\\d-]+(\\(\\d\\))*$/.test(segment)) {\n    return segment;\n  }\n  const dashIndices = arrayIndices('-', segment.split(''));\n  if (!dashIndices.length) return segment;\n  const numbers = segment.split('-');\n  const eventNumberCount = !(numbers.length % 2);\n  const oddDashCount = !!(dashIndices.length % 2);\n  // handle situation where too many dashes join what should be sets\n  // multiple sets were found within a parenthetical\n  if (\n    eventNumberCount &&\n    oddDashCount &&\n    dashIndices.length > numbers.length / 2\n  ) {\n    const spaceIndices = dashIndices.filter((_, i) => i % 2);\n    spaceIndices.forEach((index) => {\n      segment =\n        segment.substring(0, index) + ' ' + segment.substring(index + 1);\n    });\n  }\n  return segment;\n}\n","import { isNumeric } from '../../utilities/math';\n\nexport function setBuilder({ score }) {\n  const chars = score.split('');\n  const sets: any[] = [];\n  let set;\n\n  const resetSet = () => (set = [undefined, undefined, undefined]);\n  const completeSet = () => {\n    let joinedSet = `${set[0]}-${set[1]}`;\n    if (set[2]) joinedSet += ` (${set[2]})`;\n    resetSet();\n    set.push(set);\n    return joinedSet;\n  };\n  resetSet();\n\n  // let tiebreak = '';\n\n  const getDiff = () => {\n    return (\n      set[0] !== undefined &&\n      set[1] !== undefined &&\n      Math.abs(parseInt(set[0]) - parseInt(set[1]))\n    );\n  };\n\n  while (chars.length) {\n    const char = chars.shift();\n    const digit = isNumeric(char) && parseInt(char);\n    const twoSetScores = set[0] !== undefined && set[1] !== undefined;\n\n    if (isNumeric(digit)) {\n      if (set[0] === undefined) {\n        set[0] = digit;\n        continue;\n      }\n      if (set[1] === undefined) {\n        set[1] = digit;\n        if (getDiff() || 0 > 1) {\n          sets.push(completeSet());\n          set = [undefined, undefined];\n          continue;\n        }\n      }\n      if (twoSetScores && chars.length === 1 && isNumeric(chars[0])) {\n        const lastChar = chars.pop();\n        set[0] = set[0].toString() + set[1].toString();\n        set[1] = lastChar;\n        sets.push(completeSet());\n        set = [undefined, undefined];\n      }\n      if (twoSetScores && getDiff() === 1) {\n        // is a set tiebreak\n      }\n      // const diff = getDiff();\n    }\n  }\n\n  return { sets };\n}\n","import { getSuper } from './utilities';\n\nexport function parseSuper(score) {\n  const oneIndex = score.indexOf('1');\n  const numbers = score.split('');\n  const allNumeric = numbers.every((n) => !isNaN(n));\n\n  if (allNumeric && score.length === 3 && oneIndex === 0) {\n    const superTiebreak = getSuper(numbers, oneIndex);\n    if (superTiebreak) return superTiebreak;\n  }\n\n  if (allNumeric && score.length === 7 && oneIndex > 3) {\n    const tiebreak = numbers.slice(4);\n    const superTiebreak = getSuper(tiebreak, oneIndex - 4);\n    if (superTiebreak) {\n      return `${numbers[0]}-${numbers[1]} ${numbers[2]}-${numbers[3]} ${superTiebreak}`;\n    }\n  }\n\n  return undefined;\n}\n","import { chunkArray, instanceCount } from '../../utilities/arrays';\nimport { setBuilder } from './setBuilder';\nimport { parseSuper } from './parseSuper';\nimport { isNumeric } from '../../utilities/math';\n\nexport function handleNumeric(params) {\n  let { score } = params;\n  const { applied, matchUpStatus } = params;\n  const onlyNumbers = score\n    ?.toString()\n    // .replace(/\\(|\\)|\\s/g, '')\n    .split('');\n  const allNumeric = onlyNumbers?.every((d) => isNumeric(d));\n\n  const getDiff = (values) => Math.abs(values[0] - values[1]);\n\n  if (typeof score === 'number' || allNumeric) {\n    score = score.toString().toLowerCase();\n    if (allNumeric) score = onlyNumbers.join('');\n    const numbers = allNumeric\n      ? onlyNumbers.map((n) => parseInt(n))\n      : score.split('').map((n) => parseInt(n));\n\n    const { sets } = setBuilder({ score });\n    if (sets) {\n      /**\n      console.log({ sets });\n      */\n    }\n\n    if (numbers.length === 6) {\n      /**\n      console.log(getDiff(numbers.slice(0, 2)));\n      console.log(getDiff(numbers.slice(2, 4)));\n      console.log(getDiff(numbers.slice(4, 6)));\n      */\n    }\n\n    if (score.length === 3 && getDiff(numbers.slice(0, 2)) === 1) {\n      const [s1, s2, tb] = numbers;\n      score = `${s1}-${s2}(${tb})`;\n      applied.push('numericTiebreakPattern1');\n    } else if (score.length === 3 && numbers[0] === 1) {\n      const [mtb1, mtb2, mtb3] = numbers;\n      score = `[${mtb1}${mtb2}-${mtb3}]`;\n      applied.push('numericTiebreakPattern2');\n    } else if (\n      score.length === 4 &&\n      getDiff(numbers.slice(0, 2)) === 1 &&\n      '987654'.split('').includes(numbers[0].toString())\n    ) {\n      const [s1, s2, tb1, tb2] = numbers;\n      const tb = Math.min(tb1, tb2);\n      score = `${s1}-${s2}(${tb})`;\n      applied.push('numericTiebreakPattern3');\n    } else if (score.length === 4 && numbers[0] === 1 && numbers[2] === 1) {\n      const [tb1, tb2, tb3, tb4] = numbers;\n      score = `[${tb1}${tb2}-${tb3}${tb4}]`;\n      applied.push('bigSuper');\n    } else if (score.length === 4) {\n      const [s1, s2, s3, s4] = numbers;\n      score = `${s1}${s2} ${s3}${s4}`;\n      applied.push('split4');\n    } else if (score.length === 5 && getDiff(numbers.slice(0, 2)) === 1) {\n      const [s1, s2, tb, s3, s4] = numbers;\n      score = `${s1}-${s2}(${tb}) ${s3}-${s4}`;\n      applied.push('numericTiebreakPattern4');\n    } else if (score.length === 5 && getDiff(numbers.slice(3)) === 1) {\n      const [s1, s2, s3, s4, tb] = numbers;\n      score = `${s1}-${s2} ${s3}-${s4}(${tb})`;\n      applied.push('numericTiebreakPattern5');\n    } else if (numbers.length === 7) {\n      if (\n        getDiff(numbers.slice(0, 2)) > 1 &&\n        getDiff(numbers.slice(2, 4)) > 1 &&\n        numbers[4] === 1\n      ) {\n        const [s1, s2, s3, s4, mtb1, mtb2, mtb3] = numbers;\n        score = `${s1}-${s2} ${s3}-${s4} [${mtb1}${mtb2}-${mtb3}]`;\n        applied.push('numericTiebreakPattern6');\n      } else if (\n        getDiff(numbers.slice(0, 2)) === 1 &&\n        getDiff(numbers.slice(3, 5)) > 1 &&\n        getDiff(numbers.slice(5, 7)) > 1\n      ) {\n        const [s1, s2, tb, s3, s4, s5, s6] = numbers;\n        score = `${s1}-${s2}(${tb}) ${s3}-${s4} ${s5}-${s6}`;\n        applied.push('numericTiebreakPattern7');\n      } else if (\n        getDiff(numbers.slice(0, 2)) > 1 &&\n        getDiff(numbers.slice(2, 4)) === 1 &&\n        getDiff(numbers.slice(5, 7)) > 1\n      ) {\n        const [s1, s2, s3, s4, tb, s5, s6] = numbers;\n        /**\n        if (tb === 1) {\n          score = `${s1}-${s2} ${s3}-${s4} [${tb}${s5}-${s6}]`;\n          applied.push('numericTiebreakPattern8');\n        } else {\n        */\n        score = `${s1}-${s2} ${s3}-${s4}(${tb}) ${s5}-${s6}`;\n        applied.push('numericTiebreakPattern8');\n        //}\n      } else if (\n        getDiff(numbers.slice(0, 2)) > 1 &&\n        getDiff(numbers.slice(2, 4)) > 1 &&\n        getDiff(numbers.slice(4, 6)) === 1\n      ) {\n        const [s1, s2, s3, s4, s5, s6, tb] = numbers;\n        score = `${s1}-${s2} ${s3}-${s4} ${s5}-${s6}(${tb})`;\n        applied.push('numericTiebreakPattern9');\n      } else {\n        score =\n          score.slice(0, 2) + ' ' + score.slice(2, 4) + ' ' + score.slice(4);\n        applied.push('numericMatchTiebreakPattern');\n      }\n    } else if (!(score.length % 2)) {\n      const chunks = chunkArray(score.split(''), 2).map((part) =>\n        part.join('')\n      );\n      const chunkCharacter = chunks.map((chunk) => {\n        const [s1, s2] = chunk.split('').map((s) => parseInt(s));\n        const diff = Math.abs(s1 - s2);\n        const winner = s1 > s2 ? 1 : 2;\n        return (diff > 1 && winner) || winner * -1;\n      });\n      const allWinners = chunkCharacter.reduce((a, b) => a > 0 && b > 0, 1);\n      const instances = instanceCount(chunkCharacter);\n      const positiveCharacter = chunkCharacter.map((c) => Math.abs(c));\n      const positiveInstances = instanceCount(positiveCharacter);\n      const set1tb = chunkCharacter[0] < 0;\n      const set2tb = !set1tb && chunkCharacter[1] < 0;\n\n      if (\n        chunkCharacter[0] > 0 &&\n        chunkCharacter[1] > 0 &&\n        chunkCharacter[0] !== chunkCharacter[1]\n      ) {\n        score = [chunks.slice(0, 2).join(' '), chunks.slice(2).join('-')].join(\n          ' '\n        );\n        applied.push('numeric3rdSetTiebreakPattern');\n      } else if (allWinners) {\n        score = chunks.join(' ');\n        applied.push('chunkSplit');\n      } else if (numbers.length == 6) {\n        if (instances[1] == 2 || instances[2] === 2) {\n          if (!Object.values(positiveInstances).includes(3)) {\n            score = chunks.join(' ');\n            applied.push('chunkSplit');\n          } else {\n            const [n1, n2, n3, n4, n5, n6] = numbers;\n            const tiebreakChunkIndex = chunkCharacter.reduce(\n              (index, chunk, i) => (chunk < 0 ? i : index),\n              undefined\n            );\n            if (tiebreakChunkIndex === 0) {\n              const tb = Math.min(n3, n4);\n              score = `${n1}-${n2}(${tb}) ${n5}-${n6}`;\n              applied.push('chunkSplitTiebreak1');\n            } else if (tiebreakChunkIndex === 1) {\n              const tb = Math.min(n5, n6);\n              score = `${n1}-${n2} ${n3}-${n4}(${tb})`;\n              applied.push('chunkSplitTiebreak2');\n            } else {\n              score = `${n1}-${n2} ${n3}-${n4}`;\n              applied.push('chunkSplitTrimExtraneous');\n            }\n          }\n        }\n      } else if (numbers.length === 8) {\n        const [n1, n2, n3, n4, n5, n6, n7, n8] = numbers;\n        if (set1tb || set2tb) {\n          // there is a tiebreak in the first two sets\n          // remaining 3 digits can be super or another tiebreak set\n          if (numbers[5] === 1) {\n            // 3rd set match tiebreak\n            if (set1tb) {\n              score = `${n1}-${n2}(${n3}) ${n4}-${n5} [${n6}${n7}-${n8}]`;\n            } else {\n              score = `${n1}-${n2} ${n3}-${n4}(${n5}) [${n6}${n7}-${n8}]`;\n            }\n          }\n        } else if (chunkCharacter[0] !== chunkCharacter[1]) {\n          // first two sets are split\n        }\n      }\n    } else {\n      const superParse = parseSuper(score);\n      if (superParse && score !== superParse) {\n        applied.push('parsedSuperPattern');\n      }\n      score = superParse ?? score;\n    }\n  }\n\n  return { score, applied, matchUpStatus };\n}\n","export function getWinningSide(score) {\n  const setsWon = [0, 0];\n  const setWinners: number[] = [];\n  const sets = score.split(' ');\n  const getSetScores = /(\\d+)-(\\d+)/;\n  sets.forEach((set) => {\n    if (getSetScores.test(set)) {\n      const setScores = set\n        .match(getSetScores)\n        .slice(1)\n        .map((s) => parseInt(s));\n      const winningSide =\n        (setScores[0] > setScores[1] && 1) ||\n        (setScores[1] > setScores[0] && 2);\n      if (winningSide) {\n        setsWon[winningSide - 1] += 1;\n        setWinners.push(winningSide);\n      }\n    }\n  });\n  const winningSide =\n    (setsWon[0] > setsWon[1] && 1) || (setsWon[1] > setsWon[0] && 2);\n  const setsTied = setsWon[0] > 0 && setsWon[0] === setsWon[1];\n  const totalSets = setsWon.reduce((a, b) => a + b, 0);\n\n  return { setsWon, setsTied, setWinners, totalSets, winningSide };\n}\n","import { punctuationAdjustments } from './punctuationAdjustments';\nimport { handleBracketSpacing } from './handleBracketSpacing';\nimport { joinFloatingTiebreak } from './joinFloatingTiebreak';\nimport { matchKnownPatterns } from './matchKnownPatterns';\nimport { properTiebreak } from './properTiebreak';\nimport { containedSets } from './containedSets';\nimport { handleNumeric } from './handleNumeric';\nimport { sensibleSets } from './sensibleSets';\nimport { superSquare } from './superSquare';\nimport { setBuilder } from './setBuilder';\nimport { parseSuper } from './parseSuper';\nimport { getSuper } from './utilities';\nimport { isNumeric } from '../../utilities/math';\n\nexport function stringScore({ score }) {\n  score = score?.toString().toLowerCase() || '';\n\n  return { score };\n}\n\nexport function replaceOh({ score, applied }) {\n  if (typeof score !== 'string') return { score };\n\n  if (score.toLowerCase().includes('o')) {\n    score = score\n      .toLowerCase()\n      .split(' ')\n      .map((part) => part.split('o').join('0'))\n      .join(' ');\n    applied.push('replaceOh');\n  }\n\n  return { score, applied };\n}\n\nexport function separateScoreBlocks({ score, applied }) {\n  if (typeof score !== 'string') return { score };\n  score = score\n    .toLowerCase()\n    .split(' ')\n    .map((part) => {\n      if (/^\\d+$/.test(part) && part.length > 2) {\n        const oneIndex = part.indexOf('1');\n        if (!(part.length % 2)) {\n          const { score: xPart, applied: app } = handleNumeric({\n            score: part,\n            applied: [],\n          });\n          if (xPart !== part) {\n            part = xPart;\n            applied.push(...app);\n          }\n        } else if (part.length === 3 && oneIndex === 0) {\n          const tiebreakScore = getSuper(part.split(''), oneIndex);\n          applied.push('getSuper');\n          return tiebreakScore;\n        }\n      }\n      return part;\n    })\n    .join(' ');\n\n  return { score, applied };\n}\n\nexport function removeErroneous({ score, applied }) {\n  if (typeof score !== 'string') return { score };\n\n  if ([3, 4].includes(score.length) && parseSuper(score)) {\n    const superTie = parseSuper(score);\n    return { score: superTie };\n  }\n\n  score = score\n    .toLowerCase()\n    .split(' ')\n    .map((part) => {\n      if (/^\\d+$/.test(part) && part.length === 1) {\n        applied.push('removeErroneous1');\n        return;\n      }\n      return part;\n    })\n    .filter(Boolean)\n    .join(' ');\n\n  return { score, applied };\n}\n\nexport function handleWalkover({ score, applied }) {\n  if (\n    ['walkover', 'wo', 'w/o', 'w-o'].includes(score?.toString().toLowerCase())\n  ) {\n    applied.push('handleWalkover');\n    return { matchUpStatus: 'walkover', score: '', applied };\n  }\n  return { score };\n}\n\nexport function handleRetired({ score, profile, applied }) {\n  score = score?.toString().toLowerCase();\n  const re = /^(.*\\d+.*)(ret|con)+[A-Za-z ]*$/; // at least one digit\n  if (re.test(score)) {\n    const [leading] = score.match(re).slice(1);\n    applied.push('handleRetired');\n    return { score: leading.trim(), matchUpStatus: 'retired', applied };\n  }\n\n  const providerRetired = profile?.matchUpStatuses?.retired;\n  const additionalRetired = Array.isArray(providerRetired)\n    ? providerRetired\n    : [providerRetired].filter(Boolean);\n\n  // accommodate other variations\n  const retired = ['rtd', ...additionalRetired].find(\n    (ret) => score?.endsWith(ret)\n  );\n\n  if (retired) {\n    applied.push('handleRetired');\n    return {\n      matchUpStatus: 'retired',\n      score: score?.replace(retired, '').trim(),\n      applied,\n    };\n  }\n  return { score };\n}\n\nexport function removeDanglingBits({ score, attributes }) {\n  if (score.endsWith(' am') || score.endsWith(' pm')) score = '';\n\n  score = score.replace(/[A-Za-z]+/g, '').trim();\n  if (['.', ','].some((punctuation) => score.endsWith(punctuation))) {\n    score = score.slice(0, score.length - 1);\n  }\n\n  const targetPunctuation = '()/-'\n    .split('')\n    .some((punctuation) => score.includes(punctuation));\n  if (/ \\d$/.test(score) && targetPunctuation) {\n    const removed = score.slice(score.length - 2).trim();\n    attributes = { removed };\n    score = score.slice(0, score.length - 2);\n  }\n\n  const alphaEnding = /(.*)[A-Za-z]+$/;\n  if (alphaEnding.test(score)) {\n    const scorePart = score.match(alphaEnding).slice(1)[0];\n    score = scorePart.trim();\n  }\n\n  return { score, attributes };\n}\n\nexport function handleSetSlashSeparation({ score }) {\n  const re = new RegExp(/-\\d+\\/\\d+-/);\n  if (re.test(score)) {\n    score = score.split('/').join(' ');\n  }\n  return { score };\n}\n\nexport function handleGameSeparation({ score }) {\n  const re = new RegExp(/^\\d+\\/\\d+/);\n  const parts = score.split(' ');\n  if (parts.some((part) => re.test(part))) {\n    score = parts\n      .map((part) => (re.test(part) ? part.replace('/', '-') : part))\n      .join(' ');\n  }\n\n  const singleSet = /^(\\d+), *(\\d+)$/;\n  if (singleSet.test(score)) {\n    const [s1, s2] = score.match(singleSet).slice(1);\n    const setScore = [s1, s2].join('-');\n    score = setScore;\n  }\n\n  return { score };\n}\n\nexport function handleTiebreakSlashSeparation({ score }) {\n  const re = new RegExp(/\\(\\d+\\/\\d+\\)/g);\n  const tiebreaks = score.match(re);\n  for (const tiebreak of tiebreaks || []) {\n    const replacement = tiebreak.replace('/', '-');\n    score = score.replace(tiebreak, replacement);\n  }\n  return { score };\n}\n\nexport function handleSpaceSeparator({ score }) {\n  if (score.includes(',')) {\n    const sets = score.split(',').map((set) => set.trim());\n    const isSpaced = (set) => /\\d \\d/.test(set);\n    const spacedSets = sets.every(isSpaced);\n    if (spacedSets)\n      score = sets\n        .map((set) => {\n          const spaceSeparatedDigits = /\\d+ \\d+/g;\n          for (const ssd of set.match(spaceSeparatedDigits)) {\n            const [d1, d2] = ssd.match(/(\\d+) (\\d+)/).slice(1);\n            set = set.replace(ssd, `${d1}-${d2}`);\n          }\n          return set;\n        })\n        .join(' ');\n  }\n\n  if (score.includes(' ')) {\n    const noSpaces = score.replace(/[ ,]/g, '');\n    const isNumber = noSpaces.split('').every((char) => isNumeric(char));\n    if (isNumber && noSpaces.length === 4) {\n      score = noSpaces;\n    }\n  }\n\n  return { score };\n}\n\nexport function excisions({ score }) {\n  const re = new RegExp(/^\\[\\d+\\](.*)$/);\n  if (re.test(score)) {\n    score = score.match(re).slice(1)[0].trim();\n  }\n\n  const openComma = /\\(,/g;\n  if (openComma.test(score)) {\n    score = score.replace(openComma, '(');\n  }\n\n  return { score };\n}\n\nexport const transforms = {\n  handleTiebreakSlashSeparation: handleTiebreakSlashSeparation,\n  handleSetSlashSeparation: handleSetSlashSeparation,\n  punctuationAdjustments: punctuationAdjustments,\n  handleGameSeparation: handleGameSeparation,\n  joinFloatingTiebreak: joinFloatingTiebreak,\n  handleBracketSpacing: handleBracketSpacing,\n  handleSpaceSeparator: handleSpaceSeparator,\n  separateScoreBlocks: separateScoreBlocks,\n  matchKnownPatterns: matchKnownPatterns,\n  removeDanglingBits: removeDanglingBits,\n  removeErroneous: removeErroneous,\n  handleWalkover: handleWalkover,\n  properTiebreak: properTiebreak,\n  handleNumeric: handleNumeric,\n  handleRetired: handleRetired,\n  containedSets: containedSets,\n  sensibleSets: sensibleSets,\n  stringScore: stringScore,\n  superSquare: superSquare,\n  setBuilder: setBuilder,\n  excisions: excisions,\n  replaceOh: replaceOh,\n};\n","import { correctContainerMismatch } from './correctContainerMismatch';\nimport { instanceCount } from '../../utilities/arrays';\nimport { isContained } from './utilities';\n\nexport function punctuationAdjustments({ score, applied }) {\n  score = correctContainerMismatch(score);\n\n  const closeParenDigit = /\\)(\\d+)/g;\n  if (closeParenDigit.test(score)) {\n    for (const instance of score.match(closeParenDigit)) {\n      const replacement = instance.replace(')', ') ');\n      score = score.replace(instance, replacement);\n    }\n  }\n\n  score = score.replace(/\\)\\//g, ') / ');\n  score = score.replace(/\\/\\)/g, ')');\n\n  // convert (# - # ) => (#-#)\n  const bwsg = /\\(([\\d- ]+)\\)/g;\n  const bws = /\\(([\\d- ]+)\\)/;\n  const ws = score.match(bwsg);\n  for (const s of ws || []) {\n    const [v] = s.match(bws).slice(1);\n    const trimmedBracketValue = v.replace(/ /g, '');\n    score = score.replace(s, `(${trimmedBracketValue})`);\n  }\n\n  let doubleBracketed = /\\(\\(\\d-\\d\\)\\)/g;\n  if (doubleBracketed.test(score)) {\n    const dbls = score.match(doubleBracketed);\n    if (dbls.length) {\n      dbls.forEach((dbl) => {\n        const m = dbl.match(/\\((\\(\\d-\\d\\))\\)/).slice(1)[0];\n        score = score.replace(dbl, m);\n      });\n    }\n  }\n\n  doubleBracketed = /\\(\\((\\d)\\)\\)/g;\n  if (doubleBracketed.test(score)) {\n    const dbls = score.match(doubleBracketed);\n    if (dbls.length) {\n      dbls.forEach((dbl) => {\n        const m = dbl.match(/\\((\\(\\d\\))\\)/).slice(1)[0];\n        score = score.replace(dbl, m);\n      });\n    }\n  }\n\n  // must occur before repating dash or dash with comma\n  if (/(^|\\s)6-,/.test(score)) {\n    score = score.replace(/(^|\\s)6-,/g, '6-0,');\n  }\n\n  // repeating dash or dash with comma\n  const repeatingDash = new RegExp(/[-,]{2,}/g);\n  score = score.replace(repeatingDash, '-');\n\n  // dash space or space dash\n  ['- ', ' -'].forEach((dashScenario) => {\n    const dashSpace = new RegExp(`(\\\\d+)${dashScenario}(\\\\d+)`, 'g');\n    const spacedDash = score.match(dashSpace);\n    if (spacedDash) {\n      spacedDash.forEach(\n        (spaced) =>\n          (score = score.replace(spaced, spaced.split(dashScenario).join('-')))\n      );\n    }\n  });\n\n  // remove punctuation-only results\n  if (/^[(-/,]+$/.test(score)) {\n    score = '';\n  }\n\n  // remove extraneous trailing punctuation\n  if (/\\)[-/,]+$/.test(score)) {\n    score = score.slice(0, score.length - 1);\n  }\n\n  // space slash surrounded by digits\n  if (/\\d \\/\\d/.test(score)) score = score.replace(/ \\//g, '/');\n  // all other space slashes are replaced by space\n  if (score.includes(' /')) score = score.replace(/ \\//g, ' ');\n\n  const ghost = /\\(\\d+, \\)/g;\n  if (ghost.test(score)) {\n    const ghosts = score.match(ghost);\n    ghosts.forEach((g) => {\n      const [digits] = g.match(/\\((\\d+), \\)/).slice(1);\n      if (digits.length === 2) {\n        score = score.replace(g, `(${digits})`);\n      } else if (digits.length === 1 && digits === '6') {\n        score = score.replace(g, `(6-0)`);\n      }\n    });\n  }\n\n  const slashClose = /\\((\\d+)\\/\\)/g;\n  if (slashClose.test(score)) {\n    const sc = score.match(slashClose);\n    sc.forEach((s) => {\n      const [digits] = s.match(/\\((\\d+)\\/\\)/).slice(1);\n      if (digits.length === 2) {\n        score = score.replace(s, `(${digits})`);\n      } else if (digits.length === 1 && digits === '6') {\n        // TODO: some logic to determine whether tiebreak value is expected\n        score = score.replace(s, `(6-0)`);\n      } else {\n        // TODO: some logic to determine whether tiebreak value is expected\n        score = score.replace(s, `(${digits})`);\n      }\n    });\n  }\n\n  const slashComma = /\\d\\/\\d\\/,/g;\n  if (slashComma.test(score)) {\n    const sc = score.match(slashComma);\n    sc.forEach((s) => {\n      const [digits] = s.match(/(\\d\\/\\d)\\/,/).slice(1);\n      score = score.replace(s, `${digits},`);\n      applied.push('slashComma');\n    });\n  }\n\n  const slashOpen = /\\(\\/(\\d+)\\)/g;\n  if (slashOpen.test(score)) {\n    const sc = score.match(slashOpen);\n    sc.forEach((s) => {\n      const [digits] = s.match(/\\(\\/(\\d+)\\)/).slice(1);\n      if (digits.length === 2) {\n        score = score.replace(s, `(${digits})`);\n      } else if (digits.length === 1 && parseInt(digits) < 6) {\n        score = score.replace(s, `(6-${digits})`);\n      } else {\n        // TODO: some logic to determine whether tiebreak value is expected\n        score = score.replace(s, `(${digits})`);\n      }\n    });\n  }\n\n  let missingOpenParen, missingCloseParen, missingCloseBracket, noClose, counts;\n  const getMissing = () => {\n    counts = instanceCount(score.split(''));\n    missingCloseParen = counts['('] === (counts[')'] || 0) + 1;\n    missingOpenParen = (counts['('] || 0) + 1 === counts[')'];\n    missingCloseBracket = counts['['] === counts[']'] + 1;\n    noClose = missingCloseParen && !missingCloseBracket;\n  };\n  getMissing();\n\n  const unclosed = /(\\d+-\\d+\\(\\d+)0,/;\n  if (unclosed.test(score)) {\n    const [setScore] = score.match(unclosed).slice(1);\n    score = score.replace(unclosed, setScore + ')');\n  }\n\n  if (counts['('] === counts[')'] && counts['('] > 1) {\n    const parts = score.split(')(').join(') (').split(' ');\n    if (parts.every(isContained)) {\n      score = parts\n        .map((part) => {\n          const innards = part.slice(1, part.length - 1);\n          return innards.length > 2 ? innards : part;\n        })\n        .join(' ');\n    } else {\n      score = parts.join(' ');\n    }\n  }\n\n  getMissing();\n\n  const hasAlpha = /[A-Za-z]+/.test(score);\n  const hasDigits = /\\d+/.test(score);\n\n  if (!hasAlpha && !hasDigits) return { score: '' };\n\n  // remove enclosing [] provided there is anything other than numbers contained\n  // don't want to remove for e.g. \"[1]\" which is dealt with as seeding value\n  if (\n    /^\\[.+\\]$/.test(score) &&\n    '()/,- '.split('').some((punctuation) => counts[punctuation])\n  ) {\n    score = score.slice(1, score.length - 1);\n  }\n\n  // remove enclosing () provided contained punctuation\n  if (\n    /^\\(.+\\)$/.test(score) &&\n    counts['('] === 1 &&\n    counts[')'] === 1 &&\n    '[]/,'.split('').some((punctuation) => counts[punctuation] > 1)\n  ) {\n    score = score.slice(1, score.length - 1);\n  }\n\n  if (score.startsWith('(') && score.endsWith('))')) {\n    score = score.slice(1, score.length - 1);\n  }\n\n  if (counts['('] > (counts[')'] || 0) && score[score.length - 1] === '(') {\n    score = score.slice(0, score.length - 1) + ')';\n    getMissing();\n  }\n\n  if (counts['('] === 1 && !counts[')'] && score[0] === '(') {\n    score = score + ')';\n    getMissing();\n  }\n\n  if (counts['('] > (counts[')'] || 0) && score.slice(0, 2) === '((') {\n    score = score.slice(1);\n  }\n\n  if (missingOpenParen) {\n    if (/^9\\d/.test(score)) {\n      score = '(' + score.slice(1);\n    } else if (score[0] !== '(') {\n      score = '(' + score;\n    } else {\n      const reconstructed: string[] = [];\n      let open = 0;\n      // step through characters and insert close before open when open\n      for (const char of score.split('').reverse()) {\n        if (char === ')') {\n          if (open) {\n            reconstructed.push('(');\n          } else {\n            open += 1;\n          }\n        }\n        if (char === '(') open -= 1;\n        reconstructed.push(char);\n      }\n      reconstructed.reverse();\n      score = reconstructed.join('');\n    }\n\n    getMissing();\n  }\n\n  if (counts[')'] > (counts['('] || 0) && score[0] === ')') {\n    score = '(' + score.slice(1);\n    getMissing();\n  }\n\n  if (noClose && (score.endsWith(9) || /\\d+0$/.test(score))) {\n    score = score.slice(0, score.length - 1) + ')';\n    getMissing();\n  }\n\n  if (noClose && (!score.endsWith(')') || score.startsWith('(('))) {\n    score = score + ')';\n    getMissing();\n  }\n\n  if (noClose) {\n    let reconstructed = '';\n    let open = 0;\n    // step through characters and insert close before open when open\n    for (const char of score.split('')) {\n      if (char === '(') {\n        if (open) {\n          reconstructed += ')';\n        } else {\n          open += 1;\n        }\n      }\n      if (char === ')') open -= 1;\n      reconstructed += char;\n    }\n    score = reconstructed;\n  }\n\n  getMissing();\n  if (missingCloseBracket && !missingCloseParen) score = score + ']';\n\n  // this is potentially problematic as enclosing with '[]' yields tiebreak...\n  // ... wheres enclosing with '()' yields a set which gets converted to a supertiebreak!\n  // Really it would be better to convert to set and determine later which type of tiebreak based on previous set\n  if (score.includes('([') && score.includes('])')) {\n    score = score.split('([').join('[').split('])').join(']');\n    getMissing();\n  }\n\n  if (/\\(\\d+0$/.test(score)) {\n    score = score.slice(0, score.length - 1) + ')';\n  }\n\n  getMissing();\n\n  if (counts[')'] === 1 && !counts['('] && score.endsWith(')')) {\n    score = score.slice(0, score.length - 1);\n  }\n\n  if (\n    score.startsWith('(') &&\n    score.endsWith(')') &&\n    counts['('] === 1 &&\n    counts[')'] === 1\n  ) {\n    score = score.slice(1, score.length - 1);\n    getMissing();\n  }\n\n  const openFirst = (value) => {\n    const open = value.indexOf('(');\n    const close = value.indexOf(')');\n    return open >= 0 && close >= 0 && open < close;\n  };\n\n  if (/^\\([\\d ]+.*[\\d ]+\\)$/.test(score) && counts['('] === counts[')']) {\n    const proposed = score.slice(1, score.length - 1);\n    if (openFirst(proposed)) {\n      score = proposed;\n      getMissing();\n    }\n  }\n\n  return { score, applied };\n}\n","export function correctContainerMismatch(score) {\n  const brackets = '[];';\n  const parens = '()';\n  const types = brackets + parens;\n  const openers = [brackets[0], parens[0]];\n  const typeCount = Object.assign(\n    {},\n    ...types.split('').map((char) => ({ [char]: 0 }))\n  );\n\n  let lastType = '';\n  const corrected = score\n    .split('')\n    .map((char) => {\n      const type = types.includes(char) && char;\n      const isOpener = openers.includes(type);\n      if (isOpener && type) {\n        typeCount[type] += 1;\n        lastType = type;\n        return char;\n      }\n      if (!isOpener && type && lastType && type !== lastType) {\n        typeCount[lastType] -= 1;\n        const domain =\n          (brackets.includes(lastType) && brackets) ||\n          (parens.includes(lastType) && parens) ||\n          '';\n        const complement = domain.split('').find((c) => c !== lastType);\n        if (!domain.includes(type)) {\n          if (!typeCount[type]) lastType = '';\n          return complement;\n        } else {\n          if (!typeCount[lastType]) lastType = '';\n        }\n      }\n\n      return char;\n    })\n    .join('');\n\n  if (score !== corrected) {\n    return corrected;\n  }\n\n  return score;\n}\n","import { matchTiebreak, standardSet, tiebreakSet } from './validPatterns';\nimport { isBracketScore, isDiffOne, isTiebreakScore } from './utilities';\nimport { arrayIndices } from '../../utilities/arrays';\n\nexport function joinFloatingTiebreak({ score }) {\n  if (typeof score !== 'string') return { score };\n  const strip = (value) => value?.split('-').join('').split('/').join('');\n  const bracketToParen = (value) =>\n    value.split('[').join('(').split(']').join(')');\n  score = score.split(', ').join(' ');\n  let parts = score.split(' ');\n\n  score = parts\n    .map((part) => {\n      const deDash = /^-(\\d+)$/;\n      if (deDash.test(part)) {\n        const [value] = part.match(deDash).slice(1);\n        if (value.length === 2) {\n          return value.split('').join('-');\n        }\n      }\n      return part;\n    })\n    .join(' ');\n\n  parts = score.split(' ');\n\n  const floatingTiebreaks = parts.filter(isTiebreakScore);\n\n  let lastIndex = 0;\n  let joinedScore = '';\n  for (const floatingTiebreak of floatingTiebreaks) {\n    const thisIndex = arrayIndices(floatingTiebreak, parts).filter(\n      (index) => !lastIndex || index > lastIndex\n    )[0];\n    const leading = parts.slice(lastIndex, thisIndex - 1);\n    const prior = parts[thisIndex - 1];\n    const stripped = strip(prior);\n    if (/^\\d+$/.test(stripped) && stripped.length === 2) {\n      const scores = stripped.split('');\n      const diff = Math.abs(scores.reduce((a, b) => +a - +b));\n      if (diff === 1) {\n        const joined = [\n          leading.join(' '),\n          [prior, floatingTiebreak].join(''),\n        ].join(' ');\n        joinedScore += joined;\n        lastIndex = thisIndex + 1;\n      } else if (diff === 0) {\n        const sameScore = Math.max(...scores);\n        if ([4, 5, 6, 7, 8, 9].includes(sameScore)) {\n          const pairedScore = [6, 4].includes(sameScore)\n            ? sameScore + 1\n            : sameScore - 1;\n          const setScore = [sameScore, pairedScore].sort().reverse().join('-');\n          const joined = [\n            leading.join(' '),\n            [setScore, floatingTiebreak].join(''),\n          ].join(' ');\n          joinedScore += joined;\n          lastIndex = thisIndex + 1;\n        }\n      }\n    }\n  }\n\n  if (floatingTiebreaks.length && joinedScore.length) {\n    const remainder = parts.slice(lastIndex).join(' ');\n    joinedScore = [joinedScore, remainder].join(' ');\n    return { score: joinedScore.trim() };\n  }\n\n  if (\n    parts.length === 2 &&\n    ['(', '['].some((punctuation) => parts[1].includes(punctuation))\n  ) {\n    const stripped = strip(parts[0]);\n    const scores = stripped.split('');\n    const diff = Math.abs(scores.reduce((a, b) => +a - +b, 0));\n    if (diff === 1) {\n      parts[1] = bracketToParen(parts[1]);\n      return { score: parts.join('') };\n    }\n  }\n\n  const parenScores = parts.map(\n    (part) => (isBracketScore(part) && 'bracket') || (isDiffOne(part) && 'set')\n  );\n  if (parenScores.includes('set') && parenScores.includes('bracket')) {\n    let lastPart;\n    let joinedParts = '';\n    parts.forEach((part, i) => {\n      if (parenScores[i] === 'bracket' && lastPart === 'set') {\n        part = bracketToParen(part);\n        joinedParts += part;\n      } else {\n        joinedParts += ` ${part}`;\n      }\n      lastPart = parenScores[i];\n    });\n    return { score: joinedParts.trim() };\n  }\n\n  // recognize tiebreak scores which look like sets s#-s# tb#-tb#\n  parts = score.split(' ');\n  let lastSet;\n  let profile = parts.map((part) => {\n    const re = new RegExp(/^(\\d+)-(\\d+)$/); // only consider sets which have no existing tiebreak score\n    if (re.test(part)) {\n      const [n1, n2] = part.match(re).slice(1);\n      const diff = Math.abs([n1, n2].reduce((a, b) => +a - +b));\n      const max = Math.max(n1, n2);\n      if (diff === 1) {\n        lastSet = 'tiebreakSet';\n        return lastSet;\n      } else if (diff >= 2 && max >= 7 && lastSet === 'tiebreakSet') {\n        lastSet = 'tiebreak';\n        return lastSet;\n      }\n    }\n  });\n\n  const tiebreakIndices = arrayIndices('tiebreak', profile);\n  if (tiebreakIndices.length) {\n    let joinedParts = '';\n    parts.forEach((part, i) => {\n      if (tiebreakIndices.includes(i)) {\n        joinedParts += `(${part}) `;\n      } else if (tiebreakIndices.includes(i + 1)) {\n        joinedParts += `${part}`;\n      } else {\n        joinedParts += `${part} `;\n      }\n    });\n    score = joinedParts.trim();\n  }\n\n  const setCheck = /(\\d+-\\d+)\\((\\d+)-(\\d+)\\)$/;\n  if (setCheck.test(score)) {\n    const [setScore, t1, t2] = score.match(setCheck).slice(1);\n    const maxTiebreakScore = Math.max(t1, t2);\n    const potentialSuper = maxTiebreakScore >= 10;\n    if (!isDiffOne(setScore) && potentialSuper) {\n      score = score.replace(setCheck, `${setScore} [${t1}-${t2}]`);\n    }\n  }\n\n  profile = [];\n  score = score\n    .split(' ')\n    .map((set) => {\n      const getContained = /^\\((.*)\\)$/;\n      const isContained = getContained.test(set);\n      const setType =\n        (new RegExp(matchTiebreak).test(set) && 'super') ||\n        (new RegExp(tiebreakSet).test(set) && 'tiebreak') ||\n        (new RegExp(standardSet).test(set) && 'standard') ||\n        'unknown';\n      profile.push(setType);\n\n      if (setType === 'standard' && isContained) {\n        return set.match(getContained)[1];\n      }\n      return set;\n    })\n    .join(' ');\n\n  return { score };\n}\n","import { dashMash } from './commonPatterns';\nimport { standardSetComma, tiebreakSetComma } from './validPatterns';\n\nexport function handleBracketSpacing({ score, applied }) {\n  if (score.includes('( ')) {\n    applied.push('removeParenSpacingAfterOpen');\n    score = score\n      .split('( ')\n      .map((part) => part.trim())\n      .join('(');\n  }\n\n  if (score.includes(' )')) {\n    applied.push('removeParenSpacingBeforeClose');\n    score = score\n      .split(' )')\n      .map((part) => part.trim())\n      .join(')');\n  }\n\n  [standardSetComma, tiebreakSetComma].forEach((setComma) => {\n    const setsEndComma = score.match(setComma);\n    if (setsEndComma?.length) {\n      setsEndComma.forEach((commaEnd) => {\n        score = score.replace(\n          commaEnd,\n          commaEnd.slice(0, commaEnd.length - 1) + ' '\n        );\n      });\n      applied.push('setsEndComma');\n    }\n  });\n\n  // remove extraneous spaces\n  score = score.split(' ').filter(Boolean).map(dashMash).join(' ');\n\n  return { score, applied };\n}\n","import { dashMash } from './commonPatterns';\n\nexport function matchKnownPatterns({ score, applied }) {\n  for (const punctuation of ['.', ',', ' ', '/']) {\n    const re = new RegExp(`^(\\\\d+)\\\\${punctuation}(\\\\d+)$`);\n    if (re.test(score)) {\n      const numbers = score\n        .match(re)\n        .slice(1)\n        .map((n) => parseInt(n));\n      const diff = Math.abs(numbers[0] - numbers[1]);\n      if (diff <= 10 && diff >= 2) {\n        score = score.split(punctuation).join('-');\n        applied.push('variedJoinerPattern');\n      }\n    }\n  }\n\n  if (score.includes(';')) {\n    score = score.split(';').join(' ');\n    applied.push('semicolon set separation');\n  }\n\n  const smashSlash = /(^|\\s)(\\d)\\/(\\d)(\\d)\\/(\\d)(\\(|$)/;\n  if (smashSlash.test(score)) {\n    const [before, s1, s2, s3, s4, after] = score.match(smashSlash).slice(1);\n    score = score.replace(\n      smashSlash,\n      `${before}${s1}-${s2} ${s3}-${s4}${after}`\n    );\n    applied.push('smashSlashPattern');\n  }\n\n  const incompleteFinalSet = /.*\\s6[/-]+$/;\n  if (incompleteFinalSet.test(score)) {\n    score += '0';\n    applied.push('incompleteFinalSetPattern');\n  }\n\n  const missingZero = /\\(6,\\)/g;\n  if (missingZero.test(score)) {\n    score = score.replace(missingZero, '(6, 0)');\n    applied.push('missingZeroPattern1');\n  }\n\n  // insert spaces before and after parentheses\n  const noSpacing = /^\\d{3,}\\(/;\n  const parenStart = /\\(\\d+\\)\\d+/;\n  const considerations = [noSpacing, parenStart];\n  considerations.forEach(() => {\n    const parts = score.split(' ');\n    score = parts\n      .map((part) => {\n        if (noSpacing.test(part)) {\n          part = part.replace('(', ' (');\n        }\n        if (parenStart.test(part)) {\n          part = part.replace(')', ') ');\n        }\n        return part;\n      })\n      .join(' ');\n    applied.push('spaceConsiderationPatterns');\n  });\n\n  const deDashMash = dashMash(score);\n  if (deDashMash !== score) {\n    score = deDashMash;\n    applied.push('deDashMash');\n  }\n\n  const smashedSets = /^(\\d)[-/,]+(\\d{2})[-/,]+(\\d)$/;\n  if (smashedSets.test(score)) {\n    const [s1, ss, s4] = score.match(smashedSets).slice(1);\n    const [s2, s3] = ss.split('');\n    score = `${s1}-${s2} ${s3}-${s4}`;\n    applied.push('smashSetPattern');\n  }\n\n  const setSpacing = /^(\\d+)[ -](\\d+)$/;\n  const slashSeparation = /^([\\d -]+)\\/([\\d -]+)$/;\n  if (slashSeparation.test(score)) {\n    const [left, right] = score.match(slashSeparation).slice(1);\n    const s1 = left.trim();\n    const s2 = right.trim();\n    if (setSpacing.test(s1) && setSpacing.test(s2)) {\n      const set1 = s1.match(setSpacing).slice(1, 3).join('-');\n      const set2 = s2.match(setSpacing).slice(1, 3).join('-');\n      score = `${set1} ${set2}`;\n      applied.push('slashSeparationPattern');\n    }\n  }\n\n  const commaSeparation = /^([\\d -]+),([\\d -]+)$/;\n  if (commaSeparation.test(score)) {\n    const [left, right] = score.match(commaSeparation).slice(1);\n    const s1 = left.trim();\n    const s2 = right.trim();\n    if (setSpacing.test(s1) && setSpacing.test(s2)) {\n      const set1 = s1.match(setSpacing).slice(1, 3).join('-');\n      const set2 = s2.match(setSpacing).slice(1, 3).join('-');\n      score = `${set1} ${set2}`;\n      applied.push('commaSeparationPattern');\n    }\n  }\n\n  const singleSetCommaSeparation = /^\\d \\d,/;\n  if (singleSetCommaSeparation.test(score)) {\n    const set = score.match(singleSetCommaSeparation)[0];\n    const replacement = set\n      .slice(0, set.length - 1)\n      .split(' ')\n      .join('-');\n    score = score.replace(set, replacement);\n    applied.push('singleSetCommaSeparationPattern');\n  }\n\n  // pattern \\d+-\\d{2}-\\d+ => \\d-\\d \\d-\\d\n  let failSafe = 0;\n  const noSetSeparation = /(\\d+)-(\\d{2})-(\\d+)/;\n  while (noSetSeparation.test(score) && failSafe < 3) {\n    const [left, middle, right] = score.match(noSetSeparation).slice(1);\n    const separated = middle.split('');\n    const reformatted = `${left}-${separated[0]} ${separated[1]}-${right}`;\n    score = score.replace(noSetSeparation, reformatted);\n    applied.push('noSetSeparationPattern');\n    failSafe += 1;\n  }\n\n  const getFloatingTiebreaks = /(^|\\s)7-6\\s(\\d+)\\s/g;\n  const floatingTiebreaks = score.match(getFloatingTiebreaks);\n  if (floatingTiebreaks?.length) {\n    const getFloatingTiebreak = /(^|\\s)7-6\\s(\\d+)\\s/;\n    floatingTiebreaks.forEach((floater) => {\n      const tiebreakScore = floater.match(getFloatingTiebreak).slice(2)[0];\n      score = score.replace(floater, `7-6(${tiebreakScore}) `);\n      applied.push('floatingTiebreakPattern1');\n    });\n  }\n\n  let spaceSeparatedSets = score.match(/\\d \\d /);\n  spaceSeparatedSets?.forEach((ss) => {\n    const replacement = ss\n      .slice(0, ss.length - 1)\n      .split(' ')\n      .join('-');\n    score = score.replace(ss, replacement);\n    applied.push('spaceSeparatedSetPattern1');\n  });\n\n  spaceSeparatedSets = score.match(/ \\d \\d$/);\n  spaceSeparatedSets?.forEach((ss) => {\n    const replacement = ' ' + ss.slice(1).split(' ').join('-');\n    score = score.replace(ss, replacement);\n    applied.push('spaceSeparatedSetPattern2');\n  });\n\n  // slash separated sets with comma separated games\n  // pattern /\\d+,\\s?\\d/+\\/\\d+\\s?\\d+/\n  const slashCommaSets = /^\\d, *\\d\\/\\d, *\\d/;\n  if (slashCommaSets.test(score)) {\n    const excerpt = score.match(slashCommaSets)[0];\n    const replacement =\n      excerpt\n        .split('/')\n        .map((e) => `(${e})`)\n        .join(' ') + ' ';\n    score = score.replace(excerpt, replacement);\n    applied.push('slashCommaSetPattern');\n  }\n\n  const missedSet0 = /\\(6-\\)/g;\n  if (missedSet0.test(score)) {\n    score = score.replace(missedSet0, '(6-0)');\n    applied.push('missingZeroPattern2');\n  }\n\n  // IMPORTANT: must occur last...\n  const slashSetGlobal = /(?<!-)(\\d+)\\/(\\d+)(?!-)/g;\n  if (slashSetGlobal.test(score)) {\n    const slashSets = score.match(slashSetGlobal);\n    const slashSet = /(?<!-)(\\d+)\\/(\\d+)(?!-)/;\n    let newScore = score;\n    slashSets.forEach((set) => {\n      const [s1, s2] = set.match(slashSet).slice(1);\n      const dashSet = `${s1}-${s2}`;\n      newScore = newScore.replace(set, dashSet);\n    });\n    score = newScore;\n    applied.push('slashSetPattern');\n  }\n\n  // space separated match tiebreak\n  const spaceSeparatedSuper = /(.*)\\s(1\\d)\\s(\\d+)$/;\n  if (spaceSeparatedSuper.test(score)) {\n    const [start, s1, s2] = score.match(spaceSeparatedSuper).slice(1);\n    const digitCount = start.replace(/\\D/g, '').length;\n    if (digitCount >= 4) {\n      score = start + ` ${s1}${s2}`;\n      applied.push('spaceSeparatedSuperPattern');\n    }\n  }\n\n  // space separated set tiebreak\n  // #-# # => #-#(#) with boundary constraints\n  const spaceSeparatedSetTB = /(^|\\s)(\\d+-\\d+)\\s(\\d+)(\\s|$)/g;\n  for (const ssb of score.match(spaceSeparatedSetTB) || []) {\n    const [before, setScore, tb, after] = ssb\n      .match(/(^|\\s)(\\d+-\\d+)\\s(\\d+)(\\s|$)/)\n      .slice(1);\n    const [s1, s2] = setScore.split('-').map((s) => parseInt(s));\n    const diff = Math.abs(s1 - s2);\n    if (diff === 1) {\n      score = score.replace(ssb, `${before}${setScore}(${tb})${after}`);\n      applied.push('spaceSeparatedSetPattern');\n    }\n  }\n\n  const getFloaters = /\\d-\\d \\(\\d{1,2}\\)(\\s|$|,)/g;\n  for (const floater of score.match(getFloaters) || []) {\n    const getFloater = /(\\d-\\d) \\((\\d{1,2})\\)(\\s|$|,)/;\n    const [setScore, tb, tail] = floater.match(getFloater).slice(1);\n    const [s1, s2] = setScore.split('-').map((s) => parseInt(s));\n    const diff = Math.abs(s1 - s2);\n\n    if (diff === 1) {\n      score = score.replace(floater, `${setScore}(${tb})${tail}`);\n      applied.push('floatingTiebreakPattern2');\n    }\n  }\n\n  const getSpacedTibreakSets = /(^|\\s)(\\d \\d)\\(/g;\n  for (const spacedTB of score.match(getSpacedTibreakSets) || []) {\n    const getSpacedTibreakSet = /(^|\\s)(\\d \\d)\\(/;\n    const [before, spacedScore] = spacedTB.match(getSpacedTibreakSet).slice(1);\n    score = score.replace(\n      spacedTB,\n      `${before}${spacedScore.split(' ').join('-')}(`\n    );\n    applied.push('spacedTiebreakPattern');\n  }\n\n  return { score, applied };\n}\n","import { getSuper, isDiffOne } from './utilities';\nimport { isNumeric } from '../../utilities/math';\n\nexport function properTiebreak({ score, matchUpStatus }) {\n  let parts = score?.split(' ');\n  score = parts\n    .map((part) => {\n      if (part.endsWith(']')) {\n        const setScores = part.split('[');\n        if (isDiffOne(setScores[0])) {\n          return (\n            setScores[0] + `(${setScores[1].slice(0, setScores[1].length - 1)})`\n          );\n        }\n      }\n      return part;\n    })\n    .join(' ');\n\n  const tb = new RegExp(/(\\([\\d ]+\\))/g);\n  // const tb = new RegExp(/(\\([\\d+ ]+\\))/g);\n  if (tb.test(score)) {\n    // handle tiebreak score which has no delimiter\n    for (const t of score.match(tb)) {\n      const replacement = t.replace(' ', '-');\n      // score = score.replace(t, replacement);\n      let tiebreakScore = replacement.match(/\\((.*)\\)/)?.[1];\n      if (isNumeric(tiebreakScore) && tiebreakScore?.[0] > 2) {\n        if ([2, 4].includes(tiebreakScore.length)) {\n          tiebreakScore = tiebreakScore.split('').join('-');\n        } else if (tiebreakScore.length === 3) {\n          const oneIndex = tiebreakScore.indexOf('1');\n          tiebreakScore = getSuper(tiebreakScore.split(''), oneIndex);\n        }\n      }\n      score = score.replace(t, `(${tiebreakScore})`);\n    }\n  }\n\n  parts = score?.split(' ');\n  // handles tiebreaks (#-#) or (#/#)\n  let re = new RegExp(/^(\\d[-/]+\\d)\\((\\d+)[-/]+(\\d+)\\)$/);\n  const lastIndex = parts.length - 1;\n  score = parts\n    .map((part, index) => {\n      const considerCompleted =\n        [undefined, '', 'COMPLETED'].includes(matchUpStatus) ||\n        index !== lastIndex;\n      if (re.test(part) && considerCompleted) {\n        const [set, tb1, tb2] = Array.from(part.match(re)).slice(1) as number[];\n        const lowTiebreakScore = Math.min(tb1, tb2);\n        return `${set}(${lowTiebreakScore})`;\n      }\n      return part;\n    })\n    .join(' ');\n\n  // convert ##(#) => #-#(#)\n  parts = score?.split(' ');\n  re = new RegExp(/^(\\d{2})\\((\\d+)\\)$/);\n  score = parts\n    .map((part) => {\n      if (re.test(part)) {\n        const [set, lowTiebreakScore] = Array.from(part.match(re)).slice(\n          1\n        ) as string[];\n        const setScores = set.split('');\n        return `${setScores[0]}-${setScores[1]}(${lowTiebreakScore})`;\n      }\n      return part;\n    })\n    .join(' ');\n\n  // convert (#-#)# to #-#(#)\n  parts = score?.split(' ');\n  re = new RegExp(/^\\((\\d[-/]+\\d)\\)(\\d+)$/);\n  score = parts\n    .map((part) => {\n      if (re.test(part)) {\n        const [set, lowTiebreakScore] = Array.from(part.match(re)).slice(1);\n        if (isDiffOne(set)) {\n          return `${set}(${lowTiebreakScore})`;\n        } else {\n          // discard the number outside the bracket as erroneous\n          return set;\n        }\n      }\n      return part;\n    })\n    .join(' ');\n\n  // convert 1-0(#) to super tiebreak\n  parts = score?.split(' ');\n  re = new RegExp(/^1-0\\((\\d+)\\)$/);\n  score = parts\n    .map((part) => {\n      if (re.test(part)) {\n        const [lowTiebreakScore] = part.match(re).slice(1);\n        const hightiebreakScore =\n          lowTiebreakScore < 9 ? 10 : parseInt(lowTiebreakScore) + 2;\n        return `[${hightiebreakScore}-${lowTiebreakScore}]`;\n      }\n      return part;\n    })\n    .join(' ');\n\n  // (#0, => (#) // ')' mistyped as '0'\n  const misTyped0 = /\\((\\d)+0 /;\n  if (misTyped0.test(score)) {\n    const value = score.match(misTyped0)[1];\n    score = score.replace(misTyped0, `(${value}) `);\n  }\n\n  return { score };\n}\n","import { dashJoin, isDiffOne, isTiebreakScore } from './utilities';\nimport { dashMash } from './commonPatterns';\nimport { instanceCount } from '../../utilities/arrays';\nimport { isNumeric } from '../../utilities/math';\n\nexport function containedSets({ score, attributes, identifier }) {\n  if (typeof score !== 'string') return { score, identifier };\n\n  const withParens = new RegExp(/\\([\\d,/ ]+\\)/g);\n  const contained = score.match(withParens);\n  for (const container of contained || []) {\n    const matched = container.match(/^\\((.*)\\)$/);\n    const innards = matched?.slice(1)?.[0];\n\n    // don't split double digits if they follow digits with diff 1\n    const before = score.split(container)[0];\n    const priorDigits = before.split(')').reverse()[0].replace(/\\D/g, '');\n    if (innards?.length === 2 && priorDigits?.length >= 2) {\n      const priorTwo = priorDigits\n        .slice(priorDigits.length - 2)\n        .split('')\n        .map((d) => parseInt(d));\n      const diff = Math.abs(priorTwo[0] - priorTwo[1]);\n      if (diff === 1) continue;\n    }\n\n    const joined = dashJoin(innards);\n    const mashed = dashMash(joined);\n    score = score.replace(container, `(${mashed})`).trim();\n  }\n\n  const withBrackets = new RegExp(/\\[[\\d,/ ]+\\]/g);\n  const bracketed = score.match(withBrackets);\n  bracketed?.forEach((container) => {\n    const innards = dashJoin(container.match(/^\\[(.*)\\]$/)[1]);\n    score = score.replace(container, `(${innards}) `).trim();\n  });\n\n  const potentialEndings = [')', ']'];\n  const potentialMiddles = [')(', '), (', ') (', ')[', `) [`, '](', '] ('];\n  if (\n    score.startsWith('(') &&\n    potentialEndings.some((ending) => score.endsWith(ending)) &&\n    potentialMiddles.some((middle) => score.includes(middle))\n  ) {\n    let newScore = '';\n    const parts = score\n      .split(/[)\\]]/)\n      .filter(Boolean)\n      .map((part) => {\n        if (part.startsWith(',')) part = part.slice(1);\n        return part.trim();\n      });\n    const commadDelimited = parts.every(\n      (part) => part.includes(',') || isTiebreakScore(part)\n    );\n    const slashDelimited = parts.every(\n      (part) => part.includes('/') || isTiebreakScore(part)\n    );\n    const dashDelimited = parts.every(\n      (part) => part.includes('-') || isTiebreakScore(part)\n    );\n    const delimiter =\n      (commadDelimited && ',') ||\n      (dashDelimited && '-') ||\n      (slashDelimited && '/');\n\n    if (delimiter) {\n      let lastPart;\n      parts.forEach((part) => {\n        if (part.startsWith('(')) {\n          // is a set score\n          if (lastPart === 'set') newScore += ' ';\n\n          if (part.includes(delimiter)) {\n            newScore += part\n              .slice(1)\n              .split(delimiter)\n              .map((s) => s.trim())\n              .join('-');\n            lastPart = 'set';\n          } else {\n            const value = part.slice(1);\n            newScore += `(${value}) `;\n            lastPart = 'tiebreak';\n          }\n        } else if (part.startsWith('[')) {\n          const values = part\n            .slice(1)\n            .split(delimiter)\n            .map((s) => parseInt(s.trim()));\n          const highValue = Math.min(...values);\n          // is a tiebreak score\n          if (lastPart === 'set') {\n            newScore += `(${highValue}) `;\n          } else {\n            newScore += `[${values.join('-')}] `;\n          }\n          lastPart = 'tiebreak';\n        }\n      });\n\n      score = newScore.trim();\n    }\n  }\n\n  const counts = instanceCount(score.split(''));\n  if (\n    counts['('] === 1 &&\n    counts[')'] === 1 &&\n    score.startsWith('(') &&\n    score.endsWith(')')\n  ) {\n    score = score.slice(1, score.length - 1);\n\n    // is a tiebreakSet; check for valid removed tiebreak value\n    if (\n      counts['-'] === 1 &&\n      isDiffOne(score) &&\n      isNumeric(attributes?.removed)\n    ) {\n      score = score + `(${attributes.removed})`;\n      attributes.removed = undefined;\n    }\n  }\n\n  const emptyParens = /\\(\\)/g;\n  if (emptyParens.test(score)) {\n    score = score.replace(emptyParens, '').trim();\n  }\n\n  return { score };\n}\n","import { matchTiebreak, standardSet, tiebreakSet } from './validPatterns';\nimport { getWinningSide } from './getWinningSide';\nimport { dashMash } from './commonPatterns';\nimport { isDiffOne } from './utilities';\nimport { isNumeric } from '../../utilities/math';\n\nexport function sensibleSets({ score, matchUpStatus, attributes }) {\n  const profile: any[] = [];\n\n  let maxSetValue;\n  const sets = score.split(' ');\n  const setsCount = sets.length;\n\n  score = sets\n    .map((set, index) => {\n      if (new RegExp(tiebreakSet).test(set)) {\n        const tiebreak = set.slice(3);\n        const setScores = set.slice(0, 3);\n        const sideScores = setScores.split('-');\n\n        if (!isDiffOne(setScores) && !matchUpStatus) {\n          const maxSetScore = Math.max(...sideScores);\n          const maxIndex = setScores.indexOf(maxSetScore);\n          const sensibleSetScores = [maxSetScore, maxSetScore - 1];\n          if (maxIndex) sensibleSetScores.reverse();\n          const sensibleSetScore = sensibleSetScores.join('-');\n          return sensibleSetScore + tiebreak;\n        }\n      } else if (set.length === 2 && isNumeric(set)) {\n        return set.split('').join('-');\n      }\n\n      set = dashMash(set);\n\n      const setType =\n        (new RegExp(`^${matchTiebreak}$`).test(set) && 'super') ||\n        (new RegExp(`^${tiebreakSet}$`).test(set) && 'tiebreak') ||\n        (new RegExp(`^${standardSet}$`).test(set) && 'standard') ||\n        'unknown';\n      profile.push(setType);\n\n      // check for reasonable set scores in the first two sets\n      if (setsCount > 1 && setType === 'standard' && index < 2) {\n        const [s1, s2] = set.split('-');\n        const diff = Math.abs(parseInt(s1) - parseInt(s2));\n        const max = Math.max(s1, s2);\n        const min = Math.min(s1, s2);\n        const minIndex = [parseInt(s1), parseInt(s2)].indexOf(min);\n\n        // identify problematic score\n        // coerce larger value to something reasonable\n        if (max > 9 && diff > 2) {\n          const splitMax = max.toString().split('');\n          const reasonable =\n            splitMax.find(\n              (value) =>\n                parseInt(value) > min ||\n                (index && parseInt(value) <= maxSetValue)\n            ) ?? splitMax[0];\n\n          if (reasonable) {\n            set = minIndex\n              ? [reasonable, min].join('-')\n              : [min, reasonable].join('-');\n          }\n        }\n\n        if (max > (maxSetValue || 0)) maxSetValue = max;\n      }\n\n      // throw out any sets where the values are equal and there is no retirement\n      if (setType === 'standard') {\n        const [s1, s2] = set.split('-');\n        const diff = Math.abs(parseInt(s1) - parseInt(s2));\n        if (!diff && matchUpStatus !== 'RETIRED') {\n          return '';\n        }\n      }\n\n      return set;\n    })\n    .filter(Boolean)\n    .join(' ');\n\n  const { setsWon, setWinners, totalSets } = getWinningSide(score);\n\n  // if there was a 6 removed from the end of the score and there is only one set...\n  if (totalSets === 1 && attributes?.removed === '6') {\n    score += ' 6-0';\n  }\n\n  // if a side won the first two sets and there are more than 2 sets, trim the score\n  if (\n    score.split(' ').length > 2 &&\n    Math.max(...setsWon) >= 2 &&\n    setWinners[0] === setWinners[1]\n  ) {\n    score = score.split(' ').slice(0, 2).join(' ');\n  }\n\n  if (Math.max(...setsWon) > 2) {\n    const counts = [0, 0];\n    score = score\n      .split(' ')\n      .map((set, i) => {\n        counts[setWinners[i]] += 1;\n        return Math.max(...counts) > 2 ? undefined : set;\n      })\n      .filter(Boolean)\n      .join(' ');\n  }\n\n  return { score, profile };\n}\n","import { getWinningSide } from './getWinningSide';\nimport { isNumeric } from '../../utilities/math';\n\nexport function superSquare({ score }) {\n  const { setsTied, winningSide } = getWinningSide(score);\n\n  // when final set is (#) match tiebreak\n  const finalSetMatchTiebreak = /\\s\\((\\d+)\\)$/;\n  if (!winningSide && setsTied && finalSetMatchTiebreak.test(score)) {\n    const lowTiebreakScore = score.match(finalSetMatchTiebreak).slice(1)[0];\n    const highTiebreakScore = lowTiebreakScore <= 8 ? 10 : lowTiebreakScore + 2;\n    score = score.replace(\n      finalSetMatchTiebreak,\n      ` [${highTiebreakScore}-${lowTiebreakScore}]`\n    );\n  }\n\n  const sets = score.split(' ');\n  const finalSet = sets[sets.length - 1];\n  if (!finalSet.includes('-') || finalSet.indexOf('(') > 0) return { score };\n\n  let scores = finalSet.split('(').join('').split(')').join('').split('-');\n  if (!scores.every((score) => isNumeric(score))) return { score };\n  if (scores[0] === '76') {\n    const tb =\n      scores[1].length === 2\n        ? Math.min(...scores[1].split('').map((n) => parseInt(n)))\n        : scores[1];\n    score = [...sets.slice(0, sets.length - 1), `7-6(${tb})`].join(' ');\n  } else {\n    scores = scores.map((score) => parseInt(score));\n\n    const maxSetScore = Math.max(...scores);\n    let diff = Math.abs(scores[0] - scores[1]);\n\n    if (maxSetScore >= 10) {\n      // if both scores are greater than 10 and diff > 2 then attempt to modify\n      if (diff > 2 && scores.every((s) => +s >= 10)) {\n        const modifiedScores = scores\n          .map((s) => (s === maxSetScore ? s - 10 : 10))\n          .sort();\n        diff = Math.abs(modifiedScores[0] - modifiedScores[1]);\n        if (diff > 2) scores = modifiedScores;\n      }\n      score = [...sets.slice(0, sets.length - 1), `[${scores.join('-')}]`].join(\n        ' '\n      );\n    } else if (sets.length === 3 && maxSetScore >= 7 && diff > 2) {\n      score = [...sets.slice(0, sets.length - 1), `[${scores.join('-')}]`].join(\n        ' '\n      );\n    }\n  }\n\n  return { score };\n}\n","import { isValidPattern } from './validPatterns';\nimport { transforms } from './transforms';\nimport { INVALID_VALUES } from '../../constants/errorConditionConstants';\n\nlet transformations: { [key: string]: number } = {};\nlet invalid: any[] = [];\n\nconst processingOrder = [\n  'handleNumeric',\n  'handleWalkover',\n  'handleRetired',\n  'replaceOh',\n  'stringScore',\n  'punctuationAdjustments',\n  'excisions',\n  'handleSpaceSeparator',\n  'matchKnownPatterns',\n  'removeDanglingBits',\n  'handleBracketSpacing',\n  'matchKnownPatterns',\n  'containedSets',\n  'separateScoreBlocks',\n  'handleGameSeparation',\n  'removeErroneous',\n  'joinFloatingTiebreak',\n  'handleSetSlashSeparation',\n  'handleTiebreakSlashSeparation',\n  'properTiebreak',\n  'sensibleSets',\n  'superSquare',\n];\n\n// secondPass is used to process only numbers which have been extracted from strings\nconst secondPass = [\n  'handleNumeric',\n  'separateScoreBlocks',\n  'sensibleSets',\n  'superSquare',\n];\n\nexport function getInvalid() {\n  return invalid;\n}\nexport function dumpInvalid() {\n  invalid = [];\n}\n\nexport function getTransformations() {\n  return transformations;\n}\nexport function resetTransformations() {\n  transformations = {};\n}\n\nexport function tidyScore(params) {\n  if (!params.score) return { error: INVALID_VALUES };\n  const {\n    score: incomingScore,\n    sheetName,\n    identifier,\n    fileName,\n    stepLog,\n    fullLog,\n    profile,\n  } = params;\n\n  const modifications: any[] = [];\n  let matchUpStatus,\n    applied = [],\n    attributes,\n    result;\n\n  let score = incomingScore;\n\n  const doProcess = (methods) => {\n    methods.forEach((method) => {\n      result = transforms[method]({\n        profile, // config object compatible with provider profiles\n        identifier, // optional identifier (used in test harness)\n        matchUpStatus,\n        attributes,\n        applied,\n        score,\n      });\n      const modified = result.score !== score;\n      if (modified) {\n        modifications.push({ method, score: result.score });\n      }\n\n      if (\n        stepLog &&\n        (fullLog || modified || result.matchUpStatus !== matchUpStatus)\n      ) {\n        if (matchUpStatus) {\n          console.log({ score: result.score, matchUpStatus }, method);\n        } else {\n          console.log({ score: result.score }, method);\n        }\n      }\n\n      if (result.matchUpStatus) matchUpStatus = result.matchUpStatus;\n      if (result.attributes) attributes = result.attributes;\n      if (result.applied) applied = result.applied;\n      score = result.score;\n    });\n  };\n\n  doProcess(processingOrder);\n\n  let isValid = isValidPattern(score);\n  if (!isValid) {\n    // Hail Mary: extract only the numbers from the string\n    score = incomingScore.toString().replace(/\\D/g, '');\n    if (attributes?.removed) {\n      attributes.removed = undefined;\n    }\n    doProcess(secondPass);\n\n    isValid = isValidPattern(score);\n    if (!isValid) {\n      invalid.push({ score, fileName, sheetName });\n      score = '';\n    }\n  }\n\n  applied.forEach((application) => {\n    if (!transformations[application]) {\n      transformations[application] = 0;\n    }\n    transformations[application] += 1;\n  });\n\n  return {\n    matchUpStatus: matchUpStatus?.toUpperCase(),\n    modifications,\n    attributes,\n    isValid,\n    score,\n  };\n}\n","import { MISSING_VALUE } from '../../../constants/errorConditionConstants';\n\nexport function getWinningSide({ analysis, set }) {\n  const leadingSide = getLeadingSide({ set });\n  const { isDecidingSet, isTiebreakSet, matchUpScoringFormat } = analysis;\n  const setIsComplete = checkSetIsComplete({\n    matchUpScoringFormat,\n    isDecidingSet,\n    isTiebreakSet,\n    set,\n  });\n  return setIsComplete && leadingSide;\n}\n\nexport function checkSetIsComplete(params) {\n  let matchUpScoringFormat = params.matchUpScoringFormat;\n  const {\n    ignoreTiebreak = false,\n    matchUpFormat,\n    isTiebreakSet,\n    isDecidingSet,\n    set,\n  } = params;\n  if (!set) return { error: MISSING_VALUE };\n\n  matchUpScoringFormat = matchUpScoringFormat || matchUpFormat;\n\n  const setFormat =\n    (isDecidingSet && matchUpScoringFormat.finalSetFormat) ||\n    matchUpScoringFormat?.setFormat ||\n    {};\n  const { side1Score, side2Score } = set;\n\n  const { NoAD, setTo, tiebreakAt, tiebreakFormat } = setFormat;\n  const tiebreakNoAd = tiebreakFormat?.NoAd;\n\n  const leadingSide = getLeadingSide({ set });\n  const scoreDiff = Math.abs(side1Score - side2Score);\n  const containsSetTo = side1Score >= setTo || side2Score >= setTo;\n\n  const requiresTiebreak =\n    isTiebreakSet ||\n    (side1Score >= setTo && side2Score >= setTo) ||\n    (tiebreakAt &&\n      tiebreakAt < setTo &&\n      (side1Score === tiebreakAt || side2Score === tiebreakAt));\n\n  const tiebreakIsValid =\n    ignoreTiebreak ||\n    (requiresTiebreak &&\n      ((leadingSide === 1 && set.side1TiebreakScore > set.side2TiebreakScore) ||\n        (leadingSide === 2 &&\n          set.side2TiebreakScore > set.side1TiebreakScore)));\n\n  const winMargin =\n    NoAD ||\n    (requiresTiebreak &&\n      ((tiebreakAt && !isTiebreakSet) || (isTiebreakSet && tiebreakNoAd)))\n      ? 1\n      : 2;\n  const hasWinMargin = scoreDiff >= winMargin;\n  const validNormalSetScore =\n    containsSetTo && (hasWinMargin || requiresTiebreak);\n\n  return (\n    (validNormalSetScore || isTiebreakSet) &&\n    (!requiresTiebreak || tiebreakIsValid)\n  );\n}\n\nexport function getLeadingSide({ set }) {\n  if (set.side1Score || set.side2Score) {\n    if (set.side1Score > set.side2Score) return 1;\n    if (set.side2Score > set.side1Score) return 2;\n  } else if (set.side1TiebreakScore || set.side2TiebreakScore) {\n    if (set.side1TiebreakScore > set.side2TiebreakScore) return 1;\n    if (set.side2TiebreakScore > set.side1TiebreakScore) return 2;\n  }\n  return undefined;\n}\n","export const SPACE_CHARACTER = ' ';\n\nexport const OUTCOME_DEFAULT = 'DEF';\nexport const OUTCOME_COMPLETE = 'COMPLETED';\nexport const OUTCOME_WALKOVER = 'WO';\nexport const OUTCOME_DOUBLE_WALKOVER = 'WO/WO';\nexport const OUTCOME_ABANDONED = 'ABN';\nexport const OUTCOME_SUSPENDED = 'SUS';\nexport const OUTCOME_RETIREMENT = 'RET';\nexport const OUTCOME_INTERRUPTED = 'INT';\nexport const OUTCOMES = [\n  OUTCOME_RETIREMENT,\n  OUTCOME_DEFAULT,\n  OUTCOME_WALKOVER,\n  OUTCOME_DOUBLE_WALKOVER,\n  OUTCOME_ABANDONED,\n  OUTCOME_SUSPENDED,\n  OUTCOME_INTERRUPTED,\n];\n\nexport const WINNING_OUTCOMES = [\n  OUTCOME_RETIREMENT,\n  OUTCOME_DEFAULT,\n  OUTCOME_WALKOVER,\n];\n\nexport const STATUS_DEFAULT = 'DEFAULTED';\nexport const STATUS_COMPLETE = 'COMPLETED';\nexport const STATUS_WALKOVER = 'WALKOVER';\nexport const STATUS_DOUBLE_DEFAULT = 'DOUBLE_DEFAULT';\nexport const STATUS_DOUBLE_WALKOVER = 'DOUBLE_WALKOVER';\nexport const STATUS_ABANDONED = 'ABANDONED';\nexport const STATUS_SUSPENDED = 'SUSPENDED';\nexport const STATUS_RETIREMENT = 'RETIRED';\nexport const STATUS_INTERRUPTED = 'INTERRUPTED';\nexport const STATUSES = [\n  STATUS_RETIREMENT,\n  STATUS_DEFAULT,\n  STATUS_WALKOVER,\n  STATUS_DOUBLE_DEFAULT,\n  STATUS_DOUBLE_WALKOVER,\n  STATUS_ABANDONED,\n  STATUS_SUSPENDED,\n  STATUS_INTERRUPTED,\n];\n\nexport const WINNING_STATUSES = [\n  STATUS_RETIREMENT,\n  STATUS_DEFAULT,\n  STATUS_WALKOVER,\n];\n\nexport const PROMPT = 'Enter Score';\nexport const SET_TIEBREAK_BRACKETS = '()';\nexport const MATCH_TIEBREAK_BRACKETS = '[]';\n\nexport const MOVEUP = ['up', 'left', 'shift+tab'];\nexport const MOVEDOWN = ['enter', 'down', 'tab', 'right'];\n\nexport const BACKSPACE = 'backspace';\nexport const RETIRE = 'r';\nexport const SUSPEND = 's';\nexport const ABANDON = 'a';\nexport const DEFAULT = 'd';\nexport const WALKOVER = 'w';\nexport const INTERRUPT = 'i';\nexport const OUTCOMEKEYS = [\n  RETIRE,\n  DEFAULT,\n  WALKOVER,\n  ABANDON,\n  SUSPEND,\n  INTERRUPT,\n];\n\nexport const SPACE_KEY = 'space';\nexport const OPENERS = ['[', '('];\nexport const CLOSERS = [...MOVEUP, ...MOVEDOWN, SPACE_KEY, ']'];\n\nexport const DASH = '-';\nexport const FORWARD_SLASH = '/';\n\nexport const SCORE_JOINER = DASH;\nexport const MATCH_TIEBREAK_JOINER = DASH;\nexport const ALTERNATE_JOINERS = [FORWARD_SLASH];\n\nexport const ZERO = 0;\nexport const TEST = ['=', '+', 'num_1', 'num_2', 'shift+=', 'shift+-'];\nexport const SIDE1KEYS = [\n  '0',\n  '1',\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n].concat(OUTCOMEKEYS);\nexport const SIDE2KEYS = SIDE1KEYS.map((key) => `shift+${key}`);\nexport const MODIFIERS = [SCORE_JOINER, BACKSPACE].concat(\n  CLOSERS,\n  ALTERNATE_JOINERS\n);\nexport const VALID_VALUE_KEYS = [SIDE1KEYS, SIDE2KEYS, MODIFIERS].join(',');\nexport const HOTKEYS = [VALID_VALUE_KEYS, MOVEUP, MOVEDOWN, TEST].join(',');\n\n// for testing purposes; side keys overrepresented\nexport const SCORE_TEST_KEYS = [].concat(\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  ...SIDE1KEYS,\n  ...SIDE1KEYS,\n  ...MODIFIERS,\n  ...SIDE1KEYS,\n  ...SIDE1KEYS,\n  ...SIDE1KEYS,\n  ...SIDE1KEYS,\n  ...SIDE1KEYS,\n  ...SIDE1KEYS\n);\n\nexport const keyValueConstants = {\n  OUTCOMEKEYS,\n  SIDE1KEYS,\n  SIDE2KEYS,\n  MODIFIERS,\n  PROMPT,\n  MOVEUP,\n  MOVEDOWN,\n  HOTKEYS,\n};\n","import { arrayIndices } from '../../../utilities/arrays';\nimport { parse } from '../../../assemblies/generators/matchUpFormatCode/parse';\n\nimport {\n  SET_TIEBREAK_BRACKETS,\n  MATCH_TIEBREAK_BRACKETS,\n  OUTCOMES,\n  MATCH_TIEBREAK_JOINER,\n  SPACE_CHARACTER,\n  WINNING_STATUSES,\n} from './constants';\n\nexport function addOutcome({ scoreString, lowSide, outcome }) {\n  ({ scoreString } = removeOutcome({ scoreString }));\n\n  if (lowSide === 2) {\n    const lastScoreCharacter =\n      scoreString && scoreString[scoreString.length - 1];\n    const spacer =\n      lastScoreCharacter !== SPACE_CHARACTER ? SPACE_CHARACTER : '';\n    return scoreString + spacer + outcome;\n  } else {\n    return outcome + SPACE_CHARACTER + scoreString;\n  }\n}\n\nfunction removeOutcome({ scoreString }) {\n  if (!scoreString) return { scoreString: '' };\n\n  let removed = false;\n\n  for (const outcome of OUTCOMES) {\n    const index = scoreString?.indexOf(outcome);\n    if (index === 0) {\n      scoreString =\n        scoreString.slice(outcome.length + 1).trim() + SPACE_CHARACTER;\n    } else if (index > 0) {\n      scoreString = scoreString.slice(0, index);\n    }\n    if (index >= 0) removed = true;\n  }\n\n  if (!scoreString?.trim()) scoreString = '';\n\n  return { scoreString, removed };\n}\ntype RemoveFromScoreArgs = {\n  scoreString: string;\n  lowSide?: number;\n  analysis: any;\n  sets: any[];\n};\nexport function removeFromScore({\n  analysis,\n  scoreString,\n  sets,\n  lowSide,\n}: RemoveFromScoreArgs): {\n  outcomeRemoved?: boolean;\n  scoreString?: string;\n  sets?: any[];\n} {\n  let newScore, newSets;\n  if (!scoreString) return { scoreString, sets };\n\n  const { scoreString: outcomeRemoved, removed } = removeOutcome({\n    scoreString,\n  });\n  scoreString = outcomeRemoved;\n  if (removed) return { scoreString, sets, outcomeRemoved: true };\n\n  let lastSet = sets[sets.length - 1] || {};\n  // Looking for the last set which has some values defined\n  // setValues Count determines if there are any values other than setNumber\n  const setValuesCount = Object.values(lastSet).filter(\n    (f) => f !== undefined\n  ).length;\n  if (lastSet.setNumber && setValuesCount === 1) {\n    sets = sets.slice(0, sets.length - 1);\n    lastSet = sets[sets.length - 1] || {};\n  }\n  const { tiebreakSet } = analysis.setFormat;\n  const { tiebreakTo, NoAD } = tiebreakSet || {};\n\n  const { isTiebreakEntry: isMatchTiebreak } = testTiebreakEntry({\n    brackets: MATCH_TIEBREAK_BRACKETS,\n    scoreString,\n  });\n\n  const index = lastNumericIndex(scoreString);\n  if (index >= 0) {\n    newScore = scoreString.slice(0, index);\n    const { isTiebreakEntry: openSetTiebreak } = testTiebreakEntry({\n      brackets: SET_TIEBREAK_BRACKETS,\n      scoreString: newScore,\n    });\n    const {\n      lastOpenBracketIndex: lastMatchTiebreakOpenBracketIndex,\n      isTiebreakEntry: openMatchTiebreak,\n    } = testTiebreakEntry({\n      brackets: MATCH_TIEBREAK_BRACKETS,\n      scoreString: newScore,\n    });\n    const lastNewScoreChar = newScore && newScore[newScore.length - 1].trim();\n    const remainingNumbers = newScore && !isNaN(lastNewScoreChar);\n    let isIncompleteScore = analysis.isIncompleteSetScore;\n\n    if (isMatchTiebreak && openMatchTiebreak) {\n      const matchTiebreakScoreString = newScore.slice(\n        lastMatchTiebreakOpenBracketIndex + 1\n      );\n      const splitScoreString = matchTiebreakScoreString.split(\n        MATCH_TIEBREAK_JOINER\n      );\n      const side1TiebreakScore =\n        (splitScoreString?.length > 0 &&\n          splitScoreString[0] !== undefined &&\n          !isNaN(parseInt(splitScoreString[0])) &&\n          parseInt(splitScoreString[0])) ||\n        undefined;\n      const side2TiebreakScore =\n        (splitScoreString?.length > 1 &&\n          splitScoreString[1] !== undefined &&\n          parseInt(splitScoreString[1])) ||\n        undefined;\n      const matchTiebreakScores = [side1TiebreakScore, side2TiebreakScore];\n\n      if (side2TiebreakScore) {\n        const highIndex = lowSide === 1 ? 1 : 0;\n\n        matchTiebreakScores[highIndex] =\n          (matchTiebreakScores?.[1 - highIndex] || 0) + (NoAD ? 1 : 2);\n        if ((matchTiebreakScores[highIndex] || 0) < tiebreakTo)\n          matchTiebreakScores[highIndex] = tiebreakTo;\n\n        newScore = scoreString.slice(0, lastMatchTiebreakOpenBracketIndex + 1);\n        newScore += matchTiebreakScores.join(MATCH_TIEBREAK_JOINER);\n      } else if (side1TiebreakScore !== undefined) {\n        newScore = scoreString.slice(0, lastMatchTiebreakOpenBracketIndex + 1);\n        newScore += side1TiebreakScore;\n      } else {\n        newScore = scoreString.slice(0, lastMatchTiebreakOpenBracketIndex);\n        isIncompleteScore = true;\n      }\n\n      lastSet.side1TiebreakScore = matchTiebreakScores[0] || 0;\n      lastSet.side2TiebreakScore = matchTiebreakScores[1] || 0;\n    }\n\n    if (!newScore.length) newScore = undefined;\n    if (isIncompleteScore) {\n      const side1Score = lastSet.side1Score?.toString();\n      if (side1Score) {\n        const newSide1Score = side1Score?.slice(0, side1Score.length - 1);\n        lastSet.side1Score =\n          (!isNaN(newSide1Score) && parseInt(newSide1Score)) || undefined;\n        if (lastSet.side1Score === undefined) lastSet.side2Score = undefined;\n      }\n      if (analysis.isTimedSet) {\n        newSets = lastSet.side1Score\n          ? sets\n          : sets?.slice(0, sets.length - 1) || [];\n        newSets[sets.length - 1] = lastSet;\n      } else {\n        newSets = sets?.slice(0, sets.length - 1) || [];\n      }\n    } else if (remainingNumbers) {\n      const side2Score = lastSet.side2Score?.toString();\n      const side1Score = lastSet.side1Score?.toString();\n      if (!analysis.isTiebreakEntry && !analysis.isMatchTiebreak) {\n        if (lastSet.side2Score) {\n          const newSide2Score = side2Score?.slice(0, side2Score.length - 1);\n          lastSet.side2Score =\n            (!isNaN(newSide2Score) && parseInt(newSide2Score)) || undefined;\n        } else {\n          const newSide1Score = side1Score?.slice(0, side1Score.length - 1);\n          lastSet.side1Score =\n            (!isNaN(newSide1Score) && parseInt(newSide1Score)) || undefined;\n        }\n      }\n      if (analysis.isTimedSet) {\n        if (lastSet.side1Score) {\n          newSets = sets || [];\n          newSets[sets.length - 1] = lastSet;\n        } else {\n          newSets = sets?.slice(0, sets.length - 1) || [];\n        }\n      } else {\n        newSets = sets || [];\n        newSets[sets.length - 1] = lastSet;\n      }\n\n      if (newSets[newSets.length - 1]) {\n        Object.assign(newSets[newSets.length - 1], { winningSide: undefined });\n      }\n    } else if (openSetTiebreak) {\n      newSets = sets || [];\n      Object.assign(newSets[newSets.length - 1] || {}, {\n        winningSide: undefined,\n        side1TiebreakScore: undefined,\n        side2TiebreakScore: undefined,\n      });\n    } else {\n      if (isMatchTiebreak && !openMatchTiebreak) {\n        newSets = sets?.slice(0, sets.length - 1) || [];\n      } else {\n        newSets = sets;\n        newSets[sets.length - 1] = lastSet;\n      }\n      if (!isMatchTiebreak) {\n        newSets[newSets.length - 1].side2Score = 0;\n        newSets[newSets.length - 1].winningSide = undefined;\n      }\n    }\n\n    return { scoreString: newScore, sets: newSets };\n  }\n\n  return { scoreString, sets };\n}\n\nexport function testTiebreakEntry({\n  brackets = SET_TIEBREAK_BRACKETS,\n  scoreString,\n}) {\n  if (!scoreString) return {};\n  const [open, close] = brackets.split('');\n  const splitScore = scoreString.split('');\n  const lastOpenBracketIndex = Math.max(...arrayIndices(open, splitScore));\n  const lastCloseBracketIndex = Math.max(...arrayIndices(close, splitScore));\n  const isTiebreakEntry = lastOpenBracketIndex > lastCloseBracketIndex;\n  return { isTiebreakEntry, lastOpenBracketIndex };\n}\n\nexport function checkValidMatchTiebreak({ scoreString }) {\n  if (!scoreString) return false;\n  const lastScoreChar =\n    scoreString && scoreString[scoreString.length - 1].trim();\n  const isNumericEnding = scoreString && !isNaN(lastScoreChar);\n\n  const [open, close] = MATCH_TIEBREAK_BRACKETS.split('');\n  const splitScore = scoreString.split('');\n  const lastOpenBracketIndex = Math.max(...arrayIndices(open, splitScore));\n  const lastCloseBracketIndex = Math.max(...arrayIndices(close, splitScore));\n  const lastJoinerIndex = Math.max(\n    ...arrayIndices(MATCH_TIEBREAK_JOINER, splitScore)\n  );\n  return (\n    isNumericEnding &&\n    lastOpenBracketIndex > lastCloseBracketIndex &&\n    lastJoinerIndex > lastOpenBracketIndex\n  );\n}\n\nexport function lastNumericIndex(str) {\n  const arr = str.split('');\n  const arrayIndices = arr.reduce((a, e, i) => {\n    if (e.match(/\\d+/g)) a.push(i);\n    return a;\n  }, []);\n  return arrayIndices.pop();\n}\n\nexport function getHighTiebreakValue(params?) {\n  const { lowValue = 0, NoAD = false, tiebreakTo } = params || {};\n  const winBy = NoAD ? 1 : 2;\n  if (lowValue + 1 >= tiebreakTo) {\n    return lowValue + winBy;\n  }\n  return parseInt(tiebreakTo);\n}\n\nexport function getMatchUpWinner({\n  matchUpFormat,\n  matchUpStatus,\n  winningSide,\n  sets,\n}) {\n  const matchUpScoringFormat: any = parse(matchUpFormat);\n  const { bestOf } = matchUpScoringFormat;\n  const scoreGoal = Math.ceil(bestOf / 2);\n  const sideScores = sets?.reduce(\n    (scores, set) => {\n      const { winningSide } = set;\n      if (winningSide) scores[winningSide - 1]++;\n      return scores;\n    },\n    [0, 0]\n  );\n\n  let matchUpWinningSide = sideScores?.indexOf(scoreGoal) + 1 || undefined;\n  if (WINNING_STATUSES.includes(matchUpStatus) && winningSide) {\n    matchUpWinningSide = winningSide;\n  }\n  return { matchUpWinningSide };\n}\n","import { addOutcome } from './keyValueUtilities';\n\nimport {\n  OUTCOME_DEFAULT,\n  OUTCOME_RETIREMENT,\n  OUTCOME_WALKOVER,\n  STATUS_DEFAULT,\n  STATUS_RETIREMENT,\n  STATUS_WALKOVER,\n  STATUS_ABANDONED,\n  STATUS_INTERRUPTED,\n  STATUS_SUSPENDED,\n  RETIRE,\n  DEFAULT,\n  WALKOVER,\n  ABANDON,\n  INTERRUPT,\n  SUSPEND,\n  OUTCOME_ABANDONED,\n  OUTCOME_INTERRUPTED,\n  OUTCOME_SUSPENDED,\n} from './constants';\n\nexport function processOutcome({\n  lowSide,\n  value,\n  sets,\n  scoreString,\n  winningSide,\n  matchUpStatus,\n}) {\n  let updated;\n\n  if (value === RETIRE) {\n    if (scoreString) {\n      updated = true;\n      scoreString = addOutcome({\n        scoreString,\n        lowSide,\n        outcome: OUTCOME_RETIREMENT,\n      });\n      winningSide = lowSide === 2 ? 1 : 2;\n      matchUpStatus = STATUS_RETIREMENT;\n    } else {\n      updated = true;\n      scoreString = addOutcome({\n        scoreString,\n        lowSide,\n        outcome: OUTCOME_DEFAULT,\n      });\n      winningSide = lowSide === 2 ? 1 : 2;\n      matchUpStatus = STATUS_DEFAULT;\n    }\n  } else if (value === DEFAULT) {\n    updated = true;\n    scoreString = addOutcome({\n      scoreString,\n      lowSide,\n      outcome: OUTCOME_DEFAULT,\n    });\n    winningSide = lowSide === 2 ? 1 : 2;\n    matchUpStatus = STATUS_DEFAULT;\n  } else if (value === WALKOVER) {\n    updated = true;\n    sets = [];\n    scoreString = OUTCOME_WALKOVER;\n    winningSide = lowSide === 2 ? 1 : 2;\n    matchUpStatus = STATUS_WALKOVER;\n  } else if (value === SUSPEND && scoreString) {\n    updated = true;\n    scoreString = addOutcome({\n      scoreString,\n      lowSide,\n      outcome: OUTCOME_SUSPENDED,\n    });\n    matchUpStatus = STATUS_SUSPENDED;\n    winningSide = undefined;\n  } else if (value === ABANDON) {\n    updated = true;\n    scoreString = addOutcome({\n      scoreString,\n      lowSide,\n      outcome: OUTCOME_ABANDONED,\n    });\n    matchUpStatus = STATUS_ABANDONED;\n    winningSide = undefined;\n  } else if (value === INTERRUPT && scoreString) {\n    updated = true;\n    scoreString = addOutcome({\n      scoreString,\n      lowSide,\n      outcome: OUTCOME_INTERRUPTED,\n    });\n    matchUpStatus = STATUS_INTERRUPTED;\n    winningSide = undefined;\n  }\n\n  return { updated, sets, scoreString, matchUpStatus, winningSide };\n}\n","import { arrayIndices } from '../../../utilities/arrays';\nimport { parse } from '../../../assemblies/generators/matchUpFormatCode/parse';\nimport {\n  checkValidMatchTiebreak,\n  testTiebreakEntry,\n} from './keyValueUtilities';\n\nimport {\n  SCORE_JOINER,\n  MATCH_TIEBREAK_JOINER,\n  OPENERS,\n  CLOSERS,\n  OUTCOMES,\n  SPACE_KEY,\n  SET_TIEBREAK_BRACKETS,\n  MATCH_TIEBREAK_BRACKETS,\n} from './constants';\n\nexport function getScoreAnalysis({\n  matchUpFormat,\n  scoreString,\n  winningSide,\n  value,\n  sets,\n}) {\n  const completedSets = sets?.filter((set) => set?.winningSide)?.length || 0;\n  const setNumber = completedSets + (winningSide ? 0 : 1);\n\n  const matchUpScoringFormat: any = parse(matchUpFormat);\n  const isDecidingSet = setNumber === matchUpScoringFormat?.bestOf;\n  const setFormat =\n    (isDecidingSet && matchUpScoringFormat?.finalSetFormat) ||\n    matchUpScoringFormat?.setFormat ||\n    {};\n  const isTimedSet = setFormat?.timed;\n\n  const finalSet = isDecidingSet && sets[matchUpScoringFormat?.bestOf - 1];\n  const finalSetIsComplete = finalSet?.winningSide;\n\n  const { isTiebreakEntry: isSetTiebreakEntry } = testTiebreakEntry({\n    brackets: SET_TIEBREAK_BRACKETS,\n    scoreString,\n  });\n  const { isTiebreakEntry: isMatchTiebreakEntry } = testTiebreakEntry({\n    brackets: MATCH_TIEBREAK_BRACKETS,\n    scoreString,\n  });\n  const isTiebreakEntry = isSetTiebreakEntry || isMatchTiebreakEntry;\n\n  const isTiebreakSet = !!setFormat.tiebreakSet;\n  const lastScoreChar = scoreString?.[scoreString.length - 1]?.trim();\n  const isNumericEnding = scoreString && !isNaN(lastScoreChar);\n\n  const isIncompleteSetScore =\n    !isTiebreakEntry && lastScoreChar === SCORE_JOINER;\n  const isIncompleteSetTiebreak =\n    isSetTiebreakEntry && OPENERS.includes(lastScoreChar);\n  const isIncompleteMatchTiebreak =\n    isMatchTiebreakEntry && OPENERS.includes(lastScoreChar);\n  const isPartialMatchTiebreakValue =\n    isMatchTiebreakEntry && lastScoreChar === MATCH_TIEBREAK_JOINER;\n\n  const splitScore = scoreString?.split('');\n  const [open] = MATCH_TIEBREAK_BRACKETS.split('');\n  const lastOpenBracketIndex =\n    splitScore && Math.max(...arrayIndices(open, splitScore));\n  const lastJoinerIndex =\n    splitScore && Math.max(...arrayIndices(MATCH_TIEBREAK_JOINER, splitScore));\n  const matchTiebreakHasJoiner =\n    splitScore && lastJoinerIndex > lastOpenBracketIndex;\n\n  const lastSetIsComplete = sets[sets.length - 1]?.winningSide;\n  const isGameScoreEntry = sets?.length && !lastSetIsComplete;\n\n  const hasOutcome = OUTCOMES.find(\n    (outcome) => scoreString?.indexOf(outcome) >= 0\n  );\n\n  const isNumericValue = !isNaN(value);\n\n  const isSpace = value === SPACE_KEY;\n  const isCloser = CLOSERS.includes(value);\n  const hasOpener = scoreString\n    ?.split('')\n    .find((char) => OPENERS.includes(char));\n\n  const isInvalidMatchTiebreakValue =\n    isCloser &&\n    isMatchTiebreakEntry &&\n    !isIncompleteMatchTiebreak &&\n    (isPartialMatchTiebreakValue || !checkValidMatchTiebreak({ scoreString }));\n\n  const isInvalidSetTiebreakValue =\n    isSpace && isTiebreakEntry && isIncompleteSetTiebreak;\n  const isTiebreakCloser =\n    isCloser && hasOpener && isTiebreakEntry && isNumericEnding;\n  const isTiebreakSetValue = isTiebreakSet && isNumericValue;\n\n  return {\n    isTiebreakSetValue,\n    matchUpScoringFormat,\n    setNumber,\n    setFormat,\n    matchTiebreakHasJoiner,\n    isGameScoreEntry,\n    isSpace,\n    isCloser,\n    isTiebreakCloser,\n    isDecidingSet,\n    isTiebreakSet,\n    isTimedSet,\n    isNumericEnding,\n    isNumericValue,\n    hasOpener,\n    hasOutcome,\n    finalSet,\n    finalSetIsComplete,\n    lastSetIsComplete,\n    isInvalidSetTiebreakValue,\n    isInvalidMatchTiebreakValue,\n    isTiebreakEntry,\n    isSetTiebreakEntry,\n    isMatchTiebreakEntry,\n\n    isIncompleteSetScore,\n    isIncompleteSetTiebreak,\n    isIncompleteMatchTiebreak,\n    isPartialMatchTiebreakValue,\n  };\n}\n","import { findExtension } from '../../../../acquire/findExtension';\n\nimport { MATCHUP_HISTORY } from '../../../../constants/extensionConstants';\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport {\n  ErrorType,\n  NOT_FOUND,\n} from '../../../../constants/errorConditionConstants';\n\nexport function getHistory({ matchUp }): {\n  undoHistory?: any[];\n  success?: boolean;\n  error?: ErrorType;\n  history?: any[];\n} {\n  const { extension } = findExtension({\n    name: MATCHUP_HISTORY,\n    element: matchUp,\n  });\n  if (!extension) return { error: NOT_FOUND };\n\n  const { history = [], undoHistory = [] } = extension.value;\n\n  return { history, undoHistory, ...SUCCESS };\n}\n","import { addExtension } from '../../../extensions/addExtension';\n\nimport { MATCHUP_HISTORY } from '../../../../constants/extensionConstants';\nimport { MatchUp } from '../../../../types/tournamentTypes';\n\ntype SaveHistoryArgs = {\n  undoHistory?: any[];\n  matchUp: MatchUp;\n  history?: any[];\n};\nexport function saveHistory({\n  undoHistory,\n  history,\n  matchUp,\n}: SaveHistoryArgs) {\n  const extension = {\n    value: { history, undoHistory },\n    name: MATCHUP_HISTORY,\n  };\n  return addExtension({ element: matchUp, extension });\n}\n","export const umo = {\n  scoreboard: () => {},\n  addPoints: () => {},\n  addPoint: () => {},\n};\n","import { generateTieMatchUpScore } from '../../generators/tieMatchUpScore/generateTieMatchUpScore';\nimport { generateScoreString } from '../../generators/matchUps/generateScoreString';\nimport { tidyScore } from '../../../analyze/scoreParser/scoreParser';\nimport { reverseScore } from '../../generators/score/reverseScore';\n\nimport { isValidMatchUpFormat } from '../../../validators/isValidMatchUpFormat';\nimport { validateTieFormat } from '../../../validators/validateTieFormat';\nimport { validateScore } from '../../../validators/validateScore';\n\nimport { checkScoreHasValue } from '../../../query/matchUp/checkScoreHasValue';\nimport { analyzeSet } from '../../../query/matchUp/analyzeSet';\n\nimport { updateTieMatchUpScore } from '../../../mutate/matchUps/score/tieMatchUpScore';\n\nimport {\n  checkSetIsComplete,\n  keyValueScore,\n} from '../../../mutate/score/keyValueScore';\nimport {\n  getSetComplement,\n  getTiebreakComplement,\n} from '../../../query/matchUp/getComplement';\n\n// history\nimport { calculateHistoryScore } from '../../../mutate/matchUps/score/history/calculateHistoryScore';\nimport { setServingSide } from '../../../mutate/matchUps/score/history/setServingSide';\nimport { clearHistory } from '../../../mutate/matchUps/score/history/clearHistory';\nimport { addPoint } from '../../../mutate/matchUps/score/history/addPoint';\nimport { addGame } from '../../../mutate/matchUps/score/history/addGame';\nimport { addShot } from '../../../mutate/matchUps/score/history/addShot';\nimport { addSet } from '../../../mutate/matchUps/score/history/addSet';\nimport { redo } from '../../../mutate/matchUps/score/history/redo';\nimport { undo } from '../../../mutate/matchUps/score/history/undo';\nimport { umo } from '../../../mutate/matchUps/score/history/umo';\n\n// renamed\nimport { stringify } from '../../generators/matchUpFormatCode/stringify';\nimport { parse } from '../../generators/matchUpFormatCode/parse';\n\nexport const scoreGovernor = {\n  analyzeSet,\n  checkScoreHasValue,\n  checkSetIsComplete,\n  generateScoreString,\n  generateTieMatchUpScore,\n  getSetComplement,\n  getTiebreakComplement,\n  isValidMatchUpFormat,\n  keyValueScore,\n  parseMatchUpFormat: parse,\n  reverseScore,\n  stringifyMatchUpFormat: stringify,\n  tidyScore,\n  updateTieMatchUpScore,\n  validateScore,\n  validateTieFormat,\n\n  calculateHistoryScore,\n  setServingSide,\n  clearHistory,\n  addPoint,\n  addGame,\n  addShot,\n  addSet,\n  redo,\n  undo,\n  umo,\n};\n\nexport default scoreGovernor;\n","import { processIncompleteSetScore } from './processIncompleteSetScore';\nimport { keyValueTimedSetScore } from './keyValueTimedSetScore';\nimport { getWinningSide, getLeadingSide } from './winningSide';\nimport { arrayIndices } from '../../../utilities/arrays';\nimport { ensureInt } from '../../../utilities/ensureInt';\nimport { processTiebreakSet } from './processTiebreakSet';\nimport { keyValueSetScore } from './keyValueSetScore';\nimport { getScoreAnalysis } from './scoreAnalysis';\nimport { processOutcome } from './processOutcome';\nimport {\n  getMatchUpWinner,\n  removeFromScore,\n  getHighTiebreakValue,\n} from './keyValueUtilities';\n\nimport {\n  INCOMPLETE,\n  TO_BE_PLAYED,\n} from '../../../constants/matchUpStatusConstants';\nimport {\n  SET_TIEBREAK_BRACKETS,\n  MATCH_TIEBREAK_BRACKETS,\n  SPACE_CHARACTER,\n  BACKSPACE,\n  OUTCOMEKEYS,\n  OUTCOME_COMPLETE,\n  VALID_VALUE_KEYS,\n  SCORE_JOINER,\n  MATCH_TIEBREAK_JOINER,\n  ALTERNATE_JOINERS,\n  ZERO,\n  CLOSERS,\n  SPACE_KEY,\n  STATUS_SUSPENDED,\n  STATUS_INTERRUPTED,\n  STATUS_ABANDONED,\n} from './constants';\n\nexport function keyValueMatchUpScore(params) {\n  const { auto, checkFormat, shiftFirst, lowSide, value, matchUp } = params;\n  const { score, winningSide, matchUpStatus, matchUpFormat } = matchUp;\n  const scoreString = matchUp.scoreString || score?.scoreStringSide1;\n  const sets = matchUp.sets || score?.sets;\n  const result = keyValueScore({\n    scoreString,\n    sets,\n    winningSide,\n    matchUpStatus,\n    matchUpFormat,\n    lowSide,\n    value,\n    shiftFirst,\n    auto,\n    checkFormat,\n  });\n\n  let updatedMatchUp;\n  if (result?.updated) {\n    const { sets, scoreString, winningSide, matchUpStatus } = result;\n    updatedMatchUp = {\n      ...matchUp,\n      sets, // required for present test suites\n      scoreString, // required for present test suites\n      winningSide,\n      matchUpStatus,\n      // TODO: this should use the autocomplete function of matchUpScore\n      // and the expected behavior is therefore different than keyValueScore\n      score: { sets, scoreStringSide1: scoreString },\n    };\n  }\n  return {\n    updated: result.updated,\n    info: result.info,\n    matchUp: updatedMatchUp || matchUp,\n  };\n}\n\n/* shiftFirst indicates that SHIFT key refers to first opponent, rather than second */\nexport function keyValueScore(params) {\n  let { lowSide = 1, value } = params;\n  let { scoreString, sets, winningSide, matchUpStatus } = params;\n  const { matchUpFormat, shiftFirst, auto = true } = params;\n\n  let updated, info;\n  const isShifted =\n    (shiftFirst && lowSide === 2) || (!shiftFirst && lowSide === 1);\n\n  if (!VALID_VALUE_KEYS.includes(value)) {\n    return { updated: false, info: 'invalid key' };\n  }\n\n  if (shiftFirst) lowSide = 3 - lowSide;\n\n  const { matchUpWinningSide } = getMatchUpWinner({\n    sets,\n    winningSide,\n    matchUpStatus,\n    matchUpFormat,\n  });\n  winningSide = matchUpWinningSide;\n\n  const analysis = getScoreAnalysis({\n    value,\n    winningSide,\n    scoreString,\n    sets,\n    matchUpFormat,\n  });\n\n  if (ALTERNATE_JOINERS.includes(value)) value = SCORE_JOINER;\n  if (\n    analysis.hasOpener &&\n    analysis.isTiebreakEntry &&\n    !analysis.isTiebreakSet &&\n    isShifted &&\n    ensureInt(value) === 0\n  ) {\n    analysis.isTiebreakCloser = true;\n  }\n\n  if (CLOSERS.includes(value) && analysis.hasOpener) {\n    value = '';\n  }\n\n  if (CLOSERS.includes(value)) {\n    // TODO: not sure this is necessary\n    value = SPACE_KEY;\n  }\n\n  if (analysis.lastSetIsComplete) {\n    const finalCharacter =\n      scoreString?.length && scoreString[scoreString.length - 1];\n    if (scoreString && finalCharacter !== ' ') {\n      scoreString += ' ';\n    }\n  }\n\n  if (analysis.isTimedSet) {\n    ({ info, sets, scoreString, updated, matchUpStatus, winningSide } =\n      keyValueTimedSetScore({\n        analysis,\n        lowSide,\n        scoreString,\n        sets,\n        matchUpStatus,\n        winningSide,\n        value,\n      }));\n  } else if (OUTCOMEKEYS.includes(value)) {\n    if (analysis.finalSetIsComplete || winningSide) {\n      info = 'final set is already complete';\n    } else if (!analysis.isTiebreakEntry && !analysis.isIncompleteSetScore) {\n      ({ sets, scoreString, matchUpStatus, winningSide, updated } =\n        processOutcome({\n          lowSide,\n          sets,\n          scoreString,\n          matchUpStatus,\n          winningSide,\n          value,\n        }));\n    } else if (analysis.isTiebreakEntry || analysis.isIncompleteSetScore) {\n      info = 'incomplete set scoreString or tiebreak entry';\n    } else {\n      console.log('handle case', { value });\n    }\n  } else if (value === BACKSPACE) {\n    updated = true;\n    ({ scoreString, sets } = removeFromScore({\n      analysis,\n      scoreString,\n      sets,\n      lowSide,\n    }));\n    if (!scoreString) sets = [];\n    matchUpStatus = undefined;\n    winningSide = undefined;\n  } else if (analysis.hasOutcome) {\n    info = 'has outcome';\n  } else if (value === SCORE_JOINER && !analysis.isMatchTiebreakEntry) {\n    if (\n      !analysis.isSetTiebreakEntry ||\n      (analysis.isSetTiebreakEntry && !analysis.isNumericEnding)\n    ) {\n      updated = true;\n      ({ scoreString, sets } = removeFromScore({\n        analysis,\n        scoreString,\n        sets,\n        lowSide,\n      }));\n      matchUpStatus = undefined;\n    }\n  } else if (\n    value === MATCH_TIEBREAK_JOINER &&\n    analysis.isMatchTiebreakEntry &&\n    !analysis.isSetTiebreakEntry\n  ) {\n    if (analysis.matchTiebreakHasJoiner) {\n      info = 'existing joiner';\n    } else if (analysis.isNumericEnding) {\n      updated = true;\n      scoreString += MATCH_TIEBREAK_JOINER;\n    }\n  } else if ([SCORE_JOINER, MATCH_TIEBREAK_JOINER].includes(value)) {\n    info = 'invalid location for joiner';\n  } else if (winningSide) {\n    return { updated: false, info: 'matchUp is complete' };\n  } else if (analysis.isIncompleteSetScore) {\n    if (analysis.isNumericValue) {\n      ({ sets, scoreString, updated } = processIncompleteSetScore({\n        analysis,\n        scoreString,\n        sets,\n        value,\n      }));\n    }\n  } else if (analysis.isInvalidMatchTiebreakValue) {\n    info = 'invalid matchUp tiebreak character';\n  } else if (analysis.isInvalidSetTiebreakValue) {\n    info = 'invalid set tiebreak character';\n  } else if (analysis.isTiebreakCloser) {\n    const brackets = analysis.isSetTiebreakEntry\n      ? SET_TIEBREAK_BRACKETS\n      : MATCH_TIEBREAK_BRACKETS;\n    const close = brackets.split('').reverse()[0];\n    const open = brackets.split('')[0];\n    const set = sets[sets.length - 1];\n\n    const { tiebreakFormat } = analysis.setFormat;\n    const { tiebreakTo, NoAD } = tiebreakFormat || {};\n    const leadingSide = getLeadingSide({ set });\n\n    if (!analysis.isTiebreakSet) {\n      const lowTiebreakScore = parseInt(scoreString.split(open).reverse()[0]);\n      const highTiebreakScore = getHighTiebreakValue({\n        lowValue: lowTiebreakScore,\n        tiebreakTo,\n        NoAD,\n      });\n      if (leadingSide === 1) {\n        set.side1TiebreakScore = highTiebreakScore;\n        set.side2TiebreakScore = lowTiebreakScore;\n      } else {\n        set.side1TiebreakScore = lowTiebreakScore;\n        set.side2TiebreakScore = highTiebreakScore;\n      }\n    }\n\n    scoreString = (scoreString || '') + close;\n    if (!analysis.isDecidingSet) scoreString += SPACE_CHARACTER;\n\n    const winningSide = getWinningSide({ analysis, set });\n    set.winningSide = winningSide || undefined;\n\n    updated = true;\n  } else if (analysis.isTiebreakSetValue) {\n    ({ info, scoreString, sets, updated } = processTiebreakSet({\n      analysis,\n      auto,\n      lowSide,\n      scoreString,\n      sets,\n      value,\n    }));\n  } else if (analysis.isSetTiebreakEntry) {\n    const [open] = SET_TIEBREAK_BRACKETS.split('');\n    const lastOpenBracketIndex = Math.max(\n      ...arrayIndices(open, scoreString.split(''))\n    );\n    const tiebreakValue = scoreString.slice(lastOpenBracketIndex + 1);\n    const hasZeroStart = tiebreakValue && ensureInt(tiebreakValue) === ZERO;\n    const newTiebreakValue = ensureInt(\n      tiebreakValue ? tiebreakValue + value : value\n    );\n\n    const { tiebreakFormat } = analysis.setFormat;\n    const { tiebreakTo, NoAD } = tiebreakFormat || {};\n\n    if (!hasZeroStart && tiebreakValue.length < 2) {\n      if (NoAD && newTiebreakValue > tiebreakTo - 1) {\n        info = 'invalid low value for NoAD tiebreak';\n      } else {\n        updated = true;\n        scoreString = (scoreString || '') + value;\n      }\n    } else {\n      info = hasZeroStart\n        ? 'tiebreak begins with zero'\n        : 'tiebreak digit limit';\n    }\n  } else if (analysis.isCloser) {\n    info = `invalid key: ${value}`;\n  } else if (analysis.isGameScoreEntry) {\n    info = 'game scoreString entry';\n  } else {\n    if (analysis.lastSetIsComplete || !sets.length) {\n      updated = true;\n      const { scoreString: newScore, set } = keyValueSetScore({\n        analysis,\n        lowSide,\n        scoreString,\n        value: ensureInt(value),\n      });\n      if (set) set.setNumber = sets?.length + 1 || 1;\n      sets = sets?.concat(set).filter(Boolean) || [set];\n      scoreString = newScore || undefined;\n    } else {\n      console.log('error: unknown outcome');\n    }\n  }\n\n  if (updated) {\n    sets = sets?.filter(Boolean);\n    const { matchUpWinningSide } = getMatchUpWinner({\n      sets,\n      winningSide,\n      matchUpStatus,\n      matchUpFormat,\n    });\n    winningSide = matchUpWinningSide;\n    if (\n      matchUpWinningSide &&\n      (!matchUpStatus || [TO_BE_PLAYED, INCOMPLETE].includes(matchUpStatus))\n    ) {\n      matchUpStatus = OUTCOME_COMPLETE;\n      sets = sets.filter((set) => {\n        const {\n          side1Score,\n          side2Score,\n          side1TiebreakScore,\n          side2TiebreakScore,\n        } = set;\n        return (\n          side1Score || side2Score || side1TiebreakScore || side2TiebreakScore\n        );\n      });\n    } else if (\n      scoreString &&\n      !winningSide &&\n      ![STATUS_SUSPENDED, STATUS_ABANDONED, STATUS_INTERRUPTED].includes(\n        matchUpStatus\n      )\n    ) {\n      matchUpStatus = undefined;\n    }\n    return { updated, scoreString, sets, winningSide, matchUpStatus, info };\n  }\n\n  return { updated, scoreString, sets, winningSide, matchUpStatus, info };\n}\n","import { ensureInt } from '../../../utilities/ensureInt';\nimport { removeFromScore } from './keyValueUtilities';\nimport { processOutcome } from './processOutcome';\n\nimport { BACKSPACE, OUTCOMEKEYS, SCORE_JOINER, SPACE_KEY } from './constants';\n\nexport function keyValueTimedSetScore(params) {\n  let { sets, info, scoreString, winningSide, matchUpStatus } = params;\n  const { analysis, lowSide, value } = params;\n  let updated, outcomeRemoved;\n  if (!sets?.length && value !== BACKSPACE) sets = [{ setNumber: 1 }];\n  const setIndex = sets.length - 1;\n\n  if (OUTCOMEKEYS.includes(value)) {\n    const lastSet = sets[sets.length - 1] || {};\n    const { side1Score, side2Score } = lastSet;\n    if (side1Score && !side2Score) {\n      info = 'missing side2Score';\n    } else if (analysis.finalSetIsComplete || winningSide) {\n      info = 'final set is already complete';\n    } else if (analysis.isIncompleteSetScore) {\n      info = 'incomplete set scoreString';\n    } else if (!analysis.isIncompleteSetScore) {\n      ({ sets, scoreString, winningSide, matchUpStatus, updated } =\n        processOutcome({\n          lowSide,\n          value,\n          sets,\n          scoreString,\n          matchUpStatus,\n          winningSide,\n        }));\n    }\n  } else if (value === BACKSPACE) {\n    ({ scoreString, sets, outcomeRemoved } = removeFromScore({\n      analysis,\n      scoreString,\n      sets,\n    }));\n    if (scoreString?.trim() === '') {\n      scoreString = scoreString.trim();\n    }\n    if (!scoreString) sets = [];\n\n    if (outcomeRemoved) {\n      const lastSet = sets[sets.length - 1] || {};\n      const { side1Score, side2Score } = lastSet;\n      if (side1Score && side2Score) {\n        const winningSide =\n          (side1Score > side2Score && 1) ||\n          (side2Score > side1Score && 2) ||\n          undefined;\n        if (winningSide) {\n          lastSet.winningSide = winningSide;\n          sets.push({ setNumber: sets.length + 1 });\n        }\n      }\n    }\n    matchUpStatus = undefined;\n    winningSide = undefined;\n    updated = true;\n  } else if (analysis.hasOutcome) {\n    info = 'has outcome';\n  } else if (winningSide) {\n    return {\n      sets,\n      scoreString,\n      winningSide,\n      matchUpStatus,\n      updated: false,\n      info: 'matchUp is complete',\n    };\n\n    // SPACE_KEY indicates moving on to next set\n  } else if (value === SPACE_KEY) {\n    const lastSet = sets[sets.length - 1] || {};\n    const { side1Score, side2Score } = lastSet;\n    const setWinningSide =\n      (side1Score > side2Score && 1) ||\n      (side2Score > side1Score && 2) ||\n      undefined;\n\n    if (setWinningSide && !winningSide && !analysis.isIncompleteSetScore) {\n      sets[sets.length - 1].winningSide = setWinningSide;\n      sets.push({ setNumber: sets.length + 1 });\n      scoreString += ' ';\n      updated = true;\n    }\n\n    // SCORE_JOINGER is only valid if side1Score exists and side2Score doesn't exist\n  } else if (\n    value === SCORE_JOINER &&\n    sets[setIndex].side1Score !== undefined &&\n    sets[setIndex].side2Score === undefined &&\n    scoreString &&\n    analysis.isNumericEnding\n  ) {\n    scoreString += '-';\n    sets[setIndex].side2Score = 0;\n\n    matchUpStatus = undefined;\n    winningSide = undefined;\n    updated = true;\n  } else if (!isNaN(value)) {\n    let currentSetScore;\n\n    if (sets[setIndex].side2Score === undefined) {\n      const newValue = ensureInt(\n        (sets[setIndex].side1Score || 0).toString() + value\n      )\n        .toString()\n        .slice(0, 2);\n      sets[setIndex].side1Score = ensureInt(newValue);\n      currentSetScore = sets[setIndex].side1Score.toString();\n      updated = true;\n    } else {\n      const newValue = ensureInt(\n        (sets[setIndex].side2Score || 0).toString() + value\n      )\n        .toString()\n        .slice(0, 2);\n      sets[setIndex].side2Score = ensureInt(newValue);\n      currentSetScore = [\n        sets[setIndex].side1Score,\n        sets[setIndex].side2Score,\n      ].join('-');\n      updated = true;\n    }\n    if (updated) {\n      const priorSetScores = (sets.slice(0, setIndex) || [])\n        .filter((set) => set)\n        .map((set) => {\n          const { side1Score, side2Score } = set;\n          return [side1Score, side2Score].join('-');\n        })\n        .join(' ');\n      if (priorSetScores) {\n        scoreString = priorSetScores + ' ' + currentSetScore;\n      } else {\n        scoreString = currentSetScore;\n      }\n    }\n  }\n\n  return { sets, scoreString, winningSide, matchUpStatus, info, updated };\n}\n","import { ensureInt } from '../../../utilities/ensureInt';\nimport { getWinningSide } from './winningSide';\n\nimport { SPACE_CHARACTER, SET_TIEBREAK_BRACKETS } from './constants';\n\nexport function processIncompleteSetScore({\n  analysis,\n  scoreString,\n  sets,\n  value,\n}) {\n  let updated;\n\n  if (!sets?.length) return { sets: [] };\n\n  const set = sets[sets.length - 1];\n  value = ensureInt(value);\n  const { validSide2Score, requiresTiebreak } = checkValidSide2Score({\n    analysis,\n    set,\n    value,\n  });\n\n  if (validSide2Score) {\n    updated = true;\n    scoreString = (scoreString || '') + value;\n    set.side2Score = value;\n\n    const winningSide = getWinningSide({\n      analysis,\n      set: sets[sets.length - 1],\n    });\n    set.winningSide = winningSide || undefined;\n\n    if (requiresTiebreak) {\n      const open = SET_TIEBREAK_BRACKETS.split('')[0];\n      scoreString += open;\n    } else if (!analysis.isDecidingSet) {\n      scoreString += SPACE_CHARACTER;\n    }\n  }\n\n  return { sets, scoreString, updated };\n}\n\ntype CheckValidSide2ScoreArgs = {\n  analysis: any;\n  value: any;\n  set: any;\n};\nfunction checkValidSide2Score({\n  analysis,\n  set = {},\n  value,\n}: CheckValidSide2ScoreArgs) {\n  const setFormat =\n    (analysis.isDecidingSet && analysis.matchUpScoringFormat.finalSetFormat) ||\n    analysis.matchUpScoringFormat.setFormat;\n  const { tiebreakAt, setTo, NoAD } = setFormat;\n  const { side1Score } = set;\n\n  let validSide2Score, requiresTiebreak;\n\n  if (tiebreakAt && tiebreakAt < setTo) {\n    if (side1Score === tiebreakAt) {\n      validSide2Score = value <= setTo;\n    } else {\n      validSide2Score = value <= tiebreakAt;\n    }\n  } else if (side1Score === setTo) {\n    if (NoAD) {\n      validSide2Score = value < setTo;\n    } else {\n      validSide2Score = value <= setTo + 1;\n    }\n  } else if (side1Score === setTo - 1) {\n    if (NoAD) {\n      validSide2Score = value <= setTo;\n    } else {\n      validSide2Score = value <= setTo + 1;\n    }\n  } else if (side1Score === setTo + 1) {\n    validSide2Score = value === setTo || value === setTo - 1;\n  } else {\n    validSide2Score = value <= setTo;\n  }\n\n  if (validSide2Score) {\n    if (tiebreakAt && tiebreakAt < setTo) {\n      requiresTiebreak =\n        (side1Score === setTo && value === tiebreakAt) ||\n        (side1Score === tiebreakAt && value === setTo);\n    } else {\n      requiresTiebreak =\n        side1Score >= setTo && value >= setTo && side1Score !== value;\n    }\n  }\n\n  return { validSide2Score, requiresTiebreak };\n}\n","import { getHighTiebreakValue, testTiebreakEntry } from './keyValueUtilities';\nimport { ensureInt } from '../../../utilities/ensureInt';\n\nimport { MATCH_TIEBREAK_BRACKETS, MATCH_TIEBREAK_JOINER } from './constants';\n\nexport function processTiebreakSet({\n  analysis,\n  auto,\n  lowSide,\n  scoreString = '',\n  sets,\n  value,\n}) {\n  let updated, info;\n  const {\n    tiebreakSet: { tiebreakTo, NoAD },\n  } = analysis.setFormat;\n\n  const [open] = MATCH_TIEBREAK_BRACKETS.split('');\n  if (!analysis.isMatchTiebreakEntry) {\n    scoreString += open;\n  }\n\n  const tiebreakSet = sets[analysis.setNumber - 1];\n  if (!tiebreakSet) {\n    const highValue = getHighTiebreakValue({\n      lowValue: ensureInt(value || 0),\n      tiebreakTo,\n      NoAD,\n    });\n    const setScores = [ensureInt(value), highValue];\n    if (lowSide === 2) setScores.reverse();\n    const set = {\n      side1TiebreakScore: setScores[0],\n      side2TiebreakScore: setScores[1],\n      setNumber: sets?.length + 1 || 1,\n    };\n    sets.push(set);\n    scoreString += setScores.join(MATCH_TIEBREAK_JOINER);\n    updated = true;\n  } else {\n    // if not auto-calculating high scores add new value at the end of string\n    const { lastOpenBracketIndex } = testTiebreakEntry({\n      brackets: MATCH_TIEBREAK_BRACKETS,\n      scoreString,\n    });\n    const matchTiebreakScoreString =\n      scoreString.slice((lastOpenBracketIndex ?? 0) + 1) + (auto ? '' : value);\n    const matchTiebreakScores = matchTiebreakScoreString.split(\n      MATCH_TIEBREAK_JOINER\n    );\n    const lowSideLength = matchTiebreakScores[lowSide - 1]?.length || 0;\n\n    if (lowSideLength >= 2) {\n      // don't allow tiebreak scores to have more than two digits\n      info = 'tiebreak digit limit';\n    } else if (auto) {\n      if (lowSide === 1)\n        matchTiebreakScores[0] = (matchTiebreakScores[0] || '') + value;\n      if (lowSide === 2)\n        matchTiebreakScores[1] = (matchTiebreakScores[1] || '') + value;\n      const setScores = [\n        matchTiebreakScores[0] || 0,\n        matchTiebreakScores[1] || 0,\n      ].map((s) => ensureInt(s));\n      const highIndex = lowSide === 1 ? 1 : 0;\n      setScores[highIndex] = setScores[1 - highIndex] + (NoAD ? 1 : 2);\n      if (setScores[highIndex] < tiebreakTo) setScores[highIndex] = tiebreakTo;\n\n      const lastSet = sets[sets.length - 1];\n      lastSet.side1TiebreakScore = setScores[0];\n      lastSet.side2TiebreakScore = setScores[1];\n\n      scoreString = scoreString.slice(0, (lastOpenBracketIndex ?? 0) + 1);\n      scoreString += setScores.join(MATCH_TIEBREAK_JOINER);\n      updated = true;\n    } else {\n      const setScores = [\n        matchTiebreakScores[0] || 0,\n        matchTiebreakScores[1] || 0,\n      ].map((s) => ensureInt(s));\n\n      const lastSet = sets[sets.length - 1];\n      lastSet.side1TiebreakScore = setScores[0];\n      lastSet.side2TiebreakScore = setScores[1];\n\n      scoreString += value;\n      updated = true;\n    }\n  }\n\n  return { info, scoreString, sets, updated };\n}\n","import { getWinningSide } from './winningSide';\n\nimport {\n  SPACE_CHARACTER,\n  SET_TIEBREAK_BRACKETS,\n  SCORE_JOINER,\n} from './constants';\n\nexport function keyValueSetScore({ analysis, lowSide, scoreString, value }) {\n  const { setTo, tiebreakAt, NoAD } = analysis?.setFormat || {};\n  const needsTiebreak = value === parseInt(tiebreakAt || setTo);\n\n  if (tiebreakAt && tiebreakAt < setTo && value > tiebreakAt)\n    return { scoreString };\n  if ((NoAD && value === setTo) || value > setTo) return { scoreString };\n\n  const highValue = getHighSetValue();\n  const setScores = [value, highValue];\n  if (lowSide === 2) setScores.reverse();\n\n  const brackets = SET_TIEBREAK_BRACKETS;\n  const open = brackets.split('')[0];\n  const addition =\n    setScores.join(SCORE_JOINER) + (needsTiebreak ? open : SPACE_CHARACTER);\n  scoreString = (scoreString || '') + addition;\n\n  const set: any = {\n    side1Score: setScores[0],\n    side2Score: setScores[1],\n  };\n  const winningSide = getWinningSide({ analysis, set });\n  set.winningSide = winningSide || undefined;\n\n  return { scoreString, set };\n\n  function getHighSetValue() {\n    if (needsTiebreak) return value + 1;\n    if (value + 1 === setTo) {\n      return value + (NoAD ? 1 : 2);\n    }\n    return setTo;\n  }\n}\n","import { generateScoreString } from '../matchUps/generateScoreString';\nimport { definedAttributes } from '../../../utilities/definedAttributes';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  ErrorType,\n  MISSING_VALUE,\n} from '../../../constants/errorConditionConstants';\n\nexport function reverseScore(params?): {\n  reversedScore?: any;\n  success?: boolean;\n  error?: ErrorType;\n} {\n  if (!params?.score) return { error: MISSING_VALUE };\n  const { sets } = params.score;\n  const reversedSets = sets.map((set) => {\n    const {\n      side1TiebreakScore,\n      side2TiebreakScore,\n      winningSide,\n      side1Score,\n      side2Score,\n      setNumber,\n    } = set;\n    return definedAttributes({\n      winningSide: winningSide ? 3 - winningSide : undefined,\n      side1TiebreakScore: side2TiebreakScore,\n      side2TiebreakScore: side1TiebreakScore,\n      side1Score: side2Score,\n      side2Score: side1Score,\n      setNumber,\n    });\n  });\n  const scoreStringSide1 = generateScoreString({ sets: reversedSets });\n  const scoreStringSide2 = generateScoreString({\n    sets: reversedSets,\n    reversed: true,\n  });\n\n  return {\n    reversedScore: { sets: reversedSets, scoreStringSide1, scoreStringSide2 },\n    ...SUCCESS,\n  };\n}\n","import { generateScoreString } from '../../../../assemblies/generators/matchUps/generateScoreString';\nimport { isConvertableInteger } from '../../../../utilities/math';\nimport { isValidMatchUpFormat } from '../../../../validators/isValidMatchUpFormat';\nimport { parse } from '../../../../assemblies/generators/matchUpFormatCode/parse';\nimport { getHistory } from './getHistory';\n\nimport { SUCCESS } from '../../../../constants/resultConstants';\nimport {\n  INVALID_MATCHUP_FORMAT,\n  INVALID_VALUES,\n  MISSING_MATCHUP,\n  MISSING_MATCHUP_FORMAT,\n  MISSING_VALUE,\n} from '../../../../constants/errorConditionConstants';\n\nexport function calculateHistoryScore(params) {\n  if (!params) return { error: MISSING_VALUE };\n  const { matchUp, updateScore } = params;\n  if (!matchUp) return { error: MISSING_MATCHUP };\n\n  const history = getHistory({ matchUp })?.history || [];\n\n  if (!Array.isArray(history))\n    return { error: INVALID_VALUES, info: 'history is not an array' };\n\n  const { matchUpFormat } = matchUp;\n  if (!matchUpFormat) return { error: MISSING_MATCHUP_FORMAT };\n  if (!isValidMatchUpFormat({ matchUpFormat }))\n    return { error: INVALID_MATCHUP_FORMAT };\n\n  const parsedFormat: any = parse(matchUpFormat);\n  const { bestOf, finalSetFormat, setFormat } = parsedFormat;\n\n  const pointProgression = ['0', '15', '30', '40', 'A', 'G'];\n  //  const statsCounters = { 1: {}, 2: {} };\n  const score: any = { sets: [] };\n\n  let unknowns: any[] = [];\n  let tiebreakServingSide;\n  let sidePoints = [0, 0];\n  let servingSide = 1;\n  let setNumber = 0;\n  let isFinalSet;\n  let faults = 0;\n\n  const isValidSide = (value) => [1, 2].includes(value);\n\n  const newSet = () => {\n    setNumber += 1;\n    return {\n      winningSide: undefined,\n      side1Score: 0,\n      side2Score: 0,\n      setNumber,\n      games: [],\n    };\n  };\n\n  const newGame = () => {\n    return {\n      winningSide: undefined,\n      points: [],\n    };\n  };\n\n  const newPoint = () => {\n    return {\n      winningSide: undefined,\n      side1Score: '',\n      side2Score: '',\n      shots: [],\n    };\n  };\n\n  let point: any = newPoint();\n  let game: any = newGame();\n  let set: any = newSet();\n\n  let processedCount = 0;\n  for (const item of history) {\n    processedCount += 1;\n\n    isFinalSet = score.sets.length + 1 === bestOf;\n    const format = isFinalSet && finalSetFormat ? finalSetFormat : setFormat;\n    const { tiebreakAt, setTo, NoAD, tiebbreakFormat } = format;\n\n    const isTiebreak =\n      set.side1Score === tiebreakAt && set.side1Score === set.side2Score;\n    const isTiebreakSet = !!format.tiebreakSet;\n    const tiebreakDetails = isTiebreakSet\n      ? format.tiebreakSet\n      : tiebbreakFormat;\n    const { tiebreakTo, NoAD: tiebreakNoAD } = tiebreakDetails || {};\n\n    const cleanup = () => {\n      tiebreakServingSide = undefined;\n      sidePoints = [0, 0];\n      servingSide = 3 - servingSide;\n      set.side1TiebreakScore = 0;\n      set.side2TiebreakScore = 0;\n      set.side1PointScore = '';\n      set.side2PointScore = '';\n      faults = 0;\n    };\n    const completeSet = (winningSide) => {\n      set.winningSide = winningSide;\n\n      const { s, ...rest } = set;\n      if (s) {\n        // strip out shorthand\n      }\n\n      score.sets.push(rest);\n      point = newPoint();\n      game = newGame();\n      set = newSet();\n      cleanup();\n    };\n\n    const completeGame = (winningSide) => {\n      game.winningSide = winningSide;\n\n      const { g, ...rest } = game;\n      if (g) {\n        // strip out shorthand\n      }\n\n      set.games.push(rest);\n      point = newPoint();\n      game = newGame();\n      cleanup();\n\n      const winningScoreSide = `side${winningSide}Score`;\n      set[winningScoreSide] += 1;\n    };\n\n    const completePoint = (winningSide) => {\n      point.winningSide = winningSide;\n\n      const { p, ...rest } = point;\n      if (p) {\n        // strip out shorthand\n      }\n\n      game.points.push(rest);\n      point = newPoint();\n      faults = 0;\n\n      const getTiebreakServingSide = () => {\n        const pointsCount = sidePoints.reduce((a, b) => a + b);\n        const value = (pointsCount % 4) / 4;\n        return value > 0.5 ? servingSide : 3 - servingSide;\n      };\n\n      const winningIndex = winningSide - 1;\n      if (isTiebreak || isTiebreakSet) {\n        sidePoints[winningIndex] += 1;\n        tiebreakServingSide = getTiebreakServingSide();\n        set[`side${winningSide}TiebreakScore`] = sidePoints[winningIndex];\n        set[`side${3 - winningSide}TiebreakScore`] =\n          sidePoints[1 - winningIndex];\n\n        const winBy = tiebreakNoAD ? 1 : 2;\n        if (\n          sidePoints[winningIndex] >= tiebreakTo &&\n          sidePoints[winningIndex] >= sidePoints[1 - winningIndex] + winBy\n        ) {\n          completeGame(winningSide);\n          return { gameCompleted: true };\n        }\n      } else {\n        if (\n          sidePoints[1 - winningIndex] === 4 &&\n          sidePoints[winningIndex] === 3\n        ) {\n          // return to deuce\n          sidePoints[1 - winningIndex] -= 1;\n        } else {\n          sidePoints[winningIndex] += 1;\n        }\n\n        set.side1PointScore = pointProgression[sidePoints[0]];\n        set.side2PointScore = pointProgression[sidePoints[1]];\n\n        if (\n          sidePoints[winningIndex] === 5 ||\n          (sidePoints[winningIndex] === 4 &&\n            sidePoints[1 - winningIndex] < 3) ||\n          (NoAD && sidePoints[winningIndex] === 4)\n        ) {\n          completeGame(winningSide);\n          return { gameCompleted: true };\n        }\n      }\n      return undefined;\n    };\n\n    if (isValidSide(item.srv)) {\n      servingSide = item.srv;\n    }\n\n    if (['p', 's', 'g', 'o'].includes(item.u)) {\n      unknowns.push(item.u);\n    }\n\n    if (item.shotOutcome) {\n      point.shots.push(item);\n\n      const isServe = item.shotType === 'SERVE';\n\n      if (isServe && ['OUT', 'NET'].includes(item.shotOutcome)) faults += 1;\n\n      if (faults === 2) {\n        const winningSide = 3 - servingSide;\n        completePoint(winningSide);\n      }\n    }\n    if (isValidSide(item.p) || isConvertableInteger(item.pointNumber)) {\n      const winningSide = item.winningSide || item.p;\n      const result = completePoint(winningSide);\n      if (result?.gameCompleted) continue;\n    }\n\n    if (isValidSide(item.g) || isConvertableInteger(item.gameNumber)) {\n      const winningSide = item.winningSide || item.g;\n      game.winningSide = winningSide;\n      const winningScoreSide = `side${winningSide}Score`;\n      const losingScoreSide = `side${3 - winningSide}Score`;\n\n      if (unknowns.length) {\n        if (unknowns.includes('p')) {\n          // resolve any unknown points where possible\n        }\n        unknowns = [];\n      }\n\n      completeGame(winningSide);\n\n      const setIsComplete =\n        set[winningScoreSide] === setTo &&\n        set[winningScoreSide] - set[losingScoreSide] >= (NoAD ? 1 : 2);\n\n      if (setIsComplete) {\n        completeSet(winningSide);\n        if (isFinalSet) break;\n      }\n    }\n    if (isValidSide(item.s) || isConvertableInteger(item.setNumber)) {\n      const winningSide = item.winningSide || item.s;\n      completeSet(winningSide);\n\n      if (unknowns.length) {\n        if (unknowns.includes('p')) {\n          // resolve any unknown points where possible\n          // only possible to resolve unknown points if the winner of the game in which the points occur would win the set by winning the game\n        }\n        if (unknowns.includes('g')) {\n          // resolve any unknown games where possible\n        }\n        unknowns = [];\n      }\n\n      // check if match is complete\n      if (isFinalSet) break;\n    }\n  }\n\n  if (processedCount !== history.length) {\n    console.log({ error: 'Match completed with excess history' });\n  }\n\n  if (\n    set.side1Score ||\n    set.side2Score ||\n    set.games.length ||\n    set.side1TiebreakScore ||\n    set.side2TiebreakScore\n  ) {\n    score.sets.push(set);\n  }\n\n  score.scoreStringSide1 = generateScoreString({ ...score, matchUpFormat });\n  score.scoreStringSide2 = generateScoreString({\n    ...score,\n    matchUpFormat,\n    reversed: true,\n  });\n\n  servingSide = tiebreakServingSide || servingSide;\n\n  if (updateScore) matchUp.score = score;\n\n  return { ...SUCCESS, servingSide, score };\n}\n","import { saveHistory } from './saveHistory';\nimport { getHistory } from './getHistory';\n\nimport { INVALID_SIDE_NUMBER } from '../../../../constants/errorConditionConstants';\n\nexport function setServingSide({ matchUp, sideNumber }) {\n  // TODO: check game validity\n  if (![1, 2].includes(sideNumber)) return { error: INVALID_SIDE_NUMBER };\n\n  // do not destructure undoHistory; it is destroyed when adding to history\n  const { history = [] } = getHistory({ matchUp });\n  history.push({ srv: sideNumber });\n\n  return saveHistory({ matchUp, history });\n}\n","import { saveHistory } from './saveHistory';\n\nexport function clearHistory({ matchUp }) {\n  return saveHistory({ matchUp });\n}\n","import { saveHistory } from './saveHistory';\nimport { getHistory } from './getHistory';\n\nimport {\n  INVALID_VALUES,\n  MISSING_VALUE,\n} from '../../../../constants/errorConditionConstants';\n\nexport function addPoint({ matchUp, point }) {\n  // TODO: check point validity\n  if (!point) return { error: MISSING_VALUE };\n  if (typeof point !== 'object')\n    return { error: INVALID_VALUES, context: { point } };\n\n  // do not destructure undoHistory; it is destroyed when adding to history\n  const { history = [] } = getHistory({ matchUp });\n  history.push(point);\n\n  return saveHistory({ matchUp, history });\n}\n","import { saveHistory } from './saveHistory';\nimport { getHistory } from './getHistory';\n\nimport { INVALID_VALUES } from '../../../../constants/errorConditionConstants';\n\nexport function addGame({ matchUp, game }) {\n  // TODO: check game validity\n  if (typeof game !== 'object')\n    return { error: INVALID_VALUES, context: { game } };\n\n  // do not destructure undoHistory; it is destroyed when adding to history\n  const { history = [] } = getHistory({ matchUp });\n  history.push(game);\n\n  return saveHistory({ matchUp, history });\n}\n","import { saveHistory } from './saveHistory';\nimport { getHistory } from './getHistory';\n\nimport { MISSING_VALUE } from '../../../../constants/errorConditionConstants';\n\nexport function addShot({ matchUp, shot }) {\n  // TODO: check game validity\n  if (typeof shot !== 'object') return { error: MISSING_VALUE };\n\n  // do not destructure undoHistory; it is destroyed when adding to history\n  const { history = [] } = getHistory({ matchUp });\n  history.push(shot);\n\n  return saveHistory({ matchUp, history });\n}\n","import { saveHistory } from './saveHistory';\nimport { getHistory } from './getHistory';\n\nimport { MISSING_VALUE } from '../../../../constants/errorConditionConstants';\n\nexport function addSet({ matchUp, set }) {\n  // TODO: check set validity\n  if (typeof set !== 'object') return { error: MISSING_VALUE };\n\n  // do not destructure undoHistory; it is destroyed when adding to history\n  const { history = [] } = getHistory({ matchUp });\n  history.push(set);\n\n  return saveHistory({ matchUp, history });\n}\n","import { saveHistory } from './saveHistory';\nimport { getHistory } from './getHistory';\n\nexport function redo({ matchUp }) {\n  const { history = [], undoHistory = [] } = getHistory({ matchUp });\n  if (undoHistory.length) history.push(undoHistory.pop());\n\n  return saveHistory({ matchUp, history, undoHistory });\n}\n","import { saveHistory } from './saveHistory';\nimport { getHistory } from './getHistory';\n\nexport function undo({ matchUp }) {\n  const { history = [], undoHistory = [] } = getHistory({ matchUp });\n  undoHistory.push(history.pop());\n\n  return saveHistory({ matchUp, history, undoHistory });\n}\n","export const ABANDONED = 'ABANDONED';\nexport const ACTIVE = 'ACTIVE';\nexport const CANCELLED = 'CANCELLED';\nexport const COMPLETED = 'COMPLETED';\nexport const IN_PROGRESS = 'IN_PROGRESS';\n\nexport const tournamentConstants = {\n  ABANDONED,\n  ACTIVE,\n  CANCELLED,\n  COMPLETED,\n  IN_PROGRESS,\n};\n","import { clearScheduledMatchUps } from '../matchUps/schedule/clearScheduledMatchUps';\nimport { allTournamentMatchUps } from '../../query/matchUps/getAllTournamentMatchUps';\nimport { updateCourtAvailability } from '../venues/updateCourtAvailability';\nimport { dateValidation } from '../../validators/regex';\nimport { addNotice } from '../../global/state/globalState';\n\nimport { MODIFY_TOURNAMENT_DETAIL } from '../../constants/topicConstants';\nimport { Tournament } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_DATE,\n  INVALID_VALUES,\n  MISSING_DATE,\n  MISSING_TOURNAMENT_RECORD,\n  SCHEDULE_NOT_CLEARED,\n} from '../../constants/errorConditionConstants';\n\ntype SetTournamentDatesArgs = {\n  tournamentRecord: Tournament;\n  startDate?: string;\n  endDate?: string;\n};\nexport function setTournamentDates({\n  tournamentRecord,\n  startDate,\n  endDate,\n}: SetTournamentDatesArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (\n    (startDate && !dateValidation.test(startDate)) ||\n    (endDate && !dateValidation.test(endDate))\n  )\n    return { error: INVALID_DATE };\n\n  if (!startDate && !endDate) return { error: MISSING_DATE };\n\n  if (endDate && startDate && new Date(endDate) < new Date(startDate))\n    return { error: INVALID_VALUES };\n\n  let checkScheduling;\n  // if start has moved closer to end or end has moved closer to start, check for scheduling issues\n  if (\n    (startDate &&\n      tournamentRecord.startDate &&\n      new Date(startDate) > new Date(tournamentRecord.startDate)) ||\n    (endDate &&\n      tournamentRecord.endDate &&\n      new Date(endDate) < new Date(tournamentRecord.endDate))\n  ) {\n    checkScheduling = true;\n  }\n\n  if (startDate) tournamentRecord.startDate = startDate;\n  if (endDate) tournamentRecord.endDate = endDate;\n\n  // if there is a startDate specified after current endDate, endDate must be set to startDate\n  if (\n    startDate &&\n    tournamentRecord.endDate &&\n    new Date(startDate) > new Date(tournamentRecord.endDate)\n  ) {\n    tournamentRecord.endDate = startDate;\n  }\n\n  // if there is a endDate specified before current startDate, startDate must be set to endDate\n  if (\n    endDate &&\n    tournamentRecord.startDate &&\n    new Date(endDate) < new Date(tournamentRecord.startDate)\n  ) {\n    tournamentRecord.startDate = endDate;\n  }\n\n  const unscheduledMatchUpIds =\n    checkScheduling &&\n    removeInvalidScheduling({ tournamentRecord })?.unscheduledMatchUpIds;\n\n  updateCourtAvailability({ tournamentRecord });\n\n  addNotice({\n    topic: MODIFY_TOURNAMENT_DETAIL,\n    payload: { startDate, endDate },\n  });\n\n  return { ...SUCCESS, unscheduledMatchUpIds };\n}\n\nexport function setTournamentStartDate({ tournamentRecord, startDate }) {\n  return setTournamentDates({ tournamentRecord, startDate });\n}\n\nexport function setTournamentEndDate({ tournamentRecord, endDate }) {\n  return setTournamentDates({ tournamentRecord, endDate });\n}\n\n// unschedule scheduled matchUps that fall outside of tournament dates\nexport function removeInvalidScheduling({ tournamentRecord }) {\n  const matchUps = allTournamentMatchUps({ tournamentRecord }).matchUps ?? [];\n\n  const startDate =\n    tournamentRecord.startDate && new Date(tournamentRecord.startDate);\n  const endDate =\n    tournamentRecord.endDate && new Date(tournamentRecord.endDate);\n\n  const invalidScheduledDates: string[] = [];\n  const invalidSchedulingMatchUpIds: string[] = [];\n  for (const matchUp of matchUps) {\n    const { schedule, matchUpId } = matchUp;\n    if (!schedule) continue;\n    if (schedule.scheduledDate) {\n      const scheduledDate = new Date(schedule.scheduledDate);\n      if (\n        (startDate && scheduledDate < startDate) ||\n        (endDate && scheduledDate > endDate)\n      ) {\n        invalidSchedulingMatchUpIds.push(matchUpId);\n        if (!invalidScheduledDates.includes(schedule.scheduledDate))\n          invalidScheduledDates.push(schedule.scheduledDate);\n      }\n    }\n  }\n\n  if (invalidScheduledDates.length) {\n    const result = clearScheduledMatchUps({\n      scheduledDates: invalidScheduledDates,\n      tournamentRecord,\n    });\n    if (!result.clearedScheduleCount) return { error: SCHEDULE_NOT_CLEARED };\n  }\n\n  return { unscheduledMatchUpIds: invalidSchedulingMatchUpIds };\n}\n","import { generateDateRange, timeStringMinutes } from '../../utilities/dateTime';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { Court } from '../../types/tournamentTypes';\n\n// bulk update when tournament dates change\n// TODO: check to see if court is present in other linked tournaments\nexport function updateCourtAvailability({ tournamentRecord }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const { startDate, endDate } = tournamentRecord;\n\n  const tournamentDates = generateDateRange(startDate, endDate);\n\n  const courts: Court[] = [];\n  for (const venue of tournamentRecord.venues || []) {\n    if (venue?.courts?.length) courts.push(...venue.courts);\n  }\n\n  for (const court of courts) {\n    const { startTime, endTime } = (court.dateAvailability ?? []).reduce(\n      (extents, availability) => {\n        const startMinutes = timeStringMinutes(extents.startTime);\n        const endMinutes = timeStringMinutes(extents.endTime);\n        if (availability.startTime && timeStringMinutes(availability.startTime) < startMinutes)\n          extents.startTime = availability.startTime;\n\n        if (availability.endTime && timeStringMinutes(availability.endTime) > endMinutes)\n          extents.endTime = availability.endTime;\n\n        return extents;\n      },\n      { startTime: '08:00', endTime: '18:00' },\n    );\n\n    const updatedDateAvailability = tournamentDates.map((date) => {\n      const existing = court.dateAvailability?.find((availability) => availability.date === date);\n      return existing ?? { date, startTime, endTime };\n    });\n\n    const defaultAvailability = court.dateAvailability?.find((availability) => !availability.date);\n    if (defaultAvailability) updatedDateAvailability.unshift(defaultAvailability);\n\n    court.dateAvailability = updatedDateAvailability;\n  }\n\n  return { ...SUCCESS };\n}\n","import { setTournamentStatus } from '../../../mutate/tournaments/setTournamentStatus';\nimport { removeExtension } from '../../../mutate/extensions/removeExtension';\nimport { addNotes, removeNotes } from '../../../mutate/base/addRemoveNotes';\nimport { addOnlineResource } from '../../../mutate/base/addOnlineResource';\nimport { addExtension } from '../../../mutate/extensions/addExtension';\n\nimport {\n  setTournamentName,\n  setTournamentNotes,\n  setTournamentCategories,\n} from '../../../mutate/tournaments/tournamentDetails';\n\nimport {\n  setTournamentDates,\n  setTournamentEndDate,\n  setTournamentStartDate,\n} from '../../../mutate/tournaments/tournamentDates';\n\nimport {\n  addTimeItem,\n  addEventTimeItem,\n  addParticipantTimeItem,\n  addTournamentTimeItem,\n} from '../../../mutate/timeItems/addTimeItem';\n\nimport {\n  addDrawDefinitionExtension,\n  addEventExtension,\n  addParticipantExtension,\n  addTournamentExtension,\n  removeDrawDefinitionExtension,\n  removeEventExtension,\n  removeParticipantExtension,\n  removeTournamentExtension,\n} from '../../../mutate/extensions/addRemoveExtensions';\n\nimport { getProfileRounds } from '../../../mutate/matchUps/schedule/profileRounds';\n\nexport const tournamentGovernor = {\n  addDrawDefinitionExtension,\n  addEventExtension,\n  addEventTimeItem,\n  addExtension,\n  addNotes,\n  addOnlineResource,\n  addParticipantExtension,\n  addParticipantTimeItem,\n  addTimeItem,\n  addTournamentExtension,\n  addTournamentTimeItem,\n  getProfileRounds,\n  removeDrawDefinitionExtension,\n  removeEventExtension,\n  removeExtension,\n  removeNotes,\n  removeParticipantExtension,\n  removeTournamentExtension,\n  setTournamentCategories,\n  setTournamentDates,\n  setTournamentEndDate,\n  setTournamentName,\n  setTournamentNotes,\n  setTournamentStartDate,\n  setTournamentStatus,\n};\n\nexport default tournamentGovernor;\n","import { intersection } from '../../utilities/arrays';\nimport { isObject } from '../../utilities/objects';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  COURT_NOT_FOUND,\n  INVALID_OBJECT,\n  INVALID_PARTICIPANT,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VALUE,\n  NOT_FOUND,\n  PARTICIPANT_NOT_FOUND,\n  VENUE_NOT_FOUND,\n} from '../../constants/errorConditionConstants';\nimport {\n  ResultType,\n  decorateResult,\n} from '../../global/functions/decorateResult';\nimport {\n  DrawDefinition,\n  Event,\n  OnlineResource,\n  Tournament,\n} from '../../types/tournamentTypes';\n\ntype AddOnlineResourceArgs = {\n  onlineResource: OnlineResource;\n  drawDefinition?: DrawDefinition;\n  tournamentRecord: Tournament;\n  organisationId?: string;\n  participantId?: string;\n  personId?: string;\n  courtId?: string;\n  venueId?: string;\n  event?: Event;\n};\n\nexport function addOnlineResource({\n  tournamentRecord,\n  onlineResource,\n  organisationId,\n  participantId,\n  personId,\n  courtId,\n  venueId,\n}: AddOnlineResourceArgs): ResultType {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!isObject(onlineResource)) return { error: MISSING_VALUE };\n\n  if (\n    intersection(Object.keys(onlineResource), [\n      'resourceSubType',\n      'resourceType',\n      'identifier',\n    ]).length !== 3\n  )\n    return decorateResult({\n      result: { error: INVALID_OBJECT },\n      context: { onlineResource },\n    });\n\n  if (organisationId) {\n    if (\n      tournamentRecord.parentOrganisation?.parentOrganisationId !==\n      organisationId\n    ) {\n      return decorateResult({ result: { error: NOT_FOUND } });\n    }\n    if (!tournamentRecord.parentOrganisation.onlineResources)\n      tournamentRecord.parentOrganisation.onlineResources = [];\n    tournamentRecord.parentOrganisation.onlineResources.push(onlineResource);\n  } else if (participantId || personId) {\n    const participant = (tournamentRecord.participants ?? []).find(\n      (p) =>\n        (personId && p.person?.personId === personId) ||\n        p.participantId === participantId\n    );\n    if (!participant) {\n      if (personId) {\n        return decorateResult({ result: { error: NOT_FOUND } });\n      } else {\n        return decorateResult({ result: { error: PARTICIPANT_NOT_FOUND } });\n      }\n    }\n\n    if (personId) {\n      if (participant.person?.personId !== personId) {\n        // both personId and participantId were provided and person does not match found participant\n        return decorateResult({ result: { error: INVALID_PARTICIPANT } });\n      }\n      if (!participant.person.onlineResources)\n        participant.person.onlineResources = [];\n      participant.person.onlineResources.push(onlineResource);\n    } else {\n      if (!participant.onlineResources) participant.onlineResources = [];\n      participant.onlineResources.push(onlineResource);\n    }\n  } else if (courtId) {\n    const court = (tournamentRecord.venues ?? [])\n      .filter((v) => !venueId || v.venueId === venueId)\n      .flatMap((v) =>\n        (v.courts ?? []).filter((c) => c.courtId === courtId)\n      )?.[0];\n    if (!court) return decorateResult({ result: { error: COURT_NOT_FOUND } });\n    if (!court.onlineResources) court.onlineResources = [];\n    court.onlineResources.push(onlineResource);\n  } else if (venueId) {\n    const venue = (tournamentRecord.venues ?? []).find(\n      (v) => v.venueId === venueId\n    );\n    if (!venue) return decorateResult({ result: { error: VENUE_NOT_FOUND } });\n    if (!venue.onlineResources) venue.onlineResources = [];\n    venue.onlineResources.push(onlineResource);\n  } else {\n    if (!tournamentRecord.onlineResources)\n      tournamentRecord.onlineResources = [];\n\n    tournamentRecord.onlineResources.push(onlineResource);\n  }\n\n  return { ...SUCCESS };\n}\n","import { addNotes } from '../base/addRemoveNotes';\n\nimport { MISSING_TOURNAMENT_RECORD } from '../../constants/errorConditionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\n\nexport function setTournamentName({\n  tournamentRecord,\n  promotionalName,\n  tournamentName,\n  formalName,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (tournamentName) tournamentRecord.tournamentName = tournamentName;\n  if (promotionalName) tournamentRecord.promotionalName = promotionalName;\n  if (formalName) tournamentRecord.formalName = formalName;\n  if (tournamentRecord.promotionalName === tournamentRecord.tournamentName) {\n    delete tournamentRecord.promotionalName;\n  }\n  if (tournamentRecord.formalName === tournamentRecord.tournamentName) {\n    delete tournamentRecord.formalName;\n  }\n  return { ...SUCCESS };\n}\n\nexport function setTournamentNotes({ tournamentRecord, notes }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  return addNotes({ element: tournamentRecord, notes });\n}\n\nexport function setTournamentCategories({ tournamentRecord, categories }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  categories = (categories || []).filter((category) => {\n    return category.categoryName && category.type;\n  });\n  tournamentRecord.tournamentCategories = categories;\n  return { ...SUCCESS };\n}\n","import { tournamentConstants } from '../../constants/tournamentConstants';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\nexport function setTournamentStatus({ tournamentRecord, status }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  if (status && !Object.keys(tournamentConstants).includes(status))\n    return { error: INVALID_VALUES, info: 'Unknown status' };\n\n  tournamentRecord.tournamentStatus = status;\n\n  return { ...SUCCESS };\n}\n","import { allTournamentMatchUps } from '../../query/matchUps/getAllTournamentMatchUps';\n\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ErrorType,\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\nexport function dehydrateMatchUps({ tournamentRecord }): {\n  success?: boolean;\n  error?: ErrorType;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (typeof tournamentRecord !== 'object' || !tournamentRecord.tournamentId)\n    return { error: INVALID_VALUES };\n\n  const { matchUps } = allTournamentMatchUps({\n    tournamentRecord,\n    inContext: false,\n  });\n\n  if (matchUps?.length) {\n    const matchUpFormatMap = getMatchUpFormatMap({ tournamentRecord });\n    removeExtraneousAttributes(matchUps, matchUpFormatMap);\n  }\n\n  return { ...SUCCESS };\n}\n\nexport function getMatchUpFormatMap({ tournamentRecord }) {\n  const matchUpFormatMap = {};\n\n  for (const event of tournamentRecord.events || []) {\n    if (event.matchUpFormat)\n      matchUpFormatMap[event.eventId] = event.matchUpFormat;\n\n    for (const drawDefinition of event.drawDefinitions || []) {\n      if (drawDefinition.matchUpFormat)\n        matchUpFormatMap[drawDefinition.drawId] = drawDefinition.matchUpFormat;\n\n      for (const structure of drawDefinition.structures || []) {\n        if (structure.matchUpFormat)\n          matchUpFormatMap[structure.structureId] = structure.matchUpFormat;\n        for (const childStructure of structure.structures || []) {\n          if (childStructure.matchUpFormat)\n            matchUpFormatMap[childStructure.structureId] =\n              childStructure.matchUpFormat;\n        }\n      }\n    }\n  }\n\n  return matchUpFormatMap;\n}\n\nconst baseAttributeKeys = [\n  'collectionId',\n  'collectionPosition',\n  'drawPositions',\n  'extensions',\n  'finishingPositionRange',\n  'finishingRound',\n  'isMock',\n  'matchUpId',\n  'matchUpStatus',\n  'matchUpStatusCodes',\n  'orderOfFinish',\n  'processCodes',\n  'roundNumber',\n  'tieFormat',\n  'tieMatchUps',\n  'roundPosition',\n  'score',\n  'sides', // can be removed only if drawPositions is present and is not a TEAM matchUp\n  'winnerMatchUpId',\n  'loserMatchUpId',\n  'matchUpDuration',\n  'winningSide',\n];\n\nexport function removeExtraneousAttributes(matchUps, matchUpFormatMap = {}) {\n  for (const matchUp of matchUps) {\n    const { structureId, drawId, eventId } = matchUp;\n    const inheritedMatchUpFormat =\n      matchUpFormatMap[structureId] ||\n      matchUpFormatMap[drawId] ||\n      matchUpFormatMap[eventId];\n\n    const matchUpFormat =\n      matchUp.matchUpFormat === inheritedMatchUpFormat\n        ? undefined\n        : matchUp.matchUpFormat;\n\n    for (const key of Object.keys(matchUp)) {\n      if (!baseAttributeKeys.includes(key)) delete matchUp[key];\n    }\n\n    if (matchUp.sides && matchUp.drawPositions && !matchUp.tieMatchUps) {\n      delete matchUp.sides;\n    }\n\n    if (matchUpFormat) matchUp.matchUpFormat = matchUpFormat;\n  }\n}\n","import { isNumeric } from './math';\n\nimport { INVALID_VALUES } from '../constants/errorConditionConstants';\n\n/**\n *\n * @param {object[]} arrayOfJSON - JSON objects array\n * @param {object} config - object which configures processing (see below)\n * @returns {string} - joined by '\\r\\n' or specified line separator\n *\n * config {\n *  {boolean} includeTransformAccessors, // transform accessors are included with columnAccessors\n *  {string[]} columnAccessors, // [ 'includeThis', 'andThis' ]\n *  {object} columnTransform, // e.g. { 'newColumnName': ['oldColumn1', 'oldColumn2' ]}\n *  {object} columnMap, // e.g. { 'columnName': 'newColumnName' }\n *  {object} valuesMap, // e.g. { 'columnName': { 'value1': 'mappedValue' }} // useful for mapping IDs\n *  {array} sortOrder // e.g. ['columnName1', 'columnName2'] // determine order of csv columns\n *  {object} context, // attributes which are to be added to all rows { 'columnName': 'value }\n *  {string} delimiter, // defaults to '\"'\n *  {string} columnJoiner, // defaults to ',' // defines how CSV columns are joined\n *  {string} rowJoiner, // defaults to '\\r\\n' // defines how CSV lines are joined\n *  {string} keyJoiner, // defaults to '.' // defines how flattened column names are constructed\n * }\n *\n * NOTE: `columnTransform` mapped array elements are sensitive to order and will resolve to the first matching value\n * NOTE: `columnMap` should not contain new columnName(s) that are `columnTransform` keys\n */\nexport function JSON2CSV(arrayOfJSON?, config?) {\n  if (config && typeof config !== 'object') return INVALID_VALUES;\n\n  let { columnTransform = {} } = config || {};\n\n  const {\n    includeTransformAccessors,\n    includeHeaderRow = true,\n    returnTransformedJSON,\n    removeEmptyColumns,\n    onlyHeaderRow,\n\n    columnAccessors = [],\n    functionMap = {},\n    columnMap = {},\n    valuesMap = {},\n    context = {},\n\n    delimiter = '\"',\n    columnJoiner = ',',\n    rowJoiner = '\\r\\n',\n    keyJoiner = '.',\n  } = config || {};\n\n  if (\n    !Array.isArray(arrayOfJSON) ||\n    !Array.isArray(columnAccessors) ||\n    typeof context !== 'object' ||\n    typeof columnMap !== 'object' ||\n    typeof columnTransform !== 'object' ||\n    typeof functionMap !== 'object' ||\n    typeof valuesMap !== 'object' ||\n    typeof columnJoiner !== 'string' ||\n    typeof rowJoiner !== 'string' ||\n    typeof keyJoiner !== 'string' ||\n    typeof delimiter !== 'string'\n  )\n    return INVALID_VALUES;\n\n  // ensure all column transformers are arrays\n  columnTransform = Object.assign(\n    {},\n    ...Object.keys(columnTransform)\n      .reverse() // reverse so that exported CSV columns are in the order as defined\n      .map((key) => ({\n        [key]: Array.isArray(columnTransform[key])\n          ? columnTransform[key]\n          : [\n              // ensure transform attributes are strings\n              typeof columnTransform[key] === 'string' && columnTransform[key],\n            ].filter(Boolean),\n      }))\n  );\n\n  const flattened = arrayOfJSON\n    .filter(Boolean)\n    .map((obj) => flattenJSON(obj, keyJoiner));\n\n  const transformColumns = Object.values(columnTransform).flat();\n  if (includeTransformAccessors) columnAccessors.push(...transformColumns);\n\n  const headerRow = flattened\n    .reduce(\n      (aggregator, row) =>\n        Object.keys(row).every(\n          (key) => (!aggregator.includes(key) && aggregator.push(key)) || true\n        ) && aggregator,\n      []\n    )\n    .filter((key) => !columnAccessors?.length || columnAccessors.includes(key));\n\n  const accessorMap = Object.assign(\n    {},\n    ...Object.keys(columnTransform)\n      .reverse() // so that original order is preserved when later pushed\n      .map((transform) =>\n        columnTransform[transform]\n          .map((value) => ({ [value]: transform }))\n          .flat()\n      )\n      .flat()\n  );\n\n  const sortColumns = (a, b) =>\n    !config?.sortOrder\n      ? 0\n      : (config.sortOrder.includes(a) &&\n          config.sortOrder.includes(b) &&\n          config.sortOrder.indexOf(a) - config.sortOrder.indexOf(b)) ||\n        (!config.sortOrder.includes(b) && -1);\n\n  const tranformedHeaderRow = headerRow\n    .reduce((def, key) => {\n      const transform = accessorMap[key];\n      if (transform) {\n        if (!def.includes(transform)) def.push(transform);\n      } else {\n        def.push(key);\n      }\n      return def;\n    }, [])\n    .sort(sortColumns);\n\n  Object.keys(columnMap).forEach(\n    (columnName) =>\n      !tranformedHeaderRow.includes(columnName) &&\n      tranformedHeaderRow.unshift(columnName)\n  );\n\n  Object.keys(columnTransform).forEach(\n    (columnName) =>\n      !tranformedHeaderRow.includes(columnName) &&\n      tranformedHeaderRow.unshift(columnName)\n  );\n\n  typeof context === 'object' &&\n    Object.keys(context).forEach(\n      (columnName) =>\n        !tranformedHeaderRow.includes(columnName) &&\n        tranformedHeaderRow.unshift(columnName)\n    );\n\n  let mappedHeaderRow = tranformedHeaderRow.map((key) => columnMap[key] || key);\n\n  if (onlyHeaderRow) return [mappedHeaderRow];\n\n  const withDelimiter = (value) => `${delimiter}${value}${delimiter}`;\n\n  const columnValueCounts: number[] = [];\n  const processRow = (row) => {\n    return Object.values(\n      tranformedHeaderRow.reduce((columnsMap, columnName, columnIndex) => {\n        const accessors = columnTransform[columnName];\n        const value =\n          (accessors?.length\n            ? row[accessors.find((accessor) => row[accessor])]\n            : row[columnName]) ||\n          context?.[columnName] ||\n          '';\n\n        const mappedValue = valuesMap[columnName]?.[value] || value;\n        const fxValue =\n          typeof functionMap[columnName] === 'function'\n            ? functionMap[columnName](mappedValue)\n            : mappedValue;\n        columnsMap[columnName] = withDelimiter(fxValue);\n        if (fxValue) {\n          columnValueCounts[columnIndex] =\n            (columnValueCounts[columnIndex] || 0) + 1;\n        }\n        return columnsMap;\n      }, {})\n    );\n  };\n\n  let flattenedRows = flattened.map(processRow);\n\n  const indicesToRemove =\n    removeEmptyColumns &&\n    [...columnValueCounts]\n      .map((count, index) => !count && index)\n      .filter(isNumeric)\n      .reverse();\n\n  if (indicesToRemove) {\n    const purge = (row) =>\n      row.filter((_, index) => !indicesToRemove.includes(index));\n    flattenedRows = flattenedRows.map(purge);\n    mappedHeaderRow = purge(mappedHeaderRow);\n  }\n\n  const rows = flattenedRows.map((row) => row.join(columnJoiner));\n\n  if (returnTransformedJSON) {\n    return rows.map((row) => {\n      const columnValues = row.split(columnJoiner);\n      return Object.assign(\n        {},\n        ...columnValues.map((v, i) => ({ [mappedHeaderRow[i]]: v }))\n      );\n    });\n  }\n\n  return includeHeaderRow\n    ? [mappedHeaderRow.map(withDelimiter).join(columnJoiner), ...rows].join(\n        rowJoiner\n      )\n    : rows.join(rowJoiner);\n}\n\nexport function flattenJSON(obj, keyJoiner: string = '.', path: string[] = []) {\n  return (\n    typeof obj === 'object' &&\n    Object.keys(obj).reduce((result, key: string) => {\n      if (typeof obj[key] !== 'object') {\n        result[path.concat(key).join(keyJoiner)] = obj[key];\n        return result;\n      }\n      return Object.assign(\n        result,\n        flattenJSON(obj[key], keyJoiner, path.concat(key))\n      );\n    }, {})\n  );\n}\n","import { visualizeScheduledMatchUps } from '../../../tests/testHarness/testUtilities/visualizeScheduledMatchUps';\nimport { dehydrateMatchUps } from '../../../mutate/tournaments/dehydrate';\nimport { structureSort } from '../../../functions/sorters/structureSort';\n\nimport { definedAttributes } from '../../../utilities/definedAttributes';\nimport { attributeFilter } from '../../../utilities/attributeFilter';\nimport { matchUpSort } from '../../../functions/sorters/matchUpSort';\nimport { generateDateRange, dateTime } from '../../../utilities/dateTime';\nimport { JSON2CSV, flattenJSON } from '../../../utilities/json';\nimport { generateTimeCode } from '../../../utilities/timeCode';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { constantToString } from '../../../utilities/strings';\nimport { numericSort } from '../../../utilities/sorting';\nimport { UUID, UUIDS } from '../../../utilities/UUID';\nimport {\n  nearestPowerOf2,\n  nextPowerOf2,\n  isPowerOf2,\n  isOdd,\n  isConvertableInteger,\n  isNumeric,\n} from '../../../utilities/math';\nimport {\n  extractAttributes,\n  hasAttributeValues,\n  createMap,\n  generateHashCode,\n  undefinedToNull,\n} from '../../../utilities/objects';\n\nimport {\n  allNumeric,\n  chunkArray,\n  chunkByNth,\n  chunkSizeProfile,\n  countValues,\n  generateRange,\n  groupValues,\n  instanceCount,\n  intersection,\n  noNulls,\n  noNumeric,\n  overlap,\n  occurrences,\n  randomMember,\n  randomPop,\n  shuffleArray,\n  subSort,\n  unique,\n} from '../../../utilities/arrays';\n\nexport const utilitiesGovernor = {\n  visualizeScheduledMatchUps,\n  dehydrateMatchUps,\n  structureSort,\n\n  allNumeric,\n  attributeFilter,\n  chunkArray,\n  chunkByNth,\n  chunkSizeProfile,\n  constantToString,\n  countValues,\n  createMap,\n  dateTime,\n  definedAttributes,\n  extractAttributes,\n  flattenJSON,\n  generateDateRange,\n  generateHashCode,\n  generateRange,\n  generateTimeCode,\n  groupValues,\n  hasAttributeValues,\n  instanceCount,\n  intersection,\n  isConvertableInteger,\n  isNumeric,\n  isOdd,\n  isPowerOf2,\n  JSON2CSV,\n  makeDeepCopy,\n  matchUpSort,\n  nearestPowerOf2,\n  nextPowerOf2,\n  noNulls,\n  noNumeric,\n  numericSort,\n  occurrences,\n  overlap,\n  randomMember,\n  randomPop,\n  shuffleArray,\n  subSort,\n  undefinedToNull,\n  unique,\n  UUID,\n  UUIDS,\n};\n\nexport const utilities = utilitiesGovernor;\nexport default utilitiesGovernor;\n","import { getRoundMatchUps } from '../../../query/matchUps/getRoundMatchUps';\nimport { extractTime } from '../../../utilities/dateTime';\nimport {\n  printGlobalLog,\n  purgeGlobalLog,\n  pushGlobalLog,\n} from '../../../global/functions/globalLog';\n\nexport function visualizeScheduledMatchUps({\n  scheduledMatchUps,\n  showGlobalLog,\n}) {\n  purgeGlobalLog();\n  const structureIds = scheduledMatchUps?.reduce(\n    (structureIds, { structureId }) =>\n      structureIds.includes(structureId)\n        ? structureIds\n        : structureIds.concat(structureId),\n    []\n  );\n\n  const structureNames = Array.isArray(structureIds) && {\n    ...structureIds.map((structureId) => {\n      const { structureName, matchUpType } = scheduledMatchUps.find(\n        (matchUp) => matchUp.structureId === structureId\n      );\n      return {\n        [structureId]: `${structureName} ${matchUpType}`,\n      };\n    }),\n  };\n\n  structureIds?.forEach((structureId) => {\n    pushGlobalLog(\n      {\n        color: 'blue',\n        method: 'draw',\n        structure: structureNames[structureId],\n        keyColors: {\n          structure: 'magenta',\n        },\n      },\n      true\n    );\n    const structureMatchUps = scheduledMatchUps.filter(\n      (matchUp) => matchUp.structureId === structureId\n    );\n    const roundMatchUps =\n      getRoundMatchUps({\n        matchUps: structureMatchUps,\n      })?.roundMatchUps || [];\n    Object.keys(roundMatchUps).forEach((roundNumber) => {\n      pushGlobalLog(\n        {\n          roundNumber,\n          keyColors: {\n            roundNumber: 'brightcyan',\n          },\n        },\n        true\n      );\n      roundMatchUps[roundNumber].forEach(({ matchUpId, schedule }) => {\n        const scheduledTime = extractTime(schedule.scheduledTime);\n        pushGlobalLog(\n          {\n            matchUpId,\n            time: scheduledTime,\n            date: schedule.scheduledDate,\n            venue: schedule.venueId,\n            keyColors: {\n              time: 'brightcyan',\n              date: 'brightcyan',\n              matchUpId: 'yellow',\n              venue: 'magenta',\n            },\n          },\n          true\n        );\n      });\n    });\n  });\n\n  if (showGlobalLog) printGlobalLog();\n}\n","import { getSchedulingProfile } from '../../mutate/tournaments/schedulingProfile';\nimport { scheduledSortedMatchUps } from '../../functions/sorters/scheduledSortedMatchUps';\nimport { allTournamentMatchUps } from '../matchUps/getAllTournamentMatchUps';\n\nimport { MISSING_COURT_ID, MISSING_TOURNAMENT_RECORD, MISSING_VENUE_ID } from '../../constants/errorConditionConstants';\nimport { MatchUpFilters, ScheduleVisibilityFilters } from '../../types/factoryTypes';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { Tournament } from '../../types/tournamentTypes';\nimport { HydratedMatchUp } from '../../types/hydrated';\n\ntype GetScheduledCourtMatchUpsArgs = {\n  scheduleVisibilityFilters?: ScheduleVisibilityFilters;\n  venueMatchUps?: HydratedMatchUp[];\n  matchUpFilters?: MatchUpFilters;\n  tournamentRecord: Tournament;\n  courtId: string;\n};\n\nexport function getScheduledCourtMatchUps(\n  params: GetScheduledCourtMatchUpsArgs,\n): ResultType & { matchUps?: HydratedMatchUp[] } {\n  if (!params?.tournamentRecord && !Array.isArray(params?.venueMatchUps)) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!params?.courtId) return { error: MISSING_COURT_ID };\n\n  const { scheduleVisibilityFilters, tournamentRecord, matchUpFilters, venueMatchUps, courtId } = params;\n\n  const { schedulingProfile } = getSchedulingProfile({ tournamentRecord });\n\n  if (Array.isArray(venueMatchUps)) return { matchUps: getCourtMatchUps({ matchUps: venueMatchUps, courtId }) };\n\n  const { matchUps: tournamentMatchUps } = allTournamentMatchUps({\n    scheduleVisibilityFilters,\n    tournamentRecord,\n    matchUpFilters,\n  });\n  const matchUps = getCourtMatchUps({ matchUps: tournamentMatchUps, courtId });\n\n  return { matchUps };\n\n  function getCourtMatchUps({ matchUps, courtId }) {\n    const courtMatchUps = matchUps.filter((matchUp) => {\n      // allocatedCourtIds only applies to TEAM matchUps\n      const allocatedCourtIds = matchUp.schedule?.allocatedCourts?.map(({ courtId }) => courtId);\n      return matchUp.schedule?.courtId === courtId || allocatedCourtIds?.includes(courtId);\n    });\n    return scheduledSortedMatchUps({\n      matchUps: courtMatchUps,\n      schedulingProfile,\n    });\n  }\n}\n\ntype GetScheduledVenueMatchUpsArgs = {\n  scheduleVisibilityFilters?: ScheduleVisibilityFilters;\n  matchUpFilters?: MatchUpFilters;\n  tournamentRecord: Tournament;\n  venueId: string;\n};\nexport function getScheduledVenueMatchUps({\n  scheduleVisibilityFilters,\n  tournamentRecord,\n  matchUpFilters,\n  venueId,\n}: GetScheduledVenueMatchUpsArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!venueId) return { error: MISSING_VENUE_ID };\n\n  const { schedulingProfile } = getSchedulingProfile({ tournamentRecord });\n\n  const { matchUps: tournamentMatchUps } = allTournamentMatchUps({\n    scheduleVisibilityFilters,\n    tournamentRecord,\n    matchUpFilters,\n  });\n  const matchUps = getVenueMatchUps({ matchUps: tournamentMatchUps, venueId });\n\n  return { matchUps };\n\n  function getVenueMatchUps({ matchUps, venueId }) {\n    const venueMatchUps = matchUps.filter((matchUp) => {\n      // allocatedCourtIds only applies to TEAM matchUps\n      const allocatedVenueIds = matchUp.schedule?.allocatedCourts?.map(({ venueId }) => venueId);\n      return matchUp.schedule?.venueId === venueId || allocatedVenueIds?.includes(venueId);\n    });\n    return scheduledSortedMatchUps({\n      matchUps: venueMatchUps,\n      schedulingProfile,\n    });\n  }\n}\n","import { getAppliedPolicies } from '../../query/extensions/getAppliedPolicies';\nimport { getScheduledCourtMatchUps } from '../../query/venues/getScheduledCourtMatchUps';\nimport { minutesDifference, timeToDate } from '../../utilities/dateTime';\nimport { startTimeSort } from '../../validators/time';\nimport { addNotice } from '../../global/state/globalState';\nimport { validDateAvailability } from '../../validators/validateDateAvailability';\nimport { findCourt } from './findCourt';\n\nimport { Availability, Tournament } from '../../types/tournamentTypes';\nimport { POLICY_TYPE_SCHEDULING } from '../../constants/policyConstants';\nimport { MODIFY_VENUE } from '../../constants/topicConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { HydratedMatchUp } from '../../types/hydrated';\nimport {\n  ErrorType,\n  MISSING_COURT_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\ntype ModifyCourtAvailabilityArgs = {\n  venueMatchUps?: HydratedMatchUp[];\n  dateAvailability: Availability[];\n  tournamentRecord: Tournament;\n  disableNotice?: boolean;\n  courtId: string;\n  force?: boolean;\n};\nexport function modifyCourtAvailability({\n  tournamentRecord,\n  dateAvailability,\n  disableNotice,\n  venueMatchUps,\n  courtId,\n  force,\n}: ModifyCourtAvailabilityArgs): {\n  error?: ErrorType;\n  success?: boolean;\n  totalMergeCount?: number;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!courtId) return { error: MISSING_COURT_ID };\n\n  const dateResult = validDateAvailability({ dateAvailability });\n  if (dateResult.error) return dateResult;\n\n  // TODO: build up a map of affected dates and:\n  // 1. whether aggregate time on given dates has increased or decreased\n  // 2. specific periods of time on given dates that are no longer available\n\n  const { updatedDateAvailability, totalMergeCount } =\n    sortAndMergeDateAvailability(dateAvailability);\n  dateAvailability = updatedDateAvailability;\n\n  const courtResult = findCourt({ tournamentRecord, courtId });\n  if (courtResult.error) return courtResult;\n  const { court, venue } = courtResult;\n\n  const { matchUps: courtMatchUps } = getScheduledCourtMatchUps({\n    tournamentRecord,\n    venueMatchUps,\n    courtId,\n  });\n\n  // TODO: check whether there are matchUps which are no longer possible to play\n  // In the first instance, matchUps which are explicitly scheduled on the court for times which are no longer available\n  // NOTE: see dateAvailability.test.ts\n  if (courtMatchUps?.length) {\n    const appliedPolicies = getAppliedPolicies({\n      tournamentRecord,\n    })?.appliedPolicies;\n\n    const allowModificationWhenMatchUpsScheduled =\n      force ??\n      appliedPolicies?.[POLICY_TYPE_SCHEDULING]?.allowDeletionWithScoresPresent\n        ?.courts;\n\n    // Iterate through courtMatchUps and check that scheduledTime/scheduledDate still avilable\n    const matchUpsWithInvalidScheduling = [];\n\n    if (matchUpsWithInvalidScheduling.length) {\n      if (allowModificationWhenMatchUpsScheduled) {\n        // go ahead and remove scheduling\n      } else {\n        console.log(\n          'throw error: scheduled court matchUps',\n          matchUpsWithInvalidScheduling.length\n        );\n      }\n    }\n  }\n  // TODO: In the second instance, if there is reduced aggregate court time matchUps scheduled on the affected dates (but not specific court)\n  // would have scheduling impacts impacts\n\n  if (court) {\n    court.dateAvailability = dateAvailability;\n\n    if (!disableNotice && venue)\n      addNotice({\n        payload: { venue, tournamentId: tournamentRecord.tournamentId },\n        topic: MODIFY_VENUE,\n        key: venue.venueId,\n      });\n  }\n\n  return { ...SUCCESS, totalMergeCount };\n}\n\nfunction sortAndMergeDateAvailability(dateAvailability) {\n  let totalMergeCount = 0;\n\n  const availabilityByDate = dateAvailability.reduce((byDate, availability) => {\n    const { date, startTime, endTime, bookings } = availability;\n    if (!byDate[date]) byDate[date] = [];\n    byDate[date].push({ startTime, endTime, bookings });\n    return byDate;\n  }, {});\n\n  const updatedDateAvailability: any[] = [];\n\n  Object.keys(availabilityByDate).forEach((date) => {\n    availabilityByDate[date].sort(startTimeSort);\n    const { mergedAvailability, mergeCount } = getMergedAvailability(\n      availabilityByDate[date]\n    );\n    updatedDateAvailability.push(\n      ...mergedAvailability.map((availability: any) => ({\n        date,\n        ...availability,\n      }))\n    );\n    totalMergeCount += mergeCount;\n  });\n\n  return { updatedDateAvailability, totalMergeCount };\n}\n\nfunction getMergedAvailability(dateDetails) {\n  let lastStartTime,\n    lastEndTime,\n    lastBookings,\n    safety = dateDetails.length,\n    mergeCount = 0;\n  const mergedAvailability: any[] = [];\n\n  while (dateDetails.length && safety) {\n    const details = dateDetails.shift();\n    const { startTime, endTime, bookings } = details;\n    safety -= 1;\n\n    if (!lastStartTime) {\n      lastStartTime = startTime;\n      lastBookings = bookings;\n      lastEndTime = endTime;\n    } else {\n      const difference = minutesDifference(\n        timeToDate(lastEndTime),\n        timeToDate(startTime),\n        false\n      );\n\n      if (difference > 0) {\n        const availability: any = {\n          startTime: lastStartTime,\n          endTime: lastEndTime,\n        };\n        if (lastBookings?.length) availability.bookings = lastBookings;\n        mergedAvailability.push(availability);\n        lastStartTime = startTime;\n        lastBookings = bookings;\n        lastEndTime = endTime;\n      } else {\n        if (bookings) {\n          if (lastBookings) {\n            lastBookings.push(bookings);\n          } else {\n            lastBookings = bookings;\n          }\n        }\n        lastEndTime = endTime;\n        mergeCount += 1;\n      }\n    }\n  }\n  const availability: any = { startTime: lastStartTime, endTime: lastEndTime };\n  if (lastBookings?.length) availability.bookings = lastBookings;\n  mergedAvailability.push(availability);\n\n  return { mergedAvailability, mergeCount };\n}\n","import { SCHEDULED_MATCHUPS } from '../../../constants/errorConditionConstants';\n\nexport function deletionMessage({ matchUpsCount = 0 }) {\n  const singularPlural = matchUpsCount === 1 ? 'matchUp' : 'matchUps';\n  const info = `Schedule would be deleted from ${matchUpsCount} ${singularPlural}; use { force: true }`;\n  return {\n    error: SCHEDULED_MATCHUPS,\n    info,\n  };\n}\n","import { getMatchUp } from '../../../query/matchUps/getMatchUpFromMatchUps';\nimport { modifyMatchUpNotice } from '../../notifications/drawNotifications';\nimport { findDrawMatchUp } from '../../../acquire/findDrawMatchUp';\nimport { allTournamentMatchUps } from '../../../query/matchUps/getAllTournamentMatchUps';\nimport { findEvent } from '../../../acquire/findEvent';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport {\n  MATCHUP_NOT_FOUND,\n  MISSING_DRAW_ID,\n  MISSING_MATCHUP_ID,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../../constants/errorConditionConstants';\nimport {\n  ALLOCATE_COURTS,\n  ASSIGN_COURT,\n} from '../../../constants/timeItemConstants';\n\nimport { DrawDefinition, Tournament } from '../../../types/tournamentTypes';\n\ntype RemoveCourtAssignmentArgs = {\n  drawDefinition?: DrawDefinition;\n  tournamentRecord?: Tournament;\n  matchUpId: string;\n  drawId?: string;\n};\nexport function removeCourtAssignment({\n  tournamentRecord,\n  drawDefinition,\n  matchUpId,\n  drawId,\n}: RemoveCourtAssignmentArgs) {\n  const stack = 'removeCourtAssignment';\n  if (!matchUpId) return { error: MISSING_MATCHUP_ID };\n  if (!drawDefinition && !drawId) return { error: MISSING_DRAW_ID };\n\n  let matchUp;\n  if (!drawDefinition) {\n    if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n    ({ drawDefinition } = findEvent({ tournamentRecord, drawId }));\n  }\n\n  if (drawDefinition) {\n    ({ matchUp } = findDrawMatchUp({ drawDefinition, matchUpId }));\n  } else {\n    if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n    const matchUps =\n      allTournamentMatchUps({ tournamentRecord, inContext: false }).matchUps ??\n      [];\n    ({ matchUp } = getMatchUp({ matchUps, matchUpId }));\n  }\n  if (!matchUp) return { error: MATCHUP_NOT_FOUND };\n\n  if (matchUp.timeItems) {\n    const hasCourtAssignment = matchUp.timeItems.find((candidate) =>\n      [ASSIGN_COURT, ALLOCATE_COURTS].includes(candidate.itemType)\n    );\n\n    if (hasCourtAssignment) {\n      matchUp.timeItems = matchUp.timeItems.filter(\n        ({ itemType }) => ![ASSIGN_COURT, ALLOCATE_COURTS].includes(itemType)\n      );\n\n      modifyMatchUpNotice({\n        tournamentId: tournamentRecord?.tournamentId,\n        context: stack,\n        drawDefinition,\n        matchUp,\n      });\n    }\n  }\n\n  return { ...SUCCESS };\n}\n","import { allCompetitionMatchUps } from '../../query/matchUps/getAllCompetitionMatchUps';\nimport { deletionMessage } from '../../assemblies/generators/matchUps/deletionMessage';\nimport { removeCourtAssignment } from '../matchUps/schedule/removeCourtAssignment';\nimport { checkAndUpdateSchedulingProfile } from '../tournaments/schedulingProfile';\nimport { getAppliedPolicies } from '../../query/extensions/getAppliedPolicies';\nimport { addNotice } from '../../global/state/globalState';\n\nimport { POLICY_TYPE_SCHEDULING } from '../../constants/policyConstants';\nimport { Tournament, Venue } from '../../types/tournamentTypes';\nimport { DELETE_VENUE } from '../../constants/topicConstants';\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  ErrorType,\n  INVALID_VALUES,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_VENUE_ID,\n} from '../../constants/errorConditionConstants';\n\ntype DeleteVenueArgs = {\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  venueId: string;\n  force?: boolean;\n};\n\nexport function deleteVenue(params: DeleteVenueArgs): {\n  success?: boolean;\n  error?: ErrorType;\n} {\n  if (typeof params?.venueId !== 'string') return { error: MISSING_VENUE_ID };\n\n  const { tournamentRecord, venueId, force } = params;\n\n  const tournamentRecords =\n    params.tournamentRecords ||\n    (tournamentRecord && {\n      [tournamentRecord.tournamentId]: tournamentRecord,\n    }) ||\n    {};\n\n  if (!Object.keys(tournamentRecords).length)\n    return { error: MISSING_TOURNAMENT_RECORD };\n\n  const contextFilters = { venueIds: [venueId] };\n  const matchUpsToUnschedule =\n    allCompetitionMatchUps({\n      tournamentRecords,\n      contextFilters,\n    }).matchUps ?? [];\n\n  const appliedPolicies = getAppliedPolicies({\n    tournamentRecord,\n  })?.appliedPolicies;\n\n  const allowModificationWhenMatchUpsScheduled =\n    force ??\n    appliedPolicies?.[POLICY_TYPE_SCHEDULING]?.allowDeletionWithScoresPresent\n      ?.venues;\n\n  if (!matchUpsToUnschedule.length || allowModificationWhenMatchUpsScheduled) {\n    for (const tournamentRecord of Object.values(tournamentRecords)) {\n      // if no matchUpsToUnschedule this does nothing but avoid the deletionMessage\n      for (const matchUp of matchUpsToUnschedule) {\n        const result = removeCourtAssignment({\n          matchUpId: matchUp.matchUpId,\n          drawId: matchUp.drawId,\n          tournamentRecord,\n        });\n        if (result.error) return result;\n      }\n      let deleted;\n      tournamentRecord.venues = (tournamentRecord.venues ?? []).filter(\n        (venue: Venue | undefined) => {\n          if (venue?.venueId !== venueId) return true;\n          deleted = true;\n          return false;\n        }\n      );\n      if (deleted) {\n        addNotice({\n          payload: { venueId, tournamentId: tournamentRecord.tournamentId },\n          topic: DELETE_VENUE,\n          key: venueId,\n        });\n      }\n    }\n  } else {\n    return deletionMessage({ matchUpsCount: matchUpsToUnschedule.length });\n  }\n\n  checkAndUpdateSchedulingProfile({ tournamentRecords });\n\n  return { ...SUCCESS };\n}\n\nexport function deleteVenues({ tournamentRecord, venueIds, force }) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!Array.isArray(venueIds)) return { error: INVALID_VALUES };\n\n  for (const venue of tournamentRecord.venues || []) {\n    const { venueId } = venue;\n    if (venueIds.includes(venueId)) {\n      const { venueId } = venue;\n      const result = deleteVenue({ tournamentRecord, venueId, force });\n      if (result.error) return result;\n    }\n  }\n\n  return { ...SUCCESS };\n}\n","import { resolveTournamentRecords } from '../../parameters/resolveTournamentRecords';\nimport { checkRequiredParameters } from '../../parameters/checkRequiredParameters';\nimport { addExtension } from '../extensions/addExtension';\n\nimport { DISABLED } from '../../constants/extensionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  COURT_IDS,\n  TOURNAMENT_RECORDS,\n} from '../../constants/attributeConstants';\n\ntype DisableCourtsArgs = {\n  tournamentRecords: any;\n  tournamentId?: string;\n  courtIds: string[];\n  dates?: string[];\n};\n\nexport function disableCourts(params: DisableCourtsArgs) {\n  const { courtIds, dates } = params;\n  const tournamentRecords = resolveTournamentRecords(params);\n  const paramsToCheck: any[] = [\n    { [TOURNAMENT_RECORDS]: true, [COURT_IDS]: true },\n  ];\n  const paramCheck = checkRequiredParameters(params, paramsToCheck);\n  if (paramCheck.error) return paramCheck;\n\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    courtsDisable({ tournamentRecord, courtIds, dates });\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction courtsDisable({ tournamentRecord, courtIds, dates }) {\n  const disabledValue = Array.isArray(dates) && dates.length ? { dates } : true;\n  const disableCourt = (court) =>\n    addExtension({\n      extension: { value: disabledValue, name: DISABLED },\n      creationTime: false,\n      element: court,\n    });\n\n  for (const venue of tournamentRecord.venues || []) {\n    for (const court of venue.courts || []) {\n      if (courtIds?.includes(court.courtId)) {\n        const result = disableCourt(court);\n        if (result.error) return result;\n      }\n    }\n  }\n\n  return { ...SUCCESS };\n}\n","import { checkRequiredParameters } from '../../parameters/checkRequiredParameters';\nimport { addExtension } from '../extensions/addExtension';\n\nimport { DISABLED } from '../../constants/extensionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  TOURNAMENT_RECORDS,\n  VENUE_IDS,\n} from '../../constants/attributeConstants';\n\ntype DisableVenuesArgs = {\n  tournamentRecords: any;\n  tournamentId?: string;\n  venueIds: string[];\n};\n\nexport function disableVenues(params: DisableVenuesArgs) {\n  const { tournamentRecords, tournamentId, venueIds } = params;\n  const paramsToCheck: any[] = [\n    { [TOURNAMENT_RECORDS]: true, [VENUE_IDS]: true },\n  ];\n  const paramCheck = checkRequiredParameters(params, paramsToCheck);\n  if (paramCheck.error) return paramCheck;\n\n  const tournamentIds = Object.keys(tournamentRecords).filter(\n    (id) => !tournamentId || id === tournamentId\n  );\n\n  for (const tournamentId of tournamentIds) {\n    const tournamentRecord = tournamentRecords[tournamentId];\n    venuesDisable({ tournamentRecord, venueIds });\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction venuesDisable({ tournamentRecord, venueIds }) {\n  for (const venue of tournamentRecord.venues || []) {\n    if (venueIds?.includes(venue.venueId)) {\n      const result = addExtension({\n        creationTime: false,\n        element: venue,\n        extension: {\n          name: DISABLED,\n          value: true,\n        },\n      });\n      if (result.error) return result;\n    }\n  }\n\n  return { ...SUCCESS };\n}\n","import { resolveTournamentRecords } from '../../parameters/resolveTournamentRecords';\nimport { checkRequiredParameters } from '../../parameters/checkRequiredParameters';\nimport { removeExtension } from '../extensions/removeExtension';\nimport { addExtension } from '../extensions/addExtension';\nimport { findExtension } from '../../acquire/findExtension';\n\nimport { DISABLED } from '../../constants/extensionConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  COURT_IDS,\n  TOURNAMENT_RECORDS,\n} from '../../constants/attributeConstants';\n\nexport function enableCourts(params) {\n  const tournamentRecords = resolveTournamentRecords(params);\n  const paramsToCheck: any[] = [{ [TOURNAMENT_RECORDS]: true }];\n  !params.enableAll && paramsToCheck.push({ [COURT_IDS]: true });\n  const paramCheck = checkRequiredParameters(params, paramsToCheck);\n  if (paramCheck.error) return paramCheck;\n\n  const { enableAll, courtIds, dates } = params;\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    courtsEnable({ tournamentRecord, courtIds, enableAll, dates });\n  }\n\n  return { ...SUCCESS };\n}\n\nfunction courtsEnable({ tournamentRecord, courtIds, enableAll, dates }) {\n  for (const venue of tournamentRecord.venues || []) {\n    for (const court of venue.courts || []) {\n      if (enableAll || courtIds?.includes(court.courtId))\n        if (Array.isArray(dates)) {\n          const { extension } = findExtension({\n            element: court,\n            name: DISABLED,\n          });\n\n          if (extension) {\n            const value = extension.value;\n            if (Array.isArray(value.dates)) {\n              value.dates = value.dates.filter((date) => !dates.includes(date));\n            }\n            addExtension({\n              extension: { name: DISABLED, value },\n              creationTime: false,\n              element: court,\n            });\n          }\n        } else {\n          removeExtension({ element: court, name: DISABLED });\n        }\n    }\n  }\n\n  return { ...SUCCESS };\n}\n","import { removeCourtAssignment } from '../matchUps/schedule/removeCourtAssignment';\nimport { getScheduledCourtMatchUps } from '../../query/venues/getScheduledCourtMatchUps';\nimport { deletionMessage } from '../../assemblies/generators/matchUps/deletionMessage';\nimport { resolveTournamentRecords } from '../../parameters/resolveTournamentRecords';\nimport { checkRequiredParameters } from '../../parameters/checkRequiredParameters';\nimport { getAppliedPolicies } from '../../query/extensions/getAppliedPolicies';\nimport { addNotice } from '../../global/state/globalState';\nimport { findCourt } from './findCourt';\n\nimport { COURT_NOT_FOUND } from '../../constants/errorConditionConstants';\nimport { POLICY_TYPE_SCHEDULING } from '../../constants/policyConstants';\nimport { MODIFY_VENUE } from '../../constants/topicConstants';\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { Tournament } from '../../types/tournamentTypes';\nimport {\n  COURT_ID,\n  TOURNAMENT_RECORDS,\n} from '../../constants/attributeConstants';\n\ntype DeleteCourtArgs = {\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  disableNotice?: boolean;\n  courtId: string;\n  force?: boolean;\n};\nexport function deleteCourt(params: DeleteCourtArgs) {\n  const { courtId, disableNotice, force } = params;\n  const tournamentRecords = resolveTournamentRecords(params);\n  const paramsCheck = checkRequiredParameters(params, [\n    { [TOURNAMENT_RECORDS]: true, [COURT_ID]: true },\n  ]);\n  if (paramsCheck.error) return paramsCheck;\n\n  let courtDeleted;\n  let result;\n\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    result = courtDeletion({ tournamentRecord, disableNotice, courtId, force });\n    if (result.error && result.error !== COURT_NOT_FOUND) return result;\n    if (result.success) courtDeleted = true;\n  }\n\n  return courtDeleted ? { ...SUCCESS } : result;\n}\n\nexport function courtDeletion({\n  tournamentRecord,\n  disableNotice,\n  courtId,\n  force,\n}) {\n  const result = findCourt({ tournamentRecord, courtId });\n  if (result.error) return result;\n  const venue = result.venue;\n\n  const { matchUps } = getScheduledCourtMatchUps({\n    tournamentRecord,\n    courtId,\n  });\n\n  const appliedPolicies = getAppliedPolicies({\n    tournamentRecord,\n  })?.appliedPolicies;\n\n  const allowModificationWhenMatchUpsScheduled =\n    force ??\n    appliedPolicies?.[POLICY_TYPE_SCHEDULING]?.allowDeletionWithScoresPresent\n      ?.courts;\n\n  if (!matchUps?.length || allowModificationWhenMatchUpsScheduled) {\n    for (const matchUp of matchUps ?? []) {\n      const result = removeCourtAssignment({\n        matchUpId: matchUp.matchUpId,\n        drawId: matchUp.drawId,\n        tournamentRecord,\n      });\n      if (result.error) return result;\n    }\n\n    if (venue) {\n      venue.courts = (venue.courts ?? []).filter((courtRecord) => {\n        return courtRecord.courtId !== courtId;\n      });\n      if (!disableNotice)\n        addNotice({\n          payload: { venue, tournamentId: tournamentRecord.tournamentId },\n          topic: MODIFY_VENUE,\n          key: venue.venueId,\n        });\n    }\n  } else {\n    return deletionMessage({ matchUpsCount: matchUps.length });\n  }\n\n  return { ...SUCCESS };\n}\n","import { resolveTournamentRecords } from '../../parameters/resolveTournamentRecords';\nimport courtTemplate from '../../assemblies/generators/templates/courtTemplate';\nimport { modifyCourtAvailability } from './courtAvailability';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { addNotice } from '../../global/state/globalState';\nimport { findCourt } from './findCourt';\n\nimport { HydratedMatchUp, HydratedCourt } from '../../types/hydrated';\nimport { ResultType } from '../../global/functions/decorateResult';\nimport { MODIFY_VENUE } from '../../constants/topicConstants';\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { Tournament } from '../../types/tournamentTypes';\nimport {\n  INVALID_OBJECT,\n  MISSING_COURT_ID,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_TOURNAMENT_RECORDS,\n  NO_VALID_ATTRIBUTES,\n} from '../../constants/errorConditionConstants';\n\ntype ModifyCourtArgs = {\n  tournamentRecords?: TournamentRecords;\n  venueMatchUps?: HydratedMatchUp[];\n  tournamentRecord?: Tournament;\n  disableNotice?: boolean;\n  modifications: any;\n  courtId: string;\n  force?: boolean;\n};\n\nexport function modifyCourt(params: ModifyCourtArgs) {\n  const { disableNotice, modifications, courtId, force, venueMatchUps } =\n    params;\n  const tournamentRecords = resolveTournamentRecords(params);\n  if (!Object.keys(tournamentRecords).length)\n    return { error: MISSING_TOURNAMENT_RECORDS };\n\n  let courtModified;\n  let error;\n\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const result = courtModification({\n      tournamentRecord,\n      disableNotice,\n      venueMatchUps,\n      modifications,\n      courtId,\n      force,\n    });\n    if (result?.error) return result;\n    courtModified = true;\n  }\n\n  return courtModified ? { ...SUCCESS } : error;\n}\n\nexport function courtModification({\n  tournamentRecord,\n  disableNotice,\n  venueMatchUps,\n  modifications,\n  courtId,\n  force,\n}: ModifyCourtArgs): ResultType & { court?: HydratedCourt } {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!courtId) return { error: MISSING_COURT_ID };\n  if (!modifications || typeof modifications !== 'object')\n    return { error: INVALID_OBJECT };\n\n  const result = findCourt({ tournamentRecord, courtId });\n  if (result.error) return result;\n\n  const { venue, court } = result;\n\n  // not valid to modify a courtId\n  const validAttributes = Object.keys(courtTemplate()).filter(\n    (attribute) => attribute !== 'courtId'\n  );\n\n  const validModificationAttributes = Object.keys(modifications).filter(\n    (attribute) => validAttributes.includes(attribute)\n  );\n\n  if (!validModificationAttributes.length)\n    return { error: NO_VALID_ATTRIBUTES };\n\n  // not valid to replace the dateAvailability array\n  const validReplacements = validAttributes.filter(\n    (attribute) => !['dateAvailability'].includes(attribute)\n  );\n\n  const validReplacementAttributes = Object.keys(modifications).filter(\n    (attribute) => validReplacements.includes(attribute)\n  );\n\n  if (court)\n    validReplacementAttributes.forEach((attribute) =>\n      Object.assign(court, { [attribute]: modifications[attribute] })\n    );\n\n  if (modifications.dateAvailability) {\n    const result = modifyCourtAvailability({\n      dateAvailability: modifications.dateAvailability,\n      tournamentRecord,\n      venueMatchUps,\n      disableNotice,\n      courtId,\n      force,\n    });\n    if (result.error) return result;\n  }\n\n  if (!disableNotice) {\n    addNotice({\n      payload: { venue, tournamentId: tournamentRecord.tournamentId },\n      topic: MODIFY_VENUE,\n      key: venue?.venueId,\n    });\n  }\n\n  return { ...SUCCESS, court: makeDeepCopy(court) };\n}\n","export const venueTemplate = () => ({\n  venueId: undefined,\n  venueName: '',\n  venueAbbreviation: '',\n  onlineResources: [],\n  venueType: undefined,\n  addresses: [],\n  contacts: [],\n  courts: [],\n  roles: [],\n});\n\nexport default venueTemplate;\n","import { getScheduledCourtMatchUps, getScheduledVenueMatchUps } from '../../query/venues/getScheduledCourtMatchUps';\nimport { bulkScheduleTournamentMatchUps } from '../matchUps/schedule/bulkScheduleTournamentMatchUps';\nimport { deletionMessage } from '../../assemblies/generators/matchUps/deletionMessage';\nimport { resolveTournamentRecords } from '../../parameters/resolveTournamentRecords';\nimport { checkAndUpdateSchedulingProfile } from '../tournaments/schedulingProfile';\nimport venueTemplate from '../../assemblies/generators/templates/venueTemplate';\nimport { getAppliedPolicies } from '../../query/extensions/getAppliedPolicies';\nimport { makeDeepCopy } from '../../utilities/makeDeepCopy';\nimport { addNotice } from '../../global/state/globalState';\nimport { modifyCourt } from './modifyCourt';\nimport { addCourt } from './addCourt';\nimport { findVenue } from './findVenue';\n\nimport { POLICY_TYPE_SCHEDULING } from '../../constants/policyConstants';\nimport { Venue, Tournament } from '../../types/tournamentTypes';\nimport { MODIFY_VENUE } from '../../constants/topicConstants';\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  COURT_NOT_FOUND,\n  ErrorType,\n  INVALID_OBJECT,\n  MISSING_TOURNAMENT_RECORD,\n  MISSING_TOURNAMENT_RECORDS,\n  VENUE_NOT_FOUND,\n  MISSING_VENUE_ID,\n  NO_VALID_ATTRIBUTES,\n} from '../../constants/errorConditionConstants';\n\ntype ModifyVenueArgs = {\n  tournamentRecords?: TournamentRecords;\n  tournamentRecord?: Tournament;\n  modifications: any;\n  venueId: string;\n  force?: boolean;\n};\nexport function modifyVenue(params: ModifyVenueArgs) {\n  const { modifications, venueId, force } = params;\n\n  const tournamentRecords = resolveTournamentRecords(params);\n\n  if (!Object.keys(tournamentRecords).length) return { error: MISSING_TOURNAMENT_RECORDS };\n  if (typeof venueId !== 'string') return { error: MISSING_VENUE_ID };\n\n  let error;\n  let success;\n  // in this case suppress NOT FOUND errors if there is at least one success\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    const result = venueModify({\n      tournamentRecord,\n      modifications,\n      venueId,\n      force,\n    });\n    if (result.success) success = true;\n    if (result.error) error = result.error;\n    if (result.error && result.error !== VENUE_NOT_FOUND) return result;\n  }\n\n  checkAndUpdateSchedulingProfile({ tournamentRecords });\n\n  return success ? { ...SUCCESS } : { error };\n}\n\nexport function venueModify({ tournamentRecord, modifications, venueId, force }: ModifyVenueArgs): {\n  error?: ErrorType;\n  success?: boolean;\n  venue?: Venue;\n} {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!modifications || typeof modifications !== 'object') return { error: INVALID_OBJECT };\n  if (!venueId) return { error: MISSING_VENUE_ID };\n\n  const appliedPolicies = getAppliedPolicies({\n    tournamentRecord,\n  })?.appliedPolicies;\n\n  const allowModificationWhenMatchUpsScheduled =\n    force ?? appliedPolicies?.[POLICY_TYPE_SCHEDULING]?.allowDeletionWithScoresPresent?.venues;\n\n  const { matchUps: venueMatchUps } = getScheduledVenueMatchUps({\n    tournamentRecord,\n    venueId,\n  });\n\n  const result = findVenue({ tournamentRecord, venueId });\n  if (result.error) return result;\n  const venue = result.venue;\n\n  // not valid to modify a venueId\n  const validAttributes = Object.keys(venueTemplate()).filter((attribute) => attribute !== 'venueId');\n  const validModificationAttributes = Object.keys(modifications).filter((attribute) =>\n    validAttributes.includes(attribute),\n  );\n\n  if (!validModificationAttributes.length) return { error: NO_VALID_ATTRIBUTES };\n\n  const validReplacements = validAttributes.filter((attribute) => !['courts', 'onlineResources'].includes(attribute));\n\n  const validReplacementAttributes = Object.keys(modifications).filter((attribute) =>\n    validReplacements.includes(attribute),\n  );\n\n  venue &&\n    validReplacementAttributes.forEach((attribute) => Object.assign(venue, { [attribute]: modifications[attribute] }));\n\n  const existingCourtIds = venue?.courts?.map((court) => court.courtId) ?? [];\n  const courtIdsToModify = modifications.courts?.map((court) => court.courtId) || [];\n  const courtIdsToDelete =\n    courtIdsToModify.length && existingCourtIds.filter((courtId) => !courtIdsToModify.includes(courtId));\n\n  const matchUpsWithCourtId: { matchUpId: string; drawId: string }[] = [];\n  if (courtIdsToDelete.length) {\n    const courtsToDelete = venue?.courts?.filter((court) => courtIdsToDelete.includes(court.courtId));\n    const scheduleDeletionsCount = courtsToDelete\n      ?.map((court) => {\n        // check whether deleting court would remove schedule from any matchUps\n        const result = getScheduledCourtMatchUps({\n          courtId: court.courtId,\n          tournamentRecord,\n          venueMatchUps,\n        });\n        for (const matchUp of result.matchUps ?? []) {\n          matchUpsWithCourtId.push({\n            matchUpId: matchUp.matchUpId,\n            drawId: matchUp.drawId,\n          });\n        }\n        return result.matchUps?.length ?? 0;\n      })\n      .reduce((a, b) => a + b);\n\n    console.log({ scheduleDeletionsCount });\n\n    if (venue && (!scheduleDeletionsCount || allowModificationWhenMatchUpsScheduled)) {\n      venue.courts = venue.courts?.filter((court) => courtIdsToModify.includes(court.courtId));\n      bulkScheduleTournamentMatchUps({\n        schedule: { courtId: '', scheduledDate: '' },\n        matchUpDetails: matchUpsWithCourtId,\n        removePriorValues: true,\n        tournamentRecord,\n      });\n    } else {\n      return deletionMessage({\n        matchUpsCount: scheduleDeletionsCount,\n      });\n    }\n  }\n\n  if (modifications.courts) {\n    for (const court of modifications.courts) {\n      const { courtId } = court || {};\n      let result = modifyCourt({\n        modifications: court,\n        disableNotice: true,\n        tournamentRecord,\n        venueMatchUps,\n        courtId,\n        force,\n      });\n      if (result.error === COURT_NOT_FOUND) {\n        result = addCourt({\n          disableNotice: true,\n          tournamentRecord,\n          venueId,\n          court,\n        });\n      }\n      if (result.error) return result;\n    }\n  }\n\n  checkAndUpdateSchedulingProfile({ tournamentRecord });\n\n  if (venue) {\n    addNotice({\n      payload: { venue, tournamentId: tournamentRecord.tournamentId },\n      topic: MODIFY_VENUE,\n      key: venue?.venueId,\n    });\n  }\n\n  return { ...SUCCESS, venue: makeDeepCopy(venue) };\n}\n","import { modifyCourtAvailability } from '../../../mutate/venues/courtAvailability';\nimport { deleteVenue, deleteVenues } from '../../../mutate/venues/deleteVenue';\nimport { addCourt, addCourts } from '../../../mutate/venues/addCourt';\nimport { disableCourts } from '../../../mutate/venues/disableCourts';\nimport { disableVenues } from '../../../mutate/venues/disableVenues';\nimport { enableCourts } from '../../../mutate/venues/enableCourts';\nimport { enableVenues } from '../../../mutate/venues/enableVenues';\nimport { publicFindVenue } from '../../../mutate/venues/findVenue';\nimport { deleteCourt } from '../../../mutate/venues/deleteCourt';\nimport { modifyCourt } from '../../../mutate/venues/modifyCourt';\nimport { modifyVenue } from '../../../mutate/venues/modifyVenue';\nimport { addVenue } from '../../../mutate/venues/addVenue';\n\nexport const venueGovernor = {\n  addCourt,\n  addCourts,\n  addVenue,\n  deleteCourt,\n  deleteVenue,\n  deleteVenues,\n  disableCourts,\n  disableVenues,\n  enableCourts,\n  enableVenues,\n  findVenue: publicFindVenue,\n  modifyCourt,\n  modifyCourtAvailability,\n  modifyVenue,\n};\n\nexport default venueGovernor;\n","import { resolveTournamentRecords } from '../../parameters/resolveTournamentRecords';\nimport { checkRequiredParameters } from '../../parameters/checkRequiredParameters';\nimport { removeExtension } from '../extensions/removeExtension';\n\nimport { DISABLED } from '../../constants/extensionConstants';\nimport { TournamentRecords } from '../../types/factoryTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  TOURNAMENT_RECORDS,\n  VENUE_IDS,\n} from '../../constants/attributeConstants';\n\ntype EnableVenuesArgs = {\n  tournamentRecords: TournamentRecords;\n  enableAll?: boolean;\n  venueIds: string[];\n};\n\nexport function enableVenues(params: EnableVenuesArgs) {\n  const tournamentRecords = resolveTournamentRecords(params);\n  const paramsToCheck: any[] = [{ [TOURNAMENT_RECORDS]: true }];\n  !params.enableAll && paramsToCheck.push({ [VENUE_IDS]: true });\n  const paramCheck = checkRequiredParameters(params, paramsToCheck);\n  if (paramCheck.error) return paramCheck;\n\n  const { venueIds, enableAll } = params;\n  for (const tournamentRecord of Object.values(tournamentRecords)) {\n    for (const venue of tournamentRecord.venues || []) {\n      if (enableAll || venueIds?.includes(venue.venueId))\n        removeExtension({ element: venue, name: DISABLED });\n    }\n  }\n\n  return { ...SUCCESS };\n}\n","import competitionGovernor from './competitionGovernor';\nimport eventGovernor from './eventGovernor';\nimport generationGovernor from './generationGovernor';\nimport matchUpFormatGovernor from './matchUpFormatGovernor';\nimport mocksGovernor from './mocksGovernor';\nimport participantGovernor from './participantGovernor';\nimport policyGovernor from './policyGovernor';\nimport publishingGovernor from './publishingGovernor';\nimport queryGovernor from './queryGovernor';\nimport reportGovernor from './reportGovernor';\nimport scheduleGovernor from './scheduleGovernor';\nimport scoreGovernor from './scoreGovernor';\nimport tournamentGovernor from './tournamentGovernor';\nimport utilitiesGovernor from './utilitiesGovernor';\nimport venueGovernor from './venueGovernor';\n\nexport const governors = {\n  competitionGovernor,\n  eventGovernor,\n  generationGovernor,\n  matchUpFormatGovernor,\n  mocksGovernor,\n  participantGovernor,\n  policyGovernor,\n  publishingGovernor,\n  queryGovernor,\n  reportGovernor,\n  scheduleGovernor,\n  scoreGovernor,\n  tournamentGovernor,\n  utilitiesGovernor,\n  venueGovernor,\n};\n\nexport default governors;\n","export const forge = {};\n\nexport default forge;\n","import { callListener, getNotices, getTopics } from './globalState';\n\nimport {\n  ADD_DRAW_DEFINITION,\n  ADD_MATCHUPS,\n  DELETE_PARTICIPANTS,\n  DELETE_VENUE,\n  DELETED_DRAW_IDS,\n  DELETED_MATCHUP_IDS,\n  MODIFY_DRAW_DEFINITION,\n  MODIFY_DRAW_ENTRIES,\n  MODIFY_EVENT_ENTRIES,\n  MODIFY_MATCHUP,\n  MODIFY_PARTICIPANTS,\n  MODIFY_POSITION_ASSIGNMENTS,\n  MODIFY_SEED_ASSIGNMENTS,\n  MODIFY_VENUE,\n  UNPUBLISH_EVENT_SEEDING,\n  UNPUBLISH_EVENT,\n  UNPUBLISH_ORDER_OF_PLAY,\n  MUTATIONS,\n  UPDATE_INCONTEXT_MATCHUP,\n} from '../../constants/topicConstants';\n\ntype NotifySubscribersArgs = {\n  mutationStatus?: any;\n  tournamentId?: string;\n  directives?: any[];\n  timeStamp?: any;\n};\n\nexport function notifySubscribers(params?: NotifySubscribersArgs) {\n  const { mutationStatus, tournamentId, directives, timeStamp } = params || {};\n\n  const { topics } = getTopics();\n\n  for (const topic of [...topics].sort(topicSort)) {\n    const notices = getNotices({ topic });\n    if (notices) callListener({ topic, notices });\n  }\n\n  if (mutationStatus && timeStamp && topics.includes(MUTATIONS)) {\n    callListener({\n      notices: [{ tournamentId, directives, timeStamp }],\n      topic: MUTATIONS,\n    });\n  }\n}\n\nexport async function notifySubscribersAsync(params?: NotifySubscribersArgs) {\n  const { mutationStatus, tournamentId, directives, timeStamp } = params || {};\n  const { topics } = getTopics();\n\n  for (const topic of [...topics].sort(topicSort)) {\n    // only tested with packaged version of factory\n    // won't show up in test coverage\n    const notices = getNotices({ topic });\n    if (notices) await callListener({ topic, notices });\n  }\n\n  if (mutationStatus && timeStamp && topics.includes(MUTATIONS)) {\n    callListener({\n      notices: [{ tournamentId, directives, timeStamp }],\n      topic: MUTATIONS,\n    });\n  }\n}\n\nconst topicValues = {\n  [UNPUBLISH_EVENT_SEEDING]: 5,\n  [UNPUBLISH_EVENT]: 5,\n  [UNPUBLISH_ORDER_OF_PLAY]: 5,\n  [MODIFY_SEED_ASSIGNMENTS]: 5,\n  [MODIFY_POSITION_ASSIGNMENTS]: 5,\n  [MODIFY_DRAW_DEFINITION]: 5,\n  [MODIFY_DRAW_ENTRIES]: 5,\n  [MODIFY_EVENT_ENTRIES]: 5,\n  [MODIFY_MATCHUP]: 1,\n  [UPDATE_INCONTEXT_MATCHUP]: 1,\n  [MODIFY_PARTICIPANTS]: 5,\n  [MODIFY_VENUE]: 5,\n  [DELETED_MATCHUP_IDS]: 4,\n  [DELETE_PARTICIPANTS]: 4,\n  [DELETE_VENUE]: 4,\n  [DELETED_DRAW_IDS]: 4,\n  [ADD_MATCHUPS]: 3,\n  [ADD_DRAW_DEFINITION]: 2,\n};\n\nfunction topicSort(a, b) {\n  return (topicValues[b] || 0) - (topicValues[a] || 0);\n}\n","import { addExtension } from '../extensions/addExtension';\nimport { extensionConstants } from '../../constants/extensionConstants';\nimport { findExtension } from '../../acquire/findExtension';\n\nconst { FACTORY } = extensionConstants;\n\nexport function updateFactoryExtension({ tournamentRecord, value }) {\n  const { extension } = findExtension({\n    element: tournamentRecord,\n    name: FACTORY,\n  });\n\n  const updatedExtension = {\n    name: FACTORY,\n    value: {\n      ...extension?.value,\n      ...value,\n    },\n  };\n\n  addExtension({ element: tournamentRecord, extension: updatedExtension });\n}\n","import { updateFactoryExtension } from '../../../mutate/tournaments/updateFactoryExtension';\nimport { factoryVersion } from '../../../global/functions/factoryVersion';\nimport {\n  cycleMutationStatus,\n  getTournamentRecords,\n} from '../../../global/state/globalState';\n\nexport function getMutationStatus({ timeStamp }): boolean {\n  const tournamentRecords = getTournamentRecords();\n  const mutationStatus = cycleMutationStatus();\n  if (mutationStatus) {\n    Object.values(tournamentRecords).forEach((tournamentRecord) => {\n      updateFactoryExtension({\n        tournamentRecord,\n        value: {\n          version: factoryVersion(),\n          timeStamp,\n        },\n      });\n    });\n  }\n  return mutationStatus;\n}\n","import { ResultType } from './decorateResult';\nimport { DevContextType, getDevContext, globalLog } from '../state/globalState';\n\ntype EngineLoggingArgs = {\n  params?: { [key: string]: any } | boolean;\n  result: ResultType;\n  engineType: string;\n  methodName: string;\n  elapsed: number;\n};\n\nexport function engineLogging({\n  engineType,\n  methodName,\n  elapsed,\n  params,\n  result,\n}: EngineLoggingArgs) {\n  const devContext: DevContextType = getDevContext();\n  if (typeof devContext !== 'object') return;\n\n  const log: any = { method: methodName };\n  const logError =\n    result?.error &&\n    (devContext.errors === true ||\n      (Array.isArray(devContext.errors) &&\n        devContext.errors.includes(methodName)));\n\n  const specifiedMethodParams =\n    Array.isArray(devContext.params) && devContext.params?.includes(methodName);\n\n  const logParams =\n    (devContext.params && !Array.isArray(devContext.params)) ||\n    specifiedMethodParams;\n\n  const exclude =\n    Array.isArray(devContext.exclude) &&\n    devContext.exclude.includes(methodName);\n\n  if (\n    !exclude &&\n    ![undefined, false].includes(devContext.perf) &&\n    !isNaN(devContext.perf) &&\n    elapsed >= devContext.perf\n  ) {\n    log.elapsed = elapsed;\n  }\n\n  if (!exclude && (logError || logParams)) {\n    log.params = params;\n  }\n\n  if (\n    !exclude &&\n    (logError ||\n      (devContext.result &&\n        !Array.isArray(devContext.result) &&\n        (!Array.isArray(devContext.params) || specifiedMethodParams)) ||\n      (Array.isArray(devContext.result) &&\n        devContext.result?.includes(methodName)))\n  ) {\n    log.result = result;\n  }\n\n  if (Object.keys(log).length > 1) globalLog(engineType, log);\n}\n","import { engineLogging } from '../../../global/functions/engineLogging';\n\nimport { METHOD_NOT_FOUND } from '../../../constants/errorConditionConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\n\ntype LogMethodNotFoundArgs = {\n  params?: { [key: string]: any };\n  methodName: string;\n  start?: number;\n};\n\nexport function logMethodNotFound({\n  methodName,\n  params,\n  start,\n}: LogMethodNotFoundArgs): ResultType {\n  const result = { error: METHOD_NOT_FOUND, methodName };\n  const elapsed = start ? Date.now() - start : 0;\n  engineLogging({\n    result,\n    methodName,\n    elapsed,\n    params,\n    engineType: 'sync',\n  });\n  return result;\n}\n","import { engineLogging } from '../../../global/functions/engineLogging';\nimport { paramsMiddleware } from './paramsMiddleware';\nimport {\n  getDevContext,\n  getTournamentId,\n  getTournamentRecord,\n  getTournamentRecords,\n  handleCaughtError,\n} from '../../../global/state/globalState';\n\nimport { INVALID_VALUES } from '../../../constants/errorConditionConstants';\nimport { FactoryEngine } from '../../../types/factoryTypes';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\n\n/**\n * Executes a function within a FactoryEngine.\n *\n * @param engine - The FactoryEngine object.\n * @param method - The function to be executed.\n * @param params - The parameters to be passed to the function.\n * @param methodName - The name of the method being executed.\n * @param engineType - The type of the engine.\n * @returns The result of the function execution.\n */\n\nexport function executeFunction(\n  engine: FactoryEngine,\n  method: any,\n  params: { [key: string]: any } | undefined,\n  methodName: string,\n  engineType: string,\n) {\n  delete engine.success;\n  delete engine.error;\n\n  const start = Date.now();\n  const tournamentId = getTournamentId();\n  if (params) params.activeTournamentId = tournamentId;\n\n  if (params?.sandboxTournament && !params?.sandboxTournament.tournamentId) return { error: INVALID_VALUES };\n\n  const tournamentRecord = params?.sandboxTournament || getTournamentRecord(tournamentId);\n\n  const tournamentRecords = params?.sandboxTournament\n    ? { [params?.sandboxTournament.tournamentId]: params.sandboxTournament }\n    : getTournamentRecords();\n\n  // ENSURE that logged params are not mutated by middleware\n  const paramsToLog = params ? makeDeepCopy(params, undefined, true) : undefined;\n  const augmentedParams = params ? paramsMiddleware(tournamentRecords, params) : undefined;\n  if (augmentedParams?.error) return augmentedParams;\n\n  const result = invoke({\n    params: augmentedParams,\n    tournamentRecords,\n    tournamentRecord,\n    methodName,\n    method,\n  });\n  const elapsed = Date.now() - start;\n  engineLogging({ result, methodName, elapsed, params: paramsToLog, engineType });\n\n  return result;\n}\n\nfunction invoke({ tournamentRecords, tournamentRecord, params, methodName, method }) {\n  if (getDevContext()) {\n    return method({ tournamentRecords, tournamentRecord, ...params });\n  } else {\n    try {\n      return method({ tournamentRecords, tournamentRecord, ...params });\n    } catch (err) {\n      return handleCaughtError({\n        engineName: 'engine',\n        methodName,\n        params,\n        err,\n      });\n    }\n  }\n}\n","import { getTournamentId } from '../../../global/state/globalState';\nimport { findEvent } from '../../../acquire/findEvent';\n\nimport { TournamentRecords } from '../../../types/factoryTypes';\nimport {\n  EVENT_NOT_FOUND,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../../constants/errorConditionConstants';\n\nexport function paramsMiddleware(\n  tournamentRecords: TournamentRecords,\n  params: { [key: string]: any }\n) {\n  if (params._middleware === false) return params;\n\n  // first check validity of params.tournamentId, if present\n  if (params.tournamentId && !tournamentRecords[params.tournamentId]) {\n    return { error: MISSING_TOURNAMENT_RECORD };\n  }\n\n  const drawId = params.drawId || params.matchUp?.drawId;\n\n  if (drawId) {\n    const { event, drawDefinition, tournamentId } = findEvent({\n      tournamentRecords,\n      drawId,\n    });\n    // NOTE: not important if nothing is found; will overwrite params.drawDefinition, params.event, and params.tournamentId\n    if (drawDefinition) params.drawDefinition = drawDefinition;\n    if (tournamentId) params.tournamentId = tournamentId;\n    if (event) params.event = event;\n  }\n\n  if (params.eventId && !params.event) {\n    const { event, tournamentId } = findEvent({\n      eventId: params.eventId,\n      tournamentRecords,\n    });\n    if (!event) return { error: EVENT_NOT_FOUND };\n    // NOTE:  will overwrite params.event, and params.tournamentId\n    params.tournamentId = tournamentId;\n    params.event = event;\n  }\n\n  const tournamentId = params.tournamentId ?? getTournamentId();\n  if (!tournamentId && params) return params;\n\n  const tournamentRecord = tournamentRecords[tournamentId];\n  if (tournamentId && !tournamentRecord) {\n    return { error: MISSING_TOURNAMENT_RECORD };\n  }\n\n  if (!tournamentRecord) return params;\n  params.tournamentRecord = tournamentRecord;\n\n  return params;\n}\n","import { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { findExtension } from '../../../acquire/findExtension';\nimport {\n  getTournamentId,\n  getTournamentRecords,\n  setTournamentRecords,\n  setTournamentRecord as globalSetTournamentRecord,\n  getTournamentRecord,\n  setTournamentId,\n} from '../../../global/state/globalState';\n\nimport { LINKED_TOURNAMENTS } from '../../../constants/extensionConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport {\n  INVALID_OBJECT,\n  INVALID_RECORDS,\n  INVALID_VALUES,\n} from '../../../constants/errorConditionConstants';\n\ntype GetStateArgs = {\n  convertExtensions?: boolean;\n  removeExtensions?: boolean;\n};\nexport function getState({\n  convertExtensions,\n  removeExtensions,\n}: GetStateArgs) {\n  const tournamentRecords = getTournamentRecords();\n  const tournamentId = getTournamentId();\n  return {\n    tournamentId,\n    tournamentRecords: makeDeepCopy(\n      tournamentRecords,\n      convertExtensions,\n      false,\n      removeExtensions\n    ),\n  };\n}\n\ntype GetTournamentArgs = {\n  convertExtensions?: boolean;\n  removeExtensions?: boolean;\n  tournamentId: string | undefined;\n};\n\nexport function getTournament(params?: GetTournamentArgs) {\n  const { convertExtensions = false, removeExtensions = false } = params ?? {};\n  const tournamentId = params?.tournamentId ?? getTournamentId();\n  if (typeof tournamentId !== 'string') return {};\n  const tournamentRecord = getTournamentRecord(tournamentId);\n  return {\n    tournamentRecord: makeDeepCopy(\n      tournamentRecord,\n      convertExtensions,\n      false,\n      removeExtensions\n    ),\n  };\n}\n\nexport function removeUnlinkedTournamentRecords(): void {\n  const tournamentRecords = getTournamentRecords();\n\n  const { extension } = findExtension({\n    name: LINKED_TOURNAMENTS,\n    tournamentRecords,\n    discover: true,\n  });\n\n  const tournamentIds = extension?.value?.tournamentIds || [];\n  Object.keys(tournamentRecords).forEach((tournamentId) => {\n    if (!tournamentIds.includes(tournamentId))\n      delete tournamentRecords[tournamentId];\n  });\n\n  return setTournamentRecords(tournamentRecords);\n}\n\nexport function setTournamentRecord(record, deepCopyOption = true): ResultType {\n  if (typeof record !== 'object' || Array.isArray(record))\n    return { error: INVALID_OBJECT };\n\n  if (!record?.tournamentId) return { error: INVALID_VALUES };\n\n  return globalSetTournamentRecord(\n    deepCopyOption ? makeDeepCopy(record) : record\n  );\n}\n\nexport function setState(records, deepCopyOption = true) {\n  if (typeof records !== 'object') return { error: INVALID_OBJECT };\n\n  setTournamentId();\n  if (Array.isArray(records)) {\n    const validRecordsArray =\n      records.filter((record) => record?.tournamentId).length ===\n      records.length;\n\n    if (!validRecordsArray) return { error: INVALID_RECORDS };\n\n    records = Object.assign(\n      {},\n      ...records.map((record) => ({ [record.tournamentId]: record }))\n    );\n  } else if (records?.tournamentId) {\n    records = { [records.tournamentId]: records };\n    setTournamentId(records.tournamentId);\n  } else {\n    const validRecordsObject = Object.keys(records).every(\n      (tournamentId) => records[tournamentId].tournamentId === tournamentId\n    );\n    if (!validRecordsObject) return { error: INVALID_RECORDS };\n  }\n\n  return setTournamentRecords(deepCopyOption ? makeDeepCopy(records) : records);\n}\n","import { notifySubscribersAsync } from '../../../global/state/notifySubscribers';\nimport { isFunction, isObject, isString } from '../../../utilities/objects';\nimport { getMethods } from '../../../global/state/syncGlobalState';\nimport { getMutationStatus } from '../parts/getMutationStatus';\nimport { logMethodNotFound } from '../parts/logMethodNotFound';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { executeFunction } from '../parts/executeMethod';\nimport { setState } from '../parts/stateMethods';\nimport {\n  deleteNotices,\n  getTournamentRecords,\n} from '../../../global/state/globalState';\n\nimport {\n  INVALID_VALUES,\n  METHOD_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\n\nexport async function asyncEngineInvoke(\n  engine: { [key: string]: any },\n  args: any\n) {\n  if (!isObject(args))\n    return { error: INVALID_VALUES, message: 'args must be an object' };\n  const methodsCount = Object.values(args).filter(isFunction).length;\n  if (methodsCount > 1)\n    return {\n      message: 'there must be only one arg with typeof function',\n      error: INVALID_VALUES,\n    };\n\n  const methodName = methodsCount\n    ? Object.keys(args).find((key) => isFunction(args[key]))\n    : isString(args.method) && args.method;\n  if (!methodName) return { error: METHOD_NOT_FOUND };\n\n  const { [methodName]: passedMethod, ...remainingArgs } = args;\n  const params = args?.params || { ...remainingArgs };\n\n  const snapshot =\n    params.rollbackOnError && makeDeepCopy(getTournamentRecords(), false, true);\n\n  const method = passedMethod || engine[methodName] || getMethods()[methodName];\n  if (!method) return logMethodNotFound({ methodName, params });\n\n  const result =\n    (await executeFunction(engine, method, params, methodName, 'async')) ?? {};\n\n  if (result?.error && snapshot) setState(snapshot);\n\n  const timeStamp = Date.now();\n  const mutationStatus = getMutationStatus({ timeStamp });\n\n  const notify =\n    result?.success &&\n    params?.delayNotify !== true &&\n    params?.doNotNotify !== true;\n\n  if (notify)\n    await notifySubscribersAsync({\n      directives: [{ method, params }],\n      mutationStatus,\n      timeStamp,\n    });\n  if (notify || !result?.success || params?.doNotNotify) deleteNotices();\n\n  return result;\n}\n","export function processResult(engine, result?) {\n  if (result?.error) {\n    engine.error = result.error;\n    engine.success = false;\n  } else {\n    engine.error = undefined;\n    engine.success = true;\n  }\n  return engine;\n}\n","/**\n * Starts the engine by initializing its methods and properties.\n * @param engine - The FactoryEngine object.\n * @param engineInvoke - The engineInvoke object.\n */\n\nimport { newTournamentRecord } from '../../generators/tournamentRecords/newTournamentRecord';\nimport { factoryVersion } from '../../../global/functions/factoryVersion';\nimport { importMethods } from '../parts/importMethods';\nimport { processResult } from '../parts/processResult';\nimport {\n  setDeepCopy,\n  setDevContext,\n  getDevContext,\n  removeTournamentRecord,\n  setTournamentRecords,\n  setTournamentId,\n  getTournamentId,\n} from '../../../global/state/globalState';\nimport {\n  getState,\n  getTournament,\n  removeUnlinkedTournamentRecords,\n  setState,\n  setTournamentRecord,\n} from '../parts/stateMethods';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { FactoryEngine } from '../../../types/factoryTypes';\n\nexport function engineStart(engine: FactoryEngine, engineInvoke: any): void {\n  engine.importMethods = (methods) =>\n    importMethods(engine, engineInvoke, methods);\n  engine.getTournament = (params?) => getTournament(params);\n  engine.getState = (params?) =>\n    getState({\n      convertExtensions: params?.convertExtensions,\n      removeExtensions: params?.removeExtensions,\n    });\n  engine.version = () => factoryVersion();\n  engine.reset = () => {\n    setTournamentRecords({});\n    return processResult(engine);\n  };\n  engine.devContext = (contextCriteria) => {\n    setDevContext(contextCriteria);\n    return processResult(engine);\n  };\n  engine.getDevContext = (contextCriteria) => getDevContext(contextCriteria);\n  engine.newTournamentRecord = (params = {}) => {\n    const result = newTournamentRecord(params);\n    const tournamentId = result.tournamentId;\n    if (result.error) return result;\n    setTournamentRecord(result);\n    setTournamentId(tournamentId);\n    return { ...SUCCESS, tournamentId };\n  };\n  engine.setState = (records, deepCopyOption, deepCopyAttributes) => {\n    setDeepCopy(deepCopyOption, deepCopyAttributes);\n    const result = setState(records, deepCopyOption);\n    return processResult(engine, result);\n  };\n  engine.setTournamentId = (tournamentId) => setTournamentId(tournamentId);\n  engine.getTournamentId = () => getTournamentId();\n  engine.setTournamentRecord = (\n    tournamentRecord,\n    deepCopyOption,\n    deepCopyAttributes\n  ) => {\n    setDeepCopy(deepCopyOption, deepCopyAttributes);\n    const result = setTournamentRecord(tournamentRecord, deepCopyOption);\n    return processResult(engine, result);\n  };\n  engine.removeTournamentRecord = (tournamentId) => {\n    const result = removeTournamentRecord(tournamentId);\n    return processResult(engine, result);\n  };\n  engine.removeUnlinkedTournamentRecords = () => {\n    const result = removeUnlinkedTournamentRecords();\n    return processResult(engine, result);\n  };\n}\n","import { isFunction, isObject } from '../../../utilities/objects';\nimport {\n  getDevContext,\n  handleCaughtError,\n  setMethods,\n} from '../../../global/state/globalState';\n\nimport { INVALID_VALUES } from '../../../constants/errorConditionConstants';\nimport { ResultType } from '../../../global/functions/decorateResult';\nimport { SUCCESS } from '../../../constants/resultConstants';\n\nexport function importMethods(engine, engineInvoke, methods): ResultType {\n  if (!isObject(methods)) return { error: INVALID_VALUES };\n  setMethods(methods);\n  const methodNames = Object.keys(methods).filter((key) =>\n    isFunction(methods[key])\n  );\n  methodNames.forEach((methodName) => {\n    engine[methodName] = (params) => {\n      const invoke = () =>\n        engineInvoke(engine, {\n          [methodName]: methods[methodName],\n          ...params,\n        });\n\n      if (getDevContext()) {\n        return invoke();\n      } else {\n        try {\n          return invoke();\n        } catch (err) {\n          handleCaughtError({\n            engineName: 'engine',\n            methodName,\n            params,\n            err,\n          });\n        }\n      }\n    };\n  });\n\n  return { ...SUCCESS, ...engine };\n}\n","import { createInstanceState } from '../../../global/state/globalState';\nimport { asyncExecutionQueue } from './asyncExecutionQueue';\nimport { asyncEngineInvoke } from './asyncEngineInvoke';\nimport { engineStart } from '../parts/engineStart';\n\nimport { Directives, FactoryEngine } from '../../../types/factoryTypes';\n\nexport function asyncEngine(test?: boolean): FactoryEngine & { error?: any } {\n  const result = createInstanceState();\n  if (result.error && !test) return result;\n\n  const engine: FactoryEngine = {\n    executionQueue: (directives: Directives, rollbackOnError?: boolean) =>\n      asyncExecutionQueue(engine, directives, rollbackOnError),\n    execute: (args: any) => asyncEngineInvoke(engine, args),\n  };\n\n  engineStart(engine, asyncEngineInvoke);\n\n  return engine;\n}\n\nexport default asyncEngine;\n","import { deleteNotices, getTournamentRecords, getMethods } from '../../../global/state/globalState';\nimport { notifySubscribersAsync } from '../../../global/state/notifySubscribers';\nimport { getMutationStatus } from '../parts/getMutationStatus';\nimport { logMethodNotFound } from '../parts/logMethodNotFound';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { executeFunction } from '../parts/executeMethod';\nimport { setState } from '../parts/stateMethods';\n\nimport { INVALID_VALUES } from '../../../constants/errorConditionConstants';\nimport { Directives, FactoryEngine } from '../../../types/factoryTypes';\n\nexport async function asyncExecutionQueue(engine: FactoryEngine, directives: Directives, rollbackOnError?: boolean) {\n  if (!Array.isArray(directives)) return { error: INVALID_VALUES, message: 'directives must be an array' };\n\n  const methods = getMethods();\n  const start = Date.now();\n\n  const snapshot = rollbackOnError && makeDeepCopy(getTournamentRecords(), false, true);\n\n  const results: any[] = [];\n  for (const directive of directives) {\n    if (typeof directive !== 'object') return { error: INVALID_VALUES, message: 'directive must be an object' };\n\n    const { method: methodName, params = {}, pipe } = directive;\n    if (!methods[methodName]) return logMethodNotFound({ methodName, start, params });\n\n    if (pipe) {\n      const lastResult = results[results.length - 1];\n      const pipeKeys = Object.keys(pipe);\n      for (const pipeKey of pipeKeys) {\n        if (lastResult[pipeKey]) params[pipeKey] = lastResult[pipeKey];\n      }\n    }\n\n    const result = executeFunction(engine, methods[methodName], params, methodName, 'async');\n\n    if (result?.error) {\n      if (snapshot) setState(snapshot);\n      return { ...result, rolledBack: !!snapshot };\n    }\n    results.push({ ...result, methodName });\n  }\n  const timeStamp = Date.now();\n\n  const mutationStatus = getMutationStatus({ timeStamp });\n  notifySubscribersAsync({ directives, mutationStatus, timeStamp });\n  deleteNotices();\n\n  const success = results.every((r) => r.success);\n\n  return { success, results };\n}\n","import { isFunction, isObject, isString } from '../../../utilities/objects';\nimport { getMethods } from '../../../global/state/syncGlobalState';\nimport { logMethodNotFound } from '../parts/logMethodNotFound';\nimport { executeFunction } from '../parts/executeMethod';\n\nimport {\n  INVALID_VALUES,\n  METHOD_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\n\nexport function askInvoke(engine: { [key: string]: any }, args: any) {\n  if (!isObject(args))\n    return { error: INVALID_VALUES, message: 'args must be an object' };\n  const methodsCount = Object.values(args).filter(isFunction).length;\n  if (methodsCount > 1)\n    return {\n      message: 'there must be only one arg with typeof function',\n      error: INVALID_VALUES,\n    };\n\n  const methodName = methodsCount\n    ? Object.keys(args).find((key) => isFunction(args[key]))\n    : isString(args.method) && args.method;\n  if (!methodName) return { error: METHOD_NOT_FOUND };\n\n  const { [methodName]: passedMethod, ...remainingArgs } = args;\n  const params = args?.params || { ...remainingArgs };\n\n  const method = passedMethod || engine[methodName] || getMethods()[methodName];\n  if (!method) return logMethodNotFound({ methodName, params });\n\n  return executeFunction(engine, method, params, methodName, 'ask');\n}\n","import { askInvoke } from './askInvoke';\n\nimport { FactoryEngine } from '../../../types/factoryTypes';\nimport { engineStart } from '../parts/engineStart';\n\nexport const askEngine = (() => {\n  const engine: FactoryEngine = {\n    execute: (args: any) => askInvoke(engine, args),\n  };\n\n  engineStart(engine, askInvoke);\n\n  return engine;\n})();\n\nexport default askEngine;\n","import { isFunction, isObject, isString } from '../../../utilities/objects';\nimport { notifySubscribers } from '../../../global/state/notifySubscribers';\nimport { getMethods } from '../../../global/state/syncGlobalState';\nimport { logMethodNotFound } from '../parts/logMethodNotFound';\nimport { getMutationStatus } from '../parts/getMutationStatus';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { executeFunction } from '../parts/executeMethod';\nimport { setState } from '../parts/stateMethods';\nimport {\n  deleteNotices,\n  getTournamentRecords,\n} from '../../../global/state/globalState';\n\nimport {\n  INVALID_VALUES,\n  METHOD_NOT_FOUND,\n} from '../../../constants/errorConditionConstants';\n\nexport function engineInvoke(engine: { [key: string]: any }, args: any) {\n  if (!isObject(args))\n    return { error: INVALID_VALUES, message: 'args must be an object' };\n  const methodsCount = Object.values(args).filter(isFunction).length;\n  if (methodsCount > 1)\n    return {\n      message: 'there must be only one arg with typeof function',\n      error: INVALID_VALUES,\n    };\n\n  const methodName = methodsCount\n    ? Object.keys(args).find((key) => isFunction(args[key]))\n    : isString(args.method) && args.method;\n  if (!methodName) return { error: METHOD_NOT_FOUND };\n\n  const { [methodName]: passedMethod, ...remainingArgs } = args;\n  const params = args?.params || { ...remainingArgs };\n\n  const snapshot =\n    params.rollbackOnError && makeDeepCopy(getTournamentRecords(), false, true);\n\n  const method = passedMethod || engine[methodName] || getMethods()[methodName];\n  if (!method) return logMethodNotFound({ methodName, params });\n\n  const result =\n    executeFunction(engine, method, params, methodName, 'sync') ?? {};\n\n  if (result?.error && snapshot) setState(snapshot);\n\n  const timeStamp = Date.now();\n  const mutationStatus = getMutationStatus({ timeStamp });\n\n  const notify =\n    result?.success &&\n    params?.delayNotify !== true &&\n    params?.doNotNotify !== true;\n  if (notify)\n    notifySubscribers({\n      directives: [{ method, params }],\n      mutationStatus,\n      timeStamp,\n    });\n  if (notify || !result?.success || params?.doNotNotify) deleteNotices();\n\n  return result;\n}\n","import { engineStart } from '../parts/engineStart';\nimport { executionQueue } from './executionQueue';\nimport { engineInvoke } from './engineInvoke';\n\nimport { Directives, FactoryEngine } from '../../../types/factoryTypes';\n\nexport const engine = ((): FactoryEngine => {\n  const engine: FactoryEngine = {\n    executionQueue: (directives: Directives, rollbackOnError?: boolean) =>\n      executionQueue(engine, directives, rollbackOnError),\n    execute: (args: any) => engineInvoke(engine, args),\n  };\n\n  engineStart(engine, engineInvoke);\n\n  return engine;\n})();\n\nexport default engine;\n","import { deleteNotices, getTournamentRecords, getMethods } from '../../../global/state/globalState';\nimport { notifySubscribers } from '../../../global/state/notifySubscribers';\nimport { getMutationStatus } from '../parts/getMutationStatus';\nimport { logMethodNotFound } from '../parts/logMethodNotFound';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { executeFunction } from '../parts/executeMethod';\nimport { setState } from '../parts/stateMethods';\n\nimport { INVALID_VALUES } from '../../../constants/errorConditionConstants';\nimport { Directives, FactoryEngine } from '../../../types/factoryTypes';\n\nexport function executionQueue(engine: FactoryEngine, directives: Directives, rollbackOnError?: boolean) {\n  if (!Array.isArray(directives)) return { error: INVALID_VALUES, message: 'directives must be an array' };\n\n  const methods = getMethods();\n  const start = Date.now();\n\n  const snapshot = rollbackOnError && makeDeepCopy(getTournamentRecords(), false, true);\n\n  const results: any[] = [];\n  for (const directive of directives) {\n    if (typeof directive !== 'object') return { error: INVALID_VALUES, message: 'directive must be an object' };\n\n    const { method: methodName, params = {}, pipe } = directive;\n    if (!methods[methodName]) return logMethodNotFound({ methodName, start, params });\n\n    if (pipe) {\n      const lastResult = results[results.length - 1];\n      const pipeKeys = Object.keys(pipe);\n      for (const pipeKey of pipeKeys) {\n        if (lastResult[pipeKey]) params[pipeKey] = lastResult[pipeKey];\n      }\n    }\n\n    const result = executeFunction(engine, methods[methodName], params, methodName, 'sync');\n\n    if (result?.error) {\n      if (snapshot) setState(snapshot);\n      return { ...result, rolledBack: !!snapshot };\n    }\n    results.push({ ...result, methodName });\n  }\n  const timeStamp = Date.now();\n\n  const mutationStatus = getMutationStatus({ timeStamp });\n  notifySubscribers({ directives, mutationStatus, timeStamp });\n  deleteNotices();\n\n  const success = results.every((r) => r.success);\n\n  return { success, results };\n}\n","import competitionGovernor from '../../../assemblies/governors/competitionGovernor';\nimport participantGovernor from '../../../assemblies/governors/participantGovernor';\nimport generationGovernor from '../../../assemblies/governors/generationGovernor';\nimport publishingGovernor from '../../../assemblies/governors/publishingGovernor';\nimport scheduleGovernor from '../../../assemblies/governors/scheduleGovernor';\nimport reportGovernor from '../../../assemblies/governors/reportGovernor';\nimport scoreGovernor from '../../../assemblies/governors/scoreGovernor';\nimport venueGovernor from '../../../assemblies/governors/venueGovernor';\n\nimport tournamentGovernor from '../../../assemblies/governors/tournamentGovernor';\nimport policyGovernor from '../../../assemblies/governors/policyGovernor';\nimport queryGovernor from '../../../assemblies/governors/queryGovernor';\nimport eventGovernor from '../../../assemblies/governors/eventGovernor';\n\nimport syncEngine from '../../../assemblies/engines/sync';\n\nconst methods = {\n  ...competitionGovernor,\n  ...participantGovernor,\n  ...publishingGovernor,\n  ...generationGovernor,\n  ...tournamentGovernor,\n  ...scheduleGovernor,\n  ...policyGovernor,\n  ...reportGovernor,\n  ...eventGovernor,\n  ...queryGovernor,\n  ...scoreGovernor,\n  ...venueGovernor,\n};\n\nsyncEngine.importMethods(methods);\n\nexport const competitionEngine = syncEngine;\nexport const tournamentEngine = syncEngine;\nexport default syncEngine;\n","import { makeDeepCopy } from '../../../utilities/makeDeepCopy';\nimport { MatchUp } from '../../../types/tournamentTypes';\nimport {\n  INVALID_OBJECT,\n  MISSING_VALUE,\n} from '../../../constants/errorConditionConstants';\n\ntype MatchUpArg = {\n  [key: string | number | symbol]: unknown;\n} & MatchUp;\n\n// TASK: add verify/validate structure as option in setState\n\nlet keyedMatchUps = {};\nlet matchUpId;\n\nexport function setState(value: MatchUpArg, deepCopyOption = true) {\n  if (!value) return { error: MISSING_VALUE };\n  if (typeof value !== 'object') return { error: INVALID_OBJECT };\n\n  if (value.matchUpId) {\n    matchUpId = value.matchUpId;\n    keyedMatchUps[matchUpId] = deepCopyOption ? makeDeepCopy(value) : value;\n  } else if (Array.isArray(value)) {\n    for (const m of value.reverse()) {\n      if (m.matchUpId) {\n        keyedMatchUps[m.matchUpId] = deepCopyOption ? makeDeepCopy(m) : m;\n        if (!matchUpId) matchUpId = m.matchUpId;\n      }\n    }\n  } else {\n    for (const m of Object.values(value) as Array<MatchUpArg>) {\n      if (m.matchUpId) {\n        keyedMatchUps[m.matchUpId] = deepCopyOption ? makeDeepCopy(m) : m;\n        if (!matchUpId) matchUpId = m.matchUpId;\n      }\n    }\n  }\n\n  return deepCopyOption ? makeDeepCopy(value) : value;\n}\n\nexport function getMatchUp() {\n  return keyedMatchUps[matchUpId];\n}\n\nexport function getMatchUps() {\n  return Object.values(keyedMatchUps);\n}\n\nexport function reset() {\n  matchUpId = undefined;\n  keyedMatchUps = {};\n}\n\nexport function getState(params?) {\n  return makeDeepCopy(\n    keyedMatchUps[matchUpId],\n    params?.convertExtensions,\n    false,\n    params?.removeExtensions\n  );\n}\n","import scoreGovernor from '../../governors/scoreGovernor';\nimport { makeDeepCopy } from '../../../utilities/makeDeepCopy';\n\nimport { notifySubscribers } from '../../../global/state/notifySubscribers';\nimport { factoryVersion } from '../../../global/functions/factoryVersion';\nimport {\n  setDeepCopy,\n  setDevContext,\n  getDevContext,\n  deleteNotices,\n  handleCaughtError,\n} from '../../../global/state/globalState';\nimport {\n  getMatchUps,\n  getMatchUp,\n  setState,\n  getState,\n  reset,\n} from './stateMethods';\n\nimport { SUCCESS } from '../../../constants/resultConstants';\nimport { FactoryEngine } from '../../../types/factoryTypes';\n\nexport const matchUpEngine = (() => {\n  const engine: FactoryEngine = {\n    getState: (params) => getState(params),\n    version: () => factoryVersion(),\n    reset: () => {\n      reset();\n      return { ...SUCCESS };\n    },\n    drawId: undefined,\n    error: undefined,\n    success: false,\n    devContext: (contextCriteria) => {\n      setDevContext(contextCriteria);\n      return engine;\n    },\n    setState: (definition, deepCopyOption, deepCopyAttributes) => {\n      setDeepCopy(deepCopyOption, deepCopyAttributes);\n      const result = setState(definition);\n      return processResult(result);\n    },\n  };\n\n  function processResult(result) {\n    if (result?.error) {\n      engine.error = result.error;\n      engine.success = false;\n    } else {\n      engine.error = undefined;\n      engine.success = true;\n      engine.drawId = result.drawId;\n    }\n    return engine;\n  }\n\n  importGovernors([scoreGovernor]);\n\n  return engine;\n\n  function importGovernors(governors) {\n    governors.forEach((governor) => {\n      Object.keys(governor).forEach((methodName) => {\n        engine[methodName] = (params) => {\n          if (getDevContext()) {\n            return invoke({ params, governor, methodName });\n          } else {\n            try {\n              return invoke({ params, governor, methodName });\n            } catch (err) {\n              handleCaughtError({\n                engineName: 'matchUpEngine',\n                methodName,\n                params,\n                err,\n              });\n            }\n          }\n        };\n      });\n    });\n  }\n\n  function invoke({ params, governor, methodName }) {\n    engine.error = undefined;\n    engine.success = false;\n\n    const matchUp = params?.matchUp || getMatchUp();\n    const matchUps = params?.matchUps || getMatchUps();\n\n    const snapshot =\n      params?.rollbackOnError && makeDeepCopy(matchUp, false, true);\n\n    params = {\n      ...params,\n      matchUpId: matchUp?.matchUpId,\n      matchUps,\n      matchUp,\n    };\n\n    const result = governor[methodName](params);\n\n    if (result?.error) {\n      if (snapshot) setState(snapshot);\n      return { ...result, rolledBack: !!snapshot };\n    }\n\n    const notify =\n      result?.success &&\n      params?.delayNotify !== true &&\n      params?.doNotNotify !== true;\n    if (notify) notifySubscribers();\n    if (notify || !result?.success || params?.doNotNotify) deleteNotices();\n\n    return result;\n  }\n})();\n\nexport default matchUpEngine;\n","import { deleteNotices, setDevContext, setDeepCopy } from '../../../global/state/globalState';\nimport { notifySubscribers } from '../../../global/state/notifySubscribers';\nimport { factoryVersion } from '../../../global/functions/factoryVersion';\nimport mocksGovernor from '../../governors/mocksGovernor';\n\nimport { FactoryEngine } from '../../../types/factoryTypes';\nimport { setState } from '../parts/stateMethods';\n\nlet devContextSet = false;\n\nexport const mocksEngine = (() => {\n  const engine: FactoryEngine = {\n    version: () => factoryVersion(),\n    setDeepCopy: (deepCopyOption, deepCopyAttributes) => {\n      setDeepCopy(deepCopyOption, deepCopyAttributes);\n      return engine;\n    },\n    devContext: (isDev) => {\n      setDevContext(isDev);\n      devContextSet = true;\n      return engine;\n    },\n  };\n\n  importGovernors([mocksGovernor]);\n\n  return engine;\n\n  // enable Middleware\n  function engineInvoke(method, params) {\n    const result = method({ ...params });\n    if (!result?.error) notifySubscribers();\n    deleteNotices();\n\n    // cleanup if set on invocation\n    if (devContextSet) {\n      setDevContext(false);\n      devContextSet = false;\n    }\n\n    return result;\n  }\n\n  function importGovernors(governors) {\n    governors.forEach((governor) => {\n      Object.keys(governor).forEach((method) => {\n        engine[method] = (params) => {\n          try {\n            const invocationResult = engineInvoke(governor[method], params);\n            if (!invocationResult?.error && params?.setState && invocationResult?.tournamentRecord) {\n              setState(invocationResult.tournamentRecord);\n            }\n            return invocationResult;\n          } catch (err) {\n            let error;\n            if (typeof err === 'string') {\n              error = err.toUpperCase();\n            } else if (err instanceof Error) {\n              error = err.message;\n            }\n            console.log('ERROR', {\n              params: JSON.stringify(params),\n              method,\n              error,\n            });\n          }\n        };\n      });\n    });\n  }\n})();\n\nexport default mocksEngine;\n","export function getTargetElement(target, element) {\n  return (\n    (target && element && Array.isArray(element) && element[target - 1]) ||\n    (typeof element === 'object' && element[target])\n  );\n}\n","export function getAwardProfile(params) {\n  const {\n    participation = {},\n    awardProfiles,\n    startDate,\n    eventType,\n    drawSize,\n    drawType,\n    category,\n    endDate,\n    level,\n  } = params;\n  const { participationOrder, flightNumber, rankingStage } = participation;\n\n  const isValidDateRange = (profile) => {\n    if ((!startDate && !endDate) || !profile.dateRanges) return true;\n    return profile.dateRanges.some((dateRange) => {\n      const validStartDate =\n        !startDate ||\n        !dateRange.startDate ||\n        new Date(startDate) > new Date(dateRange.startDate);\n      const validEndDate =\n        !endDate ||\n        !dateRange.endDate ||\n        new Date(endDate) <= new Date(dateRange.endDate);\n      return validStartDate && validEndDate;\n    });\n  };\n\n  const awardProfile = awardProfiles.find(\n    (profile) =>\n      isValidDateRange(profile) &&\n      (!profile.maxFlightNumber || flightNumber <= profile.maxFlightNumber) &&\n      (!profile.drawTypes?.length || profile.drawTypes?.includes(drawType)) &&\n      (!profile.drawSizes?.length || profile.drawSizes.includes(drawSize)) &&\n      (!profile.stages?.length || profile.stages.includes(rankingStage)) &&\n      (!profile.levels?.length || profile.levels.includes(level)) &&\n      (!profile.maxDrawSize || drawSize <= profile.maxDrawSize) &&\n      (!profile.drawSize || profile.drawSize === drawSize) &&\n      (!profile.maxLevel || level <= profile.maxLevel) &&\n      (!flightNumber ||\n        !profile.flights?.flightNumbers?.length ||\n        profile.flights.flightNumbers.includes(flightNumber)) &&\n      (!profile.participationOrder ||\n        profile.participationOrder === participationOrder) &&\n      (!profile.category?.ageCategoryCodes ||\n        profile.category.ageCategoryCodes.includes(\n          category?.ageCategoryCode\n        )) &&\n      (!profile.eventTypes?.length || profile.eventTypes?.includes(eventType))\n  );\n\n  return { awardProfile };\n}\n","import { isConvertableInteger } from '../../utilities/math';\nimport { getTargetElement } from './getTargetElement';\n\ntype GetAwardPointsArgs = {\n  participantWon?: boolean;\n  flightNumber?: number;\n  drawSize: number;\n  valueObj: any;\n  flights?: any;\n  level?: number;\n};\nexport function getAwardPoints({\n  participantWon,\n  flightNumber,\n  valueObj,\n  drawSize,\n  flights,\n  level,\n}: GetAwardPointsArgs) {\n  const getFlightValue = (flightNumber, targetElement) => {\n    if (!flightNumber) return;\n    if (Array.isArray(targetElement)) {\n      const arrayMember = targetElement.find(\n        (m) => m.flight === flightNumber || m.f === flightNumber\n      );\n      return arrayMember.value || arrayMember.v;\n    }\n    if (typeof targetElement === 'object') {\n      const flights = targetElement.flights || targetElement.f;\n      if (Array.isArray(flights)) return flights[flightNumber - 1];\n    }\n  };\n\n  const getValue = (obj, flightNumber) => {\n    const objectValue =\n      obj?.value || obj?.v || (isConvertableInteger(obj) ? obj : 0);\n    const targetElement = getTargetElement(level, obj?.level);\n    const flightValue = getFlightValue(flightNumber, targetElement);\n    const value =\n      flightValue ||\n      (isConvertableInteger(targetElement) && targetElement) ||\n      objectValue;\n    return { value };\n  };\n\n  let awardPoints = 0;\n  let requireWin;\n  let s, t, d;\n\n  const winAccessor =\n    (participantWon && 'won') ||\n    (participantWon === false && 'lost') ||\n    undefined;\n\n  if (Array.isArray(valueObj)) {\n    let sizeDefined = valueObj.find(\n      (obj) => obj.drawSize === drawSize || obj.drawSizes?.includes(drawSize)\n    );\n\n    // threshold attribute allows a definition for e.g. drawSize: 16 to apply to all LARGER drawSizes\n    let thresholdMatched = valueObj.find(\n      (obj) => obj.drawSize && obj.threshold && drawSize > obj.drawSize\n    );\n    // a default definition can be provided which has no drawSize or drawSizes\n    let defaultDef = valueObj.find(\n      (obj) => !obj.drawSize && !obj.drawSizes?.length\n    );\n\n    if (winAccessor !== undefined) {\n      sizeDefined = sizeDefined?.[winAccessor];\n      thresholdMatched = thresholdMatched?.[winAccessor];\n      defaultDef = defaultDef?.[winAccessor];\n    }\n    s = getValue(sizeDefined, flightNumber).value;\n    t = getValue(thresholdMatched, flightNumber).value;\n    d = getValue(defaultDef, flightNumber).value;\n    awardPoints = s || t || d;\n\n    requireWin =\n      (s && sizeDefined.requireWin) ||\n      (t && thresholdMatched.requireWin) ||\n      defaultDef?.requireWin;\n  } else if (typeof valueObj === 'object') {\n    let sizeDefined = valueObj?.drawSizes?.[drawSize];\n    let defaultDef = valueObj;\n    if (winAccessor !== undefined) {\n      sizeDefined = sizeDefined?.[winAccessor];\n      defaultDef = defaultDef?.[winAccessor];\n    }\n    s = getValue(sizeDefined, flightNumber).value;\n    d = getValue(defaultDef, flightNumber).value;\n    awardPoints = s || d;\n\n    requireWin = s ? sizeDefined.requireWin : defaultDef?.requireWin;\n  } else if (isConvertableInteger(valueObj) && winAccessor === undefined) {\n    // when using participantWon non-objects are not valid\n    awardPoints = valueObj;\n  }\n\n  if (flightNumber && flights?.pct?.[flightNumber]) {\n    awardPoints = Math.round(awardPoints * flights.pct[flightNumber]);\n  }\n\n  return { awardPoints, requireWin };\n}\n","import { getTournamentPoints } from '../../../../../query/scales/getTournamentPoints';\n\nconst rankingsGovernor = {\n  getTournamentPoints,\n};\n\nexport default rankingsGovernor;\n","import { getPolicyDefinitions } from '../extensions/getAppliedPolicies';\nimport { addExtension } from '../../mutate/extensions/addExtension';\nimport { getParticipants } from '../participants/getParticipants';\nimport { getTargetElement } from './getTargetElement';\nimport { getAwardProfile } from './getAwardProfile';\nimport { getAwardPoints } from './getAwardPoints';\nimport { unique } from '../../utilities/arrays';\n\nimport { PAIR, TEAM_PARTICIPANT } from '../../constants/participantConstants';\nimport { POLICY_TYPE_RANKING_POINTS } from '../../constants/policyConstants';\nimport { QUALIFYING } from '../../constants/drawDefinitionConstants';\nimport { RANKING_POINTS } from '../../constants/extensionConstants';\nimport { Tournament } from '../../types/tournamentTypes';\nimport { TEAM_EVENT } from '../../constants/eventConstants';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport {\n  MISSING_POLICY_DEFINITION,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\nimport {\n  ParticipantFilters,\n  PolicyDefinitions,\n} from '../../types/factoryTypes';\n\ntype GetTournamentPointsArgs = {\n  participantFilters?: ParticipantFilters;\n  policyDefinitions?: PolicyDefinitions;\n  tournamentRecord: Tournament;\n  saveRankings?: boolean;\n  level?: number;\n};\nexport function getTournamentPoints({\n  participantFilters,\n  policyDefinitions,\n  tournamentRecord,\n  saveRankings,\n  level,\n}: GetTournamentPointsArgs) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n\n  const { policyDefinitions: attachedPolicies } = getPolicyDefinitions({\n    policyTypes: [POLICY_TYPE_RANKING_POINTS],\n    tournamentRecord,\n  });\n\n  const pointsPolicy =\n    policyDefinitions?.[POLICY_TYPE_RANKING_POINTS] ??\n    attachedPolicies?.[POLICY_TYPE_RANKING_POINTS];\n  if (!pointsPolicy) return { error: MISSING_POLICY_DEFINITION };\n\n  const awardProfiles = pointsPolicy.awardProfiles;\n  let requireWinFirstRound = pointsPolicy.requireWinFirstRound;\n  const requireWinForPoints = pointsPolicy.requireWinForPoints;\n\n  const { participants, derivedEventInfo, derivedDrawInfo, mappedMatchUps } =\n    getParticipants({\n      withRankingProfile: true,\n      participantFilters,\n      tournamentRecord,\n    });\n\n  const participantsWithOutcomes = participants?.filter((p) => p.draws?.length);\n\n  // keep track of points earned per person / per team\n  const personPoints = {};\n  const teamPoints = {};\n  const pairPoints = {};\n\n  for (const participant of participantsWithOutcomes ?? []) {\n    const { participantType, participantId, person, draws } = participant;\n\n    for (const draw of draws) {\n      const { drawId, structureParticipation, eventId } = draw;\n      const eventInfo = derivedEventInfo[eventId];\n      const drawInfo = derivedDrawInfo[drawId];\n      const drawType = drawInfo?.drawType;\n\n      const { category, eventType } = eventInfo || {};\n      const startDate =\n        draw.startDate || eventInfo.startDate || tournamentRecord.startDate;\n      const endDate =\n        draw.endDate || eventInfo.endDate || tournamentRecord.endDate;\n\n      // don't process INDIVIDUAL and PAIR participants in TEAM events\n      // They are processed in the context of the TEAM in which they appear\n      if (eventType === TEAM_EVENT && participantId !== TEAM_PARTICIPANT) {\n        continue;\n      }\n\n      let points;\n\n      if (awardProfiles) {\n        let requireWin = requireWinForPoints;\n        let totalWinsCount = 0;\n        let positionPoints = 0;\n        let perWinPoints = 0;\n        let rangeAccessor;\n\n        for (const participation of structureParticipation) {\n          const {\n            finishingPositionRange,\n            participationOrder,\n            participantWon,\n            flightNumber,\n            rankingStage,\n            winCount,\n          } = participation;\n\n          totalWinsCount += winCount || 0;\n\n          const drawSize = drawInfo?.drawSize;\n\n          const { awardProfile } = getAwardProfile({\n            awardProfiles,\n            participation,\n            eventType,\n            startDate,\n            category,\n            drawSize,\n            drawType,\n            endDate,\n            level,\n          });\n\n          if (awardProfile) {\n            // NOTE: for now drawSize: 0 indicates qualifying structure with no MAIN structure\n            // TODO: support for qualifying stage awardProfiles\n            if (!drawSize) continue;\n\n            const accessor =\n              Array.isArray(finishingPositionRange) &&\n              Math.max(...finishingPositionRange);\n            const dashRange = unique(finishingPositionRange || []).join('-');\n\n            const firstRound =\n              accessor &&\n              rankingStage !== QUALIFYING &&\n              finishingPositionRange?.includes(drawSize);\n\n            if (awardProfile.requireWinForPoints !== undefined)\n              requireWin = awardProfile.requireWinForPoints;\n            if (awardProfile.requireWinFirstRound !== undefined)\n              requireWinFirstRound = awardProfile.requireWinFirstRound;\n\n            const {\n              finishingPositionPoints = {},\n              finishingPositionRanges,\n              finishingRound,\n              pointsPerWin,\n              flights,\n            } = awardProfile;\n\n            const ppwProfile = Array.isArray(awardProfile.perWinPoints)\n              ? awardProfile.perWinPoints?.find(\n                  (pwp) => pwp.participationOrders?.includes(participationOrder)\n                )\n              : awardProfile.perWinPoints;\n\n            const participationOrders =\n              finishingPositionPoints.participationOrders;\n\n            let awardPoints = 0;\n            let winRequired;\n\n            const isValidOrder =\n              !participationOrders ||\n              participationOrders.includes(participationOrder);\n\n            if (isValidOrder && finishingPositionRanges && accessor) {\n              const valueObj = finishingPositionRanges[accessor];\n              if (valueObj) {\n                ({ awardPoints, requireWin: winRequired } = getAwardPoints({\n                  flightNumber,\n                  valueObj,\n                  drawSize,\n                  flights,\n                  level,\n                }));\n              }\n            }\n\n            if (\n              !awardPoints &&\n              finishingRound &&\n              participationOrder === 1 &&\n              accessor\n            ) {\n              const valueObj = finishingRound[accessor];\n              if (valueObj) {\n                ({ awardPoints, requireWin: winRequired } = getAwardPoints({\n                  participantWon,\n                  flightNumber,\n                  valueObj,\n                  drawSize,\n                  flights,\n                  level,\n                }));\n              }\n            }\n\n            if (firstRound && requireWinFirstRound !== undefined) {\n              requireWin = requireWinFirstRound;\n            }\n            if (winRequired !== undefined) requireWin = winRequired;\n\n            if (awardPoints > positionPoints && (!requireWin || winCount)) {\n              positionPoints = awardPoints;\n              rangeAccessor = accessor;\n            }\n\n            if (!awardPoints && pointsPerWin && winCount) {\n              perWinPoints += winCount * pointsPerWin;\n              rangeAccessor = dashRange;\n            }\n\n            if (!awardPoints && winCount && ppwProfile) {\n              const levelValue = getTargetElement(level, ppwProfile?.level);\n              if (levelValue) {\n                perWinPoints += winCount * levelValue;\n              } else if (ppwProfile.value) {\n                perWinPoints += winCount * ppwProfile.value;\n              }\n            }\n          }\n\n          points = positionPoints + perWinPoints;\n\n          if (participantType === TEAM_PARTICIPANT) {\n            const teamStructureMatchUps = (participant.matchUps || []).filter(\n              ({ structureId }) => structureId === participation.structureId\n            );\n            for (const { matchUpId } of teamStructureMatchUps) {\n              const matchUp = mappedMatchUps[matchUpId];\n              const sideNumber = matchUp.sides.find(\n                (side) => side.participantId === participantId\n              ).sideNumber;\n\n              // for now only supporting line position awards per team win\n              if (matchUp.winningSice !== sideNumber) {\n                continue;\n              }\n\n              for (const tieMatchUp of matchUp.tieMatchUps) {\n                // ingore matchUps with no winningSide\n                if (!tieMatchUp.winningSide) continue;\n              }\n            }\n          }\n        }\n\n        if (perWinPoints || positionPoints) {\n          const award = {\n            winCount: totalWinsCount,\n            positionPoints,\n            rangeAccessor,\n            perWinPoints,\n            eventType,\n            drawId,\n            points,\n          };\n\n          const personId = person?.personId;\n          if (personId) {\n            if (!personPoints[personId]) personPoints[personId] = [];\n            personPoints[personId].push(award);\n          } else if (participantType === PAIR) {\n            if (!pairPoints[participantId]) pairPoints[participantId] = [];\n            pairPoints[participantId].push(award);\n          } else if (participantType === TEAM_PARTICIPANT) {\n            if (!teamPoints[participantId]) teamPoints[participantId] = [];\n            teamPoints[participantId].push(award);\n          }\n        }\n      }\n    }\n  }\n\n  if (saveRankings) {\n    // possibly also ensure ranking policy is part of applied policies\n    const extension = {\n      name: RANKING_POINTS,\n      value: { personPoints, teamPoints, pairPoints },\n    };\n    addExtension({ element: tournamentRecord, extension });\n  }\n\n  return {\n    participantsWithOutcomes,\n    personPoints,\n    pairPoints,\n    teamPoints,\n    ...SUCCESS,\n  };\n}\n","import ratingsParameters from '../../fixtures/ratings/ratingsParameters';\n\nimport { MISSING_VALUE } from '../../constants/errorConditionConstants';\nimport { ELO } from '../../constants/ratingConstants';\n\n// see footnote #3 here:\n// http://fivethirtyeight.com/features/serena-williams-and-the-difference-between-all-time-great-and-greatest-of-all-time/\nconst k538 = (countables) => 250 / Math.pow(countables + 5, 0.4);\nconst kDefault = () => 1;\n\n// win multipier is scaled by % countables won\n// https://www.stat.berkeley.edu/~aldous/157/Old_Projects/huang.pdf\nfunction kSet(maxCountables = 3, counted = 2) {\n  const kset = maxCountables / counted;\n  return isNaN(kset) ? eloConfig.kDefault() : kset;\n}\n\nconst eloConfig = {\n  nSpread: 400, // determines the 'spread' of the scale\n  diffThreshold: 0.125,\n\n  kCalc: k538, // use calculation defined by FiveThirtyEight.com\n  kMultiplier: kSet, // change to kDefault for value of 1\n  kDefault,\n};\n\nexport function getRatingDelta({\n  ratings = ratingsParameters,\n  ratingType,\n  rating,\n  delta,\n}) {\n  const ratingParameters = ratings?.[ratingType];\n  const decimalPlaces = ratingParameters.decimalsCount || 0;\n  let newRating = (parseFloat(rating) + parseFloat(delta)).toFixed(\n    decimalPlaces\n  );\n  if (parseFloat(newRating) < 0) newRating = rating;\n  return newRating;\n}\n\nexport function calculateNewRatings(params?) {\n  let { winnerRating, loserRating, ratingRange } = params;\n  const {\n    ratings = ratingsParameters,\n    winnerCountables = 1,\n    loserCountables = 0,\n    ratingType = ELO,\n    maxCountables,\n    countables,\n  } = params || {};\n  const ratingParameters = ratings?.[ratingType];\n  if (!ratingParameters) return { error: MISSING_VALUE };\n\n  ratingRange = ratingParameters.range || ratingRange;\n  winnerRating = winnerRating || ratingParameters.defaultInitialization;\n  loserRating = loserRating || ratingParameters.defaultInitialization;\n\n  const invertedScale = ratingRange[0] > ratingRange[1];\n\n  const decimalPlaces = ratingParameters.decimalsCount || 0;\n  const consideredRange = invertedScale\n    ? ratingRange.slice().reverse()\n    : ratingRange;\n\n  const inRange = (range, value) =>\n    parseFloat(value) >= Math.min(...range) &&\n    parseFloat(value) <= Math.max(...range);\n  if (\n    !inRange(ratingRange, winnerRating) ||\n    !inRange(ratingRange, loserRating)\n  ) {\n    if (!inRange(ratingRange, winnerRating))\n      winnerRating = ratingParameters.defaultInitialization;\n    if (!inRange(ratingRange, loserRating))\n      loserRating = ratingParameters.defaultInitialization;\n  }\n\n  // convert one rating range to another rating range\n  const convertRange = ({ value, sourceRange, targetRange }) =>\n    ((value - sourceRange[0]) * (targetRange[1] - targetRange[0])) /\n      (sourceRange[1] - sourceRange[0]) +\n    targetRange[0];\n\n  // convert inbound ratings from ratingType into ELO\n  const convertedWinnerRating = convertRange({\n    targetRange: ratingsParameters[ELO].range,\n    sourceRange: consideredRange,\n    value: invertedScale ? ratingRange[0] - winnerRating : winnerRating,\n  });\n  const convertedLoserRating = convertRange({\n    targetRange: ratingsParameters[ELO].range,\n    sourceRange: consideredRange,\n    value: invertedScale ? ratingRange[0] - loserRating : loserRating,\n  });\n\n  const getExpectation = (playerRating, opponentRating) =>\n    1 / (1 + Math.pow(10, (opponentRating - playerRating) / eloConfig.nSpread));\n\n  const winnerExpectation = getExpectation(\n    convertedWinnerRating,\n    convertedLoserRating\n  );\n  const loserExpectation = getExpectation(\n    convertedLoserRating,\n    convertedWinnerRating\n  );\n\n  const winnerKValue = eloConfig.kCalc(winnerCountables);\n  const loserKValue = eloConfig.kCalc(loserCountables);\n  const k = eloConfig.kMultiplier(maxCountables, countables);\n\n  const winnerUpdatedConvertedRating =\n    convertedWinnerRating + k * winnerKValue * (1 - winnerExpectation);\n  const loserUpdatedConvertedRating =\n    convertedLoserRating + k * loserKValue * (0 - loserExpectation);\n\n  // convert calculated new ratings from ELO into ratingType\n  const convertedUpdatedWinnerRating = convertRange({\n    sourceRange: ratingsParameters[ELO].range,\n    value: winnerUpdatedConvertedRating,\n    targetRange: consideredRange,\n  });\n  const convertedUpdatedLoserRating = convertRange({\n    sourceRange: ratingsParameters[ELO].range,\n    value: loserUpdatedConvertedRating,\n    targetRange: consideredRange,\n  });\n\n  const updatedWinnerRating = invertedScale\n    ? ratingRange[0] - convertedUpdatedWinnerRating\n    : convertedUpdatedWinnerRating;\n  let newWinnerRating = parseFloat(\n    parseFloat(updatedWinnerRating).toFixed(decimalPlaces)\n  );\n  const updatedLoserRating = invertedScale\n    ? ratingRange[0] - convertedUpdatedLoserRating\n    : convertedUpdatedLoserRating;\n  let newLoserRating = parseFloat(\n    parseFloat(updatedLoserRating).toFixed(decimalPlaces)\n  );\n\n  //  if expected winner && percentageDifference > threshold don't change ratings\n  const percentageDifference = Math.max(...ratingRange)\n    ? Math.abs(winnerRating - loserRating) / Math.max(...ratingRange)\n    : 0;\n\n  if (\n    (convertedUpdatedWinnerRating > convertedUpdatedLoserRating &&\n      percentageDifference > eloConfig.diffThreshold) ||\n    newWinnerRating < 0 ||\n    newLoserRating < 0\n  ) {\n    newWinnerRating = winnerRating;\n    newLoserRating = loserRating;\n  }\n\n  return { newWinnerRating, newLoserRating };\n}\n","import { calculateNewRatings } from '../../../../../mutate/scales/calculateNewRatings';\nimport { generateDynamicRatings } from '../../../../../mutate/scales/generateDynamicRatings';\n\nconst governor = {\n  calculateNewRatings,\n  generateDynamicRatings,\n};\n\nexport default governor;\n","import { getParticipantScaleItem } from '../../query/participant/getParticipantScaleItem';\nimport { setParticipantScaleItem } from '../participants/addScaleItems';\nimport { allTournamentMatchUps } from '../../query/matchUps/getAllTournamentMatchUps';\nimport { parse } from '../../assemblies/generators/matchUpFormatCode/parse';\nimport ratingsParameters from '../../fixtures/ratings/ratingsParameters';\nimport { matchUpSort } from '../../functions/sorters/matchUpSort';\nimport { calculateNewRatings } from './calculateNewRatings';\nimport { aggregateSets } from './aggregators';\n\nimport { completedMatchUpStatuses } from '../../constants/matchUpStatusConstants';\nimport { DYNAMIC, RATING } from '../../constants/scaleConstants';\nimport { EventTypeUnion } from '../../types/tournamentTypes';\nimport { SUCCESS } from '../../constants/resultConstants';\nimport { ELO } from '../../constants/ratingConstants';\nimport { HydratedSide } from '../../types/hydrated';\nimport {\n  INVALID_VALUES,\n  MISSING_MATCHUPS,\n  MISSING_TOURNAMENT_RECORD,\n} from '../../constants/errorConditionConstants';\n\nexport function generateDynamicRatings({\n  removePriorValues = true,\n  tournamentRecord,\n  ratingType = ELO,\n  considerGames,\n  matchUpIds,\n  asDynamic,\n}) {\n  if (!tournamentRecord) return { error: MISSING_TOURNAMENT_RECORD };\n  if (!Array.isArray(matchUpIds)) return { error: MISSING_MATCHUPS };\n  if (typeof ratingType !== 'string')\n    return { error: INVALID_VALUES, ratingType };\n  if (!ratingsParameters[ratingType]) return { error: INVALID_VALUES };\n  const ratingParameter = ratingsParameters[ratingType];\n  const { accessor } = ratingParameter;\n\n  const modifiedScaleValues = {};\n\n  const matchUps =\n    allTournamentMatchUps({\n      matchUpFilters: { matchUpIds, matchUpStatuses: completedMatchUpStatuses },\n      tournamentRecord,\n      inContext: true,\n    }).matchUps ?? [];\n\n  matchUps.sort(matchUpSort);\n  for (const matchUp of matchUps) {\n    const { endDate, matchUpFormat, score, sides, winningSide } = matchUp;\n\n    const matchUpType = matchUp.matchUpType as EventTypeUnion;\n\n    const scaleAttributes = {\n      eventType: matchUpType,\n      scaleName: ratingType,\n      scaleType: RATING,\n    };\n\n    const dynamicScaleName = `${ratingType}.${DYNAMIC}`;\n    const dynamicScaleAttributes = {\n      scaleName: dynamicScaleName,\n      eventType: matchUpType,\n      scaleType: RATING,\n    };\n\n    const sideParticipantIds: string[] = Object.assign(\n      {},\n      ...(sides ?? []).map((side: HydratedSide) => {\n        const { sideNumber, participant } = side;\n        return (\n          sideNumber && {\n            [sideNumber]: [\n              participant?.participantId,\n              ...(participant?.individualParticipantIds ?? []),\n            ]\n              .filter(Boolean)\n              .flat(),\n          }\n        );\n      })\n    );\n\n    const outputScaleName = asDynamic ? dynamicScaleName : ratingType;\n    const scaleItemMap = Object.assign(\n      {},\n      ...Object.values(sideParticipantIds)\n        .flat()\n        .map((participantId) => {\n          const { scaleItem: dynamicScaleItem } = getParticipantScaleItem({\n            scaleAttributes: dynamicScaleAttributes,\n            tournamentRecord,\n            participantId,\n          });\n          const { scaleItem } = getParticipantScaleItem({\n            tournamentRecord,\n            scaleAttributes,\n            participantId,\n          });\n\n          const scaleValue = accessor ? { [accessor]: undefined } : undefined;\n\n          return (\n            participantId && {\n              [participantId]: dynamicScaleItem ??\n                scaleItem ?? {\n                  scaleName: outputScaleName,\n                  eventType: matchUpType,\n                  scaleDate: endDate,\n                  scaleType: RATING,\n                  scaleValue,\n                },\n            }\n          );\n        })\n    );\n\n    const parsedFormat: any = matchUpFormat ? parse(matchUpFormat) : {};\n    const bestOf = parsedFormat?.bestOf || 1;\n    const setsTo = parsedFormat?.setsTo || 1;\n\n    const maxCountables = considerGames ? bestOf & setsTo : bestOf;\n\n    const countables = (score?.sets && aggregateSets(score.sets)) ||\n      (winningSide === 1 && [1, 0]) || [0, 1];\n\n    const winningSideParticipantIds = winningSide\n      ? sideParticipantIds[winningSide]\n      : [];\n    const losingSideParticipantIds = winningSide\n      ? sideParticipantIds[3 - winningSide]\n      : [];\n    for (const winnerParticipantId of winningSideParticipantIds) {\n      const winnerScaleValue = scaleItemMap[winnerParticipantId]?.scaleValue;\n      const winnerRating =\n        typeof winnerScaleValue === 'object'\n          ? winnerScaleValue[accessor]\n          : winnerScaleValue;\n\n      for (const loserParticipantId of losingSideParticipantIds) {\n        const loserScaleValue = scaleItemMap[loserParticipantId]?.scaleValue;\n        const loserRating =\n          typeof loserScaleValue === 'object'\n            ? loserScaleValue[accessor]\n            : loserScaleValue;\n\n        const winnerCountables = winningSide ? countables[winningSide] : [0, 0];\n        const loserCountables = winningSide\n          ? countables[3 - winningSide]\n          : [0, 0];\n\n        const { newWinnerRating, newLoserRating } = calculateNewRatings({\n          winnerCountables,\n          loserCountables,\n          maxCountables,\n          winnerRating,\n          loserRating,\n          ratingType,\n        });\n\n        const newWinnerScaleValue = accessor\n          ? {\n              ...winnerScaleValue,\n              [accessor]: newWinnerRating,\n            }\n          : newWinnerRating;\n        const newLoserScaleValue = accessor\n          ? {\n              ...loserScaleValue,\n              [accessor]: newLoserRating,\n            }\n          : newLoserRating;\n        scaleItemMap[winnerParticipantId].scaleValue = newWinnerScaleValue;\n        scaleItemMap[loserParticipantId].scaleValue = newLoserScaleValue;\n\n        let result = setParticipantScaleItem({\n          participantId: winnerParticipantId,\n          removePriorValues,\n          tournamentRecord,\n          scaleItem: {\n            ...scaleItemMap[winnerParticipantId],\n            scaleName: outputScaleName,\n          },\n        });\n        if (result.error) return result;\n\n        result = setParticipantScaleItem({\n          participantId: loserParticipantId,\n          removePriorValues,\n          tournamentRecord,\n          scaleItem: {\n            ...scaleItemMap[loserParticipantId],\n            scaleName: outputScaleName,\n          },\n        });\n        if (result.error) return result;\n      }\n    }\n\n    Object.assign(modifiedScaleValues, scaleItemMap);\n  }\n\n  const processedMatchUpIds = matchUps.map(({ matchUpId }) => matchUpId);\n\n  return { ...SUCCESS, modifiedScaleValues, processedMatchUpIds };\n}\n","export const aggregateGames = (sets) => {\n  return (\n    sets?.reduce(\n      (aggregate, set) => {\n        aggregate[0] += set.side1Score;\n        aggregate[1] += set.side2Score;\n        return aggregate;\n      },\n      [0, 0]\n    ) || [0, 0]\n  );\n};\n\nexport const aggregateSets = (sets) => {\n  return (\n    sets?.reduce(\n      (aggregate, set) => {\n        if (set.winningSide) aggregate[set.winningSide - 1] += 1;\n        return aggregate;\n      },\n      [0, 0]\n    ) || [0, 0]\n  );\n};\n","import rankingsGovernor from './governors/rankingsGovernor';\nimport ratingsGovernor from './governors/ratingsGovernor';\nimport syncEngine from '../../../assemblies/engines/sync';\n\nconst methods = {\n  ...rankingsGovernor,\n  ...ratingsGovernor,\n};\n\nsyncEngine.importMethods(methods);\n\nexport const scaleEngine = syncEngine;\nexport default syncEngine;\n","import { countries, countryToFlag, flagIOC } from './countryData';\nimport ratingsParameters from './ratings/ratingsParameters';\nimport { matchUpFormats } from './scoring/matchUpFormats';\nimport { tieFormats } from './scoring/tieFormats';\nimport { policies } from './policies';\n\nexport const fixtures = {\n  ratingsParameters,\n  matchUpFormats,\n  countryToFlag,\n  tieFormats,\n  countries,\n  policies,\n  flagIOC,\n};\n","import { POLICY_AVOIDANCE_COUNTRY } from './POLICY_AVOIDANCE_COUNTRY';\n\nimport { POLICY_POSITION_ACTIONS_UNRESTRICTED } from './POLICY_POSITION_ACTIONS_UNRESTRICTED';\nimport { POLICY_POSITION_ACTIONS_NO_MOVEMENT } from './POLICY_POSITION_ACTIONS_NO_MOVEMENT';\nimport { POLICY_POSITION_ACTIONS_DISABLED } from './POLICY_POSITION_ACTIONS_DISABLED';\nimport { POLICY_POSITION_ACTIONS_DEFAULT } from './POLICY_POSITION_ACTIONS_DEFAULT';\n\nimport { POLICY_ROUND_NAMING_DEFAULT } from './POLICY_ROUND_NAMING_DEFAULT';\nimport { POLICY_SCHEDULING_DEFAULT } from './POLICY_SCHEDULING_DEFAULT';\nimport { POLICY_PRIVACY_DEFAULT } from './POLICY_PRIVACY_DEFAULT';\n\nimport { POLICY_SCORING_DEFAULT } from './POLICY_SCORING_DEFAULT';\nimport { POLICY_SCORING_USTA } from './POLICY_SCORING_USTA';\n\nimport { POLICY_SEEDING_DEFAULT } from './POLICY_SEEDING_DEFAULT';\nimport { POLICY_SEEDING_ITF } from './POLICY_SEEDING_ITF';\n\nexport const policies = {\n  POLICY_AVOIDANCE_COUNTRY,\n\n  POLICY_POSITION_ACTIONS_DEFAULT,\n  POLICY_POSITION_ACTIONS_DISABLED,\n  POLICY_POSITION_ACTIONS_NO_MOVEMENT,\n  POLICY_POSITION_ACTIONS_UNRESTRICTED,\n\n  POLICY_PRIVACY_DEFAULT,\n\n  POLICY_ROUND_NAMING_DEFAULT,\n\n  POLICY_SCHEDULING_DEFAULT,\n\n  POLICY_SCORING_DEFAULT,\n  POLICY_SCORING_USTA,\n\n  POLICY_SEEDING_ITF,\n  POLICY_SEEDING_DEFAULT,\n};\n","import { POLICY_TYPE_AVOIDANCE } from '../../constants/policyConstants';\n\nexport const POLICY_AVOIDANCE_COUNTRY = {\n  [POLICY_TYPE_AVOIDANCE]: {\n    roundsToSeparate: undefined,\n    policyName: 'Nationality Code',\n    policyAttributes: [\n      { key: 'person.nationalityCode' },\n      { key: 'individualParticipants.person.nationalityCode' },\n    ],\n  },\n};\n\nexport default POLICY_AVOIDANCE_COUNTRY;\n","import { POLICY_TYPE_POSITION_ACTIONS } from '../../constants/policyConstants';\n\nexport const POLICY_POSITION_ACTIONS_DISABLED = {\n  [POLICY_TYPE_POSITION_ACTIONS]: {\n    policyName: 'positionActionsDisabled',\n\n    // positionActions will be selectively enabled for structures matching { stages: [], stageSequences: [], structureTypes: [] }\n    // enabledStructures: [] => all structures are enabled\n    enabledStructures: false,\n  },\n};\n\nexport default POLICY_POSITION_ACTIONS_DISABLED;\n","import { POLICY_TYPE_POSITION_ACTIONS } from '../../constants/policyConstants';\nimport {\n  ADD_NICKNAME,\n  ADD_PENALTY,\n  SEED_VALUE,\n} from '../../constants/positionActionConstants';\n\nexport const POLICY_POSITION_ACTIONS_NO_MOVEMENT = {\n  [POLICY_TYPE_POSITION_ACTIONS]: {\n    policyName: 'positionActionsNoMovement',\n\n    // positionActions will be selectively enabled for structures matching { stages: [], stageSequences: [] }\n    // enabledStructures: [] => all structures are enabled\n    enabledStructures: [\n      {\n        stages: [], // stages: [] => applies to all stages\n        stageSequences: [], // stageSequences: [] => applies to all stageSequences\n        enabledActions: [SEED_VALUE, ADD_NICKNAME, ADD_PENALTY],\n        disabledActions: [], // disabledActions: [] => no actions are disabled\n      },\n    ],\n  },\n};\n\nexport default POLICY_POSITION_ACTIONS_NO_MOVEMENT;\n","import { POLICY_TYPE_POSITION_ACTIONS } from '../../constants/policyConstants';\nimport {\n  REMOVE_SEED,\n  SEED_VALUE,\n} from '../../constants/positionActionConstants';\n\nexport const POLICY_POSITION_ACTIONS_UNRESTRICTED = {\n  [POLICY_TYPE_POSITION_ACTIONS]: {\n    policyName: 'positionActionsUnrestricted',\n\n    // positionActions will be selectively enabled for structures matching { stages: [], stageSequences: [], structureTypes: [] }\n    // enabledStructures: [] => all structures are enabled\n    enabledStructures: [],\n\n    // enables entries in other flights to be accessed as alternates\n    otherFlightEntries: true,\n\n    // enables entries with multiple qualifying roundTargets to be placed in any round\n    disableRoundRestrictions: true,\n\n    // enable specific actions even when there are active positions\n    activePositionOverrides: [SEED_VALUE, REMOVE_SEED],\n  },\n};\n\nexport default POLICY_POSITION_ACTIONS_UNRESTRICTED;\n","import { POLICY_TYPE_PARTICIPANT } from '../../constants/policyConstants';\n\nexport const POLICY_PRIVACY_DEFAULT = {\n  [POLICY_TYPE_PARTICIPANT]: {\n    policyName: 'Participant Privacy Policy',\n    participant: {\n      contacts: false,\n      individualParticipants: {\n        onlineResources: false,\n        participantName: true,\n        participantOtherName: true,\n        participantId: true,\n        participantRole: true,\n        participantStatus: true,\n        penalties: false,\n        representing: true,\n        participantRoleResponsibilities: false,\n        participantType: true,\n        person: {\n          addresses: false,\n          biographicalInformation: false,\n          birthDate: false,\n          contacts: false,\n          nationalityCode: true,\n          nativeFamilyName: false,\n          nativeGivenName: false,\n          onlineResources: false,\n          otherNames: true,\n          parentOrganisationId: false,\n          passportFamilyName: false,\n          passportGivenName: false,\n          personId: false,\n          personOtherIds: false,\n          previousNames: false,\n          sex: false,\n          standardFamilyName: true,\n          standardGivenName: true,\n          status: false,\n          tennisId: false,\n          wheelchair: true,\n        },\n      },\n      individualParticipantIds: true,\n      onlineResources: false,\n      participantName: true,\n      participantOtherName: true,\n      participantId: true,\n      participantRole: true,\n      participantStatus: true,\n      penalties: false,\n      representing: true,\n      participantRoleResponsibilities: false,\n      participantType: true,\n      person: {\n        addresses: false,\n        biographicalInformation: false,\n        birthDate: false,\n        contacts: false,\n        nationalityCode: true,\n        nativeFamilyName: false,\n        nativeGivenName: false,\n        onlineResources: false,\n        otherNames: true,\n        parentOrganisationId: false,\n        passportFamilyName: false,\n        passportGivenName: false,\n        personId: false,\n        personOtherIds: false,\n        previousNames: false,\n        sex: false,\n        standardFamilyName: true,\n        standardGivenName: true,\n        status: false,\n        tennisId: false,\n        wheelchair: true,\n      },\n    },\n  },\n};\n\nexport default POLICY_PRIVACY_DEFAULT;\n","import { POLICY_TYPE_SCORING } from '../../constants/policyConstants';\nimport { MAIN } from '../../constants/drawDefinitionConstants';\nimport { FORMAT_STANDARD } from '../scoring/matchUpFormats';\n\n/**\n * without a SCORING_POLICY which sets { requireAllPositionsAssigned: false },  all stage:MAIN, stageSequence:1 drawPositions must be assigned **BEFORE** scoring is enabled,\n * scoring is enabled in consolation and compass/playoff structures when not all drawPositions have been filled\n */\nexport const POLICY_SCORING_DEFAULT = {\n  [POLICY_TYPE_SCORING]: {\n    defaultMatchUpFormat: FORMAT_STANDARD,\n    allowDeletionWithScoresPresent: {\n      drawDefinitions: false,\n      structures: false,\n    },\n    requireAllPositionsAssigned: false,\n    processCodes: {\n      incompleteAssignmentsOnDefault: ['RANKING.IGNORE'],\n    },\n    stage: {\n      [MAIN]: {\n        stageSequence: {\n          1: {\n            requireAllPositionsAssigned: true,\n          },\n        },\n      },\n    },\n  },\n};\n\nexport default POLICY_SCORING_DEFAULT;\n","import { POLICY_TYPE_SCORING } from '../../constants/policyConstants';\nimport { MAIN } from '../../constants/drawDefinitionConstants';\nimport { FORMAT_STANDARD } from '../scoring/matchUpFormats';\n\nexport const POLICY_SCORING_USTA = {\n  [POLICY_TYPE_SCORING]: {\n    requireAllPositionsAssigned: false,\n    stage: {\n      [MAIN]: {\n        stageSequence: {\n          1: {\n            requireAllPositionsAssigned: true,\n          },\n        },\n      },\n    },\n    defaultMatchUpFormat: FORMAT_STANDARD,\n    matchUpFormats: [\n      {\n        description: 'Best of 3 tiebreak sets',\n        matchUpFormat: FORMAT_STANDARD,\n        categoryNames: [],\n        categoryTypes: [],\n      },\n      {\n        description: 'Two tiebreak sets, 7-point match tiebreak at one set all',\n        matchUpFormat: 'SET3-S:6/TB7-F:TB7',\n      },\n      {\n        description:\n          'Two tiebreak sets, 10-point match tiebreak at one set all',\n        matchUpFormat: 'SET3-S:6/TB7-F:TB10',\n      },\n      {\n        description:\n          'One standard tiebreak set to 6, 7-point tiebreak at 6 games all',\n        matchUpFormat: 'SET1-S:6/TB7',\n      },\n      {\n        description: 'Best of 3 sets to 4',\n        matchUpFormat: 'SET3-S:4/TB7',\n      },\n      {\n        description:\n          'Two out of three short sets to 4 with 5-point tiebreak at 3 games all',\n        matchUpFormat: 'SET3-S:4/TB5@3',\n      },\n      {\n        description: 'One short set to 4, 7-point tiebreak at 4 games all',\n        matchUpFormat: 'SET1-S:4/TB7',\n      },\n      {\n        description: 'One short set to 4, 5-point tiebreak at 3 games all',\n        matchUpFormat: 'SET1-S:4/TB5@3',\n      },\n      {\n        description:\n          'Two short sets to 4, 10-point match tiebreak at one set all',\n        matchUpFormat: 'SET3-S:4/TB7-F:TB10',\n      },\n      {\n        description:\n          'Two short sets to 4, 7-point match tiebreak at one set all',\n        matchUpFormat: 'SET3-S:4/TB7-F:TB7',\n      },\n      {\n        description: 'One no advantage set to 5, tiebreak to 9 at 4-4',\n        matchUpFormat: 'SET1-S:5/TB9@4',\n      },\n      {\n        description: 'One set to 6 with deciding game at 5 games all',\n        matchUpFormat: 'SET1-S:6NOAD',\n      },\n      {\n        description:\n          'One short set to 4, deciding game is played at 3 games all',\n        matchUpFormat: 'SET1-S:4NOAD',\n      },\n      {\n        description:\n          'Two short sets to 4 with deciding game at 3-3, 7-point match tiebreak at one set all',\n        matchUpFormat: 'SET3-S:4NOAD-F:TB7',\n      },\n      {\n        description: '8 game pro-set with 7 point tiebreak at 8 games all',\n        matchUpFormat: 'SET1-S:8/TB7',\n      },\n      {\n        description: '8 game pro-set with 7 point tiebreak at 7 games all',\n        matchUpFormat: 'SET1-S:8/TB7@7',\n      },\n      {\n        description: 'Best of 3 10-point tiebreak games',\n        matchUpFormat: 'SET3-S:TB10',\n      },\n      {\n        description: 'One 10-point tiebreak game',\n        matchUpFormat: 'SET1-S:TB10',\n      },\n      {\n        description: 'Timed 20 minute game - game based',\n        matchUpFormat: 'SET1-S:T20',\n      },\n    ],\n  },\n};\n\nexport default POLICY_SCORING_USTA;\n","import { POLICY_TYPE_SEEDING } from '../../constants/policyConstants';\nimport { CLUSTER } from '../../constants/drawDefinitionConstants';\n\nexport const POLICY_SEEDING_ITF = {\n  [POLICY_TYPE_SEEDING]: {\n    seedingProfile: { positioning: CLUSTER },\n    validSeedPositions: { ignore: true },\n    duplicateSeedNumbers: true,\n    drawSizeProgression: true,\n    policyName: 'ITF SEEDING',\n\n    seedsCountThresholds: [\n      { drawSize: 4, minimumParticipantCount: 3, seedsCount: 2 },\n      { drawSize: 16, minimumParticipantCount: 12, seedsCount: 4 },\n      { drawSize: 32, minimumParticipantCount: 24, seedsCount: 8 },\n      { drawSize: 64, minimumParticipantCount: 48, seedsCount: 16 },\n      { drawSize: 128, minimumParticipantCount: 97, seedsCount: 32 },\n      { drawSize: 256, minimumParticipantCount: 192, seedsCount: 64 },\n    ],\n  },\n};\n\nexport default POLICY_SEEDING_ITF;\n","export const COACHING = 'Coaching';\nexport const BALL_ABUSE = 'Ball Abuse';\nexport const RACKET_ABUSE = 'Racket Abuse';\nexport const VERBAL_ABUSE = 'Verbal Abuse';\nexport const INELIGIBILITY = 'INELIGIBILITY';\nexport const PHYSICAL_ABUSE = 'Physical Abuse';\nexport const UNSPORTSMANLIKE_CONDUCT = 'Unsportmanlike Conduct';\nexport const DRESS_CODE_VIOLATION = 'Dress Code Violation';\nexport const EQUIMENT_VIOLATION = 'Equipment Violation';\nexport const LEAVING_THE_COURT = 'Leaving the court';\nexport const FAILURE_TO_COMPLETE = 'Failure to complete';\nexport const NO_SHOW = 'No Show';\nexport const OTHER = 'Other';\nexport const REFUSAL_TO_PLAY = 'REFUSAL_TO_PLAY';\nexport const PROHIBITED_SUBSTANCE = 'PROHIBITED_SUBSTANCE';\nexport const PUNCTUALITY = 'Puncuality';\nexport const FAILUIRE_TO_SIGN_IN = 'Failure to sign in';\n\nexport const penaltyConstants = {\n  COACHING,\n  BALL_ABUSE,\n  RACKET_ABUSE,\n  VERBAL_ABUSE,\n  PHYSICAL_ABUSE,\n  INELIGIBILITY,\n\n  UNSPORTSMANLIKE_CONDUCT,\n  PROHIBITED_SUBSTANCE,\n  DRESS_CODE_VIOLATION,\n  EQUIMENT_VIOLATION,\n  LEAVING_THE_COURT,\n  REFUSAL_TO_PLAY,\n  FAILURE_TO_COMPLETE,\n\n  NO_SHOW,\n  OTHER,\n  PUNCTUALITY,\n  FAILUIRE_TO_SIGN_IN,\n};\n\nexport default penaltyConstants;\n","export const CLAY = 'CLAY';\nexport const HARD = 'HARD';\nexport const GRASS = 'GRASS';\nexport const CARPET = 'CARPET';\nexport const ARTIFICIAL = 'ARTIFICIAL';\n\nexport const surfaceConstants = {\n  CLAY,\n  HARD,\n  GRASS,\n  CARPET,\n  ARTIFICIAL,\n};\n\nexport default surfaceConstants;\n","export const INDOOR = 'INDOOR';\nexport const OUTDOOR = 'OUTDOOR';\n\nexport const venueConstants = {\n  INDOOR,\n  OUTDOOR,\n};\n\nexport default venueConstants;\n","import { auditConstants } from './auditConstants';\nimport { drawDefinitionConstants } from './drawDefinitionConstants';\nimport { entryStatusConstants } from './entryStatusConstants';\nimport { errorConditionConstants } from './errorConditionConstants';\nimport { eventConstants } from './eventConstants';\nimport { extensionConstants } from './extensionConstants';\nimport { flightConstants } from './flightConstants';\nimport { genderConstants } from './genderConstants';\nimport { keyValueConstants } from '../mutate/score/keyValueScore/constants';\nimport { matchUpActionConstants } from './matchUpActionConstants';\nimport { matchUpTypes } from './matchUpTypes';\nimport { participantConstants, participantTypes } from './participantConstants';\nimport { participantRoles } from './participantRoles';\nimport { penaltyConstants } from './penaltyConstants';\nimport { policyConstants } from './policyConstants';\nimport { positionActionConstants } from './positionActionConstants';\nimport { ratingConstants } from './ratingConstants';\nimport { requestConstants } from './requestConstants';\nimport { resultConstants } from './resultConstants';\nimport { scaleConstants } from './scaleConstants';\nimport { scheduleConstants } from './scheduleConstants';\nimport { sortingConstants } from './sortingConstants';\nimport { surfaceConstants } from './surfaceConstants';\nimport { tieFormatConstants } from './tieFormatConstants';\nimport { timeItemConstants } from './timeItemConstants';\nimport { topicConstants } from './topicConstants';\nimport { tournamentConstants } from './tournamentConstants';\nimport { venueConstants } from './venueConstants';\n\nimport {\n  activeMatchUpStatuses,\n  completedMatchUpStatuses,\n  directingMatchUpStatuses,\n  matchUpStatusConstants,\n  nonDirectingMatchUpStatuses,\n  particicipantsRequiredMatchUpStatuses,\n  recoveryTimeRequiredMatchUpStatuses,\n  upcomingMatchUpStatuses,\n  validMatchUpStatuses,\n} from './matchUpStatusConstants';\n\nexport const factoryConstants = {\n  activeMatchUpStatuses,\n  auditConstants,\n  completedMatchUpStatuses,\n  directingMatchUpStatuses,\n  drawDefinitionConstants,\n  entryStatusConstants,\n  errorConditionConstants,\n  eventConstants,\n  extensionConstants,\n  flightConstants,\n  genderConstants,\n  keyValueConstants,\n  matchUpActionConstants,\n  matchUpStatusConstants,\n  matchUpTypes,\n  nonDirectingMatchUpStatuses,\n  participantConstants,\n  participantRoles,\n  particicipantsRequiredMatchUpStatuses,\n  participantTypes,\n  penaltyConstants,\n  policyConstants,\n  positionActionConstants,\n  ratingConstants,\n  recoveryTimeRequiredMatchUpStatuses,\n  requestConstants,\n  resultConstants,\n  scaleConstants,\n  scheduleConstants,\n  sortingConstants,\n  surfaceConstants,\n  tieFormatConstants,\n  timeItemConstants,\n  topicConstants,\n  tournamentConstants,\n  upcomingMatchUpStatuses,\n  validMatchUpStatuses,\n  venueConstants,\n};\n\nexport default factoryConstants;\n"],"names":["factoryVersion","numericSort","a","b","ensureInt","val","parseInt","toString","isPowerOf2","n","isNaN","median","arr","length","s","sort","mid","Math","floor","coerceEven","nearestPowerOf2","pow","round","log","isNumeric","value","parseFloat","isOdd","num","numInt","nextPowerOf2","randomInt","min","max","ceil","random","isConvertableInteger","Number","isSafeInteger","skewedDistribution","skew","step","significantDecimals","u","v","sqrt","cos","PI","inv","stepRound","toFixed","unique","filter","item","i","lastIndexOf","shuffleArray","map","numericSortValue","Infinity","instanceCount","values","reduce","c","groupValues","obj","Object","keys","p","push","onlyUnique","index","self","indexOf","uniqueValues","randomPop","array","Array","isArray","splice","randomMember","generateRange","start","end","from","_","k","arrayIndices","e","intersection","difference","x","includes","overlap","some","chunkArray","chunksize","all","one","ch","concat","allNumeric","numeric","noNumeric","chunkByNth","chunksCount","shuttle","chunks","entry","reverseDirection","chunkIndex","directionIndex","SUCCESS","success","resultConstants","ERROR","ANACHRONISM","message","code","CANNOT_REMOVE_MAIN_STRUCTURE","INVALID_RECORDS","MISSING_TOURNAMENT_RECORDS","MISSING_TOURNAMENT_RECORD","INVALID_TOURNAMENT_RECORD","MISSING_TOURNAMENT_ID","INVALID_DRAW_DEFINITION","MISSING_DRAW_DEFINITION","EXISTING_DRAW_DEFINITIONS","DRAW_DEFINITION_NOT_FOUND","INVALID_STRUCTURE","INCOMPLETE_SOURCE_STRUCTURE","INVALID_DRAW_POSITION_FOR_SEEDING","DRAW_POSITION_ASSIGNED","SCHEDULE_NOT_CLEARED","DRAW_POSITION_NOT_CLEARED","UNRECOGNIZED_DRAW_TYPE","MISSING_DRAW_POSITIONS","DRAW_POSITION_ACTIVE","INVALID_DRAW_POSITION","MISSING_DRAW_POSITION","INVALID_DRAW_TYPE","INVALID_DRAW_SIZE","DRAW_SIZE_MISMATCH","MISSING_DRAW_SIZE","MISSING_DRAW_ID","DRAW_ID_EXISTS","INVALID_PARTICIPANT_SEEDING","SEEDSCOUNT_GREATER_THAN_DRAW_SIZE","MISSING_SEEDCOUNT_THRESHOLDS","INVALID_ACTION","INVALID_ASSIGNMENT","MISSING_SEED_ASSIGNMENTS","INVALID_SEED_NUMBER","INVALID_SEED_POSITION","MISSING_TARGET_LINK","EXISTING_ROUND","MISSING_STRUCTURE_ID","STRUCTURE_NOT_FOUND","MISSING_STRUCTURES","MISSING_STRUCTURE","UNLINKED_STRUCTURES","INVALID_EVENT_TYPE","MISSING_EVENT","EVENT_NOT_FOUND","EVENT_EXISTS","MISSING_ENTRIES","INVALID_ENTRIES","MISSING_ASSIGNMENTS","MISSING_STAGE","INVALID_STAGE","STAGE_SEQUENCE_LIMIT","MISSING_POSITION_ASSIGNMENTS","INVALID_MATCHUP_STATUS_BYE","UNRECOGNIZED_MATCHUP_STATUS","UNRECOGNIZED_MATCHUP_FORMAT","INCOMPATIBLE_MATCHUP_STATUS","INVALID_MATCHUP_STATUS","INVALID_TIE_FORMAT","INVALID_MATCHUP_FORMAT","MISSING_MATCHUP_FORMAT","MISSING_COLLECTION_DEFINITION","MISSING_TIE_FORMAT","MISSING_MATCHUP_ID","MISSING_MATCHUP_IDS","MATCHUP_NOT_FOUND","MISSING_MATCHUPS","MISSING_MATCHUP","INVALID_MATCHUP","MISSING_POLICY_TYPE","MISSING_POLICY_DEFINITION","MISSING_AVOIDANCE_POLICY","MISSING_POLICY_ATTRIBUTES","INVALID_POLICY_DEFINITION","EXISTING_POLICY_TYPE","POLICY_NOT_FOUND","INVALID_SIDE_NUMBER","MISSING_SET_OBJECT","MISSING_COURT_ID","MISSING_VALUE","MISSING_DATE","NO_VALID_DATES","INVALID_BOOKINGS","INVALID_DATE_AVAILABILITY","MISSING_DATE_AVAILABILITY","INVALID_DATE","INVALID_TIME","INVALID_TOURNAMENT_DATES","INVALID_GAME_SCORES","INVALID_SCORE","INVALID_WINNING_SIDE","NO_PARTICIPANTS_GENERATED","CANNOT_MODIFY_TIEFORMAT","CANNOT_MODIFY_PARTICIPANT_TYPE","CANNOT_REMOVE_PARTICIPANTS","CANNOT_CHANGE_WINNING_SIDE","INVALID_PARTICIPANT","INVALID_PARTICIPANT_ID","INVALID_PARTICIPANT_IDS","INVALID_PARTICIPANT_ROLE","INVALID_PARTICIPANT_TYPE","MISSING_PARTICIPANT_ROLE","MISSING_PARTICIPANT","MISSING_PARTICIPANTS","MISSING_PARTICIPANT_ID","PARTICIPANT_NOT_FOUND","PARTICIPANT_ID_EXISTS","NO_PARTICIPANT_REMOVED","MISSING_PARTICIPANT_IDS","MISSING_PARTICIPANT_COUNT","PARTICIPANT_NOT_CHECKED_IN","MISSING_PERSON_DETAILS","EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT","EXISTING_PARTICIPANT","PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE","INVALID_ENTRY_STATUS","PARTICIPANT_ENTRY_NOT_FOUND","PARTICIPANT_NOT_ENTERED_IN_STAGE","PARTICIPANT_NOT_FOUND_IN_STAGE","ENTRY_STATUS_NOT_ALLOWED_IN_STAGE","ENTRY_STATUS_NOT_ALLOWED_FOR_EVENT","NO_STAGE_SPACE_AVAILABLE_FOR_ENTRY_STATUS","NO_DRAW_POSITIONS_AVAILABLE_FOR_QUALIFIERS","INSUFFICIENT_DRAW_POSITIONS","MISSING_PENALTY_TYPE","MISSING_PENALTY_ID","PENALTY_NOT_FOUND","MISSING_COURTS_INFO","COURT_NOT_FOUND","COURT_EXISTS","VENUE_EXISTS","VENUE_NOT_FOUND","MISSING_VENUE_ID","INVALID_END_TIME","EXISTING_END_TIME","INVALID_STOP_TIME","INVALID_START_TIME","INVALID_RESUME_TIME","INVALID_TIME_ITEM","MISSING_ASYNC_STATE_PROVIDER","MISSING_TIME_ITEM","MISSING_TIME_ITEMS","MISSING_CONTEXT","MISSING_SCHEDULE","INVALID_SCALE_ITEM","MODIFICATIONS_FAILED","NO_MODIFICATIONS_APPLIED","UNABLE_TO_ASSIGN_COURT","NO_CANDIDATES","INVALID_CONFIGURATION","INVALID_COLLECTION_DEFINITION","INVALID_OBJECT","INVALID_GENDER","INVALID_CATEGORY","INVALID_VALUES","DUPLICATE_VALUE","TEAM_NOT_FOUND","NO_VALID_ACTIONS","NO_VALID_ATTRIBUTES","VALUE_UNCHANGED","NOT_FOUND","NOT_IMPLEMENTED","EXISTING_FLIGHT","EXISTING_PROFILE","EXISTING_OUTCOME","EXISTING_MATCHUP_ID","EXISTING_STAGE","EXISTING_STRUCTURE","METHOD_NOT_FOUND","SCHEDULED_MATCHUPS","SCORES_PRESENT","errorConditionConstants","DRAW_POSITION_NOT_FOUND","INVALID_SET_NUMBER","MISSING_ROUND_NUMBER","MISSING_SCORING_POLICY","MISSING_SEEDING_POLICY","MISSING_SET_NUMBER","MISSING_SIDE_NUMBER","PARTICIPANT_PAIR_EXISTS","POLICY_NOT_ATTACHED","syncGlobalState","disableNotifications","tournamentId","tournamentRecords","subscriptions","modified","methods","notices","syncGlobalState$1","addNotice","topic","payload","key","notice","callListener","method","cycleMutationStatus","status","deleteNotice","deleteNotices","enableNotifications","getMethods","getNotices","getTopics","topics","getTournamentId","getTournamentRecord","getTournamentRecords","removeTournamentRecord","error","tournamentIds","setMethods","params","forEach","methodName","setSubscriptions","subscription","setTournamentId","setTournamentRecord","tournamentRecord","setTournamentRecords","handleCaughtError","engineName","err","toUpperCase","Error","console","JSON","stringify","engine","globalState","tournamentFactoryVersion","timers","default","elapsedTime","deepCopyAttributes","ignore","toJSON","deepCopy","_globalStateProvider","requiredStateProviderMethods","createInstanceState","getDevContext","contextCriteria","devContext","every","setGlobalLog","loggingFx","globalLog","setDevContext","setDeepCopy","attributes","threshold","deepCopyEnabled","enabled","info","async","getProvider","globalStateProvider","action","timer","timeNow","Date","now","startTime","currentTimer","elapsedPeriod","state","definedAttributes","ignoreFalse","ignoreEmptyArrays","shallow","ignoreValues","definedKeys","getDefinedKeys","assign","m","decorateResult","context","result","stack","ELEMENT_REQUIRED","MISSING_NAME","removeExtension","element","name","discover","extensions","extension","isValidExtension","requiredAttributes","extensionAttributes","attribute","addExtension","creationTime","createdAt","toISOString","existingExtension","find","findExtension","attr","validDateString","validTimeString","dateValidation","timeValidation","getIsoDateString","schedule","scheduledDate","scheduledTime","extractDate","extractedTime","extractTime","isoDateString","isDateObject","prototype","call","validTimeValue","spaceSplit","split","test","convertTime","isValidDateString","scheduleDate","isISODateString","getUTCdateString","date","dateDate","isDate","monthNumber","getUTCMonth","utcMonth","getUTCFullYear","zeroPad","getUTCDate","formatDate","separator","format","d","month","getMonth","day","getDate","year","getFullYear","join","offsetDate","targetTime","tzDifference","getTimezoneOffset","getTime","dateArg","t","valueOf","generateDateRange","startDt","endDt","startDateString","endDateString","startDate","endDate","between","iterations","currentDate","dateSecs","setDate","re","dateString","isTimeString","timeString","parts","part","timeStringMinutes","hours","minutes","tidyTime","slice","reverse","dateStringDaysChange","daysChange","splitTime","o","time","ampm","time24","keepDate","hasDate","timeValue","toLowerCase","militaryTime","regularTime","timeSort","as","bs","addDays","days","universalDate","timeToDate","milliseconds","setHours","minutesDifference","date1","date2","absolute","dt1","diff","abs","addMinutesToTimeString","minutesToAdd","addMinutes","number","sameDay","d1","d2","dateTime","addWeek","DateHHMM","dt","secondNumber","seconds","displaySeconds","HHMMSS","getSeconds","getMinutes","getHours","getDateByWeek","week","dateFormat","sunday","startValue","getDay","offsetTime","timeUTC","UTC","makeDeepCopy","sourceObject","convertExtensions","internalUse","removeExtensions","iteration","modulate","targetObject","sourceObjectKeys","stringifyValue","modulated","extensionConversions","extensionsToAttributes","Boolean","getAccessorValue","accessor","targetElement","processKeys","significantCharacters","entries","remainingKeys","nestedTarget","checkValue","extractedValue","isFunction","isString","isObject","objShallowEqual","o1","o2","keys1","keys2","createMap","objectArray","extractAttributes","xa","countKeys","TOURNAMENT_RECORDS","POLICY_DEFINITIONS","TOURNAMENT_RECORD","DRAW_DEFINITION","MATCHUP_FORMAT","PARTICIPANT_ID","SCHEDULE_DATES","STRUCTURE_ID","PARTICIPANT","MATCHUP_IDS","STRUCTURES","MATCHUP_ID","IN_CONTEXT","STRUCTURE","COURT_IDS","VENUE_IDS","MATCHUPS","COURT_ID","EVENT_ID","MATCHUP","DRAW_ID","EVENT","PARAM","OBJECT","ARRAY","VALIDATE","INVALID","OF_TYPE","ONE_OF","errors","paramTypes","uuids","checkRequiredParameters","requiredParams","_bypassParamCheck","valid","paramError","errorParam","_ofType","_oneOf","_anyOf","validate","attrs","oneOf","getIntersection","param","getOneOf","anyOf","getAnyOf","booleanParams","invalidParam","invalidValidationFunction","faliedTypeCheck","invalidType","paramNotPresent","hasError","checkValidation","findParamError","invalid","constraint","DYNAMIC","RANKING","RATING","SCALE","SEEDING","scaleConstants","getScaleValues","paramCheck","scaleItems","participant","timeItems","itemType","startsWith","scales","ratings","rankings","seedings","latestScaleItem","scaleType","timeItem","pop","itemTypes","scaleItem","type","scaleName","modifier","namedScale","scaleValue","itemValue","scaleDate","itemDate","attributeFilter","source","template","target","attributeCopy","valuesObject","templateObject","outputObject","vKeys","oKeys","orMap","or","flat","allKeys","wildcard","vKey","tobj","vobj","mappedElements","arrayMember","POLICY_TYPE_VOLUNTARY_CONSOLATION","POLICY_TYPE_COMPETITIVE_BANDS","POLICY_TYPE_ROUND_ROBIN_TALLY","POLICY_TYPE_POSITION_ACTIONS","POLICY_TYPE_MATCHUP_ACTIONS","POLICY_TYPE_RANKING_POINTS","POLICY_TYPE_ROUND_NAMING","POLICY_TYPE_PARTICIPANT","POLICY_TYPE_PROGRESSION","POLICY_TYPE_SCHEDULING","POLICY_TYPE_AVOIDANCE","POLICY_TYPE_SCORING","POLICY_TYPE_SEEDING","POLICY_TYPE_FEED_IN","POLICY_TYPE_DRAWS","policyConstants","POLICY_TYPE_DISPLAY","POLICY_TYPE_AUDIT","findParticipant","tournamentParticipants","policyDefinitions","contextProfile","participantId","personId","candidate","person","participantAttributes","withScaleValues","addTournamentExtension","addDrawDefinitionExtension","drawDefinition","addEventExtension","event","removeTournamentExtension","removeEventExtension","APPLIED_POLICIES","AUDIT_POSITION_ACTIONS","CONTEXT","DELEGATED_OUTCOME","DISABLED","DISABLE_LINKS","DISABLE_AUTO_CALC","DRAW_DELETIONS","ENTRY_PROFILE","FLIGHT_PROFILE","GROUPING_ATTRIBUTE","LINEUPS","LINKED_TOURNAMENTS","MATCHUP_HISTORY","PARTICIPANT_REPRESENTATIVES","PERSON_REQUESTS","RANKING_POINTS","ROUND_TARGET","SCHEDULE_LIMITS","SCHEDULE_TIMING","SCHEDULING_PROFILE","SUB_ORDER","TALLY","TIE_FORMAT_MODIFICATIONS","extensionConstants","ACTIVE_SUSPENSION","DRAW_PROFILE","EVENT_PROFILE","EVENT_WITHDRAWAL_REQUESTS","STATUS_DETAIL","FACTORY","internalExtensions","getTournamentIds","competitionGovernor","linkTournaments","unlinkTournament","unlinkError","currentTournamentId","linkedTournamentIds","linkedTournamentId","unlinkTournaments","extractor","object","getMatchUpIds","getMatchUpId","getParticipantIds","getParticipantId","ABANDONED","AWAITING_RESULT","BYE","CANCELLED","COMPLETED","DEAD_RUBBER","DEFAULTED","DOUBLE_DEFAULT","DOUBLE_WALKOVER","IN_PROGRESS","INCOMPLETE","NOT_PLAYED","RETIRED","SUSPENDED","TO_BE_PLAYED","WALKOVER","recoveryTimeRequiredMatchUpStatuses","particicipantsRequiredMatchUpStatuses","validMatchUpStatuses","directingMatchUpStatuses","nonDirectingMatchUpStatuses","completedMatchUpStatuses","activeMatchUpStatuses","upcomingMatchUpStatuses","matchUpStatusConstants","MAIN","QUALIFYING","CONSOLATION","VOLUNTARY_CONSOLATION","PLAY_OFF","validStages","stageOrder","FINISHING_POSITIONS","AGGREGATE_EVENT_STRUCTURES","finishOrder","aggregateOrder","CLUSTER","WATERFALL","ITEM","CONTAINER","DRAW","RANDOM","TOP_DOWN","BOTTOM_UP","POSITION","WINNER","LOSER","FIRST_MATCHUP","AD_HOC","FEED_IN","COMPASS","OLYMPIC","SINGLE_ELIMINATION","DOUBLE_ELIMINATION","FIRST_MATCH_LOSER_CONSOLATION","FIRST_ROUND_LOSER_CONSOLATION","LUCKY_DRAW","CURTIS","CURTIS_CONSOLATION","FICSF","FEED_IN_CHAMPIONSHIP_TO_SF","FICQF","FEED_IN_CHAMPIONSHIP_TO_QF","FICR16","FEED_IN_CHAMPIONSHIP_TO_R16","MFIC","MODIFIED_FEED_IN_CHAMPIONSHIP","FEED_IN_CHAMPIONSHIP","ROUND_ROBIN","ROUND_ROBIN_WITH_PLAYOFF","DECIDER","BACKDRAW","COMPASS_ATTRIBUTES","abbreviation","OLYMPIC_ATTRIBUTES","WIN_RATIO","ROUND_OUTCOME","MULTI_STRUCTURE_DRAWS","drawDefinitionConstants","FLEX_ROUNDS","KNOCKOUT","generatedDrawTypes","structureSort","config","getRoundTarget","completed","deprioritizeCompleted","aggregate","mode","finish","orderProtocol","protocolSequence","stage","stageSequence","isMain1","completedStructure","matchUps","matchUpStatus","positionAssignments","getMinFinishingPositionRange","structure","rangeSum","matchUp","sum","finishingPositionRange","winner","findStructure","structureId","structures","getDrawStructures","allStructures","containingStructure","structureType","withStageGrouping","stageSequences","roundTarget","sortConfig","stages","stageStructures","relevantStructures","stage2","getAllPositionedParticipantIds","stagePositionedParticipantIds","allPositionedParticipantIds","getPositionAssignments","particiapntIds","structureAssignedDrawPositions","assignedPositions","assignment","bye","qualifier","allPositionsAssigned","unassignedPositions","byePositions","qualifierPositions","SIGN_IN_STATUS","SIGNED_OUT","SIGNED_IN","TEAM_PARTICIPANT","INDIVIDUAL","GROUP","PAIR","TEAM","participantTypes","participantConstants","addParticipantGroupings","participantsProfile","participants","groupMap","Map","participantsWithGroupings","teamParticipants","participantType","groupParticipants","pairParticipants","groupParticipantIds","teamParticipantIds","pairParticipantIds","groups","teams","team","individualParticipantIds","individualParticipantId","get","set","participantName","participantRoleResponsibilities","participantOtherName","teamId","pair","group","groupInfo","fromEntries","countryToFlag","isoCode","String","fromCodePoint","replace","char","charCodeAt","countries","ioc","iso2","iso","label","phone","suggested","addNationalityCode","withISO2","withIOC","individualParticipants","nationalityCode","country","iocNationalityCode","iso2NationalityCode","countryName","findTournamentParticipant","getTimeItem","returnPreviousValues","itemSubTypes","filteredSorted","subType","previousItems","getEventTimeItem","getTournamentTimeItem","SINGLES_MATCHUP","SINGLES","DOUBLES_MATCHUP","DOUBLES","TEAM_MATCHUP","matchUpTypes","typeMap","TEAM$2","membershipMap","getParticipantMap","withIndividualParticipants","withSignInStatus","participantMap","initializeParticipantId","participantCopy","processIndividualParticipantIds","signedIn","participantObjects","participantObject","addIndividualParticipants","individualParticipant","partnerParticipantId","id","pairIdMap","counters","walkoverWins","defaultWins","walkovers","defaults","losses","wins","structureParticipation","potentialMatchUps","scheduleConflicts","scheduleItems","statistics","opponents","events","draws","SINGLES$1","DOUBLES$1","hydrateParticipants","useParticipantMap","inContext","withGroupings","reduceGroupedOrder","groupedOrder","roundPositionsCount","chunkValues","chunk","sortedChunks","chunkValue","getTargetMatchUp","sourceRoundMatchUpCount","inContextDrawMatchUps","sourceRoundPosition","targetLink","feedProfile","roundNumber","positionInterleave","targetStructure","structureMatchUps","targetRoundMatchUps","matchUpTieId","targetRoundMatchUpCount","roundPositions","matchUpCountFactor","calculatedRoundPosition","matchUpDrawPositionIndex","interleave","relativeRoundPosition","offset","orderedPositions","targetedRoundPosition","sizedGroupOrder","groupsCount","order","current","roundPosition","targetDrawPosition","feedRound","drawPositions","relevantAssignment","drawPosition","disabledDrawPosition","getTargetLink","finishingPositions","linkCondition","linkType","link","positionCondition","getStructureLinks","links","structureLinks","positionTargets","useTargetMatchUpIds","inContextMatchUp","matchUpId","finishingPosition","winnerMatchUpId","loserMatchUpId","getRoundLinks","winnerTargetLink","byeTargetLink","loserTargetLink","propagateByeFMLC","winnerFeedProfile","loserFeedProfile","byeFeedProfile","byeMatchUp","byeTargetDrawPosition","byeMatchUpDrawPositionIndex","loserMatchUp","loserTargetDrawPosition","loserMatchUpDrawPositionIndex","winnerMatchUp","winnerTargetDrawPosition","winnerMatchUpDrawPositionIndex","targetLinks","targetMatchUps","count","currentMatchUp","currentRoundMatchUps","nextRoundMatchUps","nextMatchUp","getNextRoundMatchUp","targetMatchUpIds","targetByRoundOutcome","targetByWinRatio","validMatchUp","validMatchUpId","validDrawPositions","dp","validMatchUps","getRoundMatchUps","interpolate","roundMatchUps","roundMatchUpsArray","roundNumbers","consideredMatchUps","matchUpType","items","finishingRoundMap","mapping","abbreviatedRoundName","finishingRound","roundName","maxRoundNumber","f","maxRoundMatchUpsCount","nextRound","maxMatchUpsCount","roundProfile","matchUpsCount","inactiveCount","score","scoreStringSide1","inactiveRound","roundIndex","feedRoundIndex","currentRoundDrawPositions","roundFactor","priorRound","priorRoundDrawPositions","chunkFactor","priorRoundDrawPositionChunks","roundDrawPositions","filteredDrawPositions","isFeedRound","targetChunkIndex","pairedDrawPositions","orderedDrawPositions","preFeedRound","roundsNotPowerOf2","hasNoRoundPositions","addUpcomingMatchUps","scheduleConflictMatchUpIds","nextRoundNumber","sidesTo","nextRoundMatchUp","sideNumber","structureName","targetData","winnerTo","getUpcomingInfo","upcomingMatchUp","loserTo","getNextToBePlayedMatchUp","timeAfterRecovery","scheduleConflict","firstMatchUp","sides","winnerParticipantIds","loserParticipantIds","winnerPotentials","loserPotentials","tbd","potentialParticipants","getAppliedPolicies","onlySpecifiedPolicyTypes","policyTypes","appliedPolicies","extractAppliedPolicies","extensionPolicies","getPolicyDefinitions","policyType","policy","COMPETITIVE","ROUTINE","DECISIVE","POLICY_COMPETITIVE_BANDS_DEFAULT","policyName","profileBands","getContextContent","contextContent","policies","withCompetitiveness","getExitProfiles","exitProfiles","initialStructure","addExitProfiles","aggregator","targetRound","exitProfile","relevantLinks","exitRound","targetStructureId","fp","getMatchUpsMap","mappedMatchUps","drawMatchUps","isRoundRobin","itemStructure","filteredMatchUps","itemStructureIds","tieMatchUps","getMappedStructureMatchUps","matchUpsMap","structureMatchUpsMap","itemStructureMatchUps","itemStructureId","containerStructureId","getCollectionPositionAssignments","collectionPosition","collectionId","lineUp","assignedParticipantIds","substitutions","getOrderValue","competitorAssignments","teamCompetitor","collectionAssignments","substitutionOrder","competitorAssignment","previousParticipantId","getPairedParticipant","participantIds","existingPairedParticipants","existingPairedParticipant","duplicatedPairParticipants","getTeamLineUp","modifyEntryProfile","entryProfile","getEntryProfile","ALTERNATE","CONFIRMED","DIRECT_ACCEPTANCE","JUNIOR_EXEMPT","LUCKY_LOSER","ORGANISER_ACCEPTANCE","QUALIFIER","SPECIAL_EXEMPT","UNGROUPED","UNPAIRED","WILDCARD","WITHDRAWN","EQUIVALENT_ACCEPTANCE_STATUSES","DRAW_SPECIFIC_STATUSES","DIRECT_ENTRY_STATUSES","STRUCTURE_SELECTED_STATUSES","VALID_ENTRY_STATUSES","entryStatusConstants","stageExists","exists","drawSize","alternates","getStageEntryTypeCount","entryStatus","entryStage","getStageEntries","provisionalPositioning","placementGroup","entryStatuses","entryRoundTarget","stageTarget","matchesEntryType","entryStageSequence","playoffEntries","inboundLink","sourceStructure","playoffStructureId","groupingValue","results","uniqueFinishingPositions","groupOrder","provisionalOrder","finishingPositionsAreUnique","participantResult","GEMscore","getPlayoffEntries","getStructureSeedAssignments","returnAllProxies","seedAssignments","proxiedEntries","seedNumber","seedValue","seedProxy","seedProxies","seedLimit","add","getBand","spread","bandProfiles","spreadValue","getScoreComponents","sets","games","side1Score","side2Score","stb","side1TiebreakScore","side2TiebreakScore","gamesPercent","scoreComponents","minGames","maxGames","pctSpread","pcts","findPolicy","getMatchUpCompetitiveProfile","winningSide","competitiveness","pctSpreadValue","getMatchUpParticipantIds","hasContext","sideParticipantIds","side","sideIndividualParticipantIds","nestedIndividualParticipantIds","allRelevantParticipantIds","CHECK_IN","CHECK_OUT","ASSIGN_VENUE","ALLOCATE_COURTS","ASSIGN_COURT","COURT_ORDER","SCHEDULED_DATE","ASSIGN_OFFICIAL","SCHEDULED_TIME","START_TIME","STOP_TIME","RESUME_TIME","END_TIME","TIME_MODIFIERS","TO_BE_ANNOUNCED","NEXT_AVAILABLE","FOLLOWED_BY","AFTER_REST","RAIN_DELAY","MUTUALLY_EXCLUSIVE_TIME_MODIFIERS","PUBLISH","PUBLIC","STATUS","timeItemConstants","COMPLETED_DATE","ELIGIBILITY","MEDICAL","MODIFICATION","NOT_BEFORE","OTHER","PENALTY","REGISTRATION","RETRIEVAL","SCHEDULE","SUSPENSION","getCheckedInParticipantIds","checkInItems","checkedInParticipantIds","sideIndex","sideParticipantId","allIndividualsCheckedIn","allParticipantsCheckedIn","checkedIn","findMatchupFormatAverageTimes","matchUpAverageTimes","matchUpFormat","codeMatches","matchUpFormatCodes","targetCode","targetDefinition","averageTimes","findMatchupFormatRecoveryTimes","matchUpRecoveryTimes","averageMinutes","recoveryTimes","greaterThan","lessThan","findCategoryTiming","timesBlockArray","categoryName","categoryType","times","categoryNames","categoryTypes","getScheduleTiming","category","ageCategoryCode","tournamentExtension","tournamentScheduling","eventExtension","eventScheduling","scheduleTiming","SINGLES_EVENT","DOUBLES_EVENT","TEAM_EVENT","eventConstants","AGE","BOTH","DOUBLES_SINGLES","SINGLES_DOUBLES","TOTAL","CONFLICT_PARTICIPANTS","CONFLICT_MATCHUP_ORDER","SCHEDULE_ISSUE_IDS","SCHEDULE_CONFLICT","SCHEDULE_WARNING","SCHEDULE_ERROR","SCHEDULE_ISSUE","SCHEDULE_STATE","scheduleConstants","getMatchUpFormatTiming","defaultAverageMinutes","defaultRecoveryMinutes","eventType","defaultTiming","matchUpFormatTimes","timingDetails","defaultTimes","getMatchUpFormatAverageTimes","averageKeys","getMatchUpFormatRecoveryTimes","recoveryKeys","recoveryMinutes","formatChangeKey","typeChangeRecoveryMinutes","getTimeStamp","latestVisibleTimeItemValue","visibilityThreshold","latestVisible","timeStamp","scheduledMatchUpTime","itemTimeStamp","scheduledMatchUpDate","matchUpAllocatedCourts","allocatedCourts","matchUpAssignedCourtId","courtId","matchUpAssignedVenueId","venueId","getLinkedTournamentIds","touranmentId","resolveTournamentRecords","UUID","lut","d0","d3","ADD_DRAW_DEFINITION","ADD_MATCHUPS","ADD_PARTICIPANTS","ADD_SCALE_ITEMS","ADD_VENUE","AUDIT","DELETE_PARTICIPANTS","DELETE_VENUE","DELETED_DRAW_IDS","DELETED_MATCHUP_IDS","MODIFY_DRAW_DEFINITION","MODIFY_DRAW_ENTRIES","MODIFY_EVENT_ENTRIES","MODIFY_MATCHUP","MODIFY_PARTICIPANTS","MODIFY_POSITION_ASSIGNMENTS","MODIFY_SEED_ASSIGNMENTS","MODIFY_TOURNAMENT_DETAIL","MODIFY_VENUE","MUTATIONS","PUBLISH_EVENT","PUBLISH_EVENT_SEEDING","PUBLISH_ORDER_OF_PLAY","UNPUBLISH_EVENT","UNPUBLISH_EVENT_SEEDING","UNPUBLISH_ORDER_OF_PLAY","UPDATE_INCONTEXT_MATCHUP","topicConstants","addVenue","disableNotice","venue","addedVenue","venueAdd","venues","existingVenue","findVenue","venueRecord","relevantIds","findCourt","court","courts","courtRecord","getCourtInfo","courtInfo","altitude","courtName","courtDimensions","latitude","longitude","surfaceCategory","surfaceType","surfacedDate","pace","notes","getVenueData","courtsInfo","venueInfo","venueName","venueAbbreviation","venueData","matchUpTimeModifiers","timeModifiers","timeDate","msToTime","pad","z","getFlightProfile","eventId","flightProfile","drawDefinitions","flights","flight","drawId","findEvent","eventIdsMap","targetDrawDefinition","drawEntries","drawName","getMatchUpScheduleDetails","scheduleVisibilityFilters","afterRecoveryTimes","usePublishState","publishStatus","relevantTimeItems","elapsed","itemTypeComponents","scheduleType","lastValue","lastType","interval","matchUpDuration","startTimeItem","startTimeCandidate","matchUpStartTime","endTime","endTimeItem","endTimeCandidate","matchUpEndTime","eventIds","drawIds","scheduleSource","courtOrder","matchUpCourtOrder","typeChangeTimeAfterRecovery","venueDataMap","allocatedCourt","venueid","vData","displaySettings","drawSettings","scheduleDetails","scheduleAttributes","details","dates","getObjectTieFormat","tieFormatId","tieFormats","tieFormat","tf","getItemTieFormat","structureTieFormat","resolveTieFormat","getRangeString","numericArray","TIMED","NOAD","SET","setTypes","S","F","parse","matchUpFormatCode","setFormat","parseTimedSet","simplified","bestOf","formatstring","setsCount","getNumber","exactly","parseSetFormat","finalSetFormat","timed","validSetsCount","validFinalSet","validSetsFormat","setsMatch","setType","setFormatString","tiebreakSet","parseTiebreakFormat","match","NoAD","isNoAD","validNoAD","setTo","tiebreakAtValue","parseTiebreakAt","validTiebreakAt","tiebreakAt","tiebreakFormat","validTiebreak","noTiebreak","expectNumber","tiebreakToString","tiebreakTo","timestring","based","validModifier","isLucky","hasDrawPositions","drawType","isAdHoc","hasRoundPosition","hasDrawPosition","POLICY_ROUND_NAMING_DEFAULT","namingConventions","pre","qualifyingFinishMap","abbreviatedRoundNamingMap","roundNamingMap","affixes","preQualifying","stageConstants","getMatchUpType","filterMatchUps","isCollectionMatchUp","excludeMatchUpStatuses","matchUpStatuses","hasWinningSide","matchUpFormats","collectionIds","isMatchUpTie","matchUpIds","roundNames","scheduledDates","processContext","structureIds","readyToScore","courtIds","venueIds","filterMatchUpIds","filterMatchUpTypes","targetParticipantIds","targetMatchUpStatuses","excludeTargetMatchUpStatuses","targetStages","targetStageSequences","targetCollectionIds","targetRoundNames","targetRoundNumbers","targetRoundPositions","targetMatchUpTypes","targetCourtIds","targetVenueIds","targetMatchUpFormats","targetScheduledDates","targetTournamentIds","targetEventIds","targetDrawIds","targetStructureIds","matchUpDate","comparisonDate","allocatedCourtIds","matchUpParticipantIds","getSide","drawPositionCollectionAssignment","sideNumberCollectionAssignment","displaySideNumber","dpc","snc","sideValue","seeding","getSeeding","getSideValue","participantFed","participantAdvanced","teamParticipant","ANY","MALE","MIXED","FEMALE","genderConstants","getAllStructureMatchUps","tournamentAppliedPolicies","contextFilters","matchUpFilters","collectionPositionMatchUps","selectedEventIds","selectedStructureIds","selectedDrawIds","targetEvent","targetDraw","drawAppliedPolicies","structureScoringPolicies","scoring","stageSpecificPolicies","sequenceSpecificPolicies","requireAllPositionsAssigned","scoringActive","structureSeedAssignments","roundOffset","initialRoundOfPlay","roundNamingPolicy","structureAbbreviation","isAdHocStructure","isLuckyStructure","roundNamingProfile","defaultRoundNamingPolicy","isQualifying","qualifyingStageSequences","preQualifyingSequence","preQualifyingAffix","preFeedAffix","roundNumberAffix","roundNameFallback","stageInitial","stageConstant","roundProfileKeys","qualifyingAffix","qualifyingFinishgMap","participantsCount","sizedRoundName","suffix","sizedAbbreviation","getRoundContextProfile","sourceDrawPositionRanges","sourceStructureIds","sourceStructureId","sourceStructureProfiles","targetStructureProfile","sourceRoundNumber","targetRoundNumber","sourceStructureProfile","firstRoundDrawPositions","sourceRoundProfile","sourceRoundMatchUpsCount","chunkSize","targetRoundMatchUpsCount","drawPositionBlocks","block","unshift","targetLength","targetRoundProfile","increment","columnPosition","getSourceDrawPositionRanges","drawPositionsRanges","firstRoundFirstDrawPositionOffset","firstRoundDrawPositionsChunks","firstRoundDrawPositionsRanges","firstRoundOffsetDrawPositionsRanges","currentRoundDrawPositionChunks","possibleDrawPositions","possible","finalGroup","roundPositionsMap","firstRoundDrawPositionsRange","firstRoundOffsetDrawPositionsRange","drawPositionsRange","getDrawPositionsRanges","addMatchUpContext","matchUpTies","matchUpTie","collectionPositionMatchUpsArray","collectionPositions","getCollectionPositionMatchUps","additionalContext","tieDrawPositions","isCollectionBye","sideLineUps","collectionDefinitions","collectionDefinition","definition","collectionAssignmentDetail","getAssignment","pairedParticipantId","teamParticipantId","getCollectionAssignment","drawPositionsRoundRanges","sourceDrawPositionRoundRanges","matchUpCategory","processCodes","competitiveProfile","onlyDefined","matchUpWithContext","gender","roundOfPlay","discipline","parsedFormat","setNumber","displayOrder","unassignedDrawPositions","getOrderedDrawPositions","reversedDisplayOrder","existingSide","existing","sourceDrawPositionRange","getMappedParticipant","inferGender","sideGenders","sex","pairGenders","inferredGender","lineUps","participanOthertName","hasParticipants","hasNoWinner","exclude","checkMatchUpIsComplete","getStructureMatchUps","requireParticipants","abandonedMatchUps","completedMatchUps","upcomingMatchUps","pendingMatchUps","byeMatchUps","participantAssignedDrawPositions","includesTeamMatchUps","teamsMatchUpsOnly","collectionSidesAssigned","drawPositionsFilled","drawPositionsAssigned","byeAssignedDrawPositions","isByeMatchUp","isUpcomingMatchUp","getAllDrawMatchUps","getDrawMatchUps","nextMatchUps","allAbandonedMatchUps","allCompletedMatchUps","allUpcomingMatchUps","allPendingMatchUps","allByeMatchUps","applyFilter","drawMatchUpsResult","nextFilter","abandoned","upcoming","pending","allDrawMatchUps","eventName","indoorOutDoor","indoorOutdoor","getStructureRoundProfile","getFinishingPositionSourceRoundsMap","sourceRounds","roundValues","rangeDefinition","position","includesNonInteger","positionIsInRange","loser","roundValueRanges","getPositionsPlayedOff","allFinishingPositionRanges","positionsPlayedOff","positionRange","positionsNotPlayedOff","getSourceRounds","excludeRoundNumbers","playoffPositions","playoffPositionSourceRoundsMap","relevantPlayoffSourceRounds","rounds","playedOffRoundsMap","roundsMapValues","playedOffSourceRounds","playoffSourceRounds","playoffPositionsReturned","playoffRoundsRanges","getPlayoffRoundsRanges","getAvailablePlayoffProfiles","filteredStructures","available","availablePlayoffProfiles","availablePlayoffRounds","positionsCount","groupCount","groupSize","finishingPositionsPlayedOff","flatMap","finishingPositionsAvailable","positionsInTargetStructures","availablePlayoffPositions","positionChunks","playoffFinishingPositionRanges","linkSourceRoundNumbers","potentialFirstMatchUpRounds","sourceRoundsResult","playoffRounds","availableToProgress","minFinishingPosition","maxFinishingPosition","roundsRange","drawUpdatedAt","updatedAt","relevantStructureIds","addMatchUpsNotice","deleteMatchUpsNotice","modifyMatchUpNotice","modifyDrawNotice","addDrawNotice","modifySeedAssignmentsNotice","modifyPositionAssignmentsNotice","conditionallyDisableLinkPositioning","relevantAssignments","addPositionActionTelemetry","positionAction","existingValue","mainStructure","initialAssignments","getContainedStructures","containedStructures","containerStructures","structureContainers","dd","structureContainer","checkScoreHasValue","firstSet","side1PointScore","side2PointScore","firstSetScore","isDirectingMatchUpStatus","isNonDirectingMatchUpStatus","isActiveMatchUp","participantAssigned","activeTieMatchUps","isActiveMatchUpStatus","getIndividualParticipantIds","potentialIndividualParticipantIds","enteredIndividualParticipantIds","addFinishingRounds","finishingPositionOffset","finishingPositionLimit","positionsFed","roundsCount","roundLimit","lucky","fmlc","finishingRoundOffset","minQualifyingPosition","roundMatchUpsCountArray","finishingRange","roundFinishingData","finishingData","rangeOffset","slicer","roundData","addGoesTo","goesToMap","loserMatchUpIds","winnerMatchUpIds","hasFinishingPositionRanges","loserRange","allEventMatchUps","hydratedParticipantResult","allTournamentMatchUps","eventDrawsCount","allCompetitionMatchUps","matchUpSort","stageDifference","getMatchUpDependencies","includeParticipantDependencies","positionDependencies","matchUpDependencies","sourceStructureIdMap","sourceMatchUpIds","allTournamentRecords","positionLinks","allLinks","initializeMatchUpId","dependentMatchUpIds","sources","propagateDependencies","targetMatchUpId","matchUpIdDependency","participantIdDependency","processMatchUps","matchUpsToProcess","processSourceStructures","s1","s2","relevantStructureId","matchUpDependency","allDrawIds","hasTournamentId","getStructureDrawPositionProfiles","findContainer","containedStructureIds","inContextStructureMatchUps","activeDependentMatchUpIdsCollection","drawPositionsCollection","drawPositionInitialRounds","activeMatchUps","activeDependentMatchUpIds","activeDrawPositions","byeDrawPositions","qualifyingDrawPositions","inactiveDrawPositions","allDrawPositions","getInitialRoundNumber","initialRoundNumber","logColors","reset","bright","dim","red","brightred","green","brightgreen","yellow","brightyellow","blue","brightblue","lightblue","magenta","brightmagenta","cyan","brightcyan","white","brightwhite","pushGlobalLog","devContextOverride","printGlobalLog","purge","globalLogCopy","getGlobalLog","modifiedText","line","color","keyColors","newline","methodColor","body","keyColor","assignDrawPositionBye","isPositionAction","currentAssignment","drawPositionIsActive","positionAssignment","filled","containsBye","assignedParticipantId","containsQualifier","drawPositionFilled","setMatchUpStatusBYE","assignRoundRobinBYE","successNotice","drawPositionToAdvance","advanceDrawPosition","sourceDrawPositions","removedParticipantId","losingDrawPosition","losingDrawPosiitonIsBye","noContextWinnerMatchUp","drawPositionToAdvanceAssigment","drawPositionToAdvanceIsBye","existingDrawPositions","existingAssignments","advancingAssignmentIsBye","priorPair","priorPairAssignment","priorPairIsBye","isByeAdvancedBye","pairedDrawPosition","drawPositionAssigned","twoDrawPositions","pairedDrawPositionIsBye","drawPositionIsBye","changedDrawPosition","advancingDrawPosition","assignFedDrawPositionBye","targetDrawPositionIndex","advanceWinner","loserStructureMatchUps","modifyRoundRobinMatchUpsStatus","matchUpContainsBye","clearDrawPosition","existingAssignment","drawPositionRemovals","drawPositionCleared","profileKeys","pairingDetails","profile","relevantPair","currentDrawPosition","pairedDrawPositionAssignment","nextRoundProfile","pairedDrawPositionInNextRound","pairedPositions","isTransitiveBye","pairedDrawPositionByeAdvancedPair","tasks","pairingDetail","newTasks","subsequentRoundRemoval","targetMatchUp","relevantMatchUps","removeDrawPosition","removeSubsequentRoundsParticipant","initialDrawPositions","initialMatchUpStatus","initialWinningSide","inContextTargetMatchUp","drawPositionSideIndex","newMatchUpStatus","matcHUpStatus","removedDrawPosition","loserMatchUpDrawPosition","consolationCleanup","getAssignedParticipantIds","refreshEntryPositions","stagedEntries","entryHash","validEntryPosition","entryPosition","isUngrouped","modifyEntriesStatus","autoEntryPositions","ignoreAssignment","eventSync","modifiedDrawIds","updateEntryStatus","filteredEntries","isAssigned","autoPosition","updateDrawEntries","entryPositionsExist","generatedDrawIds","flightsNoDraw","singleDraw","addScheduleItem","potential","participantScaleItem","requireTimeStamp","scaleAttributes","filterType","itemSubject","accessorValue","getEventSeedAssignments","publishedSeeding","withSeeding","eventSeedAssignments","getScaleAccessor","seedingScales","seedingScaleName","eventSeedingScaleNames","stageSeedingScaleNames","seedingScaleNames","publishedEventSeedingScaleNames","scaleValues","seedValues","scaleNames","published","getEventPublishStatus","getDrawPublishStatus","drawDetails","publishingDetail","getPublishState","publishState","pubStatus","getPubStatus","publishedDrawIds","eventPubStatus","processEventEntry","ranking","entryExtensions","stringSort","localeCompare","addStructureParticipation","matchUpFinishingPositionRanges","participantWon","participantAggregator","range","rankingStage","walkoverWinCount","defaultWinCount","winCount","finishingMatchUpId","processSides","withScheduleItems","scheduleAnalysis","withTeamMatchUps","withOpponents","withMatchUps","withEvents","withDraws","withRankingProfile","tieWinningSide","matchUpSides","opponentParticipantId","getOpponentInfo","opponent","addMatchUp","opponentParticipantInfo","addPartner","addPartnerParticiapntId","partnerParticipantIds","isPair","addTeamMatchUp","teamEntryStatus","addDrawData","teamEntry","individualParticiapntId","processParticipantId","filterParticipants","participantFilters","accessorValues","drawEntryStatuses","positionedParticipants","eventEntryStatuses","participantRoles","signInStatus","enableOrFiltering","genders","tournamentEvents","isValidFilterArray","drawEnteredParticipantIds","statusFilter","flightEntries","getDrawEntries","eventEnteredParticipantIds","eventEntries","getEventEntries","positionedParticipantIds","participantHasAccessorValues","hasValues","keyValue","participantSignInStatus","responsibilities","participantRole","hasGender","roleResponsbility","enteredParticipantIds","getParticipants","withPotentialMatchUps","withStatistics","entriesResult","getRelevantParticipantIds","relevantParticipantIds","withOpts","participantIdsWithConflicts","eventsPublishStatuses","derivedEventInfo","derivedDrawInfo","getRanking","publishStatuses","addEventEntry","eventPublishedSeeding","getSeedingMap","assignments","drawOrder","flightNumber","orderedStructureIds","qualifyingPositionAssignments","qualifyingSeedAssignments","mainPositionAssignments","mainSeedAssignments","mainSeedingMap","qualifyingSeedingMap","relevantEntries","seedingPublished","addDrawEntry","includeSeeding","mainSeeding","mainSeedingAssignments","qualifyingSeeding","qualifyingSeedingAssignments","linksCount","eventMatchUps","baseAttrs","tieMatchUp","tieMatchUpWinningSide","tieMatchUpSides","tieMatchUpId","potentialParticipantIds","relevantParticipantId","aggregators","singlesWins","singlesLosses","doublesWins","doublesLosses","addStatValue","statCode","denominator","numerator","statValue","nonQualifyingOrder","orderedParticipation","participation","notQualifying","participationOrder","scheduledMinutesDifference","dateItems","scheduleItem","scheduleItemsToConsider","scheduledMinutes","consideredItem","notBeforeTime","sameDraw","bothPotential","consideredMinutes","itemIsPrior","priorScheduledMatchUpId","matchUpIdWithConflict","pid","getParticipantEntries","processParticipant","participantDraws","participantOpponents","draw","ppMap","processedParticipants","filteredParticipants","participantInEntries","inEntries","getQualifiersCount","profileQualifiersCount","qualifiersCount","roundQualifiersCounts","relevantLink","qualifyingRounds","qualifyingRound","getStageDrawPositionsCount","getValidStage","getStageSpace","stageAlternatesCount","positionsAvailable","stageDrawPositionsAvailable","getStageDrawPositionsAvailable","wildcardPositions","wildcardsCount","getStageWildcardsCount","wildcardEntriesCount","totalEntriesCount","ignoreStageSpace","spaceAvailable","invalidLuckyLoser","invalidVoluntaryConsolation","invalidEntry","addDrawEntries","participantIdsNotAdded","notAdded","addEntries","participantInFlightEntries","removeEventEntries","statusParticipantIds","stageParticipantIds","participantIdsRemoved","keepEntry","POLICY_MATCHUP_ACTIONS_DEFAULT","enabledStructures","enabledActions","disabledActions","enforceCategory","enforceGender","substitution","substituteAfterCompleted","substituteWithoutScore","addEventEntries","matchUpActionsPolicy","genderEnforced","addedParticipantIdEntries","removedEntries","checkTypedParticipants","mismatchedGender","typedParticipantIds","validSingles","validDoubles","validParticipantIds","existingIds","ungroupedIndividualParticipantIds","groupedIndividualParticipantIds","ungroupedParticipantIdsToRemove","addedEntriesCount","COMPETITOR","OFFICIAL","ADMINISTRATION","CAPTAIN","COACH","MEDIA","SECURITY","removeIndividualParticipantIds","addIndividualParticipantsToEvents","groupingParticipantId","suppressErrors","groupingParticipant","removeParticipantIdsFromGroupingParticipant","removed","enteredIds","participantIdsToEnter","notRemoved","cannotRemove","inContextGroupingParticipant","groupingParticipantEventIds","updatedIndividualParticipantIds","targetParticipant","scoredParticipantGroupingMatchUps","removeParticipant","removeParticipantIdsFromAllTeams","groupingTypes","modifications","grouping","deleteParticipants","teamDrawIds","placedPairParticipantIds","participantsInDraws","drawInfo","eventParticipantIdsRemoved","mappedIndividualParticipantIdsToAdd","participantToRemove","participantTeam","participantsRemovedCount","selected","stageEntries","destroyGroupEntry","removeGroupParticipant","groupedParticipantIds","individualParticipantIdsInGroups","participantRemoved","destroyPairEntry","removeDrawPositionAssignment","replaceWithBye","destroyPair","capitalizeFirst","str","constantToString","structureTemplate","qualifyingRoundNumber","structureOrder","seedingProfile","positioning","addVoluntaryConsolationStructure","getUpdatedSchedulingProfile","schedulingProfile","issues","updatedSchedulingProfile","dateSchedulingProfile","venueExists","filteredRounds","validEventIdAndDrawId","validateSchedulingProfile","tournamentsMap","records","tournamentMap","requireCourts","tournamentRelevantSchedulingIds","getAllRelevantSchedulingIds","isValid","dateSchedule","venueProfile","roundSegment","validRound","segmentNumber","segmentsCount","validSegment","getInContextCourt","ignoreDisabled","inContextCourt","disabledDates","dateAvailability","availability","getDisabledStatus","getVenuesAndCourts","uniqueVenueIds","uniqueCourtIds","getCompetitionVenues","accumulator","additionalCourts","getTournamentVenuesAndCourts","getEventIdsAndDrawIds","tournamentIdMap","getSchedulingProfile","setSchedulingProfile","profileValidity","checkAndUpdateSchedulingProfile","addTimeItem","duplicateValues","removePriorValues","timeItemAttributes","existingTimeItem","addParticipantTimeItem","addTournamentTimeItem","addEventTimeItem","modifyEventPublishStatus","statusObject","getTournamentInfo","tournamentInfo","tournamentRank","tournamentStatus","formalName","tournamentName","promotionalName","onlineResources","localTimeZone","hostCountryCode","tournamentContacts","tournamentAddresses","getStructureGroups","structureProfiles","initStructureProfile","drawSources","drawTargets","progeny","targets","hasDrawFeedProfile","linkedStructureIds","sourceId","targetId","sourceProfile","targetProfile","sourceIds","rootStage","targetIds","maxQualifyingDepth","distanceFromMain","drawTarget","mergedWithOverlappingIds","biggest","ids","groupedStructureIds","allLinkStructuresLinked","structureGroups","linkCheck","allStructuresLinked","getDrawData","includePositionAssignments","noDeepCopy","mainStageSeedAssignments","qualificationStageSeedAssignments","drawActive","participantPlacements","completedStructures","participantResults","structureInfo","structureActive","active","activeMatchUpStatus","structureCompleted","sourceStructuresComplete","drawGenerated","generated","drawCompleted","getEventData","drawsData","drawData","structureDetails","structureFilter","stageDetails","stageFilter","roundLimitMapper","eventData","venuesData","eventInfo","eventLevel","ballType","publish","publishEvent","drawIdsToRemove","drawIdsToAdd","eventDrawIds","keyedDrawIds","specifiedDrawIds","drawIdsToValidate","invalidDrawIds","newDetail","structureIdsToRemove","structureIdsToAdd","stagesToRemove","stagesToAdd","drawStructureIds","invalidStructureIds","drawStages","DELETE_DRAW_DEFINITIONS","AUTO_SCHEDULING_AUDIT","DELETE_EVENTS","auditConstants","deleteDrawDefinitions","autoPublish","auditData","force","deletedDrawsDetail","auditTrail","positionAssignmentMap","allowDeletionWithScoresPresent","publishedDrawsDeleted","updatedDrawIds","drawIdsWithScoresPresent","filteredDrawDefinitions","pa","qualifyingStructures","qualifyingStructure","audit","deleteDrawNotice","deletionData","updatedExtension","addDrawDeletionTelemetry","getMatchUp","findDrawMatchUp","getPairedPreviousMatchUpIsDoubleExit","sourceMatchUp","previousRoundNumber","pairedRoundPosition","pairedPreviousMatchUp","pairedPreviousMatchUpStatus","pairedPreviousMatchUpIsDoubleExit","getPairedPreviousMatchUp","updateMatchUpStatusCodes","sourceMatchUpStatus","sourceMatchUpId","pairedPreviousMatchUpId","pairedMatchUp","sourceSideNumber","matchUpStatusCodes","previousMatchUpStatus","getExitWinningSide","sourceMatchUps","updateSideLineUp","drawPositionSideNumber","sideExists","targetSide","assignMatchUpDrawPosition","positionAdded","positionAssigned","updatedDrawPositions","getUpdatedDrawPositions","matchUpAssignments","isDoubleExitExit","exitWinningSide","getRoundRobinGroupMatchUps","groupMatchUps","uniqueMatchUpGroupings","drawPositionsHash","h","groupRounds","drawPositionOffset","numArr","groupPositions","aRow","bRow","j","aHead","shift","aDown","bUp","groupPosition","roundRobinGroups","determineRoundNumber","hash","generateRoundRobin","groupNameBase","playoffAttributes","structureOptions","groupNames","idPrefix","isMock","groupSizeLimit","validGroupSizes","getValidGroupSizes","maxValidGroupSize","validGroupSize","deriveGroups","positionMatchUp","roundRobinMatchUpId","roundRobinMatchUps","byesCount","maxParticipantsPerGroup","maxByesPerGroup","getSeedBlocks","roundRobinGroupsCount","cluster","seedBlocks","positions","top","isEven","first","last","remainingPositions","seedBlockSizes","getSeedGroups","seedGroups","seedNumbers","seedBlock","getNumericSeedValue","firstValue","generateBlockPattern","size","divisions","division","getDivisions","divisionGroupings","firstMember","getMember","lastMember","noneSelected","member","notSelected","select","lastPositions","getValidSeedBlocks","allPositions","validSeedBlocks","seedsCount","uniqueDrawPositionsByRound","uniqueRoundDrawPositions","firstRoundDrawPositionOffset","baseDrawSize","seedRangeDrawPositionBlocks","isContainer","isFeedIn","qualifyingBlocks","fedSeedBlockPositions","fedSeedNumberOffset","countLimit","firstRoundSeedsCount","seedingBlocksCount","getSeedPattern","drawPositionChunks","groupNumber","getSeedBlockPattern","nonRandom","containedStructure","getContainerBlocks","blocks","seedNumberOffset","seedCountGoal","getSeeds","constructPower2Blocks","validSeedPositions","seedGroup","relativePositions","blockPattern","subBlock","getSubBlock","blockIndex","consideredDrawPositions","isValidSeedPosition","seedBlockInfo","strict","targetSeedBlock","getNextSeedBlock","randomize","positionsWithParticipants","assignedDrawPositions","nextSeedBlock","assignedSeedParticipantIds","assignedPositionParticipantIds","placedSeedParticipantIds","unplacedSeedIds","unplacedSeedAssignments","seedsWithoutDrawPositions","unfilled","unfilledPositions","selectedParticipantIds","randomlySelectedUnplacedSeedValueIds","filteredAssignments","lowestSeedValue","assignmentsWithLowestSeedValue","randomlySelectLowestSeedValue","placedSeedNumbers","unplacedSeedNumbers","unplacedSeedNumberIds","duplicateSeedNumbers","unplacedSeedParticipantIds","assignSeed","validParticipantId","flightsCount","flighted","assignedDrawPosition","groupSeedingThreshold","getTargetMatchUps","removeLineUpSubstitutions","participantAssignments","permutation","mustBeAnArray","validateLineUp","validItems","collectionAssignment","noDuplicates","updateTeamLineUp","validation","resetLineUps","inheritance","assignDrawPosition","isQualifierPosition","participantSeedNumber","participantAlreadyAssigned","containsParticipant","targetStage","addDrawPositionToMatchUps","positionParticipantAction","participantIdAttributeName","positionActionName","assignResult","publicFindMatchUp","findMatchUp","resolveFromParameters","paramsToResolve","resolutions","resolution","findResolution","addMatchUpTimeItem","checkOutParticipant","getCheckedResult","getIdsResult","checkInParticipant","toggleParticipantCheckInState","activeTournamentId","getTieMatchUpContext","inContextTieMatchUp","dualMatchUp","inContextDualMatchUp","addParticipant","allowDuplicateParticipantIdPairs","returnParticipant","pairOverride","tournamentIndividualParticipantIds","tournamentParticipant","existingPairParticipants","existingPairParticipant","existingParticipant","standardFamilyName","standardGivenName","ensureSideLineUps","extractSideDetail","contextSide","referenceLineUp","noContextLineUp","noContextSideDetail","replaceTieMatchUpParticipantId","matchUpContext","existingParticipantId","newParticipantId","targetParticipants","newParticipant","substitutionProcessCodes","dualMatchUpSide","allTieIndividualParticipantIds","teamLineUp","newParticipantIdInLineUp","modifiedLineUp","modifiedCompetitor","isDoubles","existingIndividualParticipantIds","participantAdded","existingPairParticipantId","substitutionProcessCode","codeIndex","removeCollectionAssignments","previousParticipantIds","assignmentsRemoved","addIndividualParticipantIds","removeFromOtherTeams","invalidParticipantIds","participantIdsToAdd","updatedParticipant","relevantEvents","filterEntry","updateTeamEventEntries","added","modifyParticipant","updateParticipantName","participantRoleResponsibilties","contacts","newValues","allIndividualParticipantIds","generatePairParticipantName","newPersonValues","personNameModified","updatePerson","assignTieMatchUpParticipantId","participantToAssign","teamAssignment","teamDrawPosition","dualTeamSideNumber","teamSideNumber","tieMatchUpSide","targetAssignments","participantAssignment","removeResult","deletedParticipantId","updateLineUp","addParticipantId2Pair","templateTeamLineUp","participantCompetitiorProfile","newAssignment","validateCollectionValueProfiles","collectionValueProfiles","matchUpCount","valueProfile","matchUpValue","copyTieFormat","getGroupValueGroups","collectionGroups","groupValueGroups","groupValue","allGroupMatchUpsCompleted","sideWins","groupValueNumbers","calculateWinCriteria","valueTotal","aggregateValueImperative","collectionGroupNumber","collectionValue","scoreValue","setValue","belongsToValueGroup","collectionValueProfile","collectionGroup","aggregateValue","valueGoal","getTieFormat","matchUpFormatObject","preserveRedundant","bestOfValue","setLimit","timedSetFormat","setLimitCode","setCountValue","stringifySet","setCode","finalSetCountValue","finalSetCode","getSetFormat","setObject","setToValue","setTiebreakValue","setTiebreakCode","tieobject","isValidMatchUpFormat","setParts","setsTo","finalSetParts","finalSetTo","finalSetTiebreakTo","finalTiebreakAt","mixedGenderError","anyMixedError","tieFormatGenderValidityCheck","referenceGender","typeMatch","getCategoryAgeDetails","ageMaxDate","ageMinDate","ageMax","ageMin","combinedAge","consideredDate","toLocaleDateString","consideredYear","previousDayDate","previousDayMonth","previousDay","previousMonthDay","nextDayDate","nextDayMonth","nextDay","nextMonthDay","calculatedAgeMaxDate","calculatedAgeMinDate","addError","errorString","prePost","extractCombined","isBetween","isCombined","isCoded","constructedDate","y","df","uPost","ageInt","newMinDate","oPre","newMaxDate","processCode","age","post","uPre","oPost","ageMaxYear","ageMinYear","lowAge","highAge","validateCategory","categoryDetails","ratingMax","ratingMin","categoryCanContain","childCategory","withDetails","childCategoryDetails","invalidAgeMin","invalidAgeMax","invalidAgeMinDate","invalidAgeMaxDate","invalidRatingRange","ratingType","invalidBallType","validateCollectionDefinition","checkCategory","checkCollectionIds","checkGender","referenceCategory","validateTieFormat","winCriteria","validCollections","collectionDefinitionErrors","validWinCriteria","uniqueCollectionIds","generateTieMatchUps","generateCollectionMatchUps","collectionPositionOffset","matchUpsLimit","getTieFormatDesc","tieFormatName","tieFormatDesc","def","compareTieFormats","considerations","descendant","ancestor","descendantDifferences","ancestorDifferences","descendantMatchUpFormats","descendantDesc","ancestorMatchUpFormats","ancestorDesc","matchUpFormatDifferences","nameDifference","collectionName","orderDifference","collectionOrder","descendantCollectionDefinitions","ancestorCollectionDefinitions","collectionsValue","getCollectionsValue","valueDifference","totalValue","matchUpCountDifference","totalMatchUps","assignmentValuesCountDifference","assignmentValues","assignmentValuesDifference","comparisonAssignment","valueKey","different","invalidValues","definitions","total","valueAssignments","valueKeys","validUpdate","updateInProgressMatchUps","checkStructureMatchUpCounts","to","referenceKeys","sameKeys","matchUpsCountChanges","countChange","sameMatchUpsCount","equivalent","getMatchUpChangesArePossible","check","cannotChangeReaon","changes","changesArePossible","toBePlayedTieMatchUpIds","possibleToChange","tieFormatTelemetry","modifyCollectionDefinition","existingTieFormat","sourceCollectionDefinition","targetCollectionDefinition","valueProfileModified","targetCollectionGroupNumber","rest","change","modifiedTieFormat","modifiedStructuresCount","modifiedMatchUpsCount","addedMatchUpsCount","modifiedCount","collectionMap","instanceMap","matchingCollections","cMap","drawDefaultTieFormat","eventDefaultTieFormat","processDrawDefinition","matchUpMap","makeChanges","inheritedTieFormat","processStructure","modifiedStructureIds","validToUpdate","matchUpIdsRemoved","matchUpsAdded","newMatchUps","tieMatchUpIdsToRemove","updateTieFormat","swapDrawPositionAssignments","structureAssignments","isQualifierSwap","swapParticipantIdWithBYE","originalAssignments","roundRobinSwap","newAssignments","eliminationPosiitonSwap","eliminationSwap","inContextTargetMatchUps","inContextSide","originalByeAssignment","originalParticipantIdAssignment","originalByeDrawPosition","originalParticipantIdDrawPosition","getPlayoffStructures","playoffStructures","getEventStructures","drawStructures","drawStageStructures","isCompletedStructure","processAccessors","accessors","extractedValues","nestedValue","extractAttributeValues","policyAttributes","idCollections","policyAttribute","directive","groupings","includeIds","collectionParticipantId","collectionParticipant","getPositionedParticipants","candidatePositionAssignments","participantsMap","getPositionProfiles","participantIdGroups","groupsToAvoid","assginment","participantGroups","includesGroupsToAvoid","analyzeEliminationDrawPositions","chunkedDrawPositions","profiledPositions","chunkedGrouping","unassigned","unfilledPosition","unpaired","pairAssigned","pairedPosition","getPairedPosition","unpairedPositions","pairedNoConflict","organizeDrawPositionOptions","selectedParticipantGroups","vettedChunks","conflictsCount","analyzeRoundRobinDrawPositions","getUnplacedParticipantIds","getParticipantPlacement","unseededParticipantIds","drawPositionGroups","pairedPriority","allGroups","groupKey","useSpecifiedGroupKey","largest","assignmentMap","getUnfilledPositions","selectedParticipantId","newGroupKey","largestFirst","largestGroupSize","largestSizedGroupings","randomGroupKey","getNextParticipantId","getParticipantGroups","drawPositionOptions","pnc","up","desiredOptions","fallbackOptions","prioritizedOptions","section","getAvoidanceConflicts","groupedParticipants","avoidanceConflicts","participantGroup","drawPositionValuesMap","conflict","matchUpPair","getSwapOptions","potentialDrawPositions","placedParticipant","moveableParticipant","possibleDrawPositionsNoConflict","possibleDrawPosition","potentialOpponentDrawPosition","potentialOpponent","placement","conflictPotential","swappedParticipant","existingOpponentConflictPotential","generatePositioningCandidate","initialPositionAssignments","opponentsToPlaceCount","unseededByePositions","dpg","attempts","swapOptions","swapAssignedPositions","conflicts","swapOption","firstPosition","secondPosition","firstAssignment","secondAssignment","updatedFirstAssignmentAttributes","updatedSecondAssignmentAttributes","randomUnseededSeparation","avoidance","candidatesCount","targetDivisions","roundsToSeparate","exponent","deriveExponent","roundRobinParticipantGroups","drawPositionPairs","firstRoundMatchUpDrawPositions","greatestFirstRoundDrawPosition","fedDrawPositions","drawPositon","structureSize","roundSizes","chunkSizes","eliminationParticipantGroups","getAttributeGroupings","unplacedParticipantIds","noPairPriorityCandidates","pairedPriorityCandidates","alreadyAssignedParticipantIds","automaticPlacement","positionUnseededParticipants","multipleStructures","unfilledDrawPositions","unseededParticipantsCount","unfilledDrawPositionsCount","shuffledDrawPositions","randomUnseededDistribution","positionQualifiers","qualifierDrawPositions","unplacedRoundQualifierCounts","assignedQualifierPositions","unplacedQualifiersCount","placedQualifiersCount","getQualifiersData","getBlockSortedRandomDrawPositions","orderedSortedFirstRoundSeededDrawPositions","strictOrder","byesToPlace","nestedDrawPositions","nestArray","desiredPosition","popFromLargerSide","blockSortedRandom","side1","side2","desiredSide","midPoint","getSeedOrderByePositions","containerByesIgnoreSeeding","positionedSeeds","seedMap","getStructurePositionedSeeds","relevantDrawPositions","relevantPositionedSeeds","positionedSeed","seedValueSort","positionedSeedsInBlock","blockSortedRandomDrawPositions","strictSeedOrderByePositions","getOrderedByePositions","orderedSeedDrawPositions","blockSeedOrderByePositions","consideredDrawPositionPairs","byePosition","positionByes","seedsOnly","blockOrdered","placedByes","firstRoundMatchUps","maxByes","entriesCount","placedByePositions","positionsToAvoidDoubleBye","noBye","getByesData","ignoreSeededByes","seedOrderByePositions","filledDrawPositions","filledRelevantDrawPositions","getHalves","halfLength","halves","halfLengths","half","shortLength","longLength","longIndex","unequalHalves","shuffledHalves","greaterHalf","lesserHalf","getNextDrawPosition","greaterQuarter","lesserQuarter","newlyFilteredChunks","unfilledDrawPosition","quarterSeparateBlock","filteredChunks","drawPositionCount","validBlockDrawPositions","unfilledSeedBlocks","matchUpPairedDrawPositions","findDrawPositionPair","seedingOverhang","overhangDrawPositions","qualifierBlocksCount","shuffledRemainder","getUnseededByePositions","unPairedPosition","isNotPaired","positionSeedBlocks","seedPositions","placedSeedBlocks","positionSeedBlock","seedPositionError","automatedPositioning","applyPositioning","placeByes","positioningReport","handleErrorCondition","qualifierConflicts","unseededConflicts","automatedPlayoffPositioning","structurePositionAssignments","positioningReports","resequenceStructures","attachQualifyingStructure","attachQualifying","FORMAT_STANDARD","FORMAT_ATP_DOUBLES","FORMAT_STANDARD_NOAD","FORMAT_SHORT_SETS","FORMAT_FAST4","FORMAT_PRO_SET","FORMAT_COLLEGE_PRO_SET","TIMED20","countSets","matchUpWinningSide","tallyPolicy","setsTally","matchUpWinnerIndex","parsedMatchUpFormat","setsToWin","getSetsToWin","setsCreditForDefaults","setsCreditForWalkovers","setWinningSide","setsCreditForRetirements","countGames","gamesTally","gamesCreditForDefaults","gamesCreditForWalkovers","minimumGameWins","whichFormat","isTiebreakSet","isGamesBased","gamesCreditForTiebreakSets","gamesForSet","getComplement","g","talliedGames","complement","gamesCreditForRetirements","countPoints","tiebreaksTally","pointsTally","isPointsBased","bestOfGames","getParticipantResults","perPlayer","getSideId","totalSets","manualGamesOverride","_disableAutoCalc","winningParticipantId","getWinningSideId","losingParticipantId","getLosingSideId","checkInitializeParticipant","isSingles","tieMatchUpsWon","tieSinglesWon","tieDoublesWon","tieMatchUpsLost","tieSinglesLost","tieDoublesLost","processMatchUp","isTieMatchUp","processOutcome","participantIdSide1","participantIdSide2","matchUpsCancelled","tieWinningParticipantId","tieLosingParticipantId","processScore","side1participantId","side2participantId","gamesWonSide1","gamesWonSide2","gamesWon","gamesLost","parsedGroupMatchUpFormat","bracketSetsToWin","bracketGamesForSet","setsWon","setsLost","setsTotal","groupTotalSetsPlayed","setsPct","tieMatchUpsTotal","tieMatchUpsPct","matchUpsWon","matchUpsTotal","matchUpsLost","matchUpsPct","minimumExpectedGames","gamesTotal","gamesPct","pointsPct","pointsWon","pointsLost","calculatePercentages","Side","allDefaults","defeats","retirements","victories","winningSideIndex","losingSideIndex","getGroups","getResultsArray","headToHeadTallyDirectives","idsFilter","reversed","GEMScoreValueMap","getGroupOrder","requireCompletion","subOrderMap","report","resultsArray","participantsFinished","r","isComplete","groupOrderKey","orderedTallyGroups","groupSubSort","priorPositionResolution","resolved","getRatioHash","positionInstances","ties","subOrder","rankOrder","disableHeadToHead","excludedDirectives","headToHead","disabled","headToHeadWinner","filteredDirectives","tallyDirectives","keepDirective","maxParticipants","processAttribute","tallyParticipantResults","generateReport","bracketComplete","completedTieMatchUps","groupOrderReport","provisionalOrderReport","readableReport","tally","readable","note","excluded","floatSort","getExplanation","participantNames","explanation","description","orderEntry","pOrder","getTallyReport","evaluateCollectionResult","sideTieValues","collectionMatchUps","sideMatchUpValues","sideCollectionValues","allCollectionMatchUpsCompleted","getCollectionPositionValue","collectionWinningSide","winGoal","sideCollectionValue","generateTieMatchUpScore","sideAdjustments","groupWinningSide","sideScores","sideTieValue","scoreStringSide2","sideThatWon","points","toBePlayed","targetSideNumber","findTournamentId","updateAssignmentParticipantResults","subOrderArray","subOrdersCount","createSubOrderMap","addNotes","testing","modifyMatchUpScore","removeWinningSide","removeScore","isDualMatchUp","findResult","wasDefaulted","defaultedProcessCodes","incompleteAssignmentsOnDefault","updateTally","sendInContext","updateInContextMatchUp","updateTieMatchUpScore","exitWhenNoValues","scoreResult","setHasValue","scoreObject","hasWinner","hasResults","tieFormatRemoved","removeDirectedParticipants","dualWinningSideChange","isAdHocMatchUp","tieMatchUpResult","winningIndex","losingIndex","winningDrawPosition","loserDrawPosition","winnerParticipantId","loserParticipantId","drawPositionMatchUps","removeDirectedWinner","winnerHadMatchUpStatus","winnerHadBye","winnerDrawPosition","winnerMatchUpStatuses","loserMatchUpStatuses","loserHadMatchUpStatus","includesMatchUpStatuses","loserLinkCondition","removeDirectedBye","removeLoserResult","relevantDrawPosition","removeDirectedLoser","annotate","drawPositionInstanceCount","doubleExitAdvancement","progression","doubleExitPropagateBye","advanceByeToLoserMatchUp","walkoverWinningSide","conditionallyAdvanceDrawPosition","DOUBLE_EXIT","EXIT","noContextTargetMatchUp","targetMatchUpDrawPositions","sameStructure","nextLoserTargetDrawPosition","nextWinnerMatchUp","nextLoserMatchUp","existingExit","isFinal","inContextPairedPreviousMatchUp","pairedMatchUpStatus","producedMatchUpStatus","noContextNextWinnerMatchUp","nextWinnerMatchUpDrawPositions","nextWinnerMatchUpHasDrawPosition","nextDrawPositionToAdvance","advancementResult","attemptToSetMatchUpStatus","teamRoundRobinContext","rondPosition","icdm","isBYE","existingWinningSide","isDoubleExit","directing","nonDirecting","unrecognized","onlyModifyScore","changeCompletedToDoubleExit","scoreModification","removeWinningSideAndSetDoubleExit","matchUpIncludesBye","attemptToSetMatchUpStatusBYE","modifyScoreAndAdvanceDoubleExit","projectedWinningSide","checkConnectedStructures","connectedStructureIds","getAffectedTargetStructureIds","attemptToModifyScore","matchUpStatusIsValid","validToScore","drawPositionsAssignedParticipantIds","directParticipants","targetMatchUpDrawPosition","sourcePositionAssignments","relevantSourceAssignment","targetPositionAssignments","winnerExistingDrawPosition","unfilledTargetMatchUpDrawPositions","inTarget","targetDrawPositionIsUnfilled","seedAssignment","updatedSides","filteredLineUp","directWinner","fedDrawPositionFMLC","loserBackdrawPosition","loserDrawPositionWins","drawPositionSide","unscoredOutcome","validForConsolation","targetMatchUpPositionAssignments","loserAlreadyDirected","isFirstRoundValidDrawPosition","asssignLoserDrawPosition","assignLoserPositionBye","loserLinkFedFMLC","fedDrawPosition","directLoser","isActiveDownstream","loserMatchUpExit","winnerDrawPositionsCount","loserTargetData","winnerTargetData","loserActive","attemptToSetWinningSide","connectedStructures","disableAutoCalc","qualifierReplaced","qualifierPlaced","qualifierChanging","autoReplaceQualifiers","previousWinningParticipantId","mainDrawTargetMatchUp","newWinningParticipantId","subStructure","replaceQualifier","qualifierAdvancing","autoPlaceQualifiers","winningQualifierId","placeQualifier","drawPositionToRemove","removeDoubleExit","conditionallyRemoveDrawPosition","inContextLoserMatchUp","loserStructure","nextTargetData","pairedPreviousDoubleExit","pairedPreviousDrawPositions","nextWinnerDrawPositions","targetDrawPositions","getMatchUpStatus","noDownstreamDependencies","doubleWalkover","scoreWithNoWinningSide","timedTieMatchUp","lastSetNumber","matchUpScoringFormat","lastSetFormat","lastSetFormatIsTimed","statusNotTBP","removeDirected","removingQualifier","autoRemoveQualifiers","qualifierRemoved","removeQualifier","triggerDualWinningSide","allocateTeamMatchUpCourts","courtDayDate","specifiedCourts","assignMatchUpVenue","assignMatchUpCourt","addMatchUpScheduledTime","existingTimeModifiers","addMatchUpTimeModifiers","toBeAdded","addMatchUpScheduleItems","errorOnAnachronism","checkChronology","inContextMatchUps","warning","drawMatchUp","resumeTime","stopTime","priorMatchUpIds","priorMatchUpTimes","matchUpTime","addMatchUpScheduledDate","addMatchUpStartTime","addMatchUpStopTime","addMatchUpResumeTime","addMatchUpEndTime","addMatchUpCourtOrder","warnings","dateToSchedule","validDate","earliestRelevantTimeValue","earliest","validateTimeSeries","latestRelevantTimeValue","latest","hasEndTime","lastRelevantTimeItem","lastRelevantTimeItemIsStop","targetTimeStamp","lastRelevantTimeItemIsResume","validateScore","existingMatchUpStatus","setNumbers","numericValue","isValidScore","setsWinCounts","counts","matchUpWinningSideIndex","matchUpLosingSideIndex","winningSideSetsCount","losingSideSetsCount","maxSetsCount","maxSetsInstances","relevantMatchUpStatus","irregularEnding","validSets","isFinalSet","isLastSet","maxSetScore","hasTiebreak","setValues","maxTiebreakScore","calculatedWinningSide","analyzeScore","setMatchUpState","allowChangePropagation","disableScoreValidation","enableAutoCalc","existingDualMatchUpWinningSide","bothSideParticipants","qualifyingMatch","outcome","projectedDualMatchUp","getProjectedDualWinningSide","activeDownstream","directingMatchUpStatus","validWinningSideSwap","matchUpRoundNumber","existingWinnerSide","existingLoserSide","existingWinnerDrawPosition","existingWinnerParticipantId","existingLoserDrawPosition","existingLoserParticipantId","existingWinnerSubsequentMatchUps","changeWinner","currentStage","currentStageSequence","subsequentStructureIds","targetStageSequence","existingWinnerAssignment","existingLoserAssignment","swapWinnerLoser","matchUpWinner","applyMatchUpValues","winningSideWithDownstreamDependencies","updateDrawIdsOrder","orderedDrawIdsMap","drawOrders","orderedDrawIds","refreshEventDrawOrder","addDrawDefinitionTimeItem","setStageDrawSize","directAcceptanceEntries","getStageDirectEntriesCount","setStageQualifiersCount","collectionGroupUpdate","originalValueGoal","wasAggregateValue","getTargetTeamMatchUps","hasTieFormat","scoreUpdated","updateTargetTeamMatchUps","prunedTieFormat","getOrderedTieFormat","orderMap","orderedTieFormat","updateEventTieFormat","updatedFormat","updateDrawTieFormat","updateStructureMatchUps","removeCollectionDefinition","tieFormatComparison","targetCollection","collectionScore","tieFormatDifference","collectionMatchUp","deletedMatchUpIds","deleteTarget","generateQualifyingLink","targetEntryRound","generateMatchUpId","buildRound","includeMatchUpType","nodes","roundNodes","matchRoundNumber","roundMatchUpsCount","child1","child2","node","children","treeMatchUps","qualifyingPositions","requiredDrawSize","isValidQualifying","generateQualifyingStructure","structureProfile","roundTargetName","isPreQualifying","preQualifyingNaming","qualifyingStructureName","qualifyingDrawPositionsCount","setMatchUpMatchUpFormat","buildFeedRound","fed","feedRoundMatchUpsCount","initialGroupDrawPosition","drawPositionGroup","nodeIndex","feedDrawPosition","feedArm","feed","newMatchUp","roundNode","feedInMatchUps","feedRoundsProfile","feedRounds","skipRounds","linkFedFinishingRoundNumbers","linkFedRoundNumbers","feedsFromFinal","isConsolation","nearestP2","getBaseDrawSize","baseDrawRounds","roundMatchCounts","baseRoundsCount","positionsToFeed","feedSize","allRounds","positionsFedByLinks","baseDrawRound","iterationRange","finishingRoundNumber","isLinkFedRound","iterationDrawPosition","generatePlayoffStructures","addNameBaseToAttributeName","playoffStructureNameBase","finishingPositionNaming","exitProfileLimit","roundOffsetLimit","staggeredEntry","sequenceLimit","allMatchUps","finishingPositionsFrom","attributeProfile","base","customNaming","mainParams","roundsToPlayOff","playoffDrawPositions","childFinishingPositionOffset","childStructures","childMatchUps","childLinks","generateChildStructures","firstRoundLoserConsolation","consolationDrawPositions","consolationMatchUps","consolation","consolationStructureName","consolationStructure","feedInLinks","feedPolicy","roundsFed","roundGroupedOrder","roundFeedProfiles","generateCurtisConsolation","structureNameMap","mainDrawRoundsCount","consolationItems","consolationRoundsCount","indexedStructureName","defaultName","mappedStructureName","consolationFeedStructure","consolationLinks","playoffMatchUps","playoffStructure","playoffLink","feedInChampionship","feedLinks","processPlayoffGroups","requireSequential","playoffMatchUpFormat","playoffGroups","finishingPositionTargets","positionRangeMap","playoffGroupFinishingPostions","positionMap","positionDetail","getPositionRangeMap","sequential","pos","validFinishingPositions","playoffGroup","participantsInDraw","playoffDrawType","updateStructureAndLinks","playoffLinks","generatePlayoffLink","uuidsFMLC","additionalAttributes","champitionShipStructures","generateAndPopulatePlayoffStructures","availabilityResult","roundProfiles","newStructureIds","addedMatchUpIds","addedMatchUps","finishingPositionParticipantIds","generateAndPopulateRRplayoffStructures","availablePlayoffRoundsRanges","sourceRoundsError","validRoundNumbers","playoffPosition","roundsRanges","newStructures","newLinks","roundInfo","matchUpModifications","sourceStructureMatchUps","modification","attachPlayoffStructures","attachStructures","linkHash","existingLinkHashes","generatedStructureIds","existingStructureIds","modifiedMatchUpMap","modifyStructureMatchUps","attribs","modifiedTieMatchUpsMap","modifiedTieMatchUp","tm","addedStructureIds","addPlayoffStructures","generateScoreString","winnerFirst","addOutcomeString","autoComplete","reverseScores","outcomeString","outcomeStrings","RETIRED$1","WALKOVER$2","ABANDONED$1","getOutcomeString","setScores","setSort","currentSet","hasTiebreakScores","t1","t2","lowTiebreakScore","tiebreak","scoreString","matchUpScore","winnerPerspective","loserPerspective","setMatchUpStatus","addCollectionDefinition","validationResult","queueNoficiations","modifiedMatchUps","attachPolicies","checkParams","applied","policyAttachement","allowReplacement","modifyDrawName","bulkUpdate","outcomes","analyzeDraws","drawsAnalysis","positionsNoOutcomes","canBePruned","matchPlay","inactive","drawAnalysis","eventsMap","eventDraws","positionsAssignedCount","matchUpsWithWinningSideCount","matchUpsNoOutcomeCount","structuresData","orderNumber","matchUpsWithWinningSide","winningSideCount","maxWinningSideFirstRoundPosition","positionsAssigned","unassignedPositionsCount","activeRounds","inactiveRounds","inactiveStructure","data","activeStructuresCount","isMatchPlay","inactiveDraw","addDrawDefinition","flightDefinition","suppressNotifications","modifyEventEntries","existingDrawCount","checkEntryStatus","modifiedEventEntryStatusCount","relevantFlight","sourceDrawId","drawEntriesPresentInFlight","flightEntry","matchingEventEntries","eventEntry","drawEntry","flightNumbers","manuallyAdded","existingDrawDefinition","existingMatchUps","existingMatchUpIds","incomingMatchUps","addParticipants","returnParticipants","existingParticipantIds","newParticipants","participantsToAdd","addedParticipants","addedCount","generateAdHocMatchUps","newRound","participantIdPairings","structureHasRoundPositions","lastRoundNumber","selectedEntries","maxRemaining","pairing","idStack","getPrefixedId","candidateHash","roundCandidate","valueSortedPairings","stipulated","pairingValueMap","deltaObjects","valueObjects","actorsCount","roundPlayers","candidateValue","p1","p2","pairingHash","pairings","rankedPairing","maxDelta","delta","maxDiff","id1","id2","getPairingsData","possiblePairings","uniquePairings","ELO","NTRP","WTN","ratingConstants","TRN","UTR","ratingsParameters","defaultInitialization","decimalsCount","ascending","ustaRatingType","confidence","generator","DEFAULT_RATING","getPairings","adHocRatings","maxIterations","salted","defaultRating","getSideRatings","salting","salt","ratingsDifference","pairingDelta","pairingValues","participantValues","pairingValue","getParticipantPairingValues","deltaCandidate","rm","actors","proposedCandidates","initialProposal","candidateHashes","calculatedIterations","lowCandidateValue","opponentCount","stipulatedPairs","actor","stipulatedPair","proposed","generateCandidate","ENCOUNTER_VALUE","SAME_TEAM_VALUE","MAX_ITERATIONS","generateDrawMaticRound","encounterValue","sameTeamValue","generateMatchUps","encounters","getEncounters","drawMatic","restrictEntryStatus","scaleAccessor","getScaleValue","addAdHocMatchUps","attachFlightProfile","deleteExisting","existingFlightProfile","removeScaleValues","removeParticipantsScaleItems","resetTieFormat","existingCollectionMatchUps","getEliminationDrawSize","participantCount","getSeedsCount","drawSizeProgression","requireParticipantCount","validParticpantCount","consideredParticipantCount","seedsCountThresholds","minimumParticipantCount","getEntriesAndSeedsCount","eliminationDrawSize","generateSeedingScaleItems","scaledEntries","seededEntries","scaleItemsWithParticipantIds","getParticipantScaleItem","getScaledEntries","sortDescending","scaleSortMethod","scaledEntry","scaleItemValue","addFlight","flightParticipantIds","COLLEGE_DEFAULT","COLLEGE_JUCO","COLLEGE_D3","DOMINANT_DUO","DOMINANT_DUO_MIXED","LAVER_CUP","TEAM_DOUBLES_3_AGGREGATION","TIME_TENNIS_DUAL","TIME_TENNIS_PRO_CIRCUIT","USTA_BREWER_CUP","USTA_OZAKI_CUP","USTA_COLLEGE","USTA_GOLD_TEAM_CHALLENGE","USTA_LEVEL_1","USTA_INTERSECTIONAL","USTA_SECTION_BATTLE","USTA_SOUTHERN_LEVEL_5","USTA_TOC","USTA_WTT_ITT","USTA_ZONAL","tieFormatConstants","STANDARD","namedFormats","hydrate","doubles","singles","COLLEGE_D3$1","COLLEGE_DEFAULT$1","COLLEGE_JUCO$1","LAVER_CUP_TIE_FORMAT","DOMINANT_DUO_TIE_FORMAT","DOMINANT_DUO_MIXED_TIE_FORMAT","TEAM_AGGREGATION_TIE_FORMAT","TIME_TENNIS_DUAL_TIE_FORMAT","TIME_TENNIS_PRO_TIE_FORMAT","USTA_BREWER_CUP_TIE_FORMAT","USTA_OZAKI_CUP_TIE_FORMAT","USTA_COLLEGE_TIE_FORMAT","USTA_GOLD_TEAM_CHALLENGE_FORMAT","USTA_INTERSECTIONAL_TIE_FORMAT","USTA_LEVEL_1_TIE_FORMAT","USTA_SECTION_BATTLE_TIE_FORMAT","USTA_SOUTHERN_LEVEL_5_TIE_FORMAT","USTA_WTT_ITT_TIE_FORMAT","USTA_TOC_TIE_FORMAT","USTA_ZONAL_TIE_FORMAT","tieFormatDefaults","namedFormat","getCollectionId","hydrateCollections","addEvent","eventRecord","newEvent","promoteAlternates","promoteWithinElement","drawPromotionError","targetedEntries","alternateEntry","participantEntry","participantEntries","invalidEntryStatus","invalidStage","invalidStageSequence","maxEntryPosition","setEntryPosition","skipRefresh","differentiateDuplicates","setEventStartDate","getTournamentDates","tournamentStartDate","tournamentEndDate","newEventStartDate","eventEndDate","setEventEndDate","newEventEndDate","eventStartDate","eventGovernor","addCollectionGroup","groupDefinition","collecitonGroups","addEventEntryPairs","participantIdPairs","existingParticipantIdPairs","genderMap","invalidParticipantIdPairs","has","participantGenders","invalidParticiapntGenders","provisionalParticipants","addedParticipant","addedPair","newParticipantIds","addQualifyingStructure","addQualifying","addVoluntaryConsolationStage","addVoluntary","aggregateTieFormats","checkTieFormat","identifiedTieFormatId","newTieFormat","setTieFormatId","eventMatchUpResult","addNewTieFormat","alternateDrawPositionAssignment","alternateParticipantId","positionAlternate","applyLineUps","sideAssignments","collectionParticipantIds","sideNumbers","lineUpAssignment","collectionParticipantIdPairs","pairedParticipant","instances","sideAssignmentKeys","assignPositionBye","assignPosition","assignMatchUpSideParticipant","noSideNumberProvided","matchUpstatus","currentSideNumber","sidesSwapped","assignSeedPositions","useExistingSeedLimit","mergeObject","updatedAssignments","attachConsolationStructures","autoSeeding","bulkMatchUpStatusUpdate","tournamentOutcomes","deleteAdHocMatchUps","matchUpIdsWithScoreValue","matchUpsToDelete","matchUpIdsToDelete","missingRoundNumbers","getMissingSequenceNumbers","deleteEvents","removePairParticipants","deletedEventDetails","activePairParticipantIds","enteredPairParticipantIds","deleteEvent","particiapntIdsToRemove","deleteFlightAndFlightDraw","drawWasGenerated","deleteFlightProfileAndFlightDraws","destroyPairEntries","destroyedCount","disableTieAutoCalc","enableTieAutoCalc","getAvailablePlayoffRounds","luckyLoserDrawPositionAssignment","luckyLoserParticipantId","positionLuckyLoser","modifyDrawDefinition","drawUpdates","nameResult","modifyEvent","eventUpdates","enteredParticipants","genderAccumulator","enteredParticipantTypes","types","individualParticpants","enteredParticipantGenders","validGender","validEventType","unpairedParticipantIds","incoming","pairParticipantEntries","unpairedParticipantEntries","modifyPairAssignment","replacementIndividualParticipantId","existingIndividualParticipantId","newPairParticipantId","participantOtherEntries","modifySeedAssignment","existingAssginment","newValue","drawEngineModifySeedAssignment","modifyTieFormat","comparison","existingCollectionIds","updatedCollectionIds","removedCollectionIds","addedCollectionDefinitions","addedCollectionIds","processedTieFormat","orderCollectionDefinitions","promoteAlternate","pruneDrawDefinition","matchPlayDrawPositions","structureData","relevantMatchUpIds","matchPlayMatchUps","matchPlayMatchUpIds","drawPositionsMap","updatedPositionAssignments","qualifierDrawPositionAssignment","qualifyingParticipantId","positionQualifier","removeCollectionGroup","modifiedCollectionIds","removeDelegatedOutcome","removeDrawEntries","entryId","removeMatchUpSideParticipant","removeRoundMatchUps","removeCompletedMatchUps","structureResult","roundRemoved","nums","updatedMatchUps","deletedMatchUpsCount","removeAdHocRound","removeSeededParticipant","removeSeeding","removeStructure","removedStructureIds","mainStageSequence1","isMainStageSequence1","qualifyingStructureIds","removedMatchUpIds","isQualifyingStructure","relatedStructureIdsMap","getTargetedStructureIds","idsToRemove","idBeingRemoved","targetedStructureIds","mainStageSequence1MatchUpIds","removeTieMatchUpParticipantId","drawPositionMap","pairParticipantId","pairParticipant","currentId","otherSide","renameStructures","detailMap","detail","resetDrawDefinition","removeScheduling","getRawMatchUp","resetMatchUpLineUps","modificationsCount","resetScorecard","tiebreakReset","resetVoluntaryConsolationStructure","resetEntries","setDelegatedOutcome","setDelegated","setDrawParticipantRepresentativeIds","representativeParticipantIds","setEntryPositions","entryPositions","setEventDates","setMatchUpFormat","processStructures","matchUpIdsToModify","setOrderOfFinish","finishingOrder","matchUpTieIds","validOrderOfFinish","valuesMap","targetedMatchUpIds","orderOfFinishValues","validValues","orderOfFinish","otherCohortMatchUps","setOrder","setPositionAssignments","structureDrawPositions","submittedDrawPositions","drawEngineSetPositionAssignments","setStructureOrder","setSubOrder","currentStructure","substituteParticipant","substituteParticipantId","relevantSide","availableParticipantIds","participantSubstitution","positionSwap","withdrawParticipantAtDrawPosition","generateQualifyingStructures","qualifyingProfiles","qualifyingDetails","sequenceSort","roundTargetSort","totalQualifiersCount","roundTargetProfile","finalQualifyingRoundNumber","finalQualifyingStructureId","targetRoundQualifiersCount","deriveQualifyingPositions","stageSequenceName","divisionsCount","getDrawTypeCoercion","policyDefined","drawTypeCoercion","policyApplied","generateDoubleElimination","deciderMatchUps","deciderStructure","rf","mainFinalRound","finalRound","consolationFinalRound","doubleEliminationLinks","luckyDraw","intDrawSize","nextIsFinal","luckyRoundProfiles","firstRound","roundPositionRange","getGenerators","getPrefixedStructureId","feedMainFinal","generators","singleElimination","FEED_IN$1","mainDrawProperties","generateRoundRobinWithPlayOff","generateDrawStructuresAndLinks","enforceMinimumDrawSize","overwriteExisting","existingQualifyingStructures","existingQualifyingStructureIds","existingMainStructure","existingQualifyingLinks","existingQualifyingDrawPositionsCount","drawPositionsCount","existingQualifiersCount","qualifyingStructureId","mainStructureIsPlaceholder","qualifyingResult","invalidDrawSize","multiStructure","generatorResult","generatedStructures","generatedLinks","generatedMainStructure","generatedMainStructureId","qualifyingDetail","generateDrawTypeAndModifyDrawDefinition","modifyOriginal","mainStageDrawPositionsCount","getAllowedDrawTypes","drawTypesPolicy","allowedDrawTypes","checkValidEntries","consideredEntries","eventGender","entryStatusMap","invalidEntries","ungroupedParticipant","mismatch","pairGender","validPairGender","personGender","validPersonGender","definitionTemplate","prepareStage","preparedStructureIds","qualifyingOnly","automated","enforcePolicyLimits","seedAssignmentProfile","seedByRanking","seededParticipants","assignSeedsCount","maxSeedsCount","groupSeedValue","initializeStructureSeedAssignments","seededParticipant","seedingScaleAttributes","rankingScaleAttributes","scaledEntriesCount","POLICY_SEEDING_DEFAULT","drawTypes","generateDrawDefinition","considerEventEntries","ignoreAllowedDrawTypes","voluntaryConsolation","seedingPolicy","validEntriesResult","existingMainTieFormat","newDrawDefinition","policiesToAttach","drawTypeResult","generateQualifyingPlaceholder","qualifyingPlaceholder","existingQualifyingPlaceholderStructureId","qualifyingConflicts","sortedStructureProfiles","sequence","qualifyingStageResult","SPLIT_WATERFALL","SPLIT_SHUTTLE","flightConstants","SPLIT_LEVEL_BASED","ASCENDING","DESCENDING","sortingConstants","ASC","DESC","generateLineUps","useDefaultEventRanking","singlesOnly","attach","defaultScaleName","sortOrder","formattedScaleType","matchUpTypeScales","scale","sortMethod","singlesScaleSort","doublesScaleSort","singlesSort","doublesSort","singlesMatchUp","typeSort","nextParticipantId","targetGender","newPairParticipant","getCourtDateAvailability","targetDateAvailability","defaultAvailability","generateTimeSlots","includeBookingTypes","courtDate","timeSlots","bookings","booking","bookingType","timeSlot","getCourtsAvailableAtPeriodStart","averageMatchUpMinutes","periodStart","periodStartTime","periodEndTime","enoughTime","validTimeSlot","slotStartTime","slotEndTime","getEnoughTime","availableToScheduleCount","courtGenerator","generateVirtualCourts","remainingScheduleTimes","clearScheduleDates","periodLength","courtBookings","unassignedBookings","inProcessCourts","bookingsThisCourt","existingBookings","assignedBookings","unassignedBooking","startMinutes","endMinutes","bestCourt","best","startDifference","startFits","virtualCourt","virtualCourts","calculatePeriodLength","combinedMinutes","getDateTimeBoundary","boundaryTime","comparisonTime","getScheduleTimes","calculateStartTimeFromCourts","courtsCount","previousCalculation","previousAvailableCourts","cumulativeMatches","cumulativePeriods","firstTimeSlotStartTime","dateStartTime","dateEndTime","timeSlotStartTime","timeSlotEndTime","getFirstTimeSlotStartTime","dayStartMinutes","dayMinutes","timingProfile","period","totalMinutes","dayMinutesToTimeString","newCourts","averageCourts","calculatedTotal","calculationDifference","addToSchedule","scheduleTimes","newTimes","scheduleTime","generationGovernor","garman","generateCourts","namePrefix","courtNumber","courtNames","generateFlightProfile","drawNameRoot","drawNames","splitMethod","scaledEntryParticipantIds","unscaledEntries","splitEntries","updatedFlightProfile","entriesChunk","attachProfile","generateVoluntaryConsolation","attachConsolation","cityMocks","shuffledCities","citiesData","candidateCities","cities","stateMocks","shuffledStates","statesData","candidateStates","states","postalCodeMocks","candidatePostalCodes","postalCodes","generatePersonData","personData","buffer","lastNames","firstFemale","firstMale","namesData","ISOs","lastNameDupeCount","femaleDupeCount","maleDupeCount","lastNameDupes","femaleDupes","maleDupes","candidates","lastName","personSex","firstName","generatePersons","personExtensions","gendersCount","maleCount","femaleCount","defaultCount","defaultPersonData","validPersonData","nationalityCodes","validatedPersonData","shuffledPersons","maleFirstNames","maleLastNames","femaleFirstNames","femaleLastNames","rangeStart","rangeEnd","yearRange","persons","birthYear","birthDay","birthDate","dateFromDay","generateAddress","addressAttributes","participantIndex","postalCode","city","countryCode","nameMocks","nameRoot","names","getSetComplement","isSide1","lowValue","calculatedValue","valueAsNumber","getTiebreakComplement","tiebreakNoAd","highValue","winBy","getHighTiebreakValue","parseScoreString","matchTiebreak","sideScore","setString","setTiebreakLowScore","setTiebreak","parseSet","generateOutcomeFromScoreString","neutralParsedSets","winningScoreString","losingScoreString","getMatchUpDailyLimits","dailyLimits","matchUpDailyLimits","tournamentDailyLimits","policyDailyLimits","defaultDailyLimits","getDailyLimit","checkDependenciesScheduled","matchUpScheduleTimes","allDateMatchUpIds","matchUpIdDependencies","remainingDependencies","dependenciesScheduled","findDrawDefinition","processNextMatchUps","matchUpPotentialParticipantIds","matchUpNotBeforeTimes","addPotentialParticipantIds","updateNotBeforeTime","checkParticipantProfileInitialization","individualParticipantProfiles","priorMatchUpType","potentialRecovery","potentialCounted","potentialBookings","updateTimeAfterRecovery","participantIdDependencies","recoveryValue","addParticipantPotentialRecovery","checkDependendantTiming","scheduledDependent","minutesMap","dependentNotBeforeTime","matchUpIdDependents","earliestDependent","dependent","candidateId","candidateScheduleTime","candidateDependent","DO_NOT_SCHEDULE","requestConstants","checkRequestConflicts","requestConflicts","potentials","personRequests","personIds","getIndividualParticipants","potentialPersonIds","relevantPersonRequests","request","requestType","scheduleStart","averageEnd","requestId","findMatchUpFormatTiming","timing","getScheduledRoundsDetails","scheduleCompletedMatchUps","matchUpFormatCohorts","orderedMatchUpIds","greatestAverageMinutes","recoveryMinutesMap","averageMinutesMap","scheduledRoundsDetails","roundPeriodLength","segmentSize","firstSegmentIndex","matchUpFormatOrder","getGroupedRounds","garmanSinglePass","groupedRounds","lastHash","groupedMatchUpIds","roundDetails","modifyParticipantMatchUpsCount","filteredPotentials","hasSchedule","processAlreadyScheduledMatchUps","dateScheduledMatchUpIds","dateScheduledMatchUps","byeScheduledMatchUpDetails","clearDate","alreadyScheduled","getMatchUpsToSchedule","alreadyScheduledMatchUpIds","matchUpsToSchedule","doNotSchedule","generateBookings","eventDetails","generateScheduleTimes","allCourts","timingParameters","getVenueSchedulingDetails","useGarman","venueScheduledRoundDetails","allDateScheduledMatchUpIds","allDateScheduledByeMatchUpDetails","processResult","venueCourts","previousRemainingScheduleTimes","checkRecoveryTime","sufficientTimeForIndiiduals","startA","endA","startB","endB","startAisContained","startBisContained","endAisContained","endBisContained","hasOverlap","analyzeScheduleOverlap","timeBetweenMatchUps","checkDailyLimits","participantIdsAtLimit","counterName","dailyLimit","bulkScheduleTournamentMatchUps","scheduleByeMatchUps","matchUpDetails","scheduled","drawIdMap","detailMatchUpIds","drawMatchUpIds","bulkScheduleMatchUps","matchUpContextIds","paramsCheck","contextIds","tournamentMatchUpDetails","auditAutoScheduling","autoSchedulingAudit","getCount","profileRoundsCount","dateProfile","vc","scheduledDatesCount","noTimeMatchUpIdsCount","noTimeMatchUpIds","scheduledMatchUpIdsCount","scheduledMatchUpIds","overLimitMatchUpIdsCount","overLimitMatchUpIds","requestConflictsCount","getPersonRequests","requestObjects","requestObject","requests","getEarliestCourtTime","courtStartTime","courtEndTime","earliestCourtTime","consideredStartTime","clearScheduledMatchUps","ignoreMatchUpStatuses","clearedScheduleCount","clearSchedules","scheduleProfileRounds","checkPotentialRequestConflicts","scheduleDates","dryRun","pro","schedulingProfileModifications","schedulingProfileIssues","validScheduleDates","profileDates","schedulingParams","dateSchedulingProfiles","dateschedulingProfile","recoveryTimeDeferredMatchUpIds","dependencyDeferredMatchUpIds","scheduleDateRequestConflicts","matchUpScheduleCourtIds","bumpLimits","dateCourts","venueTimeBoundaries","timeBoundaries","venueEarliestCourtTime","addDateCourtBooking","failSafe","schedulingComplete","schedulingIterations","venuePassFailSafe","matchUpIdsScheduled","courtIdsScheduled","venuePassComplete","passIterations","schedulingConflicts","courtTime","complete","formatTime","canScheduleMatchUpIds","canScheduledMatchUpIds","possibleToSchedulePct","possibleToSchedule","v2Scheduler","scheduleTimesRemaining","skippedScheduleTimes","maxScheduleTimeAttempts","scheduledThisPass","scheduledMatchUp","unused","tryAgain","jinnScheduler","newTournamentRecord","createTeamsFromParticipantAttributes","participantAttribute","personAttribute","teamNames","teamIndex","attributeValue","groupingAttributes","overlappingTeamParticipantIds","groupingAttribute","participantsAdded","genParticipantId","generateParticipants","rankingRange","scaledParticipantsCount","defaultRatingsParameters","valuesInstanceLimit","nationalityCodesCount","nationalityCodeType","addressProps","scaleAllParticipants","individualParticipantsCount","personNationalityCodes","mockedPersons","doublesRankings","singlesRankings","singlesRatings","doublesRatings","ratingAttributes","ratingParameters","getAttributes","generatedAttributes","attributeKeys","generateRatings","rating","countryCodes","postalCodesProfile","postalCodesCount","statesProfile","citiesProfile","citiesCount","statesCount","valuesFromProfile","addressValues","isoMin","getMin","isoList","isoCountry","countriesList","sideParticipantsCount","personNationalityCode","participantExtensions","participantTimeItems","address","addresses","singlesRanking","doublesRanking","addScaleItem","singlesRating","doublesRating","generateIndividualParticipant","pairName","groupParticipant","processTieFormat","alternatesCount","maxDoublesCount","maxSinglesCount","singlesMatchUpTotal","doublesMatchUpTotal","categories","OTHER$2","required","categoryString","doublesCount","singlescount","teamSize","maxDoublesDraw","maxSinglesDraw","addTournamentParticipants","eventProfiles","drawProfiles","largestTeamDraw","largestTeamSize","specifiedParicipantsCount","largestDoublesDraw","largestSinglesDraw","uniqueParticipantsCount","processDrawProfile","uniqueParticipants","isTeam","requiresUniqueParticipants","additionalParticipantsCount","eventProfile","eventTieFormatName","eventTieFormat","drawProfile","individualCompetitorsCount","getParticipantsCount","teamKey","courtTemplate","getInt","validTimePeriod","startHour","startMinute","endHour","endMinute","startTimeSort","startHourA","startMinuteA","startHourB","startMinuteB","validDateAvailability","timeNote","addCourt","availabilty","newCourt","addCourts","courtsAdd","courtNameRoot","venueAbbreviationRoot","courtTimings","courtRecords","courtTiming","courtAvailability","generateVenues","venueProfiles","generatedDateAvailability","addResult","getStageParticipantsCount","stageParticipantsCount","stageCount","uniqueParticipantStages","getStageParticipants","allUniqueParticipantIds","eventParticipantType","mainParticipantsCount","qualifyingParticipantsCount","stageParticipants","setParticipantScaleItem","equivalentValue","isValidScaleItem","addParticipantScaleItem","valueChanged","scaleItemAttributes","existingScaleItem","isUndefined","scaleId","getSetWinningSide","isDecidingSet","leadingSide","getLeadingSide","setIsComplete","ignoreTiebreak","NoAd","scoreDiff","containsSetTo","requiresTiebreak","tiebreakIsValid","winMargin","hasWinMargin","checkSetIsComplete","analyzeSet","expectTiebreakSet","expectTimedSet","expectStandardSet","isValidSetNumber","sideGameScores","sidePointScores","sideTiebreakScores","sideGameScoresCount","sidePointScoresCount","sideTiebreakScoresCount","tiebreakScore","gameScoresCount","tiebreakScoresCount","hasTiebreakCondition","gameScore","isCompletedSet","standardSetError","isValidStandardSetOutcome","validGameScores","meetsSetTo","isValidWinningSide","winningSideGameScore","losingSideGameScore","gamesDifference","setTiebreakDefined","validTiebreakScores","winningSideTiebreakScore","losingSideTiebreakScore","tiebreakNoAD","tiebreakDifference","minimumGamesWinMargin","losingSideGameScoreAtSetToThreshold","invalidWinningScore","checkValidStandardSetOutcome","tiebreakSetError","isValidTiebreakSetOutcome","meetsTiebreakTo","minimumTiebreakWinMargin","losingSideGameScoreAtTiebreakToThreshold","checkValidTiebreakSetOutcome","isValidSetOutcome","analysis","isValidSet","analyzeMatchUp","isTiebreakValue","isPointValue","isCompletedMatchUp","setIndex","isExistingSet","completedSets","completedSetsCount","setsFollowingCurrent","isLastSetWithValues","noValues","specifiedSetAnalysis","isActiveSet","isValidSideNumber","hasExistingValue","completedSetsHaveValidOutcomes","validOutcome","validMatchUpWinningSide","validMatchUpOutcome","defaultStatusProfile","generateOutcome","defaultWithScorePercent","matchUpStatusProfile","pointsPerMinute","sideWeight","matchUpStatusMap","statusMap","pointer","valueMap","outcomePointer","noScore","side2ScoreString","weightedSide","weightedRange","incompleteAt","weightedWinningSide","incomplete","winningSideNumber","generateSet","weightIndex","calcPoints","pointsVariation","totalPoints","sidePoints","weight","weightedRandom","scores","highSide","specifiedWinningSide","setAnalysis","tiebreakWinningSide","completeDrawMatchUps","completeAllMatchUps","randomWinningSide","completionGoal","sortedStructures","completedCount","firstRoundDualMatchUps","assignParticipants","singlesMatchUps","doublesMatchUps","doublesMatchUp","sortedMatchUpIds","smartComplete","completeDrawMatchUp","generateFlightDrawDefinitions","existingDrawIds","generate","drawParticipantIds","drawExtensions","withPlayoffs","generateEventParticipants","eventIndex","uniqueFlightParticipants","uniqueDrawParticipants","uniqueParticipantIds","generateFlight","drawParticipants","generateFlights","uniqueParticipantsIndex","generateEventWithFlights","eventExtensions","eventAttributes","eventResult","flightResult","drawDefinitionResult","eventParticipantIds","getCompetitionDateRange","dateRange","dateOfStart","dateOfEnd","addSchedulingProfileRound","dateObject","venueOnDate","excludeKeys","hashRound","existingRound","generateEventWithDraw","drawIndex","drawProfileCopy","excessParticipantAlternates","tournamentAlternates","ignoreDefaults","drawParticipantsCount","individualParticipantCount","maleIndividualParticipantIds","femaleIndividualParticipantIds","remainingParticipantIds","mixedCount","fIndex","mIndex","rIndex","fPIDs","mPIDs","rIDs","isEventParticipantType","isEventGender","consideredParticipants","qualifyingParticipantIds","qualifyingIndex","alternatesParticipantIds","manual","goComplete","outcomeDef","matchUpIndex","structureMatchUpIds","sm","orderedStructures","mockTournamentNames","credits","mocksGovernor","anonymizeTournamentRecord","keepExtensions","anonymizeParticipantNames","extensionsToKeep","filterExtensions","idMap","newTournamentId","parentOrganisation","venueIndex","newVenueId","eventCount","newEventId","newDrawId","updateStructure","newStructureId","childStructure","genderedPersons","genderedIndices","addressComponents","components","genderedIndex","generatedPerson","generateTournamentRecord","tournamentAttributes","tournamentExtensions","autoSchedule","tournamentDate","scheduledRounds","schedulerResult","winnerFinishingPositionRange","targetRange","containingStructureId","roundToSchedule","generateScheduledRounds","modifyTournamentRecord","totalParticipantsCount","formatPersonName","personFormat","alpha","lastFirst","commaSeparated","spacer","firstInital","allLowerCase","allUpperCase","lastUpperCase","lastNameOnly","formatParticipantName","formats","doublesJoiner","penaltyRemove","penaltyId","modifiedParticipants","removedPenalty","penaltyRemoved","participantModified","penalties","penalty","penaltyTemplate","refereeParticipantId","penaltyCode","penaltyType","issuedAt","penaltyModify","validAttributes","validModificationAttributes","updatedPenalty","deepMerge","arrayMerge","merged","mergedArrays","penaltyAdd","relevantParticipants","penaltyItem","participantGovernor","addPenalty","tournamentParticipantIds","addPersons","existingPersonIds","newPersonIds","personsToAdd","addedPairParticipantsCount","addedIndividualParticipantsCount","pairedPersons","createGroupParticipant","groupName","mergeParticipants","incomingParticipants","arraysToMerge","mappedParticipants","incomingIdMap","mergedParticipant","modifiedParticipantsCount","newParticipantsCount","modifyIndividualParticipantIds","individualParticipantIdsToAdd","individualParticipantIdsToRemove","modifyParticipantName","modifyParticipantOtherName","modifyParticipantsSignInStatus","signInState","allParticipantIds","modifyPenalty","regenerateParticipantNames","removePenalty","scaledTeamAssignment","clearExistingAssignments","reverseAssignmentOrder","initialTeamIndex","scaledParticipants","teamNameBase","teamsCount","participantIdsToAssign","orderedTeamParticipantIds","relevantTeams","nameBase","addedParticipantIds","relevantTeam","preAssignedParticipantIds","scaledParticipant","relevantTeamParticipantIds","relevantTeamEntries","relevantEntry","relevantTeamParticipantId","setParticipantScaleItems","modificationsApplied","participantScaleItemsMap","policyDeletion","policyGovernor","removePolicy","policyRemoved","unPublishOOP","orderOfPlay","publishOOP","publishingGovernor","getAllEventData","allEventData","eventsData","publishEventSeeding","updatedSeedingScaleNames","publishOrderOfPlay","setEventDisplay","existingDetail","sd","unPublishEvent","unPublishEventSeeding","unPublishOrderOfPlay","getExtensionUpdate","extensionName","tournamentExtensionAdded","ADULT","JUNIOR","WHEELCHAIR","POLICY_SCHEDULING_DEFAULT","allowModificationWhenMatchUpsScheduled","getModifiedMatchUpFormatTiming","getTournamentPenalties","allPenalties","scheduledSortedMatchUps","profileHash","getHash","sortedMatchUps","dateGroups","noScheduledDate","sortedDateKeys","dateGroup","timeGroups","noScheduledTime","sortedTimeKeys","timeGroup","courtGridRows","courtPrefix","minRowsCount","courtsData","maxCourtOrder","rowBuilder","rowIndex","courtIndex","rows","row","rowId","tournamentMatchUps","filteredEventIds","getCompetitionMatchUps","tournamentsMatchUps","matchUpGroupings","competitionScheduleMatchUps","sortDateMatchUps","courtCompletedMatchUps","alwaysReturnCompleted","withCourtGridRows","minCourtGridRows","sortCourtsData","tournamentPublishStatus","dateMatchUps","detailsMap","getCompetitionPublishedDrawDetails","stageKeys","unpublishedStages","publishedStages","structureIdKeys","unpublishedStructureIds","publishedStructureIds","courtMatchUps","getCourtMatchUps","getSourceStructureIdsAndRelevantLinks","structureLinkType","QUALIFYING_PARTICIPANT_METHOD","ALTERNATE_PARTICIPANT_METHOD","LUCKY_PARTICIPANT_METHOD","REMOVE_ASSIGNMENT_METHOD","SWAP_PARTICIPANT_METHOD","MODIFY_PAIR_ASSIGNMENT_METHOD","ASSIGN_PARTICIPANT_METHOD","ASSIGN_BYE_METHOD","ADD_PENALTY_METHOD","MODIFY_PAIR_ASSIGNMENT","QUALIFYING_PARTICIPANT","ALTERNATE_PARTICIPANT","WITHDRAW_PARTICIPANT","ASSIGN_PARTICIPANT","REMOVE_ASSIGNMENT","LUCKY_PARTICIPANT","REMOVE_SEED","SWAP_PARTICIPANTS","ADD_NICKNAME","SEED_VALUE","ADD_PENALTY","ASSIGN_BYE","positionActionConstants","eligibleEntryStage","restrictQualifyingAlternates","validAssignmentsSort","getValidSwapAction","onlyAssignedPositions","possiblyDisablingAction","isByePosition","availableDrawPositions","assignmentCheck","sourceDrawPositionRangeMap","drawPosition2","participantsAvailable","availableParticipantsMap","availableAssignments","validSwapAction","willDisableLinks","POLICY_POSITION_ACTIONS_DEFAULT","disbledStructures","otherFlightEntries","activePositionOverrides","POSITION_ACTION","MATCHUP_ACTION","getEnabledStructures","actionType","defaultPolicy","actionsPolicy","targetFeedProfiles","disabledStructures","actionsDisabled","structurePolicy","structureTypes","feedProfiles","activePositionsCheck","getPolicyActions","policyActions","matchesStage","matchesStageSequence","matchesStructureType","matchesFeedProfile","isAvailableAction","REPLACE_TEAM_POSITION_METHOD","ASSIGN_TEAM_POSITION_METHOD","REMOVE_TEAM_POSITION_METHOD","ASSIGN_SIDE_METHOD","REMOVE_SIDE_METHOD","SUBSTITUTION_METHOD","REMOVE_SUBSTITUTION","REPLACE_PARTICIPANT","REMOVE_PARTICIPANT","SCHEDULE_METHOD","SUBSTITUTION","REFEREE","START","SCORE","END","matchUpActionConstants","adHocMatchUpActions","restrictAdHocRoundParticipants","validActions","roundAssignedParticipantIds","availableEventAlternatesParticipantIds","getEventAlternateParticipantIds","availableAlternatesParticipantIds","otherFlightEnteredParticipantIds","availableAlternates","alternate","matchUpActions","specifiedPolicyDefinitions","participantid","adHocValidActions","structureIsComplete","isInComplete","addPenaltyAction","collectionValidActions","firstFoundSide","assignedGender","particiapntId","allParticipants","existingParticipants","availableIndividualParticipants","availableParticipants","assignmentAvailable","availableIds","substitutedParticipantIds","sub","matchUpActionPolicy","collectionMatchUpActions","getSideValues","singlesForDoubles","exclusionRule","valueAccessor","sortedRange","checkExcludeParticipant","exclusionValue","exclusionValues","pValue","checkIsDual","twoTeams","getRoundId","getRoundTiming","formatCounts","roundMinutes","formatCount","formatMinutes","getRoundProfile","byeCount","scheduledCount","consideredCount","unscheduledCount","incompleteCount","isScheduled","getProfileRounds","withRoundId","segmentedRounds","profileRounds","roundRef","roundSort","minFinishingSum","queryGovernor","analyzeTournament","isDual","bulkUpdatePublishedEventIds","relevantEventsIds","publishedEventIds","eventIdPublishedDrawIdsMap","getAllowedMatchUpFormats","scoringPolicy","getCompetitionParticipants","idsWithConflicts","tournamentMappedMatchUps","tournamentParticipantMap","participantGetter","getCompetitionPenalties","getCourts","getDrawDefinitionTimeItem","getDrawParticipantRepresentativeIds","getEligibleVoluntaryConsolationParticipants","excludedMatchUpStatuses","includeEventParticipants","includeQualifyingStage","finishingRoundLimit","roundNumberLimit","requirePlay","requireLoss","allEntries","winsLimit","eventMatchUpFilters","drawMatchUpFilters","voluntaryConsolationEntryIds","participantMatchUps","losingParticipants","matchUpParticipants","participantWins","losingSide","considerEntered","losingParticipantIds","eligibleParticipants","satisfiesLoss","satisfiesPlay","satisfiesWinsLimit","satisfiesMatchUpsLimit","notPreviouslySelected","individual","getEvent","eventCopy","getEventMatchUpFormatTiming","matchUpFormatDefinitions","uniqueMatchUpFormats","definitionObject","at","eventMatchUpFormatTiming","getEventProperties","hasSeededParticipants","hasRankedParticipants","hasRatedParticipants","entryScaleAttributes","seed","getEvents","scaleEventType","eventCopies","ratingsStats","scaleRating","med","avg","processFlight","processedDrawIds","ignoreDrawId","eventScaleValues","getMatchUpDailyLimitsUpdate","getMatchUpFormat","matchUpResult","structureDefaultMatchUpFormat","drawDefaultMatchUpFormat","eventDefaultMatchUpFormat","getMatchUpFormatTimingUpdate","getMatchUpsStats","pctspd","categorize","WALKOVER$1","competitiveBands","retiredCount","getMaxEntryPosition","getParticipantEventDetails","getParticipantIdFinishingPositions","byeAdvancements","participantIdMatchUps","getParticipantIdMatchUps","participantIdFinishingPositions","finishingPositionRanges","participantSide","getParticipantMembership","groupingTypesMap","getParticipantSchedules","scheduledMatchUps","relevantSourceMatchUps","participantSchedules","getParticipantSignInStatus","getParticipantTimeItem","getPredictiveAccuracy","excludeMargin","zoneDoubling","zonePct","scaleProfile","ratingsRangeDifference","zoneMargin","accuracy","affirmative","negative","sideValues","missingValues","valuesGap","floatMargin","excludeGap","signedGap","percent","getGroupingAccuracy","marginCalc","zoneData","zoneBands","bands","getGroupingBands","totalZoneMatchUps","zoneDistribution","nonZone","getRounds","excludeScheduleDateProfileRounds","excludeScheduledRounds","excludeCompletedRounds","withSplitRounds","noTournamentRecords","tournamentVenueIds","validVenueIds","profileRoundsMap","excludedRounds","foo","roundTiming","roundId","keepComplete","keepScheduled","validStartDate","validEndDate","validVenue","keepRound","getSchedulingProfileIssues","issuesCount","roundIndexShouldBeAfter","schedulingErrors","getRoundIndex","shouldBeAfter","errorsDetail","matchUpRoundIndex","earlierRoundIndices","profileIssues","matchUpIdShouldBeAfter","issue","structureDefaultTieFormat","getTournamentPersons","tournamentPersons","extractPerson","getTournamentStructures","eventStructures","eventStageStructures","getVenuesReport","courtDates","venuesReport","venueReport","availableMinutes","availableCourts","courtAvailableMinutes","venueMatchUps","matchUpScheduledMinutes","percentUtilization","scheduledMatchUpsCount","getVenueReport","isValidForQualifying","participantScheduledMatchUps","positionActions","positionActionsPolicy","positionSourceStructureIds","ready","isWinRatioFedStructure","disablePlacementActions","stageAssignedParticipantIds","unassignedParticipantIds","isActiveDrawPosition","hasPositionAssigned","isDrawPosition","validAssignmentActions","ignoreSeedPositions","validToAssign","getValidAssignmentActions","qualifyingParticipants","disableRoundRestrictions","requireCompletedStructures","eliminationSoureStructureIds","eliminationSourceLinks","roundRobinSourceStructureIds","roundRobinSourceLinks","sourceLink","getValidQualifiersAction","validToAssignSeed","addNicknameAction","otherName","validAlternatesAction","validAssignmentParticipantIds","availableDrawEnteredParticipantIds","getValidAlternatesAction","validLuckyLosersAction","availableLuckyLoserParticipantIds","availableLuckyLosers","luckyLoser","getValidLuckyLosersAction","validModifyAssignedPairAction","availableIndividualParticipantIds","existingIndividualParticipants","getValidModifyAssignedPairAction","allPlayoffPositionsFilled","enteredParticipantsCount","participantIdsCount","allFilled","structurePositionsFilled","getMatchUpContextIds","getSeedingThresholds","validGroupsCounts","seedingThresholds","seedNumberBlock","getDetailsWTN","personOtherId","personOtherIds","tennisId","personWTN","wtnRating","getAvgWTN","matchUpFormatCounts","countMatchUpFormat","eventParticipants","wtnRatings","pctNoRating","wtnTotals","totals","wtnDetails","totalWTN","totalConfidence","avgWTN","avgConfidence","reportGovernor","getStructureReports","firstFlightOnly","extensionProfiles","eventStructureReports","extensionValues","getSeedingBasis","scaleBasis","tournamentStructureData","eventTimeItems","flightMap","drawDeletionsCount","mapValues","minFlightNumber","eventSeedingBasis","totalPositionManipulations","maxPositionManipulations","generatedDrawsCount","seedingBasis","drawMatchUpFormat","drawTieFormat","drawTimeItems","positionManipulations","getPositionManipulations","manipulationsCount","finalMatchUp","winningParticipant","winningTeamId","winningPersonWTN","winningPersonId","winningPersonOtherId","winningPersonTennisId","confidence1","wtnRating1","winningPerson2WTN","winningPerson2Id","winningPerson2OtherId","winningPerson2TennisId","confidence2","wtnRating2","pctInitialMatchUpFormat","drawTieFormatName","drawTieFormatDesc","structureTieFormatName","structureTieFormatDesc","equivalentTieFormatDesc","manipulations","winningPersonWTNrating","winningPersonWTNconfidence","winningPerson2WTNrating","winningPerson2WTNconfidence","structureReports","getEntryStatusReports","nonTeamEnteredParticipantIds","withDrawnParticipantIds","participantEntryReports","entryStatusReports","eventReports","drawDefinitionsCount","pushEntryReport","entryDetailsWTN","countEntryStatus","createEntryMap","participantEntriesMap","processDoublesEvent","totalEntries","pct","selectedStatuses","nonParticipatingParticipantIds","tournamentEntryReport","nonParticipatingEntriesCount","eventsCount","getParticipantStats","withCompetitiveProfiles","withIndividualStats","participantDetails","participantStats","participating","teamMap","initStats","competitorIds","tiebreaks","getSideParticipantIds","stats","getCompetitorIds","thisTeamId","teamSumTally","stat","tallyIndex","statsattributes","competitivenessAttributes","ratio","fixedValue","highLowSort","teamStats","opponentStats","participatingTeamsCount","allParticipantStats","generateTimeCode","uidate","mergePersonRequests","filteredRequests","mergeCount","savePersonRequests","tournaments","calculateScheduleTimes","minStartTime","comparisonStartTime","maxEndTime","comparisonEndTime","matchUpsWithSchedule","modifyMatchUpFormatTiming","eventModified","modifyTiming","modifyScheduling","formatAverageTimes","formatRecoveryTimes","averageTime","updatedMatchUpAverageTimes","recoveryTime","updatedMatchUpRecoveryTimes","removeTiming","bulkReschedule","scheduleChange","rescheduledMatchUpIds","notRescheduledMatchUpIds","minutesChange","scheduledNotCompletedMatchUps","notCompleted","doNotReschedule","newScheduledTime","newScheduledDate","scheduledTimeDate","newTime","timeStringDate","updatedInContext","rescheduled","notRescheduled","allRescheduled","scheduleGovernor","addMatchUpOfficial","officialType","addPersonRequests","bulkRescheduleMatchUps","notRescheduledIds","removeFromNotScheduledIds","bulkUpdateCourtAssignments","courtAssignments","drawMap","clearMatchUpSchedule","newTimeItems","matchUpScheduleChange","sourceMatchUpContextIds","targetMatchUpContextIds","sourceCourtId","targetCourtId","sourceTournamentId","targetDrawId","targetTournamentId","matchUpsModified","assignMatchUp","sourceResult","targetResult","allocateCourts","modifyEventMatchUpFormatTiming","currentAverageTime","currentRecoveryTime","newTiming","validAverageMinutes","validRecoveryMinutes","newAverageTimes","newRecoveryTimes","modifyPersonRequests","requestIds","modifyRequests","updatedRequest","newRequests","proAutoSchedule","localPerspective","gridMatchUps","gridRows","deps","previousRowMatchUpIds","unscheduledMatchUps","unscheduledMatchUpIds","linkedMatchUpIds","unscheduledContainSource","previousIncludesDependent","rowIncludesLinked","rowContainsParticipants","notScheduled","proConflicts","filteredRows","rowIndices","courtIssues","rowProfiles","potentialMatchUpParticipantIds","rowIssues","issueType","issueIds","previousRow","subsequentRows","participantConflicts","conflictedParticipantIds","conflictedMatchUpIds","previousRowWarnings","warnedMatchUpIds","subsequentRow","sourceAfter","insufficientGap","sourceDistance","distance","consideredCourtId","warningMatchUpIds","removeEventMatchUpFormatTiming","removeMatchUpCourtAssignment","removePersonRequests","filterRequests","removeAll","reorderUpcomingMatchUps","matchUpsContextIds","firstToLast","calculatedIndex","assignMatchUpScheduledTime","scheduleMatchUps","competitionMatchUps","recoveryTimeDeferred","dependencyDeferred","mappedRecoveryMinutes","setMatchUpDailyLimits","standardSet","standardSetComma","RegExp","tiebreakSetComma","regularExpressions","pattern","expression","isValidPattern","isTiebreakScore","isDiffOne","stripped","getSuper","dashJoin","isContained","endsWith","dashMash","segment","dashIndices","numbers","eventNumberCount","oddDashCount","substring","setBuilder","chars","resetSet","completeSet","joinedSet","getDiff","digit","twoSetScores","lastChar","parseSuper","oneIndex","superTiebreak","handleNumeric","onlyNumbers","tb","mtb1","mtb2","mtb3","tb1","tb2","tb3","tb4","s3","s4","s5","s6","superParse","chunkCharacter","allWinners","positiveInstances","set1tb","set2tb","n1","n2","n3","n4","n5","n6","tiebreakChunkIndex","n7","n8","getWinningSide","setWinners","getSetScores","setsTied","transforms","handleTiebreakSlashSeparation","replacement","handleSetSlashSeparation","punctuationAdjustments","brackets","parens","openers","typeCount","corrected","isOpener","domain","correctContainerMismatch","closeParenDigit","instance","bws","ws","trimmedBracketValue","doubleBracketed","dbls","dbl","repeatingDash","dashScenario","dashSpace","spacedDash","spaced","ghost","digits","slashClose","slashComma","slashOpen","missingOpenParen","missingCloseParen","missingCloseBracket","noClose","getMissing","unclosed","setScore","innards","hasAlpha","hasDigits","punctuation","reconstructed","open","close","openFirst","handleGameSeparation","singleSet","joinFloatingTiebreak","strip","bracketToParen","deDash","floatingTiebreaks","lastIndex","joinedScore","floatingTiebreak","thisIndex","leading","prior","sameScore","trim","parenScores","isBracketScore","lastPart","joinedParts","lastSet","tiebreakIndices","setCheck","potentialSuper","getContained","handleBracketSpacing","setComma","setsEndComma","commaEnd","handleSpaceSeparator","isSpaced","spaceSeparatedDigits","ssd","noSpaces","separateScoreBlocks","xPart","app","matchKnownPatterns","smashSlash","before","after","missingZero","noSpacing","parenStart","deDashMash","smashedSets","ss","setSpacing","slashSeparation","left","right","set1","set2","commaSeparation","singleSetCommaSeparation","noSetSeparation","middle","separated","reformatted","getFloatingTiebreak","floater","spaceSeparatedSets","slashCommaSets","excerpt","missedSet0","slashSetGlobal","slashSets","slashSet","newScore","dashSet","spaceSeparatedSuper","spaceSeparatedSetTB","ssb","getFloaters","getFloater","tail","getSpacedTibreakSets","spacedTB","getSpacedTibreakSet","spacedScore","removeDanglingBits","targetPunctuation","alphaEnding","scorePart","removeErroneous","handleWalkover","properTiebreak","considerCompleted","misTyped0","handleRetired","providerRetired","retired","ret","containedSets","identifier","withParens","contained","container","matched","priorDigits","priorTwo","mashed","withBrackets","bracketed","potentialMiddles","ending","commadDelimited","slashDelimited","dashDelimited","delimiter","emptyParens","sensibleSets","maxSetValue","sensibleSetScores","minIndex","splitMax","reasonable","stringScore","superSquare","finalSetMatchTiebreak","highTiebreakScore","finalSet","modifiedScores","excisions","openComma","replaceOh","transformations","processingOrder","secondPass","SPACE_CHARACTER","OUTCOME_DEFAULT","OUTCOME_WALKOVER","OUTCOME_ABANDONED","OUTCOME_SUSPENDED","OUTCOME_RETIREMENT","OUTCOME_INTERRUPTED","OUTCOMES","STATUS_DEFAULT","STATUS_WALKOVER","STATUS_ABANDONED","STATUS_SUSPENDED","STATUS_RETIREMENT","STATUS_INTERRUPTED","WINNING_STATUSES","SET_TIEBREAK_BRACKETS","MATCH_TIEBREAK_BRACKETS","MOVEUP","MOVEDOWN","BACKSPACE","RETIRE","SUSPEND","ABANDON","DEFAULT","INTERRUPT","OUTCOMEKEYS","SPACE_KEY","OPENERS","CLOSERS","SCORE_JOINER","MATCH_TIEBREAK_JOINER","ALTERNATE_JOINERS","SIDE1KEYS","SIDE2KEYS","MODIFIERS","VALID_VALUE_KEYS","HOTKEYS","keyValueConstants","PROMPT","addOutcome","lowSide","removeOutcome","removeFromScore","newSets","outcomeRemoved","setValuesCount","isTiebreakEntry","isMatchTiebreak","testTiebreakEntry","lastNumericIndex","openSetTiebreak","lastOpenBracketIndex","lastMatchTiebreakOpenBracketIndex","openMatchTiebreak","lastNewScoreChar","remainingNumbers","isIncompleteScore","isIncompleteSetScore","splitScoreString","matchTiebreakScores","highIndex","newSide1Score","isTimedSet","newSide2Score","splitScore","getMatchUpWinner","scoreGoal","updated","getScoreAnalysis","finalSetIsComplete","isSetTiebreakEntry","isMatchTiebreakEntry","lastScoreChar","isNumericEnding","isIncompleteSetTiebreak","isIncompleteMatchTiebreak","isPartialMatchTiebreakValue","lastJoinerIndex","matchTiebreakHasJoiner","lastSetIsComplete","isGameScoreEntry","hasOutcome","isNumericValue","isSpace","isCloser","hasOpener","isInvalidMatchTiebreakValue","lastCloseBracketIndex","checkValidMatchTiebreak","isTiebreakSetValue","isTiebreakCloser","isInvalidSetTiebreakValue","getHistory","history","undoHistory","saveHistory","scoreGovernor","keyValueScore","shiftFirst","auto","isShifted","finalCharacter","currentSetScore","priorSetScores","keyValueTimedSetScore","validSide2Score","checkValidSide2Score","processIncompleteSetScore","processTiebreakSet","tiebreakValue","hasZeroStart","newTiebreakValue","needsTiebreak","keyValueSetScore","parseMatchUpFormat","reverseScore","reversedSets","reversedScore","stringifyMatchUpFormat","tidyScore","incomingScore","sheetName","fileName","stepLog","fullLog","doProcess","application","calculateHistoryScore","updateScore","pointProgression","tiebreakServingSide","unknowns","servingSide","faults","isValidSide","newSet","point","shots","game","processedCount","tiebbreakFormat","isTiebreak","tiebreakDetails","cleanup","completeGame","completePoint","gameCompleted","srv","shotOutcome","shotType","pointNumber","gameNumber","winningScoreSide","losingScoreSide","setServingSide","clearHistory","addPoint","addGame","addShot","shot","addSet","redo","undo","umo","scoreboard","addPoints","tournamentConstants","ACTIVE","setTournamentDates","checkScheduling","invalidScheduledDates","invalidSchedulingMatchUpIds","removeInvalidScheduling","tournamentDates","extents","updatedDateAvailability","updateCourtAvailability","tournamentGovernor","addOnlineResource","onlineResource","organisationId","parentOrganisationId","addParticipantExtension","removeDrawDefinitionExtension","removeNotes","removeParticipantExtension","setTournamentCategories","tournamentCategories","setTournamentEndDate","setTournamentName","setTournamentNotes","setTournamentStartDate","setTournamentStatus","baseAttributeKeys","flattenJSON","keyJoiner","path","utilitiesGovernor","visualizeScheduledMatchUps","showGlobalLog","structureNames","dehydrateMatchUps","matchUpFormatMap","getMatchUpFormatMap","inheritedMatchUpFormat","removeExtraneousAttributes","chunkSizeProfile","otherSizes","countValues","generateHashCode","keyCount","charSum","hasAttributeValues","JSON2CSV","arrayOfJSON","columnTransform","includeTransformAccessors","includeHeaderRow","returnTransformedJSON","removeEmptyColumns","onlyHeaderRow","columnAccessors","functionMap","columnMap","columnJoiner","rowJoiner","flattened","transformColumns","headerRow","accessorMap","transform","tranformedHeaderRow","columnName","mappedHeaderRow","withDelimiter","columnValueCounts","flattenedRows","columnsMap","columnIndex","mappedValue","fxValue","indicesToRemove","columnValues","noNulls","occurrences","subSort","sortFx","undefinedToNull","UUIDS","utilities","getScheduledCourtMatchUps","modifyCourtAvailability","dateResult","totalMergeCount","availabilityByDate","byDate","mergedAvailability","dateDetails","lastStartTime","lastEndTime","lastBookings","safety","getMergedAvailability","sortAndMergeDateAvailability","courtResult","matchUpsWithInvalidScheduling","deletionMessage","removeCourtAssignment","deleteVenue","matchUpsToUnschedule","deleted","courtsDisable","disabledValue","disableCourt","venuesDisable","courtsEnable","enableAll","courtDeletion","modifyCourt","courtModified","courtModification","validReplacements","validReplacementAttributes","venueTemplate","venueType","roles","venueModify","allocatedVenueIds","getVenueMatchUps","getScheduledVenueMatchUps","existingCourtIds","courtIdsToModify","courtIdsToDelete","matchUpsWithCourtId","courtsToDelete","scheduleDeletionsCount","venueGovernor","deleteCourt","courtDeleted","deleteVenues","disableCourts","disableVenues","enableCourts","paramsToCheck","enableVenues","modifyVenue","governors","matchUpFormatGovernor","forge","notifySubscribers","mutationStatus","directives","topicSort","notifySubscribersAsync","topicValues","getMutationStatus","updateFactoryExtension","version","engineLogging","engineType","logError","specifiedMethodParams","logParams","perf","logMethodNotFound","executeFunction","sandboxTournament","paramsToLog","augmentedParams","_middleware","paramsMiddleware","invoke","record","deepCopyOption","globalSetTournamentRecord","setState","asyncEngineInvoke","args","methodsCount","passedMethod","remainingArgs","snapshot","rollbackOnError","notify","delayNotify","doNotNotify","engineStart","engineInvoke","importMethods","getTournament","getState","removeUnlinkedTournamentRecords","asyncEngine","executionQueue","pipe","lastResult","pipeKeys","pipeKey","rolledBack","asyncExecutionQueue","execute","askInvoke","askEngine","syncEngine","competitionEngine","tournamentEngine","keyedMatchUps","matchUpEngine","governor","importGovernors","devContextSet","mocksEngine","isDev","invocationResult","getTargetElement","getAwardProfile","awardProfiles","level","awardProfile","dateRanges","isValidDateRange","maxFlightNumber","drawSizes","levels","maxDrawSize","maxLevel","ageCategoryCodes","eventTypes","getAwardPoints","valueObj","getValue","objectValue","flightValue","getFlightValue","requireWin","awardPoints","winAccessor","sizeDefined","thresholdMatched","defaultDef","rankingsGovernor","getTournamentPoints","saveRankings","attachedPolicies","pointsPolicy","requireWinFirstRound","requireWinForPoints","participantsWithOutcomes","personPoints","teamPoints","pairPoints","rangeAccessor","totalWinsCount","positionPoints","perWinPoints","dashRange","finishingPositionPoints","pointsPerWin","ppwProfile","pwp","participationOrders","winRequired","levelValue","teamStructureMatchUps","winningSice","award","eloConfig","nSpread","diffThreshold","kCalc","countables","kMultiplier","maxCountables","counted","kset","kDefault","calculateNewRatings","winnerRating","loserRating","ratingRange","winnerCountables","loserCountables","invertedScale","decimalPlaces","consideredRange","inRange","convertRange","sourceRange","convertedWinnerRating","convertedLoserRating","getExpectation","playerRating","opponentRating","winnerExpectation","loserExpectation","winnerKValue","loserKValue","winnerUpdatedConvertedRating","loserUpdatedConvertedRating","convertedUpdatedWinnerRating","convertedUpdatedLoserRating","updatedWinnerRating","newWinnerRating","updatedLoserRating","newLoserRating","percentageDifference","generateDynamicRatings","considerGames","asDynamic","ratingParameter","modifiedScaleValues","dynamicScaleName","dynamicScaleAttributes","outputScaleName","scaleItemMap","dynamicScaleItem","winningSideParticipantIds","losingSideParticipantIds","winnerScaleValue","loserScaleValue","newWinnerScaleValue","newLoserScaleValue","processedMatchUpIds","ratingsGovernor","scaleEngine","fixtures","POLICY_AVOIDANCE_COUNTRY","POLICY_POSITION_ACTIONS_DISABLED","POLICY_POSITION_ACTIONS_NO_MOVEMENT","POLICY_POSITION_ACTIONS_UNRESTRICTED","POLICY_PRIVACY_DEFAULT","participantStatus","representing","biographicalInformation","nativeFamilyName","nativeGivenName","otherNames","passportFamilyName","passportGivenName","previousNames","wheelchair","POLICY_SCORING_DEFAULT","defaultMatchUpFormat","POLICY_SCORING_USTA","POLICY_SEEDING_ITF","flagIOC","penaltyConstants","COACHING","BALL_ABUSE","RACKET_ABUSE","VERBAL_ABUSE","PHYSICAL_ABUSE","INELIGIBILITY","UNSPORTSMANLIKE_CONDUCT","PROHIBITED_SUBSTANCE","DRESS_CODE_VIOLATION","EQUIMENT_VIOLATION","LEAVING_THE_COURT","REFUSAL_TO_PLAY","FAILURE_TO_COMPLETE","NO_SHOW","PUNCTUALITY","FAILUIRE_TO_SIGN_IN","surfaceConstants","CLAY","HARD","GRASS","CARPET","ARTIFICIAL","venueConstants","INDOOR","OUTDOOR","factoryConstants"],"mappings":"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A7C,8BACAgH,+BACA7F,kBACAC,sBACAmD,oBACAuE,oBACAH,iCACAD,yBACAlE,6BACAE,gBACA/E,0BACAM,oCACAO,wBACAG,qBACA+G,oBACAtF,mBACAL,sBACA8C,uBACAgE,kBACA7F,0BACAF,0BACAJ,8BACAe,mBACAmF,kBACAtD,0BACAC,2BACAC,4BACAxE,+BACAyE,4BACAJ,uBACAvB,6BACAxE,kBACA+I,sBACA/G,uBACAC,yBACA2I,mBA/egC,CAChC/K,QAAS,oBACTC,KAAM,0BA8eN6E,uBACAa,iBACAvC,iBACAsF,sBACA9H,oBACA6H,qBACA7E,sBACA4B,gBACAoD,qBACAnD,4BACAnF,4BACAsJ,kBACAhE,wBACAzB,qBACAuG,oBACAxH,uBACA2F,gCACApE,4BACAV,iCACAiB,oBACAiD,uBACA3C,6BACAJ,gBACAzE,0BACAkB,mBACAL,yBACAH,yBACAO,qBACAsB,mBACAH,iBACAiB,0BACAG,sBACAC,uBACAG,mBACAD,oBACA2C,6BACAL,0BACAI,2BACAP,4BACAC,uBACAC,wBACAsB,sBACAD,wBACAb,0BACAvC,6BACAF,6BACAD,uBACAjB,gCACA0H,qBAztBkC,CAClChL,QAAS,sBACTC,KAAM,4BAwtBNgJ,oBACAgC,uBA3iBoC,CACpCjL,QAAS,0CACTC,KAAM,8CA0iBNiC,4BACAH,gCACAmJ,uBA1kBoC,CACpClL,QAAS,yBACTC,KAAM,8BAykBNkL,mBA9hBgC,CAChCnL,QAAS,oBACTC,KAAM,0BA6hBN8E,sBACAqG,oBA5hBiC,CACjCpL,QAAS,qBACTC,KAAM,2BA2hBNkD,iBACAZ,wBACAG,qBACAD,sBACAJ,uBACA2B,sBACA8E,qBACAC,sBACAxI,wBACAF,4BACAD,6BACA6E,iBACAqD,oBACAa,wBACAG,iBACA1B,8CACAwB,4BACAzB,6CACAd,0BACAkD,oBACAC,uBACA7E,kBACA+E,aACAC,mBACA/C,uCACAR,yBACAI,8BACAL,yBACA0E,wBAnbqC,CACrCrL,QAAS,0BACTC,KAAM,iCAkbN+H,qBACAsD,oBAxlBiC,CACjCtL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BC,GAAsB,iBACtBC,GAAuB,kBACvBC,GAAmB,cACnBC,GAAkB,aAClBC,GAAkB,aAClBC,GAAe,UACfC,GAAiB,YACjBC,GAAoB,eACpBC,GAAgB,WAEhBC,GAAsC,CACjDf,GACAG,GACAE,GACAG,GACAC,GACAE,GACAC,IAGWI,GAAwC,CACnDhB,GACAG,GACAE,GACAE,GACAD,GACAE,GACAC,GACAE,GACAC,GACAE,IAGWG,GAAuB,CAClClB,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAE,GACAD,GACAE,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,IAGWI,GAA2B,CACtCjB,GACAM,GACAD,GACAH,GACAE,GACAM,GACAG,IAGWK,GAA8B,CACzCpB,GACAC,GACAE,GACAE,GACAI,GACAC,GACAC,GACAE,GACAC,QACA,GAGWO,GAA2B,CACtClB,GACAH,GACAI,GACAC,GACAC,GACAE,GACAD,GACAK,GACAG,IAGWO,GAAwB,CACnCtB,GACAI,GACAE,GACAE,GACAD,GACAE,GACAG,GACAG,IAGWQ,GAA0B,CACrCd,GACAC,GACAG,GACAC,IAGWU,GAAyB,CAAAxB,UACpCA,GACAC,mBACAC,OAAAC,UACAA,GAAAC,UACAA,GACAC,eACAC,aACAE,mBACAD,kBAAAE,YACAA,GACAC,cACAC,cAAAC,QACAA,GACAC,aACAC,gBAAAC,SACAA,IC/HWU,GAAO,OACPC,GAAa,aACbC,GAAc,cACdC,GAAwB,wBACxBC,GAAW,WAEXC,GAAc,CACzBL,GACAC,GACAC,GACAE,GACAD,IAGWG,GAAa,CACxBL,CAACA,IAAa,EACdD,CAACA,IAAO,EACRI,CAACA,IAAW,EACZF,CAACA,IAAc,EACfC,CAACA,IAAwB,GAGdI,GAAsB,qBACtBC,GAA6B,2BAE7BC,GAAc,CACzBT,CAACA,IAAO,EACRI,CAACA,IAAW,EACZF,CAACA,IAAc,EACfD,CAACA,IAAa,EACdE,CAACA,IAAwB,GAIdO,GAAiB,CAC5BN,CAACA,IAAW,EACZJ,CAACA,IAAO,EACRE,CAACA,IAAc,EACfD,CAACA,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"}