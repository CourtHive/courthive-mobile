declare function factoryVersion(): string;

interface Tournament {
    createdAt?: Date | string;
    /**
     * Date on which the tournament ends
     */
    endDate?: string;
    events?: Event$1[];
    extensions?: Extension[];
    formalName?: string;
    hostCountryCode?: CountryCodeUnion;
    indoorOutdoor?: IndoorOutdoorUnion;
    isMock?: boolean;
    localTimeZone?: string;
    matchUps?: MatchUp[];
    notes?: string;
    onlineResources?: OnlineResource[];
    parentOrganisationId?: string;
    parentOrganisation?: Organisation;
    participants?: Participant[];
    processCodes?: string[];
    promotionalName?: string;
    registrationProfile?: RegistrationProfile;
    season?: string;
    /**
     * Date on which the tournament starts
     */
    startDate?: string;
    surfaceCategory?: SurfaceCategoryUnion;
    timeItems?: TimeItem[];
    totalPrizeMoney?: PrizeMoney[];
    tournamentCategories?: Category[];
    tournamentGroups?: string[];
    tournamentId: string;
    tournamentLevel?: TournamentLevelUnion;
    tournamentName?: string;
    tournamentOtherIds?: UnifiedTournamentID[];
    tournamentRank?: string;
    updatedAt?: Date | string;
    venues?: Venue[];
}
interface Organisation {
    onlineResources?: OnlineResource[];
    organisationAbbreviation: string;
    parentOrganisationId?: string;
    extensions?: Extension[];
    organisationName: string;
    organisationId: string;
    notes?: string;
}
interface Event$1 {
    allowedDrawTypes?: DrawTypeUnion[];
    category?: Category;
    createdAt?: Date | string;
    discipline?: DisciplineUnion;
    drawDefinitions?: DrawDefinition[];
    /**
     * Date on which the event ends
     */
    endDate?: string;
    entries?: Entry[];
    eventAbbreviation?: string;
    eventId: string;
    eventLevel?: TournamentLevelUnion;
    eventName?: string;
    eventOrder?: number;
    eventRank?: string;
    eventType?: EventTypeUnion;
    extensions?: Extension[];
    gender?: GenderUnion;
    indoorOutdoor?: IndoorOutdoorUnion;
    isMock?: boolean;
    links?: DrawLink[];
    matchUpFormat?: string;
    notes?: string;
    processCodes?: string[];
    /**
     * Date on which the event starts
     */
    startDate?: string;
    surfaceCategory?: SurfaceCategoryUnion;
    tennisOfficialIds?: string[];
    tieFormat?: TieFormat;
    tieFormatId?: string;
    tieFormats?: TieFormat[];
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    wheelchairClass?: WheelchairClassUnion;
}
declare enum DrawTypeEnum {
    AD_HOC = "AD_HOC",
    COMPASS = "COMPASS",
    CURTIS_cONSOLATION = "CURTIS_CONSOLATION",
    DOUBLE_eLIMINATION = "DOUBLE_ELIMINATION",
    FEED_IN = "FEED_IN",
    FEED_IN_CHAMPIONSHIP = "FEED_IN_CHAMPIONSHIP",
    FEED_IN_CHAMPIONSHIP_TO_QF = "FEED_IN_CHAMPIONSHIP_TO_QF",
    FEED_IN_CHAMPIONSHIP_TO_R16 = "FEED_IN_CHAMPIONSHIP_TO_R16",
    FEED_In_CHAMPIONSHIP_TO_SF = "FEED_IN_CHAMPIONSHIP_TO_SF",
    FIRST_MATCH_LOSER_CONSOLATION = "FIRST_MATCH_LOSER_CONSOLATION",
    FIRST_ROUND_LOSER_CONSOLATION = "FIRST_ROUND_LOSER_CONSOLATION",
    MODIFIED_FEED_IN_CHAMPIONSHIP = "MODIFIED_FEED_IN_CHAMPIONSHIP",
    LUCKY_DRAW = "LUCKY_DRAW",
    OLYMPIC = "OLYMPIC",
    OTHER = "OTHER",
    PLAYOFF = "PLAYOFF",
    ROUND_ROBIN = "ROUND_ROBIN",
    ROUND_ROBIN_WITH_PLAYOFF = "ROUND_ROBIN_WITH_PLAYOFF",
    SINGLE_ELIMINATION = "SINGLE_ELIMINATION"
}
type DrawTypeUnion = keyof typeof DrawTypeEnum;
interface Category {
    ageCategoryCode?: string;
    ageMax?: number;
    ageMaxDate?: string;
    ageMin?: number;
    ageMinDate?: string;
    ballType?: BallTypeUnion;
    categoryName?: string;
    categoryType?: string;
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    ratingMax?: number;
    ratingMin?: number;
    ratingType?: string;
    subType?: string;
    timeItems?: TimeItem[];
    type?: CategoryUnion;
    updatedAt?: Date | string;
}
declare enum BallTypeEnum {
    HIGH_ALTITUDE = "HIGH_ALTITUDE",
    Stage1Green = "STAGE1GREEN",
    Stage2Orange = "STAGE2ORANGE",
    Stage3Red = "STAGE3RED",
    T2STANDARD_PRESSURELESS = "T2STANDARD_PRESSURELESS",
    T2STANDARD_PRESSURISED = "T2STANDARD_PRESSURISED",
    TYPE1FAST = "TYPE1FAST",
    TYPE3SLOW = "TYPE3SLOW"
}
type BallTypeUnion = keyof typeof BallTypeEnum;
interface Extension {
    description?: string;
    name: string;
    value: any;
}
interface TimeItem {
    createdAt?: Date | string;
    itemDate?: Date | string;
    itemSubTypes?: string[];
    itemType?: string;
    itemValue?: any;
}
declare enum CategoryEnum {
    AGE = "AGE",
    BOTH = "BOTH",
    LEVEL = "LEVEL"
}
type CategoryUnion = keyof typeof CategoryEnum;
declare enum DisciplineEnum {
    BEACH_TENNIS = "BEACH_TENNIS",
    TENNIS = "TENNIS",
    WHEELCHAIR_TENNIS = "WHEELCHAIR_TENNIS"
}
type DisciplineUnion = keyof typeof DisciplineEnum;
interface DrawDefinition {
    automated?: boolean;
    createdAt?: Date | string;
    drawId: string;
    drawName?: string;
    drawOrder?: number;
    drawRepresentativeIds?: string[];
    drawStatus?: DrawStatusUnion;
    drawType?: DrawTypeUnion;
    /**
     * Date on which the draw ends
     */
    endDate?: string;
    entries?: Entry[];
    extensions?: Extension[];
    isMock?: boolean;
    links?: DrawLink[];
    matchUpFormat?: string;
    matchUps?: MatchUp[];
    matchUpType?: EventTypeUnion;
    notes?: string;
    processCodes?: string[];
    /**
     * Date on which the draw begins
     */
    startDate?: string;
    structures?: Structure[];
    tieFormat?: TieFormat;
    tieFormatId?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
declare enum DrawStatusEnum {
    COMPLETE = "COMPLETE",
    IN_PROGRESS = "IN_PROGRESS",
    TO_BE_PLAYED = "TO_BE_PLAYED"
}
type DrawStatusUnion = keyof typeof DrawStatusEnum;
interface Entry {
    createdAt?: Date | string;
    entryId?: string;
    entryPosition?: number;
    entryStage?: StageTypeUnion;
    entryStageSequence?: number;
    entryStatus?: EntryStatusUnion;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    participantId: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    scaleValue?: number;
}
declare enum StageTypeEnum {
    CONSOLATION = "CONSOLATION",
    MAIN = "MAIN",
    PLAY_OFF = "PLAY_OFF",
    QUALIFYING = "QUALIFYING",
    VOLUNTARY_CONSOLATION = "VOLUNTARY_CONSOLATION"
}
type StageTypeUnion = keyof typeof StageTypeEnum;
declare enum EntryStatusEnum {
    ALTERNATE = "ALTERNATE",
    CONFIRMED = "CONFIRMED",
    DIRECT_ACCEPTANCE = "DIRECT_ACCEPTANCE",
    FEED_IN = "FEED_IN",
    JUNIOR_EXEMPT = "JUNIOR_EXEMPT",
    LUCKY_LOSER = "LUCKY_LOSER",
    ORGANISER_ACCEPTANCE = "ORGANISER_ACCEPTANCE",
    QUALIFIER = "QUALIFIER",
    REGISTERED = "REGISTERED",
    SPECIAL_EXEMPT = "SPECIAL_EXEMPT",
    UNGROUPED = "UNGROUPED",
    UNPAIRED = "UNPAIRED",
    WILDCARD = "WILDCARD",
    WITHDRAWN = "WITHDRAWN"
}
type EntryStatusUnion = keyof typeof EntryStatusEnum;
interface DrawLink {
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    linkCondition?: string;
    linkType: LinkTypeUnion;
    notes?: string;
    source: DrawLinkSource;
    target: DrawLinkTarget;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
declare enum LinkTypeEnum {
    LOSER = "LOSER",
    POSITION = "POSITION",
    WINNER = "WINNER"
}
type LinkTypeUnion = keyof typeof LinkTypeEnum;
interface DrawLinkSource {
    createdAt?: Date | string;
    drawId?: string;
    extensions?: Extension[];
    finishingPositions?: number[];
    isMock?: boolean;
    notes?: string;
    roundNumber?: number;
    structureId: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
interface DrawLinkTarget {
    createdAt?: Date | string;
    drawId?: string;
    extensions?: Extension[];
    feedProfile: PositioningProfileUnion;
    groupedOrder?: number[];
    isMock?: boolean;
    notes?: string;
    positionInterleave?: Interleave;
    roundNumber: number;
    structureId: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
declare enum PositioningProfileEnum {
    BOTTOM_UP = "BOTTOM_UP",
    DRAW = "DRAW",
    LOSS_POSITION = "LOSS_POSITION",
    RANDOM = "RANDOM",
    TOP_DOWN = "TOP_DOWN",
    WATERFALL = "WATERFALL"
}
type PositioningProfileUnion = keyof typeof PositioningProfileEnum;
declare enum SeedingProfileEnum {
    CLUSTER = "CLUSTER",
    SEPARATE = "SEPARATE",
    WATERFALL = "WATERFALL"
}
type SeedingProfileUnion = keyof typeof SeedingProfileEnum;
interface Interleave {
    interleave: number;
    offset: number;
}
type EventTypeUnion = 'SINGLES' | 'DOUBLES' | 'TEAM';
interface MatchUp {
    collectionId?: string;
    collectionPosition?: number;
    createdAt?: Date | string;
    drawPositions?: number[];
    /**
     * Date on which the matchUp ends
     */
    endDate?: string;
    extensions?: Extension[];
    finishingPositionRange?: MatchUpFinishingPositionRange;
    finishingRound?: number;
    indoorOutdoor?: IndoorOutdoorUnion;
    isMock?: boolean;
    loserMatchUpId?: string;
    matchUpDuration?: string;
    matchUpFormat?: string;
    matchUpId: string;
    matchUpStatus?: MatchUpStatusUnion;
    matchUpStatusCodes?: any[];
    matchUpType?: EventTypeUnion;
    notes?: string;
    orderOfFinish?: number;
    processCodes?: string[];
    roundName?: string;
    roundNumber?: number;
    roundPosition?: number;
    score?: Score;
    sides?: Side[];
    /**
     * Date on which matchUp begins
     */
    startDate?: string;
    surfaceCategory?: SurfaceCategoryUnion;
    tieFormat?: TieFormat;
    tieFormatId?: string;
    tieMatchUps?: MatchUp[];
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    winnerMatchUpId?: string;
    winningSide?: number;
}
interface MatchUpFinishingPositionRange {
    loser: number[];
    winner: number[];
}
declare enum IndoorOutdoorEnum {
    INDOOR = "INDOOR",
    MIXED = "MIXED",
    OUTDOOR = "OUTDOOR"
}
type IndoorOutdoorUnion = keyof typeof IndoorOutdoorEnum;
declare enum MatchUpStatusEnum {
    ABANDONED = "ABANDONED",
    AWAITING_RESULT = "AWAITING_RESULT",
    BYE = "BYE",
    CANCELLED = "CANCELLED",
    COMPLETED = "COMPLETED",
    DEAD_RUBBER = "DEAD_RUBBER",
    DEFAULTED = "DEFAULTED",
    DOUBLE_DEFAULT = "DOUBLE_DEFAULT",
    DOUBLE_WALKOVER = "DOUBLE_WALKOVER",
    IN_PROGRESS = "IN_PROGRESS",
    INCOMPLETE = "INCOMPLETE",
    NOT_PLAYED = "NOT_PLAYED",
    RETIRED = "RETIRED",
    SUSPENDED = "SUSPENDED",
    TO_BE_PLAYED = "TO_BE_PLAYED",
    WALKOVER = "WALKOVER"
}
type MatchUpStatusUnion = keyof typeof MatchUpStatusEnum;
interface Score {
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    scoreStringSide1?: string;
    scoreStringSide2?: string;
    sets?: Set[];
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
interface Set {
    createdAt?: Date | string;
    extensions?: Extension[];
    games?: Game[];
    isMock?: boolean;
    notes?: string;
    setDuration?: string;
    setFormat?: string;
    setNumber?: number;
    side1PointScore?: number;
    side1Score?: number;
    side1TiebreakScore?: number;
    side2PointScore?: number;
    side2Score?: number;
    side2TiebreakScore?: number;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    winningSide?: number;
}
interface Game {
    createdAt?: Date | string;
    extensions?: Extension[];
    gameDuration?: string;
    gameFormat?: string;
    gameNumber?: number;
    isMock?: boolean;
    notes?: string;
    points?: Point[];
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    winningSide?: number;
    winReason?: WinReasonUnion;
}
interface Point {
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    pointDuration?: string;
    pointNumber?: number;
    shots?: Shot[];
    side1Score?: string;
    side2Score?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    winningSide?: number;
    winReason?: WinReasonUnion;
}
interface Shot {
    bounceAt?: CourtPosition;
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    participantId: string;
    shotDetail?: ShotDetailUnion;
    shotMadeFrom?: CourtPosition;
    shotNumber?: number;
    shotOutcome?: ShotOutcomeUnion;
    shotType?: ShotTypeUnion;
    sideNumber?: number;
    speed?: number;
    spin?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
interface CourtPosition {
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    positionName?: CourtPositionUnion;
    timeAtPosition?: Date | string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    x?: number;
    y?: number;
}
declare enum CourtPositionEnum {
    BaSELINE = "BASELINE",
    LEFT_SERVICE_COURT = "LEFT_SERVICE_COURT",
    NET = "NET",
    RIGHT_SERVICE_COURT = "RIGHT_SERVICE_COURT",
    SERVICELINE = "SERVICELINE"
}
type CourtPositionUnion = keyof typeof CourtPositionEnum;
declare enum ShotDetailEnum {
    DRIVE = "DRIVE",
    DRIVE_VOLLEY = "DRIVE_VOLLEY",
    DROP_SHOT = "DROP_SHOT",
    GROUND_STROKE = "GROUND_STROKE",
    HALF_VOLLEY = "HALF_VOLLEY",
    LOB = "LOB",
    PASSING_SHOT = "PASSING_SHOT",
    SMASH = "SMASH",
    TRICK = "TRICK",
    VOLLEY = "VOLLEY"
}
type ShotDetailUnion = keyof typeof ShotDetailEnum;
declare enum ShotOutcomeEnum {
    IN = "IN",
    LET = "LET",
    NET = "NET",
    OUT = "OUT"
}
type ShotOutcomeUnion = keyof typeof ShotOutcomeEnum;
declare enum ShotTypeEnum {
    BACKHAND = "BACKHAND",
    FOREHAND = "FOREHAND",
    SERVE = "SERVE"
}
type ShotTypeUnion = keyof typeof ShotTypeEnum;
declare enum WinReasonEnum {
    ACE = "ACE",
    DOUBLE_FAULT = "DOUBLE_FAULT",
    ERROR = "ERROR",
    FORCED = "FORCED",
    NETcORD = "NET_CORD",
    PENALTY = "PENALTY",
    UNFORCED = "UNFORCED",
    WINNER = "WINNER"
}
type WinReasonUnion = keyof typeof WinReasonEnum;
interface Side {
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    lineUp?: TeamCompetitor[];
    notes?: string;
    participantId?: string;
    participant?: Participant;
    sideNumber?: number;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
interface TeamCompetitor {
    collectionAssignments?: CollectionAssignment[];
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    participantId: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
interface CollectionAssignment {
    collectionId: string;
    collectionPosition: number;
}
declare enum SurfaceCategoryEnum {
    ARTIFICIAL = "ARTIFICIAL",
    CARPET = "CARPET",
    CLAY = "CLAY",
    GRASS = "GRASS",
    HARD = "HARD"
}
type SurfaceCategoryUnion = keyof typeof SurfaceCategoryEnum;
interface TieFormat {
    collectionDefinitions: CollectionDefinition[];
    collectionGroups?: CollectionGroup[];
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    tieFormatId?: string;
    tieFormatName?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    winCriteria: WinCriteria;
}
interface CollectionDefinition {
    collectionValueProfiles?: CollectionValueProfile[];
    collectionGroupNumber?: number;
    category?: Category;
    collectionId: string;
    collectionName?: string;
    collectionOrder?: number;
    collectionValue?: number;
    createdAt?: Date | string;
    extensions?: Extension[];
    gender?: GenderUnion;
    isMock?: boolean;
    matchUpCount?: number;
    matchUpFormat?: string;
    matchUpType?: EventTypeUnion;
    matchUpValue?: number;
    notes?: string;
    processCodes?: string[];
    scoreValue?: number;
    setValue?: number;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    winCriteria?: WinCriteria;
}
interface CollectionValueProfile {
    collectionPosition: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    extensions?: Extension[];
    timeItems?: TimeItem[];
    matchUpValue: number;
    isMock?: boolean;
    notes?: string;
}
declare enum GenderEnum {
    ANY = "ANY",
    FEMALE = "FEMALE",
    MALE = "MALE",
    MIXED = "MIXED"
}
type GenderUnion = keyof typeof GenderEnum;
interface WinCriteria {
    aggregateValue?: boolean;
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    valueGoal: number;
}
interface CollectionGroup {
    createdAt?: Date | string;
    extensions?: Extension[];
    groupName?: string;
    groupNumber: number;
    groupValue?: number;
    isMock?: boolean;
    notes?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    winCriteria?: WinCriteria;
}
interface Structure {
    createdAt?: Date | string;
    extensions?: Extension[];
    finishingPosition?: FinishingPositionUnion;
    isMock?: boolean;
    matchUpFormat?: string;
    matchUps?: MatchUp[];
    matchUpType?: EventTypeUnion;
    notes?: string;
    positionAssignments?: PositionAssignment[];
    processCodes?: string[];
    qualifyingRoundNumber?: number;
    roundLimit?: number;
    roundOffset?: number;
    seedAssignments?: SeedAssignment[];
    seedingProfile?: SeedingProfileUnion;
    seedLimit?: number;
    stage?: StageTypeUnion;
    stageSequence?: number;
    structureAbbreviation?: string;
    structureId: string;
    structureName?: string;
    structures?: Structure[];
    structureOrder?: number;
    structureType?: StructureTypeUnion;
    tieFormat?: TieFormat;
    tieFormatId?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
declare enum FinishingPositionEnum {
    ROUND_OUTCOME = "ROUND_OUTCOME",
    WIN_RATIO = "WIN_RATIO"
}
type FinishingPositionUnion = keyof typeof FinishingPositionEnum;
interface PositionAssignment {
    bye?: boolean;
    createdAt?: Date | string;
    drawPosition: number;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    participantId?: string;
    qualifier?: boolean;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
interface SeedAssignment {
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    participantId?: string;
    seedNumber: number;
    seedValue: number | string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
declare enum StructureTypeEnum {
    CONTAINER = "CONTAINER",
    ITEM = "ITEM"
}
type StructureTypeUnion = keyof typeof StructureTypeEnum;
declare enum TournamentLevelEnum {
    CLUB = "CLUB",
    DISTRICT = "DISTRICT",
    INTERNATIONAL = "INTERNATIONAL",
    LOCAL = "LOCAL",
    NATIONAL = "NATIONAL",
    Recreational = "RECREATIONAL",
    REGIONAL = "REGIONAL",
    ZONAL = "ZONAL"
}
type TournamentLevelUnion = keyof typeof TournamentLevelEnum;
declare enum WheelchairClassEnum {
    QUAD = "QUAD",
    STANDARD = "STANDARD"
}
type WheelchairClassUnion = keyof typeof WheelchairClassEnum;
declare enum CountryCodeEnum {
    ASM = "ASM",
    ATA = "ATA",
    Abw = "ABW",
    Afg = "AFG",
    Ago = "AGO",
    Aia = "AIA",
    Ala = "ALA",
    Alb = "ALB",
    And = "AND",
    Ant = "ANT",
    Are = "ARE",
    Arg = "ARG",
    Arm = "ARM",
    Atf = "ATF",
    Atg = "ATG",
    Aus = "AUS",
    Aut = "AUT",
    Aze = "AZE",
    Bdi = "BDI",
    Bel = "BEL",
    Ben = "BEN",
    Bfa = "BFA",
    Bgd = "BGD",
    Bgr = "BGR",
    Bhr = "BHR",
    Bhs = "BHS",
    Bih = "BIH",
    Blm = "BLM",
    Blr = "BLR",
    Blz = "BLZ",
    Bmu = "BMU",
    Bol = "BOL",
    Bra = "BRA",
    Brb = "BRB",
    Brn = "BRN",
    Btn = "BTN",
    Bvt = "BVT",
    Bwa = "BWA",
    COM = "COM",
    Caf = "CAF",
    Can = "CAN",
    Cck = "CCK",
    Cgd = "CGD",
    Che = "CHE",
    Chl = "CHL",
    Chn = "CHN",
    Civ = "CIV",
    Cmr = "CMR",
    Cod = "COD",
    Cog = "COG",
    Cok = "COK",
    Col = "COL",
    Cpv = "CPV",
    Cri = "CRI",
    Cub = "CUB",
    Cuw = "CUW",
    Cxr = "CXR",
    Cym = "CYM",
    Cyp = "CYP",
    Cze = "CZE",
    DMA = "DMA",
    DOM = "DOM",
    Deu = "DEU",
    Dji = "DJI",
    Dnk = "DNK",
    Dza = "DZA",
    Ecu = "ECU",
    Egy = "EGY",
    Eri = "ERI",
    Ese = "ESE",
    Esh = "ESH",
    Esp = "ESP",
    Eth = "ETH",
    FSM = "FSM",
    Fin = "FIN",
    Fji = "FJI",
    Flk = "FLK",
    Fra = "FRA",
    Fro = "FRO",
    Gab = "GAB",
    Gbr = "GBR",
    Geo = "GEO",
    Ggy = "GGY",
    Gha = "GHA",
    Gib = "GIB",
    Gin = "GIN",
    Glp = "GLP",
    Gmb = "GMB",
    Gnb = "GNB",
    Gnq = "GNQ",
    Grc = "GRC",
    Grd = "GRD",
    Grl = "GRL",
    Gtm = "GTM",
    Guf = "GUF",
    Gum = "GUM",
    Guy = "GUY",
    Hkg = "HKG",
    Hmd = "HMD",
    Hnd = "HND",
    Hrv = "HRV",
    Hti = "HTI",
    Hun = "HUN",
    IRQ = "IRQ",
    ISR = "ISR",
    Idn = "IDN",
    Imn = "IMN",
    Ind = "IND",
    Iot = "IOT",
    Irl = "IRL",
    Irn = "IRN",
    Isl = "ISL",
    Ita = "ITA",
    Jam = "JAM",
    Jey = "JEY",
    Jor = "JOR",
    Jpn = "JPN",
    Kaz = "KAZ",
    Ken = "KEN",
    Kgz = "KGZ",
    Khm = "KHM",
    Kir = "KIR",
    Kna = "KNA",
    Kor = "KOR",
    Kos = "KOS",
    Kwt = "KWT",
    Lao = "LAO",
    Lbn = "LBN",
    Lbr = "LBR",
    Lby = "LBY",
    Lca = "LCA",
    Lie = "LIE",
    Lka = "LKA",
    Lso = "LSO",
    Ltu = "LTU",
    Lux = "LUX",
    Lva = "LVA",
    MAC = "MAC",
    MDA = "MDA",
    MNG = "MNG",
    Maf = "MAF",
    Mar = "MAR",
    Mco = "MCO",
    Mdg = "MDG",
    Mdv = "MDV",
    Mex = "MEX",
    Mhl = "MHL",
    Mkd = "MKD",
    Mli = "MLI",
    Mlt = "MLT",
    Mmr = "MMR",
    Mne = "MNE",
    Mnp = "MNP",
    Moz = "MOZ",
    Mrt = "MRT",
    Msr = "MSR",
    Mtq = "MTQ",
    Mus = "MUS",
    Mwi = "MWI",
    Mys = "MYS",
    Myt = "MYT",
    NIC = "NIC",
    NPL = "NPL",
    Nam = "NAM",
    Ncl = "NCL",
    Ner = "NER",
    Nfk = "NFK",
    Nga = "NGA",
    Niu = "NIU",
    Nld = "NLD",
    Nmp = "NMP",
    Nor = "NOR",
    Nru = "NRU",
    Nzl = "NZL",
    Omn = "OMN",
    PNG = "PNG",
    Pak = "PAK",
    Pan = "PAN",
    Pcn = "PCN",
    Per = "PER",
    Phl = "PHL",
    Plw = "PLW",
    Pol = "POL",
    Pri = "PRI",
    Prk = "PRK",
    Prt = "PRT",
    Pry = "PRY",
    Pse = "PSE",
    Pyf = "PYF",
    Qat = "QAT",
    Reu = "REU",
    Rou = "ROU",
    Rus = "RUS",
    Rwa = "RWA",
    SDN = "SDN",
    SPM = "SPM",
    SSD = "SSD",
    Sau = "SAU",
    Sen = "SEN",
    Sgp = "SGP",
    Sgs = "SGS",
    Shn = "SHN",
    Sjm = "SJM",
    Slb = "SLB",
    Sle = "SLE",
    Slv = "SLV",
    Smr = "SMR",
    Smx = "SMX",
    Som = "SOM",
    Srb = "SRB",
    Stp = "STP",
    Sur = "SUR",
    Svk = "SVK",
    Svn = "SVN",
    Swe = "SWE",
    Swz = "SWZ",
    Syc = "SYC",
    Syr = "SYR",
    TLS = "TLS",
    Tca = "TCA",
    Tcd = "TCD",
    Tgo = "TGO",
    Tha = "THA",
    Tjk = "TJK",
    Tkl = "TKL",
    Tkm = "TKM",
    Ton = "TON",
    Tto = "TTO",
    Tun = "TUN",
    Tur = "TUR",
    Tuv = "TUV",
    Twn = "TWN",
    Tza = "TZA",
    Uga = "UGA",
    Ukr = "UKR",
    Umi = "UMI",
    Ury = "URY",
    Usa = "USA",
    Uzb = "UZB",
    Vat = "VAT",
    Vct = "VCT",
    Ven = "VEN",
    Vgb = "VGB",
    Vir = "VIR",
    Vnm = "VNM",
    Vut = "VUT",
    Wlf = "WLF",
    Wsm = "WSM",
    Yem = "YEM",
    Zaf = "ZAF",
    Zmb = "ZMB",
    Zwe = "ZWE"
}
type CountryCodeUnion = keyof typeof CountryCodeEnum;
interface OnlineResource {
    createdAt?: Date | string;
    extensions?: Extension[];
    identifier?: string;
    isMock?: boolean;
    name?: string;
    notes?: string;
    provider?: string;
    resourceSubType?: string;
    resourceType?: OnlineResourceTypeUnion;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
declare enum OnlineResourceTypeEnum {
    EMAIL = "EMAIL",
    OTHER = "OTHER",
    SOCIAl_MEDIA = "SOCIAL_MEDIA",
    URL = "URL"
}
type OnlineResourceTypeUnion = keyof typeof OnlineResourceTypeEnum;
interface Participant {
    contacts?: Contact[];
    createdAt?: Date | string;
    extensions?: Extension[];
    individualParticipantIds?: string[];
    isMock?: boolean;
    notes?: string;
    onlineResources?: OnlineResource[];
    participantId: string;
    participantName?: string;
    participantOtherName?: string;
    participantRole?: ParticipantRoleUnion;
    participantRoleResponsibilities?: string[];
    participantStatus?: ParticipantStatusUnion;
    participantType?: ParticipantTypeUnion;
    penalties?: Penalty[];
    person?: Person;
    personId?: string;
    representing?: CountryCodeUnion;
    teamId?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
interface Contact {
    createdAt?: Date | string;
    emailAddress?: string;
    extensions?: Extension[];
    fax?: string;
    isMock?: boolean;
    isPublic?: boolean;
    mobileTelephone?: string;
    name?: string;
    notes?: string;
    telephone?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
declare enum ParticipantRoleEnum {
    ADMINISTRATION = "ADMINISTRATION",
    CAPTAIN = "CAPTAIN",
    COACH = "COACH",
    COMPETITOR = "COMPETITOR",
    MEDIA = "MEDIA",
    MEDICAL = "MEDICAL",
    OFFICIAL = "OFFICIAL",
    OTHER = "OTHER",
    SECURITY = "SECURITY"
}
type ParticipantRoleUnion = keyof typeof ParticipantRoleEnum;
declare enum ParticipantStatusEnum {
    ACTIVE = "ACTIVE",
    WITHDRAWN = "WITHDRAWN"
}
type ParticipantStatusUnion = keyof typeof ParticipantStatusEnum;
declare enum ParticipantTypeEnum {
    GROUP = "GROUP",
    INDIVIDUAL = "INDIVIDUAL",
    PAIR = "PAIR",
    TEAM = "TEAM"
}
type ParticipantTypeUnion = keyof typeof ParticipantTypeEnum;
interface Penalty {
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    issuedAt?: string;
    matchUpId?: string;
    notes?: string;
    penaltyCode?: string;
    penaltyId: string;
    penaltyType: PenaltyTypeUnion;
    refereeParticipantId?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
declare enum PenaltyTypeEnum {
    BALL_ABUSE = "BALL_ABUSE",
    COACHING = "COACHING",
    DRESS_CODE_VIOLATION = "DRESS_CODE_VIOLATION",
    EQUIMENT_VIOLATION = "EQUIMENT_VIOLATION",
    FAILUIRE_TO_SIGN_IN = "FAILUIRE_TO_SIGN_IN",
    FAILURE_TO_COMPLETE = "FAILURE_TO_COMPLETE",
    INELIGIBILITY = "INELIGIBILITY",
    LEAVING_THE_COURT = "LEAVING_THE_COURT",
    NO_SHOW = "NO_SHOW",
    OTHER = "OTHER",
    PHYSICAL_ABUSE = "PHYSICAL_ABUSE",
    PROHIBITED_SUBSTANCE = "PROHIBITED_SUBSTANCE",
    PUNCTUALITY = "PUNCTUALITY",
    RACKET_ABUSE = "RACKET_ABUSE",
    REFUSAL_TO_PLAY = "REFUSAL_TO_PLAY",
    UNSPORTSMANLIKE_CONDUCT = "UNSPORTSMANLIKE_CONDUCT",
    VERBAL_ABUSE = "VERBAL_ABUSE"
}
type PenaltyTypeUnion = keyof typeof PenaltyTypeEnum;
interface Person {
    addresses?: Address[];
    biographicalInformation?: BiographicalInformation;
    birthDate?: string;
    contacts?: Contact[];
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    nationalityCode?: string;
    nativeFamilyName?: string;
    nativeGivenName?: string;
    notes?: string;
    onlineResources?: OnlineResource[];
    otherNames?: string[];
    parentOrganisationId?: string;
    passportFamilyName?: string;
    passportGivenName?: string;
    personId: string;
    personOtherIds?: UnifiedPersonID[];
    previousNames?: string[];
    sectionId?: string;
    sex?: SexUnion;
    standardFamilyName?: string;
    standardGivenName?: string;
    status?: string;
    tennisId?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    wheelchair?: boolean;
}
interface Address {
    addressLine1?: string;
    addressLine2?: string;
    addressLine3?: string;
    addressName?: string;
    addressType?: AddressTypeUnion;
    city?: string;
    countryCode?: CountryCodeUnion;
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    latitude?: string;
    longitude?: string;
    notes?: string;
    postalCode?: string;
    state?: string;
    timeItems?: TimeItem[];
    timeZone?: string;
    updatedAt?: Date | string;
}
declare enum AddressTypeEnum {
    HOME = "HOME",
    MAIL = "MAIL",
    PRIMARY = "PRIMARY",
    RESIDENTIAL = "RESIDENTIAL",
    VENUE = "VENUE",
    WORK = "WORK"
}
type AddressTypeUnion = keyof typeof AddressTypeEnum;
interface BiographicalInformation {
    ageBeganTennis?: number;
    ageTurnedPro?: number;
    birthCountryCode?: CountryCodeUnion;
    coachId?: string;
    createdAt?: Date | string;
    doublePlayingHand?: PlayingDoubleHandCodeUnion;
    extensions?: Extension[];
    height?: number;
    heightUnit?: LengthUnitUnion;
    isMock?: boolean;
    notes?: string;
    organisationIds?: string[];
    placeOfResidence?: string;
    playingHand?: PlayingHandCodeUnion;
    residenceCountryCode?: CountryCodeUnion;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    weight?: number;
    weightUnit?: WeightUnitEnum;
}
declare enum PlayingDoubleHandCodeEnum {
    BACKHAND = "BACKHAND",
    BOTH = "BOTH",
    FOREHAND = "FOREHAND",
    NONE = "NONE"
}
type PlayingDoubleHandCodeUnion = keyof typeof PlayingDoubleHandCodeEnum;
declare enum LengthUnitEnum {
    CENTIMETER = "CENTIMETER",
    METER = "METER",
    MILLIMETER = "MILLIMETER"
}
type LengthUnitUnion = keyof typeof LengthUnitEnum;
declare enum PlayingHandCodeEnum {
    AMBIDEXTROUS = "AMBIDEXTROUS",
    LEFT = "LEFT",
    RIGHT = "RIGHT"
}
type PlayingHandCodeUnion = keyof typeof PlayingHandCodeEnum;
declare enum WeightUnitEnum {
    GRAM = "GRAM",
    KILOGRAM = "KILOGRAM"
}
interface UnifiedPersonID {
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    organisationId: string;
    personId: string;
    timeItems?: TimeItem[];
    uniqueOrganisationName?: string;
    updatedAt?: Date | string;
}
declare enum SexEnum {
    FEMALE = "FEMALE",
    MALE = "MALE",
    OTHER = "OTHER"
}
type SexUnion = keyof typeof SexEnum;
interface RegistrationProfile {
    createdAt?: Date | string;
    entriesClose?: Date | string;
    entriesOpen?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    withdrawalDeadline?: Date | string;
}
interface PrizeMoney {
    amount: number;
    createdAt?: Date | string;
    currencyCode: string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
interface UnifiedTournamentID {
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    organisationId: string;
    timeItems?: TimeItem[];
    tournamentId: string;
    uniqueOrganisationName?: string;
    updatedAt?: Date | string;
}
interface Venue {
    addresses?: Address[];
    contacts?: Contact[];
    courts?: Court[];
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    onlineResources?: OnlineResource[];
    parentOrganisationId?: string;
    roles?: string[];
    subVenues?: Venue[];
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
    venueAbbreviation?: string;
    venueId: string;
    venueName?: string;
    venueOtherIds?: UnifiedVenueID[];
    venueType?: string;
}
interface Court {
    altitude?: number;
    courtDimensions?: string;
    courtId: string;
    courtName?: string;
    createdAt?: Date | string;
    dateAvailability?: Availability[];
    extensions?: Extension[];
    floodlit?: boolean;
    indoorOutdoor?: IndoorOutdoorUnion;
    isMock?: boolean;
    latitude?: string;
    longitude?: string;
    notes?: string;
    onlineResources?: OnlineResource[];
    pace?: string;
    surfaceCategory?: SurfaceCategoryUnion;
    surfacedDate?: Date | string;
    surfaceType?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
interface Availability {
    bookings?: Booking[];
    createdAt?: Date | string;
    date?: string;
    endTime?: string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    startTime?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
interface Booking {
    bookingType?: string;
    createdAt?: Date | string;
    endTime?: string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    startTime?: string;
    timeItems?: TimeItem[];
    updatedAt?: Date | string;
}
interface UnifiedVenueID {
    createdAt?: Date | string;
    extensions?: Extension[];
    isMock?: boolean;
    notes?: string;
    organisationId: string;
    timeItems?: TimeItem[];
    uniqueOrganisationName?: string;
    updatedAt?: Date | string;
    venueId: string;
}

declare const SINGLES_EVENT = "SINGLES";
declare const DOUBLES_EVENT = "DOUBLES";
declare const TEAM_EVENT = "TEAM";
declare const eventConstants: {
    AGE: string;
    BOTH: string;
    DOUBLES: string;
    DOUBLES_EVENT: string;
    RATING: string;
    SINGLES: string;
    SINGLES_EVENT: string;
    TEAM_EVENT: string;
    TEAM: string;
};

type SignedInStatusUnion = typeof SIGNED_IN | typeof SIGNED_OUT;
declare const SIGNED_OUT = "SIGNED_OUT";
declare const SIGNED_IN = "SIGNED_IN";
declare const participantTypes: {
    TEAM_PARTICIPANT: string;
    INDIVIDUAL: string;
    GROUP: string;
    TEAM: string;
    PAIR: string;
};
declare const participantConstants: {
    INDIVIDUAL: string;
    GROUP: string;
    PAIR: string;
    TEAM: string;
    SIGN_IN_STATUS: string;
    SIGNED_OUT: string;
    SIGNED_IN: string;
};

type HydratedCourt = {
    [key: string]: any;
} & Court;
type HydratedVenue = {
    [key: string]: any;
} & Venue;
type HydratedMatchUp = MatchUp & {
    [key: string | number]: any;
    sides?: HydratedSide[];
};
type HydratedParticipant = {
    individualParticipants?: HydratedParticipant[];
    [key: string | number]: any;
} & Participant;
type HydratedSide = Side & {
    participant?: HydratedParticipant;
    [key: string | number]: any;
};

type ErrorType = {
    message: string;
    info?: string;
    code: string;
};
declare const errorConditionConstants: {
    ANACHRONISM: {
        message: string;
        code: string;
    };
    CANNOT_CHANGE_WINNING_SIDE: {
        message: string;
        code: string;
    };
    CANNOT_MODIFY_TIEFORMAT: {
        message: string;
        code: string;
    };
    CANNOT_MODIFY_PARTICIPANT_TYPE: {
        message: string;
        code: string;
    };
    CANNOT_REMOVE_MAIN_STRUCTURE: {
        message: string;
        code: string;
    };
    CANNOT_REMOVE_PARTICIPANTS: {
        message: string;
        code: string;
    };
    COURT_EXISTS: {
        message: string;
        code: string;
    };
    COURT_NOT_FOUND: {
        message: string;
        code: string;
    };
    DRAW_DEFINITION_NOT_FOUND: {
        message: string;
        code: string;
    };
    DRAW_ID_EXISTS: {
        message: string;
        code: string;
    };
    DRAW_POSITION_ACTIVE: {
        message: string;
        code: string;
    };
    DRAW_POSITION_ASSIGNED: {
        message: string;
        code: string;
    };
    DRAW_POSITION_NOT_CLEARED: {
        message: string;
        code: string;
    };
    DRAW_POSITION_NOT_FOUND: {
        message: string;
        code: string;
    };
    DRAW_SIZE_MISMATCH: {
        message: string;
        code: string;
    };
    DUPLICATE_VALUE: {
        message: string;
        code: string;
    };
    ENTRY_STATUS_NOT_ALLOWED_FOR_EVENT: {
        message: string;
        code: string;
    };
    ENTRY_STATUS_NOT_ALLOWED_IN_STAGE: {
        message: string;
        code: string;
    };
    EVENT_EXISTS: {
        message: string;
        code: string;
    };
    EVENT_NOT_FOUND: {
        message: string;
        code: string;
    };
    EXISTING_DRAW_DEFINITIONS: {
        message: string;
        code: string;
    };
    EXISTING_END_TIME: {
        message: string;
        code: string;
    };
    EXISTING_FLIGHT: {
        message: string;
        code: string;
    };
    EXISTING_MATCHUP_ID: {
        message: string;
        code: string;
    };
    EXISTING_OUTCOME: {
        message: string;
        code: string;
    };
    EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT: {
        message: string;
        code: string;
    };
    EXISTING_PARTICIPANT: {
        message: string;
        code: string;
    };
    EXISTING_POLICY_TYPE: {
        message: string;
        code: string;
    };
    EXISTING_PROFILE: {
        message: string;
        code: string;
    };
    EXISTING_ROUND: {
        message: string;
        code: string;
    };
    EXISTING_STAGE: {
        message: string;
        code: string;
    };
    EXISTING_STRUCTURE: {
        message: string;
        code: string;
    };
    INCOMPATIBLE_MATCHUP_STATUS: {
        message: string;
        code: string;
    };
    INCOMPLETE_SOURCE_STRUCTURE: {
        message: string;
        code: string;
    };
    INSUFFICIENT_DRAW_POSITIONS: {
        message: string;
        code: string;
    };
    INVALID_ACTION: {
        message: string;
        code: string;
    };
    INVALID_ASSIGNMENT: {
        message: string;
        code: string;
    };
    INVALID_BOOKINGS: {
        message: string;
        code: string;
    };
    INVALID_CATEGORY: {
        message: string;
        code: string;
    };
    INVALID_COLLECTION_DEFINITION: {
        message: string;
        code: string;
    };
    INVALID_CONFIGURATION: {
        message: string;
        code: string;
    };
    INVALID_DATE_AVAILABILITY: {
        message: string;
        code: string;
    };
    INVALID_DATE: {
        message: string;
        code: string;
    };
    INVALID_DRAW_DEFINITION: {
        message: string;
        code: string;
    };
    INVALID_DRAW_POSITION_FOR_SEEDING: {
        message: string;
        code: string;
    };
    INVALID_DRAW_POSITION: {
        message: string;
        code: string;
    };
    INVALID_DRAW_SIZE: {
        message: string;
        code: string;
    };
    INVALID_END_TIME: {
        message: string;
        code: string;
    };
    INVALID_ENTRIES: {
        message: string;
        code: string;
    };
    INVALID_EVENT_TYPE: {
        message: string;
        code: string;
    };
    INVALID_GAME_SCORES: {
        message: string;
        code: string;
    };
    INVALID_GENDER: {
        message: string;
        code: string;
    };
    INVALID_MATCHUP_FORMAT: {
        message: string;
        code: string;
    };
    INVALID_MATCHUP_STATUS: {
        message: string;
        code: string;
    };
    INVALID_MATCHUP_STATUS_BYE: {
        message: string;
        code: string;
    };
    INVALID_MATCHUP: {
        message: string;
        code: string;
    };
    INVALID_OBJECT: {
        message: string;
        code: string;
    };
    INVALID_PARTICIPANT_ID: {
        message: string;
        code: string;
    };
    INVALID_PARTICIPANT_IDS: {
        message: string;
        code: string;
    };
    INVALID_PARTICIPANT_ROLE: {
        message: string;
        code: string;
    };
    INVALID_PARTICIPANT_SEEDING: {
        message: string;
        code: string;
    };
    INVALID_PARTICIPANT_TYPE: {
        message: string;
        code: string;
    };
    INVALID_PARTICIPANT: {
        message: string;
        code: string;
    };
    INVALID_POLICY_DEFINITION: {
        message: string;
        code: string;
    };
    INVALID_RECORDS: {
        message: string;
        code: string;
    };
    INVALID_SCALE_ITEM: {
        message: string;
        code: string;
    };
    INVALID_SEED_NUMBER: {
        message: string;
        code: string;
    };
    INVALID_SEED_POSITION: {
        message: string;
        code: string;
    };
    INVALID_SET_NUMBER: {
        message: string;
        code: string;
    };
    INVALID_SIDE_NUMBER: {
        message: string;
        code: string;
    };
    INVALID_SCORE: {
        message: string;
        code: string;
    };
    INVALID_STAGE: {
        message: string;
        code: string;
    };
    INVALID_START_TIME: {
        message: string;
        code: string;
    };
    INVALID_STRUCTURE: {
        message: string;
        code: string;
    };
    INVALID_STOP_TIME: {
        message: string;
        code: string;
    };
    INVALID_TIE_FORMAT: {
        message: string;
        code: string;
    };
    INVALID_TIME: {
        message: string;
        code: string;
    };
    INVALID_TIME_ITEM: {
        message: string;
        code: string;
    };
    INVALID_TOURNAMENT_DATES: {
        message: string;
        code: string;
    };
    INVALID_TOURNAMENT_RECORD: {
        message: string;
        code: string;
    };
    INVALID_VALUES: {
        message: string;
        code: string;
    };
    INVALID_WINNING_SIDE: {
        message: string;
        code: string;
    };
    MATCHUP_NOT_FOUND: {
        message: string;
        code: string;
    };
    METHOD_NOT_FOUND: {
        message: string;
        code: string;
    };
    MISSING_ASSIGNMENTS: {
        message: string;
        code: string;
    };
    MISSING_ASYNC_STATE_PROVIDER: {
        message: string;
        code: string;
    };
    MISSING_AVOIDANCE_POLICY: {
        message: string;
        code: string;
    };
    MISSING_COLLECTION_DEFINITION: {
        message: string;
        code: string;
    };
    MISSING_COURT_ID: {
        message: string;
        code: string;
    };
    MISSING_COURTS_INFO: {
        message: string;
        code: string;
    };
    MISSING_DATE_AVAILABILITY: {
        message: string;
        code: string;
    };
    MISSING_DATE: {
        message: string;
        code: string;
    };
    MISSING_DRAW_DEFINITION: {
        message: string;
        code: string;
    };
    MISSING_DRAW_ID: {
        message: string;
        code: string;
    };
    MISSING_DRAW_POSITION: {
        message: string;
        code: string;
    };
    MISSING_DRAW_POSITIONS: {
        message: string;
        code: string;
    };
    MISSING_DRAW_SIZE: {
        message: string;
        code: string;
    };
    MISSING_ENTRIES: {
        message: string;
        code: string;
    };
    MISSING_EVENT: {
        message: string;
        code: string;
    };
    MISSING_MATCHUP_FORMAT: {
        message: string;
        code: string;
    };
    MISSING_MATCHUP_ID: {
        message: string;
        code: string;
    };
    MISSING_MATCHUP_IDS: {
        message: string;
        code: string;
    };
    MISSING_MATCHUP: {
        message: string;
        code: string;
    };
    MISSING_MATCHUPS: {
        message: string;
        code: string;
    };
    MISSING_PARTICIPANT_COUNT: {
        message: string;
        code: string;
    };
    MISSING_PARTICIPANT_ID: {
        message: string;
        code: string;
    };
    MISSING_PARTICIPANT_IDS: {
        message: string;
        code: string;
    };
    MISSING_PARTICIPANT_ROLE: {
        message: string;
        code: string;
    };
    MISSING_PARTICIPANT: {
        message: string;
        code: string;
    };
    MISSING_PARTICIPANTS: {
        message: string;
        code: string;
    };
    MISSING_PENALTY_ID: {
        message: string;
        code: string;
    };
    MISSING_PENALTY_TYPE: {
        message: string;
        code: string;
    };
    MISSING_PERSON_DETAILS: {
        message: string;
        code: string;
    };
    MISSING_POLICY_ATTRIBUTES: {
        message: string;
        code: string;
    };
    MISSING_POLICY_DEFINITION: {
        message: string;
        code: string;
    };
    MISSING_POLICY_TYPE: {
        message: string;
        code: string;
    };
    MISSING_POSITION_ASSIGNMENTS: {
        message: string;
        code: string;
    };
    MISSING_ROUND_NUMBER: {
        message: string;
        code: string;
    };
    MISSING_SCHEDULE: {
        message: string;
        code: string;
    };
    MISSING_SCORING_POLICY: {
        message: string;
        code: string;
    };
    MISSING_SEED_ASSIGNMENTS: {
        message: string;
        code: string;
    };
    MISSING_SEEDCOUNT_THRESHOLDS: {
        message: string;
        code: string;
    };
    MISSING_SEEDING_POLICY: {
        message: string;
        code: string;
    };
    MISSING_SET_NUMBER: {
        message: string;
        code: string;
    };
    MISSING_SET_OBJECT: {
        message: string;
        code: string;
    };
    MISSING_SIDE_NUMBER: {
        message: string;
        code: string;
    };
    MISSING_STAGE: {
        message: string;
        code: string;
    };
    MISSING_STRUCTURE_ID: {
        message: string;
        code: string;
    };
    MISSING_STRUCTURE: {
        message: string;
        code: string;
    };
    MISSING_STRUCTURES: {
        message: string;
        code: string;
    };
    MISSING_TARGET_LINK: {
        message: string;
        code: string;
    };
    MISSING_TIE_FORMAT: {
        message: string;
        code: string;
    };
    MISSING_TIME_ITEM: {
        message: string;
        code: string;
    };
    MISSING_TIME_ITEMS: {
        message: string;
        code: string;
    };
    MISSING_TOURNAMENT_ID: {
        message: string;
        code: string;
    };
    MISSING_TOURNAMENT_RECORD: {
        message: string;
        code: string;
    };
    MISSING_TOURNAMENT_RECORDS: {
        message: string;
        code: string;
    };
    MISSING_VALUE: {
        message: string;
        code: string;
    };
    MISSING_VENUE_ID: {
        message: string;
        code: string;
    };
    MODIFICATIONS_FAILED: {
        message: string;
        code: string;
    };
    NO_CANDIDATES: {
        message: string;
        code: string;
    };
    NO_DRAW_POSITIONS_AVAILABLE_FOR_QUALIFIERS: {
        message: string;
        code: string;
    };
    NO_MODIFICATIONS_APPLIED: {
        message: string;
        code: string;
    };
    NO_STAGE_SPACE_AVAILABLE_FOR_ENTRY_STATUS: {
        message: string;
        code: string;
    };
    NO_PARTICIPANT_REMOVED: {
        message: string;
        code: string;
    };
    NO_VALID_ACTIONS: {
        message: string;
        code: string;
    };
    NO_VALID_ATTRIBUTES: {
        message: string;
        code: string;
    };
    NO_VALID_DATES: {
        message: string;
        code: string;
    };
    NOT_FOUND: {
        message: string;
        code: string;
    };
    NOT_IMPLEMENTED: {
        message: string;
        code: string;
    };
    PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE: {
        message: string;
        code: string;
    };
    PARTICIPANT_ID_EXISTS: {
        message: string;
        code: string;
    };
    PARTICIPANT_NOT_CHECKED_IN: {
        message: string;
        code: string;
    };
    PARTICIPANT_NOT_FOUND: {
        message: string;
        code: string;
    };
    PARTICIPANT_PAIR_EXISTS: {
        message: string;
        code: string;
    };
    PENALTY_NOT_FOUND: {
        message: string;
        code: string;
    };
    POLICY_NOT_ATTACHED: {
        message: string;
        code: string;
    };
    POLICY_NOT_FOUND: {
        message: string;
        code: string;
    };
    SCHEDULE_NOT_CLEARED: {
        message: string;
        code: string;
    };
    SCHEDULED_MATCHUPS: {
        message: string;
        code: string;
    };
    SCORES_PRESENT: {
        message: string;
        code: string;
    };
    SEEDSCOUNT_GREATER_THAN_DRAW_SIZE: {
        message: string;
        code: string;
    };
    STAGE_SEQUENCE_LIMIT: {
        message: string;
        code: string;
    };
    STRUCTURE_NOT_FOUND: {
        message: string;
        code: string;
    };
    TEAM_NOT_FOUND: {
        message: string;
        code: string;
    };
    UNABLE_TO_ASSIGN_COURT: {
        message: string;
        code: string;
    };
    UNLINKED_STRUCTURES: {
        message: string;
        code: string;
    };
    UNRECOGNIZED_DRAW_TYPE: {
        message: string;
        code: string;
    };
    UNRECOGNIZED_MATCHUP_FORMAT: {
        message: string;
        code: string;
    };
    UNRECOGNIZED_MATCHUP_STATUS: {
        message: string;
        code: string;
    };
    VALUE_UNCHANGED: {
        message: string;
        code: string;
    };
    VENUE_EXISTS: {
        message: string;
        code: string;
    };
};

declare const POLICY_TYPE_VOLUNTARY_CONSOLATION = "voluntaryConsolation";
declare const POLICY_TYPE_COMPETITIVE_BANDS = "competitiveBands";
declare const POLICY_TYPE_ROUND_ROBIN_TALLY = "roundRobinTally";
declare const POLICY_TYPE_POSITION_ACTIONS = "positionActions";
declare const POLICY_TYPE_MATCHUP_ACTIONS = "matchUpActions";
declare const POLICY_TYPE_RANKING_POINTS = "rankingPoints";
declare const POLICY_TYPE_ROUND_NAMING = "roundNaming";
declare const POLICY_TYPE_PARTICIPANT = "participant";
declare const POLICY_TYPE_PROGRESSION = "progression";
declare const POLICY_TYPE_SCHEDULING = "scheduling";
declare const POLICY_TYPE_AVOIDANCE = "avoidance";
declare const POLICY_TYPE_DISPLAY = "display";
declare const POLICY_TYPE_SCORING = "scoring";
declare const POLICY_TYPE_SEEDING = "seeding";
declare const POLICY_TYPE_FEED_IN = "feedIn";
declare const POLICY_TYPE_AUDIT = "audit";
declare const POLICY_TYPE_DRAWS = "draws";
type ValidPolicyTypes = typeof POLICY_TYPE_VOLUNTARY_CONSOLATION | typeof POLICY_TYPE_COMPETITIVE_BANDS | typeof POLICY_TYPE_ROUND_ROBIN_TALLY | typeof POLICY_TYPE_POSITION_ACTIONS | typeof POLICY_TYPE_MATCHUP_ACTIONS | typeof POLICY_TYPE_RANKING_POINTS | typeof POLICY_TYPE_ROUND_NAMING | typeof POLICY_TYPE_PARTICIPANT | typeof POLICY_TYPE_PROGRESSION | typeof POLICY_TYPE_SCHEDULING | typeof POLICY_TYPE_AVOIDANCE | typeof POLICY_TYPE_DISPLAY | typeof POLICY_TYPE_FEED_IN | typeof POLICY_TYPE_SCORING | typeof POLICY_TYPE_SEEDING | typeof POLICY_TYPE_AUDIT | typeof POLICY_TYPE_DRAWS;
declare const policyConstants: {
    readonly POLICY_TYPE_VOLUNTARY_CONSOLATION: "voluntaryConsolation";
    readonly POLICY_TYPE_COMPETITIVE_BANDS: "competitiveBands";
    readonly POLICY_TYPE_ROUND_ROBIN_TALLY: "roundRobinTally";
    readonly POLICY_TYPE_POSITION_ACTIONS: "positionActions";
    readonly POLICY_TYPE_MATCHUP_ACTIONS: "matchUpActions";
    readonly POLICY_TYPE_RANKING_POINTS: "rankingPoints";
    readonly POLICY_TYPE_ROUND_NAMING: "roundNaming";
    readonly POLICY_TYPE_PARTICIPANT: "participant";
    readonly POLICY_TYPE_PROGRESSION: "progression";
    readonly POLICY_TYPE_SCHEDULING: "scheduling";
    readonly POLICY_TYPE_AVOIDANCE: "avoidance";
    readonly POLICY_TYPE_DISPLAY: "display";
    readonly POLICY_TYPE_FEED_IN: "feedIn";
    readonly POLICY_TYPE_SCORING: "scoring";
    readonly POLICY_TYPE_SEEDING: "seeding";
    readonly POLICY_TYPE_AUDIT: "audit";
    readonly POLICY_TYPE_DRAWS: "draws";
};

type MappedMatchUps = {
    [key: string]: {
        matchUps: HydratedMatchUp[] | MatchUp[] | undefined;
        itemStructureIds: string[];
        structureName?: string;
    };
};
type MatchUpsMap = {
    mappedMatchUps: MappedMatchUps;
    drawMatchUps: MatchUp[];
};

type FactoryEngine = {
    [key: string]: any;
};
type TournamentRecords = {
    [key: string]: Tournament;
};
type CheckInOutParticipantArgs = {
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    matchUp?: HydratedMatchUp;
    participantId: string;
    matchUpId: string;
    event?: Event$1;
};
type ScheduleTimesResult = {
    scheduleTime: string;
};
type SeedingProfile = {
    groupSeedingThreshold?: number;
    positioning?: string;
    nonRandom?: boolean;
};
type ScaleAttributes = {
    eventType?: EventTypeUnion;
    scaleType: string;
    scaleName: string;
    accessor?: string;
};
type ScaleItem = {
    scaleDate?: string | Date;
    eventType?: EventTypeUnion;
    scaleName: string;
    scaleType: string;
    scaleValue: any;
};
type Flight = {
    manuallyAdded?: boolean;
    drawEntries: Entry[];
    flightNumber: number;
    drawName: string;
    drawId: string;
};
type FlightProfile = {
    scaleAttributes?: ScaleAttributes;
    splitMethod?: string;
    flights: Flight[];
};
type PolicyDefinitions = {
    [key in ValidPolicyTypes]?: {
        [key: string]: any;
    };
};
type QueueMethod = {
    params: {
        [key: string]: any;
    };
    method: string;
};
type RoundProfile = {
    [key: number]: {
        finishingPositionRange: MatchUpFinishingPositionRange;
        pairedDrawPositions: number[][];
        abbreviatedRoundName?: string;
        participantsCount?: number;
        drawPositions?: number[];
        inactiveRound?: boolean;
        feedRoundIndex?: number;
        inactiveCount?: number;
        finishingRound?: number;
        preFeedRound?: boolean;
        matchUpsCount: number;
        roundFactor?: number;
        feedRound?: boolean;
        roundIndex?: number;
        roundNumber: number;
        roundName?: string;
    };
};
type ParticipantFilters = {
    accessorValues?: {
        accessor: string;
        value: any;
    }[];
    participantRoleResponsibilities?: string[];
    participantRoles?: ParticipantRoleUnion[];
    participantTypes?: ParticipantTypeUnion[];
    signInStatus?: SignedInStatusUnion;
    positionedParticipants?: boolean;
    eventEntryStatuses?: string[];
    drawEntryStatuses?: string[];
    enableOrFiltering?: boolean;
    participantIds?: string[];
    genders?: GenderUnion;
    eventIds?: string[];
};
type StructureSortConfig = {
    deprioritizeCompleted?: boolean;
    mode?: {
        [key: string]: number;
    };
};
type PersonData = {
    participantExtensions?: Extension[];
    participantTimeItems?: TimeItem[];
    [key: string]: any;
};
type AddressProps = {
    postalCodesCount?: number;
    citiesCount?: number;
    statesCount?: number;
    [key: string]: any;
};
type TeamKey = {
    participantAttribute?: string;
    addParticipants?: boolean;
    personAttribute?: string;
    teamNames?: string[];
    accessor?: string;
    uuids?: string[];
};
type ScheduleAnalysis = boolean | {
    scheduledMinutesDifference: number;
};
type ParticipantsProfile = {
    participantType?: ParticipantTypeUnion;
    scaledParticipantsCount?: number;
    rankingRange?: [number, number];
    nationalityCodesCount?: number;
    scaleAllParticipants?: boolean;
    personExtensions?: Extension[];
    valuesInstanceLimit?: number;
    addressProps?: AddressProps;
    convertExtensions?: boolean;
    participantsCount?: number;
    addParticipants?: boolean;
    withScaleValues?: boolean;
    personAttribute?: string;
    consideredDate?: string;
    withGroupings?: boolean;
    personData?: PersonData;
    personIds?: string[];
    inContext?: boolean;
    category?: Category;
    withISO2?: boolean;
    withIOC?: boolean;
    teamKey?: TeamKey;
    idPrefix?: string;
    uuids?: string[];
    sex?: SexUnion;
    usePublishState?: boolean;
    withStatistics?: boolean;
    withOpponents?: boolean;
    withMatchUps?: boolean;
    withSeeding?: boolean;
    withEvents?: boolean;
    withDraws?: boolean;
    participantFilters?: ParticipantFilters;
    scheduleAnalysis?: ScheduleAnalysis;
    policyDefinitions?: PolicyDefinitions;
};
type ScheduleVisibilityFilters = {
    visibilityThreshold: string;
    eventIds?: string[];
    drawIds?: string[];
};
type ContextContent = {
    policies?: PolicyDefinitions;
};
type ContextProfile = {
    withCompetitiveness?: boolean;
    withScaleValues?: boolean;
    inferGender?: boolean;
    exclude?: string[];
};
type Counters = {
    walkoverWins: number;
    defaultWins: number;
    walkovers: number;
    defaults: number;
    losses: number;
    wins: number;
};
type ScheduleConflict = {
    priorScheduledMatchUpId: string;
    matchUpIdWithConflict: string;
};
type StructureParticipation = {
    rankingStage: StageTypeUnion;
    walkoverWinCount: number;
    defaultWinCount: number;
    stageSequence: number;
    structureId: string;
    winCount: number;
    drawId: string;
};
type MappedParticipant = {
    structureParticipation: {
        [key: string]: StructureParticipation;
    } | StructureParticipation[];
    potentialMatchUps: {
        tournamentId: string;
        matchUpId: string;
        eventId: string;
        drawId: string;
    }[];
    scheduleConflicts: {
        [key: string]: ScheduleConflict;
    };
    scheduleItems: any[];
    participant: HydratedParticipant & {
        groupParticipantIds: string[];
        pairParticipantIds: string[];
        teamParticipantIds: string[];
        groups: {
            participantRoleResponsibilities?: string[];
            participantOtherName?: string;
            participantName: string;
            participantId: string;
        }[];
        teams: {
            participantRoleResponsibilities?: string[];
            participantOtherName?: string;
            participantName: string;
            participantId: string;
            teamId: string;
        }[];
    };
    statistics: {
        [key: string]: any;
    } | any[];
    opponents: {
        [key: string]: any;
    } | any[];
    pairIdMap: {
        [key: string]: any;
    } | any[];
    matchUps: {
        [key: string]: any;
    } | any[];
    events: {
        [key: string]: any;
    } | any[];
    draws: {
        [key: string]: any;
    } | any[];
    counters: Counters & {
        [DOUBLES_EVENT]: Counters;
        [SINGLES_EVENT]: Counters;
        [TEAM_EVENT]: Counters;
    };
};
type ParticipantMap = {
    [key: string]: MappedParticipant;
};
type GetMatchUpsArgs = {
    scheduleVisibilityFilters?: ScheduleVisibilityFilters;
    tournamentAppliedPolicies?: PolicyDefinitions;
    participantsProfile?: ParticipantsProfile;
    participants?: HydratedParticipant[];
    policyDefinitions?: PolicyDefinitions;
    context?: {
        [key: string]: any;
    };
    contextFilters?: MatchUpFilters;
    matchUpFilters?: MatchUpFilters;
    contextContent?: ContextContent;
    participantMap?: ParticipantMap;
    tournamentRecord?: Tournament;
    contextProfile?: ContextProfile;
    drawDefinition?: DrawDefinition;
    afterRecoveryTimes?: boolean;
    useParticipantMap?: boolean;
    usePublishState?: boolean;
    nextMatchUps?: boolean;
    tournamentId?: string;
    publishStatus?: any;
    inContext?: boolean;
    event?: Event$1;
};
type GroupInfo = {
    [key: string]: {
        participantName: string;
        participantId: string;
    };
};
type GroupsMatchUpsResult = {
    abandonedMatchUps?: HydratedMatchUp[];
    completedMatchUps?: HydratedMatchUp[];
    upcomingMatchUps?: HydratedMatchUp[];
    pendingMatchUps?: HydratedMatchUp[];
    byeMatchUps?: HydratedMatchUp[];
    matchUpsMap?: MatchUpsMap;
    matchUpsCount?: number;
    groupInfo?: GroupInfo;
    success?: boolean;
    error?: ErrorType;
};
type MinutesMapping = {
    categoryNames: string[];
    minutes: any;
};
type ScheduleTiming = {
    matchUpRecoveryTimes: {
        [key: string]: {
            recoveryTiming: MinutesMapping[];
            matchUpFormatCodes: string[];
        };
    }[];
    matchUpAverageTimes: {
        [key: string]: {
            [key: string]: {
                averageTiming: MinutesMapping[];
                matchUpFormatCodes: string[];
            };
        };
    }[];
};
type PlayoffAttributes = {
    [key: string | number]: {
        name: string;
        abbreviation: string;
    };
};
type LineUp = TeamCompetitor[];
type Request$1 = {
    requestType: string;
    requestId: string;
    startTime: string;
    endTime: string;
    date: string;
};
type PersonRequests = {
    [key: string]: Request$1[];
};
type AddScheduleAttributeArgs = {
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    removePriorValues?: boolean;
    disableNotice?: boolean;
    matchUpId: string;
    event?: Event$1;
};
type MatchUpFilters = {
    matchUpStatuses?: MatchUpStatusUnion[];
    excludeMatchUpStatuses?: string[];
    isCollectionMatchUp?: boolean;
    matchUpFormats?: string[];
    roundPositions?: number[];
    hasWinningSide?: boolean;
    collectionIds?: string[];
    roundNumbers?: number[];
    isMatchUpTie?: boolean;
    matchUpFormat?: string;
    matchUpIds?: string[];
    roundNames?: string[];
    processContext?: boolean;
    stageSequences?: string[];
    scheduledDates?: string[];
    participantIds?: string[];
    stages?: StageTypeUnion[];
    tournamentIds?: string[];
    matchUpTypes?: string[];
    structureIds?: string[];
    scheduledDate?: string;
    readyToScore?: boolean;
    courtIds?: string[];
    eventIds?: string[];
    venueIds?: string[];
    drawIds?: string[];
    filterMatchUpTypes?: boolean;
    filterMatchUpIds?: boolean;
};

type ModifyVenueArgs = {
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
    modifications: any;
    venueId: string;
    force?: boolean;
};
declare function modifyVenue(params: ModifyVenueArgs): {
    error?: ErrorType | undefined;
    success?: boolean | undefined;
    venue?: Venue | undefined;
} | {
    error: any;
};

type ModifyCourtAvailabilityArgs = {
    venueMatchUps?: HydratedMatchUp[];
    dateAvailability: Availability[];
    tournamentRecord: Tournament;
    disableNotice?: boolean;
    courtId: string;
    force?: boolean;
};
declare function modifyCourtAvailability({ tournamentRecord, dateAvailability, disableNotice, venueMatchUps, courtId, force, }: ModifyCourtAvailabilityArgs): {
    error?: ErrorType;
    success?: boolean;
    totalMergeCount?: number;
};

type ResultType = {
    context?: {
        [key: string]: any;
    };
    stack?: string | string[];
    error?: ErrorType;
    errors?: string[];
    success?: boolean;
    valid?: boolean;
    info?: any;
};

type ModifyCourtArgs = {
    tournamentRecords?: TournamentRecords;
    venueMatchUps?: HydratedMatchUp[];
    tournamentRecord?: Tournament;
    disableNotice?: boolean;
    modifications: any;
    courtId: string;
    force?: boolean;
};
declare function modifyCourt(params: ModifyCourtArgs): any;

type EnableVenuesArgs = {
    tournamentRecords: TournamentRecords;
    enableAll?: boolean;
    venueIds: string[];
};
declare function enableVenues(params: EnableVenuesArgs): ResultType & {
    valid?: boolean | undefined;
};

declare function enableCourts(params: any): ResultType & {
    valid?: boolean | undefined;
};

type DisableVenuesArgs = {
    tournamentRecords: any;
    tournamentId?: string;
    venueIds: string[];
};
declare function disableVenues(params: DisableVenuesArgs): ResultType & {
    valid?: boolean | undefined;
};

type DisableCourtsArgs = {
    tournamentRecords: any;
    tournamentId?: string;
    courtIds: string[];
    dates?: string[];
};
declare function disableCourts(params: DisableCourtsArgs): ResultType & {
    valid?: boolean | undefined;
};

type DeleteVenueArgs = {
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
    venueId: string;
    force?: boolean;
};
declare function deleteVenue(params: DeleteVenueArgs): {
    success?: boolean;
    error?: ErrorType;
};
declare function deleteVenues({ tournamentRecord, venueIds, force }: {
    tournamentRecord: any;
    venueIds: any;
    force: any;
}): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};

type DeleteCourtArgs = {
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
    disableNotice?: boolean;
    courtId: string;
    force?: boolean;
};
declare function deleteCourt(params: DeleteCourtArgs): any;

declare function addVenue(params: any): any;

type AddCourtArgs = {
    tournamentRecord: Tournament;
    disableNotice?: boolean;
    courtId?: string;
    venueId: string;
    court?: any;
};
declare function addCourt({ tournamentRecord, disableNotice, venueId, courtId, court, }: AddCourtArgs): {
    error: {
        message: string;
        code: string;
    };
    dateAvailability?: undefined;
    info?: undefined;
    booking?: undefined;
    valid?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    dateAvailability: {
        date: any;
        startTime?: undefined;
        endTime?: undefined;
    };
    info: string;
    booking?: undefined;
    valid?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    dateAvailability: {
        startTime: any;
        date?: undefined;
        endTime?: undefined;
    };
    info: string;
    booking?: undefined;
    valid?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    dateAvailability: {
        endTime: any;
        date?: undefined;
        startTime?: undefined;
    };
    info: string;
    booking?: undefined;
    valid?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    dateAvailability: {
        startTime: any;
        endTime: any;
        date?: undefined;
    };
    info: string;
    booking?: undefined;
    valid?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    booking: {
        startTime: any;
        endTime?: undefined;
    };
    info: string;
    dateAvailability?: undefined;
    valid?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    booking: {
        endTime: any;
        startTime?: undefined;
    };
    info: string;
    dateAvailability?: undefined;
    valid?: undefined;
} | {
    court: any;
    venueId: string;
    success: boolean;
};
type ACArgs = AddCourtsArgs & {
    tournamentRecords?: {
        [key: string]: Tournament;
    };
    tournamentRecord?: Tournament;
    venueId: string;
};
declare function addCourts(params: ACArgs): (ResultType & {
    courts?: Court[] | undefined;
}) | {
    error: {
        message: string;
        code: string;
    };
} | {
    courtIds: string[];
    success: boolean;
    error?: undefined;
};
type AddCourtsArgs = {
    dateAvailability?: Availability[];
    venueAbbreviationRoot?: string;
    tournamentRecord: Tournament;
    courtNameRoot?: string;
    courtNames?: string[];
    courtTimings?: any[];
    courtsCount?: number;
    courtIds?: string[];
    startTime?: string;
    endTime?: string;
    idPrefix?: string;
    venueId: string;
    dates: string[];
};

/**
 * generate a given number of UUIDs
 *
 * @param {number} count - number of UUIDs to generate
 */
declare function UUIDS(count?: number): string[];
declare function UUID(): string;

declare function numericSort(a: any, b: any): number;

/**
 * Sorting function to arrange matchUps by stage, stageSequence, roundNumber, roundPosition (where applicable)
 * - Useful for automatically scoring all matchUps in connected draw structures
 * - Useful for visualizing the progression of drawPositions through rounds
 *
 * @param {object} a - matchUp object
 * @param {object} b - matchUp object
 *
 */
declare function matchUpSort(a: HydratedMatchUp, b: HydratedMatchUp): number;

declare function makeDeepCopy(sourceObject: any, // arbitrary JSON object; functions will be stripped.
convertExtensions?: any, // optional - all extension objects converted to attributes ._key
internalUse?: any, // disregard deepCopy being disabled within the engine - necessary for query results
removeExtensions?: any, // optional - strip all extension attributes
iteration?: number): any;

declare function isPowerOf2(n?: any): any;
declare function nearestPowerOf2(val: any): number;
declare function isNumeric(value: any): boolean;
declare function isOdd(num: any): boolean | undefined;
declare function nextPowerOf2(n?: any): any;
declare function isConvertableInteger(n: any): boolean;

declare function generateTimeCode(index?: number): string;

/**
 *
 * @param {object[]} arrayOfJSON - JSON objects array
 * @param {object} config - object which configures processing (see below)
 * @returns {string} - joined by '\r\n' or specified line separator
 *
 * config {
 *  {boolean} includeTransformAccessors, // transform accessors are included with columnAccessors
 *  {string[]} columnAccessors, // [ 'includeThis', 'andThis' ]
 *  {object} columnTransform, // e.g. { 'newColumnName': ['oldColumn1', 'oldColumn2' ]}
 *  {object} columnMap, // e.g. { 'columnName': 'newColumnName' }
 *  {object} valuesMap, // e.g. { 'columnName': { 'value1': 'mappedValue' }} // useful for mapping IDs
 *  {array} sortOrder // e.g. ['columnName1', 'columnName2'] // determine order of csv columns
 *  {object} context, // attributes which are to be added to all rows { 'columnName': 'value }
 *  {string} delimiter, // defaults to '"'
 *  {string} columnJoiner, // defaults to ',' // defines how CSV columns are joined
 *  {string} rowJoiner, // defaults to '\r\n' // defines how CSV lines are joined
 *  {string} keyJoiner, // defaults to '.' // defines how flattened column names are constructed
 * }
 *
 * NOTE: `columnTransform` mapped array elements are sensitive to order and will resolve to the first matching value
 * NOTE: `columnMap` should not contain new columnName(s) that are `columnTransform` keys
 */
declare function JSON2CSV(arrayOfJSON?: any, config?: any): string | any[] | {
    message: string;
    code: string;
};
declare function flattenJSON(obj: any, keyJoiner?: string, path?: string[]): any;

declare function definedAttributes(obj: object, ignoreFalse?: boolean, ignoreEmptyArrays?: boolean, shallow?: boolean): any;

declare function getIsoDateString(schedule: any): any;
declare function validTimeValue(value: any): boolean;
declare function DateHHMM(date: any): string;
declare function timeUTC(date?: any): number;
declare function formatDate(date?: any, separator?: string, format?: string): string;
declare function offsetDate(date: any): Date;
declare function offsetTime(date?: any): number;
declare function isDate(dateArg: any): boolean;
declare function generateDateRange(startDt?: any, endDt?: any): string[];
declare function isISODateString(dateString: any): boolean;
declare function isTimeString(timeString: any): boolean;
declare function timeStringMinutes(timeString?: any): any;
declare function extractTime(dateString: any): any;
declare function extractDate(dateString: any): any;
declare function convertTime(value: any, time24?: any, keepDate?: any): any;
declare function addDays(date: any, days?: number): string;
declare function addWeek(date: any): string;
declare function getDateByWeek(week: any, year: any, dateFormat: any, sunday?: boolean): string;
declare function timeToDate(timeString: any, date?: undefined): Date;
declare function addMinutesToTimeString(timeString?: any, minutes?: any): any;
declare function sameDay(date1: any, date2: any): boolean;

declare function createMap(objectArray: any, attribute: any): any;
declare function undefinedToNull(obj: object, shallow?: boolean): any;
declare function generateHashCode(o: any): string | undefined;

declare function constantToString(str: any): any;

declare function attributeFilter(params?: any): any;

declare function unique(arr: any): any;
declare function noNulls(arr: any): any;
declare function shuffleArray(arr: any): any;
declare function instanceCount(values: any): {
    [key: number | string]: number;
};
declare function countValues(values: any): {
    [key: number]: string[];
};
declare function groupValues(obj: any): {};
declare function randomPop(array: any): any;
declare function randomMember(arr: any): any;
declare function generateRange(start: any, end: any): any[];
declare function intersection(a: any, b: any): any[];
declare function overlap(a: any, b: any): boolean;
declare function occurrences(val: any, arr: any): any;
declare function subSort(arr: any, i: any, n: any, sortFx: any): never[];
declare function chunkArray(arr: any, chunksize: any): any;
declare function chunkSizeProfile(arr: number[], [size, ...otherSizes]: number[]): any;
declare function allNumeric(arr: any): any;
declare function noNumeric(arr: any): any;
/**
 * chunk an arbitrary array of elements by adding every Nth instance to chunksCount chunks
 *
 * e.g. given arr=[1,2,3,4,5,6,7,8,9,10,11,12]:
 *
 * chunkByNth(arr, 3)
 * [1, 4, 7, 10]
 * [2, 5, 8, 11]
 * [3, 6, 9, 12]
 * chunkByNth(arr, 4)
 * [1, 5, 9]
 * [2, 6, 10]
 * [3, 7, 11]
 * [4, 8, 12]
 *
 * When shuttle = true:
 * chunkByNth(arr, 3, true)
 * [1, 6, 7, 12]
 * [2, 5, 8, 11]
 * [3, 4, 9, 10]
 * chunkByNth(arr, 4, true)
 * [1, 8, 9]
 * [2, 7, 10]
 * [3, 6, 11]
 * [4, 5, 12]
 *
 * @param {any[]} arr - an array
 * @param {number} chunksCount - number of chunks to create
 * @param {boolean} shuttle - whether or not to "shuttle" as in the movment of a shuttle in a loom
 */
declare function chunkByNth(arr: any[], chunksCount: number, shuttle?: boolean): any;

declare function structureSort(a: Structure | undefined, b: Structure | undefined, config?: any): number;

declare function dehydrateMatchUps({ tournamentRecord }: {
    tournamentRecord: any;
}): {
    success?: boolean;
    error?: ErrorType;
};

declare function visualizeScheduledMatchUps({ scheduledMatchUps, showGlobalLog, }: {
    scheduledMatchUps: any;
    showGlobalLog: any;
}): void;

declare function setTournamentStatus({ tournamentRecord, status }: {
    tournamentRecord: any;
    status: any;
}): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};

type SetTournamentDatesArgs = {
    tournamentRecord: Tournament;
    startDate?: string;
    endDate?: string;
};
declare function setTournamentDates({ tournamentRecord, startDate, endDate, }: SetTournamentDatesArgs): {
    error: {
        message: string;
        code: string;
    };
} | {
    unscheduledMatchUpIds: any;
    success: boolean;
    error?: undefined;
};
declare function setTournamentStartDate({ tournamentRecord, startDate }: {
    tournamentRecord: any;
    startDate: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    unscheduledMatchUpIds: any;
    success: boolean;
    error?: undefined;
};
declare function setTournamentEndDate({ tournamentRecord, endDate }: {
    tournamentRecord: any;
    endDate: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    unscheduledMatchUpIds: any;
    success: boolean;
    error?: undefined;
};

declare function setTournamentName({ tournamentRecord, promotionalName, tournamentName, formalName, }: {
    tournamentRecord: any;
    promotionalName: any;
    tournamentName: any;
    formalName: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};
declare function setTournamentNotes({ tournamentRecord, notes }: {
    tournamentRecord: any;
    notes: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};
declare function setTournamentCategories({ tournamentRecord, categories }: {
    tournamentRecord: any;
    categories: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

type RemoveExtensionResult = {
    success?: boolean;
    error?: ErrorType;
    info?: any;
};
declare function removeExtension(params?: any): RemoveExtensionResult;

type AddOnlineResourceArgs = {
    onlineResource: OnlineResource;
    drawDefinition?: DrawDefinition;
    tournamentRecord: Tournament;
    organisationId?: string;
    participantId?: string;
    personId?: string;
    courtId?: string;
    venueId?: string;
    event?: Event$1;
};
declare function addOnlineResource({ tournamentRecord, onlineResource, organisationId, participantId, personId, courtId, venueId, }: AddOnlineResourceArgs): ResultType;

declare function addNotes(params?: any): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};
declare function removeNotes(params?: any): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

type AddExtensionArgs$1 = {
    tournamentRecords?: TournamentRecords;
    activeTournamentId?: string;
    creationTime?: boolean;
    tournamentId?: string;
    extension: Extension;
    discover?: boolean;
    element?: any;
};
declare function addExtension(params?: AddExtensionArgs$1): {
    success?: boolean;
    error?: ErrorType;
};

type AddTimeItemArgs = {
    removePriorValues?: boolean;
    duplicateValues?: boolean;
    creationTime?: boolean;
    timeItem: TimeItem;
    element: any;
};
declare function addTimeItem(params: AddTimeItemArgs): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};
type AddParticipantTimeItemArgs = {
    tournamentRecord: Tournament;
    removePriorValues?: boolean;
    duplicateValues?: boolean;
    creationTime?: boolean;
    participantId: string;
    timeItem: TimeItem;
};
declare function addParticipantTimeItem({ creationTime, removePriorValues, tournamentRecord, duplicateValues, participantId, timeItem, }: AddParticipantTimeItemArgs): {
    participant?: Participant | undefined;
    tournamentId?: string | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};
declare function addTournamentTimeItem(params: any): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};
declare function addEventTimeItem(params: any): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};

type AddExtensionArgs = {
    tournamentRecord?: Tournament;
    drawDefinition?: DrawDefinition;
    participantId?: string;
    creationTime?: boolean;
    extension: Extension;
    event?: Event$1;
};
declare function addTournamentExtension(params: AddExtensionArgs): {
    success?: boolean;
    error?: ErrorType;
};
declare function addDrawDefinitionExtension(params: AddExtensionArgs): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};
declare function addEventExtension(params: AddExtensionArgs): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};
declare function addParticipantExtension(params?: any): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};
declare function removeTournamentExtension(params: any): {
    success?: boolean;
    error?: ErrorType;
    info?: any;
};
declare function removeDrawDefinitionExtension(params: any): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
    info?: any;
} | {
    error: {
        message: string;
        code: string;
    };
};
declare function removeEventExtension(params: any): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
    info?: any;
} | {
    error: {
        message: string;
        code: string;
    };
};
declare function removeParticipantExtension(params?: any): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
    info?: any;
} | {
    error: {
        message: string;
        code: string;
    };
};

declare function undo({ matchUp }: {
    matchUp: any;
}): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
};

declare function redo({ matchUp }: {
    matchUp: any;
}): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
};

declare function addSet({ matchUp, set }: {
    matchUp: any;
    set: any;
}): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};

declare function addShot({ matchUp, shot }: {
    matchUp: any;
    shot: any;
}): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};

declare function addGame({ matchUp, game }: {
    matchUp: any;
    game: any;
}): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    context: {
        game: any;
    };
};

declare function addPoint({ matchUp, point }: {
    matchUp: any;
    point: any;
}): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    context?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    context: {
        point: any;
    };
};

declare function clearHistory({ matchUp }: {
    matchUp: any;
}): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
};

declare function setServingSide({ matchUp, sideNumber }: {
    matchUp: any;
    sideNumber: any;
}): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};

declare function calculateHistoryScore(params: any): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    servingSide: number;
    score: any;
    success: boolean;
    error?: undefined;
    info?: undefined;
};

type ValidateTieFormatArgs = {
    checkCollectionIds?: boolean;
    enforceCategory?: boolean;
    enforceGender?: boolean;
    gender?: GenderUnion;
    category?: Category;
    tieFormat?: any;
    event?: Event$1;
};
declare function validateTieFormat(params: ValidateTieFormatArgs): ResultType;

type validateScoreTypes = {
    existingMatchUpStatus?: string;
    matchUpStatus?: string;
    matchUpFormat?: string;
    winningSide?: number;
    score: Score;
};
declare function validateScore({ existingMatchUpStatus, matchUpFormat, matchUpStatus, winningSide, score, }: validateScoreTypes): ResultType & {
    valid?: boolean;
};

declare function tidyScore(params: any): {
    error: {
        message: string;
        code: string;
    };
    matchUpStatus?: undefined;
    modifications?: undefined;
    attributes?: undefined;
    isValid?: undefined;
    score?: undefined;
} | {
    matchUpStatus: any;
    modifications: any[];
    attributes: any;
    isValid: boolean;
    score: any;
    error?: undefined;
};

declare function reverseScore(params?: any): {
    reversedScore?: any;
    success?: boolean;
    error?: ErrorType;
};

/**
 * Calculates the number of wins per side and winningSide. When provided with `sideAdjustments`
 * will calculate prjected score and winningSide which is necessary for checking validity of score
 */
type TieMatchUpScore = {
    scoreStringSide1?: string;
    scoreStringSide2?: string;
    winningSide?: number;
    set?: any;
};
type GenerateTieMatchUpScoreArgs = {
    sideAdjustments?: [number, number];
    drawDefinition?: DrawDefinition;
    matchUpsMap?: MatchUpsMap;
    matchUp: HydratedMatchUp;
    structure?: Structure;
    tieFormat?: TieFormat;
    separator?: string;
    event?: Event$1;
};
declare function generateTieMatchUpScore(params: GenerateTieMatchUpScoreArgs): TieMatchUpScore & ResultType;

type GenerateScoreString = {
    addOutcomeString?: boolean;
    autoComplete?: boolean;
    matchUpStatus?: string;
    matchUpFormat?: string;
    winnerFirst?: boolean;
    winningSide?: number;
    reversed?: boolean;
    sets: any;
};
declare function generateScoreString(params: GenerateScoreString): string | {
    error?: ErrorType;
    info?: ErrorType | string;
};

declare function checkSetIsComplete(params: any): any;

declare function keyValueScore(params: any): {
    updated: boolean;
    info: string;
    scoreString?: undefined;
    sets?: undefined;
    winningSide?: undefined;
    matchUpStatus?: undefined;
} | {
    updated: any;
    scoreString: any;
    sets: any;
    winningSide: any;
    matchUpStatus: any;
    info: any;
};

declare function checkScoreHasValue(params: any): boolean;

declare function analyzeSet(params: any): {
    [key: string]: any;
};

declare function validateSchedulingProfile({ tournamentRecords, schedulingProfile }: {
    tournamentRecords: any;
    schedulingProfile: any;
}): any;

type SetMatchUpDailyLimitsArgs = {
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
    tournamentId: string;
    dailyLimits: any;
};
declare function setMatchUpDailyLimits(params: SetMatchUpDailyLimitsArgs): ResultType;

type ScheduleProfileRoundsArgs = {
    checkPotentialRequestConflicts?: boolean;
    tournamentRecords: TournamentRecords;
    scheduleCompletedMatchUps?: boolean;
    clearScheduleDates?: boolean;
    scheduleDates?: string[];
    periodLength?: number;
    useGarman?: boolean;
    dryRun?: boolean;
    pro?: boolean;
};
declare function scheduleProfileRounds(params: ScheduleProfileRoundsArgs): (ResultType & {
    valid?: boolean | undefined;
}) | {
    schedulingProfile?: any;
    modifications?: number | undefined;
    error?: ErrorType | undefined;
    issues?: string[] | undefined;
} | {
    schedulingProfileModifications: any;
    schedulingProfileIssues: any;
    scheduleTimesRemaining: {};
    dateSchedulingProfiles: any;
    skippedScheduleTimes: {};
    recoveryTimeDeferredMatchUpIds: {};
    dependencyDeferredMatchUpIds: {};
    matchUpScheduleTimes: {};
    overLimitMatchUpIds: {};
    scheduledMatchUpIds: {};
    noTimeMatchUpIds: {};
    requestConflicts: {};
    scheduledDates: any;
    success: boolean;
} | {
    schedulingProfileModifications: any;
    schedulingProfileIssues: any[] | undefined;
    dateSchedulingProfiles: any[];
    recoveryTimeDeferredMatchUpIds: {};
    dependencyDeferredMatchUpIds: {};
    matchUpScheduleTimes: {};
    overLimitMatchUpIds: {};
    scheduledMatchUpIds: {};
    noTimeMatchUpIds: {};
    requestConflicts: {};
    scheduledDates: any[];
    success: boolean;
} | {
    error: {
        message: string;
        code: string;
    };
};

/**
 *
 * @param {object[]} tournamentRecords - provided by competitionEngine
 * @param {string[]} matchUpIds - matchUpIds to schedule
 * @param {string[]} venueIds - venueIds of venues where dateAvailability for courts is found
 * @param {string} scheduleDate - YYYY-MM-DD string representing day on which matchUps should be scheduled
 * @param {string} startTime - 00:00 - military time string
 * @param {string} endTime - 00:00 - military time string
 *
 * @param {number} periodLength - granularity of time blocks to consider, in minutes
 * @param {number} averageMatchUpMinutes - how long the expected matchUps are expected to last, in minutes, on average
 * @param {number} recoveryMinutes - time in minutes that should be alloted for participants to recover between matches
 * @param {object} matchUpDailyLimits - { SINGLES, DOUBLES, TOTAL } - maximum number of matches allowed per participant
 * @param {boolean} checkPotentialRequestConflicts - check personRequests when person is only potentially in matchUp being scheduled
 *
 * @returns scheduledMatchUpIds, individualParticipantProfiles
 */
declare function scheduleMatchUps(params: any): (ResultType & {
    valid?: boolean | undefined;
}) | {
    requestConflicts: unknown[];
    remainingScheduleTimes: any[] | undefined;
    individualParticipantProfiles: any;
    matchUpNotBeforeTimes: any;
    participantIdsAtLimit: any;
    skippedScheduleTimes: string[];
    overLimitMatchUpIds: any;
    scheduledMatchUpIds: string[];
    noTimeMatchUpIds: any[];
    recoveryTimeDeferred: {};
    dependencyDeferred: {};
    success: boolean;
};

/**
 * Reorders an array of time-ordered matchUps by re-assigning their times
 * Assumes:
 * 1. that only the matchUps which need to be reordered are present in the matchUpContextIds array
 * 2. that either a match has moved from the bottom of the group to the top or vice-versa
 */
declare function reorderUpcomingMatchUps(params: any): {
    success: boolean;
} | ResultType;

type RemovePersonRequests = {
    tournamentRecords: TournamentRecords;
    requestType?: string;
    requestId?: string;
    personId?: string;
    date?: string;
};
declare function removePersonRequests(params: RemovePersonRequests): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
    info?: any;
};

declare function removeMatchUpCourtAssignment(params: any): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    matchUp?: HydratedMatchUp | undefined;
    structure?: Structure | undefined;
    error?: ErrorType | undefined;
} | {
    error?: ErrorType | undefined;
    success?: boolean | undefined;
};

type RemoveEventMatchUpFormatTimingArgs = {
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
    eventId: string;
    event?: Event$1;
};
declare function removeEventMatchUpFormatTiming(params: RemoveEventMatchUpFormatTimingArgs): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
    info?: any;
} | {
    error: {
        message: string;
        code: string;
    };
};

type ProConflictsArgs = {
    tournamentRecords: {
        [key: string]: Tournament;
    };
    matchUps: HydratedMatchUp[];
};
declare function proConflicts({ tournamentRecords, matchUps, }: ProConflictsArgs): {
    error: ErrorType;
    info?: any;
} | {
    courtIssues: {
        [key: string]: any;
    };
    rowIssues: {
        [key: string]: any;
    };
};

type ProAutoScheduleArgs = {
    tournamentRecords: {
        [key: string]: Tournament;
    };
    scheduleCompletedMatchUps?: boolean;
    matchUps: HydratedMatchUp[];
    scheduledDate: string;
};
declare function proAutoSchedule({ scheduleCompletedMatchUps, tournamentRecords, scheduledDate, matchUps, }: ProAutoScheduleArgs): {
    completedMatchUps?: HydratedMatchUp[] | undefined;
    dateMatchUps?: HydratedMatchUp[] | undefined;
    courtPrefix?: string | undefined;
    error?: ErrorType | undefined;
    venues?: Venue[] | undefined;
    courtsData?: any;
    rows?: any[] | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    info: string;
    error: {
        message: string;
        code: string;
    };
} | {
    scheduled: HydratedMatchUp[];
    notScheduled: HydratedMatchUp[];
    completedMatchUps?: HydratedMatchUp[] | undefined;
    dateMatchUps?: HydratedMatchUp[] | undefined;
    courtPrefix?: string | undefined;
    error?: ErrorType | undefined;
    venues?: Venue[] | undefined;
    courtsData?: any;
    rows?: any[] | undefined;
    info?: undefined;
};

declare function modifyPersonRequests(params: any): ResultType & {
    valid?: boolean | undefined;
};

declare function modifyMatchUpFormatTiming(params: any): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

type ModifyEventMatchUpFormatTimingArgs = {
    tournamentRecord: Tournament;
    recoveryMinutes?: number;
    averageMinutes?: number;
    matchUpFormat: string;
    categoryType?: string;
    tournamentId?: string;
    eventId: string;
    event?: Event$1;
};
declare function modifyEventMatchUpFormatTiming(params: ModifyEventMatchUpFormatTimingArgs): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

declare function matchUpScheduleChange(params: any): {
    success: boolean;
} | ResultType | {
    error: {
        message: string;
        code: string;
    };
};

type GetSchedulingProfileArgs = {
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
};
declare function getSchedulingProfile({ tournamentRecords, tournamentRecord, }: GetSchedulingProfileArgs): {
    schedulingProfile?: any;
    modifications?: number;
    error?: ErrorType;
    issues?: string[];
};
type SetSchedulingProfileArgs = {
    tournamentRecords: TournamentRecords;
    tournamentRecord?: Tournament;
    schedulingProfile?: any[];
};
declare function setSchedulingProfile({ tournamentRecords, tournamentRecord, schedulingProfile, }: SetSchedulingProfileArgs): any;

type GetProfileRoundsArgs = {
    tournamentRecords?: {
        [key: string]: Tournament;
    };
    tournamentRecord?: Tournament;
    schedulingProfile?: any;
    withRoundId?: boolean;
};
declare function getProfileRounds({ tournamentRecords, schedulingProfile, tournamentRecord, withRoundId, }: GetProfileRoundsArgs): {
    segmentedRounds?: {
        [key: string]: any;
    };
    profileRounds?: any[];
    error?: ErrorType;
};

declare function generateVirtualCourts(params: any): {
    error: {
        message: string;
        code: string;
    };
    courts: any;
    virtualCourts?: undefined;
    assignedBookings?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    courts?: undefined;
    virtualCourts?: undefined;
    assignedBookings?: undefined;
} | {
    virtualCourts: any[];
    assignedBookings: any[];
    error?: undefined;
    courts?: undefined;
};

type GenerateBookingsArgs = {
    tournamentRecords: {
        [key: string]: Tournament;
    };
    dateScheduledMatchUps?: HydratedMatchUp[];
    defaultRecoveryMinutes?: number;
    averageMatchUpMinutes?: number;
    matchUps?: HydratedMatchUp[];
    periodLength?: number;
    scheduleDate?: string;
    venueIds?: string[];
};
declare function generateBookings({ defaultRecoveryMinutes, averageMatchUpMinutes, dateScheduledMatchUps, tournamentRecords, venueIds, periodLength, scheduleDate, matchUps, }: GenerateBookingsArgs): {
    error: {
        message: string;
        code: string;
    };
    bookings?: undefined;
    relevantMatchUps?: undefined;
    dateScheduledMatchUps?: undefined;
} | {
    bookings: {
        recoveryMinutes: number | undefined;
        averageMinutes: number | undefined;
        periodLength: number | undefined;
        startTime: any;
        courtId: any;
        endTime: any;
        venueId: any;
    }[] | undefined;
    relevantMatchUps: HydratedMatchUp[] | undefined;
    dateScheduledMatchUps: HydratedMatchUp[] | undefined;
    error?: undefined;
};

type FindVenueArgs = {
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
    venueId: string;
};
declare function findVenue({ tournamentRecords, tournamentRecord, venueId, }: FindVenueArgs): {
    success?: boolean;
    venue?: Venue;
    error?: ErrorType;
};
declare function publicFindVenue({ convertExtensions, ...params }: {
    [x: string]: any;
    convertExtensions: any;
}): any;

type FindMatchUpFormatTiming = {
    tournamentRecords: {
        [key: string]: Tournament;
    };
    defaultRecoveryMinutes?: number;
    defaultAverageMinutes?: number;
    matchUpFormat: string;
    categoryName?: string;
    categoryType?: string;
    tournamentId: string;
    eventType?: EventTypeUnion;
    eventId?: string;
};
declare function findMatchUpFormatTiming({ defaultRecoveryMinutes, defaultAverageMinutes, tournamentRecords, matchUpFormat, categoryName, categoryType, tournamentId, eventType, eventId, }: FindMatchUpFormatTiming): {
    error: {
        message: string;
        code: string;
    };
    recoveryMinutes?: undefined;
    averageMinutes?: undefined;
    typeChangeRecoveryMinutes?: undefined;
} | {
    recoveryMinutes: any;
    averageMinutes: any;
    typeChangeRecoveryMinutes: any;
    error?: undefined;
};

declare function publicFindCourt(params: any): any;

declare function courtGridRows({ courtPrefix, minRowsCount, courtsData, }: {
    courtPrefix?: string | undefined;
    minRowsCount: any;
    courtsData: any;
}): {
    error: {
        message: string;
        code: string;
    };
    courtPrefix?: undefined;
    rows?: undefined;
} | {
    courtPrefix: string;
    rows: any[];
    error?: undefined;
};

type ClearScheduledMatchUpsArgs = {
    ignoreMatchUpStatuses?: MatchUpStatusUnion[];
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
    scheduleAttributes?: string[];
    scheduledDates: string[];
    venueIds?: string[];
};
declare function clearScheduledMatchUps(params: ClearScheduledMatchUpsArgs): ResultType & {
    clearedScheduleCount?: number;
};

declare function clearMatchUpSchedule({ scheduleAttributes, tournamentRecord, drawDefinition, matchUpId, }: {
    scheduleAttributes?: string[] | undefined;
    tournamentRecord: any;
    drawDefinition: any;
    matchUpId: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

type CalculateScheduleTimesArgs = {
    tournamentRecords: {
        [key: string]: Tournament;
    };
    calculateStartTimeFromCourts?: boolean;
    remainingScheduleTimes?: string[];
    defaultRecoveryMinutes?: number;
    averageMatchUpMinutes?: number;
    clearScheduleDates?: boolean;
    periodLength?: number;
    scheduleDate: string;
    venueIds?: string[];
    startTime?: string;
    endTime?: string;
};
declare function calculateScheduleTimes({ calculateStartTimeFromCourts, defaultRecoveryMinutes, averageMatchUpMinutes, remainingScheduleTimes, clearScheduleDates, tournamentRecords, periodLength, scheduleDate, startTime, venueIds, endTime, }: CalculateScheduleTimesArgs): {
    dateScheduledMatchUpIds?: string[];
    totalMatchUps?: number;
    scheduleTimes?: any[];
    timingProfile?: any;
    error?: ErrorType;
    venueId?: string;
};

type BulkUpdateCourtAssignmentsParams = {
    tournamentRecords: TournamentRecords;
    courtAssignments: any[];
    courtDayDate: string;
};
declare function bulkUpdateCourtAssignments(params: BulkUpdateCourtAssignmentsParams): any;

type BulkScheduleMachUpsArgs = {
    tournamentRecords?: {
        [key: string]: Tournament;
    };
    scheduleCompletedMatchUps?: boolean;
    tournamentRecord?: Tournament;
    scheduleByeMatchUps?: boolean;
    errorOnAnachronism?: boolean;
    removePriorValues?: boolean;
    checkChronology?: boolean;
    matchUpDependencies?: any;
    matchUpIds?: string[];
    matchUpDetails?: any;
    schedule?: any;
};
declare function bulkScheduleTournamentMatchUps({ scheduleCompletedMatchUps, scheduleByeMatchUps, errorOnAnachronism, checkChronology, matchUpDependencies, removePriorValues, tournamentRecords, tournamentRecord, matchUpDetails, matchUpIds, schedule, }: BulkScheduleMachUpsArgs): {
    error?: ErrorType;
    scheduled?: number;
    warnings?: any[];
};

type BulkScheduleMatchUpsArgs = {
    tournamentRecords: {
        [key: string]: Tournament;
    };
    scheduleCompletedMatchUps?: boolean;
    tournamentRecord?: Tournament;
    scheduleByeMatchUps?: boolean;
    errorOnAnachronism?: boolean;
    removePriorValues?: boolean;
    checkChronology?: boolean;
    matchUpContextIds?: any;
    matchUpIds?: string[];
    matchUpDetails: any;
    schedule?: any;
};
declare function bulkScheduleMatchUps(params: BulkScheduleMatchUpsArgs): (ResultType & {
    valid?: boolean | undefined;
}) | {
    error?: ErrorType | undefined;
    scheduled?: number | undefined;
    warnings?: any[] | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
};

type BulkRescheduleMatchUpsArgs = {
    tournamentRecords: TournamentRecords;
    tournamentRecord: Tournament;
    matchUpIds: string[];
    scheduleChange: any;
    dryRun?: boolean;
};
declare function bulkRescheduleMatchUps(params: BulkRescheduleMatchUpsArgs): ResultType & {
    allRescheduled?: boolean;
    notRescheduled?: any[];
    rescheduled?: any[];
};

type AssignMatchUpVenueArgs = {
    tournamentRecords?: {
        [key: string]: Tournament;
    };
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    removePriorValues?: boolean;
    disableNotice?: boolean;
    matchUpId: string;
    venueId?: string;
};
declare function assignMatchUpVenue({ removePriorValues, tournamentRecords, tournamentRecord, drawDefinition, disableNotice, matchUpId, venueId, }: AssignMatchUpVenueArgs): {
    success?: boolean | undefined;
    venue?: Venue | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};

type AssignMatchUpCourtArgs = {
    tournamentRecords?: {
        [key: string]: Tournament;
    };
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    removePriorValues?: boolean;
    disableNotice?: boolean;
    courtDayDate: string;
    matchUpId: string;
    courtId: string;
};
declare function assignMatchUpCourt({ removePriorValues, tournamentRecords, tournamentRecord, drawDefinition, disableNotice, courtDayDate, matchUpId, courtId, }: AssignMatchUpCourtArgs): {
    error?: ErrorType;
    success?: boolean;
};

type AllocateTeamMatchUpCourtsArgs = {
    tournamentRecords?: {
        [key: string]: Tournament;
    };
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    removePriorValues?: boolean;
    disableNotice?: boolean;
    courtDayDate?: string;
    matchUpId: string;
    courtIds: any;
};
declare function allocateTeamMatchUpCourts({ removePriorValues, tournamentRecords, tournamentRecord, drawDefinition, disableNotice, courtDayDate, matchUpId, courtIds, }: AllocateTeamMatchUpCourtsArgs): (ResultType & {
    venues?: HydratedVenue[] | undefined;
    courts?: HydratedCourt[] | undefined;
}) | {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
} | {
    matchUp?: HydratedMatchUp | undefined;
    structure?: Structure | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    context: {
        courtIds: any;
    };
};

declare function addSchedulingProfileRound({ tournamentRecords, scheduleDate, venueId, round, }: {
    tournamentRecords: any;
    scheduleDate: any;
    venueId: any;
    round: any;
}): any;

type AddPersonRequestsArgs = {
    tournamentRecords: TournamentRecords;
    requests: Request[];
    personId: string;
};
declare function addPersonRequests(params: AddPersonRequestsArgs): (ResultType & {
    valid?: boolean | undefined;
}) | {
    error: {
        message: string;
        code: string;
    };
};

type AddMatchUpScheduledTimeArgs = {
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    removePriorValues?: boolean;
    disableNotice?: boolean;
    scheduledTime?: string;
    matchUpId?: string;
    matchUp?: MatchUp;
};
declare function addMatchUpScheduledTime(params: AddMatchUpScheduledTimeArgs): any;

type AddMatchUpScheduleItemsArgs = {
    inContextMatchUps?: HydratedMatchUp[];
    drawMatchUps?: HydratedMatchUp[];
    drawDefinition: DrawDefinition;
    errorOnAnachronism?: boolean;
    removePriorValues?: boolean;
    checkChronology?: boolean;
    matchUpDependencies?: any;
    disableNotice?: boolean;
    tournamentRecords: any;
    tournamentRecord: any;
    matchUpId: string;
    schedule: any;
    event?: Event$1;
};
declare function addMatchUpScheduleItems({ errorOnAnachronism, checkChronology, matchUpDependencies, inContextMatchUps, removePriorValues, tournamentRecords, tournamentRecord, drawDefinition, disableNotice, drawMatchUps, matchUpId, schedule, event, }: AddMatchUpScheduleItemsArgs): {
    error?: ErrorType;
    success?: boolean;
    warnings?: any[];
    info?: any;
};
declare function addMatchUpScheduledDate({ scheduledDate: dateToSchedule, removePriorValues, tournamentRecord, drawDefinition, disableNotice, matchUpId, }: AddScheduleAttributeArgs & {
    scheduledDate?: string;
}): ResultType;
declare function addMatchUpCourtOrder({ removePriorValues, tournamentRecord, drawDefinition, disableNotice, courtOrder, matchUpId, }: AddScheduleAttributeArgs & {
    courtOrder?: number;
}): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};
declare function addMatchUpOfficial({ removePriorValues, tournamentRecord, drawDefinition, disableNotice, participantId, officialType, matchUpId, }: AddScheduleAttributeArgs & {
    participantId?: string;
    officialType?: string;
}): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};
declare function addMatchUpStartTime({ removePriorValues, tournamentRecord, drawDefinition, disableNotice, matchUpId, startTime, event, }: AddScheduleAttributeArgs & {
    startTime?: string;
}): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};
declare function addMatchUpEndTime({ validateTimeSeries, removePriorValues, tournamentRecord, drawDefinition, disableNotice, matchUpId, endTime, event, }: AddScheduleAttributeArgs & {
    validateTimeSeries?: boolean;
    endTime?: string;
}): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};
declare function addMatchUpStopTime({ removePriorValues, tournamentRecord, drawDefinition, disableNotice, matchUpId, stopTime, event, }: AddScheduleAttributeArgs & {
    stopTime?: string;
}): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};
declare function addMatchUpResumeTime({ removePriorValues, tournamentRecord, drawDefinition, disableNotice, resumeTime, matchUpId, event, }: AddScheduleAttributeArgs & {
    resumeTime?: string;
}): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};

type Tally = [number, number];

type StatCounters = {
    participantName: string;
    competitorIds: string[];
    participantId: string;
    matchUpStatuses: {
        [key: string]: number;
    };
    competitiveness: {
        [key: string]: Tally;
    };
    competitiveRatio?: number;
    decisiveRatio?: number;
    routineRatio?: number;
    tiebreaksRatio?: number;
    matchUpsRatio?: number;
    pointsRatio?: number;
    gamesRatio?: number;
    setsRatio?: number;
    tiebreaksRank?: number;
    matchUpsRank?: number;
    pointsRank?: number;
    gamesRank?: number;
    setsRank?: number;
    tiebreaks: Tally;
    matchUps: Tally;
    points: Tally;
    games: Tally;
    sets: Tally;
};
type GetTeamStatistics = {
    withCompetitiveProfiles?: boolean;
    opponentParticipantId?: string;
    withIndividualStats?: boolean;
    tournamentRecord: Tournament;
    matchUps?: HydratedMatchUp[];
    teamParticipantId?: string;
    withScaleValues?: boolean;
    tallyPolicy?: any;
};
type TeamStatsResults = {
    allParticipantStats?: StatCounters[];
    relevantMatchUps: HydratedMatchUp[];
    participatingTeamsCount?: number;
    opponentStats?: StatCounters;
    teamStats?: StatCounters;
    success: boolean;
};
declare function getParticipantStats({ withCompetitiveProfiles, opponentParticipantId, withIndividualStats, teamParticipantId, tournamentRecord, withScaleValues, tallyPolicy, matchUps, }: GetTeamStatistics): ResultType | TeamStatsResults;

type GetEntryStatusReportsArgs = {
    tournamentRecord: Tournament;
};
declare function getEntryStatusReports({ tournamentRecord, }: GetEntryStatusReportsArgs): {
    error: {
        message: string;
        code: string;
    };
    entryStatusReports?: undefined;
    participantEntryReports?: undefined;
    eventReports?: undefined;
    withDrawnParticipantIds?: undefined;
    tournamentEntryReport?: undefined;
} | {
    entryStatusReports: unknown[];
    participantEntryReports: unknown[];
    eventReports: unknown[];
    withDrawnParticipantIds: string[];
    tournamentEntryReport: {
        nonParticipatingEntriesCount: number;
        individualParticipantsCount: number;
        eventsCount: number;
        nonParticipatingParticipantIds: string[];
        drawDefinitionsCount: number;
        tournamentId: string;
    };
    error?: undefined;
};

type GetStructureReportsArgs = {
    tournamentRecord: Tournament;
    extensionProfiles?: any[];
    firstFlightOnly?: boolean;
};
declare function getStructureReports({ firstFlightOnly, extensionProfiles, tournamentRecord, }: GetStructureReportsArgs): {
    error: {
        message: string;
        code: string;
    };
    eventStructureReports?: undefined;
    structureReports?: undefined;
} | {
    eventStructureReports: unknown[];
    structureReports: any[] | undefined;
    error?: undefined;
};

declare function validateCategory({ category }: {
    category: any;
}): any;

type GenderValidityCheckArgs = {
    referenceGender?: GenderUnion;
    matchUpType?: string;
    gender?: GenderUnion;
};
declare function tieFormatGenderValidityCheck(params: GenderValidityCheckArgs): ResultType;

declare function getRoundRobinGroupMatchUps({ drawPositions }: {
    drawPositions: any;
}): {
    groupMatchUps: never[];
    uniqueMatchUpGroupings: any;
};
declare function drawPositionsHash(drawPositions: any): string;
declare function groupRounds({ groupSize, drawPositionOffset }: {
    groupSize: any;
    drawPositionOffset: any;
}): any[];
declare function determineRoundNumber({ rounds, hash }: {
    rounds: any;
    hash: any;
}): any;

type IsAdHocArgs = {
    drawDefinition?: DrawDefinition;
    structure?: any;
};
declare function isAdHoc({ drawDefinition, structure }: IsAdHocArgs): boolean;

type GetValidGroupSizesArgs = {
    groupSizeLimit?: number;
    drawSize: number;
};
declare function getValidGroupSizes({ drawSize, groupSizeLimit, }: GetValidGroupSizesArgs): ResultType & {
    validGroupSizes?: number[];
};

type GetSeedingThresholdsArgs = {
    roundRobinGroupsCount?: number;
    participantsCount: number;
};
declare function getSeedingThresholds({ roundRobinGroupsCount, participantsCount, }: GetSeedingThresholdsArgs): ResultType & {
    seedingThresholds?: any;
    success?: boolean;
};

type ScaleType = {
    scaleName: string;
    scaleDate: string;
    scaleValue: any;
};
type ScalesType = {
    [SINGLES_EVENT]?: ScaleType;
    [DOUBLES_EVENT]?: ScaleType;
    [TEAM_EVENT]?: ScaleType;
};
declare function getScaleValues(params: any): ResultType & {
    seedings?: ScalesType;
    rankings?: ScalesType;
    ratings?: ScalesType;
};

declare function getMatchUpContextIds({ matchUps, matchUpId }: {
    matchUps: any;
    matchUpId: any;
}): {
    error: {
        message: string;
        code: string;
    };
    matchUpId?: undefined;
    drawId?: undefined;
    eventId?: undefined;
    structureId?: undefined;
    tournamentId?: undefined;
} | {
    matchUpId: any;
    drawId: any;
    eventId: any;
    structureId: any;
    tournamentId: any;
    error?: undefined;
};

type CompareTieFormatsArgs = {
    considerations?: any;
    descendant: TieFormat;
    ancestor: TieFormat;
};
declare function compareTieFormats({ considerations, descendant, ancestor, }: CompareTieFormatsArgs): {
    different: any;
    invalid: 0 | any[];
    success: boolean;
    matchUpFormatDifferences: any;
    matchUpCountDifference: number;
    descendantDifferences: any;
    ancestorDifferences: any;
    orderDifference: boolean;
    valueDifference: number;
    nameDifference: boolean;
    descendantDesc: any;
    ancestorDesc: any;
};

type CalculateWinCriteriaArgs = {
    collectionGroups?: {
        groupValue?: number;
        groupNumber?: number;
    }[];
    collectionDefinitions?: CollectionDefinition[];
};
declare function calculateWinCriteria({ collectionDefinitions, collectionGroups, }: CalculateWinCriteriaArgs): ResultType & {
    aggregateValue?: boolean;
    valueGoal?: number;
};

type ParseArgs = {
    consideredDate?: string;
    category?: Category;
};
declare function getCategoryAgeDetails(params: ParseArgs): any;

type StructureActionsArgs = {
    drawDefinition: DrawDefinition;
    structureId: string;
};
type StructureQueryArgs = {
    drawDefinition: DrawDefinition;
    structure?: Structure;
    structureId?: string;
};
declare function isCompletedStructure(params: StructureQueryArgs): boolean;
declare function allPlayoffPositionsFilled(params: StructureActionsArgs): boolean | {
    error: {
        message: string;
        code: string;
    };
};

declare function validMatchUp(matchUp: any): boolean;
declare function validMatchUps(matchUps: any): boolean;

type ValidateLineUpArgs = {
    tieFormat?: TieFormat;
    lineUp: LineUp;
};
declare function validateLineUp({ lineUp, tieFormat }: ValidateLineUpArgs): {
    valid: boolean;
    errors: string[];
    error: {
        message: string;
        code: string;
    } | undefined;
};

type ValidateCollectionDefinitionArgs = {
    collectionDefinition: CollectionDefinition;
    referenceGender?: GenderUnion;
    referenceCategory?: Category;
    checkCollectionIds?: boolean;
    eventType?: EventTypeUnion;
    checkCategory?: boolean;
    checkGender?: boolean;
    event?: Event$1;
};
declare function validateCollectionDefinition({ checkCategory, collectionDefinition, checkCollectionIds, checkGender, referenceCategory, referenceGender, event, }: ValidateCollectionDefinitionArgs): ResultType;

declare function tournamentMatchUps(params: GetMatchUpsArgs): GroupsMatchUpsResult;

type TallyParticipantResultsArgs = {
    policyDefinitions?: PolicyDefinitions;
    generateReport?: boolean;
    matchUpFormat?: string;
    perPlayer?: number;
    subOrderMap?: any;
    matchUps: any[];
};
type TallyResultType = {
    completedTieMatchUps?: boolean;
    bracketComplete?: boolean;
    participantResults?: any;
    readableReport?: string;
    report?: string[];
    order?: any[];
};
declare function tallyParticipantResults({ policyDefinitions, generateReport, matchUpFormat, matchUps, subOrderMap, perPlayer, }: TallyParticipantResultsArgs): TallyResultType & ResultType;

type PositionActionsArgs = {
    inContextDrawMatchUps?: HydratedMatchUp[];
    restrictAdHocRoundParticipants?: boolean;
    tournamentParticipants?: Participant[];
    policyDefinitions?: PolicyDefinitions;
    provisionalPositioning?: boolean;
    tournamentRecord?: Tournament;
    returnParticipants?: boolean;
    drawDefinition: DrawDefinition;
    matchUpsMap?: MatchUpsMap;
    drawPosition: number;
    structureId: string;
    matchUpId?: string;
    event?: Event$1;
};
/**
 * Calculates the valid actions for a draw position based on the provided parameters.
 *
 * @param params - The parameters for calculating the position actions.
 * @returns An object containing the valid actions for the draw position.
 */
declare function positionActions(params: PositionActionsArgs): ResultType & {
    isActiveDrawPosition?: boolean;
    hasPositionAssigned?: boolean;
    isDrawPosition?: boolean;
    isByePosition?: boolean;
    validActions?: any[];
};

/**
 * Retrieves the scheduled matchUps for participants.
 *
 * @param {Object} options - The options for retrieving scheduled match-ups.
 * @param {string[]} options.scheduleAttributes - The attributes to include in the schedule.
 * @param {HydratedMatchUp[]} options.matchUps - The match-ups to filter and sort.
 *
 * @returns {Object} - The scheduled match-ups organized by scheduled date and sorted by scheduled time.
 * @property {Object} scheduledMatchUps - The scheduled match-ups organized by scheduled date and sorted by scheduled time.
 * @property {string[]} scheduledMatchUps[date] - The match-ups scheduled for the specified date.
 */
type ParticiapntScheduledMatchUps = {
    scheduleAttributes?: string[];
    matchUps?: HydratedMatchUp[];
};
declare function participantScheduledMatchUps({ scheduleAttributes, matchUps, }: ParticiapntScheduledMatchUps): {
    error: {
        message: string;
        code: string;
    };
} | {
    scheduledMatchUps: {};
    success: boolean;
    error?: undefined;
};

interface ParticipantScaleItemArgs {
    scaleAttributes: ScaleAttributes;
    requireTimeStamp?: boolean;
    participant: Participant;
}
declare function participantScaleItem({ requireTimeStamp, scaleAttributes, participant, }: ParticipantScaleItemArgs): ResultType & {
    scaleItem?: ScaleItem;
};

type MatchUpActionsArgs = {
    inContextDrawMatchUps?: HydratedMatchUp[];
    restrictAdHocRoundParticipants?: boolean;
    tournamentParticipants?: Participant[];
    tournamentRecords?: TournamentRecords;
    policyDefinitions?: PolicyDefinitions;
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    matchUpsMap?: MatchUpsMap;
    enforceGender?: boolean;
    participantId?: string;
    tournamentId?: string;
    sideNumber?: number;
    matchUpId?: string;
    eventId?: string;
    drawId?: string;
    event?: Event$1;
};
declare function matchUpActions(params?: MatchUpActionsArgs): ResultType & {
    structureIsComplete?: boolean;
    isDoubleExit?: boolean;
    isByeMatchUp?: boolean;
    validActions?: any[];
};

declare function isValidForQualifying({ structureId, drawDefinition }: {
    structureId: any;
    drawDefinition: any;
}): {
    error: {
        message: string;
        code: string;
    };
    links?: undefined;
} | {
    valid: boolean;
    success: boolean;
};

type GetVenueReportArgs = {
    tournamentRecords: TournamentRecords;
    ignoreDisabled?: boolean;
    tournamentId?: string;
    venueIds?: string[];
    dates?: string[];
};
declare function getVenuesReport({ ignoreDisabled, tournamentRecords, tournamentId, venueIds, dates, }: GetVenueReportArgs): (ResultType & {
    venues?: HydratedVenue[] | undefined;
    courts?: HydratedCourt[] | undefined;
}) | {
    error: {
        message: string;
        code: string;
    };
    dates: never;
    venueIds?: undefined;
    venuesReport?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    venueIds: never;
    dates?: undefined;
    venuesReport?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    dates?: undefined;
    venueIds?: undefined;
    venuesReport?: undefined;
} | {
    venuesReport: {
        venueId: any;
        venueName: any;
        venueReport: {};
    }[] | undefined;
    error?: undefined;
    dates?: undefined;
    venueIds?: undefined;
};

declare function getTournamentPersons({ tournamentRecord, participantFilters }: {
    tournamentRecord: any;
    participantFilters: any;
}): {
    error: {
        message: string;
        code: string;
    };
    tournamentPersons?: undefined;
} | {
    tournamentPersons: unknown[];
    error?: undefined;
};

type GetTournamentPenaltiesArgs = {
    tournamentRecord: Tournament;
};
declare function getTournamentPenalties({ tournamentRecord, }: GetTournamentPenaltiesArgs): {
    error?: ErrorType;
    penalties?: Penalty[];
};

declare function getTournamentInfo({ tournamentRecord }: {
    tournamentRecord: any;
}): {
    tournamentInfo?: any;
    error?: ErrorType;
};

declare function getTournamentIds({ tournamentRecords }: {
    tournamentRecords: any;
}): {
    success: boolean;
    tournamentIds: string[];
};

type GetTieFormatArgs = {
    tournamentRecord: Tournament;
    drawDefinition?: DrawDefinition;
    structure?: Structure;
    structureId?: string;
    matchUpId: string;
    eventId?: string;
    drawId?: string;
    event?: Event$1;
};
declare function getTieFormat({ tournamentRecord, // passed in automatically by tournamentEngine
drawDefinition, // passed in automatically by tournamentEngine when drawId provided
structureId, // optional - if only the default matchUpFormat for a structure is required
matchUpId, // id of matchUp for which the scoped matchUpFormat(s) are desired
structure, // optional optimization - when structure already known
eventId, // optional - if only the default matchUpFormat for an event is required
drawId, // avoid brute force search for matchUp
event, }: GetTieFormatArgs): {
    structureDefaultTieFormat?: TieFormat;
    eventDefaultTieFormat?: TieFormat;
    drawDefaultTieFormat?: TieFormat;
    tieFormat?: TieFormat;
    structure?: Structure;
    error?: ErrorType;
    success?: boolean;
    matchUp?: MatchUp;
};

declare function getTeamLineUp({ drawDefinition, participantId }: {
    drawDefinition: any;
    participantId: any;
}): {
    error: {
        message: string;
        code: string;
    };
    lineUp?: undefined;
} | {
    lineUp: any;
    error?: undefined;
};

type GetStructureSeedAssignmentsArgs = {
    provisionalPositioning?: boolean;
    drawDefinition?: DrawDefinition;
    returnAllProxies?: boolean;
    structure?: Structure;
    structureId?: string;
};
declare function getStructureSeedAssignments({ provisionalPositioning, returnAllProxies, drawDefinition, structureId, structure, }: GetStructureSeedAssignmentsArgs): {
    seedAssignments?: SeedAssignment[];
    stageSequence?: number;
    stage?: StageTypeUnion;
    seedLimit?: number;
    error?: ErrorType;
};

type GetSeedsCountArgs = {
    policyDefinitions?: PolicyDefinitions;
    requireParticipantCount?: boolean;
    drawSizeProgression?: boolean;
    tournamentRecord?: Tournament;
    drawDefinition?: DrawDefinition;
    participantsCount?: number;
    participantCount?: number;
    drawSize?: any;
    event?: Event$1;
};
declare function getSeedsCount(params: GetSeedsCountArgs): ResultType & {
    seedsCount?: number;
};

type GetSchedulingProfileIssuesArgs = {
    tournamentRecords: TournamentRecords;
    scheduleDates?: string[];
    periodLength?: number;
};
declare function getSchedulingProfileIssues(params?: GetSchedulingProfileIssuesArgs): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    issues: any[];
    error?: undefined;
} | {
    success: boolean;
    issuesCount: number;
    profileIssues: {
        matchUpIdShouldBeAfter: any;
    };
    roundIndexShouldBeAfter: {};
    error?: undefined;
};

/**
 *
 * @param {object} tournamentRecords - passed in automatically by competitionEngine
 * @param {string[]} containedStructureIds - optional optimization - otherwise created internally
 * @param {integer} periodLength - optional - defaults to 30
 * @param {object[]} matchUps - optional optimization - otherwise created internally
 * @param {object[]} rounds - array of ordered rounds specified as part of a schedulingProfile
 * @returns
 */
type GetScheduledRoundsDetailsArgs = {
    tournamentRecords: {
        [key: string]: Tournament;
    };
    scheduleCompletedMatchUps?: boolean;
    containedStructureIds?: string[];
    matchUps?: HydratedMatchUp[];
    periodLength?: number;
    rounds: any[];
};
type RoundsDetailsResult = {
    greatestAverageMinutes?: number;
    scheduledRoundsDetails?: any[];
    orderedMatchUpIds?: string[];
    matchUpFormatCohorts?: any;
    recoveryMinutesMap?: any;
    averageMinutesMap?: any;
    error?: ErrorType;
    success?: boolean;
    minutesMap?: any;
    info?: string;
};
declare function getScheduledRoundsDetails({ scheduleCompletedMatchUps, containedStructureIds, // optional to support calling method outside of scheduleProfileRounds
tournamentRecords, periodLength, matchUps, // optional to support calling method outside of scheduleProfileRounds
rounds, }: GetScheduledRoundsDetailsArgs): RoundsDetailsResult;

/**
 *
 * @param {object} tournamentRecord - passed in automatically by tournamentEngine
 * @param {object} event - OPTIONAL - will be passed in automatically if tournamentEngine is passed drawId or eventId
 * @param {object} entries - OPTIONAL - provide entries rather than using event.entries
 * @param {string} stage - OPTIONAL - filters entries matching stage, if present
 * @param {object} scaleAttributes - { scaleName, scaleType, eventType }
 * @param {function} scaleSortMethod - OPTIONAL - function(a, b) {} - custom sorting function
 * @param {boolean} sortDescending - OPTIONL - default sorting method is ASCENDING; only applies to default sorting method
 */
type GetScaledEntriesArgs = {
    scaleAttributes: ScaleAttributes;
    tournamentRecord: Tournament;
    sortDescending?: boolean;
    stageSequence?: number;
    scaleSortMethod?: any;
    entries?: Entry[];
    stage?: string;
    event?: Event$1;
};
declare function getScaledEntries({ sortDescending, tournamentRecord, scaleAttributes, scaleSortMethod, stageSequence, entries, event, stage, }: GetScaledEntriesArgs): {
    error?: ErrorType;
    scaledEntries?: any[];
};

type GetRoundsArgs = {
    tournamentRecords?: {
        [key: string]: Tournament;
    };
    excludeScheduleDateProfileRounds?: string;
    inContextMatchUps?: HydratedMatchUp[];
    excludeScheduledRounds?: boolean;
    excludeCompletedRounds?: boolean;
    context?: {
        [key: string]: any;
    };
    matchUpFilters?: MatchUpFilters;
    tournamentRecord?: Tournament;
    withSplitRounds?: boolean;
    schedulingProfile?: any;
    scheduleDate?: string;
    withRoundId?: boolean;
    venueId?: string;
};
declare function getRounds({ excludeScheduleDateProfileRounds, excludeScheduledRounds, excludeCompletedRounds, inContextMatchUps, tournamentRecords, schedulingProfile, tournamentRecord, withSplitRounds, matchUpFilters, scheduleDate, withRoundId, venueId, context, }: GetRoundsArgs): {
    error: {
        message: string;
        code: string;
    };
    inContextMatchUps: HydratedMatchUp[];
} | {
    error: {
        message: string;
        code: string;
    };
    inContextMatchUps?: undefined;
} | {
    rounds: any[];
    excludedRounds: any[];
    success: boolean;
    error?: undefined;
    inContextMatchUps?: undefined;
};

type GetRoundMatchUpsArgs = {
    matchUps?: HydratedMatchUp[];
    interpolate?: boolean;
};
type RoundMatchUpsResult = {
    roundMatchUps?: {
        [roundNumber: number]: HydratedMatchUp[];
    };
    hasNoRoundPositions?: boolean;
    roundsNotPowerOf2?: boolean;
    maxMatchUpsCount?: number;
    roundProfile?: RoundProfile;
    roundNumbers?: number[];
    error?: ErrorType;
};
declare function getRoundMatchUps({ matchUps, interpolate }: GetRoundMatchUpsArgs): RoundMatchUpsResult;

type getPredictiveAccuracyArgs = {
    exclusionRule?: {
        valueAccessor: string;
        range: [number, number];
    };
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    matchUps?: HydratedMatchUp[];
    singlesForDoubles?: boolean;
    valueAccessor?: string;
    excludeMargin?: number;
    zoneDoubling?: boolean;
    matchUpType: EventTypeUnion;
    zoneMargin?: number;
    ascending?: boolean;
    scaleName: string;
    eventId?: string;
    zonePct?: number;
    drawId?: string;
    event?: Event$1;
};
declare function getPredictiveAccuracy(params: getPredictiveAccuracyArgs): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
    context?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: {
        matchUpType: EventTypeUnion;
    };
    context?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    context: {
        matchUps: HydratedMatchUp[];
    };
    info?: undefined;
} | {
    relevantMatchUps: HydratedMatchUp[];
    zoneDistribution: any;
    zoneData: {
        competitiveness: any;
        valuesGap: number;
        score: Score | undefined;
    }[];
    accuracy: any;
    nonZone: number;
    success: boolean;
    error?: undefined;
    info?: undefined;
    context?: undefined;
};

type GetPositionAssignmentsArgs = {
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    structure?: Structure;
    structureId?: string;
    stage?: string;
};
declare function getPositionAssignments({ tournamentRecord, drawDefinition, stage, structureId, structure, }: GetPositionAssignmentsArgs): {
    error: {
        message: string;
        code: string;
    };
    positionAssignments?: undefined;
    structureId?: undefined;
} | {
    positionAssignments: PositionAssignment[];
    structureId: string | undefined;
    error: ErrorType | undefined;
};

type GetPersonRequestsArgs = {
    tournamentRecords: {
        [key: string]: Tournament;
    };
    requestType?: string;
};
declare function getPersonRequests(params: GetPersonRequestsArgs): {
    personRequests?: PersonRequests;
    error?: ErrorType;
};

declare function getParticipantSignInStatus({ tournamentRecord, participantId, }: {
    tournamentRecord: any;
    participantId: any;
}): false | "SIGNED_IN" | {
    error: {
        message: string;
        code: string;
    };
} | undefined;

type GetParticipantSchedulesArgs = {
    tournamentRecord: Tournament;
    participantFilters?: any;
};
declare function getParticipantSchedules({ participantFilters, tournamentRecord, }: GetParticipantSchedulesArgs): {
    error: {
        message: string;
        code: string;
    };
    context?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    context: {
        participantFilters: any;
    };
} | {
    success: boolean;
    participantSchedules: any[];
    error?: undefined;
    context?: undefined;
};

type GetParticipantScaleItemArgs = {
    tournamentRecords?: TournamentRecords;
    scaleAttributes: ScaleAttributes;
    tournamentRecord?: Tournament;
    participantId: string;
};
declare function getParticipantScaleItem(params: GetParticipantScaleItemArgs): {
    tournamentId?: string;
    scaleItem?: ScaleItem;
    error?: ErrorType;
};

type GetParticipantsArgs = {
    withIndividualParticipants?: boolean | {
        [key: string]: any;
    };
    participantFilters?: ParticipantFilters;
    scheduleAnalysis?: ScheduleAnalysis;
    policyDefinitions?: PolicyDefinitions;
    withPotentialMatchUps?: boolean;
    contextProfile?: ContextProfile;
    tournamentRecord: Tournament;
    withRankingProfile?: boolean;
    convertExtensions?: boolean;
    withScheduleItems?: boolean;
    withSignInStatus?: boolean;
    withTeamMatchUps?: boolean;
    withScaleValues?: boolean;
    usePublishState?: boolean;
    withStatistics?: boolean;
    withOpponents?: boolean;
    withMatchUps?: boolean;
    internalUse?: boolean;
    withSeeding?: boolean;
    withEvents?: boolean;
    withDraws?: boolean;
    withISO2?: boolean;
    withIOC?: boolean;
};
declare function getParticipants(params: GetParticipantsArgs): {
    eventsPublishStatuses?: {
        [key: string]: any;
    };
    participantIdsWithConflicts?: string[];
    participants?: HydratedParticipant[];
    participantMap?: ParticipantMap;
    derivedEventInfo?: any;
    derivedDrawInfo?: any;
    matchUps?: MatchUp[];
    mappedMatchUps?: any;
    error?: ErrorType;
    success?: boolean;
};

type GetMembershipArgs = {
    tournamentRecord: Tournament;
    participantId: string;
};
declare function getParticipantMembership({ tournamentRecord, participantId, }: GetMembershipArgs): ResultType | {
    [key: string]: string[];
};

type GetParticipantIdFinishingPositionsArgs = {
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    byeAdvancements?: boolean;
};
declare function getParticipantIdFinishingPositions({ byeAdvancements, tournamentRecord, drawDefinition, }: GetParticipantIdFinishingPositionsArgs): any;

/**
 * Returns { eventDetails: { eventName, eventId }} for events in which participantId or TEAM/PAIR including participantId appears
 */
type getParticipantEventDetailsType = {
    tournamentRecord: Tournament;
    participantId: string;
};
declare function getParticipantEventDetails({ tournamentRecord, participantId, }: getParticipantEventDetailsType): ResultType & {
    eventDetails?: {
        eventName?: string;
        eventId: string;
    }[];
};

type GetPairedParticipantArgs = {
    tournamentParticipants?: any[];
    tournamentRecord?: Tournament;
    participantIds: string[];
};
declare function getPairedParticipant({ tournamentParticipants, tournamentRecord, participantIds, }: GetPairedParticipantArgs): {
    duplicatedPairParticipants?: any[];
    participant?: Participant;
    error?: ErrorType;
    success?: boolean;
};

type GetModifiedMatchUpFormatTimingArgs = {
    tournamentRecord: Tournament;
    matchUpFormat: string;
    event: Event$1;
};
declare function getModifiedMatchUpFormatTiming(params: GetModifiedMatchUpFormatTimingArgs): ResultType & {
    matchUpFormat?: string;
    recoveryTimes?: any[];
    averageTimes?: any[];
};

declare function getMaxEntryPosition(params: any): number;

declare function getMatchUpType(params: {
    matchUp: {
        sides?: {
            participant?: {
                participantType?: string;
            };
        }[];
        matchUpType?: string;
    };
}): ResultType & {
    matchUpType?: string;
};

declare function getMatchUpsStats({ profileBands, tournamentRecord, matchUps }: {
    profileBands: any;
    tournamentRecord: any;
    matchUps: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    competitiveBands: any;
    error?: undefined;
};

type GetMatchUpScheduleDetailsArgs = {
    scheduleVisibilityFilters?: ScheduleVisibilityFilters;
    scheduleTiming?: ScheduleTiming;
    tournamentRecord?: Tournament;
    matchUpType?: EventTypeUnion;
    afterRecoveryTimes?: boolean;
    usePublishState?: boolean;
    matchUp: HydratedMatchUp;
    matchUpFormat?: string;
    publishStatus?: any;
    event?: Event$1;
};
declare function getMatchUpScheduleDetails(params: GetMatchUpScheduleDetailsArgs): {
    error: {
        message: string;
        code: string;
    };
    schedule?: undefined;
    endDate?: undefined;
} | {
    schedule: any;
    endDate: any;
    error?: undefined;
};

declare function getMatchUpFormatTimingUpdate({ tournamentRecords }: {
    tournamentRecords: any;
}): {
    error?: ErrorType | undefined;
} | {
    methods: QueueMethod[];
};

type GetMatchUpFormatTimingArgs = {
    defaultRecoveryMinutes?: number;
    defaultAverageMinutes?: number;
    tournamentRecord: Tournament;
    matchUpFormat: string;
    categoryName?: string;
    categoryType?: string;
    eventType?: EventTypeUnion;
    event?: Event$1;
};
declare function getMatchUpFormatTiming({ defaultAverageMinutes, defaultRecoveryMinutes, tournamentRecord, matchUpFormat, categoryName, categoryType, eventType, event, }: GetMatchUpFormatTimingArgs): (ResultType & {
    typeChangeRecoveryMinutes?: number | undefined;
    recoveryMinutes?: number | undefined;
    averageMinutes?: number | undefined;
}) | {
    error: {
        message: string;
        code: string;
    };
};

type GetMatchUpFormatArgs = {
    tournamentRecord: Tournament;
    drawDefinition?: DrawDefinition;
    structureId?: string;
    matchUpId?: string;
    eventId?: string;
    drawId?: string;
    event?: Event$1;
};
declare function getMatchUpFormat(params: GetMatchUpFormatArgs): any;

/**
 * Builds up an exhaustive map of all matchUpIds on which a matchUpId is depdendent
 * Optionally builds up an exhaustive map of all potential participantIds for each matchUpId
 */

type GetMatchUpDependenciesArgs = {
    includeParticipantDependencies?: boolean;
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
    drawDefinition?: DrawDefinition;
    matchUps?: HydratedMatchUp[];
    matchUpIds?: string[];
    drawIds?: string[];
};
declare function getMatchUpDependencies(params: GetMatchUpDependenciesArgs): {
    sourceMatchUpIds?: {
        [key: string]: any[];
    };
    matchUps?: HydratedMatchUp[];
    positionDependencies?: any;
    matchUpDependencies?: any;
    error?: ErrorType;
    success?: boolean;
};

declare function getMatchUpDailyLimitsUpdate({ tournamentRecords }: {
    tournamentRecords: any;
}): {
    error?: ErrorType | undefined;
} | {
    methods: QueueMethod[];
};

type GetMatchUpDailyLimitsArgs = {
    tournamentRecords: {
        [key: string]: Tournament;
    };
    tournamentId?: string;
};
declare function getMatchUpDailyLimits({ tournamentRecords, tournamentId, }: GetMatchUpDailyLimitsArgs): ResultType & {
    matchUpDailyLimits?: any;
};

type GetMatchUpCompetitivenessArgs = {
    tournamentRecord?: Tournament;
    profileBands?: any;
    matchUp: MatchUp;
};
declare function getMatchUpCompetitiveProfile({ tournamentRecord, profileBands, matchUp, }: GetMatchUpCompetitivenessArgs): {
    competitiveness?: any;
    pctSpread?: number;
    success?: boolean;
    error?: ErrorType;
};

declare function getLinkedTournamentIds({ tournamentRecords, }: {
    tournamentRecords: TournamentRecords;
}): ResultType & {
    linkedTournamentIds?: string[];
};

type GetFlightProfileArgs = {
    eventId?: string;
    event: Event$1;
};
declare function getFlightProfile({ event, eventId }: GetFlightProfileArgs): {
    error: {
        message: string;
        code: string;
    };
    flightProfile?: undefined;
} | {
    flightProfile: any;
    error?: undefined;
};

declare function getEventStructures({ withStageGrouping, stageSequences, stageSequence, roundTarget, stages, event, stage, }: {
    withStageGrouping: any;
    stageSequences: any;
    stageSequence: any;
    roundTarget: any;
    stages: any;
    event: any;
    stage: any;
}): {
    error: {
        message: string;
        code: string;
    };
    structures?: undefined;
    stageStructures?: undefined;
} | {
    structures: Structure[];
    stageStructures: {};
    error?: undefined;
};
declare function getTournamentStructures({ withStageGrouping, tournamentRecord, stageSequences, stageSequence, roundTarget, stages, stage, }: {
    withStageGrouping: any;
    tournamentRecord: any;
    stageSequences: any;
    stageSequence: any;
    roundTarget: any;
    stages: any;
    stage: any;
}): {
    error: {
        message: string;
        code: string;
    };
    structures?: undefined;
    stageStructures?: undefined;
} | {
    structures: Structure[];
    stageStructures: {};
    error?: undefined;
};

type RankingStat = {
    median: number;
    avg: number;
    max: number;
    min: number;
};
type EventScaleValues = {
    [key: string]: {
        ratingsStats: {
            [key: string]: RankingStat;
        };
        ratings: {
            [key: string]: number[];
        };
        ranking: {
            [key: string]: any;
        };
        draws: {
            [key: string]: {
                ratingsStats: {
                    [key: string]: RankingStat;
                };
                ratings: {
                    [key: string]: number[];
                };
                ranking: {
                    [key: string]: any;
                };
            };
        };
    };
};
type GetEventsArgs = {
    tournamentRecord: Tournament;
    withScaleValues?: boolean;
    scaleEventType?: EventTypeUnion;
    inContext?: boolean;
    eventIds?: string[];
    drawIds?: string[];
    context?: any;
};
declare function getEvents({ tournamentRecord, withScaleValues, scaleEventType, inContext, // hydrate with tournamentId
eventIds, // only return events with these eventIds
drawIds, // only return events with these drawIds, and only drawDefinitions with these drawIds
context, }: GetEventsArgs): ResultType & {
    eventScaleValues?: EventScaleValues;
    events?: Event$1[];
};

declare function getEventProperties({ tournamentRecord, event }: {
    tournamentRecord: any;
    event: any;
}): {
    error: {
        message: string;
        code: string;
    };
    entryScaleAttributes?: undefined;
    hasSeededParticipants?: undefined;
    hasRankedParticipants?: undefined;
    hasRatedParticipants?: undefined;
} | {
    entryScaleAttributes: any;
    hasSeededParticipants: any;
    hasRankedParticipants: any;
    hasRatedParticipants: any;
    error?: undefined;
};

type GetEventMatchUpFormatTimingArgs = {
    tournamentRecord: Tournament;
    matchUpFormats?: string[];
    categoryType?: string;
    event: Event$1;
};
declare function getEventMatchUpFormatTiming({ tournamentRecord, matchUpFormats, // optional - can be retrieved from policy
categoryType, // optional - categoryType is not part of event attributes
event, }: GetEventMatchUpFormatTimingArgs): {
    eventMatchUpFormatTiming?: any;
    error?: ErrorType;
    info?: string;
};

type GetEventArgs = {
    context: {
        [key: string]: any;
    };
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    event: Event$1;
};
declare function getEvent({ tournamentRecord, drawDefinition, context, event, }: GetEventArgs): any;

type GetEntriesAndSeedsCountArgs = {
    policyDefinitions: PolicyDefinitions;
    drawDefinition: DrawDefinition;
    stage: StageTypeUnion;
    drawSize?: number;
    drawId?: string;
    event: Event$1;
};
declare function getEntriesAndSeedsCount({ policyDefinitions, drawDefinition, drawSize, drawId, event, stage, }: GetEntriesAndSeedsCountArgs): {
    stageEntries?: Entry[];
    seedsCount?: number;
    entries?: Entry[];
    error?: ErrorType;
};

type GetEligibleVoluntaryConsolationParticipantsArgs = {
    excludedMatchUpStatuses?: MatchUpStatusUnion[];
    policyDefinitions?: PolicyDefinitions;
    includeEventParticipants?: boolean;
    includeQualifyingStage?: boolean;
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    finishingRoundLimit?: number;
    roundNumberLimit?: number;
    matchUpsLimit?: number;
    requirePlay?: boolean;
    requireLoss?: boolean;
    allEntries?: boolean;
    winsLimit?: number;
    event?: Event$1;
};
declare function getEligibleVoluntaryConsolationParticipants({ excludedMatchUpStatuses, includeEventParticipants, // boolean - consider event entries rather than draw entries (if event is present)
includeQualifyingStage, finishingRoundLimit, policyDefinitions, roundNumberLimit, tournamentRecord, drawDefinition, matchUpsLimit, requirePlay, requireLoss, allEntries, // boolean - consider all entries, regardless of whether placed in draw
winsLimit, event, }: GetEligibleVoluntaryConsolationParticipantsArgs): {
    eligibleParticipants?: Participant[];
    losingParticipantIds?: string[];
    error?: ErrorType;
};

type getDrawTypeCoercionArgs = {
    policyDefinitions?: PolicyDefinitions;
    appliedPolicies?: PolicyDefinitions;
    drawType?: string;
};
declare function getDrawTypeCoercion({ policyDefinitions, appliedPolicies, drawType, }: getDrawTypeCoercionArgs): any;

declare function getDrawParticipantRepresentativeIds({ drawDefinition }: {
    drawDefinition: any;
}): (ResultType & {
    extension?: Extension | undefined;
}) | {
    representativeParticipantIds: any;
};

type TimeItemResult = {
    timeItem?: TimeItem;
    previousItems?: any;
    success?: boolean;
    code?: string;
    info?: any;
};
type TimeItemArgs = {
    returnPreviousValues?: boolean;
    itemSubTypes?: string[];
    itemType: string;
    element: any;
};
declare function getTimeItem({ returnPreviousValues, itemSubTypes, itemType, element, }: TimeItemArgs): TimeItemResult & ResultType;
declare function getDrawDefinitionTimeItem({ returnPreviousValues, drawDefinition, itemSubTypes, itemType, }: {
    returnPreviousValues: any;
    drawDefinition: any;
    itemSubTypes: any;
    itemType: any;
}): {
    error: {
        message: string;
        code: string;
    };
    timeItem?: undefined;
    previousItems?: undefined;
    info?: undefined;
} | {
    timeItem: TimeItem;
    previousItems: any;
    error?: undefined;
    info?: undefined;
} | {
    info: any;
    error?: undefined;
    timeItem?: undefined;
    previousItems?: undefined;
};
type GetEventTimeItemArgs = {
    returnPreviousValues?: boolean;
    itemSubTypes?: string[];
    itemType: string;
    event: Event$1;
};
declare function getEventTimeItem({ returnPreviousValues, itemSubTypes, itemType, event, }: GetEventTimeItemArgs): {
    error: {
        message: string;
        code: string;
    };
    timeItem?: undefined;
    previousItems?: undefined;
    info?: undefined;
} | {
    timeItem: TimeItem;
    previousItems: any;
    error?: undefined;
    info?: undefined;
} | {
    info: any;
    error?: undefined;
    timeItem?: undefined;
    previousItems?: undefined;
};
type GetTournamentTimeItemArgs = {
    returnPreviousValues?: boolean;
    tournamentRecord: Tournament;
    itemSubTypes?: string[];
    itemType: string;
};
declare function getTournamentTimeItem({ returnPreviousValues, tournamentRecord, itemSubTypes, itemType, }: GetTournamentTimeItemArgs): {
    error: {
        message: string;
        code: string;
    };
    timeItem?: undefined;
    previousItems?: undefined;
    info?: undefined;
} | {
    timeItem: TimeItem;
    previousItems: any;
    error?: undefined;
    info?: undefined;
} | {
    info: any;
    error?: undefined;
    timeItem?: undefined;
    previousItems?: undefined;
};
declare function getParticipantTimeItem({ returnPreviousValues, tournamentRecord, participantId, itemSubTypes, itemType, }: {
    returnPreviousValues: any;
    tournamentRecord: any;
    participantId: any;
    itemSubTypes: any;
    itemType: any;
}): {
    participant?: Participant | undefined;
    tournamentId?: string | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    timeItem?: undefined;
    previousItems?: undefined;
    info?: undefined;
} | {
    timeItem: TimeItem;
    previousItems: any;
    error?: undefined;
    info?: undefined;
} | {
    info: any;
    error?: undefined;
    timeItem?: undefined;
    previousItems?: undefined;
};

/**
 *
 * @param {string} venueId - optional -
 * @param {string[]} venueIds - optional -
 */
declare function getCourts({ tournamentRecord, venueId, venueIds }: {
    tournamentRecord: any;
    venueId: any;
    venueIds: any;
}): {
    error: {
        message: string;
        code: string;
    };
    courts?: undefined;
} | {
    courts: any;
    error?: undefined;
};

type GetVenuesAndCourtsArgs = {
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
    convertExtensions?: boolean;
    ignoreDisabled?: boolean;
    tournamentId?: string;
    venueIds?: string[];
    dates?: string[];
};
declare function getVenuesAndCourts(params: GetVenuesAndCourtsArgs): ResultType & {
    venues?: HydratedVenue[];
    courts?: HydratedCourt[];
};
type GetCompeitionVenuesArgs = {
    tournamentRecords: TournamentRecords;
    requireCourts?: boolean;
    dates?: string[];
};
declare function getCompetitionVenues({ tournamentRecords, requireCourts, dates, }: GetCompeitionVenuesArgs): {
    venueIds?: string[];
    error?: ErrorType;
    venues?: Venue[];
};

type GetCompetitionPenaltiesArgs = {
    tournamentRecords: TournamentRecords;
};
declare function getCompetitionPenalties({ tournamentRecords, }: GetCompetitionPenaltiesArgs): {
    error: {
        message: string;
        code: string;
    };
    penalties?: undefined;
} | {
    penalties: Penalty[];
    error?: undefined;
};

declare function getCompetitionParticipants(params: any): ResultType & {
    mappedMatchUps?: {
        [key: string]: HydratedMatchUp;
    };
    participantIdsWithConflicts?: string[];
    participants?: HydratedParticipant[];
    participantMap?: ParticipantMap;
    matchUps?: MatchUp[];
    derivedEventInfo?: any;
    derivedDrawInfo?: any;
    success?: boolean;
};

type CompetitionMatchUpsArgs$1 = {
    scheduleVisibilityFilters?: ScheduleVisibilityFilters;
    participantsProfile?: ParticipantsProfile;
    tournamentRecords: TournamentRecords;
    policyDefinitions?: PolicyDefinitions;
    matchUpFilters?: MatchUpFilters;
    contextFilters?: MatchUpFilters;
    afterRecoveryTimes?: boolean;
    usePublishState?: boolean;
    nextMatchUps?: boolean;
    inContext?: boolean;
};
declare function getCompetitionMatchUps({ scheduleVisibilityFilters, participantsProfile, tournamentRecords, policyDefinitions, usePublishState, matchUpFilters, contextFilters, nextMatchUps, inContext, }: CompetitionMatchUpsArgs$1): ResultType & {
    abandonedMatchUps?: HydratedMatchUp[];
    completedMatchUps?: HydratedMatchUp[];
    upcomingMatchUps?: HydratedMatchUp[];
    pendingMatchUps?: HydratedMatchUp[];
    byeMatchUps?: HydratedMatchUp[];
    groupInfo?: GroupInfo;
};

declare function getCompetitionDateRange({ tournamentRecords, }: {
    tournamentRecords: TournamentRecords;
}): {
    startDate?: Date;
    endDate?: Date;
    error?: ErrorType;
};

type GetAssignedParticipantIdsArgs = {
    drawDefinition: DrawDefinition;
    stages?: StageTypeUnion[];
};
declare function getAssignedParticipantIds({ drawDefinition, stages }: GetAssignedParticipantIdsArgs): ResultType & {
    assignedParticipantIds?: string[];
};

type GetAppliedPoliciesArgs = {
    onlySpecifiedPolicyTypes?: boolean;
    tournamentRecord?: Tournament;
    drawDefinition?: DrawDefinition;
    policyTypes?: string[];
    structure?: Structure;
    event?: Event$1;
};
declare function getAppliedPolicies({ onlySpecifiedPolicyTypes, policyTypes, tournamentRecord, drawDefinition, structure, event, }: GetAppliedPoliciesArgs): {
    appliedPolicies?: PolicyDefinitions;
    error?: ErrorType;
};
type GetPolicyDefinitionsArgs = {
    tournamentRecord?: Tournament;
    drawDefinition?: DrawDefinition;
    policyTypes?: string[];
    structure?: Structure;
    event?: Event$1;
};
declare function getPolicyDefinitions({ policyTypes, tournamentRecord, drawDefinition, structure, event, }: GetPolicyDefinitionsArgs): {
    policyDefinitions?: PolicyDefinitions;
    error?: ErrorType;
    info?: string;
};

declare function getAllowedMatchUpFormats({ tournamentRecord, categoryName, categoryType, }: {
    tournamentRecord: any;
    categoryName: any;
    categoryType: any;
}): any;
declare function getAllowedDrawTypes({ tournamentRecord, categoryName, categoryType, }: {
    tournamentRecord: any;
    categoryName: any;
    categoryType: any;
}): any;

declare function getAllDrawMatchUps(params: any): ResultType & {
    matchUps?: HydratedMatchUp[];
    matchUpsMap?: MatchUpsMap;
};

type FindPolicyArgs = {
    drawDefinition?: DrawDefinition;
    tournamentRecord?: Tournament;
    structure?: Structure;
    policyType: string;
    event?: Event$1;
};
declare function findPolicy({ tournamentRecord, drawDefinition, policyType, structure, event, }: FindPolicyArgs): {
    policy?: any;
    error?: ErrorType;
    info?: string;
};

type PublicFindParticipantArgs = {
    tournamentRecords?: TournamentRecords;
    policyDefinitions?: PolicyDefinitions;
    tournamentRecord?: Tournament;
    contextProfile?: ContextProfile;
    participantId?: string;
    personId?: string;
};
declare function publicFindParticipant(params: PublicFindParticipantArgs): {
    participant?: HydratedParticipant;
    tournamentId?: string;
    error?: ErrorType;
    stack?: any;
};

type FindMatchUpType = {
    participantsProfile?: ParticipantsProfile;
    contextContent?: ContextContent;
    contextProfile?: ContextProfile;
    drawDefinition?: DrawDefinition;
    afterRecoveryTimes?: boolean;
    tournamentRecord: Tournament;
    nextMatchUps?: boolean;
    inContext?: boolean;
    matchUpId: string;
    eventId?: string;
    drawId?: string;
    event?: Event$1;
};
type FindMatchUpResult = {
    drawDefinition?: DrawDefinition;
    matchUp?: HydratedMatchUp;
    structure?: Structure;
    error?: ErrorType;
};
declare function publicFindMatchUp(params: FindMatchUpType): FindMatchUpResult;

type FindExtensionType = {
    tournamentRecords?: TournamentRecords;
    params?: {
        [key: string]: any;
    };
    discover?: boolean | string[];
    element?: any;
    name: string;
};
type ExtensionResult = ResultType & {
    extension?: Extension;
};
declare function findExtension({ discover, // boolean or array of keys to discover extensions on specified params
element, name, ...params }: FindExtensionType): ExtensionResult;

declare function eventMatchUps(params: GetMatchUpsArgs): GroupsMatchUpsResult;

declare function drawMatchUps({ participants: tournamentParticipants, tournamentAppliedPolicies, scheduleVisibilityFilters, participantsProfile, afterRecoveryTimes, policyDefinitions, useParticipantMap, tournamentRecord, usePublishState, contextFilters, contextContent, matchUpFilters, participantMap, publishStatus, contextProfile, drawDefinition, nextMatchUps, tournamentId, inContext, context, event, }: GetMatchUpsArgs): {
    groupInfo: any;
    abandonedMatchUps?: HydratedMatchUp[] | undefined;
    completedMatchUps?: HydratedMatchUp[] | undefined;
    upcomingMatchUps?: HydratedMatchUp[] | undefined;
    pendingMatchUps?: HydratedMatchUp[] | undefined;
    byeMatchUps?: HydratedMatchUp[] | undefined;
    matchUpsMap?: MatchUpsMap | undefined;
    matchUpsCount?: number | undefined;
    success?: boolean | undefined;
    error?: ErrorType | undefined;
};

type CompetitionScheduleMatchUpsArgs = {
    tournamentRecords: TournamentRecords;
    courtCompletedMatchUps?: boolean;
    alwaysReturnCompleted?: boolean;
    contextFilters?: MatchUpFilters;
    matchUpFilters?: MatchUpFilters;
    withCourtGridRows?: boolean;
    activeTournamentId?: string;
    sortDateMatchUps?: boolean;
    minCourtGridRows?: number;
    usePublishState?: boolean;
    sortCourtsData?: boolean;
    status?: string;
};
declare function competitionScheduleMatchUps(params: CompetitionScheduleMatchUpsArgs): {
    completedMatchUps?: HydratedMatchUp[];
    dateMatchUps?: HydratedMatchUp[];
    courtPrefix?: string;
    error?: ErrorType;
    venues?: Venue[];
    courtsData?: any;
    rows?: any[];
};

type CheckValidEntriesArgs = {
    policyDefinitions?: PolicyDefinitions;
    appliedPolicies?: PolicyDefinitions;
    participantMap?: ParticipantMap;
    tournamentRecord?: Tournament;
    participants?: Participant[];
    consideredEntries?: Entry[];
    enforceGender?: boolean;
    event: Event$1;
};
declare function checkValidEntries({ consideredEntries, policyDefinitions, tournamentRecord, appliedPolicies, participantMap, enforceGender, participants, event, }: CheckValidEntriesArgs): {
    error: {
        message: string;
        code: string;
    };
    invalidParticipantIds?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    invalidParticipantIds: string[];
} | {
    valid: boolean;
    success: boolean;
    error?: undefined;
    invalidParticipantIds?: undefined;
};

declare function checkMatchUpIsComplete({ matchUp }: {
    matchUp: any;
}): any;

type CategoryCanContainArgs = {
    childCategory: Category;
    withDetails?: boolean;
    category: Category;
};
declare function categoryCanContain({ childCategory, withDetails, category, }: CategoryCanContainArgs): any;

/**
 *
 * @param {object[]} outcomes - array of outcomes to be applied to matchUps, relevent attributes: { eventId: string; drawId: string; }
 *
 */
declare function bulkUpdatePublishedEventIds({ tournamentRecord, outcomes }: {
    tournamentRecord: any;
    outcomes: any;
}): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
    publishedEventIds?: undefined;
    eventIdPublishedDrawIdsMap?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
    publishedEventIds?: undefined;
    eventIdPublishedDrawIdsMap?: undefined;
} | {
    publishedEventIds: any;
    eventIdPublishedDrawIdsMap: any;
    error?: undefined;
    info?: undefined;
};

declare function analyzeTournament({ tournamentRecord }: {
    tournamentRecord: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    analysis: {
        isDual: boolean;
        drawsAnalysis: any;
    };
    success: boolean;
    error?: undefined;
};

declare function analyzeMatchUp(params?: any): ResultType & {
    matchUpScoringFormat?: any;
    validMatchUpOutcome?: boolean;
    calculatedWinningSide?: number;
    validMatchUpWinningSide?: boolean;
    completedSetsHaveValidOutcomes?: boolean;
    isLastSetWithValues?: boolean;
    completedSetsCount?: number;
    isCompletedMatchUp?: boolean;
    isValidSideNumber?: boolean;
    hasExistingValue?: boolean;
    existingValue?: number;
    expectTimedSet?: boolean;
    isExistingSet?: boolean;
    isActiveSet?: boolean;
    isCompletedSet?: boolean;
    sideGameScores?: number[];
    sidePointScores?: number[];
    sideTiebreakScores?: number[];
    winningSide?: number;
};

declare function analyzeDraws({ tournamentRecord }: {
    tournamentRecord: any;
}): {
    error?: ErrorType;
    drawsAnalysis?: any;
    success?: boolean;
};

declare function allTournamentMatchUps(params?: GetMatchUpsArgs): ResultType & {
    matchUps?: HydratedMatchUp[];
};

declare function allEventMatchUps(params: GetMatchUpsArgs): {
    error: {
        message: string;
        code: string;
    };
    matchUps?: undefined;
    groupInfo?: undefined;
} | {
    matchUps: HydratedMatchUp[];
    groupInfo: any;
    error?: undefined;
};

declare function allDrawMatchUps(params: GetMatchUpsArgs): {
    groupInfo: any;
    context?: {
        [key: string]: any;
    } | undefined;
    stack?: string | string[] | undefined;
    error?: ErrorType | undefined;
    errors?: string[] | undefined;
    success?: boolean | undefined;
    valid?: boolean | undefined;
    info?: any;
    matchUps?: HydratedMatchUp[] | undefined;
    matchUpsMap?: MatchUpsMap | undefined;
};

type CompetitionMatchUpsArgs = {
    scheduleVisibilityFilters?: ScheduleVisibilityFilters;
    participantsProfile?: ParticipantsProfile;
    tournamentRecords: TournamentRecords;
    policyDefinitions?: PolicyDefinitions;
    matchUpFilters?: MatchUpFilters;
    contextFilters?: MatchUpFilters;
    afterRecoveryTimes?: boolean;
    usePublishState?: boolean;
    nextMatchUps?: boolean;
    inContext?: boolean;
};
declare function allCompetitionMatchUps({ scheduleVisibilityFilters, afterRecoveryTimes, participantsProfile, tournamentRecords, policyDefinitions, matchUpFilters, contextFilters, nextMatchUps, inContext, }: CompetitionMatchUpsArgs): {
    matchUps?: HydratedMatchUp[];
    error?: ErrorType;
};

declare function unPublishOrderOfPlay(params: any): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

declare function unPublishEvent({ removePriorValues, tournamentRecord, status, event, }: {
    removePriorValues?: boolean | undefined;
    tournamentRecord: any;
    status?: string | undefined;
    event: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    eventId: any;
    error?: undefined;
};

type ScheduleDetails = {
    attributes: {
        [key: string]: boolean;
    };
    dates: string[];
};
type DisplayAttributes = {
    participantAttributes?: {
        [key: string]: any;
    };
    scheduleDetails?: ScheduleDetails[];
    [key: string]: any;
    theme?: string;
};
type DisplaySettings = {
    draws: {
        [key: string]: DisplayAttributes;
        default: DisplayAttributes;
    };
    [key: string]: any;
};
type SetEventDisplaySettings = {
    displaySettings: DisplaySettings;
    tournamentRecord: Tournament;
    removePriorValues?: boolean;
    eventId?: string;
    status?: string;
    event: Event$1;
};
declare function setEventDisplay({ removePriorValues, tournamentRecord, displaySettings, status, event, }: SetEventDisplaySettings): ResultType;

declare function publishOrderOfPlay(params: any): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

declare function publishEventSeeding({ removePriorValues, stageSeedingScaleNames, seedingScaleNames, tournamentRecord, status, drawIds, event, }: {
    removePriorValues?: boolean | undefined;
    stageSeedingScaleNames: any;
    seedingScaleNames: any;
    tournamentRecord: any;
    status?: string | undefined;
    drawIds?: never[] | undefined;
    event: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};
declare function unPublishEventSeeding({ removePriorValues, seedingScaleNames, tournamentRecord, status, drawIds, stages, event, }: {
    removePriorValues?: boolean | undefined;
    seedingScaleNames: any;
    tournamentRecord: any;
    status?: string | undefined;
    drawIds: any;
    stages: any;
    event: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

type PublishingDetail = {
    roundLimit?: number;
    published?: boolean;
    embargo?: string;
};
type DrawPublishingDetails = {
    structureDetails?: {
        [key: string]: PublishingDetail;
    };
    stageDetails?: {
        [key: string]: PublishingDetail;
    };
    publishingDetail: PublishingDetail;
    structureIdsToRemove?: string[];
    structureIdsToAdd?: string[];
    stagesToRemove?: string[];
    stagesToAdd?: string[];
};
type PublishEventType = {
    includePositionAssignments?: boolean;
    policyDefinitions?: PolicyDefinitions;
    removePriorValues?: boolean;
    tournamentRecord: Tournament;
    drawIds?: string[];
    status?: string;
    event?: Event$1;
    drawDetails?: {
        [key: string]: DrawPublishingDetails;
    };
    drawIdsToRemove?: string[];
    drawIdsToAdd?: string[];
};
declare function publishEvent(params: PublishEventType): ResultType | {
    error: {
        message: string;
        code: string;
    };
} | {
    eventData: any;
    success: boolean;
    error?: undefined;
};

type GetVenueDataArgs = {
    tournamentRecord: Tournament;
    venueId: string;
};
declare function getVenueData({ tournamentRecord, venueId }: GetVenueDataArgs): {
    success?: boolean;
    error?: ErrorType;
    venueData?: any;
};

type GetPublishStateArgs = {
    tournamentRecord?: Tournament;
    eventIds?: string[];
    drawIds?: string[];
    drawId?: string;
    event: Event$1;
};
declare function getPublishState({ tournamentRecord, eventIds, drawIds, drawId, event, }: GetPublishStateArgs): ResultType & {
    publishState?: any;
};

type GetEventDataArgs = {
    participantsProfile?: ParticipantsProfile;
    includePositionAssignments?: boolean;
    policyDefinitions?: PolicyDefinitions;
    sortConfig?: StructureSortConfig;
    tournamentRecord: Tournament;
    usePublishState?: boolean;
    status?: string;
    event: Event$1;
};
declare function getEventData(params: GetEventDataArgs): {
    error?: ErrorType;
    success?: boolean;
    eventData?: any;
};

declare function getDrawData(params: any): {
    structures?: any[];
    success?: boolean;
    error?: ErrorType;
    drawInfo?: any;
};

type GetCourtInfoArgs = {
    tournamentRecord: Tournament;
    internalUse?: boolean;
    courtId: string;
};
declare function getCourtInfo({ tournamentRecord, internalUse, courtId, }: GetCourtInfoArgs): {
    error?: ErrorType;
    success?: boolean;
    courtInfo?: any;
};

declare function getAllEventData({ tournamentRecord, policyDefinitions }: {
    tournamentRecord: any;
    policyDefinitions: any;
}): {
    error: {
        message: string;
        code: string;
    };
    allEventData?: undefined;
} | {
    allEventData: {
        tournamentInfo: any;
        venuesData: HydratedVenue[] | undefined;
        eventsData: any;
    };
    error?: undefined;
};

type RemovePolicyArgs = {
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
    drawDefinition?: DrawDefinition;
    tournamentId?: string;
    policyType: string;
    event?: Event$1;
};
declare function removePolicy(params: RemovePolicyArgs): (ResultType & {
    valid?: boolean | undefined;
}) | {
    success: boolean;
    error?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};

type AttachPoliciesArgs = {
    tournamentRecords?: TournamentRecords;
    policyDefinitions: PolicyDefinitions;
    drawDefinition?: DrawDefinition;
    tournamentRecord?: Tournament;
    allowReplacement?: boolean;
    tournamentId?: string;
    event?: Event$1;
};
declare function attachPolicies(params: AttachPoliciesArgs): ResultType & {
    applied?: string[];
};

type SetParticipantScaleItemArgs = {
    tournamentRecord: Tournament;
    removePriorValues?: boolean;
    participantId: string;
    scaleItem?: ScaleItem;
};
declare function setParticipantScaleItem(params: SetParticipantScaleItemArgs): any;
type SetParticipantScaleItemsArgs = {
    scaleItemsWithParticipantIds: {
        scaleItems: ScaleItem[];
        participantId: string;
    }[];
    context?: {
        [key: string]: any;
    };
    tournamentRecord: Tournament;
    removePriorValues?: boolean;
    auditData?: any;
};
declare function setParticipantScaleItems(params: SetParticipantScaleItemsArgs): any;

type ScaledTeamAssignmentArgs = {
    clearExistingAssignments?: boolean;
    individualParticipantIds?: string[];
    reverseAssignmentOrder?: boolean;
    initialTeamIndex?: number;
    scaledParticipants?: any[];
    teamParticipantIds?: string[];
    tournamentRecord: Tournament;
    scaleAttributes?: any;
    teamNameBase?: string;
    teamsCount?: number;
    eventId?: string;
    event?: Event$1;
};
declare function scaledTeamAssignment({ clearExistingAssignments, // by default remove all existing individualParticipantIds from targeted teams
individualParticipantIds, // if scaledParticipants are provided, individualParticipants is ignored
reverseAssignmentOrder, // optional - reverses team order; useful for sequential assignment of participant groupings to ensure balanced distribution
initialTeamIndex, // optional - allows assignment to begin at a specified array index; useful for sequential assignment of groups of scaledParticipants
scaledParticipants, // optional - either scaledParticipants or (individualParticipantIds and scaleName) must be provided
teamParticipantIds, // optional, IF teamsCount is provided then teams will be created
tournamentRecord, // supplied automatically by tournamentEngine
scaleAttributes, // ignored if scaledParticipants are provided; { scaleName, scaleType, sortOrder, eventType }
teamNameBase, // optional - defaults to '[categoryName] TEAM #', where categoryName is derived from eventId (if supplied)
teamsCount, // optional - derived from teamParticipantIds (if provided) - create # of teams if teamParticipantIds provided are insufficient
eventId, // optional - source teamParticipantIds from DIRECT_ACCEPTANCE participants in a TEAM event
event, }: ScaledTeamAssignmentArgs): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
    participant?: undefined;
    scaledParticipant?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
    participant?: undefined;
    scaledParticipant?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    participant: Participant;
    info?: undefined;
    scaledParticipant?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    scaledParticipant: any;
    info?: undefined;
    participant?: undefined;
} | {
    scaledParticipants: any[];
    success: boolean;
    error?: undefined;
    info?: undefined;
    participant?: undefined;
    scaledParticipant?: undefined;
};

declare function removePenalty(params: any): {
    error?: ErrorType | undefined;
    success?: boolean | undefined;
    penalty?: Penalty | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};

type RemoveIndividualParticipantIdsArgs = {
    addIndividualParticipantsToEvents?: boolean;
    individualParticipantIds: string[];
    groupingParticipantId: string;
    tournamentRecord: Tournament;
    suppressErrors?: boolean;
};
declare function removeIndividualParticipantIds({ addIndividualParticipantsToEvents, individualParticipantIds, groupingParticipantId, tournamentRecord, suppressErrors, }: RemoveIndividualParticipantIdsArgs): ResultType;
type RemoveParticipantIdsFromAllTeamsArgs = {
    participantRole?: ParticipantRoleUnion;
    individualParticipantIds?: string[];
    tournamentRecord: Tournament;
    groupingTypes?: string[];
};
declare function removeParticipantIdsFromAllTeams({ participantRole, individualParticipantIds, groupingTypes, tournamentRecord, }: RemoveParticipantIdsFromAllTeamsArgs): {
    success: boolean;
} | {
    error: {
        message: string;
        code: string;
    };
};

/**
 * "First Last"
 * "Last, First"
 * "LAST, First"
 * "LAST, FIRST"
 * "F. Last"
 * "first last"
 * "Last"
 */
type RegenArgs = {
    formats: {
        [key: string]: {
            personFormat: string;
            doublesJoiner: string;
        };
    }[];
    tournamentRecord: Tournament;
};
declare function regenerateParticipantNames({ tournamentRecord, formats, }: RegenArgs): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

declare function modifyPenalty(params: any): {
    modifications?: any;
    error?: ErrorType | undefined;
    success?: boolean | undefined;
    penalty?: Penalty | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};

declare function modifyParticipantsSignInStatus({ tournamentRecord, participantIds, signInState, }: {
    tournamentRecord: any;
    participantIds: any;
    signInState: any;
}): {
    participant?: Participant | undefined;
    tournamentId?: string | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    error: {
        message: string;
        code: string;
    };
    signInState: any;
    context?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    context: {
        invalidParticipantIds: any[];
    };
    signInState?: undefined;
} | {
    success: boolean;
    error?: undefined;
    signInState?: undefined;
    context?: undefined;
};

declare function modifyParticipantOtherName({ tournamentRecord, participantId, participantOtherName, }: {
    tournamentRecord: any;
    participantId: any;
    participantOtherName: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

declare function modifyParticipantName({ tournamentRecord, participantName, participantId, }: {
    tournamentRecord: any;
    participantName: any;
    participantId: any;
}): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};

declare function modifyParticipant(params: any): any;

/**
 *
 * @param {object} tournamentRecord - passed in automatically by tournamentEngine
 * @param {string} groupingParticipantId - grouping participant to which participantIds are to be added
 * @param {string[]} individualParticipantIds - new value for individualParticipantIds array
 *
 */
declare function modifyIndividualParticipantIds({ individualParticipantIds, groupingParticipantId, tournamentRecord, }: {
    individualParticipantIds: any;
    groupingParticipantId: any;
    tournamentRecord: any;
}): ResultType;

declare function mergeParticipants({ participants: incomingParticipants, tournamentRecord, arraysToMerge }: {
    participants?: never[] | undefined;
    tournamentRecord: any;
    arraysToMerge: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    modifiedParticipantsCount: number;
    newParticipantsCount: number;
    error?: undefined;
};

type FilterParticipantsArgs = {
    participantFilters: ParticipantFilters;
    participants: HydratedParticipant[];
    tournamentRecord: Tournament;
};
declare function filterParticipants({ participantFilters, tournamentRecord, participants, }: FilterParticipantsArgs): HydratedParticipant[];

/**
 *
 * @param {boolean=} addIndividualParticipantsToEvents
 * @param {object} tournamentRecord
 * @param {string[]} participantIds
 * @returns {object}
 */
declare function deleteParticipants(params: any): {
    participantsRemovedCount?: number;
    success?: boolean;
    error?: ErrorType;
};

/**
 *
 * @param {object} tournamentRecord - passed in automatically by tournamentEngine
 * @param {string} participantAttribute - optional - participant attribute to be used to group individual participants
 * @param {string} personAttribute - optional - person attribute to be used to group individual participants
 * @param {string} accessor - optional - dot delimited string targeting nested value
 * @param {string[]} uuids - optional - array of unique identifiers for genrated team participants
 * @returns { success: true } or { error }
 */
type GenerateTeamsArgs = {
    participantAttribute?: string;
    tournamentRecord: Tournament;
    addParticipants?: boolean;
    personAttribute?: string;
    teamNames?: string[];
    accessor?: string;
    uuids?: string[];
};
declare function createTeamsFromParticipantAttributes({ addParticipants, // optional boolean to disable add
participantAttribute, tournamentRecord, personAttribute, teamNames, accessor, uuids, }: GenerateTeamsArgs): {
    error: {
        message: string;
        code: string;
    };
} | {
    participantsAdded: number;
    success: boolean;
    error?: undefined;
} | {
    newParticipants: any[];
    success: boolean;
    error?: undefined;
};

type CreateGroupParticipantType = {
    participantRoleResponsibilities?: string[];
    individualParticipantIds: string[];
    tournamentRecord: Tournament;
    participantRole?: string;
    participantId: string;
    groupName: string;
};
declare function createGroupParticipant({ individualParticipantIds, participantRoleResponsibilities, participantRole, tournamentRecord, participantId, groupName, }: CreateGroupParticipantType): {
    participant?: Participant;
    participantId?: string;
    success?: boolean;
    error?: ErrorType;
    info?: any;
};

declare function addPersons({ participantRole, tournamentRecord, persons, }: {
    participantRole?: any;
    tournamentRecord: any;
    persons: any;
}): any;

type AddPenaltyArgs = {
    refereeParticipantId?: string;
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
    penaltyType: PenaltyTypeUnion;
    participantIds: string[];
    extensions?: Extension[];
    penaltyCode: string;
    penaltyId?: string;
    matchUpId?: string;
    issuedAt?: string;
    notes?: string;
};
declare function addPenalty(params: AddPenaltyArgs): ResultType & {
    penaltyId?: string;
};

type AddParticipantsType = {
    allowDuplicateParticipantIdPairs?: boolean;
    returnParticipants?: boolean;
    participants?: Participant[];
    tournamentRecord: Tournament;
};
declare function addParticipants({ allowDuplicateParticipantIdPairs, returnParticipants, tournamentRecord, participants, }: AddParticipantsType): any;

type AddParticipantType = {
    allowDuplicateParticipantIdPairs?: boolean;
    tournamentRecords?: TournamentRecords;
    tournamentRecord: Tournament;
    activeTournamentId?: string;
    returnParticipant?: boolean;
    disableNotice?: boolean;
    pairOverride?: boolean;
    tournamentId?: string;
    participant: any;
};
declare function addParticipant(params: AddParticipantType): any;

type AddIndividualParticipantIdsType = {
    individualParticipantIds: string[];
    removeFromOtherTeams?: boolean;
    groupingParticipantId: string;
    tournamentRecord: Tournament;
};
declare function addIndividualParticipantIds({ individualParticipantIds, groupingParticipantId, removeFromOtherTeams, tournamentRecord, }: AddIndividualParticipantIdsType): ResultType & {
    groupingParticipant?: Participant;
    added?: number;
};

declare function credits(): string;

/**
 *
 * @param {string} matchUpFormat - optional - TODS matchUpFormat code string - defaults to 'SET3-S:6/TB7'
 * @param {object} matchUpStatusProfile - optional - whole number percent for each target matchUpStatus { [matchUpStatus]: percentLikelihood }
 * @param {integer} pointsPerMinute - optional - value used for generating timed sets scores
 * @param {integer} sideWeight - optional - the larger the number the less likely a deciding (e.g. 3rd) set is generated
 * @param {integer} winningSide - optional - 1 or 2 forces the winningSide
 * @param {integer} defaultWithScorePercent - optional - percentage of the time a DEFAULT should include a score
 *
 * @returns {object} outcome - { score, winningSide, matchUpStatus }
 */
declare function generateOutcome(params: any): {
    error: {
        message: string;
        code: string;
    };
    matchUpStatusProfile?: undefined;
    outcome?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    matchUpStatusProfile: any;
    outcome?: undefined;
} | {
    outcome: {
        score: {
            sets: never[];
            scoreStringSide1: string;
            side2ScoreString: string;
        };
        winningSide: any;
        matchUpStatus: string;
    };
    error?: undefined;
    matchUpStatusProfile?: undefined;
} | {
    outcome: {
        score: {
            sets: never[];
            scoreStringSide1: string;
            side2ScoreString: string;
        };
        matchUpStatus: string;
    };
    error?: undefined;
    matchUpStatusProfile?: undefined;
} | {
    outcome: {
        score: {
            sets: any;
            scoreStringSide1: string | {
                error?: ErrorType | undefined;
                info?: string | ErrorType | undefined;
            };
            scoreStringSide2: string | {
                error?: ErrorType | undefined;
                info?: string | ErrorType | undefined;
            };
        } | undefined;
        winningSide: any;
        matchUpStatus: string;
    };
    error?: undefined;
    matchUpStatusProfile?: undefined;
};

type ParseScoreArgs = {
    scoreString: string;
    tiebreakTo?: number;
};
type ParsedSetString = {
    winningSide: number | undefined;
    side1TiebreakScore?: number;
    side2TiebreakScore?: number;
    side1Score?: number;
    side2Score?: number;
    setNumber: number;
};
declare function parseScoreString({ tiebreakTo, scoreString, }: ParseScoreArgs): ParsedSetString[];

declare function generateParticipants(params: any): {
    participants?: any[];
    error?: ErrorType;
};

declare function generateEventWithDraw(params: any): any;

declare function modifyTournamentRecord(params: any): any;

type GenerateTournamentRecordArgs = {
    scheduleCompletedMatchUps?: boolean;
    tournamentExtensions?: Extension[];
    completeAllMatchUps?: boolean;
    tournamentName?: string;
    autoSchedule?: boolean;
    startDate?: string;
    endDate?: string;
    uuids?: string[];
    [key: string]: any;
};
declare function generateTournamentRecord(params: GenerateTournamentRecordArgs): any;

declare function anonymizeTournamentRecord({ keepExtensions, // e.g. ['level']
anonymizeParticipantNames, tournamentRecord, tournamentName, personIds, tournamentId, }: {
    keepExtensions?: never[] | undefined;
    anonymizeParticipantNames?: boolean | undefined;
    tournamentRecord: any;
    tournamentName: any;
    personIds?: never[] | undefined;
    tournamentId: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

/**
 *
 * Generates TODS score object from parseable score string
 *
 * @param {string} scoreString - parseable score string, e.g. '6-0 6-0'
 * @param {number} winningSide - optional - valid values are [1, 2, undefined]
 * @param {string=} matchUpFormat
 * @param {string=} matchUpStatus
 *
 */
declare function generateOutcomeFromScoreString(params: any): any;

type ParsedFormat = {
    finalSetFormat?: any;
    simplified?: boolean;
    exactly?: number;
    setFormat?: any;
    bestOf?: number;
};
declare function parse(matchUpFormatCode: string): ParsedFormat | undefined;

declare function stringify(matchUpFormatObject: any, preserveRedundant?: boolean): string | undefined;

declare function isValidMatchUpFormat({ matchUpFormat, }: {
    matchUpFormat: string;
}): boolean;

type GenerateVoluntaryConsolationArgs = {
    playoffAttributes?: PlayoffAttributes;
    tournamentRecord: Tournament;
    seedingProfile?: SeedingProfile;
    drawDefinition: DrawDefinition;
    matchUpType?: EventTypeUnion;
    attachConsolation?: boolean;
    applyPositioning?: boolean;
    staggeredEntry?: boolean;
    structureName?: string;
    tieFormat?: TieFormat;
    automated?: boolean;
    placeByes?: boolean;
    drawType?: string;
    isMock?: boolean;
    event?: Event$1;
};
declare function generateVoluntaryConsolation(params: GenerateVoluntaryConsolationArgs): {
    structures?: Structure[];
    links?: DrawLink[];
    success?: boolean;
    error?: ErrorType;
};

type ScaleItemsWithParticipantId = {
    participantId: string;
    scaleItems: any[];
};
type GenerateSeedingScaleItemsArgs = {
    scaleAttributes?: ScaleAttributes;
    stageEntries: Entry[];
    scaledEntries: any[];
    seedsCount: number;
    scaleName: string;
};
declare function generateSeedingScaleItems({ scaleAttributes, scaledEntries, stageEntries, seedsCount, scaleName, }: GenerateSeedingScaleItemsArgs): {
    scaleItemsWithParticipantIds?: ScaleItemsWithParticipantId[];
    error?: ErrorType;
    info?: any;
};

type GenerateQualifyingStructureArgs = {
    appliedPolicies?: PolicyDefinitions;
    qualifyingRoundNumber: number;
    drawDefinition: DrawDefinition;
    qualifyingPositions?: number;
    participantsCount?: number;
    targetStructureId: string;
    drawType?: DrawTypeUnion;
    structureOptions?: any;
    matchUpFormat?: string;
    structureName?: string;
    structureId?: string;
    roundTarget: number;
    drawSize?: number;
    idPrefix?: string;
    isMock?: boolean;
    uuids?: string[];
    event?: Event$1;
};
declare function generateQualifyingStructure(params: GenerateQualifyingStructureArgs): {
    qualifyingDrawPositionsCount?: number;
    qualifiersCount?: number;
    structure?: Structure;
    error?: ErrorType;
    success?: boolean;
    link?: DrawLink;
};

type GenerateLineUpsArgs = {
    useDefaultEventRanking?: boolean;
    tournamentRecord: Tournament;
    drawDefinition?: DrawDefinition;
    scaleAccessor: any;
    singlesOnly?: boolean;
    tieFormat?: TieFormat;
    attach?: boolean;
    event: Event$1;
};
declare function generateLineUps(params: GenerateLineUpsArgs): ResultType & {
    lineUps?: {
        [key: string]: LineUp;
    };
    participantsToAdd?: any[];
};

/**
 * @param {object} event - automatically retrieved by tournamentEngine given eventId
 * @param {string} eventId - unique identifier for event
 * @param {string} splitMethod - one of the supported methods for splitting entries
 * @param {object} scaleAttributes - { scaleName, scaleType, eventType }
 * @param {object[]} scaledEntries - pre-sorted entries
 * @param {function} scaleSortMethod - ignored if scaledEntries present
 * @param {boolean} sortDescending - ignored if scaledEntries present
 * @param {number} flightsCount - number of flights to create from existing entries
 * @param {object[]} flightValues - optional - [{ flightNumber: 1, matchUpValue: 1, flightNumber: 2, matchUpValue: 2 }]
 * @param {string[]} drawNames - array of names to be used when generating flights
 * @param {string} drawNameRoot - root word for generating flight names
 * @param {boolean} deleteExisting - if flightProfile exists then delete
 * @param {string} stage - OPTIONAL - only consider event entries matching stage
 */
type GenerateFlightProfileArgs = {
    scaleAttributes: ScaleAttributes;
    attachFlightProfile?: boolean;
    tournamentRecord: Tournament;
    deleteExisting?: boolean;
    sortDescending?: boolean;
    drawNameRoot?: string;
    scaleSortMethod?: any;
    stage?: StageTypeUnion;
    drawNames?: string[];
    scaledEntries?: any;
    flightsCount: number;
    splitMethod: string;
    uuids?: string[];
    event: Event$1;
};
declare function generateFlightProfile(params: GenerateFlightProfileArgs): {
    flightProfile?: FlightProfile;
    splitEntries?: Entry[][];
    success?: boolean;
    error?: ErrorType;
};

type GenerateDrawTypeAndModify = {
    policyDefinitions?: PolicyDefinitions;
    appliedPolicies?: PolicyDefinitions;
    finishingPositionLimit?: number;
    tournamentRecord?: Tournament;
    matchUpType?: EventTypeUnion;
    drawDefinition: DrawDefinition;
    drawTypeCoercion?: boolean;
    modifyOriginal?: boolean;
    qualifiersCount?: number;
    stageSequence?: number;
    matchUpFormat?: string;
    structureOptions?: any;
    tieFormat?: TieFormat;
    drawType?: string;
    drawSize?: number;
    feedPolicy?: any;
    isMock?: boolean;
    event?: Event$1;
};
declare function generateDrawTypeAndModifyDrawDefinition(params: GenerateDrawTypeAndModify): ResultType & {
    inContextDrawMatchUps?: HydratedMatchUp[];
    drawDefinition?: DrawDefinition;
    matchUpsMap?: MatchUpsMap;
    structures?: Structure[];
    matchUps?: MatchUp[];
    links?: DrawLink[];
    success?: boolean;
};

type GenerateDrawStructuresAndLinksArgs = {
    playoffAttributes?: PlayoffAttributes;
    appliedPolicies?: PolicyDefinitions;
    enforceMinimumDrawSize?: boolean;
    drawDefinition: DrawDefinition;
    overwriteExisting?: boolean;
    drawTypeCoercion?: boolean;
    staggeredEntry?: boolean;
    qualifyingProfiles?: any;
    structureName?: string;
    tieFormat?: TieFormat;
    matchUpType?: string;
    drawType?: string;
    drawSize?: number;
    idPrefix?: string;
    isMock?: boolean;
    uuids?: string[];
};
declare function generateDrawStructuresAndLinks(params: GenerateDrawStructuresAndLinksArgs): any;

type GenerateDrawMaticRoundArgs = {
    tournamentParticipants?: HydratedParticipant[];
    adHocRatings?: {
        [key: string]: number;
    };
    restrictEntryStatus?: boolean;
    drawDefinition: DrawDefinition;
    generateMatchUps?: boolean;
    eventType?: EventTypeUnion;
    salted?: number | boolean;
    participantIds?: string[];
    encounterValue?: number;
    sameTeamValue?: number;
    maxIterations?: number;
    matchUpIds?: string[];
    structure?: Structure;
    structureId?: string;
    scaleName?: string;
    idPrefix?: string;
    isMock?: boolean;
    drawId?: string;
    event: Event$1;
};
type DrawMaticRoundResult = {
    participantIdPairings?: string[][];
    candidatesCount?: number;
    matchUps?: MatchUp[];
    iterations?: number;
    success?: boolean;
    maxDelta?: number;
    maxDiff?: number;
};
declare function generateDrawMaticRound({ encounterValue, sameTeamValue, maxIterations, generateMatchUps, tournamentParticipants, participantIds, drawDefinition, adHocRatings, structureId, salted, matchUpIds, eventType, structure, scaleName, idPrefix, isMock, event, }: GenerateDrawMaticRoundArgs): ResultType & DrawMaticRoundResult;

type DrawMaticArgs = {
    adHocRatings?: {
        [key: string]: number;
    };
    restrictEntryStatus?: boolean;
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    generateMatchUps?: boolean;
    eventType?: EventTypeUnion;
    salted?: number | boolean;
    participantIds?: string[];
    encounterValue?: number;
    sameTeamValue?: number;
    maxIterations?: number;
    structure?: Structure;
    matchUpIds?: string[];
    structureId?: string;
    idPrefix?: string;
    isMock?: boolean;
    event: Event$1;
    scaleAccessor?: string;
    scaleName?: string;
};
declare function drawMatic(params: DrawMaticArgs): ResultType & DrawMaticRoundResult;

type GenerateDrawDefinitionArgs = {
    automated?: boolean | {
        seedsOnly: boolean;
    };
    playoffAttributes?: PlayoffAttributes;
    policyDefinitions?: PolicyDefinitions;
    voluntaryConsolation?: {
        structureAbbreviation?: string;
        structureName?: string;
        structureId?: string;
    };
    ignoreAllowedDrawTypes?: boolean;
    qualifyingPlaceholder?: boolean;
    considerEventEntries?: boolean;
    seedingProfile?: SeedingProfile;
    hydrateCollections?: boolean;
    tournamentRecord: Tournament;
    drawTypeCoercion?: boolean;
    ignoreStageSpace?: boolean;
    qualifyingProfiles?: any[];
    drawMatic?: DrawMaticArgs;
    qualifyingOnly?: boolean;
    drawType?: DrawTypeUnion;
    enforceGender?: boolean;
    processCodes?: string[];
    matchUpFormat?: string;
    matchUpType?: EventTypeUnion;
    structureName?: string;
    tieFormatName?: string;
    tieFormat?: TieFormat;
    drawEntries?: Entry[];
    roundsCount?: number;
    seedsCount?: number;
    placeByes?: boolean;
    drawName?: string;
    drawSize?: number;
    idPrefix?: string;
    isMock?: boolean;
    uuids?: string[];
    drawId?: string;
    event: Event$1;
};
declare function generateDrawDefinition(params: GenerateDrawDefinitionArgs): ResultType & {
    existingDrawDefinition?: boolean;
    qualifyingConflicts?: any[];
    positioningReports?: any[];
    drawDefinition?: DrawDefinition;
    structureId?: string;
    success?: boolean;
    error?: ErrorType;
    conflicts?: any[];
};

type GenerateCourtsArgs = {
    tournamentRecord?: Tournament;
    courtNames?: string[];
    namePrefix?: string;
    startTime?: string;
    endTime?: string;
    idPrefix?: string;
    uuids?: string[];
    dates?: string[];
    count: number;
};
type GenerateCourtsResult = {
    courts?: Court[];
};
declare function generateCourts(params: GenerateCourtsArgs): ResultType & GenerateCourtsResult;

type NamingEntry = {
    [key: string]: {
        name: string;
        abbreviation: string;
        structureId?: string;
    };
};

type GenerateAndPopulateArgs = {
    addNameBaseToAttributeName?: boolean;
    finishingPositionNaming?: NamingEntry;
    playoffStructureNameBase?: string;
    playoffAttributes?: NamingEntry;
    finishingPositionLimit?: number;
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    roundProfiles?: RoundProfile[];
    playoffPositions?: number[];
    roundOffsetLimit?: number;
    exitProfileLimit?: boolean;
    roundNumbers?: number[];
    structureId: string;
    idPrefix?: string;
    isMock?: boolean;
    uuids?: string[];
    event?: Event$1;
};
declare function generateAndPopulatePlayoffStructures(params: GenerateAndPopulateArgs): ResultType & {
    drawDefinition?: DrawDefinition;
    matchUpModifications?: any[];
    structures?: Structure[];
    links?: DrawLink[];
    success?: boolean;
};

type GenerateAdHocMatchUpsArgs = {
    participantIdPairings?: {
        participantIds: [string | undefined, string | undefined];
    }[];
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    matchUpsCount?: number;
    matchUpIds?: string[];
    roundNumber?: number;
    structureId?: string;
    newRound?: boolean;
    idPrefix?: string;
    isMock?: boolean;
    event: Event$1;
};
declare function generateAdHocMatchUps(params: GenerateAdHocMatchUpsArgs): {
    matchUpsCount?: number;
    matchUps?: MatchUp[];
    error?: ErrorType;
    info?: any;
};

type CourtGeneratorArgs = {
    startTime?: string;
    endTime?: string;
    count?: number;
    date?: string;
};
declare function courtGenerator(params?: CourtGeneratorArgs): {
    dateAvailability: {
        date: string | undefined;
        startTime: string;
        endTime: string;
    }[];
}[];

declare function getScheduleTimes(params: any): {
    scheduleTimes: ScheduleTimesResult[];
    totalMatchUps: number;
    timingProfile: any;
};

type GenerateTimeSlotsArgs = {
    includeBookingTypes?: string[];
    courtDate: any;
};
declare function generateTimeSlots({ includeBookingTypes, courtDate, }: GenerateTimeSlotsArgs): any[];

type GetCourtsAvailableAtPeriodStartArgs = {
    averageMatchUpMinutes: number;
    includeBookingTypes?: boolean;
    periodStart: string;
    courts: any[];
    date: string;
};
declare function getCourtsAvailableAtPeriodStart(params: GetCourtsAvailableAtPeriodStartArgs): {
    availableToScheduleCount: number;
};

declare function withdrawParticipantAtDrawPosition(params: any): ResultType & {
    participantId?: string | undefined;
};

type UpdateTieMatchUpScoreArgs = {
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    exitWhenNoValues?: boolean;
    matchUpsMap?: MatchUpsMap;
    matchUpStatus?: string;
    tournamentId?: string;
    removeScore?: boolean;
    matchUpId: string;
    event?: Event$1;
};
declare function updateTieMatchUpScore(params: UpdateTieMatchUpScoreArgs): {
    removeWinningSide?: boolean;
    tieFormatRemoved?: boolean;
    winningSide?: number;
    error?: ErrorType;
    success?: boolean;
    score?: any;
};

type UpdateTeamLineUpArgs = {
    drawDefinition: DrawDefinition;
    participantId: string;
    tieFormat: TieFormat;
    drawId?: string;
    lineUp: LineUp;
};
declare function updateTeamLineUp({ drawDefinition, participantId, tieFormat, lineUp, }: UpdateTeamLineUpArgs): {
    success?: boolean;
    error?: ErrorType;
};

/**
 *
 * @param {object} orderedDrawIdsMap - required - mapping of ALL present drawIds => { [drawId]: drawOrder }
 */
declare function updateDrawIdsOrder({ event, orderedDrawIdsMap }: {
    event: any;
    orderedDrawIdsMap: any;
}): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};

type ToggleParticipantCheckInStateArgs = {
    tournamentRecords?: TournamentRecords;
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    activeTournamentId?: string;
    participantId: string;
    tournamentId?: string;
    matchUpIds?: string[];
    matchUpId: string;
};
declare function toggleParticipantCheckInState(params: ToggleParticipantCheckInStateArgs): any;

/**
 *
 * @param {string} drawId - id of drawDefinition within which structure is found
 * @param {string} structureId - id of structure of drawPosition
 * @param {number[]} drawPositions - drawPositions for which participants will be swapped
 *
 */
declare function swapDrawPositionAssignments(params: any): any;

declare function substituteParticipant(params: any): ResultType | {
    error: {
        message: string;
        code: string;
    };
};

/**
 *
 * Used to order ROUND_ROBIN participants when finishingPosition ties cannot be broken algorithmically.
 * Assigns a subOrder value to a participant within a structure by drawPosition.
 */
type SetSubOrderArgs = {
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    drawPosition: number;
    structureId: string;
    subOrder: number;
    event?: Event$1;
};
declare function setSubOrder({ tournamentRecord, drawDefinition, drawPosition, structureId, subOrder, event, }: SetSubOrderArgs): ResultType;

declare function setStructureOrder({ drawDefinition, orderMap }: {
    drawDefinition: any;
    orderMap: any;
}): ResultType;

declare function setPositionAssignments(params: any): any;

declare function setOrderOfFinish(params: any): ResultType | {
    error: {
        message: string;
        code: string;
    };
};

/**
 * Sets either matchUpStatus or score and winningSide; values to be set are passed in outcome object.
 * Public API for setting matchUpStatus or score and winningSide.
 */
type SetMatchUpStatusArgs$1 = {
    tournamentRecords?: {
        [key: string]: Tournament;
    };
    policyDefinitions?: PolicyDefinitions;
    allowChangePropagation?: boolean;
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    disableAutoCalc?: boolean;
    enableAutoCalc?: boolean;
    matchUpFormat?: string;
    tournamentId?: string;
    matchUpId: string;
    eventId?: string;
    drawId?: string;
    schedule?: any;
    notes?: string;
    event?: Event$1;
    outcome?: any;
};
declare function setMatchUpStatus(params: SetMatchUpStatusArgs$1): any;

type SetMatchUpStatusArgs = {
    tournamentRecord?: Tournament;
    drawDefinition?: DrawDefinition;
    scheduledDates?: string[];
    stageSequences?: number[];
    structureIds?: string[];
    matchUpFormat: string;
    structureId?: string;
    eventIds?: string[];
    eventType?: string;
    matchUpId?: string;
    drawIds?: string[];
    stages?: string[];
    eventId?: string;
    drawId?: string;
    force?: boolean;
    event?: Event$1;
};
declare function setMatchUpFormat(params: SetMatchUpStatusArgs): ResultType | {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
    info?: string | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
} | {
    modificationsCount: number;
    success: boolean;
    error?: undefined;
};

declare function setEventStartDate({ tournamentRecord, event, startDate }: {
    tournamentRecord: any;
    event: any;
    startDate: any;
}): (ResultType & {
    tournamentStartDate?: number | undefined;
    tournamentEndDate?: number | undefined;
}) | {
    error: {
        message: string;
        code: string;
    };
};
declare function setEventEndDate({ tournamentRecord, event, endDate }: {
    tournamentRecord: any;
    event: any;
    endDate: any;
}): (ResultType & {
    tournamentStartDate?: number | undefined;
    tournamentEndDate?: number | undefined;
}) | {
    error: {
        message: string;
        code: string;
    };
};
declare function setEventDates({ tournamentRecord, event, startDate, endDate }: {
    tournamentRecord: any;
    event: any;
    startDate: any;
    endDate: any;
}): (ResultType & {
    tournamentStartDate?: number | undefined;
    tournamentEndDate?: number | undefined;
}) | {
    error: {
        message: string;
        code: string;
    };
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
};

declare function setEntryPosition({ tournamentRecord, drawDefinition, participantId, entryPosition, skipRefresh, event, }: {
    tournamentRecord: any;
    drawDefinition: any;
    participantId: any;
    entryPosition: any;
    skipRefresh: any;
    event: any;
}): ResultType | {
    error: {
        message: string;
        code: string;
    };
    entryPosition?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    entryPosition: any;
};
declare function setEntryPositions({ tournamentRecord, entryPositions, drawDefinition, event, }: {
    tournamentRecord: any;
    entryPositions: any;
    drawDefinition: any;
    event: any;
}): ResultType | {
    error: {
        message: string;
        code: string;
    };
    entryPosition?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    entryPosition: any;
};

declare function setDrawParticipantRepresentativeIds({ representativeParticipantIds, drawDefinition, }: {
    representativeParticipantIds: any;
    drawDefinition: any;
}): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};

declare function setDelegatedOutcome(params: any): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
} | {
    matchUp?: HydratedMatchUp | undefined;
    structure?: Structure | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
};

declare function resetVoluntaryConsolationStructure({ tournamentRecord, drawDefinition, resetEntries, event, }: {
    tournamentRecord: any;
    drawDefinition: any;
    resetEntries: any;
    event: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

/**
 * remove the tieFormat from a TEAM matchUp if there is a tieFormat further up the hierarchy
 * modify the matchUp's tieMatchUps to correspond to the tieFormat found further up the hierarchy
 */
type ResetTieFormatArgs = {
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    matchUpId: string;
    uuids?: string[];
    event?: Event$1;
};
declare function resetTieFormat(params: ResetTieFormatArgs): ResultType & {
    deletedMatchUpIds?: string[];
    newMatchUps?: MatchUp[];
    success?: boolean;
};

/**
 *
 * @param {string} drawDefinition - required to collect all draw matchUps for scenario analysis
 * @param {string} matchUpId - id of the matchUp to be modified
 * @param {object} score - score object { sets: [] }
 * @param {string} matchUpStatus - optional - new matchUpStatus
 * @param {number} winningSide - optional - new winningSide; 1 or 2
 * @param {object} tournamentRecord - optional - used to discover relevant policyDefinitions or to modify scheduling information (integrity checks)
 * @param {boolean} tiebreakReset - optional - check for tiebreak scenarios and reset tieFormat
 * @returns
 */
type ResetScoreCardArgs = {
    score?: {
        sets: {
            side1Score: number;
            side2Score: number;
        }[];
    };
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    tiebreakReset?: boolean;
    matchUpStatus?: string;
    winningSide?: number;
    matchUpId: string;
    event?: Event$1;
};
declare function resetScorecard(params: ResetScoreCardArgs): ResultType;

type ResetMatchUpLineUps = {
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    inheritance?: boolean;
    matchUpId: string;
    event?: Event$1;
};
declare function resetMatchUpLineUps({ inheritance, tournamentRecord, drawDefinition, matchUpId, event, }: ResetMatchUpLineUps): {
    error: {
        message: string;
        code: string;
    };
} | {
    modificationsCount: number;
    success: boolean;
    error?: undefined;
};

declare function resetDrawDefinition({ tournamentRecord, removeScheduling, drawDefinition, }: {
    tournamentRecord: any;
    removeScheduling: any;
    drawDefinition: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

type ReplaceTieMatchUpParticipantIdArgs = {
    policyDefinitions?: PolicyDefinitions;
    existingParticipantId: string;
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    newParticipantId: string;
    enforceGender?: boolean;
    substitution?: boolean;
    tieMatchUpId: string;
    event: Event$1;
};
declare function replaceTieMatchUpParticipantId(params: ReplaceTieMatchUpParticipantIdArgs): ResultType & {
    participantRemoved?: string;
    participantAdded?: string;
    modifiedLineUp?: LineUp;
};

type RenameStructuresArgs = {
    drawDefinition: DrawDefinition;
    structureDetails: {
        structureId: string;
        structureName: string;
    }[];
};
declare function renameStructures({ drawDefinition, structureDetails, }: RenameStructuresArgs): ResultType;

type RemoveTieMatchUpParticipantIdArgs = {
    policyDefinitions?: PolicyDefinitions;
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    participantId: string;
    tieMatchUpId: string;
    event: Event$1;
};
declare function removeTieMatchUpParticipantId(params: RemoveTieMatchUpParticipantIdArgs): ResultType & {
    modifiedLineUp?: LineUp;
};

type RemoveStructureArgs = {
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    structureId: string;
    force?: boolean;
    event: Event$1;
};
declare function removeStructure({ tournamentRecord, drawDefinition, structureId, event, force }: RemoveStructureArgs): {
    error: {
        message: string;
        code: string;
    };
} | {
    removedMatchUpIds: string[];
    removedStructureIds: string[];
    success: boolean;
    error?: undefined;
};

declare function removeSeeding({ tournamentRecord, drawDefinition, entryStatuses, scaleName, drawId, event, stage, }: {
    tournamentRecord: any;
    drawDefinition: any;
    entryStatuses: any;
    scaleName: any;
    drawId: any;
    event: any;
    stage: any;
}): ResultType | {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};

type RemoveSeededParticipantArgs = {
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    participantId: string;
    structureId: string;
};
declare function removeSeededParticipant({ tournamentRecord, drawDefinition, participantId, structureId, }: RemoveSeededParticipantArgs): ResultType;

/**
 *
 * @param {object} tournamentRecord - passed automatically if tournamentEngine.setState()
 * @param {string} eventId - resolves to event
 * @param {string} drawId - OPTIONAL - resolves drawDefinition - scopes participants to clear to drawDefinition.entries or flightProfile.flight.drawEntries
 * @param {string} scaleAttributes - { scaleType, scaleName, eventType }
 * @param {string} stage - OPTIONAL - filter event or draw entries by stage
 * @returns {boolean} { success: true } or { error }
 */
declare function removeScaleValues({ tournamentRecord, scaleAttributes, drawDefinition, entryStatuses, drawId, event, stage, }: {
    tournamentRecord: any;
    scaleAttributes: any;
    drawDefinition: any;
    entryStatuses: any;
    drawId: any;
    event: any;
    stage: any;
}): ResultType | {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};

type RemoveRoundMatchUpsArgs = {
    removeCompletedMatchUps?: boolean;
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    structureId: string;
    roundNumber: number;
    event: Event$1;
};
declare function removeRoundMatchUps({ removeCompletedMatchUps, tournamentRecord, drawDefinition, structureId, roundNumber, event, }: RemoveRoundMatchUpsArgs): ResultType & {
    deletedMatchUpsCount?: number;
    roundRemoved?: boolean;
};

declare function removeMatchUpSideParticipant({ tournamentRecord, drawDefinition, sideNumber, matchUpId, event, }: {
    tournamentRecord: any;
    drawDefinition: any;
    sideNumber: any;
    matchUpId: any;
    event: any;
}): {
    error: {
        message: string;
        code: string;
    };
    sideNumber?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    sideNumber: any;
} | {
    success: boolean;
    error?: undefined;
    sideNumber?: undefined;
};

type RemoveEventEntriesArgs = {
    tournamentParticipants?: HydratedParticipant[];
    entryStatuses?: EntryStatusUnion[];
    tournamentRecord?: Tournament;
    autoEntryPositions?: boolean;
    participantIds: string[];
    stage?: StageTypeUnion;
    event: Event$1;
};
declare function removeEventEntries({ autoEntryPositions, participantIds, entryStatuses, stage, event, }: RemoveEventEntriesArgs): {
    participantIdsRemoved?: string[];
    success?: boolean;
    error?: ErrorType;
};

declare function removeDrawPositionAssignment(params: any): ResultType & {
    participantId?: string;
};

declare function removeDrawEntries({ autoEntryPositions, participantIds, drawDefinition, drawId, stages, event, }: {
    autoEntryPositions?: boolean | undefined;
    participantIds: any;
    drawDefinition: any;
    drawId: any;
    stages: any;
    event: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

declare function removeDelegatedOutcome({ drawDefinition, event, matchUpId }: {
    drawDefinition: any;
    event: any;
    matchUpId: any;
}): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
    info?: any;
} | {
    error: {
        message: string;
        code: string;
    };
};

type RemoveCollectionGroupArgs = {
    updateInProgressMatchUps?: boolean;
    collectionGroupNumber: number;
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    tieFormatName?: string;
    structureId: string;
    matchUpId: string;
    matchUp?: MatchUp;
    eventId?: string;
    event?: Event$1;
};
declare function removeCollectionGroup({ updateInProgressMatchUps, collectionGroupNumber, tournamentRecord, drawDefinition, tieFormatName, structureId, matchUpId, matchUp, eventId, event, }: RemoveCollectionGroupArgs): ResultType | {
    error: {
        message: string;
        code: string;
    };
};

type RemoveCollectionDefinitionArgs = {
    updateInProgressMatchUps?: boolean;
    tieFormatComparison?: boolean;
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    tieFormatName?: string;
    collectionId: string;
    structureId?: string;
    matchUpId?: string;
    matchUp?: MatchUp;
    eventId?: string;
    event?: Event$1;
};
declare function removeCollectionDefinition({ updateInProgressMatchUps, tieFormatComparison, tournamentRecord, drawDefinition, tieFormatName, collectionId, structureId, matchUpId, eventId, matchUp, event, }: RemoveCollectionDefinitionArgs): {
    targetMatchUps?: HydratedMatchUp[];
    deletedMatchUpIds?: string[];
    tieFormat?: TieFormat;
    success?: boolean;
    error?: ErrorType;
};

declare function refreshEventDrawOrder({ tournamentRecord, event }: {
    tournamentRecord: any;
    event: any;
}): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};

/**
 *
 * @param {string} drawId - id of drawDefinition within which structure is found
 * @param {string} structureId - id of structure of drawPosition
 * @param {number} drawPosition - drawPosition where lucky loser participantId will be assigned
 * @param {string} qualifierParticipantId - id of participant
 *
 */
declare function qualifierDrawPositionAssignment(params: any): ResultType | {
    error: {
        message: string;
        code: string;
    };
};

declare function pruneDrawDefinition({ matchPlayDrawPositions, // when simply extracting matchUps for aggregation, drawPositions are unnecessary
tournamentRecord, drawDefinition, drawId, }: {
    matchPlayDrawPositions?: boolean | undefined;
    tournamentRecord: any;
    drawDefinition: any;
    drawId: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    matchUps: MatchUp[];
    success: boolean;
    error?: undefined;
};

declare function promoteAlternate(params: any): ResultType | {
    error: {
        message: string;
        code: string;
    };
    invalidEntryStatus: any;
    invalidStage?: undefined;
    invalidStageSequence?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    invalidStage: any;
    invalidEntryStatus?: undefined;
    invalidStageSequence?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    invalidStageSequence: any;
    invalidEntryStatus?: undefined;
    invalidStage?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    participantIds?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    participantIds: any;
} | {
    error: {
        message: string;
        code: string;
    };
    participantId: any;
};
declare function promoteAlternates({ tournamentRecord, drawDefinition, participantIds, stageSequence, stage, eventId, event, }: {
    tournamentRecord: any;
    drawDefinition: any;
    participantIds: any;
    stageSequence: any;
    stage?: string | undefined;
    eventId: any;
    event: any;
}): ResultType | {
    error: {
        message: string;
        code: string;
    };
    invalidEntryStatus: any;
    invalidStage?: undefined;
    invalidStageSequence?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    invalidStage: any;
    invalidEntryStatus?: undefined;
    invalidStageSequence?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    invalidStageSequence: any;
    invalidEntryStatus?: undefined;
    invalidStage?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    participantIds?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    participantIds: any;
};

type OrderCollectionDefinitionsArgs = {
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    structureId?: string;
    matchUpId?: string;
    matchUp?: MatchUp;
    eventId?: string;
    orderMap: any;
    event?: Event$1;
};
declare function orderCollectionDefinitions({ tournamentRecord, drawDefinition, structureId, matchUpId, orderMap, eventId, matchUp, event, }: OrderCollectionDefinitionsArgs): ResultType | {
    matchUp?: HydratedMatchUp | undefined;
    structure?: Structure | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};

type ModifyTieFormatArgs = {
    updateInProgressMatchUps?: boolean;
    tieFormatComparison?: boolean;
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    modifiedTieFormat: TieFormat;
    structureId?: string;
    matchUpId?: string;
    eventId?: string;
    uuids?: string[];
    event?: Event$1;
};
declare function modifyTieFormat({ updateInProgressMatchUps, tieFormatComparison, modifiedTieFormat, tournamentRecord, drawDefinition, structureId, matchUpId, eventId, uuids, event, }: ModifyTieFormatArgs): ResultType | {
    success: boolean;
    processedTieFormat: any;
    modifications: any[];
};

/**
 *
 * @param {string} drawId - id of drawDefinition within which structure occurs
 * @param {object} drawDefinition - added automatically by tournamentEngine
 * @param {string} participantId - id of participant which will receive the seedValue
 * @param {string} structureId - id of structure within drawDefinition
 * @param {string} seedValue - supports value of e.g. '5-8'
 *
 */
declare function modifySeedAssignment({ tournamentRecord, drawDefinition, participantId, structureId, seedValue, event, }: {
    tournamentRecord: any;
    drawDefinition: any;
    participantId: any;
    structureId: any;
    seedValue: any;
    event: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

declare function modifyPairAssignment({ replacementIndividualParticipantId, existingIndividualParticipantId, tournamentRecord, drawDefinition, participantId, event, uuids, }: {
    replacementIndividualParticipantId: any;
    existingIndividualParticipantId: any;
    tournamentRecord: any;
    drawDefinition: any;
    participantId: any;
    event: any;
    uuids: any;
}): any;

type ModifyEventEntriesArgs = {
    unpairedParticipantIds?: string[];
    participantIdPairs?: string[][];
    entryStatus?: EntryStatusUnion;
    tournamentRecord: Tournament;
    entryStage?: string;
    event: Event$1;
};
declare function modifyEventEntries({ entryStatus, unpairedParticipantIds, participantIdPairs, entryStage, tournamentRecord, event, }: ModifyEventEntriesArgs): any;

type ModifyEventArgs = {
    tournamentRecord: Tournament;
    eventUpdates: {
        eventType?: EventTypeUnion;
        gender?: GenderUnion;
        /**
         TODO: logic to determine if category can be changed
         Considerations:
         1) all collectionDefinitions can be contained
         2) all particiapnts have valid ages
         */
        eventName?: string;
    };
    eventId: string;
    event: Event$1;
};
declare function modifyEvent({ tournamentRecord, eventUpdates, eventId, event, }: ModifyEventArgs): ResultType;

type ModifyEntriesStatusArgs = {
    drawDefinition?: DrawDefinition;
    autoEntryPositions?: boolean;
    tournamentRecord: Tournament;
    entryStatus?: EntryStatusUnion;
    ignoreAssignment?: boolean;
    entryStage?: StageTypeUnion;
    participantIds: string[];
    extension?: Extension;
    eventSync?: boolean;
    drawId: string;
    stage?: StageTypeUnion;
    event?: Event$1;
};
declare function modifyEntriesStatus({ autoEntryPositions, ignoreAssignment, // override check for existing assignments
tournamentRecord, drawDefinition, participantIds, entryStatus, entryStage, extension, // modify the specified extension (remove if value undefined)
eventSync, drawId, stage, event, }: ModifyEntriesStatusArgs): ResultType | {
    error: {
        message: string;
        code: string;
    };
    method: string;
    participantIds: never;
} | {
    error: {
        message: string;
        code: string;
    };
    method?: undefined;
    participantIds?: undefined;
};

type ModifyDrawNameArgs = {
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    flightProfile: FlightProfile;
    drawName: string;
    drawId: string;
    event: Event$1;
};
declare function modifyDrawName({ tournamentRecord, drawDefinition, flightProfile, drawName, drawId, event, }: ModifyDrawNameArgs): ResultType & {
    flight?: Flight;
};

type ModifyDrawArgs = {
    drawUpdates: {
        drawName: string;
        policyDefinitions: PolicyDefinitions;
    };
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    drawId: string;
    event: Event$1;
};
declare function modifyDrawDefinition({ tournamentRecord, drawDefinition, drawUpdates, drawId, event, }: ModifyDrawArgs): ResultType;

type ModifyCollectionDefinitionArgs = {
    updateInProgressMatchUps?: boolean;
    tournamentRecord?: Tournament;
    drawDefinition?: DrawDefinition;
    collectionOrder?: number;
    collectionName?: string;
    tieFormatName?: string;
    matchUpFormat?: string;
    matchUpType?: EventTypeUnion;
    matchUpCount?: number;
    gender?: GenderUnion;
    collectionId: string;
    structureId?: string;
    category?: Category;
    matchUpId?: string;
    eventId?: string;
    event?: Event$1;
    collectionValueProfiles?: CollectionValueProfile[];
    collectionValue?: number;
    matchUpValue?: number;
    scoreValue?: number;
    setValue?: number;
};
declare function modifyCollectionDefinition({ updateInProgressMatchUps, tournamentRecord, collectionOrder, collectionName, tieFormatName, drawDefinition, matchUpFormat, matchUpCount, collectionId, matchUpType, structureId, matchUpId, category, eventId, gender, event, collectionValueProfiles, collectionValue, matchUpValue, scoreValue, setValue, }: ModifyCollectionDefinitionArgs): ResultType & {
    tieFormat?: TieFormat;
    modifications?: any[];
};

/**
 *
 * @param {string} drawId - id of drawDefinition within which structure is found
 * @param {string} structureId - id of structure of drawPosition
 * @param {number} drawPosition - drawPosition where lucky loser participantId will be assigned
 * @param {string} luckyLoserParticipantId - id of participant
 *
 */
declare function luckyLoserDrawPositionAssignment(params: any): ResultType | {
    error: {
        message: string;
        code: string;
    };
};

type GetAvailablePlayoffProfileArgs = {
    drawDefinition: DrawDefinition;
    structureId?: string;
};
declare function getAvailablePlayoffProfiles({ drawDefinition, structureId }: GetAvailablePlayoffProfileArgs): any;

declare function enableTieAutoCalc({ tournamentRecord, drawDefinition, matchUpId, event, }: {
    tournamentRecord: any;
    drawDefinition: any;
    matchUpId: any;
    event: any;
}): any;

declare function disableTieAutoCalc({ drawDefinition, matchUpId, event }: {
    drawDefinition: any;
    matchUpId: any;
    event: any;
}): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};

/**
 *
 * @param {object} tournamentRecord - passed in by tournamentEngine
 * @param {string} participantId - id of TEAM/PAIR participant to remove
 * @param {string} eventId - resolved to { event } by tournamentEngine
 * @param {string} drawId - optional - resolved to { drawDefinition }
 * @param {boolean} removeGroupParticipant - whether to also remove grouping participant from tournamentRecord.participants
 *
 */
type DestroyPairEntryArgs = {
    removeGroupParticipant?: boolean;
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    participantId: string;
    drawId?: string;
    event: Event$1;
};
declare function destroyPairEntry({ removeGroupParticipant, tournamentRecord, drawDefinition, participantId, drawId, event, }: DestroyPairEntryArgs): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
    participantRemoved?: boolean | undefined;
};
declare function destroyPairEntries(params: any): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    destroyedCount: number;
    error?: undefined;
} | {
    error: any[];
};

declare function deleteFlightProfileAndFlightDraws({ autoPublish, tournamentRecord, auditData, event, force, }: {
    autoPublish?: boolean | undefined;
    tournamentRecord: any;
    auditData: any;
    event: any;
    force: any;
}): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
    info?: any;
} | {
    error: {
        message: string;
        code: string;
    };
};

declare function deleteFlightAndFlightDraw({ autoPublish, tournamentRecord, auditData, drawId, event, force, }: {
    autoPublish?: boolean | undefined;
    tournamentRecord: any;
    auditData: any;
    drawId: any;
    event: any;
    force: any;
}): ResultType | {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};

declare function deleteEvents({ removePairParticipants, tournamentRecord, eventIds, }: {
    removePairParticipants: any;
    tournamentRecord: any;
    eventIds: any;
}): {
    error: {
        message: string;
        code: string;
    };
    info?: undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    info: string;
} | {
    success: boolean;
    error?: undefined;
    info?: undefined;
};

type DeleteDrawDefinitionArgs = {
    policyDefinitions?: PolicyDefinitions;
    tournamentRecord: Tournament;
    autoPublish?: boolean;
    drawIds?: string[];
    auditData?: any;
    eventId?: string;
    force?: boolean;
    event?: Event$1;
};
declare function deleteDrawDefinitions(params: DeleteDrawDefinitionArgs): ResultType | {
    error: {
        message: string;
        code: string;
    };
};

type DeleteAdHocMatchUpsArgs = {
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    matchUpIds?: string[];
    structureId: string;
    event?: Event$1;
};
declare function deleteAdHocMatchUps({ tournamentRecord, matchUpIds, drawDefinition, structureId, event, }: DeleteAdHocMatchUpsArgs): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

declare function checkOutParticipant(params: CheckInOutParticipantArgs): any;

declare function checkInParticipant(params: CheckInOutParticipantArgs): any;

declare function bulkMatchUpStatusUpdate(params: any): any;

/**
 *
 * @param {object} tournamentRecord - passed automatically if tournamentEngine.setState() has been called
 * @param {string} eventId - resolved by tournamentEngine to the event object
 *
 * @param {object} policyDefinitions - seeding policyDefinitions determines the # of seeds for given participantsCount/drawSize
 * @param {object} scaleAttributes -
 * @param {string} scaleName - OPTIONAL - defaults to scaleAttributes.scaleName
 * @param {number} drawSize - OPTIONAL - defaults to calculation based on # of entries
 * @param {string} drawId - OPTIONAL - will use flight.drawEntries or drawDefinition.entries rather than event.entries
 * @param {string} stage - OPTIONAL - filters entries by specified stage
 *
 * @param {boolean} sortDescending - OPTIONAL - defaults to false
 * @param {function} scaleSortMethod - OPTIONAL - user defined sorting method
 *
 * @returns {object} - { success: true } or { error }
 */
declare function autoSeeding({ tournamentRecord, drawDefinition, policyDefinitions, scaleAttributes, scaleName, drawSize, drawId, event, stage, sortDescending, scaleSortMethod, }: {
    tournamentRecord: any;
    drawDefinition: any;
    policyDefinitions: any;
    scaleAttributes: any;
    scaleName: any;
    drawSize: any;
    drawId: any;
    event: any;
    stage: any;
    sortDescending: any;
    scaleSortMethod: any;
}): {
    stageEntries?: Entry[] | undefined;
    seedsCount?: number | undefined;
    entries?: Entry[] | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
    scaleItemsWithParticipantIds?: undefined;
} | {
    scaleItemsWithParticipantIds: {
        participantId: string;
        scaleItems: any[];
    }[] | undefined;
    error?: undefined;
};

type AutomatedPositioningArgs = {
    inContextDrawMatchUps?: HydratedMatchUp[];
    appliedPolicies?: PolicyDefinitions;
    provisionalPositioning?: boolean;
    seedingProfile?: SeedingProfile;
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    multipleStructures?: boolean;
    applyPositioning?: boolean;
    matchUpsMap?: MatchUpsMap;
    placementGroup?: number;
    placeByes?: boolean;
    structureId: string;
    seedsOnly?: boolean;
    seedLimit?: number;
    drawType?: string;
    drawSize?: number;
    event?: Event$1;
};
declare function automatedPositioning({ applyPositioning, provisionalPositioning, inContextDrawMatchUps, multipleStructures, placeByes, tournamentRecord, appliedPolicies, placementGroup, drawDefinition, seedingProfile, structureId, matchUpsMap, seedLimit, seedsOnly, drawType, drawSize, event, }: AutomatedPositioningArgs): ResultType & {
    positionAssignments?: PositionAssignment[];
    positioningReport?: {
        [key: string]: any;
    }[];
    success?: boolean;
    conflicts?: any[];
};

type StructurePositionAssignmentType = {
    positionAssignments: PositionAssignment[];
    structureId: string;
};
type AutomatedPlayoffPositioningArgs = {
    provisionalPositioning?: boolean;
    seedingProfile?: SeedingProfile;
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    applyPositioning?: boolean;
    structureId: string;
    placeByes?: boolean;
    seedsOnly?: boolean;
    event: Event$1;
};
declare function automatedPlayoffPositioning(params: AutomatedPlayoffPositioningArgs): {
    structurePositionAssignments?: StructurePositionAssignmentType[];
    positioningReports?: {
        [key: string]: any;
    }[];
    success?: boolean;
    error?: ErrorType;
};

declare function attachQualifyingStructure({ tournamentRecord, drawDefinition, structure, link, }: {
    tournamentRecord: any;
    drawDefinition: any;
    structure: any;
    link: any;
}): ResultType | {
    error: {
        message: string;
        code: string;
    };
};

declare function attachFlightProfile({ deleteExisting, event, flightProfile }: {
    deleteExisting: any;
    event: any;
    flightProfile: any;
}): ResultType | {
    success: boolean;
    flightProfile: any;
};

declare function attachConsolationStructures(params: any): ResultType & {
    addedStructureIds?: string[] | undefined;
};
declare function attachPlayoffStructures(params: any): ResultType & {
    addedStructureIds?: string[] | undefined;
};
type AttachStructuresArgs = {
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    matchUpModifications?: any[];
    structures: Structure[];
    links?: DrawLink[];
    itemType?: string;
    event?: Event$1;
};
declare function attachStructures({ itemType, matchUpModifications, tournamentRecord, drawDefinition, structures, links, event, }: AttachStructuresArgs): ResultType & {
    addedStructureIds?: string[];
};

type AssignMatchUpSideParticipantIdArgs = {
    policyDefinitions?: PolicyDefinitions;
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    teamParticipantId?: string;
    enforceGender?: boolean;
    participantId: string;
    tieMatchUpId: string;
    sideNumber?: number;
    event: Event$1;
};
declare function assignTieMatchUpParticipantId(params: AssignMatchUpSideParticipantIdArgs): ResultType & {
    deletedParticipantId?: string;
    modifiedLineUp?: LineUp;
};

type AssignSeedPositionsArgs = {
    provisionalPositioning?: boolean;
    useExistingSeedLimit?: boolean;
    seedingProfile?: SeedingProfile;
    assignments: SeedAssignment[];
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    structureId: string;
    drawId: string;
    event: Event;
};
declare function assignSeedPositions(params: AssignSeedPositionsArgs): ResultType | {
    modifications?: number;
    success?: boolean;
};

type AssignMatchUpSideParticipantArgs = {
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    participantId: string;
    sideNumber: number;
    matchUpId: string;
    event: Event$1;
};
declare function assignMatchUpSideParticipant({ tournamentRecord, drawDefinition, participantId, sideNumber, matchUpId, event, }: AssignMatchUpSideParticipantArgs): ResultType & {
    sidesSwapped?: boolean;
};

type AssignDrawPositionByeArgs = {
    provisionalPositioning?: boolean;
    tournamentRecord?: Tournament;
    drawDefinition: DrawDefinition;
    isPositionAction?: boolean;
    matchUpsMap?: MatchUpsMap;
    structure?: Structure;
    drawPosition: number;
    structureId?: string;
    event?: Event$1;
};
declare function assignDrawPositionBye({ provisionalPositioning, isPositionAction, tournamentRecord, drawDefinition, drawPosition, matchUpsMap, structureId, structure, event, }: AssignDrawPositionByeArgs): any;

declare function assignDrawPosition({ tournamentRecord, drawDefinition, participantId, drawPosition, structureId, qualifier, event, bye, }: {
    tournamentRecord: any;
    drawDefinition: any;
    participantId: any;
    drawPosition: any;
    structureId: any;
    qualifier: any;
    event: any;
    bye: any;
}): any;

declare function applyLineUps({ tournamentRecord, drawDefinition, matchUpId, lineUps, event, }: {
    tournamentRecord: any;
    drawDefinition: any;
    matchUpId: any;
    lineUps: any;
    event: any;
}): any;

/**
 *
 * @param {string} drawId - id of drawDefinition within which structure is found
 * @param {string} structureId - id of structure of drawPosition
 * @param {number} drawPosition - drawPosition where alternate participantId will be assigned
 * @param {string} alternateParticipantId - id of participant
 *
 */
declare function alternateDrawPositionAssignment(params: any): ResultType | {
    error: {
        message: string;
        code: string;
    };
};

type AggreateTieFormatsArgs = {
    tournamentRecord: Tournament;
};
declare function aggregateTieFormats({ tournamentRecord, }: AggreateTieFormatsArgs): ResultType & {
    addedCount?: number;
};

type AddVoluntaryConsolationStructureArgs = {
    structureAbbreviation?: string;
    drawDefinition: DrawDefinition;
    structureName?: string;
    matchUpType?: string;
    structureId?: string;
};
declare function addVoluntaryConsolationStructure({ structureName, structureAbbreviation, drawDefinition, matchUpType, structureId, }: AddVoluntaryConsolationStructureArgs): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

declare function addVoluntaryConsolationStage(params: any): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
};

type AddQualifyingstructureArgs = {
    qualifyingRoundNumber: number;
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    qualifyingPositions: number;
    targetStructureId: string;
    roundTarget: number;
    structureName: string;
    matchUpType: string;
    drawSize: number;
    drawType: string;
    eventId: string;
    event: Event$1;
};
declare function addQualifyingStructure(params: AddQualifyingstructureArgs): ResultType | {
    error: {
        message: string;
        code: string;
    };
} | {
    qualifyingDrawPositionsCount?: number | undefined;
    qualifiersCount?: number | undefined;
    structure?: Structure | undefined;
    error?: ErrorType | undefined;
    success?: boolean | undefined;
    link?: DrawLink | undefined;
};

declare function addPlayoffStructures(params: any): ResultType & {
    addedStructureIds?: string[] | undefined;
};

type AddFlightArgs = {
    qualifyingPositions?: number;
    drawEntries?: Entry[];
    drawName?: string;
    drawId: string;
    stage?: string;
    event: Event$1;
};
declare function addFlight({ qualifyingPositions, drawEntries, // [{ entryPosition, entryStatus, participantId }]
drawName, drawId, event, stage, }: AddFlightArgs): {
    success?: boolean | undefined;
    error?: ErrorType | undefined;
} | {
    error: {
        message: string;
        code: string;
    };
};

/**
 * Add PAIR participant to an event
 * Creates new { participantType: PAIR } participants if necessary
 */
type AddEventEntryPairsArgs = {
    allowDuplicateParticipantIdPairs?: boolean;
    participantIdPairs?: string[][];
    entryStatus?: EntryStatusUnion;
    tournamentRecord: Tournament;
    drawDefinition: DrawDefinition;
    entryStage?: StageTypeUnion;
    uuids?: string[];
    event: Event$1;
};
declare function addEventEntryPairs({ allowDuplicateParticipantIdPairs, entryStage, entryStatus, participantIdPairs, tournamentRecord, drawDefinition, event, uuids, }: AddEventEntryPairsArgs): any;

/**
 * Add entries into an event; optionally add to specified drawDefinition/flightProfile, if possible.
 */
type AddEventEntriesArgs = {
    policyDefinitions?: PolicyDefinitions;
    drawDefinition?: DrawDefinition;
    entryStatus?: EntryStatusUnion;
    autoEntryPositions?: boolean;
    tournamentRecord: Tournament;
    entryStageSequence?: number;
    ignoreStageSpace?: boolean;
    entryStage?: StageTypeUnion;
    participantIds?: string[];
    extensions?: Extension[];
    enforceGender?: boolean;
    extension?: Extension;
    roundTarget?: number;
    drawId?: string;
    event: Event$1;
};
declare function addEventEntries(params: AddEventEntriesArgs): ResultType;

type AddEventArgs = {
    suppressNotifications?: boolean;
    tournamentRecord: Tournament;
    internalUse?: boolean;
    event: any;
};
declare function addEvent({ suppressNotifications, tournamentRecord, internalUse, event }: AddEventArgs): {
    context?: {
        [key: string]: any;
    };
    error?: ErrorType;
    event?: Event$1;
    info?: any;
};

declare function addDrawEntries({ autoEntryPositions, entryStageSequence, ignoreStageSpace, drawDefinition, participantIds, entryStatus, roundTarget, entryStage, extension, drawId, event, }: {
    autoEntryPositions?: boolean | undefined;
    entryStageSequence: any;
    ignoreStageSpace: any;
    drawDefinition: any;
    participantIds: any;
    entryStatus: any;
    roundTarget: any;
    entryStage: any;
    extension: any;
    drawId: any;
    event: any;
}): ResultType | {
    error: {
        message: string;
        code: string;
    };
};

declare function addDrawDefinitionTimeItem({ drawDefinition, timeItem }: {
    drawDefinition: any;
    timeItem: any;
}): {
    error: {
        message: string;
        code: string;
    };
} | {
    success: boolean;
    error?: undefined;
};

type AddDrawDefinitionArgs = {
    flight?: {
        flightNumber: number;
    };
    suppressNotifications?: boolean;
    tournamentRecord?: Tournament;
    modifyEventEntries?: boolean;
    drawDefinition: DrawDefinition;
    existingDrawCount?: number;
    allowReplacement?: boolean;
    checkEntryStatus?: boolean;
    tournamentId?: string;
    event: Event$1;
};
declare function addDrawDefinition(params: AddDrawDefinitionArgs): ResultType & {
    modifiedEventEntryStatusCount?: number;
};

declare function addCollectionGroup({ updateInProgressMatchUps, tournamentRecord, groupDefinition, drawDefinition, collectionIds, tieFormatName, structureId, matchUpId, matchUp, eventId, event, }: {
    updateInProgressMatchUps?: boolean | undefined;
    tournamentRecord: any;
    groupDefinition: any;
    drawDefinition: any;
    collectionIds: any;
    tieFormatName: any;
    structureId: any;
    matchUpId: any;
    matchUp: any;
    eventId: any;
    event: any;
}): ResultType | {
    error: {
        message: string;
        code: string;
    };
};

type AddCollectionDefinitionArgs = {
    collectionDefinition: CollectionDefinition;
    policyDefinitions?: PolicyDefinitions;
    updateInProgressMatchUps?: boolean;
    referenceGender?: GenderUnion;
    drawDefinition: DrawDefinition;
    referenceCategory?: Category;
    tournamentRecord: Tournament;
    enforceCategory?: boolean;
    enforceGender?: boolean;
    tieFormatName?: string;
    structureId?: string;
    matchUpId?: string;
    matchUp?: MatchUp;
    eventId?: string;
    uuids?: string[];
    event?: Event$1;
};
declare function addCollectionDefinition({ updateInProgressMatchUps, collectionDefinition, referenceCategory, tournamentRecord, policyDefinitions, enforceCategory, referenceGender, drawDefinition, tieFormatName, enforceGender, structureId, matchUpId, matchUp, eventId, uuids, event, }: AddCollectionDefinitionArgs): ResultType & {
    tieFormat?: TieFormat;
    targetMatchUps?: any;
    addedMatchUps?: any;
};

declare function addAdHocMatchUps({ tournamentRecord, drawDefinition, structureId, matchUps, }: {
    tournamentRecord: any;
    drawDefinition: any;
    structureId: any;
    matchUps: any;
}): ResultType;

/**
 * Links all tournaments which are currently loaded into competitionEngine state
 */
declare function linkTournaments({ tournamentRecords, }: {
    tournamentRecords: TournamentRecords;
}): ResultType;
type UnlinkTournamentsArgs = {
    tournamentRecords: TournamentRecords;
};
declare function unlinkTournaments({ tournamentRecords, }: UnlinkTournamentsArgs): ResultType;
type UnlinkTournamentArgs = {
    tournamentRecords: TournamentRecords;
    tournamentId: string;
};
declare function unlinkTournament({ tournamentRecords, tournamentId, }: UnlinkTournamentArgs): ResultType;

declare const governors: {
    competitionGovernor: {
        linkTournaments: typeof linkTournaments;
        unlinkTournament: typeof unlinkTournament;
        unlinkTournaments: typeof unlinkTournaments;
    };
    eventGovernor: {
        addAdHocMatchUps: typeof addAdHocMatchUps;
        addCollectionDefinition: typeof addCollectionDefinition;
        addCollectionGroup: typeof addCollectionGroup;
        addDrawDefinition: typeof addDrawDefinition;
        addDrawDefinitionTimeItem: typeof addDrawDefinitionTimeItem;
        addDrawEntries: typeof addDrawEntries;
        addEvent: typeof addEvent;
        addEventEntries: typeof addEventEntries;
        addEventEntryPairs: typeof addEventEntryPairs;
        addFlight: typeof addFlight;
        addPlayoffStructures: typeof addPlayoffStructures;
        addQualifyingStructure: typeof addQualifyingStructure;
        addVoluntaryConsolationStage: typeof addVoluntaryConsolationStage;
        addVoluntaryConsolationStructure: typeof addVoluntaryConsolationStructure;
        aggregateTieFormats: typeof aggregateTieFormats;
        alternateDrawPositionAssignment: typeof alternateDrawPositionAssignment;
        applyLineUps: typeof applyLineUps;
        assignDrawPosition: typeof assignDrawPosition;
        assignDrawPositionBye: typeof assignDrawPositionBye;
        assignMatchUpSideParticipant: typeof assignMatchUpSideParticipant;
        assignSeedPositions: typeof assignSeedPositions;
        assignTieMatchUpParticipantId: typeof assignTieMatchUpParticipantId;
        attachConsolationStructures: typeof attachConsolationStructures;
        attachFlightProfile: typeof attachFlightProfile;
        attachPlayoffStructures: typeof attachPlayoffStructures;
        attachQualifyingStructure: typeof attachQualifyingStructure;
        attachStructures: typeof attachStructures;
        automatedPlayoffPositioning: typeof automatedPlayoffPositioning;
        automatedPositioning: typeof automatedPositioning;
        autoSeeding: typeof autoSeeding;
        bulkMatchUpStatusUpdate: typeof bulkMatchUpStatusUpdate;
        checkInParticipant: typeof checkInParticipant;
        checkOutParticipant: typeof checkOutParticipant;
        deleteAdHocMatchUps: typeof deleteAdHocMatchUps;
        deleteDrawDefinitions: typeof deleteDrawDefinitions;
        deleteEvents: typeof deleteEvents;
        deleteFlightAndFlightDraw: typeof deleteFlightAndFlightDraw;
        deleteFlightProfileAndFlightDraws: typeof deleteFlightProfileAndFlightDraws;
        destroyPairEntries: typeof destroyPairEntries;
        destroyPairEntry: typeof destroyPairEntry;
        disableTieAutoCalc: typeof disableTieAutoCalc;
        drawMatic: typeof drawMatic;
        enableTieAutoCalc: typeof enableTieAutoCalc;
        getAvailablePlayoffProfiles: typeof getAvailablePlayoffProfiles;
        getAvailablePlayoffRounds: typeof getAvailablePlayoffProfiles;
        luckyLoserDrawPositionAssignment: typeof luckyLoserDrawPositionAssignment;
        modifyCollectionDefinition: typeof modifyCollectionDefinition;
        modifyDrawDefinition: typeof modifyDrawDefinition;
        modifyDrawName: typeof modifyDrawName;
        modifyEntriesStatus: typeof modifyEntriesStatus;
        modifyEvent: typeof modifyEvent;
        modifyEventEntries: typeof modifyEventEntries;
        modifyPairAssignment: typeof modifyPairAssignment;
        modifySeedAssignment: typeof modifySeedAssignment;
        modifyTieFormat: typeof modifyTieFormat;
        orderCollectionDefinitions: typeof orderCollectionDefinitions;
        promoteAlternate: typeof promoteAlternate;
        promoteAlternates: typeof promoteAlternates;
        pruneDrawDefinition: typeof pruneDrawDefinition;
        qualifierDrawPositionAssignment: typeof qualifierDrawPositionAssignment;
        refreshEventDrawOrder: typeof refreshEventDrawOrder;
        removeCollectionDefinition: typeof removeCollectionDefinition;
        removeCollectionGroup: typeof removeCollectionGroup;
        removeDelegatedOutcome: typeof removeDelegatedOutcome;
        removeDrawEntries: typeof removeDrawEntries;
        removeDrawPositionAssignment: typeof removeDrawPositionAssignment;
        removeEventEntries: typeof removeEventEntries;
        removeMatchUpSideParticipant: typeof removeMatchUpSideParticipant;
        removeRoundMatchUps: typeof removeRoundMatchUps;
        removeScaleValues: typeof removeScaleValues;
        removeSeededParticipant: typeof removeSeededParticipant;
        removeSeeding: typeof removeSeeding;
        removeStructure: typeof removeStructure;
        removeTieMatchUpParticipantId: typeof removeTieMatchUpParticipantId;
        renameStructures: typeof renameStructures;
        replaceTieMatchUpParticipantId: typeof replaceTieMatchUpParticipantId;
        resetDrawDefinition: typeof resetDrawDefinition;
        resetMatchUpLineUps: typeof resetMatchUpLineUps;
        resetScorecard: typeof resetScorecard;
        resetTieFormat: typeof resetTieFormat;
        resetVoluntaryConsolationStructure: typeof resetVoluntaryConsolationStructure;
        setDelegatedOutcome: typeof setDelegatedOutcome;
        setDrawParticipantRepresentativeIds: typeof setDrawParticipantRepresentativeIds;
        setEntryPosition: typeof setEntryPosition;
        setEntryPositions: typeof setEntryPositions;
        setEventDates: typeof setEventDates;
        setEventEndDate: typeof setEventEndDate;
        setEventStartDate: typeof setEventStartDate;
        setMatchUpFormat: typeof setMatchUpFormat;
        setMatchUpStatus: typeof setMatchUpStatus;
        setOrderOfFinish: typeof setOrderOfFinish;
        setPositionAssignments: typeof setPositionAssignments;
        setStructureOrder: typeof setStructureOrder;
        setSubOrder: typeof setSubOrder;
        substituteParticipant: typeof substituteParticipant;
        swapDrawPositionAssignments: typeof swapDrawPositionAssignments;
        toggleParticipantCheckInState: typeof toggleParticipantCheckInState;
        updateDrawIdsOrder: typeof updateDrawIdsOrder;
        updateTeamLineUp: typeof updateTeamLineUp;
        updateTieMatchUpScore: typeof updateTieMatchUpScore;
        withdrawParticipantAtDrawPosition: typeof withdrawParticipantAtDrawPosition;
    };
    generationGovernor: {
        garman: {
            getCourtsAvailableAtPeriodStart: typeof getCourtsAvailableAtPeriodStart;
            generateTimeSlots: typeof generateTimeSlots;
            getScheduleTimes: typeof getScheduleTimes;
            courtGenerator: typeof courtGenerator;
        };
        generateAdHocMatchUps: typeof generateAdHocMatchUps;
        generateAndPopulatePlayoffStructures: typeof generateAndPopulatePlayoffStructures;
        generateCourts: typeof generateCourts;
        generateDrawDefinition: typeof generateDrawDefinition;
        generateDrawMaticRound: typeof generateDrawMaticRound;
        generateDrawStructuresAndLinks: typeof generateDrawStructuresAndLinks;
        generateDrawTypeAndModifyDrawDefinition: typeof generateDrawTypeAndModifyDrawDefinition;
        generateFlightProfile: typeof generateFlightProfile;
        generateLineUps: typeof generateLineUps;
        generateQualifyingStructure: typeof generateQualifyingStructure;
        generateSeedingScaleItems: typeof generateSeedingScaleItems;
        generateVoluntaryConsolation: typeof generateVoluntaryConsolation;
    };
    matchUpFormatGovernor: {
        isValid: typeof isValidMatchUpFormat;
        isValidMatchUpFormat: typeof isValidMatchUpFormat;
        stringify: typeof stringify;
        parse: typeof parse;
    };
    mocksGovernor: {
        generateOutcomeFromScoreString: typeof generateOutcomeFromScoreString;
        anonymizeTournamentRecord: typeof anonymizeTournamentRecord;
        generateTournamentRecord: typeof generateTournamentRecord;
        modifyTournamentRecord: typeof modifyTournamentRecord;
        generateEventWithDraw: typeof generateEventWithDraw;
        generateParticipants: typeof generateParticipants;
        parseScoreString: typeof parseScoreString;
        generateOutcome: typeof generateOutcome;
        credits: typeof credits;
    };
    participantGovernor: {
        addIndividualParticipantIds: typeof addIndividualParticipantIds;
        addParticipant: typeof addParticipant;
        addParticipants: typeof addParticipants;
        addPenalty: typeof addPenalty;
        addPersons: typeof addPersons;
        createGroupParticipant: typeof createGroupParticipant;
        createTeamsFromParticipantAttributes: typeof createTeamsFromParticipantAttributes;
        deleteParticipants: typeof deleteParticipants;
        filterParticipants: typeof filterParticipants;
        mergeParticipants: typeof mergeParticipants;
        modifyIndividualParticipantIds: typeof modifyIndividualParticipantIds;
        modifyParticipant: typeof modifyParticipant;
        modifyParticipantName: typeof modifyParticipantName;
        modifyParticipantOtherName: typeof modifyParticipantOtherName;
        modifyParticipantsSignInStatus: typeof modifyParticipantsSignInStatus;
        modifyPenalty: typeof modifyPenalty;
        regenerateParticipantNames: typeof regenerateParticipantNames;
        removeIndividualParticipantIds: typeof removeIndividualParticipantIds;
        removeParticipantIdsFromAllTeams: typeof removeParticipantIdsFromAllTeams;
        removePenalty: typeof removePenalty;
        scaledTeamAssignment: typeof scaledTeamAssignment;
        setParticipantScaleItem: typeof setParticipantScaleItem;
        setParticipantScaleItems: typeof setParticipantScaleItems;
    };
    policyGovernor: {
        attachPolicies: typeof attachPolicies;
        removePolicy: typeof removePolicy;
    };
    publishingGovernor: {
        getAllEventData: typeof getAllEventData;
        getCourtInfo: typeof getCourtInfo;
        getDrawData: typeof getDrawData;
        getEventData: typeof getEventData;
        getPublishState: typeof getPublishState;
        getVenueData: typeof getVenueData;
        publishEvent: typeof publishEvent;
        publishEventSeeding: typeof publishEventSeeding;
        publishOrderOfPlay: typeof publishOrderOfPlay;
        setEventDisplay: typeof setEventDisplay;
        unPublishEvent: typeof unPublishEvent;
        unPublishEventSeeding: typeof unPublishEventSeeding;
        unPublishOrderOfPlay: typeof unPublishOrderOfPlay;
    };
    queryGovernor: {
        allCompetitionMatchUps: typeof allCompetitionMatchUps;
        allDrawMatchUps: typeof allDrawMatchUps;
        allEventMatchUps: typeof allEventMatchUps;
        allTournamentMatchUps: typeof allTournamentMatchUps;
        analyzeDraws: typeof analyzeDraws;
        analyzeMatchUp: typeof analyzeMatchUp;
        analyzeTournament: typeof analyzeTournament;
        bulkUpdatePublishedEventIds: typeof bulkUpdatePublishedEventIds;
        categoryCanContain: typeof categoryCanContain;
        checkMatchUpIsComplete: typeof checkMatchUpIsComplete;
        checkValidEntries: typeof checkValidEntries;
        competitionScheduleMatchUps: typeof competitionScheduleMatchUps;
        credits: typeof credits;
        drawMatchUps: typeof drawMatchUps;
        eventMatchUps: typeof eventMatchUps;
        findDrawDefinition: ({ tournamentRecord, drawDefinition }: {
            tournamentRecord: any;
            drawDefinition: any;
        }) => {
            error: {
                message: string;
                code: string;
            };
            drawDefinition?: undefined;
        } | {
            drawDefinition: any;
            error?: undefined;
        };
        findExtension: typeof findExtension;
        findMatchUp: typeof publicFindMatchUp;
        findParticipant: typeof publicFindParticipant;
        findPolicy: typeof findPolicy;
        getAllDrawMatchUps: typeof getAllDrawMatchUps;
        getAllowedDrawTypes: typeof getAllowedDrawTypes;
        getAllowedMatchUpFormats: typeof getAllowedMatchUpFormats;
        getAppliedPolicies: typeof getAppliedPolicies;
        getAssignedParticipantIds: typeof getAssignedParticipantIds;
        getCompetitionDateRange: typeof getCompetitionDateRange;
        getCompetitionMatchUps: typeof getCompetitionMatchUps;
        getCompetitionParticipants: typeof getCompetitionParticipants;
        getCompetitionPenalties: typeof getCompetitionPenalties;
        getCompetitionVenues: typeof getCompetitionVenues;
        getCourts: typeof getCourts;
        getDrawDefinitionTimeItem: typeof getDrawDefinitionTimeItem;
        getDrawParticipantRepresentativeIds: typeof getDrawParticipantRepresentativeIds;
        getDrawTypeCoercion: typeof getDrawTypeCoercion;
        getEligibleVoluntaryConsolationParticipants: typeof getEligibleVoluntaryConsolationParticipants;
        getEntriesAndSeedsCount: typeof getEntriesAndSeedsCount;
        getEvent: typeof getEvent;
        getEventMatchUpFormatTiming: typeof getEventMatchUpFormatTiming;
        getEventProperties: typeof getEventProperties;
        getEvents: typeof getEvents;
        getEventStructures: typeof getEventStructures;
        getEventTimeItem: typeof getEventTimeItem;
        getFlightProfile: typeof getFlightProfile;
        getLinkedTournamentIds: typeof getLinkedTournamentIds;
        getMatchUpCompetitiveProfile: typeof getMatchUpCompetitiveProfile;
        getMatchUpDailyLimits: typeof getMatchUpDailyLimits;
        getMatchUpDailyLimitsUpdate: typeof getMatchUpDailyLimitsUpdate;
        getMatchUpDependencies: typeof getMatchUpDependencies;
        getMatchUpFormat: typeof getMatchUpFormat;
        getMatchUpFormatTiming: typeof getMatchUpFormatTiming;
        getMatchUpFormatTimingUpdate: typeof getMatchUpFormatTimingUpdate;
        getMatchUpScheduleDetails: typeof getMatchUpScheduleDetails;
        getMatchUpsStats: typeof getMatchUpsStats;
        getMatchUpType: typeof getMatchUpType;
        getMaxEntryPosition: typeof getMaxEntryPosition;
        getModifiedMatchUpFormatTiming: typeof getModifiedMatchUpFormatTiming;
        getPairedParticipant: typeof getPairedParticipant;
        getParticipantEventDetails: typeof getParticipantEventDetails;
        getParticipantIdFinishingPositions: typeof getParticipantIdFinishingPositions;
        getParticipantMembership: typeof getParticipantMembership;
        getParticipants: typeof getParticipants;
        getParticipantScaleItem: typeof getParticipantScaleItem;
        getParticipantSchedules: typeof getParticipantSchedules;
        getParticipantSignInStatus: typeof getParticipantSignInStatus;
        getParticipantTimeItem: typeof getParticipantTimeItem;
        getPersonRequests: typeof getPersonRequests;
        getPolicyDefinitions: typeof getPolicyDefinitions;
        getPositionAssignments: typeof getPositionAssignments;
        getPredictiveAccuracy: typeof getPredictiveAccuracy;
        getRoundMatchUps: typeof getRoundMatchUps;
        getRounds: typeof getRounds;
        getScaledEntries: typeof getScaledEntries;
        getScheduledRoundsDetails: typeof getScheduledRoundsDetails;
        getSchedulingProfileIssues: typeof getSchedulingProfileIssues;
        getSeedsCount: typeof getSeedsCount;
        getStructureSeedAssignments: typeof getStructureSeedAssignments;
        getTeamLineUp: typeof getTeamLineUp;
        getTieFormat: typeof getTieFormat;
        getTournamentIds: typeof getTournamentIds;
        getTournamentInfo: typeof getTournamentInfo;
        getTournamentPenalties: typeof getTournamentPenalties;
        getTournamentPersons: typeof getTournamentPersons;
        getTournamentStructures: typeof getTournamentStructures;
        getTournamentTimeItem: typeof getTournamentTimeItem;
        getVenuesAndCourts: typeof getVenuesAndCourts;
        getVenuesReport: typeof getVenuesReport;
        isValidForQualifying: typeof isValidForQualifying;
        isValidMatchUpFormat: typeof isValidMatchUpFormat;
        matchUpActions: typeof matchUpActions;
        participantScaleItem: typeof participantScaleItem;
        participantScheduledMatchUps: typeof participantScheduledMatchUps;
        positionActions: typeof positionActions;
        tallyParticipantResults: typeof tallyParticipantResults;
        tournamentMatchUps: typeof tournamentMatchUps;
        validateCollectionDefinition: typeof validateCollectionDefinition;
        validateLineUp: typeof validateLineUp;
        validMatchUp: typeof validMatchUp;
        validMatchUps: typeof validMatchUps;
        allPlayoffPositionsFilled: typeof allPlayoffPositionsFilled;
        getCategoryAgeDetails: typeof getCategoryAgeDetails;
        calculateWinCriteria: typeof calculateWinCriteria;
        compareTieFormats: typeof compareTieFormats;
        getMatchUpContextIds: typeof getMatchUpContextIds;
        getScaleValues: typeof getScaleValues;
        getSeedingThresholds: typeof getSeedingThresholds;
        getTimeItem: typeof getTimeItem;
        getValidGroupSizes: typeof getValidGroupSizes;
        isAdHoc: typeof isAdHoc;
        isCompletedStructure: typeof isCompletedStructure;
        roundRobinGroups: {
            getRoundRobinGroupMatchUps: typeof getRoundRobinGroupMatchUps;
            determineRoundNumber: typeof determineRoundNumber;
            drawPositionsHash: typeof drawPositionsHash;
            groupRounds: typeof groupRounds;
        };
        tieFormatGenderValidityCheck: typeof tieFormatGenderValidityCheck;
        validateCategory: typeof validateCategory;
    };
    reportGovernor: {
        getStructureReports: typeof getStructureReports;
        getEntryStatusReports: typeof getEntryStatusReports;
        getParticipantStats: typeof getParticipantStats;
    };
    scheduleGovernor: {
        addMatchUpCourtOrder: typeof addMatchUpCourtOrder;
        addMatchUpEndTime: typeof addMatchUpEndTime;
        addMatchUpOfficial: typeof addMatchUpOfficial;
        addMatchUpResumeTime: typeof addMatchUpResumeTime;
        addMatchUpScheduledDate: typeof addMatchUpScheduledDate;
        addMatchUpScheduledTime: typeof addMatchUpScheduledTime;
        addMatchUpScheduleItems: typeof addMatchUpScheduleItems;
        addMatchUpStartTime: typeof addMatchUpStartTime;
        addMatchUpStopTime: typeof addMatchUpStopTime;
        addPersonRequests: typeof addPersonRequests;
        addSchedulingProfileRound: typeof addSchedulingProfileRound;
        allocateTeamMatchUpCourts: typeof allocateTeamMatchUpCourts;
        assignMatchUpCourt: typeof assignMatchUpCourt;
        assignMatchUpVenue: typeof assignMatchUpVenue;
        bulkRescheduleMatchUps: typeof bulkRescheduleMatchUps;
        bulkScheduleMatchUps: typeof bulkScheduleMatchUps;
        bulkScheduleTournamentMatchUps: typeof bulkScheduleTournamentMatchUps;
        bulkUpdateCourtAssignments: typeof bulkUpdateCourtAssignments;
        calculateScheduleTimes: typeof calculateScheduleTimes;
        clearMatchUpSchedule: typeof clearMatchUpSchedule;
        clearScheduledMatchUps: typeof clearScheduledMatchUps;
        courtGridRows: typeof courtGridRows;
        findCourt: typeof publicFindCourt;
        findMatchUpFormatTiming: typeof findMatchUpFormatTiming;
        findVenue: typeof findVenue;
        generateBookings: typeof generateBookings;
        generateVirtualCourts: typeof generateVirtualCourts;
        getProfileRounds: typeof getProfileRounds;
        getSchedulingProfile: typeof getSchedulingProfile;
        matchUpScheduleChange: typeof matchUpScheduleChange;
        modifyEventMatchUpFormatTiming: typeof modifyEventMatchUpFormatTiming;
        modifyMatchUpFormatTiming: typeof modifyMatchUpFormatTiming;
        modifyPersonRequests: typeof modifyPersonRequests;
        proAutoSchedule: typeof proAutoSchedule;
        proConflicts: typeof proConflicts;
        removeEventMatchUpFormatTiming: typeof removeEventMatchUpFormatTiming;
        removeMatchUpCourtAssignment: typeof removeMatchUpCourtAssignment;
        removePersonRequests: typeof removePersonRequests;
        reorderUpcomingMatchUps: typeof reorderUpcomingMatchUps;
        scheduleMatchUps: typeof scheduleMatchUps;
        scheduleProfileRounds: typeof scheduleProfileRounds;
        setMatchUpDailyLimits: typeof setMatchUpDailyLimits;
        setSchedulingProfile: typeof setSchedulingProfile;
        toggleParticipantCheckInState: typeof toggleParticipantCheckInState;
        validateSchedulingProfile: typeof validateSchedulingProfile;
    };
    scoreGovernor: {
        analyzeSet: typeof analyzeSet;
        checkScoreHasValue: typeof checkScoreHasValue;
        checkSetIsComplete: typeof checkSetIsComplete;
        generateScoreString: typeof generateScoreString;
        generateTieMatchUpScore: typeof generateTieMatchUpScore;
        getSetComplement: (params: {
            lowValue?: string | number | undefined;
            tiebreakAt?: number | undefined;
            isSide1?: boolean | undefined;
            NoAD?: boolean | undefined;
            setTo: number;
        }) => false | number[];
        getTiebreakComplement: (params: {
            lowValue?: string | number | undefined;
            tiebreakNoAd?: boolean | undefined;
            tiebreakTo: number;
            isSide1?: boolean | undefined;
        }) => false | number[];
        isValidMatchUpFormat: typeof isValidMatchUpFormat;
        keyValueScore: typeof keyValueScore;
        parseMatchUpFormat: typeof parse;
        reverseScore: typeof reverseScore;
        stringifyMatchUpFormat: typeof stringify;
        tidyScore: typeof tidyScore;
        updateTieMatchUpScore: typeof updateTieMatchUpScore;
        validateScore: typeof validateScore;
        validateTieFormat: typeof validateTieFormat;
        calculateHistoryScore: typeof calculateHistoryScore;
        setServingSide: typeof setServingSide;
        clearHistory: typeof clearHistory;
        addPoint: typeof addPoint;
        addGame: typeof addGame;
        addShot: typeof addShot;
        addSet: typeof addSet;
        redo: typeof redo;
        undo: typeof undo;
        umo: {
            scoreboard: () => void;
            addPoints: () => void;
            addPoint: () => void;
        };
    };
    tournamentGovernor: {
        addDrawDefinitionExtension: typeof addDrawDefinitionExtension;
        addEventExtension: typeof addEventExtension;
        addEventTimeItem: typeof addEventTimeItem;
        addExtension: typeof addExtension;
        addNotes: typeof addNotes;
        addOnlineResource: typeof addOnlineResource;
        addParticipantExtension: typeof addParticipantExtension;
        addParticipantTimeItem: typeof addParticipantTimeItem;
        addTimeItem: typeof addTimeItem;
        addTournamentExtension: typeof addTournamentExtension;
        addTournamentTimeItem: typeof addTournamentTimeItem;
        getProfileRounds: typeof getProfileRounds;
        removeDrawDefinitionExtension: typeof removeDrawDefinitionExtension;
        removeEventExtension: typeof removeEventExtension;
        removeExtension: typeof removeExtension;
        removeNotes: typeof removeNotes;
        removeParticipantExtension: typeof removeParticipantExtension;
        removeTournamentExtension: typeof removeTournamentExtension;
        setTournamentCategories: typeof setTournamentCategories;
        setTournamentDates: typeof setTournamentDates;
        setTournamentEndDate: typeof setTournamentEndDate;
        setTournamentName: typeof setTournamentName;
        setTournamentNotes: typeof setTournamentNotes;
        setTournamentStartDate: typeof setTournamentStartDate;
        setTournamentStatus: typeof setTournamentStatus;
    };
    utilitiesGovernor: {
        visualizeScheduledMatchUps: typeof visualizeScheduledMatchUps;
        dehydrateMatchUps: typeof dehydrateMatchUps;
        structureSort: typeof structureSort;
        allNumeric: typeof allNumeric;
        attributeFilter: typeof attributeFilter;
        chunkArray: typeof chunkArray;
        chunkByNth: typeof chunkByNth;
        chunkSizeProfile: typeof chunkSizeProfile;
        constantToString: typeof constantToString;
        countValues: typeof countValues;
        createMap: typeof createMap;
        dateTime: {
            addDays: typeof addDays;
            addWeek: typeof addWeek;
            addMinutesToTimeString: typeof addMinutesToTimeString;
            convertTime: typeof convertTime;
            getIsoDateString: typeof getIsoDateString;
            getUTCdateString: (date?: any) => string;
            DateHHMM: typeof DateHHMM;
            extractDate: typeof extractDate;
            extractTime: typeof extractTime;
            formatDate: typeof formatDate;
            getDateByWeek: typeof getDateByWeek;
            isISODateString: typeof isISODateString;
            isDate: typeof isDate;
            isTimeString: typeof isTimeString;
            offsetDate: typeof offsetDate;
            offsetTime: typeof offsetTime;
            sameDay: typeof sameDay;
            timeStringMinutes: typeof timeStringMinutes;
            timeToDate: typeof timeToDate;
            timeUTC: typeof timeUTC;
            validTimeValue: typeof validTimeValue;
            validDateString: RegExp;
            timeValidation: RegExp;
            dateValidation: RegExp;
        };
        definedAttributes: typeof definedAttributes;
        extractAttributes: (accessor: any) => (element: any) => any;
        flattenJSON: typeof flattenJSON;
        generateDateRange: typeof generateDateRange;
        generateHashCode: typeof generateHashCode;
        generateRange: typeof generateRange;
        generateTimeCode: typeof generateTimeCode;
        groupValues: typeof groupValues;
        hasAttributeValues: (a: any) => (o: any) => boolean;
        instanceCount: typeof instanceCount;
        intersection: typeof intersection;
        isConvertableInteger: typeof isConvertableInteger;
        isNumeric: typeof isNumeric;
        isOdd: typeof isOdd;
        isPowerOf2: typeof isPowerOf2;
        JSON2CSV: typeof JSON2CSV;
        makeDeepCopy: typeof makeDeepCopy;
        matchUpSort: typeof matchUpSort;
        nearestPowerOf2: typeof nearestPowerOf2;
        nextPowerOf2: typeof nextPowerOf2;
        noNulls: typeof noNulls;
        noNumeric: typeof noNumeric;
        numericSort: typeof numericSort;
        occurrences: typeof occurrences;
        overlap: typeof overlap;
        randomMember: typeof randomMember;
        randomPop: typeof randomPop;
        shuffleArray: typeof shuffleArray;
        subSort: typeof subSort;
        undefinedToNull: typeof undefinedToNull;
        unique: typeof unique;
        UUID: typeof UUID;
        UUIDS: typeof UUIDS;
    };
    venueGovernor: {
        addCourt: typeof addCourt;
        addCourts: typeof addCourts;
        addVenue: typeof addVenue;
        deleteCourt: typeof deleteCourt;
        deleteVenue: typeof deleteVenue;
        deleteVenues: typeof deleteVenues;
        disableCourts: typeof disableCourts;
        disableVenues: typeof disableVenues;
        enableCourts: typeof enableCourts;
        enableVenues: typeof enableVenues;
        findVenue: typeof publicFindVenue;
        modifyCourt: typeof modifyCourt;
        modifyCourtAvailability: typeof modifyCourtAvailability;
        modifyVenue: typeof modifyVenue;
    };
};

declare const matchUpFormatCode: {
    isValid: typeof isValidMatchUpFormat;
    isValidMatchUpFormat: typeof isValidMatchUpFormat;
    stringify: typeof stringify;
    parse: typeof parse;
};

declare const utilities: {
    visualizeScheduledMatchUps: typeof visualizeScheduledMatchUps;
    dehydrateMatchUps: typeof dehydrateMatchUps;
    structureSort: typeof structureSort;
    allNumeric: typeof allNumeric;
    attributeFilter: typeof attributeFilter;
    chunkArray: typeof chunkArray;
    chunkByNth: typeof chunkByNth;
    chunkSizeProfile: typeof chunkSizeProfile;
    constantToString: typeof constantToString;
    countValues: typeof countValues;
    createMap: typeof createMap;
    dateTime: {
        addDays: typeof addDays;
        addWeek: typeof addWeek;
        addMinutesToTimeString: typeof addMinutesToTimeString;
        convertTime: typeof convertTime;
        getIsoDateString: typeof getIsoDateString;
        getUTCdateString: (date?: any) => string;
        DateHHMM: typeof DateHHMM;
        extractDate: typeof extractDate;
        extractTime: typeof extractTime;
        formatDate: typeof formatDate;
        getDateByWeek: typeof getDateByWeek;
        isISODateString: typeof isISODateString;
        isDate: typeof isDate;
        isTimeString: typeof isTimeString;
        offsetDate: typeof offsetDate;
        offsetTime: typeof offsetTime;
        sameDay: typeof sameDay;
        timeStringMinutes: typeof timeStringMinutes;
        timeToDate: typeof timeToDate;
        timeUTC: typeof timeUTC;
        validTimeValue: typeof validTimeValue;
        validDateString: RegExp;
        timeValidation: RegExp;
        dateValidation: RegExp;
    };
    definedAttributes: typeof definedAttributes;
    extractAttributes: (accessor: any) => (element: any) => any;
    flattenJSON: typeof flattenJSON;
    generateDateRange: typeof generateDateRange;
    generateHashCode: typeof generateHashCode;
    generateRange: typeof generateRange;
    generateTimeCode: typeof generateTimeCode;
    groupValues: typeof groupValues;
    hasAttributeValues: (a: any) => (o: any) => boolean;
    instanceCount: typeof instanceCount;
    intersection: typeof intersection;
    isConvertableInteger: typeof isConvertableInteger;
    isNumeric: typeof isNumeric;
    isOdd: typeof isOdd;
    isPowerOf2: typeof isPowerOf2;
    JSON2CSV: typeof JSON2CSV;
    makeDeepCopy: typeof makeDeepCopy;
    matchUpSort: typeof matchUpSort;
    nearestPowerOf2: typeof nearestPowerOf2;
    nextPowerOf2: typeof nextPowerOf2;
    noNulls: typeof noNulls;
    noNumeric: typeof noNumeric;
    numericSort: typeof numericSort;
    occurrences: typeof occurrences;
    overlap: typeof overlap;
    randomMember: typeof randomMember;
    randomPop: typeof randomPop;
    shuffleArray: typeof shuffleArray;
    subSort: typeof subSort;
    undefinedToNull: typeof undefinedToNull;
    unique: typeof unique;
    UUID: typeof UUID;
    UUIDS: typeof UUIDS;
};

type Notice = {
    topic: string;
    payload: any;
    key?: string;
};
type DevContextType = {
    errors?: boolean | string[];
    params?: boolean | string[];
    result?: boolean | string[];
    exclude?: string[];
    [key: string]: any;
} | boolean;
type ImplemtationGlobalStateTypes = {
    tournamentRecords: TournamentRecords;
    tournamentId?: string | undefined;
    methods: {
        [key: string]: any;
    };
    disableNotifications: boolean;
    subscriptions: any;
    notices: Notice[];
    modified: boolean;
};
declare function setStateProvider(globalStateProvider?: {
    [key: string]: any;
}): {
    success: boolean;
};
declare function createInstanceState(): {
    error: unknown;
    success?: undefined;
} | {
    success: boolean;
    error?: undefined;
};
/**
 * if contextCriteria, check whether all contextCriteria keys values are equivalent with globalState.devContext object
 */
declare function getDevContext(contextCriteria?: {
    [key: string]: any;
}): DevContextType;
declare function timeKeeper(action?: string, timer?: string): any;
declare function setGlobalLog(loggingFx?: any): void;
declare function setDevContext(value?: DevContextType): void;
declare function disableNotifications(): void;
declare function enableNotifications(): void;
type DeepCopyAttributes = {
    threshold?: number;
    stringify?: string[];
    ignore?: string[];
    toJSON?: string[];
};
declare function setDeepCopy(value: boolean, attributes: DeepCopyAttributes): void;
declare function deepCopyEnabled(): {
    threshold?: number | undefined;
    modulate?: any;
    stringify: string[];
    ignore: any;
    toJSON: string[];
    enabled: boolean;
};
declare function setSubscriptions(params: any): any;
declare function setMethods(params?: {
    [key: string]: any;
}): any;
declare function cycleMutationStatus(): any;
declare function addNotice(notice: Notice): any;
type GetNoticesArgs = {
    topic: string;
};
declare function getMethods(): {
    [key: string]: any;
};
declare function getNotices(params: GetNoticesArgs): string[];
type DeleteNoticeArgs = {
    topic?: string;
    key: string;
};
declare function deleteNotice({ key, topic }: DeleteNoticeArgs): any;
declare function deleteNotices(): any;
declare function getTopics(): any;
type CallListenerArgs = {
    notices: Notice[];
    topic: string;
};
declare function callListener(payload: any): Promise<any>;
declare function getTournamentId(): any;
declare function getTournamentRecord(tournamentId: string): any;
declare function getTournamentRecords(): any;
declare function setTournamentRecord(tournamentRecord: ResultType): any;
declare function setTournamentRecords(tournamentRecords: any): any;
declare function setTournamentId(tournamentId?: string): {
    success?: boolean;
    error?: ErrorType;
};
declare function removeTournamentRecord(tournamentId: string): any;
declare function getProvider(): any;
type HandleCaughtErrorArgs = {
    engineName?: string;
    methodName: string;
    params: any;
    err: any;
};
declare function handleCaughtError({ engineName, methodName, params, err, }: HandleCaughtErrorArgs): any;
declare function globalLog(engine: string, log: any): void;

type globalState_CallListenerArgs = CallListenerArgs;
type globalState_DeepCopyAttributes = DeepCopyAttributes;
type globalState_DeleteNoticeArgs = DeleteNoticeArgs;
type globalState_DevContextType = DevContextType;
type globalState_GetNoticesArgs = GetNoticesArgs;
type globalState_HandleCaughtErrorArgs = HandleCaughtErrorArgs;
type globalState_ImplemtationGlobalStateTypes = ImplemtationGlobalStateTypes;
type globalState_Notice = Notice;
declare const globalState_addNotice: typeof addNotice;
declare const globalState_callListener: typeof callListener;
declare const globalState_createInstanceState: typeof createInstanceState;
declare const globalState_cycleMutationStatus: typeof cycleMutationStatus;
declare const globalState_deepCopyEnabled: typeof deepCopyEnabled;
declare const globalState_deleteNotice: typeof deleteNotice;
declare const globalState_deleteNotices: typeof deleteNotices;
declare const globalState_disableNotifications: typeof disableNotifications;
declare const globalState_enableNotifications: typeof enableNotifications;
declare const globalState_getDevContext: typeof getDevContext;
declare const globalState_getMethods: typeof getMethods;
declare const globalState_getNotices: typeof getNotices;
declare const globalState_getProvider: typeof getProvider;
declare const globalState_getTopics: typeof getTopics;
declare const globalState_getTournamentId: typeof getTournamentId;
declare const globalState_getTournamentRecord: typeof getTournamentRecord;
declare const globalState_getTournamentRecords: typeof getTournamentRecords;
declare const globalState_globalLog: typeof globalLog;
declare const globalState_handleCaughtError: typeof handleCaughtError;
declare const globalState_removeTournamentRecord: typeof removeTournamentRecord;
declare const globalState_setDeepCopy: typeof setDeepCopy;
declare const globalState_setDevContext: typeof setDevContext;
declare const globalState_setGlobalLog: typeof setGlobalLog;
declare const globalState_setMethods: typeof setMethods;
declare const globalState_setStateProvider: typeof setStateProvider;
declare const globalState_setSubscriptions: typeof setSubscriptions;
declare const globalState_setTournamentId: typeof setTournamentId;
declare const globalState_setTournamentRecord: typeof setTournamentRecord;
declare const globalState_setTournamentRecords: typeof setTournamentRecords;
declare const globalState_timeKeeper: typeof timeKeeper;
declare namespace globalState {
  export { type globalState_CallListenerArgs as CallListenerArgs, type globalState_DeepCopyAttributes as DeepCopyAttributes, type globalState_DeleteNoticeArgs as DeleteNoticeArgs, type globalState_DevContextType as DevContextType, type globalState_GetNoticesArgs as GetNoticesArgs, type globalState_HandleCaughtErrorArgs as HandleCaughtErrorArgs, type globalState_ImplemtationGlobalStateTypes as ImplemtationGlobalStateTypes, type globalState_Notice as Notice, globalState_addNotice as addNotice, globalState_callListener as callListener, globalState_createInstanceState as createInstanceState, globalState_cycleMutationStatus as cycleMutationStatus, globalState_deepCopyEnabled as deepCopyEnabled, globalState_deleteNotice as deleteNotice, globalState_deleteNotices as deleteNotices, globalState_disableNotifications as disableNotifications, globalState_enableNotifications as enableNotifications, globalState_getDevContext as getDevContext, globalState_getMethods as getMethods, globalState_getNotices as getNotices, globalState_getProvider as getProvider, globalState_getTopics as getTopics, globalState_getTournamentId as getTournamentId, globalState_getTournamentRecord as getTournamentRecord, globalState_getTournamentRecords as getTournamentRecords, globalState_globalLog as globalLog, globalState_handleCaughtError as handleCaughtError, globalState_removeTournamentRecord as removeTournamentRecord, globalState_setDeepCopy as setDeepCopy, globalState_setDevContext as setDevContext, globalState_setGlobalLog as setGlobalLog, globalState_setMethods as setMethods, globalState_setStateProvider as setStateProvider, globalState_setSubscriptions as setSubscriptions, globalState_setTournamentId as setTournamentId, globalState_setTournamentRecord as setTournamentRecord, globalState_setTournamentRecords as setTournamentRecords, globalState_timeKeeper as timeKeeper };
}

declare const forge: {};

declare function asyncEngine(test?: boolean): FactoryEngine & {
    error?: any;
};

declare const askEngine: FactoryEngine;

declare const engine: FactoryEngine;

declare const competitionEngine: FactoryEngine;
declare const tournamentEngine: FactoryEngine;

declare const matchUpEngine: FactoryEngine;

declare const mocksEngine: FactoryEngine;

declare const scaleEngine: FactoryEngine;

declare function countryToFlag(isoCode: string): string;
declare function flagIOC(ioc: string): string;

declare const fixtures: {
    ratingsParameters: {
        ELO: {
            defaultInitialization: number;
            decimalsCount: number;
            range: number[];
            ascending: boolean;
        };
        NTRP: {
            accessors: string[];
            attributes: {
                ustaRatingType: string;
            };
            accessor: string;
            defaultInitialization: number;
            decimalsCount: number;
            ascending: boolean;
            range: number[];
        };
        UTR: {
            defaultInitialization: number;
            accessors: string[];
            accessor: string;
            decimalsCount: number;
            ascending: boolean;
            range: number[];
        };
        WTN: {
            attributes: {
                confidence: {
                    generator: boolean;
                    range: number[];
                };
            };
            accessors: string[];
            defaultInitialization: number;
            accessor: string;
            ascending: boolean;
            decimalsCount: number;
            range: number[];
        };
    };
    matchUpFormats: {
        FORMAT_STANDARD: string;
        FORMAT_STANDARD_NOAD: string;
        FORMAT_ATP_DOUBLES: string;
        FORMAT_SHORT_SETS: string;
        FORMAT_FAST4: string;
        FORMAT_PRO_SET: string;
        FORMAT_COLLEGE_PRO_SET: string;
        TIMED20: string;
    };
    countryToFlag: typeof countryToFlag;
    tieFormats: {
        COLLEGE_D3: {
            collectionDefinitions: {
                collectionName: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
            }[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
        COLLEGE_DEFAULT: {
            collectionDefinitions: ({
                collectionName: string;
                collectionValue: number;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue?: undefined;
            } | {
                collectionName: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
                collectionValue?: undefined;
            })[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
        COLLEGE_JUCO: {
            collectionDefinitions: {
                collectionName: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
            }[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
        DOMINANT_DUO: {
            collectionDefinitions: {
                collectionName: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
            }[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
        DOMINANT_DUO_MIXED: {
            collectionDefinitions: {
                collectionName: string;
                gender: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
            }[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
        LAVER_CUP: {
            collectionDefinitions: {
                collectionGroupNumber: number;
                matchUpType: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpValue: number;
            }[];
            collectionGroups: {
                groupNumber: number;
                groupName: string;
            }[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
        TEAM_DOUBLES_3_AGGREGATION: {
            collectionDefinitions: {
                collectionName: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                scoreValue: number;
            }[];
            tieFormatName: string;
            unrestrictedSelections: boolean;
            winCriteria: {
                aggregateValue: boolean;
            };
        };
        TIME_TENNIS_DUAL: {
            collectionDefinitions: ({
                scoreValue: number;
                matchUpType: string;
                collectionName: string;
                matchUpFormat: string;
                gender: string;
                matchUpCount: number;
                matchUpValue?: undefined;
            } | {
                matchUpValue: number;
                matchUpType: string;
                collectionName: string;
                matchUpFormat: string;
                gender: string;
                matchUpCount: number;
                scoreValue?: undefined;
            })[];
            tieFormatName: string;
            winCriteria: {
                aggregateValue: boolean;
            };
        };
        TIME_TENNIS_PRO_CIRCUIT: {
            collectionDefinitions: ({
                scoreValue: number;
                matchUpType: string;
                collectionName: string;
                matchUpFormat: string;
                gender: string;
                matchUpCount: number;
                matchUpValue?: undefined;
            } | {
                matchUpValue: number;
                matchUpType: string;
                collectionName: string;
                matchUpFormat: string;
                gender: string;
                matchUpCount: number;
                scoreValue?: undefined;
            })[];
            tieFormatName: string;
            winCriteria: {
                aggregateValue: boolean;
            };
        };
        USTA_BREWER_CUP: {
            collectionDefinitions: ({
                category: {
                    ageCategoryCode: string;
                };
                collectionName: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
                collectionGroupNumber?: undefined;
            } | {
                category: {
                    ageCategoryCode: string;
                };
                collectionName: string;
                collectionGroupNumber: number;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
            })[];
            collectionGroups: {
                groupNumber: number;
                groupName: string;
                groupValue: number;
                winCriteria: {
                    valueGoal: number;
                };
            }[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
        USTA_OZAKI_CUP: {
            winCriteria: {
                valueGoal: number;
            };
            tieFormatName: string;
            collectionDefinitions: {
                category: {
                    ageCategoryCode: string;
                };
                matchUpFormat: string;
                collectionName: string;
                matchUpType: string;
                matchUpCount: number;
                matchUpValue: number;
                gender: string;
            }[];
        };
        USTA_COLLEGE: {
            collectionDefinitions: ({
                collectionName: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                collectionValue: number;
                matchUpValue?: undefined;
            } | {
                collectionName: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
                collectionValue?: undefined;
            })[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
        USTA_GOLD_TEAM_CHALLENGE: {
            collectionDefinitions: {
                collectionName: string;
                matchUpFormat: string;
                matchUpType: string;
                matchUpCount: number;
                matchUpValue: number;
                gender: string;
            }[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
        USTA_INTERSECTIONAL: {
            collectionDefinitions: {
                collectionName: string;
                gender: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
            }[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
        USTA_LEVEL_1: {
            collectionDefinitions: {
                collectionName: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
            }[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
        USTA_SECTION_BATTLE: {
            collectionDefinitions: ({
                category: {
                    ageCategoryCode: string;
                };
                collectionName: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
                processCodes?: undefined;
            } | {
                collectionName: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
                processCodes: string[];
                category?: undefined;
            })[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
        USTA_SOUTHERN_LEVEL_5: {
            collectionDefinitions: {
                collectionName: string;
                gender: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
            }[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
        USTA_TOC: {
            collectionDefinitions: {
                collectionName: string;
                gender: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                scoreValue: number;
            }[];
            tieFormatName: string;
            winCriteria: {
                aggregateValue: boolean;
            };
        };
        USTA_WTT_ITT: {
            collectionDefinitions: {
                collectionName: string;
                gender: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                scoreValue: number;
            }[];
            tieFormatName: string;
            winCriteria: {
                aggregateValue: boolean;
            };
        };
        USTA_ZONAL: {
            collectionDefinitions: {
                collectionName: string;
                gender: string;
                matchUpCount: number;
                matchUpFormat: string;
                matchUpType: string;
                matchUpValue: number;
            }[];
            tieFormatName: string;
            winCriteria: {
                valueGoal: number;
            };
        };
    };
    countries: ({
        ioc: string;
        iso2: string;
        iso: string;
        label: string;
        phone: string;
        suggested?: undefined;
    } | {
        ioc: string;
        iso2: string;
        iso: string;
        label: string;
        phone: string;
        suggested: boolean;
    })[];
    policies: {
        POLICY_AVOIDANCE_COUNTRY: {
            avoidance: {
                roundsToSeparate: undefined;
                policyName: string;
                policyAttributes: {
                    key: string;
                }[];
            };
        };
        POLICY_POSITION_ACTIONS_DEFAULT: {
            positionActions: {
                policyName: string;
                enabledStructures: ({
                    stages: string[];
                    stageSequences: number[];
                    enabledActions: never[];
                    disabledActions: never[];
                } | {
                    stages: never[];
                    stageSequences: never[];
                    enabledActions: string[];
                    disabledActions: never[];
                })[];
                disbledStructures: never[];
                otherFlightEntries: boolean;
                activePositionOverrides: never[];
            };
        };
        POLICY_POSITION_ACTIONS_DISABLED: {
            positionActions: {
                policyName: string;
                enabledStructures: boolean;
            };
        };
        POLICY_POSITION_ACTIONS_NO_MOVEMENT: {
            positionActions: {
                policyName: string;
                enabledStructures: {
                    stages: never[];
                    stageSequences: never[];
                    enabledActions: string[];
                    disabledActions: never[];
                }[];
            };
        };
        POLICY_POSITION_ACTIONS_UNRESTRICTED: {
            positionActions: {
                policyName: string;
                enabledStructures: never[];
                otherFlightEntries: boolean;
                disableRoundRestrictions: boolean;
                activePositionOverrides: string[];
            };
        };
        POLICY_PRIVACY_DEFAULT: {
            participant: {
                policyName: string;
                participant: {
                    contacts: boolean;
                    individualParticipants: {
                        onlineResources: boolean;
                        participantName: boolean;
                        participantOtherName: boolean;
                        participantId: boolean;
                        participantRole: boolean;
                        participantStatus: boolean;
                        penalties: boolean;
                        representing: boolean;
                        participantRoleResponsibilities: boolean;
                        participantType: boolean;
                        person: {
                            addresses: boolean;
                            biographicalInformation: boolean;
                            birthDate: boolean;
                            contacts: boolean;
                            nationalityCode: boolean;
                            nativeFamilyName: boolean;
                            nativeGivenName: boolean;
                            onlineResources: boolean;
                            otherNames: boolean;
                            parentOrganisationId: boolean;
                            passportFamilyName: boolean;
                            passportGivenName: boolean;
                            personId: boolean;
                            personOtherIds: boolean;
                            previousNames: boolean;
                            sex: boolean;
                            standardFamilyName: boolean;
                            standardGivenName: boolean;
                            status: boolean;
                            tennisId: boolean;
                            wheelchair: boolean;
                        };
                    };
                    individualParticipantIds: boolean;
                    onlineResources: boolean;
                    participantName: boolean;
                    participantOtherName: boolean;
                    participantId: boolean;
                    participantRole: boolean;
                    participantStatus: boolean;
                    penalties: boolean;
                    representing: boolean;
                    participantRoleResponsibilities: boolean;
                    participantType: boolean;
                    person: {
                        addresses: boolean;
                        biographicalInformation: boolean;
                        birthDate: boolean;
                        contacts: boolean;
                        nationalityCode: boolean;
                        nativeFamilyName: boolean;
                        nativeGivenName: boolean;
                        onlineResources: boolean;
                        otherNames: boolean;
                        parentOrganisationId: boolean;
                        passportFamilyName: boolean;
                        passportGivenName: boolean;
                        personId: boolean;
                        personOtherIds: boolean;
                        previousNames: boolean;
                        sex: boolean;
                        standardFamilyName: boolean;
                        standardGivenName: boolean;
                        status: boolean;
                        tennisId: boolean;
                        wheelchair: boolean;
                    };
                };
            };
        };
        POLICY_ROUND_NAMING_DEFAULT: {
            roundNaming: {
                policyName: string;
                namingConventions: {
                    round: string;
                    pre: string;
                };
                qualifyingFinishMap: {
                    1: string;
                };
                abbreviatedRoundNamingMap: {
                    1: string;
                    2: string;
                    4: string;
                };
                roundNamingMap: {
                    1: string;
                    2: string;
                    4: string;
                };
                affixes: {
                    roundNumber: string;
                    preFeedRound: string;
                    preQualifying: string;
                };
                stageConstants: {
                    MAIN: string;
                    PLAY_OFF: string;
                    QUALIFYING: string;
                    CONSOLATION: string;
                };
            };
        };
        POLICY_SCHEDULING_DEFAULT: {
            scheduling: {
                allowModificationWhenMatchUpsScheduled: {
                    courts: boolean;
                    venues: boolean;
                };
                defaultTimes: {
                    averageTimes: {
                        categoryNames: never[];
                        minutes: {
                            default: number;
                        };
                    }[];
                    recoveryTimes: {
                        minutes: {
                            DOUBLES: number;
                            default: number;
                        };
                    }[];
                };
                defaultDailyLimits: {
                    SINGLES: number;
                    DOUBLES: number;
                    total: number;
                };
                matchUpAverageTimes: {
                    matchUpFormatCodes: string[];
                    averageTimes: ({
                        categoryNames: never[];
                        minutes: {
                            default: number;
                        };
                        categoryTypes?: undefined;
                    } | {
                        categoryTypes: string[];
                        minutes: {
                            default: number;
                        };
                        categoryNames?: undefined;
                    })[];
                }[];
                matchUpRecoveryTimes: ({
                    matchUpFormatCodes: string[];
                    recoveryTimes: {
                        categoryTypes: string[];
                        minutes: {
                            default: number;
                            DOUBLES: number;
                        };
                    }[];
                } | {
                    matchUpFormatCodes: string[];
                    recoveryTimes: {
                        categoryTypes: string[];
                        minutes: {
                            default: number;
                        };
                    }[];
                } | {
                    matchUpFormatCodes: string[];
                    recoveryTimes: {
                        categoryNames: never[];
                        minutes: {
                            default: number;
                        };
                    }[];
                })[];
                matchUpDailyLimits: never[];
            };
        };
        POLICY_SCORING_DEFAULT: {
            scoring: {
                defaultMatchUpFormat: string;
                allowDeletionWithScoresPresent: {
                    drawDefinitions: boolean;
                    structures: boolean;
                };
                requireAllPositionsAssigned: boolean;
                processCodes: {
                    incompleteAssignmentsOnDefault: string[];
                };
                stage: {
                    MAIN: {
                        stageSequence: {
                            1: {
                                requireAllPositionsAssigned: boolean;
                            };
                        };
                    };
                };
            };
        };
        POLICY_SCORING_USTA: {
            scoring: {
                requireAllPositionsAssigned: boolean;
                stage: {
                    MAIN: {
                        stageSequence: {
                            1: {
                                requireAllPositionsAssigned: boolean;
                            };
                        };
                    };
                };
                defaultMatchUpFormat: string;
                matchUpFormats: ({
                    description: string;
                    matchUpFormat: string;
                    categoryNames: never[];
                    categoryTypes: never[];
                } | {
                    description: string;
                    matchUpFormat: string;
                    categoryNames?: undefined;
                    categoryTypes?: undefined;
                })[];
            };
        };
        POLICY_SEEDING_ITF: {
            seeding: {
                seedingProfile: {
                    positioning: string;
                };
                validSeedPositions: {
                    ignore: boolean;
                };
                duplicateSeedNumbers: boolean;
                drawSizeProgression: boolean;
                policyName: string;
                seedsCountThresholds: {
                    drawSize: number;
                    minimumParticipantCount: number;
                    seedsCount: number;
                }[];
            };
        };
        POLICY_SEEDING_DEFAULT: {
            seeding: {
                validSeedPositions: {
                    ignore: boolean;
                };
                duplicateSeedNumbers: boolean;
                drawSizeProgression: boolean;
                seedingProfile: {
                    drawTypes: {
                        ROUND_ROBIN_WITH_PLAYOFF: {
                            positioning: string;
                        };
                        ROUND_ROBIN: {
                            positioning: string;
                        };
                    };
                    positioning: string;
                };
                policyName: string;
                seedsCountThresholds: {
                    drawSize: number;
                    minimumParticipantCount: number;
                    seedsCount: number;
                }[];
            };
        };
    };
    flagIOC: typeof flagIOC;
};

declare const factoryConstants: {
    activeMatchUpStatuses: any[];
    auditConstants: {
        AUTO_SCHEDULING_AUDIT: string;
        DELETE_EVENTS: string;
        DELETE_DRAW_DEFINITIONS: string;
    };
    completedMatchUpStatuses: any[];
    directingMatchUpStatuses: any[];
    drawDefinitionConstants: {
        MAIN: string;
        QUALIFYING: string;
        CONSOLATION: string;
        ITEM: string;
        CONTAINER: string;
        FIRST_MATCHUP: string;
        WINNER: any;
        LOSER: any;
        AD_HOC: string;
        FEED_IN: string;
        FLEX_ROUNDS: string;
        COMPASS: string;
        PLAY_OFF: string;
        OLYMPIC: string;
        KNOCKOUT: string;
        SINGLE_ELIMINATION: string;
        DOUBLE_ELIMINATION: string;
        CURTIS: string;
        FICSF: string;
        FICQF: string;
        FICR16: string;
        MFIC: string;
        VOLUNTARY_CONSOLATION: string;
        FIRST_MATCH_LOSER_CONSOLATION: string;
        FIRST_ROUND_LOSER_CONSOLATION: string;
        MODIFIED_FEED_IN_CHAMPIONSHIP: string;
        FEED_IN_CHAMPIONSHIP_TO_R16: string;
        FEED_IN_CHAMPIONSHIP_TO_QF: string;
        FEED_IN_CHAMPIONSHIP_TO_SF: string;
        FEED_IN_CHAMPIONSHIP: string;
        LUCKY_DRAW: string;
        ROUND_ROBIN_WITH_PLAYOFF: string;
        ROUND_ROBIN: string;
        DECIDER: string;
        BACKDRAW: string;
        COMPASS_ATTRIBUTES: {
            0: {
                name: string;
                abbreviation: string;
            };
            '0-1': {
                name: string;
                abbreviation: string;
            };
            '0-2': {
                name: string;
                abbreviation: string;
            };
            '0-3': {
                name: string;
                abbreviation: string;
            };
            '0-1-1': {
                name: string;
                abbreviation: string;
            };
            '0-1-2': {
                name: string;
                abbreviation: string;
            };
            '0-2-1': {
                name: string;
                abbreviation: string;
            };
            '0-1-1-1': {
                name: string;
                abbreviation: string;
            };
        };
        OLYMPIC_ATTRIBUTES: {
            0: {
                name: string;
                abbreviation: string;
            };
            '0-1': {
                name: string;
                abbreviation: string;
            };
            '0-2': {
                name: string;
                abbreviation: string;
            };
            '0-1-1': {
                name: string;
                abbreviation: string;
            };
        };
        DRAW: any;
        RANDOM: any;
        TOP_DOWN: any;
        BOTTOM_UP: any;
        WATERFALL: string;
        WIN_RATIO: string;
        ROUND_OUTCOME: string;
        MULTI_STRUCTURE_DRAWS: string[];
        generatedDrawTypes: string[];
        stageOrder: {
            QUALIFYING: number;
            MAIN: number;
            PLAY_OFF: number;
            CONSOLATION: number;
            VOLUNTARY_CONSOLATION: number;
        };
        finishOrder: {
            MAIN: number;
            PLAY_OFF: number;
            CONSOLATION: number;
            QUALIFYING: number;
            VOLUNTARY_CONSOLATION: number;
        };
        AGGREGATE_EVENT_STRUCTURES: string;
        FINISHING_POSITIONS: string;
    };
    entryStatusConstants: any;
    errorConditionConstants: {
        ANACHRONISM: {
            message: string;
            code: string;
        };
        CANNOT_CHANGE_WINNING_SIDE: {
            message: string;
            code: string;
        };
        CANNOT_MODIFY_TIEFORMAT: {
            message: string;
            code: string;
        };
        CANNOT_MODIFY_PARTICIPANT_TYPE: {
            message: string;
            code: string;
        };
        CANNOT_REMOVE_MAIN_STRUCTURE: {
            message: string;
            code: string;
        };
        CANNOT_REMOVE_PARTICIPANTS: {
            message: string;
            code: string;
        };
        COURT_EXISTS: {
            message: string;
            code: string;
        };
        COURT_NOT_FOUND: {
            message: string;
            code: string;
        };
        DRAW_DEFINITION_NOT_FOUND: {
            message: string;
            code: string;
        };
        DRAW_ID_EXISTS: {
            message: string;
            code: string;
        };
        DRAW_POSITION_ACTIVE: {
            message: string;
            code: string;
        };
        DRAW_POSITION_ASSIGNED: {
            message: string;
            code: string;
        };
        DRAW_POSITION_NOT_CLEARED: {
            message: string;
            code: string;
        };
        DRAW_POSITION_NOT_FOUND: {
            message: string;
            code: string;
        };
        DRAW_SIZE_MISMATCH: {
            message: string;
            code: string;
        };
        DUPLICATE_VALUE: {
            message: string;
            code: string;
        };
        ENTRY_STATUS_NOT_ALLOWED_FOR_EVENT: {
            message: string;
            code: string;
        };
        ENTRY_STATUS_NOT_ALLOWED_IN_STAGE: {
            message: string;
            code: string;
        };
        EVENT_EXISTS: {
            message: string;
            code: string;
        };
        EVENT_NOT_FOUND: {
            message: string;
            code: string;
        };
        EXISTING_DRAW_DEFINITIONS: {
            message: string;
            code: string;
        };
        EXISTING_END_TIME: {
            message: string;
            code: string;
        };
        EXISTING_FLIGHT: {
            message: string;
            code: string;
        };
        EXISTING_MATCHUP_ID: {
            message: string;
            code: string;
        };
        EXISTING_OUTCOME: {
            message: string;
            code: string;
        };
        EXISTING_PARTICIPANT_DRAW_POSITION_ASSIGNMENT: {
            message: string;
            code: string;
        };
        EXISTING_PARTICIPANT: {
            message: string;
            code: string;
        };
        EXISTING_POLICY_TYPE: {
            message: string;
            code: string;
        };
        EXISTING_PROFILE: {
            message: string;
            code: string;
        };
        EXISTING_ROUND: {
            message: string;
            code: string;
        };
        EXISTING_STAGE: {
            message: string;
            code: string;
        };
        EXISTING_STRUCTURE: {
            message: string;
            code: string;
        };
        INCOMPATIBLE_MATCHUP_STATUS: {
            message: string;
            code: string;
        };
        INCOMPLETE_SOURCE_STRUCTURE: {
            message: string;
            code: string;
        };
        INSUFFICIENT_DRAW_POSITIONS: {
            message: string;
            code: string;
        };
        INVALID_ACTION: {
            message: string;
            code: string;
        };
        INVALID_ASSIGNMENT: {
            message: string;
            code: string;
        };
        INVALID_BOOKINGS: {
            message: string;
            code: string;
        };
        INVALID_CATEGORY: {
            message: string;
            code: string;
        };
        INVALID_COLLECTION_DEFINITION: {
            message: string;
            code: string;
        };
        INVALID_CONFIGURATION: {
            message: string;
            code: string;
        };
        INVALID_DATE_AVAILABILITY: {
            message: string;
            code: string;
        };
        INVALID_DATE: {
            message: string;
            code: string;
        };
        INVALID_DRAW_DEFINITION: {
            message: string;
            code: string;
        };
        INVALID_DRAW_POSITION_FOR_SEEDING: {
            message: string;
            code: string;
        };
        INVALID_DRAW_POSITION: {
            message: string;
            code: string;
        };
        INVALID_DRAW_SIZE: {
            message: string;
            code: string;
        };
        INVALID_END_TIME: {
            message: string;
            code: string;
        };
        INVALID_ENTRIES: {
            message: string;
            code: string;
        };
        INVALID_EVENT_TYPE: {
            message: string;
            code: string;
        };
        INVALID_GAME_SCORES: {
            message: string;
            code: string;
        };
        INVALID_GENDER: {
            message: string;
            code: string;
        };
        INVALID_MATCHUP_FORMAT: {
            message: string;
            code: string;
        };
        INVALID_MATCHUP_STATUS: {
            message: string;
            code: string;
        };
        INVALID_MATCHUP_STATUS_BYE: {
            message: string;
            code: string;
        };
        INVALID_MATCHUP: {
            message: string;
            code: string;
        };
        INVALID_OBJECT: {
            message: string;
            code: string;
        };
        INVALID_PARTICIPANT_ID: {
            message: string;
            code: string;
        };
        INVALID_PARTICIPANT_IDS: {
            message: string;
            code: string;
        };
        INVALID_PARTICIPANT_ROLE: {
            message: string;
            code: string;
        };
        INVALID_PARTICIPANT_SEEDING: {
            message: string;
            code: string;
        };
        INVALID_PARTICIPANT_TYPE: {
            message: string;
            code: string;
        };
        INVALID_PARTICIPANT: {
            message: string;
            code: string;
        };
        INVALID_POLICY_DEFINITION: {
            message: string;
            code: string;
        };
        INVALID_RECORDS: {
            message: string;
            code: string;
        };
        INVALID_SCALE_ITEM: {
            message: string;
            code: string;
        };
        INVALID_SEED_NUMBER: {
            message: string;
            code: string;
        };
        INVALID_SEED_POSITION: {
            message: string;
            code: string;
        };
        INVALID_SET_NUMBER: {
            message: string;
            code: string;
        };
        INVALID_SIDE_NUMBER: {
            message: string;
            code: string;
        };
        INVALID_SCORE: {
            message: string;
            code: string;
        };
        INVALID_STAGE: {
            message: string;
            code: string;
        };
        INVALID_START_TIME: {
            message: string;
            code: string;
        };
        INVALID_STRUCTURE: {
            message: string;
            code: string;
        };
        INVALID_STOP_TIME: {
            message: string;
            code: string;
        };
        INVALID_TIE_FORMAT: {
            message: string;
            code: string;
        };
        INVALID_TIME: {
            message: string;
            code: string;
        };
        INVALID_TIME_ITEM: {
            message: string;
            code: string;
        };
        INVALID_TOURNAMENT_DATES: {
            message: string;
            code: string;
        };
        INVALID_TOURNAMENT_RECORD: {
            message: string;
            code: string;
        };
        INVALID_VALUES: {
            message: string;
            code: string;
        };
        INVALID_WINNING_SIDE: {
            message: string;
            code: string;
        };
        MATCHUP_NOT_FOUND: {
            message: string;
            code: string;
        };
        METHOD_NOT_FOUND: {
            message: string;
            code: string;
        };
        MISSING_ASSIGNMENTS: {
            message: string;
            code: string;
        };
        MISSING_ASYNC_STATE_PROVIDER: {
            message: string;
            code: string;
        };
        MISSING_AVOIDANCE_POLICY: {
            message: string;
            code: string;
        };
        MISSING_COLLECTION_DEFINITION: {
            message: string;
            code: string;
        };
        MISSING_COURT_ID: {
            message: string;
            code: string;
        };
        MISSING_COURTS_INFO: {
            message: string;
            code: string;
        };
        MISSING_DATE_AVAILABILITY: {
            message: string;
            code: string;
        };
        MISSING_DATE: {
            message: string;
            code: string;
        };
        MISSING_DRAW_DEFINITION: {
            message: string;
            code: string;
        };
        MISSING_DRAW_ID: {
            message: string;
            code: string;
        };
        MISSING_DRAW_POSITION: {
            message: string;
            code: string;
        };
        MISSING_DRAW_POSITIONS: {
            message: string;
            code: string;
        };
        MISSING_DRAW_SIZE: {
            message: string;
            code: string;
        };
        MISSING_ENTRIES: {
            message: string;
            code: string;
        };
        MISSING_EVENT: {
            message: string;
            code: string;
        };
        MISSING_MATCHUP_FORMAT: {
            message: string;
            code: string;
        };
        MISSING_MATCHUP_ID: {
            message: string;
            code: string;
        };
        MISSING_MATCHUP_IDS: {
            message: string;
            code: string;
        };
        MISSING_MATCHUP: {
            message: string;
            code: string;
        };
        MISSING_MATCHUPS: {
            message: string;
            code: string;
        };
        MISSING_PARTICIPANT_COUNT: {
            message: string;
            code: string;
        };
        MISSING_PARTICIPANT_ID: {
            message: string;
            code: string;
        };
        MISSING_PARTICIPANT_IDS: {
            message: string;
            code: string;
        };
        MISSING_PARTICIPANT_ROLE: {
            message: string;
            code: string;
        };
        MISSING_PARTICIPANT: {
            message: string;
            code: string;
        };
        MISSING_PARTICIPANTS: {
            message: string;
            code: string;
        };
        MISSING_PENALTY_ID: {
            message: string;
            code: string;
        };
        MISSING_PENALTY_TYPE: {
            message: string;
            code: string;
        };
        MISSING_PERSON_DETAILS: {
            message: string;
            code: string;
        };
        MISSING_POLICY_ATTRIBUTES: {
            message: string;
            code: string;
        };
        MISSING_POLICY_DEFINITION: {
            message: string;
            code: string;
        };
        MISSING_POLICY_TYPE: {
            message: string;
            code: string;
        };
        MISSING_POSITION_ASSIGNMENTS: {
            message: string;
            code: string;
        };
        MISSING_ROUND_NUMBER: {
            message: string;
            code: string;
        };
        MISSING_SCHEDULE: {
            message: string;
            code: string;
        };
        MISSING_SCORING_POLICY: {
            message: string;
            code: string;
        };
        MISSING_SEED_ASSIGNMENTS: {
            message: string;
            code: string;
        };
        MISSING_SEEDCOUNT_THRESHOLDS: {
            message: string;
            code: string;
        };
        MISSING_SEEDING_POLICY: {
            message: string;
            code: string;
        };
        MISSING_SET_NUMBER: {
            message: string;
            code: string;
        };
        MISSING_SET_OBJECT: {
            message: string;
            code: string;
        };
        MISSING_SIDE_NUMBER: {
            message: string;
            code: string;
        };
        MISSING_STAGE: {
            message: string;
            code: string;
        };
        MISSING_STRUCTURE_ID: {
            message: string;
            code: string;
        };
        MISSING_STRUCTURE: {
            message: string;
            code: string;
        };
        MISSING_STRUCTURES: {
            message: string;
            code: string;
        };
        MISSING_TARGET_LINK: {
            message: string;
            code: string;
        };
        MISSING_TIE_FORMAT: {
            message: string;
            code: string;
        };
        MISSING_TIME_ITEM: {
            message: string;
            code: string;
        };
        MISSING_TIME_ITEMS: {
            message: string;
            code: string;
        };
        MISSING_TOURNAMENT_ID: {
            message: string;
            code: string;
        };
        MISSING_TOURNAMENT_RECORD: {
            message: string;
            code: string;
        };
        MISSING_TOURNAMENT_RECORDS: {
            message: string;
            code: string;
        };
        MISSING_VALUE: {
            message: string;
            code: string;
        };
        MISSING_VENUE_ID: {
            message: string;
            code: string;
        };
        MODIFICATIONS_FAILED: {
            message: string;
            code: string;
        };
        NO_CANDIDATES: {
            message: string;
            code: string;
        };
        NO_DRAW_POSITIONS_AVAILABLE_FOR_QUALIFIERS: {
            message: string;
            code: string;
        };
        NO_MODIFICATIONS_APPLIED: {
            message: string;
            code: string;
        };
        NO_STAGE_SPACE_AVAILABLE_FOR_ENTRY_STATUS: {
            message: string;
            code: string;
        };
        NO_PARTICIPANT_REMOVED: {
            message: string;
            code: string;
        };
        NO_VALID_ACTIONS: {
            message: string;
            code: string;
        };
        NO_VALID_ATTRIBUTES: {
            message: string;
            code: string;
        };
        NO_VALID_DATES: {
            message: string;
            code: string;
        };
        NOT_FOUND: {
            message: string;
            code: string;
        };
        NOT_IMPLEMENTED: {
            message: string;
            code: string;
        };
        PARTICIPANT_COUNT_EXCEEDS_DRAW_SIZE: {
            message: string;
            code: string;
        };
        PARTICIPANT_ID_EXISTS: {
            message: string;
            code: string;
        };
        PARTICIPANT_NOT_CHECKED_IN: {
            message: string;
            code: string;
        };
        PARTICIPANT_NOT_FOUND: {
            message: string;
            code: string;
        };
        PARTICIPANT_PAIR_EXISTS: {
            message: string;
            code: string;
        };
        PENALTY_NOT_FOUND: {
            message: string;
            code: string;
        };
        POLICY_NOT_ATTACHED: {
            message: string;
            code: string;
        };
        POLICY_NOT_FOUND: {
            message: string;
            code: string;
        };
        SCHEDULE_NOT_CLEARED: {
            message: string;
            code: string;
        };
        SCHEDULED_MATCHUPS: {
            message: string;
            code: string;
        };
        SCORES_PRESENT: {
            message: string;
            code: string;
        };
        SEEDSCOUNT_GREATER_THAN_DRAW_SIZE: {
            message: string;
            code: string;
        };
        STAGE_SEQUENCE_LIMIT: {
            message: string;
            code: string;
        };
        STRUCTURE_NOT_FOUND: {
            message: string;
            code: string;
        };
        TEAM_NOT_FOUND: {
            message: string;
            code: string;
        };
        UNABLE_TO_ASSIGN_COURT: {
            message: string;
            code: string;
        };
        UNLINKED_STRUCTURES: {
            message: string;
            code: string;
        };
        UNRECOGNIZED_DRAW_TYPE: {
            message: string;
            code: string;
        };
        UNRECOGNIZED_MATCHUP_FORMAT: {
            message: string;
            code: string;
        };
        UNRECOGNIZED_MATCHUP_STATUS: {
            message: string;
            code: string;
        };
        VALUE_UNCHANGED: {
            message: string;
            code: string;
        };
        VENUE_EXISTS: {
            message: string;
            code: string;
        };
    };
    eventConstants: {
        AGE: string;
        BOTH: string;
        DOUBLES: string;
        DOUBLES_EVENT: string;
        RATING: string;
        SINGLES: string;
        SINGLES_EVENT: string;
        TEAM_EVENT: string;
        TEAM: string;
    };
    extensionConstants: {
        ACTIVE_SUSPENSION: string;
        APPLIED_POLICIES: string;
        AUDIT_POSITION_ACTIONS: string;
        CONTEXT: string;
        DELEGATED_OUTCOME: string;
        DISABLED: string;
        DISABLE_LINKS: string;
        DISABLE_AUTO_CALC: string;
        DRAW_DELETIONS: string;
        DRAW_PROFILE: string;
        ENTRY_PROFILE: string;
        EVENT_PROFILE: string;
        EVENT_WITHDRAWAL_REQUESTS: string;
        FLIGHT_PROFILE: string;
        GROUPING_ATTRIBUTE: string;
        LINEUPS: string;
        LINKED_TOURNAMENTS: string;
        MATCHUP_HISTORY: string;
        PARTICIPANT_REPRESENTATIVES: string;
        PERSON_REQUESTS: string;
        RANKING_POINTS: string;
        ROUND_TARGET: string;
        SCHEDULE_LIMITS: string;
        SCHEDULE_TIMING: string;
        SCHEDULING_PROFILE: string;
        STATUS_DETAIL: string;
        SUB_ORDER: string;
        TALLY: string;
        TIE_FORMAT_MODIFICATIONS: string;
        FACTORY: string;
    };
    flightConstants: {
        SPLIT_LEVEL_BASED: string;
        SPLIT_WATERFALL: string;
        SPLIT_SHUTTLE: string;
    };
    genderConstants: {
        ANY: any;
        MALE: any;
        FEMALE: any;
        MIXED: any;
        OTHER: any;
    };
    keyValueConstants: {
        OUTCOMEKEYS: string[];
        SIDE1KEYS: string[];
        SIDE2KEYS: string[];
        MODIFIERS: string[];
        PROMPT: string;
        MOVEUP: string[];
        MOVEDOWN: string[];
        HOTKEYS: string;
    };
    matchUpActionConstants: {
        REPLACE_TEAM_POSITION_METHOD: string;
        ASSIGN_TEAM_POSITION_METHOD: string;
        REMOVE_TEAM_POSITION_METHOD: string;
        REPLACE_PARTICIPANT: string;
        SUBSTITUTION_METHOD: string;
        REMOVE_SUBSTITUTION: string;
        REMOVE_PARTICIPANT: string;
        SCHEDULE_METHOD: string;
        SUBSTITUTION: string;
        SCHEDULE: string;
        PENALTY: string;
        REFEREE: string;
        STATUS: string;
        SCORE: string;
        START: string;
        END: string;
    };
    matchUpStatusConstants: {
        ABANDONED: any;
        AWAITING_RESULT: any;
        BYE: any;
        CANCELLED: any;
        COMPLETED: any;
        DEAD_RUBBER: any;
        DEFAULTED: any;
        DOUBLE_WALKOVER: any;
        DOUBLE_DEFAULT: any;
        IN_PROGRESS: any;
        INCOMPLETE: any;
        NOT_PLAYED: any;
        RETIRED: any;
        SUSPENDED: any;
        TO_BE_PLAYED: any;
        WALKOVER: any;
    };
    matchUpTypes: {
        SINGLES_MATCHUP: string;
        SINGLES: string;
        DOUBLES_MATCHUP: string;
        DOUBLES: string;
        TEAM_MATCHUP: string;
        TEAM: string;
    };
    nonDirectingMatchUpStatuses: any[];
    participantConstants: {
        INDIVIDUAL: string;
        GROUP: string;
        PAIR: string;
        TEAM: string;
        SIGN_IN_STATUS: string;
        SIGNED_OUT: string;
        SIGNED_IN: string;
    };
    participantRoles: {
        ADMINISTRATION: any;
        CAPTAIN: any;
        COACH: any;
        COMPETITOR: any;
        MEDIA: any;
        MEDICAL: any;
        OFFICIAL: any;
        OTHER: any;
        SECURITY: any;
    };
    particicipantsRequiredMatchUpStatuses: any[];
    participantTypes: {
        TEAM_PARTICIPANT: string;
        INDIVIDUAL: string;
        GROUP: string;
        TEAM: string;
        PAIR: string;
    };
    penaltyConstants: {
        COACHING: string;
        BALL_ABUSE: string;
        RACKET_ABUSE: string;
        VERBAL_ABUSE: string;
        PHYSICAL_ABUSE: string;
        INELIGIBILITY: string;
        UNSPORTSMANLIKE_CONDUCT: string;
        PROHIBITED_SUBSTANCE: string;
        DRESS_CODE_VIOLATION: string;
        EQUIMENT_VIOLATION: string;
        LEAVING_THE_COURT: string;
        REFUSAL_TO_PLAY: string;
        FAILURE_TO_COMPLETE: string;
        NO_SHOW: string;
        OTHER: string;
        PUNCTUALITY: string;
        FAILUIRE_TO_SIGN_IN: string;
    };
    policyConstants: {
        readonly POLICY_TYPE_VOLUNTARY_CONSOLATION: "voluntaryConsolation";
        readonly POLICY_TYPE_COMPETITIVE_BANDS: "competitiveBands";
        readonly POLICY_TYPE_ROUND_ROBIN_TALLY: "roundRobinTally";
        readonly POLICY_TYPE_POSITION_ACTIONS: "positionActions";
        readonly POLICY_TYPE_MATCHUP_ACTIONS: "matchUpActions";
        readonly POLICY_TYPE_RANKING_POINTS: "rankingPoints";
        readonly POLICY_TYPE_ROUND_NAMING: "roundNaming";
        readonly POLICY_TYPE_PARTICIPANT: "participant";
        readonly POLICY_TYPE_PROGRESSION: "progression";
        readonly POLICY_TYPE_SCHEDULING: "scheduling";
        readonly POLICY_TYPE_AVOIDANCE: "avoidance";
        readonly POLICY_TYPE_DISPLAY: "display";
        readonly POLICY_TYPE_FEED_IN: "feedIn";
        readonly POLICY_TYPE_SCORING: "scoring";
        readonly POLICY_TYPE_SEEDING: "seeding";
        readonly POLICY_TYPE_AUDIT: "audit";
        readonly POLICY_TYPE_DRAWS: "draws";
    };
    positionActionConstants: {
        MODIFY_PAIR_ASSIGNMENT: string;
        QUALIFYING_PARTICIPANT: string;
        ALTERNATE_PARTICIPANT: string;
        WITHDRAW_PARTICIPANT: string;
        ASSIGN_PARTICIPANT: string;
        LUCKY_PARTICIPANT: string;
        REMOVE_ASSIGNMENT: string;
        SWAP_PARTICIPANTS: string;
        ADD_NICKNAME: string;
        REMOVE_SEED: string;
        ADD_PENALTY: string;
        ASSIGN_BYE: string;
        SEED_VALUE: string;
    };
    ratingConstants: {
        ELO: string;
        NTRP: string;
        TRN: string;
        UTR: string;
        WTN: string;
    };
    recoveryTimeRequiredMatchUpStatuses: any[];
    requestConstants: {
        DO_NOT_SCHEDULE: string;
    };
    resultConstants: {
        SUCCESS: {
            success: boolean;
        };
        ERROR: string;
    };
    scaleConstants: {
        RANKING: string;
        RATING: string;
        SCALE: string;
        SEEDING: string;
    };
    scheduleConstants: {
        SINGLES_DOUBLES: string;
        DOUBLES_SINGLES: string;
        TOTAL: string;
        CONFLICT_MATCHUP_ORDER: string;
        CONFLICT_PARTICIPANTS: string;
        SCHEDULE_ISSUE_IDS: string;
        SCHEDULE_CONFLICT: string;
        SCHEDULE_WARNING: string;
        SCHEDULE_ERROR: string;
        SCHEDULE_ISSUE: string;
        SCHEDULE_STATE: string;
    };
    sortingConstants: {
        ASC: string;
        ASCENDING: string;
        DESC: string;
        DESCENDING: string;
    };
    surfaceConstants: {
        CLAY: string;
        HARD: string;
        GRASS: string;
        CARPET: string;
        ARTIFICIAL: string;
    };
    tieFormatConstants: {
        COLLEGE_D3: string;
        COLLEGE_DEFAULT: string;
        COLLEGE_JUCO: string;
        DOMINANT_DUO: string;
        DOMINANT_DUO_MIXED: string;
        LAVER_CUP: string;
        TEAM_DOUBLES_3_AGGREGATION: string;
        TIME_TENNIS_DUAL: string;
        TIME_TENNIS_PRO_CIRCUIT: string;
        USTA_BREWER_CUP: string;
        USTA_OZAKI_CUP: string;
        USTA_COLLEGE: string;
        USTA_GOLD_TEAM_CHALLENGE: string;
        USTA_INTERSECTIONAL: string;
        USTA_LEVEL_1: string;
        USTA_SECTION_BATTLE: string;
        USTA_SOUTHERN_LEVEL_5: string;
        USTA_TOC: string;
        USTA_WTT_ITT: string;
        USTA_ZONAL: string;
    };
    timeItemConstants: {
        MUTUALLY_EXCLUSIVE_TIME_MODIFIERS: string[];
        AFTER_REST: string;
        ALLOCATE_COURTS: string;
        ASSIGN_COURT: string;
        ASSIGN_OFFICIAL: string;
        ASSIGN_VENUE: string;
        CHECK_IN: string;
        CHECK_OUT: string;
        COMPLETED_DATE: string;
        COURT_ORDER: string;
        ELIGIBILITY: string;
        END_TIME: string;
        FOLLOWED_BY: string;
        MEDICAL: string;
        MODIFICATION: string;
        NEXT_AVAILABLE: string;
        NOT_BEFORE: string;
        OTHER: string;
        PENALTY: string;
        PUBLIC: string;
        PUBLISH: string;
        RANKING: string;
        RATING: string;
        RAIN_DELAY: string;
        REGISTRATION: string;
        RESUME_TIME: string;
        RETRIEVAL: string;
        SCALE: string;
        SCHEDULE: string;
        SCHEDULED_DATE: string;
        SCHEDULED_TIME: string;
        SEEDING: string;
        START_TIME: string;
        STATUS: string;
        STOP_TIME: string;
        SUSPENSION: string;
        TIME_MODIFIERS: string;
        TO_BE_ANNOUNCED: string;
    };
    topicConstants: {
        ADD_DRAW_DEFINITION: string;
        ADD_MATCHUPS: string;
        ADD_PARTICIPANTS: string;
        ADD_SCALE_ITEMS: string;
        ADD_VENUE: string;
        AUDIT: string;
        DELETE_PARTICIPANTS: string;
        DELETE_VENUE: string;
        DELETED_DRAW_IDS: string;
        DELETED_MATCHUP_IDS: string;
        MODIFY_DRAW_DEFINITION: string;
        MODIFY_DRAW_ENTRIES: string;
        MODIFY_EVENT_ENTRIES: string;
        MODIFY_MATCHUP: string;
        MODIFY_PARTICIPANTS: string;
        MODIFY_POSITION_ASSIGNMENTS: string;
        MODIFY_SEED_ASSIGNMENTS: string;
        MODIFY_TOURNAMENT_DETAIL: string;
        MODIFY_VENUE: string;
        MUTATIONS: string;
        PUBLISH_EVENT_SEEDING: string;
        PUBLISH_EVENT: string;
        PUBLISH_ORDER_OF_PLAY: string;
        UNPUBLISH_EVENT_SEEDING: string;
        UNPUBLISH_EVENT: string;
        UNPUBLISH_ORDER_OF_PLAY: string;
        UPDATE_INCONTEXT_MATCHUP: string;
    };
    tournamentConstants: {
        ABANDONED: string;
        ACTIVE: string;
        CANCELLED: string;
        COMPLETED: string;
        IN_PROGRESS: string;
    };
    upcomingMatchUpStatuses: any[];
    validMatchUpStatuses: any[];
    venueConstants: {
        INDOOR: string;
        OUTDOOR: string;
    };
};

declare const drawDefinitionConstants: {
    MAIN: string;
    QUALIFYING: string;
    CONSOLATION: string;
    ITEM: string;
    CONTAINER: string;
    FIRST_MATCHUP: string;
    WINNER: any;
    LOSER: any;
    AD_HOC: string;
    FEED_IN: string;
    FLEX_ROUNDS: string;
    COMPASS: string;
    PLAY_OFF: string;
    OLYMPIC: string;
    KNOCKOUT: string;
    SINGLE_ELIMINATION: string;
    DOUBLE_ELIMINATION: string;
    CURTIS: string;
    FICSF: string;
    FICQF: string;
    FICR16: string;
    MFIC: string;
    VOLUNTARY_CONSOLATION: string;
    FIRST_MATCH_LOSER_CONSOLATION: string;
    FIRST_ROUND_LOSER_CONSOLATION: string;
    MODIFIED_FEED_IN_CHAMPIONSHIP: string;
    FEED_IN_CHAMPIONSHIP_TO_R16: string;
    FEED_IN_CHAMPIONSHIP_TO_QF: string;
    FEED_IN_CHAMPIONSHIP_TO_SF: string;
    FEED_IN_CHAMPIONSHIP: string;
    LUCKY_DRAW: string;
    ROUND_ROBIN_WITH_PLAYOFF: string;
    ROUND_ROBIN: string;
    DECIDER: string;
    BACKDRAW: string;
    COMPASS_ATTRIBUTES: {
        0: {
            name: string;
            abbreviation: string;
        };
        '0-1': {
            name: string;
            abbreviation: string;
        };
        '0-2': {
            name: string;
            abbreviation: string;
        };
        '0-3': {
            name: string;
            abbreviation: string;
        };
        '0-1-1': {
            name: string;
            abbreviation: string;
        };
        '0-1-2': {
            name: string;
            abbreviation: string;
        };
        '0-2-1': {
            name: string;
            abbreviation: string;
        };
        '0-1-1-1': {
            name: string;
            abbreviation: string;
        };
    };
    OLYMPIC_ATTRIBUTES: {
        0: {
            name: string;
            abbreviation: string;
        };
        '0-1': {
            name: string;
            abbreviation: string;
        };
        '0-2': {
            name: string;
            abbreviation: string;
        };
        '0-1-1': {
            name: string;
            abbreviation: string;
        };
    };
    DRAW: any;
    RANDOM: any;
    TOP_DOWN: any;
    BOTTOM_UP: any;
    WATERFALL: string;
    WIN_RATIO: string;
    ROUND_OUTCOME: string;
    MULTI_STRUCTURE_DRAWS: string[];
    generatedDrawTypes: string[];
    stageOrder: {
        QUALIFYING: number;
        MAIN: number;
        PLAY_OFF: number;
        CONSOLATION: number;
        VOLUNTARY_CONSOLATION: number;
    };
    finishOrder: {
        MAIN: number;
        PLAY_OFF: number;
        CONSOLATION: number;
        QUALIFYING: number;
        VOLUNTARY_CONSOLATION: number;
    };
    AGGREGATE_EVENT_STRUCTURES: string;
    FINISHING_POSITIONS: string;
};

declare const entryStatusConstants: any;

declare const flightConstants: {
    SPLIT_LEVEL_BASED: string;
    SPLIT_WATERFALL: string;
    SPLIT_SHUTTLE: string;
};

declare const genderConstants: {
    ANY: any;
    MALE: any;
    FEMALE: any;
    MIXED: any;
    OTHER: any;
};

declare const keyValueConstants: {
    OUTCOMEKEYS: string[];
    SIDE1KEYS: string[];
    SIDE2KEYS: string[];
    MODIFIERS: string[];
    PROMPT: string;
    MOVEUP: string[];
    MOVEDOWN: string[];
    HOTKEYS: string;
};

declare const matchUpActionConstants: {
    REPLACE_TEAM_POSITION_METHOD: string;
    ASSIGN_TEAM_POSITION_METHOD: string;
    REMOVE_TEAM_POSITION_METHOD: string;
    REPLACE_PARTICIPANT: string;
    SUBSTITUTION_METHOD: string;
    REMOVE_SUBSTITUTION: string;
    REMOVE_PARTICIPANT: string;
    SCHEDULE_METHOD: string;
    SUBSTITUTION: string;
    SCHEDULE: string;
    PENALTY: string;
    REFEREE: string;
    STATUS: string;
    SCORE: string;
    START: string;
    END: string;
};

declare const matchUpStatusConstants: {
    ABANDONED: any;
    AWAITING_RESULT: any;
    BYE: any;
    CANCELLED: any;
    COMPLETED: any;
    DEAD_RUBBER: any;
    DEFAULTED: any;
    DOUBLE_WALKOVER: any;
    DOUBLE_DEFAULT: any;
    IN_PROGRESS: any;
    INCOMPLETE: any;
    NOT_PLAYED: any;
    RETIRED: any;
    SUSPENDED: any;
    TO_BE_PLAYED: any;
    WALKOVER: any;
};

declare const matchUpTypes: {
    SINGLES_MATCHUP: string;
    SINGLES: string;
    DOUBLES_MATCHUP: string;
    DOUBLES: string;
    TEAM_MATCHUP: string;
    TEAM: string;
};

declare const participantRoles: {
    ADMINISTRATION: any;
    CAPTAIN: any;
    COACH: any;
    COMPETITOR: any;
    MEDIA: any;
    MEDICAL: any;
    OFFICIAL: any;
    OTHER: any;
    SECURITY: any;
};

declare const penaltyConstants: {
    COACHING: string;
    BALL_ABUSE: string;
    RACKET_ABUSE: string;
    VERBAL_ABUSE: string;
    PHYSICAL_ABUSE: string;
    INELIGIBILITY: string;
    UNSPORTSMANLIKE_CONDUCT: string;
    PROHIBITED_SUBSTANCE: string;
    DRESS_CODE_VIOLATION: string;
    EQUIMENT_VIOLATION: string;
    LEAVING_THE_COURT: string;
    REFUSAL_TO_PLAY: string;
    FAILURE_TO_COMPLETE: string;
    NO_SHOW: string;
    OTHER: string;
    PUNCTUALITY: string;
    FAILUIRE_TO_SIGN_IN: string;
};

declare const positionActionConstants: {
    MODIFY_PAIR_ASSIGNMENT: string;
    QUALIFYING_PARTICIPANT: string;
    ALTERNATE_PARTICIPANT: string;
    WITHDRAW_PARTICIPANT: string;
    ASSIGN_PARTICIPANT: string;
    LUCKY_PARTICIPANT: string;
    REMOVE_ASSIGNMENT: string;
    SWAP_PARTICIPANTS: string;
    ADD_NICKNAME: string;
    REMOVE_SEED: string;
    ADD_PENALTY: string;
    ASSIGN_BYE: string;
    SEED_VALUE: string;
};

declare const resultConstants: {
    SUCCESS: {
        success: boolean;
    };
    ERROR: string;
};

declare const scaleConstants: {
    RANKING: string;
    RATING: string;
    SCALE: string;
    SEEDING: string;
};

declare const surfaceConstants: {
    CLAY: string;
    HARD: string;
    GRASS: string;
    CARPET: string;
    ARTIFICIAL: string;
};

declare const timeItemConstants: {
    MUTUALLY_EXCLUSIVE_TIME_MODIFIERS: string[];
    AFTER_REST: string;
    ALLOCATE_COURTS: string;
    ASSIGN_COURT: string;
    ASSIGN_OFFICIAL: string;
    ASSIGN_VENUE: string;
    CHECK_IN: string;
    CHECK_OUT: string;
    COMPLETED_DATE: string;
    COURT_ORDER: string;
    ELIGIBILITY: string;
    END_TIME: string;
    FOLLOWED_BY: string;
    MEDICAL: string;
    MODIFICATION: string;
    NEXT_AVAILABLE: string;
    NOT_BEFORE: string;
    OTHER: string;
    PENALTY: string;
    PUBLIC: string;
    PUBLISH: string;
    RANKING: string;
    RATING: string;
    RAIN_DELAY: string;
    REGISTRATION: string;
    RESUME_TIME: string;
    RETRIEVAL: string;
    SCALE: string;
    SCHEDULE: string;
    SCHEDULED_DATE: string;
    SCHEDULED_TIME: string;
    SEEDING: string;
    START_TIME: string;
    STATUS: string;
    STOP_TIME: string;
    SUSPENSION: string;
    TIME_MODIFIERS: string;
    TO_BE_ANNOUNCED: string;
};

declare const venueConstants: {
    INDOOR: string;
    OUTDOOR: string;
};

export { askEngine, asyncEngine, competitionEngine, drawDefinitionConstants, entryStatusConstants, errorConditionConstants, eventConstants, factoryConstants, fixtures, flightConstants, forge, genderConstants, globalState, governors, keyValueConstants, matchUpActionConstants, matchUpEngine, matchUpFormatCode, matchUpStatusConstants, matchUpTypes, mocksEngine, participantConstants, participantRoles, participantTypes, penaltyConstants, policyConstants, positionActionConstants, resultConstants, scaleConstants, scaleEngine, surfaceConstants, engine as syncEngine, timeItemConstants, tournamentEngine, utilities, venueConstants, factoryVersion as version };
